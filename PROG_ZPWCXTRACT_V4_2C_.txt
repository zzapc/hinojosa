*&---------------------------------------------------------------------*
*& Report  ZPWCXTRACT_V4_2c
*&---------------------------------------------------------------------*

REPORT ZPWCXTRACT_V4_2c NO STANDARD PAGE HEADING LINE-SIZE 400.

*********************************************************************
* Report PWCXTRACT - SAP-TABLE EXTRACTION PROGRAM
*
* PWCXTRACT is used for extracting system-resident (non-archived) SAP tables into text files in .csv or .acl format.
* The generated output is stored in a directory on the application server.
*
* The report is available in two versions: one for SAP Release 4.6 and one for releases 4.7 and higher.
* The version for releases 4.7 and higher.
*
* In order to run the report, a parameter file must be supplied containing the target selection of SAP tables and fields.
* Moreover, an initial execution of the program in a test environment is strongly recommended.
* Only after successful validation, the program should be transferred to the production system.
*
* More information about how to install and run the program can be found in the documents
* "PwC-Xtract Installation Instructions" and "PwC-Xtract User Manual" respectively.
*
* Note, the text at end of lines  "#EC NOTEXT is to suppress language translation issues
* when evaluating the code using Check -> ABAP Test Cockpit
*
* This report is property of PricewaterhouseCoopers AG WPG and is to be used only for extractions
* within projects being coordinated by representatives of PwC.
* The program has to be removed from all involved systems after the completion of the project.
* It is maintained by the department of Forensic Technology Solutions, PwC Germany.
**********************************************************************

CONSTANTS:

**********************************************************************
* SETTINGS

* default oinput location
*  this is where extract packages will be written
  def_loc_in(60) TYPE c VALUE 'C:\temp\', "#EC NOTEXT

* default output location
*  this is where extract packages will be written
  def_loc_out(60) TYPE c VALUE '/usr/sap/trans/tmp/', "#EC NOTEXT

* default zip option is enabled
* 'X' = enabled, '' = disabled
  def_zip_enable(1) TYPE c VALUE 'X',

* controls the zip size and therefore memory usage requirements
*  size is the limit once exceeded, zip files will be split and memory usage will be reduced again.
*  size is in bytes; e.g. 100000000 = 100mb
  p_cb_max_zip_size TYPE i VALUE 250000000,

**********************************************************************

* Placeholders for former GUI fields that are no longer optional
* Log Output Query
  p_cb_deb(1) TYPE c VALUE 'X',
* Run as Background Job - extracts can take some time to run, run them all as separate background jobs to avoid freezing the user's session for the duration
  p_cb_bgr(1) TYPE c VALUE 'X',
* Remove Newline Characters (Special) - ensures a record is presented as a single row in the output file
  p_cb_soz(1) TYPE c VALUE 'X',
* Estimate Extract Size - causes problems when run as a background job
  p_cb_est(1) TYPE c VALUE '',
* Do Not Run Background Job - testing purposes only
  p_cb_aa1 TYPE c VALUE '',
* Produce Header Definition Files, more information is better than less, always produce
  p_cb_hdr TYPE c VALUE 'X',

* Default values for GUI fields
  gc_max_results TYPE i VALUE 10000,
* BUG FIX 4.1->4.2
* reduced the maximum record count to 100,000 to reduce chance of hitting 2GB limit with BSEG being too large to compress
  gc_max_rec_per_file TYPE i VALUE 100000,
* END OF BUG FIX
* BUG FIX 4.1->4.2
* updated the version number
   gc_version(30) TYPE c VALUE 'PwC Xtract ABAP v4.2c'. "#EC NOTEXT

* END OF BUG FIX


*********************************************************************
* Selection options
**********************************************************************
* Chose input-/upload conditions
SELECTION-SCREEN BEGIN OF SCREEN 100 AS SUBSCREEN.

PARAMETERS:
* Chose file to upload (table and field-definition)
  p_file TYPE rlgrap-filename DEFAULT def_loc_in,

* Limit results to a certain amount
  p_cb_max AS CHECKBOX USER-COMMAND checkbox,
* Define limit-amount
  p_max TYPE i DEFAULT gc_max_results,
***************************************************************************************************************************
** Checkbox Storage local or storage on application server
 c_local RADIOBUTTON GROUP loc1 DEFAULT 'X',
 c_server RADIOBUTTON GROUP loc1.

***************************************************************************************************************************
SELECTION-SCREEN END OF SCREEN 100.


* Chose output conditions
SELECTION-SCREEN BEGIN OF SCREEN 200 AS SUBSCREEN.

PARAMETERS:
* Separator
  p_sep TYPE c DEFAULT ';',

* Limit records per file
  p_cb_rec AS CHECKBOX USER-COMMAND checkbox DEFAULT 'X',
* Define limit
  p_maxrec TYPE i DEFAULT gc_max_rec_per_file,

* ACL
  p_CB_acl RADIOBUTTON GROUP rad1 DEFAULT 'X',
  p_cb_csv RADIOBUTTON GROUP rad1,

* Storage location
  p_lctn(60) TYPE c DEFAULT def_loc_out LOWER CASE.

" BUG FIX 4.0->4.1
" Hint to use the output path defined in ZPWCXTRACT2
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 35(81) op_cmt1.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 35(81) op_cmt2.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 35(81) op_cmt3.
SELECTION-SCREEN END OF LINE.
" END BUG FIX 4.0->4.1

* Should resulting file be zipped?
  PARAMETERS: p_cb_zip AS CHECKBOX USER-COMMAND checkbox DEFAULT def_zip_enable.



SELECTION-SCREEN END OF SCREEN 200.

* Chose output location
SELECTION-SCREEN BEGIN OF SCREEN 400 AS SUBSCREEN.

PARAMETERS:

  t_vers(30) TYPE c DEFAULT gc_version.
SELECTION-SCREEN END OF SCREEN 400.


**********************************************************************
* Tabs for Select Options
**********************************************************************
* First tab
SELECTION-SCREEN BEGIN OF TABBED BLOCK block1 FOR 5 LINES.
SELECTION-SCREEN TAB (30) tab1 USER-COMMAND '' DEFAULT SCREEN 100.
SELECTION-SCREEN END OF BLOCK block1.

* Second tab
SELECTION-SCREEN BEGIN OF TABBED BLOCK block2 FOR 10 LINES.
SELECTION-SCREEN TAB (30) tab2 USER-COMMAND '' DEFAULT SCREEN 200.
SELECTION-SCREEN END OF BLOCK block2.

* fourth tab
SELECTION-SCREEN BEGIN OF TABBED BLOCK block4 FOR 1 LINES.
SELECTION-SCREEN TAB (30) tab4 USER-COMMAND '' DEFAULT SCREEN 400.
SELECTION-SCREEN END OF BLOCK block4.


**********************************************************************
INITIALIZATION.
**********************************************************************
*  SET TITLEBAR 'START'.
  tab1 = '@HE@Table configuration'. "#EC NOTEXT
  tab2 = '@I3@Output configuration'. "#EC NOTEXT
  tab4 = '@I3@Other'. "#EC NOTEXT
  " BUG FIX 4.0->4.1
  " Hint to use the output path defined in ZPWCXTRACT2
  op_cmt1 ='@AH@ The output directory has to be identical or a subfolder of the pysical path'. "#EC NOTEXT
  op_cmt2 ='defined by the logical file PWCXTRACT2. The path has to end with / on unix'. "#EC NOTEXT
  op_cmt3 ='or \ on windows systems.'. "#EC NOTEXT
  " END BUG FIX 4.0->4.1

**********************************************************************
AT SELECTION-SCREEN OUTPUT.
**********************************************************************
  LOOP AT SCREEN.
* Checkbox "Trefferzahl begrenzen" active
    IF p_cb_max = 'X' AND
      (
        screen-name = 'P_MAX' OR screen-name = '%_P_MAX_%_APP_%-TEXT' "#EC NOTEXT
      ).
      IF p_max < 0.
        p_max = p_max * -1.
      ENDIF.
      IF p_max IS INITIAL.
        p_max = gc_max_results.
      ENDIF.
      screen-active = 1.
      screen-invisible = 0.
      MODIFY SCREEN.
    ENDIF.
* Checkbox "Trefferzahl begrenzen" inactive
    IF p_cb_max <> 'X' AND ( screen-name = 'P_MAX' OR screen-name = '%_P_MAX_%_APP_%-TEXT' ). "#EC NOTEXT
      p_max = 0.
      screen-active = 0.
      screen-invisible = 1.
      MODIFY SCREEN.
    ENDIF.
* Checkbox "Max. Belege pro Datei" active
    IF p_cb_rec = 'X' AND ( screen-name = 'P_MAXREC' OR screen-name = '%_P_MAXREC_%_APP_%-TEXT' ). "#EC NOTEXT
      IF p_maxrec < 0.
        p_maxrec = p_maxrec * -1.
      ENDIF.
      IF p_maxrec IS INITIAL.
        p_maxrec = gc_max_rec_per_file.
      ENDIF.
      screen-active = 1.
      screen-invisible = 0.
      MODIFY SCREEN.
    ENDIF.
* Checkbox "Max. Belege pro Datei" inactive
    IF p_cb_rec <> 'X' AND ( screen-name = 'P_MAXREC' OR screen-name = '%_P_MAXREC_%_APP_%-TEXT' ). "#EC NOTEXT
      p_maxrec = 0.
      screen-active = 0.
      screen-invisible = 1.
      MODIFY SCREEN.
    ENDIF.

    IF screen-name = 'T_VERS'.  "#EC NOTEXT
      screen-input = 0.
      MODIFY SCREEN.
    ENDIF.

  ENDLOOP.

**********************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
**********************************************************************
  DATA:
* Table containing selected files
  e_ft TYPE filetable,

* Return value: Number of files or -1 if an error occured
  e_rc TYPE i.

*File dialog for choosing the input file
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title            = 'Open file for import'  "#EC NOTEXT
*      DEFAULT_EXTENSION       = ''
      default_filename        = '*.*'
*      FILE_FILTER             =
*      WITH_ENCODING           =
*     initial_directory       = 'C:\'  "#EC NOTEXT
*      MULTISELECTION          =
    CHANGING
      file_table              = e_ft
      rc                      = e_rc
*      USER_ACTION             =
*      FILE_ENCODING           =
    EXCEPTIONS
      file_open_dialog_failed = 1
      cntl_error              = 2
      OTHERS                  = 5
          .

  IF sy-subrc <> 0.
* In case file could not be found/dialog did not work
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

  ELSE.
* Read file path into variable
    READ TABLE e_ft INTO p_file INDEX 1.
  ENDIF.

**********************************************************************
START-OF-SELECTION.
**********************************************************************

**********************************************************************
* Preparation
**********************************************************************

  DATA: filename TYPE string,
        pre_filename LIKE filename,
        pre_filename_Ohne_Pfad LIKE filename,
        l_hashbase TYPE string,
        l_hash TYPE hash160.

** table for storing log messages
  DATA: logline(400) TYPE c,
        loglines TYPE TABLE OF logline INITIAL SIZE 0.

** table for storing error messages in order to write
** them in the bcg log from the generated report in the end.
  TYPES ty_errline(400) TYPE c.
  DATA: errline TYPE ty_errline,
        errlines TYPE TABLE OF ty_errline INITIAL SIZE 0.

* strtemp is a variable used temporarly
* for converting between int and character
  DATA: strtemp(100) TYPE c,
        strtmp TYPE string,
        strtmp_1 TYPE string,
        strtmp_2 TYPE string,
        year(4) TYPE c,
        month(2) TYPE c,
        day(2) TYPE c,
        hrs(2) TYPE c,
        min(2) TYPE c,
        sec(2) TYPE c,
        f_separator TYPE c.
* Get time parameters for hash values, naming and log file
  GET TIME.
  year  = sy-datum+0(4).
  month = sy-datum+4(2).
  day   = sy-datum+6(2).
  hrs   = sy-uzeit+0(2).
  min   = sy-uzeit+2(2).
  sec   = sy-uzeit+4(2).

* Create a hash value based on system ID, client and timestamp
* as a unique identifier for each extraction run
  CONCATENATE sy-sysid
              '_'
              sy-mandt
              '_'
              year month day
              '_'
              hrs min sec
         INTO l_hashbase.

  CLEAR l_hash.
* Calculate Hash value
  CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR' "#EC NOTEXT
    EXPORTING
     ALG                  = 'MD5'
      DATA                 = l_hashbase
   IMPORTING
     HASH                 = l_hash
   EXCEPTIONS
     UNKNOWN_ALG          = 1
     PARAM_ERROR          = 2
     INTERNAL_ERROR       = 3
     OTHERS               = 4
            .
* If hash value could not be created exit the program with an error message
  IF SY-SUBRC <> 0.
    WRITE 'An error occured while calculating the ID for this data extraction run.'.  "#EC NOTEXT
    IF sy-subrc = 1.
      WRITE 'Error: Unknown hash algorithm'. "#EC NOTEXT
    ELSEIF sy-subrc = 2.
      WRITE 'Error: Unknown/invalid parameter'. "#EC NOTEXT
    ELSEIF sy-subrc = 3.
      WRITE 'Internal error'. "#EC NOTEXT
    ENDIF.
    WRITE 'The following error code was reported: '. "#EC NOTEXT
    WRITE sy-subrc.
    EXIT.
  ENDIF.

  l_hash = l_hash+0(10).

** Validate output file path again logical file name
* need for security reason to avoid Directory Traversals
  DATA l_pathvalid(1) TYPE c.
  PERFORM sub_validate_logical_file_path USING 'ZPWCXTRACT2' p_lctn CHANGING l_pathvalid. "#EC NOTEXT

*   IF validation failed, exit the program.
  IF l_pathvalid <> 'X'.
    WRITE 'Output filepath validation failed.'. "#EC NOTEXT
    EXIT.
  ENDIF.

* Create file name with hash value as prefix/unique ID
  CONCATENATE l_hash '' INTO pre_filename_Ohne_Pfad.

  CONCATENATE p_lctn
              pre_filename_Ohne_Pfad
         INTO pre_filename.

* If the results should not be distributed between different files
* Set p_maxrec to a very high number
  IF p_cb_rec <> 'X'.
    p_maxrec = 100000000.
  ENDIF.

**********************************************************************
* Read input file
**********************************************************************
  IF strlen( p_file ) > 127.
    WRITE 'Input file path is too long. The maximum length of the file path is 127 characters.'. "#EC NOTEXT
    EXIT.
  ENDIF.

  TYPES:  BEGIN OF ty_xls,
      table(50) TYPE c,
      field(50) TYPE c,
      from(50) TYPE c,
      to(50) TYPE c,
    END OF ty_xls.

  TYPES lty_raw_data(4096) TYPE c.
  DATA l_raw_data TYPE STANDARD TABLE OF lty_raw_data.

* Isolate the file extension of the input file. String offset
* depends on position of "." in filename to deal with different
* lengths in file extensions (e.g. XLS vs. XLSX).
  DATA it_xls TYPE STANDARD TABLE OF ty_xls.
  DATA wa_xls TYPE ty_xls.
*  DATA error_text(200) TYPE c.
  DATA filenamelength TYPE i.
  filenamelength = strlen( p_file ).
  DATA srcex(3) TYPE c.
  srcex = ''.
  DATA punktPosition TYPE i.
  punktPosition = filenamelength - 4.
  DATA filenameoffset TYPE i.
  IF p_file+punktPosition(1) = '.'.
    filenameoffset = filenamelength - 3.
  ELSE.
    filenameoffset = filenamelength - 4.
  ENDIF.
  srcex = p_file+filenameoffset.
  TRANSLATE srcex TO UPPER CASE.

** Excel files can only be read in dialog-mode
** because dependent function modules use a GUI function.
** CSV files can be read in dialog as well as in batch mode.
** In batch mode, the file has to be located on the application server.

** Execution also differentiates between location on application server or local
** For local paths, there is no validation, since we cannot access local client machine.

IF c_local = 'X'.
  IF srcex = 'XLS' OR srcex = 'XLSX' OR srcex = 'XLSM'.
      IF sy-batch = 'X'.
        WRITE 'An error occured while reading the input file.'. "#EC NOTEXT
        WRITE 'In Batch mode, the parameter file has to be located on the application server'. "#EC NOTEXT
        EXIT.
      ENDIF.
* Convert Excel file into an internal table
      CALL FUNCTION 'TEXT_CONVERT_XLS_TO_SAP' "#EC NOTEXT
        EXPORTING
          I_TAB_RAW_DATA             = l_raw_data
          I_FILENAME                 = p_file
        TABLES
          I_TAB_CONVERTED_DATA       = it_xls
       EXCEPTIONS
         CONVERSION_FAILED          = 1
         OTHERS                     = 2
                .
      IF SY-SUBRC <> 0.
        WRITE 'Error while reading the input file while converting Excel to SAP table'. "#EC NOTEXT
        IF sy-subrc = 1.
          WRITE 'Conversion failed.'. "#EC NOTEXT
        ENDIF.
        EXIT.
      ENDIF.

    ELSEIF srcex = 'CSV'.

      DATA l_text(800) TYPE c.
      TYPES: BEGIN OF ty_text,
              entry(800) TYPE c,
            END OF ty_text.
      DATA it_text TYPE TABLE OF ty_text.

      CLEAR l_raw_data.
      DATA l_newfilename TYPE string.
      CONCATENATE '' p_file INTO l_newfilename.
* Use GUI Upload function to convert input file into internal table
      CALL FUNCTION 'GUI_UPLOAD' "#EC NOTEXT
        EXPORTING
          FILENAME = l_newfilename
          FILETYPE = 'DAT'
        TABLES
          DATA_TAB = l_raw_data
        EXCEPTIONS
          OTHERS   = 17.
       IF SY-SUBRC <> 0.
         WRITE 'Error while reading the input file while attempting to upload file (csv)'. "#EC NOTEXT
         EXIT.
       ENDIF.
* Separate different columns of csv file
      PERFORM sub_text_convert_csv_to_sap
        USING p_sep l_raw_data p_file
        CHANGING it_xls.

        IF SY-SUBRC <> 0.
          WRITE 'Error while reading the input file while attempting to parse the csv file'. "#EC NOTEXT
          EXIT.
        ENDIF.

      ELSE.
        WRITE 'Error while reading the input file.'. "#EC NOTEXT
        WRITE 'Invalid file format. The following formats are valid: '. "#EC NOTEXT
        WRITE 'XLS'.
        WRITE 'XLSX'.
        WRITE 'CSV'.
        EXIT.
      ENDIF.
ENDIF.

** If a file is located on the application server, OPEN DATASET is used.
** In batch mode, the file has to be located on the application server.
** Encoding default is UTF-8 in Unicode systems (otherwise: non-unicode)

IF c_server = 'X'.
  IF srcex = 'CSV'.
** First, validate file path:
    l_pathvalid = ''.
    PERFORM sub_validate_logical_file_path USING 'ZPWCXTRACT2' p_file CHANGING l_pathvalid.

    IF l_pathvalid <> 'X'.
       WRITE 'Input filepath validation failed.'. "#EC NOTEXT
       EXIT.
    ENDIF.
* Open file for reading
  OPEN DATASET p_file FOR INPUT IN TEXT MODE ENCODING UTF-8.
* Read file by line and write content to internal table
    IF sy-subrc = 0.
      DO.
        READ DATASET p_file INTO l_text.
        IF sy-subrc = 0.
          APPEND l_text To it_text.
        ELSE.
          EXIT.
        ENDIF.
      ENDDO.

      CLOSE DATASET p_file.
* Split csv files into different columns
      LOOP AT it_text INTO l_text.
        CLEAR wa_xls.
        split l_text AT p_sep INTO wa_xls-table wa_xls-field wa_xls-from wa_xls-to.
        APPEND wa_xls TO it_xls.
      ENDLOOP.
    ENDIF.
  ELSE.
    WRITE 'Error while reading the input file.'. "#EC NOTEXT
    WRITE 'Invalid file format. The following formats are valid: '. "#EC NOTEXT
    WRITE 'CSV'.
    EXIT.
  ENDIF.
 ENDIF.


  IF c_local = '' AND c_server = ''.
    WRITE: 'Please select storage location!'. "#EC NOTEXT
    EXIT.
  ENDIF.

***************************************************************************************************************************
***************************************************************************************************************************

  DELETE it_xls WHERE table CP 'Tabellen*'. "#EC NOTEXT
  DELETE it_xls WHERE table CP '*table*'. "#EC NOTEXT

* Translate all tablenames in upper case.
* In SAP all tables are stored Upper case
* -> transformation facilitates comparisons
  LOOP AT it_xls INTO wa_xls.
    TRANSLATE wa_xls-table TO UPPER CASE.
    MODIFY it_xls INDEX sy-tabix FROM wa_xls
         TRANSPORTING table.
  ENDLOOP.

**********************************************************************
* Create header for logfile
**********************************************************************

  CONCATENATE '* PwCXTRACT version: ' gc_version INTO logline.
  APPEND logline TO loglines.
  APPEND '* Property of PricewaterhouseCoopers WPG AG' TO loglines. "#EC NOTEXT
  CONCATENATE 'Data extraction run with ID: ' pre_filename_Ohne_Pfad INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO loglines.
  APPEND 'The ID is based on system ID, client, date and time.' TO loglines. "#EC NOTEXT
  CONCATENATE 'System ID: ' sy-sysid INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO loglines.
  CONCATENATE 'Client: ' sy-mandt INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO loglines.
  CONCATENATE year '/' month '/' day INTO logline.
  CONCATENATE 'Date: ' logline INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO loglines.
  CONCATENATE hrs ':' min INTO logline.
  CONCATENATE 'Time: ' logline INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO loglines.
  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.

* Description about what is included in the log file:
  APPEND 'This logfile includes the following content:' TO loglines. "#EC NOTEXT
  APPEND '1. Content of input file' TO loglines. "#EC NOTEXT
  IF p_cb_est = 'X'.
    APPEND '2. Estimated extracted data volume.' TO loglines. "#EC NOTEXT
    APPEND '3. Processed fields' TO loglines. "#EC NOTEXT
    APPEND '4. Processed tables' TO loglines. "#EC NOTEXT
    APPEND '5. Table of WHERE statements' TO loglines. "#EC NOTEXT
    APPEND '6. Generated extraction report' TO loglines. "#EC NOTEXT
    APPEND '7. Attributes of triggered extraction job' TO loglines. "#EC NOTEXT
    APPEND '8. Overview of input parameters' TO loglines. "#EC NOTEXT
  ELSE.
    APPEND '2. Processed fields' TO loglines. "#EC NOTEXT
    APPEND '3. Processed tables' TO loglines. "#EC NOTEXT
    APPEND '4. Table of WHERE statements' TO loglines. "#EC NOTEXT
    APPEND '5. Generated extraction report' TO loglines. "#EC NOTEXT
    APPEND '6. Attributes of triggered extraction job' TO loglines. "#EC NOTEXT
    APPEND '7. Overview of input parameters' TO loglines. "#EC NOTEXT
  ENDIF.

  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.

**********************************************************************
* Show imported file
**********************************************************************

  IF p_cb_deb = 'X'.
    APPEND 'Input:' TO loglines. "#EC NOTEXT
    LOOP AT it_xls INTO wa_xls.
      strtemp = ''.
      WRITE wa_xls-table(20) TO strtemp(20).
      WRITE wa_xls-field(20) TO strtemp+20(20).
      WRITE wa_xls-from(40) TO strtemp+40(40).
      WRITE wa_xls-to(40) TO strtemp+80(40).
      APPEND strtemp TO loglines.
    ENDLOOP.

    APPEND '' TO loglines.
    APPEND sy-uline TO loglines.
  ENDIF.

**********************************************************************
* Process fields, read metadata, write header files
**********************************************************************

  TYPES: begin of ty_fields,
    TABNAME TYPE TABNAME,
    FIELDNAME TYPE fieldname,
    INTLEN TYPE intlen,
    OUTPUTLEN TYPE outputlen,
    INTTYPE TYPE INTTYPE,
    DECIMALS TYPE DECIMALS,
    FIELDTEXT  TYPE AS4TEXT,
  end of ty_fields.

  DATA it_fields TYPE standard table of ty_fields.
  DATA wa_field TYPE ty_fields.

  TYPES: begin of ty_table,
    TABNAME TYPE TABNAME,
    SUBSELECT(800) TYPE c,
    TABNAMESS1 TYPE TABNAME,
    TABNAMESS2 TYPE TABNAME,
    TABNAMESS3 TYPE TABNAME,
    TABNAMESS4 TYPE TABNAME,
  end of ty_table,
  BEGIN OF ty_fieldStore,
    tabname TYPE TABNAME,
    fieldname TYPE FIELDNAME,
  END OF ty_fieldStore.

  DATA wa_table TYPE ty_table.
  DATA it_tables TYPE standard table of ty_table.
  DATA wa_removeFields TYPE ty_fieldStore.
  DATA it_removeFields TYPE standard table of ty_fieldStore.

  DATA myretfields TYPE TABLE OF DFIES.
  DATA mytab TYPE TABNAME.
  DATA myfield TYPE FIELDNAME.

* Define storage variables for HALO - Metadata
  DATA Topic(300) TYPE c.
  DATA PackagePath(300) TYPE c.
  DATA RequestId(300) TYPE c.
  DATA PublicKey(300) TYPE c.

* Loop once over excel import
  LOOP AT it_xls INTO wa_xls WHERE field <> '@'.
* If * or ALL -> all fields should be used
    IF wa_xls-field = '*' or wa_xls-field = 'ALL'. "#EC NOTEXT
      wa_xls-field = ''.
    ENDIF.

    MOVE wa_xls-table TO mytab.
    MOVE wa_xls-field TO myfield.
* Check for HALO metadata fields
    IF mytab = 'TOPIC'. "#EC NOTEXT
      Topic = myfield.
      wa_removeFields-tabname = mytab.
      wa_removeFields-fieldname = myfield.
      APPEND wa_removeFields TO it_removeFields.
    ENDIF.
    IF mytab = 'PACKAGEPATH'. "#EC NOTEXT
      PackagePath = myfield.
      wa_removeFields-tabname = mytab.
      wa_removeFields-fieldname = myfield.
      APPEND wa_removeFields TO it_removeFields.
    ENDIF.
    IF mytab = 'REQUESTID'. "#EC NOTEXT
      RequestId = myfield.
      wa_removeFields-tabname = mytab.
      wa_removeFields-fieldname = myfield.
      APPEND wa_removeFields TO it_removeFields.
    ENDIF.
    IF mytab = 'PUBLICKEY'. "#EC NOTEXT
      PublicKey = myfield.
      wa_removeFields-tabname = mytab.
      wa_removeFields-fieldname = myfield.
      APPEND wa_removeFields TO it_removeFields.
    ENDIF.

* If the from field contains a #, this field should be removed from the extract.
* The field is stored is a speperate table which is used later for screening the fields.
    IF wa_xls-from = '#'.
      wa_removeFields-tabname = mytab.
      wa_removeFields-fieldname = myfield.
      APPEND wa_removeFields TO it_removeFields.
    ENDIF.

* If field is equal to *,
* it is set to blank
* In this case, the function returns the whole table
    CALL FUNCTION 'DDIF_FIELDINFO_GET' "#EC NOTEXT
      EXPORTING
        TABNAME        = mytab
        FIELDNAME      = myfield
      TABLES
        DFIES_TAB      = myretfields
      EXCEPTIONS
        NOT_FOUND      = 1
        INTERNAL_ERROR = 2
        OTHERS         = 3.

    wa_removeFields-tabname = mytab.
    wa_removeFields-fieldname = myfield.

    IF SY-SUBRC <> 0.
      APPEND 'Error reading metadata for: ' TO errlines. "#EC NOTEXT
      CONCATENATE  'Table: ' mytab INTO errline. "#EC NOTEXT
      APPEND errline TO errlines.
      IF myfield <> ''.
        CONCATENATE 'Field: ' myfield INTO errline. "#EC NOTEXT
        APPEND errline TO errlines.
        APPEND '' TO errlines.
      ENDIF.
* delete tab and field if its not in data dictionary
      APPEND wa_removeFields TO it_removeFields.
      CONTINUE.
    ENDIF.

* It has to be checked if the field has already been read
* If yes, it should not be imported into the it_fields-Tabelle
    DATA schonvorhanden TYPE c.

    DATA wa_retfields TYPE DFIES.
    LOOP AT myretfields INTO wa_retfields.

      schonvorhanden = ''.:

      LOOP AT it_fields INTO wa_field.
      IF wa_field-fieldname = wa_retfields-fieldname
        AND wa_field-tabname = wa_retfields-tabname.
        schonvorhanden = 'X'.
      ENDIF.
    ENDLOOP.

    IF schonvorhanden = ''.
      wa_field-tabname = wa_retfields-tabname.
      wa_field-fieldname = wa_retfields-fieldname.
      wa_field-intlen = wa_retfields-intlen.
      wa_field-outputlen = wa_retfields-outputlen.
      wa_field-inttype = wa_retfields-inttype.
      wa_field-decimals = wa_retfields-decimals.
      wa_field-fieldtext = wa_retfields-fieldtext.
      APPEND wa_field TO it_fields.
    ENDIF.

  ENDLOOP.

* It also has to be checked if the current table has already been
* added to the list of included tables it_tables. If not, is it added.
  DATA bereitsvorhanden TYPE c.
  bereitsvorhanden = ''.

  LOOP AT it_tables INTO wa_table.
    IF wa_table-tabname = mytab.
      bereitsvorhanden = 'X'.
    ENDIF.
  ENDLOOP.

  IF bereitsvorhanden = ''.
    APPEND mytab TO it_tables.
  ENDIF.

ENDLOOP.

* Check now for fields that should be removed
LOOP AT it_removeFields INTO wa_removeFields.
  DELETE it_fields WHERE tabname = wa_removeFields-tabname AND fieldname = wa_removeFields-fieldname.
ENDLOOP.


**********************************************************************
* Create WHERE-Table
**********************************************************************
TYPES: begin of ty_where,
  TABNAME TYPE TABNAME,
  WHERE TYPE PROGTAB,
  FREITEXT(800) TYPE c,
end of ty_where.

DATA it_where TYPE standard table of ty_where.
DATA wa_where TYPE ty_where.

* Loop again over excel import in order to find where clause
LOOP AT it_xls INTO wa_xls.

  " BUG FIX 4.0->4.1
  " Check if wa_xls-to equals carrige return. This should be treated as an empty field.
  DATA: first_char TYPE C,
        first_char_hex(2) TYPE C.
  FIELD-SYMBOLS: <convert_hex> TYPE x.
  first_char = wa_xls-to.
  ASSIGN first_char TO <convert_hex> CASTING TYPE X.
  WRITE <convert_hex> to first_char_hex.

  IF first_char_hex = '0D'. " Carrige return
    CLEAR wa_xls-to.
  ENDIF.
  " END BUG FIX 4.0->4.1

  wa_where-freitext = ''.

* Checks several scenarios which require different handling in the WHERE-clause
* Scenario 1: The column "Value/From" is not empty, but column "To" is empty. Also,
* there is neither a free Selection nor is the field excluded from the selection
* --> The WHERE-clause is not a 'between', but some condition has been defined.
* Therefore, we use the operator from the import
  IF NOT wa_xls-from IS INITIAL
    AND wa_xls-to IS INITIAL
    AND wa_xls-field <> '@'
    AND wa_xls-from <> '#'.

    wa_where-tabname = wa_xls-table.
    CONCATENATE wa_xls-field wa_xls-from INTO wa_where-where
      SEPARATED BY space.
    APPEND wa_where TO it_where.

* Scenario 2: Both the column "Value/From" and "To" contain some text. Also, the
* field is not excluded from the selection.
* --> The WHERE-clause is a 'between'-condition
  ELSEIF NOT wa_xls-from IS INITIAL
    AND  NOT wa_xls-to IS INITIAL
    AND wa_xls-from <> '#'.

    wa_where-tabname = wa_xls-table.
    CONCATENATE '''' wa_xls-from '''' INTO strtemp.

    CONCATENATE wa_xls-field 'between' strtemp 'AND' INTO wa_where-where SEPARATED BY space.

    CONCATENATE '''' wa_xls-to '''' INTO strtemp.

    CONCATENATE wa_where-where strtemp INTO wa_where-where SEPARATED BY space.

    APPEND wa_where TO it_where.

* Scenario 3: The column "Fieldname" contains an "@"-sign
* --> The WHERE-clause is defined by a free selection.
  ELSEIF wa_xls-field = '@'.

    wa_where-tabname = wa_xls-table.
    wa_where-where = wa_xls-from.
    wa_where-freitext = 'X'.

    APPEND wa_where TO it_where.

  ENDIF.

ENDLOOP.

* Check for code injection
DATA moff TYPE i.
LOOP AT it_where INTO wa_where.
  moff = 0.

  SEARCH wa_where-where FOR '.'.

  IF sy-subrc = 0.
    moff = 1.
    WRITE / wa_where-where.
    WRITE / 'Found code injection.'. "#EC NOTEXT
    WRITE / 'The program is aborted.'. "#EC NOTEXT
    EXIT.
  ENDIF.

ENDLOOP.
IF moff > 0.
  RETURN.
ENDIF.

DELETE ADJACENT DUPLICATES FROM it_where.


**********************************************************************
* Check user permissions for reading the database tables
**********************************************************************

DATA query_table TYPE DD02L-TABNAME.
DATA l_index TYPE i.
DATA it_delInd TYPE STANDARD TABLE OF i.

LOOP AT it_tables INTO wa_table.
  query_table = wa_table-tabname.

  CALL FUNCTION 'VIEW_AUTHORITY_CHECK'
    EXPORTING
      view_action                    = 'S'
      view_name                      = query_table
    EXCEPTIONS
      no_authority                   = 2
      no_clientindependent_authority = 2
      no_linedependent_authority     = 2
      OTHERS                         = 1.
* If user doesn't have permission, there will be an entry in the bcg log
* the table is then removed from the list of tables to process
  IF sy-subrc <> 0.
    APPEND sy-tabix TO it_delInd.
    CONCATENATE 'No permission for reading table: ' query_table INTO errline. "#EC NOTEXT
    APPEND errline TO errlines.
  ENDIF.

ENDLOOP.

APPEND '' TO errlines.
*delete tables where user does not have permission from extration
LOOP AT it_delInd INTO l_index.
  DELETE it_tables INDEX l_index.
ENDLOOP.


**********************************************************************
* Set SUBSELECT flag if a table is dependent on another table
**********************************************************************

DATA temppattern TYPE string.

LOOP AT it_where INTO wa_where.
  LOOP AT it_tables INTO wa_table.
    CONCATENATE '*' wa_table-tabname '-*' INTO temppattern.

    IF wa_where-where cp temppattern.
      IF wa_table-tabnamess1 IS INITIAL.
        wa_table-subselect = '1'.
        wa_table-tabnamess1 = wa_where-tabname.
        modify it_tables FROM wa_table.
      ELSE.
        IF wa_table-tabnamess1 <> wa_where-tabname
          AND wa_table-tabnamess2 <> wa_where-tabname
          AND wa_table-tabnamess3 <> wa_where-tabname
          AND wa_table-tabnamess4 <> wa_where-tabname.
          IF wa_table-tabnamess1 <> wa_where-tabname
              AND wa_table-tabnamess2 IS INITIAL.
*            wa_table-subselect = wa_table-subselect + 1.
            wa_table-subselect = '2'.
            wa_table-tabnamess2 = wa_where-tabname.
            modify it_tables FROM wa_table.
          ELSEIF wa_table-tabnamess2 <> wa_where-tabname
              AND wa_table-tabnamess3 IS INITIAL.
*            wa_table-subselect = wa_table-subselect + 1.
            wa_table-subselect = '3'.
            wa_table-tabnamess3 = wa_where-tabname.
            modify it_tables FROM wa_table.
          ELSEIF wa_table-tabnamess3 <> wa_where-tabname
              AND wa_table-tabnamess4 IS INITIAL.
*            wa_table-subselect = wa_table-subselect + 1.
            wa_table-subselect = '4'.
            wa_table-tabnamess4 = wa_where-tabname.
            modify it_tables FROM wa_table.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDLOOP.
ENDLOOP.


**********************************************************************
* Execute estimation of data volume generated by job.
**********************************************************************

IF p_cb_est = 'X'.
* Create separate logfile.
  DATA it_estimation_log TYPE TABLE OF logline INITIAL SIZE 0.

* Create necessary variables.
  DATA lf_condition TYPE string.
  DATA wa_tablename(10) TYPE c.
  DATA it_tablesdone LIKE TABLE OF wa_tablename.
  DATA lf_done(1) TYPE c.
  DATA lf_tablelength TYPE i.
  DATA lf_linelength TYPE i.
  DATA lf_tablesize_max TYPE p DECIMALS 0 VALUE 0.
  DATA lf_tablesize_est TYPE p DECIMALS 0 VALUE 0.
  DATA lf_datavolume_max TYPE p DECIMALS 0 VALUE 0.
  DATA lf_datavolume_est TYPE p DECIMALS 0 VALUE 0.
  DATA lf_temptext(100) TYPE c.
  DATA lf_tempvalue(100) TYPE c.

* Add header for log of volume estimation.
  APPEND 'Estimated data volume of extraction:' TO it_estimation_log. "#EC NOTEXT
  CLEAR logline.
  logline+0 = 'Table'. "#EC NOTEXT
  logline+20 = 'Lines'. "#EC NOTEXT
  logline+40 = 'Bytes per line'. "#EC NOTEXT
  logline+60 = 'Maximum filesize'. "#EC NOTEXT
  logline+90 = 'Expected filesize'. "#EC NOTEXT
  APPEND logline TO it_estimation_log.

* Loop over all tables TO conduct volume estimation
  LOOP AT it_tables INTO wa_table.

* Initialize and reset variables where needed.
    mytab = wa_table-tabname.
    CLEAR lf_done.
    CLEAR lf_condition.
    lf_tablelength = 0.
    lf_tablesize_max = 0.
    lf_tablesize_est = 0.

* Check if current table has already been included in data volume estimation as part of a referential
* join estimation. If it has, the remaining part of the current loop is skipped. This step is done in
* two separate routines (/LOOP/IF & /IF) since the CONTINUE statement only escaped the current loop.
    LOOP AT it_tablesdone INTO wa_tablename.
      IF wa_tablename = mytab.
        lf_done = 'X'.
      ENDIF.
    ENDLOOP.
    IF lf_done = 'X'.
      CONTINUE.
    ENDIF.

* Fill variable lf_condition with WHERE condition for current table.
    LOOP AT it_where INTO wa_where WHERE tabname = mytab.
      IF lf_condition <> '' AND wa_where-freitext = ''.
        CONCATENATE lf_condition 'AND' wa_where-where INTO lf_condition SEPARATED BY space.
      ELSEIF lf_condition = '' OR wa_where-freitext <> ''.
        CONCATENATE lf_condition wa_where-where INTO lf_condition SEPARATED BY space.
      ENDIF.
    ENDLOOP.
    REPLACE ALL OCCURRENCES OF '''''' IN lf_condition WITH ''''.

* Get line count for table. To improve the performance of the data volume estimation,
* several different cases need to be considered.
* The first case is that no join exists from the current table to any other, so the table
* can be handled in isolation.
* The second case is that referential joins of the form BUKRS = CDHDR-BUKRS to the current
* table exist. In this case a queried copy of the table must be stored internally to allow
* queries from other tables. A simple join operator can not be used since some of the tables
* that are routinely extracted are pool tables that do not allow join operations.
* The third case is that the WHERE clause of the current table contains references to other
* tables. In this case, the current table must be queried several times containing values
* from the stored version of the referenced table.
* Case 1: No join.
    IF wa_table-subselect = ''.
      IF lf_condition = ''.
        SELECT COUNT(*) INTO lf_tablelength FROM (mytab).
      ELSE.
        SELECT COUNT(*) INTO lf_tablelength FROM (mytab) WHERE (lf_condition).
      ENDIF.

      PERFORM sub_get_line_length USING mytab it_fields CHANGING lf_linelength.
      lf_tablesize_max = lf_tablelength * lf_linelength.
      PERFORM sub_get_estimated_bytesize USING lf_tablesize_max CHANGING lf_tablesize_est.
      lf_datavolume_max = lf_datavolume_max + lf_tablesize_max.
      lf_datavolume_est = lf_datavolume_est + lf_tablesize_est.
      PERFORM sub_write_volume_info USING mytab lf_tablelength lf_linelength lf_tablesize_max lf_tablesize_est CHANGING logline.
      APPEND logline TO it_estimation_log.
* Add warning in case estimated table size exceeds 1,7GB. 1825361101 = 1,7 * 1024^3
      IF lf_tablesize_est > 1825361101.
        CONCATENATE 'Note: In case the entire table' mytab 'is stored in only one file, the file might be too large for zipping.' INTO logline SEPARATED BY space. "#EC NOTEXT
        APPEND logline TO it_estimation_log.
        APPEND 'Please consider setting a record number limit per file manually.' TO it_estimation_log. "#EC NOTEXT
      ENDIF.

* Case 2: Join exists. Table is referenced from other table.
    ELSE.

* Create required variables
      DATA lf_subselect_count TYPE i.
      DATA lf_sub_tablename TYPE tabname.
      DATA lf_sub_condition_v1 TYPE string.
      DATA lf_sub_condition_v2 TYPE string.
      DATA lf_offset TYPE i.
      DATA lf_line_counter TYPE i.
      DATA ls_tabfield(15) TYPE c.
      DATA wa_tabfields LIKE TABLE OF ls_tabfield.
      DATA ref_tab TYPE REF TO data.
      DATA ref_line TYPE REF TO data.

* Create container for copy of queried main table.
      FIELD-SYMBOLS:  <lt_main_table> TYPE table,
                      <ls_main_line> TYPE any,
                      <ls_var> TYPE any.

      CREATE DATA ref_tab TYPE TABLE OF (mytab).
      ASSIGN ref_tab->* TO <lt_main_table>.
      CREATE DATA ref_line LIKE LINE OF <lt_main_table>.
      ASSIGN ref_line->* TO <ls_main_line>.
      CLEAR ref_tab.
      CLEAR ref_line.

* Initialize counter to loop through all tables with a reference to the current table
      lf_subselect_count = wa_table-subselect.

* Copy queried table into placeholder.
      SELECT * FROM (mytab) INTO TABLE <lt_main_table> WHERE (lf_condition).

* Count length in lines of copied table.
      DESCRIBE TABLE <lt_main_table>.
      lf_tablelength = sy-tfill.
      PERFORM sub_get_line_length USING mytab it_fields CHANGING lf_linelength.
      lf_tablesize_max = lf_tablelength * lf_linelength.
      PERFORM sub_get_estimated_bytesize USING lf_tablesize_max CHANGING lf_tablesize_est.
      lf_datavolume_max = lf_datavolume_max + lf_tablesize_max.
      lf_datavolume_est = lf_datavolume_est + lf_tablesize_est.
      PERFORM sub_write_volume_info USING mytab lf_tablelength lf_linelength lf_tablesize_max lf_tablesize_est CHANGING logline.
      APPEND logline TO it_estimation_log.
* Add warning in case estimated table size exceeds 1,7GB. 1825361101 = 1,7 * 1024^3
      IF lf_tablesize_est > 1825361101.
        CONCATENATE 'Note: In case the entire table' mytab 'is stored in only one file, the file might be too large for zipping.' INTO logline SEPARATED BY space. "#EC NOTEXT
        APPEND logline TO it_estimation_log.
        APPEND 'Please consider setting a record number per file manually.' TO it_estimation_log. "#EC NOTEXT
      ENDIF.

* Case 3: Join exists. Table references other table.
* Loop over all tables that are dependent on the selected main table.
      WHILE lf_subselect_count > 0.

* Clear items in case of remaining data of previous loop iteration.
        lf_tablelength = 0.
        CLEAR wa_tabfields.
        CLEAR ref_tab.
        CLEAR lf_sub_condition_v1.
        CLEAR lf_sub_condition_v2.

* Assign table to treat as sub table in this loop iteration.
        CASE lf_subselect_count.
          WHEN '1'.
            lf_sub_tablename = wa_table-tabnamess1.
          WHEN '2'.
            lf_sub_tablename = wa_table-tabnamess2.
          WHEN '3'.
            lf_sub_tablename = wa_table-tabnamess3.
          WHEN '4'.
            lf_sub_tablename = wa_table-tabnamess4.
        ENDCASE.

* Create search term to identify referenced fields in WHERE clause of sub table
        CONCATENATE mytab '-' INTO lf_temptext.

* Loop through relevant lines of WHERE table
        LOOP AT it_where INTO wa_where WHERE tabname = lf_sub_tablename.
* Identify referenced fields/columns of main table and add the field names to table wa_tabfields
          IF wa_where-where CS lf_temptext.
            lf_offset = sy-fdpos + strlen( lf_temptext ).
            ls_tabfield = wa_where-where+lf_offset.
            APPEND ls_tabfield TO wa_tabfields.
          ENDIF.

* Concatenate all lines of WHERE clause to single string.
          IF lf_sub_condition_v1 <> '' AND wa_where-freitext = ''.
            CONCATENATE lf_sub_condition_v1 'AND' wa_where-where INTO lf_sub_condition_v1 SEPARATED BY space.
          ELSEIF lf_sub_condition_v1 = '' OR wa_where-freitext <> ''.
            CONCATENATE lf_sub_condition_v1 wa_where-where INTO lf_sub_condition_v1 SEPARATED BY space.
          ENDIF.
        ENDLOOP.
        REPLACE ALL OCCURRENCES OF '''''' IN lf_sub_condition_v1 WITH ''''.

* Loop through all lines of copy of referenced main table. Replace the referenced fields in the
* WHERE clause by their actual values for every line in the queried copy of the main table.
* Perform a SELECT COUNT(*) with the appropriate WHERE clause for every line and sum up the line
* count over all COUNT(*) queries.
        LOOP AT <lt_main_table> ASSIGNING <ls_main_line>.
          lf_sub_condition_v2 = lf_sub_condition_v1.
          LOOP AT wa_tabfields INTO ls_tabfield.
            ASSIGN COMPONENT ls_tabfield OF STRUCTURE <ls_main_line> TO <ls_var>.
            CONCATENATE mytab '-' ls_tabfield INTO lf_temptext.
            CONCATENATE '''' <ls_var> '''' INTO lf_tempvalue.
            REPLACE ALL OCCURRENCES OF lf_temptext IN lf_sub_condition_v2 WITH lf_tempvalue.
          ENDLOOP.
          SELECT COUNT(*) FROM (lf_sub_tablename) INTO lf_line_counter WHERE (lf_sub_condition_v2).
          lf_tablelength = lf_tablelength + lf_line_counter.
        ENDLOOP.

* WRITE table length.
        PERFORM sub_get_line_length USING lf_sub_tablename it_fields CHANGING lf_linelength.
        lf_tablesize_max = lf_tablelength * lf_linelength.
        PERFORM sub_get_estimated_bytesize USING lf_tablesize_max CHANGING lf_tablesize_est.
        lf_datavolume_max = lf_datavolume_max + lf_tablesize_max.
        lf_datavolume_est = lf_datavolume_est + lf_tablesize_est.
        PERFORM sub_write_volume_info USING lf_sub_tablename lf_tablelength lf_linelength lf_tablesize_max lf_tablesize_est CHANGING logline.
        APPEND logline TO it_estimation_log.
* Add warning in case estimated table size exceeds 1,7GB. 1825361101 = 1,7 * 1024^3
        IF lf_tablesize_est > 1825361101.
          CONCATENATE 'Note: In case the entire table' mytab 'is stored in only one file, the file might be too large for zipping.' INTO logline SEPARATED BY space. "#EC NOTEXT
          APPEND logline TO it_estimation_log.
          APPEND 'Please consider setting a record number limit per file manually.' TO it_estimation_log. "#EC NOTEXT
        ENDIF.

* Mark handled sub table as already done.
        APPEND lf_sub_tablename TO it_tablesdone.

* Decrease counter so next table with subselect clause can be handled.
        lf_subselect_count = lf_subselect_count - 1.
      ENDWHILE.
    ENDIF.
  ENDLOOP.

* Write overall information about estimated data volume to logfile.
  APPEND '' TO it_estimation_log.
  PERFORM sub_convert_bytes_to_unit USING lf_datavolume_max CHANGING logline.
  CONCATENATE 'Total maximum filesize:' logline INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO it_estimation_log.
  PERFORM sub_convert_bytes_to_unit USING lf_datavolume_est CHANGING logline.
  CONCATENATE 'Total estimated filesize:' logline INTO logline SEPARATED BY space. "#EC NOTEXT
  APPEND logline TO it_estimation_log.

* If required, also add information about estimated data volume of zip archive to logfile.
  IF p_cb_zip = 'X'.
    DATA lf_datavolume_zip TYPE p DECIMALS 0 VALUE 0.
    PERFORM sub_get_estimated_zipsize USING lf_datavolume_est CHANGING lf_datavolume_zip.
    PERFORM sub_convert_bytes_to_unit USING lf_datavolume_zip CHANGING logline.
    CONCATENATE 'Estimated size of zip file:' logline INTO logline SEPARATED BY space. "#EC NOTEXT
    APPEND logline TO it_estimation_log.
  ENDIF.

**********************************************************************
* Display estimation of data volume generated by job.
**********************************************************************

* Create and open file for data volume estimation.
  CONCATENATE pre_filename '_datavolume_estimation.txt' INTO lf_temptext. "#EC NOTEXT
  OPEN DATASET lf_temptext FOR APPENDING IN TEXT MODE ENCODING UTF-8 IGNORING CONVERSION ERRORS.

* Write file header to volume estimation file.
  CONCATENATE '* PwCXTRACT version: ' gc_version INTO logline. "#EC NOTEXT
  TRANSFER logline TO lf_temptext.
  TRANSFER '* Property of PricewaterhouseCoopers WPG AG' TO lf_temptext. "#EC NOTEXT
  CONCATENATE 'Data volume estimation run for ID: ' pre_filename_Ohne_Pfad INTO logline SEPARATED BY space. "#EC NOTEXT
  TRANSFER logline TO lf_temptext.
  TRANSFER 'The ID is based on system ID, client, date and time.' TO lf_temptext. "#EC NOTEXT
  TRANSFER '' TO lf_temptext.
  TRANSFER 'This file includes the following content:' TO lf_temptext. "#EC NOTEXT
  TRANSFER '1. Estimation of generated data volume for each extracted table' TO lf_temptext. "#EC NOTEXT
  TRANSFER '2. Estimation of generated data volume overall' TO lf_temptext. "#EC NOTEXT
  TRANSFER '' TO lf_temptext.
  TRANSFER sy-uline TO lf_temptext.

* Write result of estimation process to separate file on application server and log.
  LOOP AT it_estimation_log INTO logline.
    APPEND logline TO loglines.
    TRANSFER logline TO lf_temptext.
  ENDLOOP.

* Close file.
  CLOSE DATASET lf_temptext.

  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.

ENDIF.

**********************************************************************
* Show processed fields and tables
**********************************************************************

IF p_cb_deb = 'X'.
  APPEND 'Processed fields:' TO loglines. "#EC NOTEXT
  LOOP AT it_fields INTO wa_field.
    APPEND wa_field TO loglines.
  ENDLOOP.
  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.

  APPEND 'Processed tables:' TO loglines. "#EC NOTEXT
  LOOP AT it_tables INTO wa_table.
    CONCATENATE wa_table-tabname wa_table-subselect
      wa_table-tabnamess1 wa_table-tabnamess2
      wa_table-tabnamess3 wa_table-tabnamess4
      INTO logline SEPARATED BY '     '.
    APPEND logline TO loglines.
  ENDLOOP.
  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.
ENDIF.

**********************************************************************
* Show processed WHERE-Table
**********************************************************************

IF p_cb_deb = 'X'.
  APPEND 'Where table:' TO loglines. "#EC NOTEXT
  LOOP AT it_where INTO wa_where.
    APPEND wa_where TO loglines.
  ENDLOOP.
  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.
ENDIF.

**********************************************************************
* Check for length of path including tablenames
**********************************************************************
DATA: tablename_length TYPE i,
      output_path_length TYPE i,
      gesamtlaenge TYPE i.

output_path_length = strlen( pre_filename ).

LOOP AT it_tables INTO wa_table.
  tablename_length = strlen( wa_table-tabname ).
  gesamtlaenge = tablename_length + output_path_length + 7.
  IF gesamtlaenge > 200 .
    WRITE 'Output path is too long.'. "#EC NOTEXT
    WRITE 'Error is caused by table '. "#EC NOTEXT
    WRITE wa_table-tabname.
    WRITE 'Remove table or shorten output path.'. "#EC NOTEXT
    EXIT.
  ENDIF.
ENDLOOP.

**********************************************************************
* Check if output path exists
**********************************************************************

DATA mybcglog_1(256) TYPE c.
CONCATENATE pre_filename '_bcglog.txt' INTO mybcglog_1.

OPEN DATASET mybcglog_1 FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.

IF sy-subrc <> 0.
  WRITE 'Cannot write to output path.'. "#EC NOTEXT
  WRITE 'Please verify that the path exists and that you have write permission.'. "#EC NOTEXT
  EXIT.
ENDIF.

***********************************************************************
** Generate Report
***********************************************************************
DATA progline TYPE string.
DATA myprog LIKE TABLE OF progline.

DATA progname LIKE SY-REPID.
CONCATENATE 'ZPWCXTRACT_GEN_' pre_filename_Ohne_Pfad INTO progname. "#EC NOTEXT
DATA tempcounter TYPE i.
DATA subselectzumachen TYPE c.
DATA tabnamess LIKE wa_table-tabname.
DATA max_line_length TYPE i.
DATA max_fragment_length TYPE i.
DATA max_fragment_length_tmp TYPE i.
DATA fileextension(3) TYPE c.

IF p_CB_acl = 'X'.
  fileextension = 'fil'.
ELSE.
  fileextension = 'csv'.
ENDIF.

* Kopfteil des Programms
APPEND '*&----------------------------*' TO myprog.
APPEND '*& auto generated *' TO myprog. "#EC NOTEXT
APPEND '*&----------------------------*' TO myprog.
CONCATENATE 'REPORT' progname '.' INTO progline SEPARATED BY space. "#EC NOTEXT
APPEND progline TO myprog.
APPEND '' TO myprog.

* Initialisierung von Variablen
APPEND 'DATA fragment({MAX_FRAGMENT_LENGTH}) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA line({MAX_LINE_LENGTH}) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA separator TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA filename TYPE string.' TO myprog. "#EC NOTEXT
APPEND 'DATA strtemp(256) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA tempstring(256) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA logline TYPE string.' TO myprog. "#EC NOTEXT
APPEND 'DATA loglines TYPE logline OCCURS 0 WITH HEADER LINE.' TO myprog. "#EC NOTEXT
APPEND 'DATA mybcglog TYPE string.' TO myprog. "#EC NOTEXT
APPEND 'DATA query_table TYPE DD02L-TABNAME.' TO myprog. "#EC NOTEXT
APPEND '' TO myprog.

* If special characters should be deleted, create placeholders for relevant character
* for use in REPLACE ALL OCCURRENCES OF x.
IF p_cb_soz = 'X'.
  APPEND 'DATA CR_LF(2) TYPE c.' TO myprog. "#EC NOTEXT
  APPEND 'DATA CR(1) TYPE c.' TO myprog. "#EC NOTEXT
  APPEND 'DATA LF(1) TYPE c.' TO myprog. "#EC NOTEXT
  APPEND 'CR_LF = CL_ABAP_CHAR_UTILITIES=>CR_LF.' TO myprog. "#EC NOTEXT
  APPEND 'CR = CR_LF+0(1).' TO myprog. "#EC NOTEXT
  APPEND 'LF = CL_ABAP_CHAR_UTILITIES=>NEWLINE.' TO myprog. "#EC NOTEXT
ENDIF.

APPEND '' TO myprog.

* If needed, add specific variables for creating a .zip archive.
IF p_cb_zip = 'X'.
  APPEND 'DATA mo_zip_tool TYPE REF TO cl_abap_zip.' TO myprog. "#EC NOTEXT

* The subroutine addToZip requires input of type string, therefore a second temporary text variable
* is needed (the first being tempstring of type c).
  APPEND 'DATA lf_string_path TYPE string.' TO myprog. "#EC NOTEXT
  APPEND 'DATA gf_current_zipsize TYPE i.' TO myprog. "#EC NOTEXT
  APPEND 'DATA gf_conent_size TYPE i.' TO myprog. "#EC NOTEXT
  APPEND 'DATA gf_zipfile_counter TYPE i VALUE 1.' TO myprog. "#EC NOTEXT
  strtemp = p_cb_max_zip_size.
  CONDENSE strtemp NO-GAPS.
  CONCATENATE 'DATA p_cb_max_zip_size TYPE i VALUE ' strtemp '.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND '' TO myprog.

* Zip tool is initialized.
  APPEND 'CREATE OBJECT mo_zip_tool.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog.
ENDIF.

* Separator for extraction job is set.
CONCATENATE 'separator = ''' p_sep '''.' INTO progline. "#EC NOTEXT
APPEND progline TO myprog.
APPEND '' TO myprog.

* Open file for protocol
CONCATENATE  'mybcglog = ''' pre_filename '_bcglog.txt''.' INTO progline. "#EC NOTEXT
APPEND progline TO myprog.
APPEND 'OPEN DATASET mybcglog FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.' TO myprog. "#EC NOTEXT
APPEND '' TO myprog.

CONCATENATE '* PwCXTRACT version: ' gc_version INTO progline. "#EC NOTEXT
CONCATENATE 'PERFORM schreibeprotokoll USING ''' progline '''.' INTO progline. "#EC NOTEXT
APPEND progline TO myprog.
APPEND 'PERFORM schreibeprotokoll USING ''* Property of PricewaterhouseCoopers WPG AG''.' TO myprog. "#EC NOTEXT
CONCATENATE 'Background job for ID:' pre_filename_Ohne_Pfad INTO progline SEPARATED BY space. "#EC NOTEXT
CONCATENATE 'PERFORM schreibeprotokoll USING ''' progline '''.' INTO progline. "#EC NOTEXT
APPEND progline TO myprog.
APPEND 'PERFORM schreibeprotokoll USING ''The ID is based on system ID, client, date and time.''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING sy-uline.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''This logfile contains:''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''1. List of all handled files along with status updates''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''2. Log of errors which occured during execution''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING sy-uline.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''Open log''.' TO myprog. "#EC NOTEXT


* Add the datetime the extract started
APPEND '' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
APPEND 'DATA ts1 TYPE timestamp.' TO myprog. "#EC NOTEXT
APPEND 'GET TIME STAMP FIELD ts1.' TO myprog. "#EC NOTEXT
APPEND 'strtemp = ts1.' TO myprog. "#EC NOTEXT
APPEND 'CONDENSE strtemp.' TO myprog. "#EC NOTEXT
APPEND 'CONCATENATE ''Start time:'' strtemp INTO strtemp SEPARATED BY space.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING strtemp.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT


LOOP AT it_tables INTO mytab.

* Another authority check for reading each table
* Check needed as the code could potentially stay in the system
* In case it is executed out of context, there is another authority check
* The program ends as soon as it doesn't have authority for at least one table
  CONCATENATE 'query_table = ''' mytab '''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.

  APPEND 'CALL FUNCTION ''VIEW_AUTHORITY_CHECK'' ' TO myprog. "#EC NOTEXT
  APPEND 'EXPORTING' TO myprog. "#EC NOTEXT
  APPEND 'view_action                    = ''S''' TO myprog. "#EC NOTEXT
  APPEND 'view_name                      = query_table' TO myprog. "#EC NOTEXT
  APPEND ' EXCEPTIONS' TO myprog. "#EC NOTEXT
  APPEND ' OTHERS                         = 1.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog.
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'WRITE ''No permission for reading tables.''.' TO myprog. "#EC NOTEXT
  APPEND 'EXIT.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

  CONCATENATE 'TABLES' mytab '.' INTO progline SEPARATED BY space.
  APPEND progline TO myprog.
ENDLOOP.

APPEND '' TO myprog.
APPEND '' TO myprog.

DATA filenamevariable(200) TYPE c.
DATA chunkcountervariable(200) TYPE c.
DATA countperchunkvariable(200) TYPE c.

* Loop over tables for opening the files
* For each table, one file is opened
LOOP AT it_tables INTO mytab.

* Variable for "Anzahl Zeilen pro Chunk"
  CONCATENATE 'count_' mytab INTO countperchunkvariable. "#EC NOTEXT
  CONCATENATE 'DATA' countperchunkvariable 'TYPE i.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE countperchunkvariable '= 0.' INTO progline SEPARATED BY space.
  APPEND progline TO myprog.

* Variable for Chunk-Counter (Filename suffix)
  CONCATENATE 'chunkcounter_' mytab INTO chunkcountervariable. "#EC NOTEXT
  CONCATENATE 'DATA' chunkcountervariable 'TYPE i.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE chunkcountervariable '= 1.' INTO progline SEPARATED BY space.
  APPEND progline TO myprog.

* Variable for file (filenamevariable)
  CONCATENATE pre_filename '_' mytab '_1' '.' fileextension INTO filename.
  CONCATENATE 'file_' mytab INTO filenamevariable. "#EC NOTEXT

  CONCATENATE 'DATA' filenamevariable 'TYPE string.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

* Open file
  CONCATENATE filenamevariable ' = ''' filename '''.' INTO progline.
  APPEND progline TO myprog.
  CONCATENATE 'OPEN DATASET' filenamevariable 'FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'line = ''''.' TO myprog. "#EC NOTEXT

* Add headers in csv
  IF p_CB_acl <> 'X'.

    DATA mycounter TYPE i.
    mycounter = 0.

    LOOP AT it_fields INTO wa_field WHERE tabname = mytab.

      IF mycounter > 0.
        CONCATENATE '''' p_sep  '''' INTO progline.
        CONCATENATE 'CONCATENATE line ' progline ' INTO line.' INTO progline SEPARATED BY space. "#EC NOTEXT
        APPEND progline TO myprog.
      ENDIF.

      CONCATENATE 'CONCATENATE line ''"'' INTO ' "#EC NOTEXT
        '  line.' INTO progline SEPARATED BY space. "#EC NOTEXT
      APPEND progline TO myprog.

      CONCATENATE '''' wa_field-fieldname '''' INTO progline.
      CONCATENATE 'CONCATENATE line ' progline ' INTO ' "#EC NOTEXT
        '  line.' INTO progline SEPARATED BY space. "#EC NOTEXT
      APPEND progline TO myprog.


      CONCATENATE 'CONCATENATE line ''"'' INTO ' "#EC NOTEXT
        '  line.' INTO progline SEPARATED BY space. "#EC NOTEXT
      APPEND progline TO myprog.

      mycounter = mycounter + 1.

    ENDLOOP.

    CONCATENATE 'TRANSFER line TO ' filenamevariable '.' "#EC NOTEXT
      INTO progline SEPARATED BY space.
    APPEND progline TO myprog.

  ENDIF.

* Mark file opening in protocol.
  APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
  CONCATENATE 'PERFORM schreibeprotokoll USING ''Opening file ' filename '''.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  APPEND '' TO myprog.

ENDLOOP.


* Loop over tables in it_tables for select and open files
LOOP AT it_tables INTO wa_table.
  mytab = wa_table-tabname.

  APPEND '' TO myprog.

* Start select statement
  APPEND 'SELECT * FROM' TO myprog.
  APPEND mytab TO myprog.

* In case of size limitation:
  IF p_cb_max = 'X'.
    DATA mytempchar(10) TYPE c.
    WRITE p_max TO mytempchar NO-GROUPING.
    CONCATENATE 'UP TO' mytempchar 'ROWS'
      INTO progline SEPARATED BY space.
    APPEND progline TO myprog.
  ENDIF.

* Generate Where Statement from it_where
  tempcounter = 0.
  LOOP AT it_where INTO wa_where WHERE tabname = mytab.
    IF tempcounter > 0.
      IF wa_where-freitext = ''.
        CONCATENATE 'AND' wa_where-where INTO wa_where-where SEPARATED BY space.
      ENDIF.
    ELSE.
      APPEND 'WHERE' TO myprog.
    ENDIF.
    MOVE wa_where-where TO progline.
    APPEND progline TO myprog.
    tempcounter = tempcounter + 1.
  ENDLOOP.

  APPEND '.' TO myprog.
  APPEND '' TO myprog.
  APPEND 'CLEAR line.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog.

  DATA acloffset TYPE outputlen.
  acloffset = 0.

* Loop over fields of table (table it_fields)
  tempcounter = 0.
  CONCATENATE 'file_' mytab INTO filenamevariable. "#EC NOTEXT

  LOOP AT it_fields INTO wa_field WHERE tabname = mytab.

    APPEND 'CLEAR fragment.' TO myprog. "#EC NOTEXT
    CONCATENATE mytab '-' wa_field-fieldname INTO progline.

* In case it should become necessary to format numbers (inttype = 'P') differently from the standard
* it should be done using the following statements

*    IF wa_field-inttype = 'P'.
*      CONCATENATE 'WRITE' progline 'TO fragment.'
*         INTO progline SEPARATED BY space.
*    ELSE
    CONCATENATE 'MOVE' progline 'TO fragment.' INTO progline SEPARATED BY space. "#EC NOTEXT
*    ENDIF.

    APPEND progline TO myprog.
    APPEND 'SHIFT fragment LEFT DELETING LEADING space.' TO myprog. "#EC NOTEXT


    IF p_CB_acl = 'X'.
* Only for ACL

      CONCATENATE 'line+' acloffset '(' wa_field-outputlen ')' INTO progline. "#EC NOTEXT
      CONCATENATE progline '= fragment.' INTO progline SEPARATED BY space. "#EC NOTEXT

      acloffset = acloffset + wa_field-outputlen.

* performance optimisation - find the longest field length
      IF wa_field-outputlen > max_fragment_length.
        max_fragment_length = wa_field-outputlen.
      ENDIF.

      APPEND progline TO myprog.

    ELSE.
* Only for csv

* performance optimisation - find the longest field length
      max_fragment_length_tmp = wa_field-outputlen + 3.
      IF max_fragment_length_tmp > max_fragment_length.
        max_fragment_length = max_fragment_length_tmp.
      ENDIF.

* first line fragment doesn't need the field delimiter
      IF tempcounter = 0.
        CONCATENATE 'line+' acloffset '(1)' "#EC NOTEXT
          INTO progline.
        CONCATENATE progline '= ''"''.'
          INTO progline SEPARATED BY space.

        acloffset = acloffset + 1.
        APPEND progline TO myprog.


        CONCATENATE 'line+' acloffset '(' "#EC NOTEXT
          wa_field-outputlen ')'
          INTO progline.
        CONCATENATE progline '= fragment.' "#EC NOTEXT
          INTO progline SEPARATED BY space.

        acloffset = acloffset + wa_field-outputlen.
        APPEND progline TO myprog.

        CONCATENATE 'line+' acloffset '(1)' "#EC NOTEXT
          INTO progline.
        CONCATENATE progline '= ''"''.'
          INTO progline SEPARATED BY space.

        acloffset = acloffset + 1.
        APPEND progline TO myprog.
      ELSE.

        CONCATENATE 'line+' acloffset '(1)' "#EC NOTEXT
          INTO progline.
        CONCATENATE progline '= separator.' "#EC NOTEXT
          INTO progline SEPARATED BY space.

        acloffset = acloffset + 1.
        APPEND progline TO myprog.

        CONCATENATE 'line+' acloffset '(1)' "#EC NOTEXT
          INTO progline.
        CONCATENATE progline '= ''"''.'
          INTO progline SEPARATED BY space.

        acloffset = acloffset + 1.
        APPEND progline TO myprog.


        CONCATENATE 'line+' acloffset '(' "#EC NOTEXT
          wa_field-outputlen ')'
          INTO progline.
        CONCATENATE progline '= fragment.' "#EC NOTEXT
          INTO progline SEPARATED BY space.
        acloffset = acloffset + wa_field-outputlen.
        APPEND progline TO myprog.

        CONCATENATE 'line+' acloffset '(1)' "#EC NOTEXT
          INTO progline.
        CONCATENATE progline '= ''"''.'
          INTO progline SEPARATED BY space.

        acloffset = acloffset + 1.
        APPEND progline TO myprog.


      ENDIF.
    ENDIF.
    APPEND '' TO myprog.
    tempcounter = tempcounter + 1.
  ENDLOOP.

* check for the longest line
  IF acloffset > max_line_length.
    max_line_length = acloffset.
  ENDIF.

  IF p_cb_soz = 'X'.
    APPEND 'REPLACE ALL OCCURRENCES of LF IN line WITH ''''.' TO myprog. "#EC NOTEXT
    APPEND 'REPLACE ALL OCCURRENCES of CR IN line WITH ''''.' TO myprog. "#EC NOTEXT
  ENDIF.

  CONCATENATE 'TRANSFER line TO ' filenamevariable '.' "#EC NOTEXT
    INTO progline SEPARATED BY space.
  APPEND progline TO myprog.

  CONCATENATE 'count_' mytab ' = count_' mytab ' + 1.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.

* Now check if the maximum number of records per chunk is reached.
* In case, open a new file
  APPEND '' TO myprog.
  WRITE p_maxrec TO strtemp LEFT-JUSTIFIED NO-GROUPING.

* Check IF we have to close the current file and open a new one.
  CONCATENATE 'IF count_' mytab INTO progline. "#EC NOTEXT
  CONCATENATE progline  '>=' strtemp '.' INTO progline SEPARATED BY space.

  APPEND progline TO myprog.

  CONCATENATE 'CLOSE DATASET ' filenamevariable '.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

* Write protocol
  CONCATENATE 'CONCATENATE ''Closing file'' ' filenamevariable INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT
  CONCATENATE 'count_' mytab  INTO progline. "#EC NOTEXT
  CONCATENATE  'WRITE' progline 'TO strtemp LEFT-JUSTIFIED.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'CONCATENATE '' --> '' strtemp '' records''' TO myprog. "#EC NOTEXT
  APPEND 'INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT
  CONCATENATE 'chunkcounter_' mytab INTO chunkcountervariable. "#EC NOTEXT

* BUG FIX 4.1->4.2
* Corrected zip logic as it was generating the incorrect destination file name
* If required, generated files are added to zip archive
  IF p_cb_zip = 'X'.
* Building filename of the file that was just generated. If full filename including path is passed to the
* addToZip function, the resulting file is buried in a folder structure within the zip file.
    APPEND 'CLEAR lf_string_path.' TO myprog. "#EC NOTEXT
    CONCATENATE 'lf_string_path = ''' pre_filename_Ohne_Pfad '_' mytab '_''.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    CONCATENATE 'tempstring = chunkcounter_' mytab '.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND 'CONDENSE tempstring NO-GAPS.' TO myprog. "#EC NOTEXT
    APPEND 'CONCATENATE lf_string_path tempstring INTO lf_string_path.' TO myprog. "#EC NOTEXT
    CONCATENATE 'CONCATENATE lf_string_path ''.' fileextension ''' INTO lf_string_path.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND 'PERFORM addToZip USING lf_string_path.' TO myprog. "#EC NOTEXT
    APPEND '' TO myprog.
  ENDIF.
* END BUG FIX

* Increase chunkcounter by 1

  CONCATENATE chunkcountervariable '=' chunkcountervariable ' + 1.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE filenamevariable ' = ''' pre_filename '_' mytab '_' '''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE 'tempstring =' chunkcountervariable '.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  APPEND 'CONDENSE tempstring NO-GAPS.' TO myprog. "#EC NOTEXT

  CONCATENATE 'CONCATENATE' filenamevariable  'tempstring ''.' INTO progline SEPARATED BY space. "#EC NOTEXT
  CONCATENATE progline fileextension INTO progline.

  CONCATENATE progline '''' 'INTO' filenamevariable '.' INTO progline separated  by space. "#EC NOTEXT
  APPEND progline TO myprog.

* Write protocol
  APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
  CONCATENATE 'CONCATENATE ''Opening file'' ' filenamevariable INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT
  CONCATENATE 'OPEN DATASET ' filenamevariable 'FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE 'count_' mytab ' = 0.' INTO progline.
  APPEND progline TO myprog.

  APPEND 'ENDIF.' TO myprog.

  APPEND '' TO myprog.

* Check if current select has to be closed
  IF wa_table-subselect < '1'.
    APPEND 'ENDSELECT.' TO myprog.

    IF subselectzumachen = '1'.
      subselectzumachen = ''.
      APPEND 'ENDSELECT.' TO myprog.

      mytab = tabnamess.

    ENDIF.
    IF subselectzumachen = '2'.
      subselectzumachen = '1'.
    ELSEIF subselectzumachen = '3'.
      subselectzumachen = '2'.
    ELSEIF subselectzumachen = '4'.
      subselectzumachen = '3'.
    ENDIF.
  ELSE.
    subselectzumachen = wa_table-subselect.
    tabnamess = wa_table-tabname.
  ENDIF.

  APPEND '' TO myprog.
  APPEND '' TO myprog.
  APPEND '' TO myprog.

ENDLOOP.

APPEND '' TO myprog.
APPEND '' TO myprog.

** Create table to store error or warning messages
APPEND 'DATA errline(400) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'TYPES ty_errline(400) TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'DATA it_err TYPE STANDARD TABLE OF ty_errline.' TO myprog. "#EC NOTEXT

APPEND '' TO myprog.
APPEND '' TO myprog.

* Second loop over tables for closing the files.
LOOP AT it_tables INTO wa_table.
  mytab = wa_table-tabname.
  CONCATENATE 'file_' mytab INTO filenamevariable. "#EC NOTEXT

  CONCATENATE filenamevariable ' = ''' pre_filename '_' mytab '_' '''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.

  CONCATENATE 'chunkcounter_' mytab INTO chunkcountervariable. "#EC NOTEXT

  CONCATENATE 'tempstring =' chunkcountervariable '.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'CONDENSE tempstring NO-GAPS.' TO myprog. "#EC NOTEXT

  CONCATENATE 'CONCATENATE' filenamevariable  'tempstring ''.' INTO progline SEPARATED BY space. "#EC NOTEXT
  CONCATENATE progline fileextension INTO progline.

  CONCATENATE progline '''' 'INTO' filenamevariable '.' INTO progline separated  by space. "#EC NOTEXT
  APPEND progline TO myprog.

* Write protocol
  CONCATENATE 'CONCATENATE ''Closing file'' ' filenamevariable INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT

  CONCATENATE 'count_' mytab INTO progline. "#EC NOTEXT
  CONCATENATE  'WRITE' progline 'TO strtemp LEFT-JUSTIFIED.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'CONCATENATE '' --> '' strtemp '' records''' TO myprog. "#EC NOTEXT
  APPEND 'INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT

  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT
** Write to error protocol if 0 lines were extracted for a table
  CONCATENATE 'IF count_' mytab ' = ''0'' AND chunkcounter_' mytab ' = ''1''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  CONCATENATE 'APPEND ''No lines extracted for Table ' mytab ''' TO it_err.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'ENDIF.' TO myprog.

  CONCATENATE 'CLOSE DATASET' filenamevariable '.' INTO progline SEPARATED BY space. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND '' TO myprog.

* If required, generated files are added to zip archive
  IF p_cb_zip = 'X'.
* Building filename of the file that was just generated. If full filename including path is passed to the
* addToZip function, the resulting file is buried in a folder structure within the zip file.
    APPEND 'CLEAR lf_string_path.' TO myprog. "#EC NOTEXT
    CONCATENATE 'lf_string_path = ''' pre_filename_Ohne_Pfad '_' mytab '_''.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    CONCATENATE 'tempstring = chunkcounter_' mytab '.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND 'CONDENSE tempstring NO-GAPS.' TO myprog. "#EC NOTEXT
    APPEND 'CONCATENATE lf_string_path tempstring INTO lf_string_path.' TO myprog. "#EC NOTEXT
    CONCATENATE 'CONCATENATE lf_string_path ''.' fileextension ''' INTO lf_string_path.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND 'PERFORM addToZip USING lf_string_path.' TO myprog. "#EC NOTEXT
    APPEND '' TO myprog.

* Adding header file for table to the zip archive. The header files were previously generated by PwC-Xtract
* itself, not the dynamically generated report.
    APPEND 'CLEAR lf_string_path.' TO myprog. "#EC NOTEXT
    CONCATENATE 'lf_string_path = ''' pre_filename_Ohne_Pfad '_' mytab '_header.txt''.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND 'PERFORM addToZip USING lf_string_path.' TO myprog. "#EC NOTEXT
    APPEND '' TO myprog.
  ENDIF.

  APPEND '' TO myprog.

ENDLOOP.

* If required, the last files are added to the .zip file
IF p_cb_zip = 'X'.

* If ACL was chosen as output format, the .acl project file is added to the zip archive.
  IF p_CB_acl = 'X'.
    CONCATENATE 'PERFORM addToZip USING ''' pre_filename_Ohne_Pfad '.acl''.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND '' TO myprog.
  ENDIF.

* Add log of PwC-Xtract main programme to .zip file.
  CONCATENATE 'PERFORM addToZip USING ''' pre_filename_Ohne_Pfad '_log.txt''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND '' TO myprog.

* Add MetaData File to .zip file.
  CONCATENATE 'PERFORM addToZip USING ''' pre_filename_Ohne_Pfad '_MetaData.txt''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND '' TO myprog.

  IF p_cb_est = 'X'.
* If necessary, add data volume estimation file to .zip file.
    CONCATENATE 'PERFORM addToZip USING ''' pre_filename_Ohne_Pfad '_datavolume_estimation.txt''.' INTO progline. "#EC NOTEXT
    APPEND progline TO myprog.
    APPEND '' TO myprog.
  ENDIF.

ENDIF.

* add execution time information
APPEND '' TO myprog.
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
APPEND 'DATA ts2 TYPE timestamp.' TO myprog. "#EC NOTEXT
APPEND 'GET TIME STAMP FIELD ts2.' TO myprog. "#EC NOTEXT
APPEND 'strtemp = ts2.' TO myprog. "#EC NOTEXT
APPEND 'CONDENSE strtemp.' TO myprog. "#EC NOTEXT
APPEND 'CONCATENATE ''End time:'' strtemp INTO strtemp SEPARATED BY space.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING strtemp.' TO myprog. "#EC NOTEXT
APPEND 'DATA ts3 TYPE i.' TO myprog. "#EC NOTEXT
APPEND 'ts3 = cl_abap_tstmp=>subtract(' TO myprog. "#EC NOTEXT
APPEND '          TSTMP1 = ts2' TO myprog. "#EC NOTEXT
APPEND '          TSTMP2 = ts1 ).' TO myprog. "#EC NOTEXT
APPEND 'WRITE ts3 TO strtemp LEFT-JUSTIFIED NO-GROUPING.' TO myprog. "#EC NOTEXT
APPEND 'CONCATENATE ''Execution time in seconds:'' strtemp INTO strtemp SEPARATED BY space.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING strtemp.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT


APPEND 'PERFORM schreibeprotokoll USING ''''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING sy-uline.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING ''Error Log:''.' TO myprog. "#EC NOTEXT

** Write errors occured in preperation phase
LOOP AT errlines INTO errline.
  APPEND 'PERFORM schreibeprotokoll USING ' TO myprog. "#EC NOTEXT
  IF errline CA ''''.
    REPLACE ALL OCCURRENCES OF '''' IN errline with ''''''.
  ENDIF.
  CONCATENATE '''' errline '''.' INTO progline.
  APPEND progline TO myprog.
ENDLOOP.

** Write errors occured in generated report
APPEND 'LOOP AT it_err INTO errline.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM schreibeprotokoll USING errline.' TO myprog. "#EC NOTEXT
APPEND 'ENDLOOP.' TO myprog.

APPEND 'CLOSE DATASET mybcglog.' TO myprog. "#EC NOTEXT
APPEND '' TO myprog.

* If required, the last file is added to the .zip file and the archive is saved on the application server.
IF p_cb_zip = 'X'.

* Add the bcglog to the zip file.
  CONCATENATE 'PERFORM addToZip USING ''' pre_filename_Ohne_Pfad '_bcglog.txt''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND '' TO myprog.

* Save archive to application server.
  APPEND 'PERFORM saveZip.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog.
ENDIF.

* Delete itself afer execution.
CONCATENATE 'DELETE REPORT ' '''' progname '''.' INTO progline.
APPEND progline TO myprog.
APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
CONCATENATE 'WRITE ''Report' progname 'could not be deleted.''.' INTO progline SEPARATED BY space. "#EC NOTEXT
APPEND progline TO myprog.
APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
APPEND '' TO myprog. "#EC NOTEXT

* Append form for writing the protocol
* added try catch if something is written while the log file is closed
APPEND 'FORM schreibeprotokoll' TO myprog. "#EC NOTEXT
APPEND 'USING' TO myprog. "#EC NOTEXT
APPEND 'meldung TYPE c.' TO myprog. "#EC NOTEXT
APPEND 'TRY.' TO myprog. "#EC NOTEXT
APPEND 'TRANSFER meldung TO mybcglog.' TO myprog. "#EC NOTEXT
APPEND 'CATCH CX_SY_FILE_OPEN_MODE.' TO myprog. "#EC NOTEXT
* log to the error log so the messages isn't lost
* ignore the last zip memory used as its the log file itself being included
APPEND 'IF meldung np ''Zip memory used*''.' TO myprog. "#EC NOTEXT
APPEND 'PERFORM fehlerprotokoll USING meldung.' TO myprog. "#EC NOTEXT
APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
APPEND 'ENDTRY.' TO myprog. "#EC NOTEXT
APPEND 'ENDFORM.' TO myprog. "#EC NOTEXT
APPEND '' TO myprog.
APPEND '' TO myprog.

* If required, a form for writing an emergency failure protocol. A second write method is needed since
* all other error messages in the generated background programme are written to the file bcglog. However,
* when the bcglog itself is added to the .zip archive, there maybe situations in which the programme returns
* no files at all and no error messages. To cover this specific case, the form fehlerprotokoll writes a short
* error dump file to the server.
IF p_cb_zip = 'X'.
  APPEND 'FORM fehlerprotokoll USING meldung TYPE c.' TO myprog. "#EC NOTEXT
  CONCATENATE 'OPEN DATASET ''' p_lctn pre_filename_Ohne_Pfad '_error.txt'' FOR APPENDING IN TEXT MODE ENCODING UTF-8.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog. "#EC NOTEXT
  CONCATENATE 'TRANSFER meldung TO ''' p_lctn pre_filename_Ohne_Pfad '_error.txt''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog. "#EC NOTEXT
  CONCATENATE 'CLOSE DATASET ''' p_lctn pre_filename_Ohne_Pfad '_error.txt''.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog. "#EC NOTEXT
  APPEND 'ENDFORM.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog. "#EC NOTEXT
ENDIF.

* If required, add sub routine for adding files to a zip archive.
IF p_cb_zip = 'X'.
  APPEND 'FORM addToZip USING ud_filename TYPE string.' TO myprog. "#EC NOTEXT

* If user specified that no header files are needed, any attempt to add header files
* is aborted immediately. In this case, no error message should not be written to the
* logfile. Therefore, header files are handled separately and not just in the handling
* of unsuccessful OPEN DATASET statements later on.
  IF p_cb_hdr <> 'X'.
    APPEND 'IF ud_filename CS ''header''.' TO myprog. "#EC NOTEXT
    APPEND 'EXIT.' TO myprog. "#EC NOTEXT
    APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  ENDIF.

* Create variables needed for adding files to zip archive.
  APPEND 'DATA lf_buffer_zip TYPE xstring.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lf_error_code TYPE c.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lf_individual_filesize TYPE i.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lf_filename TYPE epsf-epsfilnam.' TO myprog. "#EC NOTEXT
  APPEND 'lf_filename = ud_filename.' TO myprog. "#EC NOTEXT

* Build filepath of file that is being added to zip archive.
  CONCATENATE 'CONCATENATE ''' p_lctn ''' ud_filename INTO tempstring.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog. "#EC NOTEXT

* Open dataset. If opening of dataset fails, an error ist written to the logfile and the zipping process is aborted.
  APPEND 'OPEN DATASET tempstring FOR INPUT IN BINARY MODE.' TO myprog. "#EC NOTEXT
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'lf_error_code = sy-subrc.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Encountered error '' lf_error_code '' when opening file '' ud_filename INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
* Example explanation: Same process is also applied to the following steps. While the file ID_bcglog.txt is added to the .zip archive,
* trying to write any error messages to the file ID_bcglog.txt automatically leads to an abortion of the background job. This results in
* no resulting files on the server without any visible error messages at all. Therefore adding this log to the zip archive is treated
* differently and any occurring error messages are written to a dedicated .txt file on the server.
  APPEND 'IF ud_filename CS ''bcglog''.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING errline.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING ''Zipping of file aborted''.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND ''Zipping of file aborted'' TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'EXIT.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

* Get size of file that should be added. If filesize exceeds value range of i, the function
* returns -99. The maximum value range of i is only marginally lower than the maximum of bytes
* that can be stored in a xstring variable (just below 2GB). Therefore, if the file size function
* returns -99, the file is too big to be handled in the scope of this programme and is therefore
* not zipped.
  APPEND 'CALL FUNCTION ''EPS_GET_FILE_ATTRIBUTES''' TO myprog. "#EC NOTEXT
  APPEND 'EXPORTING' TO myprog. "#EC NOTEXT
  APPEND 'file_name = lf_filename' TO myprog. "#EC NOTEXT
  CONCATENATE 'dir_name = ''' p_lctn '''' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'IMPORTING' TO myprog. "#EC NOTEXT
  APPEND 'file_size = lf_individual_filesize.' TO myprog. "#EC NOTEXT

  APPEND 'IF lf_individual_filesize < 0.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''File '' ud_filename ''exceeds the maximum file size for zipping (~2GB).'' INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND ''Select a lower maximum record number per file to avoid generating files of this size.'' TO it_err.' TO myprog. "#EC NOTEXT "#EC NOTEXT
  APPEND 'EXIT.' TO myprog. "#EC NOTEXT "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT "#EC NOTEXT

* The length of the current zip buffer is determined by temporarily storing it in a variable.
* Unfortunately, the class CL_ABAP_ZIP offers no other option to recover the size of the
* compressed version of the files. If the size of the current buffer plus the size of the
* uncompressed file that should now be added exceeds the value range of i, the exception
* CX_SY_ARITHMETIC_OVERFLOW is thrown. This exception gives an indication that adding the
* current file might make to .zip buffer too big to store in an xstring variable later on
* (which is necessary to save it on the application server). Therefore, the .zip buffer is
* saved to a file on the server before progressing.
  APPEND 'TRY.' TO myprog. "#EC NOTEXT
  APPEND 'CALL METHOD mo_zip_tool->save' TO myprog. "#EC NOTEXT
  APPEND 'RECEIVING' TO myprog. "#EC NOTEXT
  APPEND 'zip = lf_buffer_zip.' TO myprog. "#EC NOTEXT
  APPEND 'gf_current_zipsize = xstrlen( lf_buffer_zip ) + lf_individual_filesize.' TO myprog. "#EC NOTEXT
  APPEND 'CATCH CX_SY_ARITHMETIC_OVERFLOW.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM saveZip.' TO myprog. "#EC NOTEXT
  APPEND 'ENDTRY.' TO myprog. "#EC NOTEXT
  APPEND 'CLEAR lf_buffer_zip.' TO myprog. "#EC NOTEXT

* Reading file into buffer.
  APPEND 'READ DATASET tempstring INTO lf_buffer_zip.' TO myprog. "#EC NOTEXT
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'lf_error_code = sy-subrc.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Encountered error'' lf_error_code ''when reading file'' ud_filename INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'IF ud_filename CS ''bcglog''.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING errline.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING ''Zipping of file aborted''.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND ''Zipping of file aborted'' TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'EXIT.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

* Closing opened dataset.
  APPEND 'CLOSE DATASET tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'lf_error_code = sy-subrc.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Encountered error'' lf_error_code ''when closing file'' ud_filename INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'IF ud_filename CS ''bcglog''.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING errline.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

* Adding file to current state of zip archive using class CL_ABAP_ZIP
  APPEND 'CALL METHOD mo_zip_tool->add' TO myprog. "#EC NOTEXT
  APPEND 'EXPORTING' TO myprog. "#EC NOTEXT
  APPEND 'name    = ud_filename' TO myprog. "#EC NOTEXT
  APPEND 'content = lf_buffer_zip.' TO myprog. "#EC NOTEXT
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'lf_error_code = sy-subrc.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Encountered error'' lf_error_code ''when zipping file'' ud_filename INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'IF ud_filename CS ''bcglog''.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING errline.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING ''Zipping of file aborted''.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND ''Zipping of file aborted'' TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'EXIT.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

* Delete unzipped version of file.
  APPEND 'DELETE DATASET tempstring.' TO myprog. "#EC NOTEXT "#EC NOTEXT
  APPEND 'IF sy-subrc <> 0.' TO myprog. "#EC NOTEXT
  APPEND 'lf_error_code = sy-subrc.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Encountered error'' lf_error_code ''when deleting file'' ud_filename INTO errline SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'IF ud_filename CS ''bcglog''.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM fehlerprotokoll USING errline.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'APPEND errline TO it_err.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

* Check if the size exceeds the imposed memory limit
* note that the size will always exceed as we only create a new zip file once it does.
  APPEND 'DATA bound_used TYPE ABAP_MSIZE.' TO myprog. "#EC NOTEXT
  APPEND 'cl_abap_memory_utilities=>get_memory_size_of_object( EXPORTING object = mo_zip_tool IMPORTING bound_size_used = bound_used ).' TO myprog. "#EC NOTEXT
  APPEND 'WRITE bound_used TO tempstring LEFT-JUSTIFIED NO-GROUPING.' TO myprog. "#EC NOTEXT
  APPEND 'CONCATENATE ''Zip memory used (bytes)'' tempstring ''after adding file:'' ud_filename INTO tempstring SEPARATED BY space.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM schreibeprotokoll USING tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'IF bound_used > p_cb_max_zip_size.' TO myprog. "#EC NOTEXT
  APPEND 'PERFORM saveZip.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT

  APPEND 'ENDFORM.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog.
  APPEND '' TO myprog.
ENDIF.

* If required, add a form for writing the current state of the .zip buffer
* into a file on the server.
IF p_cb_zip = 'X'.
  APPEND 'FORM saveZip.' TO myprog. "#EC NOTEXT

* Create required variables
  APPEND 'DATA lf_zip_buffer TYPE xstring.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lt_data_tab TYPE TABLE OF x255.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lf_length_counter TYPE i.' TO myprog. "#EC NOTEXT
  APPEND 'DATA lf_bin_size TYPE i.' TO myprog. "#EC NOTEXT

* Using a field symbol for references to lines of the table lt_data_tab speeds up the transfer process.
  APPEND 'FIELD-SYMBOLS <lt_data_line> LIKE LINE OF lt_data_tab.' TO myprog. "#EC NOTEXT

* Save current state of .zip buffer to xstring variable.
  APPEND 'CALL METHOD mo_zip_tool->save' TO myprog. "#EC NOTEXT
  APPEND 'RECEIVING' TO myprog. "#EC NOTEXT
  APPEND 'zip = lf_zip_buffer.' TO myprog. "#EC NOTEXT

* Convert stored version of zip buffer to binary format.
  APPEND 'CALL FUNCTION ''SCMS_XSTRING_TO_BINARY''' TO myprog. "#EC NOTEXT
  APPEND 'EXPORTING' TO myprog. "#EC NOTEXT
  APPEND 'buffer        = lf_zip_buffer' TO myprog. "#EC NOTEXT
  APPEND 'IMPORTING' TO myprog. "#EC NOTEXT
  APPEND 'output_length = lf_bin_size' TO myprog. "#EC NOTEXT
  APPEND 'TABLES' TO myprog. "#EC NOTEXT
  APPEND 'binary_tab    = lt_data_tab.' TO myprog. "#EC NOTEXT

* Store length of binary file to a counter. The binary file is stored in a table with lines
* of fixed length. If all lines are saved in a file in full length, excess whitespace/zeros
* are stored with them, corrupting the file. Therefore, the remaining bytes that still need
* to be saved in lf_length_counter. In the last line of the table, the content is cut off
* accordingly before saving.
  APPEND 'lf_length_counter = lf_bin_size.' TO myprog. "#EC NOTEXT
  APPEND 'tempstring = gf_zipfile_counter.' TO myprog. "#EC NOTEXT
  APPEND 'CONDENSE tempstring NO-GAPS.' TO myprog. "#EC NOTEXT
  CONCATENATE 'CONCATENATE ''' p_lctn pre_filename_Ohne_Pfad '_files_'' tempstring ''.zip'' INTO tempstring.' INTO progline. "#EC NOTEXT
  APPEND progline TO myprog.
  APPEND 'DELETE DATASET tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'OPEN DATASET tempstring FOR OUTPUT IN BINARY MODE.' TO myprog. "#EC NOTEXT
  APPEND 'LOOP AT lt_data_tab ASSIGNING <lt_data_line>.' TO myprog. "#EC NOTEXT
  APPEND 'IF lf_length_counter > 255.' TO myprog. "#EC NOTEXT
  APPEND 'TRANSFER <lt_data_line> TO tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'ELSE.' TO myprog. "#EC NOTEXT
  APPEND 'TRANSFER <lt_data_line>(lf_length_counter) TO tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'ENDIF.' TO myprog. "#EC NOTEXT
  APPEND 'SUBTRACT 255 FROM lf_length_counter.' TO myprog. "#EC NOTEXT
  APPEND 'ENDLOOP.' TO myprog. "#EC NOTEXT

* Close dataset, reset buffer of .zip file and increment .zip batch counter.
  APPEND 'CLOSE DATASET tempstring.' TO myprog. "#EC NOTEXT
  APPEND 'CLEAR mo_zip_tool.' TO myprog. "#EC NOTEXT
  APPEND 'CREATE OBJECT mo_zip_tool.' TO myprog. "#EC NOTEXT
  APPEND 'gf_zipfile_counter = gf_zipfile_counter + 1.' TO myprog. "#EC NOTEXT
  APPEND 'ENDFORM.' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog. "#EC NOTEXT
  APPEND '' TO myprog. "#EC NOTEXT
ENDIF.


***********************************************************************
** Set the maximum line and fragment lengths (performance optimisation)
***********************************************************************

* check the length of the variable
IF max_fragment_length = 0.
* no table definitions were found, report this to the user
  APPEND '## ERROR ## No table or field definitions were loaded.' TO loglines. "#EC NOTEXT
  APPEND 'Check your separator character!' TO loglines. "#EC NOTEXT
* set the line lengths to be 1 to avoid raising unnecessary errors
  max_fragment_length = 1.
  max_line_length = 1.
ENDIF.

* convert lengths to text so they can be exported into the program code
  strtmp_1 = max_fragment_length.
  CONDENSE strtmp_1.
  strtmp_2 = max_line_length.
  CONDENSE strtmp_2.
  LOOP AT myprog INTO progline.
    REPLACE '{MAX_FRAGMENT_LENGTH}' WITH strtmp_1 INTO progline.
    REPLACE '{MAX_LINE_LENGTH}' WITH strtmp_2 INTO progline.
    MODIFY myprog FROM progline.
  ENDLOOP.



***********************************************************************
** Show generated report, if indicated
***********************************************************************

IF p_cb_deb = 'X'.

  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.
  APPEND 'Generated Report:' TO loglines. "#EC NOTEXT
  LOOP AT myprog INTO progline.
    IF progline IS INITIAL.
      APPEND '' TO loglines.
    ELSE.
      APPEND progline TO loglines.
    ENDIF.
  ENDLOOP.

  APPEND 'End of program' TO loglines. "#EC NOTEXT
  APPEND '' TO loglines.
  APPEND sy-uline TO loglines.
ENDIF.

***********************************************************************
** Syntaxcheck
***********************************************************************

DATA: mess(256) TYPE c,
      lin TYPE i,
      wrd(256) TYPE c,
      dir  TYPE trdir.

* This next line will generate an ABAP Test Cockpit warning: Critical Statement - Write/delete a report/text pool
* This cannot be avoided as it inserts the program that will perform the actual data extraction. This is required.
INSERT REPORT progname FROM myprog UNICODE ENABLING 'X'.

SELECT SINGLE *
       FROM trdir
       INTO dir
       WHERE name = progname.

SYNTAX-CHECK FOR myprog MESSAGE mess LINE lin WORD wrd
       DIRECTORY ENTRY dir.

IF NOT mess IS INITIAL.

  WRITE / 'Syntaxerror in generated report:'. "#EC NOTEXT
  WRITE / 'Message: '. "#EC NOTEXT
  WRITE / mess.
  WRITE / 'Word: '. "#EC NOTEXT
  WRITE / wrd.
  WRITE / 'Line: '. "#EC NOTEXT
  WRITE / lin.

  LOOP AT myprog INTO progline.
    WRITE / progline.
  ENDLOOP.

  RETURN.

ENDIF.

***********************************************************************
** Write header files
***********************************************************************

IF p_cb_hdr = 'X'.
  TYPES: xlsfield(30) TYPE c.

  DATA:
    BEGIN OF wa_header,
      fieldname   TYPE xlsfield,
      rollname    TYPE xlsfield,
      leng        TYPE xlsfield,
      intlen      TYPE xlsfield,
      outputlen   TYPE xlsfield,
      decimals    TYPE xlsfield,
      datatype    TYPE xlsfield,
      inttype     TYPE xlsfield,
      scrtext_l   TYPE xlsfield,
      keyflag     TYPE xlsfield,
      comptype    TYPE xlsfield,
      lfieldname  TYPE xlsfield,
    END OF wa_header.


* Loop over tables
  LOOP AT it_tables INTO mytab.

    CONCATENATE pre_filename '_' mytab '_header' '.txt' INTO filename. "#EC NOTEXT

    APPEND 'Created meta data:' TO loglines. "#EC NOTEXT
    APPEND filename TO loglines.
    OPEN DATASET filename FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.
    wa_header-fieldname   = 'Feldname'. "#EC NOTEXT
    wa_header-rollname    = 'Dat.element'. "#EC NOTEXT
    wa_header-leng        = 'Lnge'. "#EC NOTEXT
    wa_header-intlen      = 'Int. Lnge (Bytes)'. "#EC NOTEXT
    wa_header-outputlen   = 'Ausgabelnge'. "#EC NOTEXT
    wa_header-decimals    = 'Dez.-stellen'. "#EC NOTEXT
    wa_header-datatype    = 'Datentyp'. "#EC NOTEXT
    wa_header-inttype     = 'ABAP-Datentyp'. "#EC NOTEXT
    wa_header-scrtext_l   = 'Feldbezeichner'. "#EC NOTEXT
    wa_header-keyflag     = 'Schlsselfeld'. "#EC NOTEXT
    wa_header-comptype    = 'Komponententyp'. "#EC NOTEXT
    wa_header-lfieldname  = 'Feldname (lang)'. "#EC NOTEXT
*  APPEND wa_header to it_header.
    TRANSFER wa_header TO filename.
    CLEAR wa_header.


    LOOP AT it_fields INTO wa_field WHERE tabname = mytab.

      MOVE wa_field-fieldname TO myfield.

      refresh myretfields.

      CALL FUNCTION 'DDIF_FIELDINFO_GET'
        EXPORTING
          tabname        = mytab
          fieldname      = myfield
          langu          = sy-langu
        TABLES
          dfies_tab      = myretfields
        EXCEPTIONS
          NOT_FOUND      = 1
          INTERNAL_ERROR = 2
          OTHERS         = 3.

      IF sy-subrc = 0.
        READ TABLE myretfields INDEX 1 INTO wa_retfields.
        MOVE-CORRESPONDING wa_retfields TO wa_header.
        TRANSFER wa_header TO filename.
        CLEAR wa_header.
      ENDIF.

    ENDLOOP.

    CLOSE DATASET filename.

  ENDLOOP.
ENDIF.

***********************************************************************
** Write ACL files
***********************************************************************

IF p_CB_acl = 'X'.

  DATA MyLine(256) TYPE c.
  DATA offset TYPE i.
  DATA tempstring(256) TYPE c.
  DATA templen TYPE i.
  DATA decimals TYPE i.

  DATA ctempoffset(7) TYPE c.
  DATA ctemplen(4) TYPE c.
  DATA ctempdecimals(2) TYPE c.


  DATA MyZaehler TYPE i.


  CONCATENATE pre_filename '.acl' INTO filename.

  APPEND 'Created ACL-File:' TO loglines. "#EC NOTEXT
  APPEND filename TO loglines.
  OPEN DATASET filename FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.
  MyLine = '@ACL900'.
  TRANSFER myline TO filename.
* Leerzeile fr kompatibilitt mit lteren ACL Versionen
  MyLine = ''.
  TRANSFER myline TO filename.

* Loop over tables for LAYOUT-Section
  LOOP AT it_tables INTO mytab.

    myline = ''.
    myline+0(10) = '^LAYOUT'.

    MyZaehler = 0.

    LOOP AT it_fields INTO wa_field WHERE tabname = mytab.
      templen = wa_field-OUTPUTLEN.
      myzaehler = myzaehler + templen.
    ENDLOOP.

    myzaehler = myzaehler + 2.

    myline+10(35) = mytab.
    WRITE myzaehler TO strtemp
      LEFT-JUSTIFIED NO-GROUPING.

    myline+45(5) = strtemp.
    myline+50(5) = 'D,T.'.

    TRANSFER myline TO filename.

    offset = 1.

    LOOP AT it_fields INTO wa_field WHERE tabname = mytab.

      myline = ''.

      MOVE wa_field-fieldname TO myfield.
      templen = wa_field-OUTPUTLEN.
      decimals = wa_field-decimals.


      WRITE offset TO ctempoffset
        RIGHT-JUSTIFIED NO-GROUPING.
      WRITE templen TO ctemplen
        RIGHT-JUSTIFIED NO-GROUPING.
      WRITE decimals TO ctempdecimals
        RIGHT-JUSTIFIED NO-GROUPING.


      myline+0(20) = myfield.

      IF wa_field-inttype = 'D'.
        myline+20(7) = 'DATE'.
      ELSEIF wa_field-inttype = 'P'.
        myline+20(7) = 'NUMERIC'.
      ELSEIF wa_field-inttype = 'I'.
        myline+20(7) = 'NUMERIC'.
      ELSE.
* Datentyp "UNICODE" kann auch verwendet werden,
* funktioniert allerdings nur in Unicode versionen von ACL
        myline+20(7) = 'ASCII'.
      ENDIF.

      myline+27(7) = ctempoffset.
      myline+34(4) = ctemplen.

      IF wa_field-inttype = 'P'.
        myline+38(2) = ctempdecimals.
      ELSEIF wa_field-inttype = 'I'.
        myline+38(2) = '0 '.
      ELSE.
        myline+38(2) = '  '.
      ENDIF.


      IF wa_field-inttype = 'D'.
        CONCATENATE myline 'PICTURE "YYYYMMDD" '
          INTO myline SEPARATED BY space.
      ENDIF.

      CONCATENATE myline 'AS "' INTO myline SEPARATED BY space.
      CONCATENATE myline wa_field-fieldtext  '"'
        INTO myline.

      TRANSFER myline TO filename.

      refresh myretfields.

      offset = offset + wa_field-OUTPUTLEN.

    ENDLOOP.

    TRANSFER '' TO filename.

  ENDLOOP.

* Loop over tables for FORMAT-Section
  LOOP AT it_tables INTO mytab.

    myline =''.
    myline+0(10) = '^FORMAT   '. "#EC NOTEXT
    myline+10(35) = mytab.
    myline+45(35) = mytab.
    myline+80(4) = '"" "'. "#EC NOTEXT


    CONCATENATE pre_filename_Ohne_Pfad '_' mytab '_1.fil' "#EC NOTEXT
      INTO tempstring.
    CONCATENATE myline tempstring INTO myline.
    CONCATENATE myline '" 0 ASCII CRLF' INTO myline. "#EC NOTEXT

    TRANSFER myline TO filename.
    TRANSFER '' TO filename.


  ENDLOOP.

  CLOSE DATASET filename.

ENDIF.

***********************************************************************
** Create and start job
***********************************************************************

DATA jobnumber TYPE TBTCJOB-JOBCOUNT.
DATA JOBNAME TYPE TBTCJOB-JOBNAME.

CONCATENATE 'PWCXTRACT_' pre_filename_Ohne_Pfad INTO JOBNAME. "#EC NOTEXT

* DATA: print_parameters TYPE pri_params.

IF p_cb_aa1 = ''.
  CALL FUNCTION 'JOB_OPEN'
    EXPORTING
      jobname          = jobname
    IMPORTING
      jobcount         = jobnumber
    EXCEPTIONS
      cant_create_job  = 1
      invalid_job_data = 2
      jobname_missing  = 3
      OTHERS           = 4.

  IF sy-subrc > 0.
    WRITE: / 'Error while creating background job. sysubrc = ', sy-subrc. "#EC NOTEXT
    EXIT.
  ENDIF.

*   Append program and job
  IF p_cb_bgr = 'X'.
    SUBMIT (progname) "#EC CI_SUBMIT.
               VIA JOB jobname NUMBER jobnumber
               AND RETURN.
  ELSE.
    SUBMIT (progname) "#EC CI_SUBMIT.
               AND RETURN.
  ENDIF.
* find out on which application server the report is running
* current server is used as target server
* Reason: If job is run on another server, it might not be able to write to specified output path
  DATA appserver TYPE BTCTGTSRVR-SRVNAME.
  DATA system_number TYPE INSTANZ-SYSTEMNR.
* Get system ID
  CALL FUNCTION 'GET_SYSTEM_NUMBER' "#EC CI_SUBMIT.
    IMPORTING
      INSTANCENUMBER = system_number.

  CONCATENATE sy-host '_' sy-sysid '_' system_number INTO appserver.

*   Finish up job creation
  CALL FUNCTION 'JOB_CLOSE' "#EC NOTEXT
    EXPORTING
      jobcount             = jobnumber
      jobname              = jobname
      strtimmed            = 'X'
      TARGETSERVER         = appserver
    EXCEPTIONS
      cant_start_immediate = 1
      invalid_startdate    = 2
      jobname_missing      = 3
      job_close_failed     = 4
      job_nosteps          = 5
      job_notex            = 6
      lock_failed          = 7
      invalid_target       = 8.

  IF sy-subrc = 0.
    APPEND 'Triggered extraction job.' TO loglines. "#EC NOTEXT
    APPEND 'Job-Name:' TO loglines. "#EC NOTEXT
    APPEND jobname TO loglines.
    APPEND '' TO loglines.
    APPEND 'Job-Number: ' TO loglines. "#EC NOTEXT
    APPEND jobnumber TO loglines.
    APPEND '' TO loglines.
    APPEND sy-uline TO loglines.
  ELSEIF sy-subrc = 8.
    APPEND 'Error while starting extraction job.' TO loglines. "#EC NOTEXT
    APPEND 'Target System is not valid.' TO loglines. "#EC NOTEXT
    WRITE 'WARNING: Backgroundjob could not be started. See log for more details.'. "#EC NOTEXT
    APPEND '' TO loglines.
    APPEND sy-uline TO loglines.
  ELSEIF sy-subrc > 1.
    APPEND 'Error while starting extraction job.' TO loglines. "#EC NOTEXT
    APPEND 'Job was not started.' TO loglines. "#EC NOTEXT
    WRITE sy-subrc.
    APPEND '' TO loglines.
    APPEND sy-uline TO loglines.
  ELSEIF sy-subrc = 1.
    APPEND 'Job could not be started immediately.' TO loglines. "#EC NOTEXT
    APPEND 'Check transaction sm37 for job status.' TO loglines. "#EC NOTEXT
    APPEND '' TO loglines.
    APPEND sy-uline TO loglines.
  ENDIF.

ENDIF.


**********************************************************************
* Show protocol
**********************************************************************

* Log parameters:
APPEND '' TO loglines.
APPEND sy-uline TO loglines.
APPEND 'SAP-User:' TO loglines. "#EC NOTEXT
APPEND sy-uname TO loglines.
APPEND 'Input-File with extraction:' TO loglines. "#EC NOTEXT
APPEND p_file TO loglines.
APPEND 'Limit result (Yes or No, X or blank):' TO loglines. "#EC NOTEXT
APPEND p_cb_max TO loglines.
APPEND 'Limit number of rows:' TO loglines. "#EC NOTEXT
WRITE p_max TO strtemp LEFT-JUSTIFIED.
APPEND strtemp TO loglines.
APPEND 'Separator:' TO loglines. "#EC NOTEXT
APPEND p_sep TO loglines.
APPEND 'Limit number of documents per file (X or blank):' TO loglines. "#EC NOTEXT
WRITE p_cb_rec TO strtemp LEFT-JUSTIFIED.
APPEND strtemp TO loglines.
APPEND 'Number of documents per file:' TO loglines. "#EC NOTEXT
WRITE p_maxrec TO strtemp LEFT-JUSTIFIED.
APPEND strtemp TO loglines.
APPEND 'Export result in ACL (Yes or No, X or blank):' TO loglines. "#EC NOTEXT
APPEND p_CB_acl TO loglines.
APPEND 'Destination directory:' TO loglines. "#EC NOTEXT
APPEND p_lctn TO loglines.
APPEND 'Show protocol (Yes or No, X or blank):' TO loglines. "#EC NOTEXT
APPEND p_cb_deb TO loglines.
APPEND 'Run in background (Yes or No, X or blank):' TO loglines. "#EC NOTEXT
APPEND p_cb_bgr TO loglines.
APPEND '' TO loglines.
APPEND sy-uline TO loglines.

* Show log table.
CONCATENATE pre_filename '_log' '.txt' INTO filename. "#EC NOTEXT
OPEN DATASET filename FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.

LOOP AT loglines INTO logline.
*  IF logline IS INITIAL.
*    skip.
*  ELSE.
  WRITE / logline.
*  ENDIF.
  TRANSFER logline TO filename.
ENDLOOP.

CLOSE DATASET filename.

* Write metadata File
DATA metavalues(350) TYPE c.

CONCATENATE pre_filename '_MetaData' '.txt' INTO filename.
OPEN DATASET filename FOR OUTPUT IN TEXT MODE ENCODING UTF-8 WITH BYTE-ORDER MARK IGNORING CONVERSION ERRORS.

CONCATENATE '{"Topic":' Topic ',' INTO metavalues. "#EC NOTEXT
TRANSFER metavalues TO filename.
CONCATENATE '"PackagePath":' PackagePath ',' INTO metavalues. "#EC NOTEXT
TRANSFER metavalues TO filename.
CONCATENATE '"RequestId":' RequestId ',' INTO metavalues. "#EC NOTEXT
TRANSFER metavalues TO filename.
CONCATENATE '"PublicKey":' PublicKey '}' INTO metavalues. "#EC NOTEXT
TRANSFER metavalues TO filename.

CLOSE DATASET filename.

**********************************************************************
* Own Routine for processing Excel/CSV Input
**********************************************************************
FORM sub_text_convert_csv_to_sap USING lv_sep      TYPE char1
*                                   lt_raw_data TYPE /pwc/cxx_t_c4096
                                   lt_raw_data LIKE l_raw_data
                                   ls_file     TYPE rlgrap-filename
                          CHANGING lt_xls      TYPE STANDARD TABLE.

  CLEAR wa_xls.

  DATA: lv_raw_data   TYPE lty_raw_data,
        lt_search_tab TYPE match_result_tab,
        ls_search_tab TYPE LINE OF match_result_tab,
        lv_raw_table(50)  TYPE c,
        lv_raw_field(50)  TYPE c,
        lv_raw_value_from(100) TYPE c,
        lv_raw_value_to(100) TYPE c,
        lv_raw_rest(500) TYPE c.

  LOOP AT lt_raw_data INTO lv_raw_data.
    CLEAR wa_xls.
    SPLIT lv_raw_data AT lv_sep INTO: lv_raw_table lv_raw_field lv_raw_value_from lv_raw_value_to lv_raw_rest.
    IF sy-subrc = 0.
      wa_xls-table = lv_raw_table.
      wa_xls-field = lv_raw_field.
      wa_xls-from = lv_raw_value_from.
      wa_xls-to = lv_raw_value_to.
      APPEND wa_xls TO it_xls.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "sub_text_convert_csv_to_sap


*&---------------------------------------------------------------------*
*&      Form  sub_get_line_length
*&---------------------------------------------------------------------*
*       Returns the length of the lines of a table in bytes. Used for
*       estimating the expected data volume of the background job.
*----------------------------------------------------------------------*
*      -->VALUE(UD_TABNAME)     Input parameter: Table for which line
*                               length is required. Must be of type
*                               TABNAME.
*      -->VALUE(UT_FIELDS)      Input parameter: The table containing
*                               all fields that are specified in the
*                               input file as relevant for output.
*                               Fields are only considered for line
*                               length if the are listed in this table.
*      -->VALUE(CD_LINELENGTH)  Output parameter: Length of the table
*                               lines in bytes.
*----------------------------------------------------------------------*
FORM sub_get_line_length USING VALUE(ud_tabname) TYPE TABNAME
                               ut_fields LIKE it_fields
                         CHANGING VALUE(cd_linelength) TYPE i.

  DATA lt_tableinfo TYPE TABLE OF DFIES.
  DATA lf_tableinfo TYPE DFIES.
  DATA lf_linelength TYPE i.

  CALL FUNCTION 'DDIF_FIELDINFO_GET'
    EXPORTING
      tabname   = ud_tabname
    TABLES
      dfies_tab = lt_tableinfo.

* Function returns a table with multi-dimensional entries which contain
* metadata for each column of the data table, including the internal length
* of the column in bytes. Loop through this table.
  LOOP AT lt_tableinfo INTO lf_tableinfo.

* Check if entry for current table and field exists in input table it_fields.
* If yes, add length of current field to length of line.
    READ TABLE ut_fields
    WITH KEY tabname = ud_tabname
             fieldname = lf_tableinfo-fieldname TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.
      lf_linelength = lf_linelength + ( lf_tableinfo-leng * 2 ).
    ENDIF.
  ENDLOOP.

* Return calculated value.
  cd_linelength = lf_linelength.

ENDFORM.                    "sub_get_line_length


*&---------------------------------------------------------------------*
*&      Form  sub_convert_bytes_to_unit
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->VALUE(UD_BYTES)       text
*      -->VALUE(CD_OUTPUTCHAR)  text
*----------------------------------------------------------------------*
FORM sub_convert_bytes_to_unit USING VALUE(ud_bytes) TYPE p
                               CHANGING VALUE(cd_outputchar) TYPE c.

  DATA lf_current_length TYPE p DECIMALS 2.
  DATA lf_conversion_helper TYPE p DECIMALS 2.
  DATA lf_conversion_level TYPE i.
  DATA lf_data_unit(2) TYPE c.
  DATA lf_outputchar(30) TYPE c.

  lf_current_length = ud_bytes.

* Check how often the original filesize in Bytes can be divided by 1024.
* Each time the number is divided successfully, the conversion level is
* increased.
  DO.
    lf_conversion_helper = lf_current_length / 1024.
    IF lf_conversion_helper > 1.
      lf_current_length = lf_conversion_helper.
      lf_conversion_level = lf_conversion_level + 1.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.

* Determine correct unit depending on how many times the original filesize
* in Bytes could be divided by 1024.
  CASE lf_conversion_level.
    WHEN 0.
      lf_data_unit = 'B'.
    WHEN 1.
      lf_data_unit = 'KB'.
    WHEN 2.
      lf_data_unit = 'MB'.
    WHEN 3.
      lf_data_unit = 'GB'.
    WHEN 4.
      lf_data_unit = 'TB'.
    WHEN OTHERS.
* In case a bigger unit than TB should be used, a dummy unit is returned.
      lf_data_unit = 'xB'.
  ENDCASE.

  WRITE lf_current_length TO lf_outputchar LEFT-JUSTIFIED.
  CONCATENATE lf_outputchar lf_data_unit INTO lf_outputchar SEPARATED BY space.

  cd_outputchar = lf_outputchar.

ENDFORM.                    "sub_convert_bytes_to_unit


*&---------------------------------------------------------------------*
*&      Form  sub_write_volume_info
*&---------------------------------------------------------------------*
*       Generates char that contains all available information about
*       the estimated data volume of a given table.
*----------------------------------------------------------------------*
*      -->VALUE(UD_TABLENAME)    Input parameter: Name of the given table
*      -->VALUE(UD_TABLELENGTH)  Input parameter: Number of lines in the
*                                table.
*      -->VALUE(UD_LINELENGTH)   Input parameter: Maximum length of each
*                                table line in bytes.
*      -->VALUE(UD_MAXBYTES)     Input parameter: Maximum size of entire
*                                table in bytes.
*      -->VALUE(UD_ESTBYTES)     Input parameter: Estimated size of entire
*                                table in bytes.
*      -->VALUE(CD_VOLUMEINFO)   Output parameter: Formatted char
*                                containing all relevant information.
*----------------------------------------------------------------------*
FORM sub_write_volume_info USING VALUE(ud_tablename) TYPE tabname
                                 VALUE(ud_tablelength) TYPE i
                                 VALUE(ud_linelength) TYPE i
                                 VALUE(ud_maxbytes) TYPE p
                                 VALUE(ud_estbytes) TYPE p
                           CHANGING VALUE(cd_volumeinfo) TYPE c.

* Create text variables
  DATA lf_temptext(30) TYPE c.
  DATA lf_outputchar(140) TYPE c.

* Fill outputchar with all information already available.
  lf_outputchar+0 = ud_tablename.

  WRITE ud_tablelength TO lf_temptext LEFT-JUSTIFIED.
  lf_outputchar+20 = lf_temptext.

  WRITE ud_linelength TO lf_temptext LEFT-JUSTIFIED.
  lf_outputchar+40 = lf_temptext.

* Add maximum filesize to outputchar.
  PERFORM sub_convert_bytes_to_unit USING ud_maxbytes CHANGING lf_temptext.
  lf_outputchar+60 = lf_temptext.

* Add estimated filesize to outputchar.
  PERFORM sub_convert_bytes_to_unit USING ud_estbytes CHANGING lf_temptext.
  lf_outputchar+90 = lf_temptext.

* Return.
  cd_volumeinfo = lf_outputchar.
ENDFORM.                    "sub_write_volume_info


*&---------------------------------------------------------------------*
*&      Form  sub_get_estimated_bytesize
*&---------------------------------------------------------------------*
*       Calculate the estimated size of a table in bytes based on the
*       number of lines and the maximum byte length of each line. A
*       data space utilization of 50% is assumed for files smaller than
*       10MB and 70% for files bigger than 10MB.
*----------------------------------------------------------------------*
*      -->VALUE(UD_BYTES)               Input parameter: Maximum size of
*                                       the complete table in bytes.
*      -->VALUE(CD_ESTIMATED_BYTESIZE)  Output parameter: Estimated size
*                                       of the complete table in bytes.
*----------------------------------------------------------------------*
FORM sub_get_estimated_bytesize USING VALUE(ud_bytes) TYPE p
                                CHANGING VALUE(cd_estimated_bytesize) TYPE p.

* Create variables.
  DATA lf_bytes TYPE p DECIMALS 2.

* Is maximum table bigger than 10MB? Adjust estimation outcome accordingly.
  IF ud_bytes > 10485760.
    lf_bytes = ( ud_bytes / 100 ) * 65.
  ELSE.
    lf_bytes = ( ud_bytes / 100 ) * 50.
  ENDIF.

* Return
  cd_estimated_bytesize = lf_bytes.

ENDFORM.                    "sub_get_estimated_bytesize

*&---------------------------------------------------------------------*
*&      Form  sub_get_estimated_zipsize
*&---------------------------------------------------------------------*
*       Calculate the estimated size of a zip archive compressing a file
*       of a given size in bytes. A compression rate of 85% is assumed
*       for files smaller than 30MB and 95% for files bigger than 30MB.
*----------------------------------------------------------------------*
*      -->VALUE(UD_BYTES)              Input parameter: Size of the
*                                      uncompressed file in bytes.
*      -->VALUE(CD_ESTIMATED_ZIPSIZE)  Output parameter: Estimated size
*                                      of the compressed file in bytes.
*----------------------------------------------------------------------*
FORM sub_get_estimated_zipsize USING VALUE(ud_bytes) TYPE p
                               CHANGING VALUE(cd_estimated_zipsize) TYPE p.

* Create variables..
  DATA lf_bytes TYPE p DECIMALS 2.

* Is estimated table size bigger than 30MB? Adjust estimated size of zip archive accordingly.
  IF ud_bytes > 31457280.
    lf_bytes = ( ud_bytes / 100 ) * 5.
  ELSE.
    lf_bytes = ( ud_bytes / 100 ) * 15.
  ENDIF.

* Return
  cd_estimated_zipsize = lf_bytes.

ENDFORM.                    "sub_get_estimated_zipsize
*&---------------------------------------------------------------------*
*&      Form  sub_validate_logical_file_path
*&---------------------------------------------------------------------*
*       Validates a given path agains a previously defined logical path
*       Returns information if path is valid
*
*----------------------------------------------------------------------*
*      -->VALUE(LOGICALFILE)          Input parameter: Correct logical file name
*      -->VALUE(PATH)                  Input parameter: Path to validate
*      -->VALUE(ISVALID)               Output parameter: "Verdict" if path is valid.
*----------------------------------------------------------------------*
FORM sub_validate_logical_file_path USING VALUE(LOGICALFILE) TYPE FILEINTERN
                                          VALUE(PATH) TYPE c
                                    CHANGING VALUE(ISVALID) TYPE c.
** Root directory of valid path
DATA lv_root(500) TYPE c.

CALL FUNCTION 'FILE_GET_NAME' "#EC NOTEXT
  EXPORTING
    LOGICAL_FILENAME = LOGICALFILE
    INCLUDING_DIR    = 'X'
  IMPORTING
    file_name        = lv_root
  EXCEPTIONS
    FILE_NOT_FOUND = 1.

** Raise Exception if FILE_GET_NAME fails
IF sy-subrc = 1.
    WRITE 'Logical Filename not found'. "#EC NOTEXT
    EXIT.
  ELSEIF sy-subrc <> 0.
    WRITE 'Path validation failed.'. "#EC NOTEXT
    EXIT.
ENDIF.

** Convert path to validate to an absolute path if it not already is
DATA lv_absolutePathToValidate(500) type c.

** Check if path is relative
** Return value of CL_FS_PATH->IS_RELATIVE
DATA ld_RESULT TYPE c LENGTH 1. " 'X':=true, '':=false

** Create reference and instance of class CL_FS_PATH
Data ref_CL_FS_PATH type ref to cl_fs_path.
ref_CL_FS_PATH = cl_fs_path=>create( PATH ).

** Call Method IS_RELATIVE
ref_CL_FS_PATH->IS_RELATIVE(
   RECEIVING
   RESULT = ld_RESULT
 ).

** Convert to absolute path if it is relative
IF ld_RESULT = 'X'. "relative
  CONCATENATE lv_root PATH 'test.csv' INTO lv_absolutePathToValidate. "#EC NOTEXT
ELSE. "absolute
  CONCATENATE PATH 'test.csv' INTO lv_absolutePathToValidate.
ENDIF.

** Validate absolute path
CALL FUNCTION 'FILE_VALIDATE_NAME' "#EC NOTEXT
    EXPORTING
      logical_filename           = LOGICALFILE
      operating_system           = SY-OPSYS
    CHANGING
      physical_filename          = lv_absolutePathToValidate
    EXCEPTIONS "0=success
      LOGICAL_FILENAME_NOT_FOUND = 2
      VALIDATION_FAILED          = 1
      OTHERS                     = 4.

** Return validation result
IF sy-subrc = 0.
    ISVALID = 'X'.
  ELSE.
    ISVALID = ''.
ENDIF.

ENDFORM.
