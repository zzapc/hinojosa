REPORT zsql_apc MESSAGE-ID zsql_free.

TYPE-POOLS: abap, icon, rsds, sqlt, trdev, slis.

TYPES: lty_commandtype(2) TYPE n.
TYPES: lty_keycol_type TYPE c.
TYPES: lty_last_display_mode TYPE c.
TYPES: lty_commandid TYPE i.
TYPES: lty_zhtdb_table_type TYPE c.

TYPES: lty_zhtdb_vrange_text(255) TYPE c.

TYPES: BEGIN OF lty_zhtdb_alv_tab,
         ddtext    TYPE lty_zhtdb_vrange_text,
         tablename TYPE tabname,
         fieldname TYPE fieldname,
         alias     TYPE tabname,
       END OF lty_zhtdb_alv_tab.

TYPES: BEGIN OF lty_zhtdb_checktable_struc,
         tabname    TYPE tabname,
         fieldname  TYPE forfield,
         forkey     TYPE forkey,
         cardleft   TYPE cardleft,
         card       TYPE card,
         checktable TYPE checktable,
       END OF lty_zhtdb_checktable_struc.

TYPES: lty_zhtdb_join_text(512) TYPE c.

TYPES: BEGIN OF lty_zhtdb_checktable_struc_alv,
         tabname  TYPE tabname,
         ddtext   TYPE as4text,
         longtext TYPE lty_zhtdb_join_text,
       END OF lty_zhtdb_checktable_struc_alv.

TYPES: BEGIN OF lty_zhtdb_fieldinfo,
         table           TYPE tabname,
         field           TYPE fieldname,
         is_key	         TYPE flag,
         orig_field	     TYPE char50,
         field_alias     TYPE char50,
         table_alias     TYPE char50,
         agg_function	   TYPE char50,
         distinctf       TYPE flag,
         generated_field TYPE char50,
         samecount       TYPE int4,
       END OF lty_zhtdb_fieldinfo.

TYPES: BEGIN OF lty_zhtdb_keyword,
         keyword   TYPE string,
         required	 TYPE c,
         order_pos TYPE i,
         begins_at TYPE i,
         ends_at   TYPE i,
         additions TYPE string,
         text	     TYPE string,
       END OF lty_zhtdb_keyword.

TYPES: BEGIN OF lty_zhtdb_sign_pos,
         position TYPE i,
         type(3)  TYPE c,
       END OF lty_zhtdb_sign_pos.

TYPES: BEGIN OF lty_zhtdb_table_aliases,
         table         TYPE tabname,
         alias         TYPE  string,
         explain_alias TYPE string,
         type	         TYPE lty_zhtdb_table_type,
         position	     TYPE i,
       END OF lty_zhtdb_table_aliases.

TYPES: lty_zhtdbt_string_tab TYPE TABLE OF string.


TYPES: lty_zhtdb_fieldinfo_tt TYPE TABLE OF lty_zhtdb_fieldinfo.
TYPES: lty_zhtdb_sign_pos_tt TYPE TABLE OF lty_zhtdb_sign_pos.



TYPES: lty_zhtdb_table_aliases_tt TYPE TABLE OF lty_zhtdb_table_aliases.

TYPES: BEGIN OF lty_zhdb_vrange,
         alias      TYPE tabname,
         rsds_range TYPE rsds_range,
       END OF lty_zhdb_vrange.

TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

CONSTANTS: gc_line_length            TYPE i VALUE 132.

CONSTANTS: gc_ctype_select TYPE lty_commandtype VALUE 1,
           gc_ctype_lawb   TYPE lty_commandtype VALUE 4,
           gc_ctype_selfae TYPE lty_commandtype VALUE 5,
           gc_ctype_script TYPE lty_commandtype VALUE 6.


* Distinguish the possible nodes
TYPES: lty_colmn_header TYPE c.

TYPES: BEGIN OF ty_notes,
         line(gc_line_length) TYPE c,
       END OF ty_notes.

TYPES: gty_tb_name  TYPE dd02d-dbtabname,
       gty_fld_name TYPE dd03p-fieldname.

TYPES: gty_fieldinfo     TYPE lty_zhtdb_fieldinfo.

TYPES: gty_table_aliases TYPE lty_zhtdb_table_aliases.

TYPES: BEGIN OF gty_ddicref,
         fieldname  TYPE gty_fld_name,
         checktable TYPE tabname,
         ref_table  TYPE gty_tb_name,
         ref_field  TYPE gty_fld_name,
         key        TYPE c,
       END OF gty_ddicref.

TYPES: BEGIN OF source,
         line(gc_line_length) TYPE c,
       END OF source.

*source_table TYPE rcg_bag_rssource.
TYPES: source_table    TYPE soli_tab.

TYPES: gty_commandtext TYPE string.

TYPES: BEGIN OF gty_linkedquery,
         fcode         TYPE ui_func,
         tabname       TYPE gty_tb_name,
         checktable    TYPE gty_tb_name,
         fieldname     TYPE gty_fld_name,
         checkfield    TYPE gty_fld_name,
         text(40)      TYPE c,
         longtext(255) TYPE c,
         join_type     TYPE c,
         ddtext        TYPE dd02t-ddtext,
         primpos       TYPE dd05m-primpos,
       END OF gty_linkedquery.

TYPES: BEGIN OF gty_ranges,
*        tablename     TYPE dd02d-dbtabname,
         table_alias TYPE string,
         fieldname   TYPE dd03p-fieldname,
         range       TYPE rsds_selopt_t,
         node_text   TYPE lvc_value,
         node_key    TYPE lvc_nkey,
         where_text  TYPE string,
       END OF gty_ranges.

TYPES: BEGIN OF gty_tab_node_xref,
         node_key  TYPE lvc_nkey,
         tablename TYPE tabname,
         alias     TYPE string,
       END OF gty_tab_node_xref.

TYPES: BEGIN OF gty_alias_ranges,
         table_alias TYPE string,
         fields      TYPE rsdsfields_t,
         expr        TYPE rsds_texpr, " zhtdb_exprtab,
         sel_id      TYPE rsdynsel-selid,
         active      TYPE i,
       END OF gty_alias_ranges.

TYPES: BEGIN OF mty_t_type,
         line(255),
       END OF mty_t_type.

FIELD-SYMBOLS: <gt_result>  TYPE STANDARD TABLE,
               <gt_display> TYPE STANDARD TABLE,
               <gt_temp>    TYPE STANDARD TABLE,
               <gt_tree>    TYPE STANDARD TABLE,
               <gt_undo>    TYPE STANDARD TABLE,
               <gs_result>,
               <gf_result>,
               <gs_temp>,
               <gs_undo>.


DATA: gv_def_col_hdr     TYPE lty_colmn_header,
      gv_def_keycol_type TYPE lty_keycol_type,

      gv_0100_first_run  TYPE flag VALUE 'X'.

DATA: gs_tab_node_xref TYPE gty_tab_node_xref.

DATA: gs_linkedquery      TYPE gty_linkedquery,
      gt_linkedquery      TYPE TABLE OF gty_linkedquery,

      gs_linkedquery_comp TYPE gty_linkedquery,
      gt_linkedquery_comp TYPE TABLE OF gty_linkedquery.


DATA: gs_ranges              TYPE gty_ranges.

DATA: ok_code      TYPE sy-ucomm.

DATA: g_textedit             TYPE REF TO cl_gui_abapedit. "cl_gui_textedit.

DATA: g_alv              TYPE REF TO cl_gui_alv_grid,
      gs_layo            TYPE lvc_s_layo,
      gt_toolbar_exclude TYPE ui_functions,
      gs_toolbar_exclude TYPE ui_func.

DATA: g_tree_tb         TYPE REF TO cl_gui_alv_tree,
      gs_fcat_tb        TYPE lvc_s_fcat,
      gt_fcat_tb        TYPE lvc_t_fcat,
      gs_layo_tb        TYPE lvc_s_layo,
      gs_outtab_tb      TYPE lty_zhtdb_alv_tab,
      g_toolbar_tb_tree TYPE REF TO cl_gui_toolbar.

DATA: autotrace(1)       TYPE c.


*----------------------------------------------------------------------*
*       CLASS lcl_event_grid DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_grid DEFINITION INHERITING FROM zcl_ap_alv_grid_eventos.
  PUBLIC SECTION.
    METHODS: double_click REDEFINITION,
      user_command REDEFINITION,
      data_changed REDEFINITION.
ENDCLASS.                    "lcl_event_grid DEFINITION

*APC20160419
DATA: o_alv           TYPE REF TO zcl_ap_alv_grid,
      o_event         TYPE REF TO lcl_event_grid,
      i_sql           TYPE TABLE OF ztemps,
      l_sql           TYPE ztemps,
      v_comando       TYPE string,
      i_lineas        TYPE TABLE OF text255,
      l_linea         TYPE text255,
      ztemps          TYPE ztemps,
      *ztemps         TYPE ztemps,
      i_lineas_sql    TYPE source_table,
      v_es_report,
      v_nombre_report TYPE string.




START-OF-SELECTION.

  CALL SCREEN 100.

*&---------------------------------------------------------------------*
*&  Include           ZHTDB_CLASSES                                    *
*&---------------------------------------------------------------------*



CLASS lcl_toolbox DEFINITION.

*"* public components of class LCL_TOOLBOX
*"* do not include other source files here!!!
  PUBLIC SECTION.

    CLASS-METHODS split_string
      IMPORTING
        !iv_string     TYPE string
        !iv_maxlen     TYPE i
        !iv_log_handle TYPE balloghndl OPTIONAL
      EXPORTING
        !et_string_tab TYPE lty_zhtdbt_string_tab.
    CLASS-METHODS get_word_at_pos
      IMPORTING
        !iv_string   TYPE string
        !iv_position TYPE i
      EXPORTING
        !ev_word     TYPE string.
    CLASS-METHODS parse_aptph
      IMPORTING
        !iv_condense   TYPE flag DEFAULT 'X'
        !iv_log_handle TYPE balloghndl OPTIONAL
      EXPORTING
        !et_aptph_pos  TYPE lty_zhtdb_sign_pos_tt
        !et_paranth    TYPE lty_zhtdb_sign_pos_tt
      CHANGING
        !cv_string     TYPE string
      EXCEPTIONS
        missing_aptph
        missing_parnth .
    CLASS-METHODS select_single_gen
      IMPORTING
        !is_key_value  TYPE REF TO data
        !iv_table_name TYPE strukname
        !it_keyf_list  TYPE lty_zhtdbt_string_tab
      EXPORTING
        !es_record     TYPE REF TO data .
    CLASS-METHODS convert_to_uppercase
      CHANGING
        !cv_string TYPE string .
    CLASS-METHODS pretty_printer
      CHANGING
        !ct_source TYPE soli_tab .
    CLASS-METHODS is_client_field
      IMPORTING
        !iv_tabname            TYPE tabname
        !iv_fieldname          TYPE fieldname
      RETURNING
        VALUE(ev_client_field) TYPE char1 .
    CLASS-METHODS has_client_field
      IMPORTING
        !iv_tabname                TYPE tabname
      RETURNING
        VALUE(ev_has_client_field) TYPE char1 .
    CLASS-METHODS pretty_printer_string
      CHANGING
        !ct_source TYPE lty_zhtdbt_string_tab .

ENDCLASS.                    "LCL_TOOLBOX DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_TOOLBOX IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_toolbox IMPLEMENTATION.

  METHOD get_word_at_pos.

    DATA: lv_length TYPE i,
          lv_char   TYPE char1,
          lv_shift  TYPE i,
          lv_start  TYPE i,
          lv_end    TYPE i.


    lv_length = strlen( iv_string ).

* check if position is valid
    IF lv_length   < iv_position OR
       iv_position < 1.
      RETURN.
    ENDIF.

    lv_shift = iv_position - 1.
    lv_char = iv_string+lv_shift(1).

* space does not matter
    IF lv_char = space.
      RETURN.
    ENDIF.

* determine start
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.

      lv_shift = lv_shift - 1.
      IF lv_shift < 0.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.
    ENDDO.

* determine end
    lv_shift = iv_position - 1.
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_end = lv_shift.
        EXIT.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift = lv_length.
        lv_end = lv_shift.
        EXIT.
      ENDIF.
    ENDDO.

    lv_length = lv_end - lv_start.
    ev_word = iv_string+lv_start(lv_length).

  ENDMETHOD.                    "

  METHOD split_string.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          ls_aptph_pos TYPE lty_zhtdb_sign_pos,
          lv_string    TYPE string,
          lv_newstr    TYPE string,
          lv_actstr    TYPE string,
          lv_char      TYPE c,
          lv_shift     TYPE i,
          lv_lastsp    TYPE i,
          lv_length    TYPE i,
          lv_strg_lgth TYPE i,
          lv_index     TYPE i.


    IF iv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_string = iv_string.

    parse_aptph( EXPORTING  iv_condense   = space
                            iv_log_handle = iv_log_handle
                 IMPORTING  et_aptph_pos  = lt_aptph_pos
                 CHANGING   cv_string     = lv_string
                 EXCEPTIONS OTHERS        = 1 ).

    lv_shift = -1.
    lv_strg_lgth = strlen( lv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = lv_string+lv_shift(1).  " current character

      IF lv_char = space.
        CONCATENATE lv_actstr lv_char INTO lv_actstr
          SEPARATED BY space.   " otherwise the SPACE will be lost ...
        lv_length = lv_length + 1.

*     check, if the SPACE is inside of apostrophes
        lv_index = lv_shift + 1.
        READ TABLE lt_aptph_pos INDEX lv_index INTO ls_aptph_pos.

        IF ls_aptph_pos-type = 'O'.  " outside of apostrophes
          IF lv_length > iv_maxlen.
*       the length of actual line is bigger than the maximum allowed
            IF lv_lastsp <> 0.   " there is a right position to cut
*           cut string at the last SPACE to get the current line
              lv_newstr = lv_actstr(lv_lastsp).
              IF lv_newstr(1) = '*'.
                SHIFT lv_newstr RIGHT BY 1 PLACES.
              ENDIF.

*           the rest is the new line
              lv_actstr = lv_actstr+lv_lastsp.
              lv_length = lv_length - lv_lastsp.
              lv_lastsp = lv_length.
              APPEND lv_newstr TO et_string_tab.

*           the new line might be already longer, than allowed
              IF lv_length >= iv_maxlen.
                IF lv_actstr(1) = '*'.
                  SHIFT lv_actstr RIGHT BY 1 PLACES.
                ENDIF.
                APPEND lv_actstr TO et_string_tab.
                CLEAR lv_actstr.
                lv_length = 0.
              ENDIF.
            ELSE.    " there is no right position to cut
              IF lv_actstr(1) = '*'.
                SHIFT lv_actstr RIGHT BY 1 PLACES.
              ENDIF.
              APPEND lv_actstr TO et_string_tab.
              CLEAR lv_actstr.
              lv_length = 0.
            ENDIF.
          ELSE.
*         this is the position of the last SPACE, where the string can be cut,
*         if no better position will be found
            lv_lastsp = lv_length.
          ENDIF.
        ENDIF.
      ELSE.    " not a SPACE
        CONCATENATE lv_actstr lv_char INTO lv_actstr.
        lv_length = lv_length + 1.
      ENDIF.
    ENDDO.

    IF lv_actstr IS NOT INITIAL.
      IF lv_length > iv_maxlen.
*   the length of actual line is bigger than the maximum allowed
        IF lv_lastsp <> 0.   " there is a right position to cut
*       cut string at the last SPACE to get the current line
          lv_newstr = lv_actstr(lv_lastsp).
          IF lv_newstr(1) = '*'.
            SHIFT lv_newstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_newstr TO et_string_tab.

*       the rest is the new line
          lv_actstr = lv_actstr+lv_lastsp.
          IF lv_actstr(1) = '*'.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ELSE.    " there is no right position to cut
          IF lv_actstr(1) = '*'.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ENDIF.
      ELSE.  " length OK
        IF lv_actstr(1) = '*'.
          SHIFT lv_actstr RIGHT BY 1 PLACES.
        ENDIF.
        APPEND lv_actstr TO et_string_tab.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_aptph.
* fills up the et_aptph_pos table: for each character of the command
* it sets the following flag:
*  - O - if the character is not part of a text
*  - A - if it is an apostrophe
*  - I - if it is part of a text

* fills up the et_paranth table with the positions of paranthesis

* executes a kind of CONDENSE, but outside of apostrophes only

    DATA: ls_aptph     LIKE LINE OF et_aptph_pos,
          ls_paranth   LIKE LINE OF et_aptph_pos,

          lv_strg_lgth TYPE i,
          lv_char      TYPE c,

          lv_shift     TYPE i,
          lv_shift_sp  TYPE i,
          lv_shift_end TYPE i,
          lv_next      TYPE i,
          lv_in_apostr TYPE xfeld,
          lv_par_cnt   TYPE i.


    IF cv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_shift = -1.
    lv_strg_lgth = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).  " current character

      IF lv_char = ''''.

        IF lv_in_apostr = ' '.
*       => beginning of a text
          lv_in_apostr = 'X'.   " mark, that we are within a text

          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = 'A'.
          APPEND ls_aptph TO et_aptph_pos.

          CONTINUE.
        ENDIF.

*     we are within a text

*     the next apostrophe closes the text, if it isn't doubled!
*     then both will be ignored
*     => the next character must be checked
        lv_next = lv_shift + 1.

        IF lv_next < lv_strg_lgth.

          IF cv_string+lv_next(1) = ''''.
*         these two apostrophes will be ignored
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = 'I'.
            APPEND ls_aptph TO et_aptph_pos.

            ls_aptph-position = lv_shift + 2.
            APPEND ls_aptph TO et_aptph_pos.

            lv_shift = lv_shift + 1.  " skip next character
          ELSE.
*         this apostrophe closes the text
            IF lv_in_apostr = 'X'.
              lv_in_apostr = ' '.   " mark, that we are not in a text
            ENDIF.
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = 'A'.
            APPEND ls_aptph TO et_aptph_pos.
          ENDIF.

        ELSE.

*       this apostrophe closes the text
          IF lv_in_apostr = 'X'.
            lv_in_apostr = ' '.   " mark, that we are not in a text
          ENDIF.
          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = 'A'.
          APPEND ls_aptph TO et_aptph_pos.

        ENDIF.

      ELSE.  " lv_char <> ''''

        ls_aptph-position = lv_shift + 1.
        IF lv_in_apostr = 'X'.  " inside a text
          ls_aptph-type = 'I'.
        ELSE.
          ls_aptph-type = 'O'.  " outside of text
        ENDIF.
        APPEND ls_aptph TO et_aptph_pos.

*     check for '('
        IF lv_char      = '(' AND
           lv_in_apostr = ' '.    " not in a text

          lv_par_cnt = lv_par_cnt + 1.
          ls_paranth-type = lv_par_cnt.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

*     check for ')'
        IF lv_char      = ')' AND
           lv_in_apostr = ' '.    " not in a text

          ls_paranth-type = lv_par_cnt.
          lv_par_cnt = lv_par_cnt - 1.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

        IF iv_condense = 'X'.
*       condense SPACEs (outside of apostrophes only!)
          IF lv_char      = space AND
             lv_in_apostr = ' '.

            lv_shift_sp  = lv_shift + 1.
            lv_shift_end = lv_shift + 2.

            IF lv_shift_sp >= lv_strg_lgth.
              EXIT.
            ENDIF.

            DO.
              IF lv_shift_sp >= lv_strg_lgth.
                EXIT.
              ENDIF.

              lv_char = cv_string+lv_shift_sp(1).
              IF lv_char = space.
                lv_strg_lgth = lv_strg_lgth - 1.
*             remove SPACE from position lv_shift_sp + 1
                CONCATENATE cv_string(lv_shift_sp) cv_string+lv_shift_end INTO cv_string.
              ELSE.
                EXIT.
              ENDIF.
            ENDDO.

          ENDIF.
        ENDIF.

      ENDIF.

    ENDDO.

    IF lv_in_apostr = 'X'.  " the command was not closed properly

      IF iv_log_handle IS INITIAL.
*     Message: An ending apostrophe is missing
        MESSAGE e005 RAISING missing_aptph.
      ELSE.
        RAISE missing_aptph.
      ENDIF.

    ENDIF.

    IF lv_par_cnt <> 0.  " the command was not closed properly
      IF iv_log_handle IS INITIAL.
*     Message: An closing paranthesis is missing
        MESSAGE e059 RAISING missing_parnth.
      ELSE.
        RAISE missing_parnth.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD select_single_gen.

    DATA: lv_keyfield TYPE fieldname,
          lr_data     TYPE REF TO data,
          lv_where    TYPE string,
          lv_keyval   TYPE string.

    FIELD-SYMBOLS: <ls_data>      TYPE any,
                   <lv_keyval>    TYPE any,
                   <ls_keyfields> TYPE any.


* create work area
    CREATE DATA lr_data TYPE (iv_table_name).
    ASSIGN lr_data->* TO <ls_data>.

    ASSIGN is_key_value->* TO <ls_keyfields>.

* create WHERE clause
    LOOP AT it_keyf_list INTO lv_keyfield.
      IF lv_where IS NOT INITIAL.
        CONCATENATE lv_where 'AND' INTO lv_where
          SEPARATED BY space.
      ENDIF.

      ASSIGN COMPONENT lv_keyfield OF STRUCTURE <ls_keyfields> TO <lv_keyval>.
      lv_keyval = <lv_keyval>.

      CONCATENATE lv_where lv_keyfield '= ''' INTO lv_where
        SEPARATED BY space.
      CONCATENATE lv_where lv_keyval '''' INTO lv_where.
    ENDLOOP.

    SELECT SINGLE * FROM (iv_table_name) INTO <ls_data>
      WHERE (lv_where).

    es_record = lr_data.

  ENDMETHOD.                    "

  METHOD convert_to_uppercase.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          lv_aptph     TYPE lty_zhtdb_sign_pos,
          lv_char      TYPE c,
          lv_uppercase TYPE string.


    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_condense    = ' '
        iv_log_handle  = 'DUMMY'
      IMPORTING
        et_aptph_pos   = lt_aptph_pos
      CHANGING
        cv_string      = cv_string
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    LOOP AT lt_aptph_pos INTO lv_aptph.

      lv_aptph-position = lv_aptph-position - 1.
      lv_char = cv_string+lv_aptph-position(1).

      IF lv_aptph-type EQ 'O'.
        TRANSLATE lv_char TO UPPER CASE.
      ENDIF.

      IF lv_char = space.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase SEPARATED BY space.   " otherwise the SPACE will be lost ...
      ELSE.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase.
      ENDIF.

    ENDLOOP.

    cv_string = lv_uppercase.

  ENDMETHOD.                    "convert_to_uppercase

  METHOD pretty_printer.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_string TYPE string,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.
      lv_string = ls_source-line.

      CALL METHOD lcl_toolbox=>convert_to_uppercase
        CHANGING
          cv_string = lv_string.

      ls_source-line = lv_string.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    "pretty_printer

  METHOD is_client_field.

    DATA: lv_datatype  TYPE dd03l-datatype,
          lv_fieldname TYPE fieldname,
          lv_tabname   TYPE tabname,

          lt_x031l_tab TYPE TABLE OF x031l,
          ls_x031l     TYPE x031l.

    CLEAR ev_client_field.

    lv_tabname   = iv_tabname.
    lv_fieldname = iv_fieldname.

    TRANSLATE lv_tabname   TO UPPER CASE.
    TRANSLATE lv_fieldname TO UPPER CASE.

    SELECT SINGLE datatype
      FROM dd03l INTO lv_datatype
      WHERE tabname   = lv_tabname AND
            fieldname = lv_fieldname AND
            keyflag   = 'X'.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'DD_DICTIONARY_TO_NAMETAB'
        EXPORTING
          foreign_key = ' '
          status      = 'A'
          tabname     = lv_tabname
        TABLES
          x031l_tab   = lt_x031l_tab.

      IF sy-subrc EQ 0.
        READ TABLE lt_x031l_tab INTO ls_x031l
          WITH KEY fieldname = lv_fieldname.

        IF ls_x031l-dtyp = 'CLNT' AND ls_x031l-position = 1.
          ev_client_field = 'X'.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "is_client_field

  METHOD has_client_field.

    DATA: x030l_wa TYPE x030l.


    CLEAR ev_has_client_field.

    CHECK iv_tabname IS NOT INITIAL.

    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = iv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos NE 0.
      ev_has_client_field = 'X'.
    ENDIF.

  ENDMETHOD.                    "has_client_field

  METHOD pretty_printer_string.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.

      CALL METHOD lcl_toolbox=>convert_to_uppercase
        CHANGING
          cv_string = ls_source.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    "pretty_printer_string


ENDCLASS.                    "LCL_TOOLBOX IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_lawb DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb IMPLEMENTATION.

ENDCLASS.                    "lcl_lawb IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_select_fae_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command IMPLEMENTATION.

ENDCLASS.                    "lcl_select_fae_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_update_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command IMPLEMENTATION.

ENDCLASS.                    "lcl_update_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_delete_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command IMPLEMENTATION.

ENDCLASS.                    "lcl_delete_command IMPLEMENTATION




*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command DEFINITION.

*"* public components of class lcl_htdb_cl_command
*"* do not include other source files here!!!
  PUBLIC SECTION.

    TYPES: BEGIN OF lty_zhdb_vrange,
             alias      TYPE tabname,
             rsds_range TYPE rsds_range,
           END OF lty_zhdb_vrange.

    TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

    METHODS create_new
      IMPORTING
        !iv_command_id     TYPE lty_commandid OPTIONAL
        !iv_command        TYPE string
        !it_vranges        TYPE lty_zhdb_vrange_tab OPTIONAL
        !iv_log_handle     TYPE balloghndl OPTIONAL
        !iv_test_from_file TYPE c OPTIONAL
      EXCEPTIONS
        no_id .
    METHODS is_client_spec
      RETURNING
        VALUE(ev_cspec) TYPE flag .
    METHODS constructor
      EXCEPTIONS
        no_id .
    METHODS get_id
      EXPORTING
        !ev_id TYPE guid_32 .
    METHODS execute
      IMPORTING
        !iv_simulation          TYPE flag OPTIONAL
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        VALUE(er_result)        TYPE REF TO data
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
        !ev_job_name            TYPE btcjob
        !ev_job_count           TYPE btcjobcnt
        !et_srccode             TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        parse_error
        exec_error
        job_submit_error
        table_locked
        no_auth_for_table
        no_auth_for_columns .
    METHODS parse
      EXCEPTIONS
        parse_error
        no_auth_for_table .
    METHODS get_message_dropped
      RETURNING
        VALUE(ev_message_dropped) TYPE char1 .
    METHODS get_where
      RETURNING
        VALUE(es_where) TYPE lty_zhtdb_keyword .
    METHODS get_command
      RETURNING
        VALUE(ev_command) TYPE string .
    TYPE-POOLS rsds .

*"* protected components of class lcl_htdb_cl_command
*"* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES gty_keyword TYPE lty_zhtdb_keyword .

    DATA mv_command_id TYPE lty_commandid .
    DATA mv_parsed TYPE flag .
    DATA mv_prog_id TYPE guid_32. "lty_gen_prog_nro .
    DATA mv_command TYPE string .
    DATA mt_vranges TYPE lty_zhdb_vrange_tab .
    DATA:
      mt_keywords TYPE STANDARD TABLE OF gty_keyword .
    DATA mt_aptph_pos TYPE lty_zhtdb_sign_pos_tt .
    CONSTANTS mc_prog_prefix TYPE string VALUE 'Z'.  " 'ZENITH_'. "#EC NOTEXT
    DATA mv_log_handle TYPE balloghndl .
    DATA ms_s_msg TYPE bal_s_msg .
    DATA mv_test_from_file TYPE c .
    DATA mv_message_dropped TYPE char1 .
    DATA mt_paranth TYPE lty_zhtdb_sign_pos_tt .
    DATA mt_query_depth TYPE lty_zhtdb_sign_pos_tt .
    DATA mv_jobname TYPE btcjob .
    DATA mv_jobcount TYPE btcjobcnt .
    METHODS call_gen_form
      IMPORTING
        !iv_program             TYPE programm
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_result)        TYPE REF TO data
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
      EXCEPTIONS
        error
        job_submit_error
        table_locked .
    METHODS create_program
      IMPORTING
        !iv_program             TYPE programm
        !it_srccode             TYPE lty_zhtdbt_string_tab
        !iv_force_insert_report TYPE c OPTIONAL
      EXPORTING
        !ev_msg                 TYPE string
        !ev_line                TYPE int4
      EXCEPTIONS
        syntax_error
        internal_error .
    METHODS det_subquery .
    METHODS execute_int
      IMPORTING
        !iv_simulation          TYPE flag OPTIONAL
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_result)        TYPE REF TO data
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
        !et_srccode             TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        syntax_error
        error
        job_submit_error
        table_locked
        no_auth_for_columns .
    METHODS generate_srccode
      EXPORTING
        et_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS generate_vranges
      EXPORTING
        !et_srccode TYPE lty_zhtdbt_string_tab .
    METHODS parse_keywords
      EXCEPTIONS
        missing_keyword
        wrong_position
        wrong_keyword .
    METHODS parse_check_dot
      EXCEPTIONS
        parse_error .
    METHODS split_string
      IMPORTING
        !iv_string TYPE string
      EXPORTING
        et_words   TYPE lty_zhtdbt_string_tab .
    METHODS add_message
      IMPORTING
        !iv_msgty TYPE symsgty
        !iv_msgid TYPE symsgid
        !iv_msgno TYPE symsgno
        !iv_msgv1 TYPE any OPTIONAL
        !iv_msgv2 TYPE any OPTIONAL
        !iv_msgv3 TYPE any OPTIONAL
        !iv_msgv4 TYPE any OPTIONAL .

    TYPE-POOLS rsds .

ENDCLASS.                    "LCL_HTDB_CL_COMMAND DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command IMPLEMENTATION.


  METHOD call_gen_form.
* calls the generated program to execute the command

    DATA: lx_root   TYPE REF TO cx_root,
          lv_locked TYPE flag.

* execute command
    TRY.
        PERFORM exec_command IN PROGRAM (iv_program)
          TABLES mt_vranges
          CHANGING lv_locked
                   ev_dbcnt.
      CATCH cx_root INTO lx_root.
*     Message: Internal error: generated program could not be called
        MESSAGE e003 RAISING error.
    ENDTRY.

    IF lv_locked = 'X'.
*   Message: Table could not be locked
      MESSAGE e146 RAISING table_locked.
    ENDIF.

  ENDMETHOD.                    "

  METHOD create_program.
* creates a repository program, which includes the command

    DATA: lv_program TYPE programm,
          lv_msg     TYPE string,
          lv_line    TYPE n,
          lv_word    TYPE char50,
          lt_str     TYPE TABLE OF string,
          ls_trdir   TYPE trdir,

          lv_str1    TYPE string,
          lv_str2    TYPE string,
          lv_str3    TYPE string,
          lv_str4    TYPE string.


    IF iv_program IS INITIAL.
      RETURN.
    ELSE.
      lv_program = iv_program.
    ENDIF.

* syntax check
    SYNTAX-CHECK FOR it_srccode
      MESSAGE lv_msg
      LINE lv_line
      WORD lv_word
      PROGRAM LV_PROGRAM.

    IF sy-subrc = 4.
      ev_line = lv_line.
      ev_msg  = lv_msg.

      IF mv_log_handle IS INITIAL.
        MESSAGE lv_msg TYPE 'I' DISPLAY LIKE 'E'.
        MESSAGE e019 RAISING syntax_error.
      ELSE.
*     split message to four parts (for four placeholders)
        CALL METHOD lcl_toolbox=>split_string
          EXPORTING
            iv_log_handle = mv_log_handle
            iv_string     = lv_msg
            iv_maxlen     = 50
          IMPORTING
            et_string_tab = lt_str.

        READ TABLE lt_str INTO lv_str1 INDEX 1.
        READ TABLE lt_str INTO lv_str2 INDEX 2.
        READ TABLE lt_str INTO lv_str3 INDEX 3.
        READ TABLE lt_str INTO lv_str4 INDEX 4.

        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = 'ZSQL_FREE'
            iv_msgno = '085'
            iv_msgv1 = lv_str1
            iv_msgv2 = lv_str2
            iv_msgv3 = lv_str3
            iv_msgv4 = lv_str4 ).

        IF iv_force_insert_report EQ 'X'.
*       create program in repository
          TRANSLATE lv_program TO UPPER CASE.            "#EC TRANSLANG
          INSERT REPORT lv_program FROM it_srccode.         "#EC *
        ENDIF.

        RAISE syntax_error.
      ENDIF.

    ELSEIF sy-subrc = 8.
*   Message: Internal error during syntax check

      IF mv_log_handle IS INITIAL.
        MESSAGE e002 RAISING internal_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '002' ).
        RAISE internal_error.
      ENDIF.

    ENDIF.

* create program in repository
    TRANSLATE lv_program TO UPPER CASE.                  "#EC TRANSLANG
    DELETE REPORT LV_PROGRAM.

    lt_str[] = it_srccode[].

    CALL METHOD lcl_toolbox=>pretty_printer_string
      CHANGING
        ct_source = lt_str.

    IF v_es_report = 'X'.
      CLEAR ls_trdir.
      ls_trdir-name = lv_program = LV_PROGRAM.
      ls_trdir-clas = 'TEMP'.
      ls_trdir-dbna = ' '.
      ls_trdir-fixpt = 'X'.
      ls_trdir-rstat = 'P'.
      ls_trdir-subc = '1'.
      ls_trdir-rmand = sy-mandt.
      IF ls_trdir-sqlx LT 'R'.
        ls_trdir-sqlx = 'R'.
      ENDIF.
      MODIFY trdir FROM ls_trdir.
      INSERT REPORT lv_program FROM lt_str.
      GENERATE REPORT lv_program.
    ELSE.
      CLEAR ls_trdir.
      ls_trdir-name = lv_program = LV_PROGRAM.
      ls_trdir-rmand = sy-mandt.

      ls_trdir-subc = '1'.
      ls_trdir-fixpt = 'X'.
      ls_trdir-uccheck = 'X'.

*      cl_demo_output=>display( lt_str ).

      INSERT REPORT lv_program FROM lt_str DIRECTORY ENTRY ls_trdir.
      GENERATE REPORT lv_program.
    ENDIF.


* mert a zsql futtataskor torli a nem lockoltakat!


    CALL FUNCTION 'ENQUEUE_ES_PROG'
      EXPORTING
        mode_trdir     = 'E'
        name           = lv_program
*       X_NAME         = ' '
*       _SCOPE         = '2'
*       _WAIT          = ' '
*       _COLLECT       = ' '
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = sy-msgty
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE internal_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD det_subquery.

    DATA: lv_str_lgth    TYPE i,
          lt_query_depth LIKE mt_query_depth,
          ls_query_depth LIKE LINE OF mt_query_depth,
          ls_depth_old   LIKE LINE OF mt_query_depth,
          ls_depth_new   LIKE LINE OF mt_query_depth,
          lv_act_depth   TYPE i,
          ls_aptph       LIKE LINE OF mt_aptph_pos,
          lv_shift       TYPE i,
          lv_position    TYPE i,
          lv_subq_end    TYPE i,
          lt_subq_end    TYPE STANDARD TABLE OF i,
          lv_depth_old   TYPE i,
          lv_depth_new   TYPE i.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    lv_str_lgth  = strlen( mv_command ).
    lv_act_depth = 1.
    lv_subq_end  = lv_str_lgth.
    APPEND lv_subq_end TO lt_subq_end.

* init lt_query_depth
    ls_query_depth-position = 1.
    ls_query_depth-type     = 1.
    APPEND ls_query_depth TO lt_query_depth.
    ls_query_depth-position = lv_str_lgth.
    ls_query_depth-type     = -1.
    APPEND ls_query_depth TO lt_query_depth.

    DO.
      lv_shift = lv_position + 1.

      SEARCH mv_command
        FOR '. ( SELECT .'
        STARTING AT lv_shift.

      IF sy-subrc EQ 0.
*        DEFINE add_keyword.
        lv_position = sy-fdpos + lv_shift + 1.

        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_position.

        IF ls_aptph-type = 'O'.  " it's not inside a text => found a new subquery
*       determine depth of the suqquery
          LOOP AT lt_subq_end INTO lv_subq_end.
            IF lv_position < lv_subq_end.
              lv_act_depth = lv_act_depth + 1.
              EXIT.
            ELSE.
              lv_act_depth = lv_act_depth - 1.
              DELETE lt_subq_end.
            ENDIF.
          ENDLOOP.

*       mark beginning of the subqery
          ls_query_depth-position = lv_position.
          ls_query_depth-type     = lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.

*       find end of the suqery
          READ TABLE mt_paranth INTO ls_aptph
            WITH KEY position = lv_position.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_shift = sy-tabix + 1.
            LOOP AT mt_paranth FROM lv_shift INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              INSERT lv_subq_end INTO lt_subq_end INDEX 1.
              EXIT.
            ENDLOOP.
          ENDIF.

*       mark end of subqery -> use negative numbers!!
          ls_query_depth-position = lv_subq_end.
          ls_query_depth-type     = - lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.
        ENDIF.
*        END-OF-DEFINITION.
*        add_keyword.
      ELSE.
        EXIT.
*        SEARCH mv_command
*          FOR '. ( UPDATE .'
*          STARTING AT lv_shift.
*        IF sy-subrc = 0.
*          add_keyword.
*        ENDIF.
      ENDIF.

    ENDDO.

    SORT lt_query_depth BY position.

* complete query_depth table
    READ TABLE lt_query_depth INTO ls_depth_old INDEX 1.
    lv_act_depth = 1.

    LOOP AT lt_query_depth INTO ls_query_depth.
*   determine depth
      lv_depth_old = ls_depth_old-type.
      lv_depth_new = ls_query_depth-type.
      IF abs( lv_depth_old ) = abs( lv_depth_new ).
        IF lv_depth_old < lv_depth_new.     " between two subquerys on the same level
          lv_act_depth = lv_depth_new - 1.
        ELSE.
          lv_act_depth = lv_depth_old.       " within one subquery
        ENDIF.
      ELSE.
        IF lv_depth_old < lv_depth_new.      " between subquery and new subquery, one level deeper
          lv_act_depth = lv_depth_old.
        ELSEIF lv_depth_old > lv_depth_new.  " between closed subquery and subquery one level higher
          lv_act_depth = - lv_depth_new.
        ENDIF.
      ENDIF.

*   complete missing positions
      lv_position = ls_depth_old-position + 1.
      WHILE ls_query_depth-position > lv_position.
        ls_depth_new-position = lv_position.
        ls_depth_new-type     = lv_act_depth.
        APPEND ls_depth_new TO mt_query_depth.

        lv_position = lv_position + 1.
      ENDWHILE.

      ls_query_depth-type = abs( ls_query_depth-type ).
      APPEND ls_query_depth TO mt_query_depth.
      ls_depth_old = ls_query_depth.
    ENDLOOP.

  ENDMETHOD.                    "

  METHOD execute_int.
* execute command

    DATA: lt_srccode             TYPE lty_zhtdbt_string_tab,
          lv_line                TYPE string,
          lv_force_insert_report TYPE c,
          lv_program             TYPE programm.


* create source code of the program
    CALL METHOD generate_srccode
      IMPORTING
        et_srccode          = lt_srccode
      EXCEPTIONS
        no_auth_for_columns = 1
        error               = 2
        OTHERS              = 3.

    IF sy-subrc = 1.
      MESSAGE e148 RAISING no_auth_for_columns.
    ELSEIF ( sy-subrc = 2 ) OR ( sy-subrc = 3 ).
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.

* program name
    lv_line = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_line INTO lv_program.
    lv_program = lv_program(30).

*    IF v_es_report = 'X'.
    GET TIME.
    lv_program = 'ZSQL_APC_TEMP' && '_' && SY-UZEIT.
*    ENDIF.

    CALL FUNCTION 'RS_DELETE_PROGRAM'
      EXPORTING
        program            = lv_program
        suppress_checks    = 'X'
        suppress_popup     = 'X'
        with_includes      = ' '
        with_cua           = ' '
        with_documentation = ' '
        with_dynpro        = ' '
        with_textpool      = ' '
        skip_progress_ind  = 'X'
      EXCEPTIONS
        enqueue_lock       = 1
        object_not_found   = 2
        permission_failure = 3
        reject_deletion    = 4
        OTHERS             = 5.

    IF mv_log_handle IS INITIAL.
      CLEAR lv_force_insert_report.
    ELSE.
      lv_force_insert_report = 'X'.
    ENDIF.


* create program in the repository
    CALL METHOD create_program
      EXPORTING
        iv_program             = lv_program
        it_srccode             = lt_srccode
        iv_force_insert_report = lv_force_insert_report
      EXCEPTIONS
        syntax_error           = 1
        internal_error         = 2
        OTHERS                 = 3.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        IF sy-subrc <> 1.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING error.
        ELSE.
*       the syntax check displayed the error already!
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING syntax_error.
        ENDIF.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        IF sy-subrc <> 1.
          RAISE error.
        ELSE.
          RAISE syntax_error.
        ENDIF.
      ENDIF.
    ENDIF.

    IF iv_simulation IS INITIAL.
      IF v_es_report = 'X'.
        SUBMIT (lv_program) VIA SELECTION-SCREEN AND RETURN.
      ELSE.
*   call generated program
        CALL METHOD call_gen_form
          EXPORTING
            iv_program       = lv_program
            iv_bg_proc       = iv_bg_proc
            iv_bg_date       = iv_bg_date
            iv_bg_time       = iv_bg_time
          IMPORTING
            er_result        = er_result
            ev_dbcnt         = ev_dbcnt
            er_lock_argument = er_lock_argument
            er_exc           = er_exc
          EXCEPTIONS
            job_submit_error = 1
            table_locked     = 2
            OTHERS           = 3.

        IF sy-subrc = 1.
          IF mv_log_handle IS INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                    RAISING job_submit_error.
          ELSE.
            CALL METHOD add_message(
                iv_msgty = 'E'
                iv_msgid = sy-msgid
                iv_msgno = sy-msgno
                iv_msgv1 = sy-msgv1
                iv_msgv2 = sy-msgv2
                iv_msgv3 = sy-msgv3
                iv_msgv4 = sy-msgv4 ).
            RAISE job_submit_error.
          ENDIF.
        ENDIF.
      ENDIF.

      IF sy-subrc = 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      ENDIF.

      IF sy-subrc = 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDIF.

* Siempre quiero borrarlo!
*    IF mv_log_handle IS NOT INITIAL.
**   if error occurred, keep the program
*      IF ms_s_msg IS INITIAL.
**   delete program from the repository

    CALL FUNCTION 'RS_DELETE_PROGRAM'
      EXPORTING
        program            = lv_program
        suppress_checks    = 'X'
        suppress_popup     = 'X'
        with_includes      = ' '
        with_cua           = ' '
        with_documentation = ' '
        with_dynpro        = ' '
        with_textpool      = ' '
        skip_progress_ind  = 'X'
      EXCEPTIONS
        enqueue_lock       = 1
        object_not_found   = 2
        permission_failure = 3
        reject_deletion    = 4
        OTHERS             = 5.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.
*      ENDIF.
*    ENDIF.

    et_srccode = lt_srccode.

  ENDMETHOD.                    "


  METHOD create_new.

    DATA: lv_returncode TYPE inri-returncode.


    CLEAR: mv_prog_id.

    mv_command_id = iv_command_id.

*** get program ID from number range
**    CALL FUNCTION 'NUMBER_GET_NEXT'
**      EXPORTING
**        nr_range_nr   = '01'
**        object        = 'ZHTDB_PROG'
**        ignore_buffer = 'X'
**      IMPORTING
**        number        = mv_prog_id
**        returncode    = lv_returncode
**      EXCEPTIONS
**        OTHERS        = 1.

*    CALL FUNCTION 'GUID_CREATE'
*      IMPORTING
*        ev_guid_32 = mv_prog_id.
    mv_prog_id = 'ZSQL_APC_TEMP_012345678901234567'.
    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING no_id.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE no_id.
      ENDIF.
    ELSE.
      IF lv_returncode IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'S' NUMBER '116' DISPLAY LIKE 'E'
                  WITH lv_returncode sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_id.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = 'ZSQL_FREE'
              iv_msgno = '116'
              iv_msgv1 = lv_returncode ).
          RAISE no_id.
        ENDIF.
      ELSE.
        COMMIT WORK.
      ENDIF.
    ENDIF.

* clear attributes
    CLEAR mv_command.
    CLEAR mt_aptph_pos.
    CLEAR mt_paranth.
    CLEAR mt_keywords.
    CLEAR mt_vranges.
    CLEAR mv_parsed.
    CLEAR ms_s_msg.

* take over data
    mv_command    = iv_command.    " Open SQL command
    SHIFT mv_command RIGHT DELETING TRAILING '. '.

    mt_vranges    = it_vranges.    " value ranges for the WHERE clause
    mv_log_handle = iv_log_handle. " Application Log handle. If supplied, no messages given.

* If select commands are loaded from file, some messages are suppressed in add_message
    mv_test_from_file = iv_test_from_file.
* if a message is suppressed, this indicator is set, so no messages are logged from outside (ZSQL)
    CLEAR mv_message_dropped.

  ENDMETHOD.                    "

  METHOD generate_srccode.
* generates a program source code, which includes the command

    DATA: lv_program TYPE programm,
          lv_line    TYPE string,
          lv_tmp     TYPE string.

    IF v_es_report = 'X'.
      et_srccode = i_lineas.
      EXIT.
    ENDIF.

*****************************************************************************************
* create source code for the program

* build program name
    lv_tmp = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_tmp INTO lv_program.

    lv_line = 'PROGRAM'.
    CONCATENATE lv_line lv_program '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

    APPEND '  TYPE-POOLS: rsds.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* FORM
    APPEND 'FORM exec_command TABLES pt_vranges CHANGING p_locked p_dbcnt.' TO et_srccode.
    APPEND '  DATA: lv_lock_argument(150) TYPE c,'                          TO et_srccode.
    APPEND '        lv_table              TYPE tabname.'                    TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

* insert command
    APPEND mv_command TO et_srccode.
    APPEND '.'        TO et_srccode.

* save SY-DBCNT
    APPEND '  p_dbcnt = sy-dbcnt.' TO et_srccode.
    APPEND 'ENDFORM.'              TO et_srccode.

  ENDMETHOD.                    "

  METHOD generate_vranges.

    DATA: ls_vrange   LIKE LINE OF mt_vranges,
          ls_frange   TYPE rsds_frange,
          lv_line     TYPE string,
          lv_index_vr TYPE sy-tabix,
          lv_index_fr TYPE sy-tabix.


    APPEND INITIAL LINE TO et_srccode.

* work area for value range entries
    APPEND '  TYPES: BEGIN OF lty_zhdb_vrange,'        TO et_srccode.
    APPEND '           alias      TYPE tabname,'       TO et_srccode.
    APPEND '           rsds_range TYPE rsds_range,'    TO et_srccode.
    APPEND '  END OF lty_zhdb_vrange.'                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND '  TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.'                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND '  DATA: ls_vrange TYPE lty_zhdb_vrange,' TO et_srccode.
    APPEND '        ls_frange TYPE rsds_frange.' TO et_srccode.

    LOOP AT mt_vranges INTO ls_vrange.
      lv_index_vr = sy-tabix.

      LOOP AT ls_vrange-rsds_range-frange_t INTO ls_frange.
        lv_index_fr = sy-tabix.

*     define new value range table
        CONCATENATE '  DATA: r_' ls_vrange-alias '_' ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line 'TYPE RSDS_SELOPT_T.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_vr.

*     take over content
        CONCATENATE '  READ TABLE pt_vranges INDEX' lv_line 'INTO ls_vrange.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_fr.
        CONCATENATE '  READ TABLE ls_vrange-rsds_range-frange_t INDEX' lv_line 'INTO ls_frange.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        CONCATENATE '  r_' ls_vrange-alias '_' ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line '= ls_frange-selopt_t.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND INITIAL LINE TO et_srccode.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.                    "


  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    DATA: lv_keyword      TYPE string,
          lv_search_str   TYPE string,
          ls_prev_keyword TYPE gty_keyword,
          ls_next_keyword TYPE gty_keyword,

          lv_length       TYPE i,
          lv_position     TYPE i,
          lv_ends_at      TYPE i,
          lv_lines        TYPE i,
          lv_index        TYPE i,
          lv_shift        TYPE i,
          lv_delta        TYPE i,
          ls_aptph        LIKE LINE OF mt_aptph_pos.

    FIELD-SYMBOLS: <ls_keyword> TYPE gty_keyword.

    IF v_es_report = 'X'. EXIT. ENDIF.

* determine subquerys
    det_subquery( ).

************************************************************************
* get keywords

    lv_length = strlen( mv_command ).

* search for keywords
    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      lv_keyword = <ls_keyword>-keyword.
      CONCATENATE '.' lv_keyword '.' INTO lv_search_str
        SEPARATED BY space.

      CLEAR lv_position.

      DO.
        lv_shift = lv_position + 1.

        SEARCH mv_command
          FOR lv_search_str
          STARTING AT lv_shift.

        IF sy-subrc EQ 0.
          lv_position = sy-fdpos + lv_shift + 1.
          lv_ends_at  = lv_position + strlen( lv_keyword ) - 1.

          READ TABLE mt_aptph_pos INTO ls_aptph
            WITH KEY position = lv_position.

          IF ls_aptph-type = 'O'.  " it's not inside a text

            READ TABLE mt_query_depth INTO ls_aptph
              WITH KEY position = lv_position.

            IF ls_aptph-type = 1.  " top level, not a subquery
*           keyword found
              <ls_keyword>-begins_at = lv_position.
              <ls_keyword>-ends_at   = lv_ends_at.

              IF <ls_keyword>-order_pos = 1 AND
              <ls_keyword>-begins_at <> 2.
                IF mv_log_handle IS INITIAL.
*               Message: Command does not begin with the keyword '&1'
                  MESSAGE e088 WITH lv_keyword
                  RAISING missing_keyword.
                ELSE.
                  CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '088' iv_msgv1 = lv_keyword ).

                  RAISE missing_keyword.
                ENDIF.
              ENDIF.

              EXIT.
            ENDIF.
          ENDIF.
        ELSE.
*       keyword not found at all
          CLEAR lv_position.
          EXIT.
        ENDIF.
      ENDDO.

      IF lv_position IS INITIAL AND
         <ls_keyword>-required = 'X'.    " required keyword

        IF mv_log_handle IS INITIAL.
*       Message: Keyword '&1' is missing
          MESSAGE e006 WITH lv_keyword
            RAISING missing_keyword.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '006' iv_msgv1 = lv_keyword ).

          RAISE missing_keyword.
        ENDIF.

      ENDIF.
    ENDLOOP.


************************************************************************
* check positions

* delete keywords, which are not defined in the current command
    DELETE mt_keywords WHERE begins_at IS INITIAL.

    SORT mt_keywords BY begins_at.

    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      IF ls_prev_keyword-order_pos > <ls_keyword>-order_pos.
        IF mv_log_handle IS INITIAL.
*       Message: Wrong order of keywords: &1 on wrong position
          MESSAGE e018 WITH <ls_keyword>-keyword
            RAISING wrong_position.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '006' iv_msgv1 = ls_prev_keyword-keyword ).

          RAISE wrong_position.
        ENDIF.

      ENDIF.

      ls_prev_keyword = <ls_keyword>.
    ENDLOOP.

************************************************************************
* get texts

* MOVED before loop above: why loop through obsolete records?
** delete keywords, which are not defined in the current command
*  LOOP AT mt_keywords ASSIGNING <ls_keyword>
*       WHERE begins_at IS INITIAL.
*    DELETE mt_keywords.
*  ENDLOOP.

    DESCRIBE TABLE mt_keywords LINES lv_lines.

* get texts
    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      lv_index = sy-tabix + 1.

      IF lv_index <= lv_lines.  " til the position of the next keyword
        READ TABLE mt_keywords INTO ls_next_keyword
          INDEX lv_index.

        lv_shift = <ls_keyword>-ends_at + 1.
        lv_delta = ls_next_keyword-begins_at - lv_shift - 1.
      ELSE.                    " til the end of the command
        lv_shift = <ls_keyword>-ends_at + 1.
        lv_delta = lv_length - lv_shift.
      ENDIF.

      MOVE mv_command+lv_shift(lv_delta) TO <ls_keyword>-text.  " trim text

      lv_index = lv_index - 1.
      MODIFY mt_keywords INDEX lv_index FROM <ls_keyword>.
    ENDLOOP.

  ENDMETHOD. "

  METHOD parse_check_dot.
* check that there is no new command after a closing dot

    DATA: lv_strg_lgth TYPE i,
          lv_char      TYPE c,
          lv_shift     TYPE i,
          lv_end       TYPE c,
          ls_aptph     LIKE LINE OF mt_aptph_pos.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    IF v_es_report = 'X'.
      EXIT.
    ENDIF.
*APC20160419
    IF NOT mv_command CS 'SELECT'. EXIT. ENDIF.

    lv_strg_lgth = strlen( mv_command ).

* check dots
    DO.
      lv_char = mv_command+lv_shift(1).

      IF lv_end  = 'X' AND
         lv_char IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
*       Message: 'Don''t write any commands after the closing dot'
          MESSAGE e001 RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '001' ).

          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF lv_char = '.'.
*     check that the dot is not inside a text
        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_shift.

        IF ls_aptph-type = 'O'.  " outside a text
          lv_end = 'X'.          " the dot closes the command
        ENDIF.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "


  METHOD is_client_spec.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'CLIENT SPECIFIED'.

    IF ls_keyword-begins_at IS NOT INITIAL.
      ev_cspec = 'X'.
    ENDIF.

  ENDMETHOD.                    "

  METHOD split_string.
* splits a string at SPACE, but outside apostrophes only

    DATA: lv_string    TYPE string,
          lt_aptph_pos LIKE mt_aptph_pos,
          lv_length    TYPE i,
          lv_shift     TYPE i,
          lv_pos       TYPE i,
          lv_char      TYPE c,
          lv_word      TYPE string,
          ls_aptph     LIKE LINE OF mt_aptph_pos.


    lv_string = iv_string.

    lcl_toolbox=>parse_aptph(
      EXPORTING
        iv_condense  = space
      IMPORTING
        et_aptph_pos = lt_aptph_pos
      CHANGING
        cv_string    = lv_string ).
* get words
    lv_shift = -1.
    lv_length = strlen( iv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift >= lv_length.
        EXIT.
      ENDIF.

      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_pos = lv_shift + 1.

        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_pos.

        IF ls_aptph-type = 'O'.

          IF lv_word IS NOT INITIAL.

            APPEND lv_word TO et_words.
            CLEAR lv_word.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      CONCATENATE lv_word lv_char INTO lv_word.
    ENDDO.

* the last word
    IF lv_word IS NOT INITIAL.
      APPEND lv_word TO et_words.
    ENDIF.

  ENDMETHOD.                    "

  METHOD add_message.

    IF     iv_msgid = 'SD'    AND iv_msgno = 94.
      RETURN.
    ELSEIF iv_msgid = 'FL'    AND iv_msgno = 714.
      RETURN.
    ELSEIF iv_msgid = 'VSCAN' AND iv_msgno = 33.
      RETURN.
    ELSEIF iv_msgid = 'E4'    AND iv_msgno = '035'.
      RETURN.
    ENDIF.

    IF mv_test_from_file EQ 'X'.
      IF iv_msgid = 'ZSQL_FREE'.
        IF iv_msgno = 14 OR iv_msgno = 68 OR iv_msgno = 16 OR iv_msgno = 36 OR iv_msgno = 8.
          mv_message_dropped = 'X'.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR ms_s_msg.

    ms_s_msg-msgid = iv_msgid.
    ms_s_msg-msgno = iv_msgno.

    ms_s_msg-msgv1 = iv_msgv1.
    ms_s_msg-msgv2 = iv_msgv2.
    ms_s_msg-msgv3 = iv_msgv3.
    ms_s_msg-msgv4 = iv_msgv4.

    IF ms_s_msg IS INITIAL.
      RETURN.
    ENDIF.

    CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

    ms_s_msg-msgty = iv_msgty.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = mv_log_handle
        i_s_msg      = ms_s_msg
      EXCEPTIONS
        OTHERS       = 1.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.                    "add_message


  METHOD constructor.


  ENDMETHOD.                    "

  METHOD get_id.

    ev_id = mv_prog_id.

  ENDMETHOD.                    "

  METHOD execute.
* execute command

    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

* parse command if needed
    IF mv_parsed IS INITIAL.
      CALL METHOD parse
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc <> 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      ENDIF.
    ENDIF.

* execute command
    CALL METHOD execute_int
      EXPORTING
        iv_simulation       = iv_simulation
        iv_bg_proc          = iv_bg_proc
        iv_bg_date          = iv_bg_date
        iv_bg_time          = iv_bg_time
*       it_selscr_fields    = it_selscr_fields
      IMPORTING
        er_result           = er_result
        ev_dbcnt            = ev_dbcnt
        er_lock_argument    = er_lock_argument
        er_exc              = er_exc
        et_srccode          = et_srccode
      EXCEPTIONS
        error               = 1
        syntax_error        = 2
        job_submit_error    = 3
        table_locked        = 4
        no_auth_for_columns = 5
        OTHERS              = 6.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING exec_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE exec_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING job_submit_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE job_submit_error.
        ENDIF.

      WHEN 4.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      WHEN 5.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_auth_for_columns.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE no_auth_for_columns.
        ENDIF.
    ENDCASE.

    ev_job_name  = mv_jobname.
    ev_job_count = mv_jobcount.

  ENDMETHOD.                    "

  METHOD parse.
* parse command and execute checks

    IF mv_parsed = 'X'.
      RETURN.
    ELSE.
      mv_parsed = 'X'.
    ENDIF.

* check apostrophes
    CLEAR mt_aptph_pos.
    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_log_handle  = mv_log_handle
      IMPORTING
        et_aptph_pos   = mt_aptph_pos
        et_paranth     = mt_paranth
      CHANGING
        cv_string      = mv_command
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
*       Message: An ending apostrophe is missing
          MESSAGE e005 RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = 'ZSQL_FREE'
              iv_msgno = '005' ).
          RAISE parse_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
*       Message: An closing paranthesis is missing
          MESSAGE e059 RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = 'ZSQL_FREE'
              iv_msgno = '059' ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.
    ENDCASE.

* if there is a closing dot, check that there is no new command after it
    parse_check_dot( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

** determine subquerys
*  det_subquery( ).

* extract keywords
    parse_keywords( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD get_message_dropped.

    ev_message_dropped = mv_message_dropped.

  ENDMETHOD.                    "get_message_dropped

  METHOD get_where.

    CLEAR es_where.

    READ TABLE mt_keywords WITH KEY keyword = 'WHERE'
      INTO es_where.

  ENDMETHOD.                    "get_where

  METHOD get_command.

    ev_command = mv_command.

  ENDMETHOD.                    "get_command

ENDCLASS.                    "lcl_HTDB_CL_COMMAND IMPLEMENTATION



*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select DEFINITION
  INHERITING FROM lcl_htdb_cl_command.

*"* public components of class lcl_htdb_cl_command_select
*"* do not include other source files here!!!
  PUBLIC SECTION.

    DATA mt_adt_tables TYPE lty_zhtdb_table_aliases_tt .

    METHODS can_edit
      RETURNING
        VALUE(ev_can_edit) TYPE char1 .
    METHODS get_fieldinfo
      EXPORTING
        !et_fieldinfo  TYPE lty_zhtdb_fieldinfo_tt
        !ev_can_edit   TYPE flag
        !ev_can_insert TYPE flag .
    METHODS get_program_name
      RETURNING
        VALUE(ev_program_name) TYPE programm .
    METHODS get_table_alias
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt .
    METHODS get_texts
      EXPORTING
        !ev_select_text   TYPE string
        !ev_from_text     TYPE string
        !ev_where_text    TYPE string
        !ev_group_by_text TYPE string
        !ev_having_text   TYPE string
        !ev_order_by_text TYPE string .

    METHODS create_new
        REDEFINITION .
    METHODS parse
        REDEFINITION .


*"* protected components of class lcl_htdb_cl_command_select
*"* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES:
      BEGIN OF gty_table_field,
        table    TYPE tabname,
        field    TYPE fieldname,
        keyflag  TYPE flag,
        position TYPE tabfdpos,
      END OF gty_table_field .

    DATA mt_fieldinfo TYPE lty_zhtdb_fieldinfo_tt .
    DATA mt_table_alias TYPE lty_zhtdb_table_aliases_tt .
    DATA:
      mt_table_fields TYPE STANDARD TABLE OF gty_table_field .
    DATA mv_sel_single TYPE flag .
    DATA mv_can_edit TYPE flag .
    DATA mv_can_insert TYPE flag .
    DATA mv_has_dupl_fields TYPE flag .
    CONSTANTS mc_type_name_res TYPE string VALUE 'GTY_RES'. "#EC NOTEXT
    CONSTANTS mc_type_name_tech_res TYPE string VALUE 'GTY_RES_TECH'. "#EC NOTEXT
    DATA mv_type_name_tech_res TYPE string .
    DATA mv_prog_id_str TYPE string .
    DATA mv_type_name_res TYPE string .
    DATA mv_program TYPE programm .
    CONSTANTS mc_result_prefix TYPE string VALUE 'GT_RES'.  "#EC NOTEXT
    DATA mv_result_name TYPE string .
    DATA mt_authorizations TYPE rsec_t_usvalues .
    DATA:
      mt_subqu_where TYPE STANDARD TABLE OF lty_zhtdb_keyword .

    METHODS extend_where_clause
      IMPORTING
        !iv_where_addition TYPE string .
    METHODS add_where_excl_all
      IMPORTING
        !iv_table          TYPE tabname
      CHANGING
        !cv_where_addition TYPE string .
    METHODS create_type
      IMPORTING
        !iv_type_name        TYPE string
        !it_fieldinfo        TYPE lty_zhtdb_fieldinfo_tt
        !iv_with_tech_fields TYPE c
      CHANGING
        !ct_srccode          TYPE lty_zhtdbt_string_tab .
    METHODS expand_asterisk
      EXCEPTIONS
        table_not_found .
    METHODS parse_adt_tables
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt
      EXCEPTIONS
        parse_error .
    METHODS parse_check_fieldname
      IMPORTING
        !iv_word        TYPE string
        !it_keywords    TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_check_name
      IMPORTING
        !iv_word        TYPE string
        !it_keywords    TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_check_value
      IMPORTING
        !iv_word        TYPE string
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_fields
      EXCEPTIONS
        parse_error
        no_fields_found
        table_not_found
        field_not_found .
    METHODS parse_tables
      EXCEPTIONS
        parse_error
        no_tables_found
        table_not_exist .
    METHODS prepare_from_text
      CHANGING
        !cv_string TYPE string .
    METHODS prepare_sel_text
      CHANGING
        !cv_string TYPE string .
    METHODS rebuild_field_list
      CHANGING
        ct_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS remove_duplicates .
    METHODS check_inserted_orgcritdep
      IMPORTING
        !it_inserted TYPE REF TO data
      EXCEPTIONS
        no_auth_for_inserted_records
        assign_error .

    METHODS call_gen_form
        REDEFINITION .
    METHODS generate_srccode
        REDEFINITION .
    METHODS parse_keywords
        REDEFINITION .
ENDCLASS.                    "LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select IMPLEMENTATION.

  METHOD call_gen_form.

    IF iv_bg_proc = space.   " execute command instantly
      TRY.
          PERFORM exec_command IN PROGRAM (iv_program)
            TABLES mt_vranges          " value ranges
            CHANGING er_result         " result set
                     ev_dbcnt          " sy-dbcnt
                     er_lock_argument  " lock argument
                     er_exc.           " exception object

          IF er_exc IS NOT INITIAL.
            RAISE error.
          ENDIF.

        CATCH cx_root.
          IF mv_log_handle IS INITIAL.
*         Message: Internal error: generated program could not be called
            MESSAGE e003 RAISING error.
          ELSE.
            CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = 003 ).
          ENDIF.
      ENDTRY.
    ENDIF.

  ENDMETHOD.                    "

  METHOD create_new.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    super->create_new(
      EXPORTING
        iv_command_id     = iv_command_id
        iv_command        = iv_command
        it_vranges        = it_vranges
        iv_log_handle     = iv_log_handle
        iv_test_from_file = iv_test_from_file
      EXCEPTIONS
        no_id             = 1
        OTHERS            = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING no_id.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mt_adt_tables.
    CLEAR mt_table_fields.
    CLEAR mv_has_dupl_fields.
    CLEAR mv_sel_single.
    CLEAR mv_prog_id_str.
    CLEAR mt_query_depth.
    CLEAR mt_subqu_where.

    CLEAR mt_authorizations.

    mv_prog_id_str = mv_prog_id.

    CONCATENATE mc_type_name_tech_res mv_prog_id_str INTO mv_type_name_tech_res.
    mv_type_name_tech_res = mv_type_name_tech_res(30).
    CONCATENATE mc_type_name_res      mv_prog_id_str INTO mv_type_name_res.
    mv_type_name_res = mv_type_name_res(30).
    CONCATENATE mc_result_prefix      mv_prog_id_str INTO mv_result_name.
    mv_result_name = mv_result_name(30).

    CONCATENATE mc_prog_prefix        mv_prog_id_str INTO mv_program.
    mv_program = mv_program(30).

* set to editable as default
    mv_can_edit = 'X'.

* fill up keywords table
    ls_keyword-keyword   = 'SELECT'.
*    ls_keyword-required  = 'X'.
    ls_keyword-order_pos = 1.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'DELETE'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 1.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'FROM'.
*    ls_keyword-required  = 'X'.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'CLIENT SPECIFIED'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'BYPASSING BUFFER'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'UP TO'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'WHERE'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 5.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'GROUP BY'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 6.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'HAVING'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 7.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'ORDER BY'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 8.
    APPEND ls_keyword TO mt_keywords.


  ENDMETHOD.                    "

  METHOD generate_srccode.

    DATA: lv_line    TYPE string,
          ls_keyword LIKE LINE OF mt_keywords,
          lv_shift   TYPE i,
          l_error.

    CLEAR et_srccode.
    IF v_es_report = 'X'.
      et_srccode = i_lineas.
      v_es_report = 'X'.
      EXIT.
    ENDIF.


    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.
    IF sy-subrc NE 0. "APC20160411
      v_comando = 'X'.
    ENDIF.

    CONCATENATE 'PROGRAM' mv_program '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* Type Pools
    APPEND '  TYPE-POOLS: rsds.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

    IF v_comando IS INITIAL.
* create local type for the result set
      create_type(
        EXPORTING
          iv_type_name        = mv_type_name_res
          it_fieldinfo        = mt_fieldinfo
          iv_with_tech_fields = ' '
        CHANGING
          ct_srccode          = et_srccode ).
      APPEND INITIAL LINE TO et_srccode.

* create local type for the result set with technical fields
      create_type(
        EXPORTING
          iv_type_name        = mv_type_name_tech_res
          it_fieldinfo        = mt_fieldinfo
          iv_with_tech_fields = 'X'
        CHANGING
          ct_srccode          = et_srccode ).
      APPEND INITIAL LINE TO et_srccode.

* create result set table
      CONCATENATE 'DATA' mv_result_name 'TYPE STANDARD TABLE OF' mv_type_name_tech_res '.'
        INTO lv_line SEPARATED BY space.
      APPEND lv_line TO et_srccode.
      APPEND INITIAL LINE TO et_srccode.
    ENDIF.

* create FORM routine
    APPEND 'FORM exec_command TABLES   pt_vranges'                  TO et_srccode.
    APPEND '                  CHANGING p_result'                    TO et_srccode.
    APPEND '                           p_dbcnt'                     TO et_srccode.
    APPEND '                           p_lock_argument'             TO et_srccode.
    APPEND '                           po_exc TYPE REF TO cx_root.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

    IF v_comando IS INITIAL.
      IF mv_sel_single = 'X'.
*   create result structure
        CONCATENATE '  DATA: ls_result LIKE LINE OF ' mv_result_name '.'
          INTO lv_line SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND INITIAL LINE TO et_srccode.
      ENDIF.
    ENDIF.

    APPEND 'TRY.' TO et_srccode.

    IF v_comando IS INITIAL.
* create SELECT command
      READ TABLE mt_keywords INTO ls_keyword
        WITH KEY keyword = 'SELECT'.

      lv_line = 'SELECT'.
      IF ls_keyword-additions IS NOT INITIAL.
        CONCATENATE lv_line ls_keyword-additions INTO lv_line
          SEPARATED BY space.
      ENDIF.
      APPEND lv_line TO et_srccode.

* build field list (SELECT clause)
      rebuild_field_list(
        CHANGING
          ct_srccode          = et_srccode
        EXCEPTIONS
          no_auth_for_columns = 1
          OTHERS              = 2 ).

      IF sy-subrc = 1.
        MESSAGE e148 RAISING no_auth_for_columns.
      ELSEIF sy-subrc = 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE error.
        ENDIF.
      ENDIF.

* insert addition INTO ...
      IF mv_sel_single = 'X'.
        APPEND '  INTO CORRESPONDING FIELDS OF ls_result' TO et_srccode.
      ELSE.
        CONCATENATE '  INTO CORRESPONDING FIELDS OF TABLE ' mv_result_name INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
      ENDIF.

* append the rest: 'FROM ...'
      READ TABLE mt_keywords INTO ls_keyword
        WITH KEY keyword = 'FROM'.
      lv_shift = ls_keyword-begins_at - 1.
      CONCATENATE mv_command+lv_shift '.' INTO lv_line.

* split line by 100
      CALL METHOD lcl_toolbox=>split_string
        EXPORTING
          iv_string     = lv_line
          iv_maxlen     = 100
        IMPORTING
          et_string_tab = et_srccode.

*      lv_line = '__break_ap.'.
*      APPEND lv_line TO et_srccode.


* save SY-DBCNT
      lv_line = 'p_dbcnt = sy-dbcnt.'.
      APPEND lv_line TO et_srccode.

      IF mv_sel_single = 'X'.
*   append result structure to result tab
        APPEND ' IF sy-subrc EQ 0.' TO et_srccode.
        CONCATENATE '   APPEND ls_result TO ' mv_result_name '.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND ' ENDIF.' TO et_srccode.
      ENDIF.

* return reference on result set
      CONCATENATE ' GET REFERENCE OF ' mv_result_name 'INTO p_result.' INTO lv_line
        SEPARATED BY space.
      APPEND lv_line TO et_srccode.
    ELSE.
      LOOP AT i_lineas INTO l_linea.
        TRANSLATE l_linea TO UPPER CASE.
        IF l_linea CS 'UPDATE' OR l_linea CS 'DELETE'.
          DATA(l_upd_del) = 'X'.
        ENDIF.
        IF l_linea CS 'WHERE'.
          DATA(l_where) = 'X'.
        ENDIF.
      ENDLOOP.
      IF l_upd_del = 'X' AND l_where = ''.
        MESSAGE 'Es necesario indicar WHERE' TYPE 'E'.
      ENDIF.

      IF zcl_c=>existe( constante = 'USUARIO_AP' valor = sy-uname ) = 'X'.
        CLEAR l_error.
      ELSE.
        IF zcl_ap_lista=>es_elemento( lista = zcl_c=>usuarios_sistemas elemento = sy-uname ) = 'X'.
          IF zcl_ap_popup=>confirmar( texto = 'Esta accin puede ser peligrosa' texto2 = 'Est seguro de continuar?' ) = ''.
            l_error = 'X'.
            EXIT.
          ENDIF.
        ELSE.
          l_error = 'X'.
        ENDIF.
      ENDIF.
      IF l_error IS INITIAL.
        v_comando = 'X'.
        LOOP AT i_lineas INTO l_linea.
          APPEND l_linea TO et_srccode.
        ENDLOOP.
        APPEND '.' TO et_srccode.

        lv_line = 'p_dbcnt = sy-dbcnt.'.
        APPEND lv_line TO et_srccode.
      ELSE.
        MESSAGE 'No autorizado a ejecutar estas acciones' TYPE 'E'.
      ENDIF.
    ENDIF.


    APPEND 'CATCH cx_root INTO po_exc.'
                                        TO et_srccode.
    APPEND 'ENDTRY.'                    TO et_srccode.

    lv_line = 'ENDFORM.'.
    APPEND lv_line TO et_srccode.

  ENDMETHOD.                    "

  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    FIELD-SYMBOLS: <ls_keyword> LIKE LINE OF mt_keywords.


* extract keywords
    super->parse_keywords(
      EXCEPTIONS
        missing_keyword = 1
        wrong_position  = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING missing_keyword.
    ELSEIF sy-subrc = 2.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING wrong_position.
    ENDIF.

* check the SELECT keyword
    READ TABLE mt_keywords ASSIGNING <ls_keyword>
      WITH KEY keyword = 'SELECT'.
    IF sy-subrc = 0.


      IF strlen( <ls_keyword>-text ) >= 8.
        IF <ls_keyword>-text(8) = 'DISTINCT'.
          SHIFT <ls_keyword>-text LEFT BY 8 PLACES.
          <ls_keyword>-additions = 'DISTINCT'.
*     <ls_keyword>-ends_at   =  <ls_keyword>-ends_at + 8.
        ENDIF.
      ENDIF.

      IF strlen( <ls_keyword>-text ) >= 6.
        IF <ls_keyword>-text(6) = 'SINGLE'.
          SHIFT <ls_keyword>-text LEFT BY 6 PLACES.
          <ls_keyword>-additions = 'SINGLE'.
*     <ls_keyword>-ends_at   = <ls_keyword>-ends_at + 6.
          mv_sel_single = 'X'.
        ENDIF.
      ENDIF.

      SEARCH <ls_keyword>-text FOR '. FOR UPDATE .'.
      IF sy-subrc = 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE e068 RAISING wrong_keyword.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'W' iv_msgid = 'ZSQL_FREE' iv_msgno = '068' ).
          RAISE wrong_keyword.
        ENDIF.
      ENDIF.
    ELSE.
*APC20160411
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse.

    IF v_es_report = 'X'.
      RETURN.
    ENDIF.

    IF mv_parsed = 'X'.
      RETURN.
    ENDIF.

* make search for keywords easier - start and end with SPACE
    SHIFT mv_command RIGHT BY 1 PLACES.
    CONCATENATE mv_command space INTO mv_command
      SEPARATED BY space.

* elemtary check of command (apostrophes, dots, keywords)
    super->parse( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING parse_error.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mv_has_dupl_fields.

* set to editable as default
    mv_can_edit = 'X'.

* get tables involved
    CALL METHOD parse_tables
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* get field list
    CALL METHOD parse_fields
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "parse

  METHOD extend_where_clause.

    DATA: ls_keywords LIKE LINE OF mt_keywords,
          lv_tabix    TYPE i,
          lv_len      TYPE i,
          lv_shift    TYPE i,
          lv_tmp      TYPE i.


    IF iv_where_addition IS NOT INITIAL.

      READ TABLE mt_keywords INTO ls_keywords WITH KEY keyword = 'WHERE'.

      IF sy-subrc EQ 0.   " extend WHERE clause

        lv_tabix = sy-tabix.

*     add pre stuff to mv_command
        lv_shift = ls_keywords-begins_at + 4.
        lv_tmp   = lv_shift + 1.
        CONCATENATE mv_command(lv_shift) '(' iv_where_addition ') AND (' mv_command+lv_tmp
          INTO mv_command SEPARATED BY space.

*     add pre stuff to ls_keywords-text
        CONCATENATE '(' iv_where_addition ') AND (' ls_keywords-text
          INTO ls_keywords-text SEPARATED BY space.

        lv_len = strlen( ls_keywords-text ) - 1.

        IF ls_keywords-text+lv_len(1) = '.'.
*       add post stuff to mv_command
          lv_shift = ls_keywords-ends_at + strlen( ls_keywords-text ) - 1.
          CONCATENATE mv_command(lv_shift) ').' INTO mv_command SEPARATED BY space.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text(lv_len) ').' INTO ls_keywords-text SEPARATED BY space.
        ELSE.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text ')' INTO ls_keywords-text SEPARATED BY space.

          LOOP AT mt_keywords TRANSPORTING NO FIELDS
               WHERE order_pos > ls_keywords-order_pos.
            lv_shift = ls_keywords-ends_at + lv_len + 1.
            lv_tmp   = lv_shift + 1.
            CONCATENATE mv_command(lv_shift) ')' mv_command+lv_shift
              INTO mv_command SEPARATED BY space.
            EXIT.
          ENDLOOP.

          IF sy-subrc EQ 4.
*         add post stuff to mv_command
            CONCATENATE mv_command ')' INTO mv_command SEPARATED BY space.
          ENDIF.
        ENDIF.

        MODIFY mt_keywords FROM ls_keywords INDEX lv_tabix.

      ELSE.   " create WHERE clause

        LOOP AT mt_keywords INTO ls_keywords WHERE order_pos > 5. " WHERE keyword
          lv_shift = ls_keywords-begins_at - 1.
          CONCATENATE mv_command(lv_shift) 'WHERE' iv_where_addition mv_command+lv_shift
            INTO mv_command SEPARATED BY space.
          EXIT.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CONCATENATE mv_command 'WHERE' iv_where_addition
            INTO mv_command SEPARATED BY space.
        ENDIF.

        ls_keywords-keyword   = 'WHERE'.
        ls_keywords-text      = iv_where_addition.
        ls_keywords-order_pos = 5.
        ls_keywords-begins_at = lv_shift.
        ls_keywords-ends_at   = lv_shift + 4.

        APPEND ls_keywords TO mt_keywords.

      ENDIF.

    ENDIF.

  ENDMETHOD.                    "extend_where_clause

  METHOD add_where_excl_all.

  ENDMETHOD.                    "ADD_WHERE_EXCL_ALL


  METHOD can_edit.

    ev_can_edit = mv_can_edit.

  ENDMETHOD.                    "can_edit

  METHOD create_type.
* create a type for the result set of the command

    DATA: lt_srccode   TYPE STANDARD TABLE OF string,
          lv_line      TYPE string,
          ls_fieldinfo LIKE LINE OF it_fieldinfo.


    IF it_fieldinfo IS INITIAL.
      RETURN.
    ENDIF.

    CONCATENATE 'TYPES: BEGIN OF' iv_type_name ',' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    IF iv_with_tech_fields EQ 'X'.
*   add system fields HTDB_ROWID and HTDB_SELECTED and HTDB_ICON
      lv_line = 'zenith_rowid TYPE i,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

      lv_line = 'zenith_selected TYPE c,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add style field
      lv_line = 'zenith_style TYPE lvc_t_styl,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add coloring field
      lv_line = 'zenith_color TYPE lvc_t_scol,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   who locked the row?
      lv_line = 'zenith_locked_by TYPE sy-uname,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDIF.

* for each entry in the field list there will be a field in the structure
    LOOP AT it_fieldinfo INTO ls_fieldinfo.
      TRANSLATE ls_fieldinfo-generated_field TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field_alias     TO LOWER CASE.
      TRANSLATE ls_fieldinfo-orig_field      TO LOWER CASE.
      TRANSLATE ls_fieldinfo-table           TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field           TO LOWER CASE.

      IF ls_fieldinfo-agg_function = 'COUNT'.
        CONCATENATE ls_fieldinfo-generated_field 'TYPE i,'
          INTO lv_line SEPARATED BY space.
*      ELSEIF ls_fieldinfo-agg_function = 'SUM'.
*        CONCATENATE ls_fieldinfo-generated_field 'TYPE f,'
*          INTO lv_line SEPARATED BY space.
      ELSEIF ls_fieldinfo-agg_function = 'AVG'.
        CONCATENATE ls_fieldinfo-generated_field 'TYPE p DECIMALS 4,'
          INTO lv_line SEPARATED BY space.
      ELSE.
        IF ls_fieldinfo-generated_field IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-generated_field 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSEIF ls_fieldinfo-field_alias IS INITIAL.
          CONCATENATE ls_fieldinfo-field_alias 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSE.
          CONCATENATE ls_fieldinfo-orig_field 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ENDIF.

        CONCATENATE lv_line '-' ls_fieldinfo-field ',' INTO lv_line.
      ENDIF.

      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDLOOP.

    CONCATENATE '       END OF' iv_type_name '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    APPEND LINES OF lt_srccode TO ct_srccode.

  ENDMETHOD.                    "

  METHOD expand_asterisk.
* get field list in case of SELECT *

    DATA: lv_lines       TYPE i,
          ls_table_field LIKE LINE OF mt_table_fields,
          ls_table_alias LIKE LINE OF mt_table_alias,
          ls_fieldinfo   LIKE LINE OF mt_fieldinfo.


    CLEAR mt_fieldinfo.

    LOOP AT mt_table_alias INTO ls_table_alias.

      ls_fieldinfo-table = ls_table_alias-table.

*   get table fields
      LOOP AT mt_table_fields INTO ls_table_field
           WHERE table = ls_fieldinfo-table.

        ls_fieldinfo-orig_field = ls_table_field-field.
        ls_fieldinfo-field      = ls_table_field-field.
        ls_fieldinfo-is_key     = ls_table_field-keyflag.

*      READ TABLE mt_table_alias INTO ls_table_alias
*        WITH KEY table = ls_table_alias-table.

        IF ls_table_alias-alias IS INITIAL.
          ls_fieldinfo-table_alias = ls_table_alias-table.
        ELSE.
          ls_fieldinfo-table_alias = ls_table_alias-alias.
        ENDIF.

        READ TABLE mt_fieldinfo
          WITH KEY orig_field = ls_table_field-field
          TRANSPORTING NO FIELDS.

        IF sy-subrc EQ 0.
          mv_has_dupl_fields = 'X'.
        ENDIF.

        APPEND ls_fieldinfo TO mt_fieldinfo.

      ENDLOOP.

    ENDLOOP.

* result set can be edited, if there is only one table
    DESCRIBE TABLE mt_table_alias LINES lv_lines.
    IF lv_lines NE 1.
      CLEAR mv_can_edit.    " result set can't be edited
      CLEAR mv_can_insert.  " new records can't inserted to the result set
    ENDIF.

* clean field list from duplicates
    remove_duplicates( ).

  ENDMETHOD.                    "


  METHOD get_fieldinfo.
* returns the field list (from the SELECT clause)

    et_fieldinfo  = mt_fieldinfo.
    ev_can_edit   = mv_can_edit.
    ev_can_insert = mv_can_insert.

  ENDMETHOD.                    "

  METHOD get_program_name.

    ev_program_name = mv_program.

  ENDMETHOD.                    "get_program_name

  METHOD get_table_alias.
* returns the table list (from the FROM clause and subquerys)

    CLEAR et_table_alias.

    et_table_alias = mt_table_alias.                   " FROM clause
    APPEND LINES OF mt_adt_tables TO et_table_alias.   " subquerys

  ENDMETHOD.                    "

  METHOD get_texts.
* returns the SELECT, FROM, etc. clauses of the command

    DATA: ls_keyword LIKE LINE OF mt_keywords.


* get SELECT text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.
    ev_select_text = ls_keyword-text.

* get FROM text
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'FROM'.
    ev_from_text = ls_keyword-text.

* ...
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'WHERE'.
    ev_where_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'GROUP BY'.
    ev_group_by_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'HAVING'.
    ev_having_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'ORDER BY'.
    ev_order_by_text = ls_keyword-text.

  ENDMETHOD.                    "


  METHOD parse_adt_tables.

    DATA: ls_keyword     LIKE LINE OF mt_keywords,
          lv_where       TYPE string,
          lt_aptph_pos   LIKE mt_aptph_pos,
          lt_paranth     LIKE mt_aptph_pos,
          ls_aptph       LIKE LINE OF mt_aptph_pos,
          lv_offset      TYPE i,
          lv_found       TYPE flag,
          lv_reparse     TYPE flag,

          lv_subquery    TYPE string,
          lv_subq_begin  TYPE i,
          lv_subq_end    TYPE i,
          lv_subq_lgth   TYPE i,
          lv_new_lgth    TYPE i,
          lv_shift       TYPE i,
          lv_left        TYPE i,
          lv_right       TYPE i,

          lo_sel_cmd     TYPE REF TO lcl_htdb_cl_command_select,
          lt_table_alias LIKE mt_table_alias.


* get WHERE text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'WHERE'.

    IF sy-subrc <> 0.
      EXIT.
    ENDIF.

* WHERE text
    lv_where = ls_keyword-text.
* SPACE as the first character
    SHIFT lv_where RIGHT BY 1 PLACES.

* identify apostrophes and paranthesis
    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_log_handle = mv_log_handle
      IMPORTING
        et_aptph_pos  = lt_aptph_pos
        et_paranth    = lt_paranth
      CHANGING
        cv_string     = lv_where
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* create new instance for the subquery
    CREATE OBJECT lo_sel_cmd.

    DO.
      CLEAR lv_found.
      lv_offset = lv_subq_begin + 1.

*   search for subquerys
      SEARCH lv_where
        FOR '. IN ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 4.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. ALL ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. SOME ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 6.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. ANY ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. EXISTS ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 8.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      IF lv_found = 'X'.
        lv_reparse = 'X'.

*     absolute position
        lv_subq_begin = lv_subq_begin + lv_offset.

*     check, whether it's outside of apostrophes
        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_subq_begin.

        IF ls_aptph-type = 'O'.  " outside apostrophes
*       identify the depth of the paranthesis in ' ### ( SELECT'
          READ TABLE lt_paranth INTO ls_aptph
            WITH KEY position = lv_subq_begin.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_subq_end = sy-tabix + 1.
            LOOP AT lt_paranth FROM lv_subq_end INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              EXIT.
            ENDLOOP.

            IF sy-subrc = 0.
*           extract subquery from string
              lv_subq_lgth = lv_subq_end - lv_subq_begin - 1.
              lv_subquery  = lv_where+lv_subq_begin(lv_subq_lgth).

*           create new subquery
              CALL METHOD lo_sel_cmd->create_new
                EXPORTING
                  iv_command    = lv_subquery
                  iv_log_handle = mv_log_handle.

*           parse subquery
              CALL METHOD lo_sel_cmd->parse
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc <> 0.
                IF mv_log_handle IS INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                          RAISING parse_error.
                ELSE.
                  CALL METHOD add_message(
                      iv_msgty = 'E'
                      iv_msgid = sy-msgid
                      iv_msgno = sy-msgno
                      iv_msgv1 = sy-msgv1
                      iv_msgv2 = sy-msgv2
                      iv_msgv3 = sy-msgv3
                      iv_msgv4 = sy-msgv4 ).
                  RAISE parse_error.
                ENDIF.
              ENDIF.

*           extract tables from subquery
              lo_sel_cmd->get_table_alias( IMPORTING et_table_alias = lt_table_alias ).
              APPEND LINES OF lt_table_alias TO mt_adt_tables.

*           get modified command text
              lo_sel_cmd->get_command( RECEIVING ev_command = lv_subquery ).

*           new length of the subquery
              lv_new_lgth = strlen( lv_subquery ).

*           insert modified subquery into the original command
*             position of WHERE + rest of the word 'WHERE' + start of subq '('
              lv_left  = ls_keyword-begins_at + 4 + lv_subq_begin + lv_shift.
*             position of WHERE + rest of the word 'WHERE' + end of subq ')' - 1
              lv_right = ls_keyword-begins_at + 4 + lv_subq_end - 1 + lv_shift.
              CONCATENATE mv_command(lv_left) lv_subquery mv_command+lv_right
                INTO mv_command SEPARATED BY space.

*           offset due to the new length of the subquery
              lv_shift = lv_shift + lv_new_lgth - lv_subq_lgth + 2.

*           continue search on the same level!
              lv_subq_begin = lv_subq_begin + lv_subq_lgth.
            ENDIF.
          ENDIF.
        ELSE.                    " inside apostrophes -> ignore
          CONTINUE.
        ENDIF.

      ELSE.    " no more subquerys found
*     the command could have been changed due to authority checks
        IF lv_reparse = 'X'.
          parse_keywords( ).
        ENDIF.

        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.                    "

  METHOD parse_check_fieldname.
* checks if the string is a valid field name, including ~ for table alias

    CLEAR rv_valid.

    READ TABLE it_keywords WITH KEY table_line = iv_word
      TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.                                       " 1 -> error
      RETURN.
    ELSE.
*    IF iv_word CO 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_~0123456789'.
      rv_valid = 'X'.
*    ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_check_name.
* checks if the string is a valid name for tables, fields or aliases

    rv_valid = 'X'.

*  CLEAR rv_valid.
*
*  READ TABLE it_keywords WITH KEY table_line = iv_word
*    TRANSPORTING NO FIELDS.
*
*  IF sy-subrc = 0.                                       " 1 -> error
*    RETURN.
*  ELSE.
*    IF iv_word CO 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.

  ENDMETHOD.                    "

  METHOD parse_check_value .
* checks the string if it is between apostrophes;
* the number of apostrophes is correct anyway

    rv_valid = 'X'.

*  DATA: lv_length TYPE i,
*        lv_word   LIKE iv_word.
*
*  CLEAR rv_valid.
*
*  lv_word = iv_word.
*
*  TRANSLATE lv_word TO UPPER CASE.
*
*  IF lv_word IS INITIAL.
*    RETURN.
*  ENDIF.
*
*  IF lv_word = 'SPACE'.
*    rv_valid = 'X'.
*  ENDIF.
*
*  IF lv_word CO '0123456789'.
*    rv_valid = 'X'.
*  ENDIF.
*
*  lv_length = strlen( lv_word ).
*  lv_length = lv_length - 1.
*
*  IF lv_length > 3.
*    IF lv_word(3) = 'SY-'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.
*
*  IF lv_length > 5.
*    IF lv_word(5) = 'SYST-'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.
*
*  IF lv_word(1)           = '''' AND
*     lv_word+lv_length(1) = ''''.
*    rv_valid = 'X'.
*  ENDIF.

  ENDMETHOD.                    "


  METHOD parse_fields.
* extracts field names from the SELECT clause
* and fills up the MT_FIELDINFO table

    DATA: lv_state       TYPE i,
          lv_error       TYPE xfeld,
          lv_lines       TYPE i,

          ls_keyword     LIKE LINE OF mt_keywords,
          lt_words       TYPE lty_zhtdbt_string_tab,
          lt_keywords    TYPE lty_zhtdbt_string_tab,
          lv_word        TYPE string,
          ls_fieldinfo   LIKE LINE OF mt_fieldinfo,
          ls_table_alias LIKE LINE OF mt_table_alias,
          lv_fdpos       TYPE i,
          ls_table_field LIKE LINE OF mt_table_fields.


* get words of select_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.

    IF sy-subrc = 0. "APC20160419

      prepare_sel_text( CHANGING cv_string = ls_keyword-text ).

      CALL METHOD split_string
        EXPORTING
          iv_string = ls_keyword-text
        IMPORTING
          et_words  = lt_words.

* list of possible keywords
      APPEND 'AS'       TO lt_keywords.
      APPEND 'MIN('     TO lt_keywords.
      APPEND 'MAX('     TO lt_keywords.
      APPEND 'AVG('     TO lt_keywords.
      APPEND 'SUM('     TO lt_keywords.
      APPEND 'COUNT('   TO lt_keywords.
      APPEND '*'        TO lt_keywords.
      APPEND 'DISTINCT' TO lt_keywords.
      APPEND ')'        TO lt_keywords.

      IF lt_words IS INITIAL.
        IF mv_log_handle IS INITIAL.
*     Message: Field list is missing
          MESSAGE e017 RAISING no_fields_found.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '017' ).
          RAISE no_fields_found.
        ENDIF.
      ENDIF.

* parse words

* The parser is a simple automat having 10 states defined as follows:

* <field_list>: 1  '*' 4                                                                    |
*               1  {fieldname} 2                                                            |
*               1  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5 ['DISTINCT'] 6 {fieldname } 7  ')' 8 |
*               1  'COUNT(' 9
*
*               2  'AS' 3 {name} 1
*               2  {fieldname} 2                        |
*               2  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5  |
*               2  'COUNT(' 9
*
*               8  'AS' 3 {name} 1                      |
*               8  {fieldname} 2                        |
*               8  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5  |
*               8  'COUNT(' 9
*
*               9  '*' 7         |
*               9  'DISTINCT' 10 |
*               9  {fieldname } 7
*
*               10 '*' 7          |
*               10 {fieldname } 7
*
* 1 is the START state, 2, 4 and 8 are END states.

      lv_state = 1.

      LOOP AT lt_words INTO lv_word
           WHERE table_line IS NOT INITIAL.

        CASE lv_state.

          WHEN 1. "************************************************

*       check wether it's a keyword
            CASE lv_word.
              WHEN '*'.                                       " 1 -> 4
                lv_state = 4.
                CONTINUE.
              WHEN 'MIN(' OR                                  " 1 -> 5
                   'MAX(' OR
                   'AVG(' OR
                   'SUM('.
                lv_state = 5.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN 'COUNT('.                                  " 1 -> 9
                lv_state = 9.
                ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = 'GROUP BY'.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = 'X'.
                ENDIF.

                CONTINUE.
            ENDCASE.

*       check wether it's a valid fieldname
            IF parse_check_fieldname(
                 iv_word = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 1 -> 2
              lv_state = 2.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 1 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 2. "************************************************

            CASE lv_word.
              WHEN 'AS'.                                      " 2 -> 3
                lv_state = 3.
                CONTINUE.
              WHEN 'MIN(' OR                                  " 2 -> 5
                   'MAX(' OR
                   'AVG(' OR
                   'SUM('.
                lv_state = 5.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN 'COUNT('.                                  " 2 -> 9
                lv_state = 9.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(5).
*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = 'GROUP BY'.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = 'X'.
                ENDIF.

                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 2 -> 2
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 2 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 3. "************************************************

            IF parse_check_name(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 3 -> 1
              lv_state = 1.
              ls_fieldinfo-field_alias = lv_word.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              CONTINUE.
            ELSE.                                               " 3 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 4. "************************************************

            IF lv_word IS NOT INITIAL.                          " 4 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 5. "************************************************

            IF lv_word = 'DISTINCT'.                          " 5 -> 6
              ls_fieldinfo-distinctf = 'X'.
              lv_state = 6.
              CONTINUE.
            ENDIF.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 5 -> 7
              lv_state = 7.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 5 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 6. "************************************************

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 6 -> 7
              ls_fieldinfo-orig_field = lv_word.
              lv_state = 7.
              CONTINUE.
            ELSE.                                               " 6 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 7. "************************************************

            IF lv_word = ')'.                                 " 7 -> 8
              lv_state = 8.
              CONTINUE.
            ENDIF.

            lv_error = 'X'.
            EXIT.

          WHEN 8. "************************************************

            CASE lv_word.
              WHEN 'AS'.                                      " 8 -> 3
                lv_state = 3.
                CONTINUE.
              WHEN 'MIN(' OR                                  " 8 -> 5
                   'MAX(' OR
                   'AVG(' OR
                   'SUM('.
                lv_state = 5.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN 'COUNT('.                                  " 8 -> 9
                lv_state = 9.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = 'GROUP BY'.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = 'X'.
                ENDIF.

                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 8 -> 2
              lv_state = 2.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 8 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 9. "************************************************

            CASE lv_word.
              WHEN '*'.                                       " 9 -> 7
                lv_state = 7.
                ls_fieldinfo-orig_field = '*'.
                CONTINUE.
              WHEN 'DISTINCT'.                                " 9 -> 10
                ls_fieldinfo-distinctf = 'X'.
                lv_state = 10.
                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 9 -> 7
              lv_state = 7.
*         CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 9 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 10. "************************************************

            CASE lv_word.
              WHEN '*'.                                       " 10 -> 7
                lv_state = 7.
                ls_fieldinfo-orig_field = '*'.
                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = 'X'.           " 10 -> 7
              lv_state = 7.
*         CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               " 10 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

        ENDCASE.

      ENDLOOP.


* check errors
      IF lv_error = 'X'.
        IF mv_log_handle IS INITIAL.
*     Message: '&1' was not expected in the field list
          MESSAGE e010 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '010' iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

* check END state
      IF lv_state <> 1 AND
         lv_state <> 2 AND
         lv_state <> 4 AND
         lv_state <> 8.

        IF mv_log_handle IS INITIAL.
*     Message: Field list ended unexpectedly with '&1'
          MESSAGE e011 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '011' iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF lv_state = 4.
* SELECT * -> expand *
        expand_asterisk( EXCEPTIONS table_not_found = 1 ).

        IF sy-subrc <> 0.
          IF mv_log_handle IS INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                    RAISING table_not_found.
          ELSE.
            CALL METHOD add_message(
                iv_msgty = 'E'
                iv_msgid = sy-msgid
                iv_msgno = sy-msgno
                iv_msgv1 = sy-msgv1
                iv_msgv2 = sy-msgv2
                iv_msgv3 = sy-msgv3
                iv_msgv4 = sy-msgv4 ).
            RAISE table_not_found.
          ENDIF.
        ENDIF.

        RETURN.
      ENDIF.

      IF ls_fieldinfo IS NOT INITIAL.
*   an END state was reached -> save the last entry
        APPEND ls_fieldinfo TO mt_fieldinfo.
      ENDIF.

************************************************************************
* expand table aliases, fields

      LOOP AT mt_fieldinfo INTO ls_fieldinfo.

        SEARCH ls_fieldinfo-orig_field FOR '~'.

        IF sy-subrc EQ 0.
          lv_fdpos = sy-fdpos.

          MOVE ls_fieldinfo-orig_field(lv_fdpos) TO ls_fieldinfo-table_alias.
          TRANSLATE ls_fieldinfo-table_alias TO UPPER CASE.
          lv_fdpos = lv_fdpos + 1.
          MOVE ls_fieldinfo-orig_field+lv_fdpos TO ls_fieldinfo-field.
          TRANSLATE ls_fieldinfo-field TO UPPER CASE.

          MODIFY mt_fieldinfo FROM ls_fieldinfo.
        ELSE.
          MOVE ls_fieldinfo-orig_field TO ls_fieldinfo-field.
          TRANSLATE ls_fieldinfo-field TO UPPER CASE.
          MODIFY mt_fieldinfo FROM ls_fieldinfo.
        ENDIF.

        IF ls_fieldinfo-field EQ '*'.
          ls_fieldinfo-field = 'ALL'.
        ELSEIF ls_fieldinfo-table_alias IS NOT INITIAL.
          READ TABLE mt_table_alias
            INTO ls_table_alias
            WITH KEY alias = ls_fieldinfo-table_alias.

          IF sy-subrc <> 0.
            READ TABLE mt_table_alias
              INTO ls_table_alias
              WITH KEY table = ls_fieldinfo-table_alias.
          ENDIF.

          IF sy-subrc <> 0.
            IF mv_log_handle IS INITIAL.
*         Message: Field list: can not find table alias &1
              MESSAGE e012 WITH ls_fieldinfo-table_alias
                RAISING table_not_found.
            ELSE.
              CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '012' iv_msgv1 = ls_fieldinfo-table_alias ).
              RAISE table_not_found.
            ENDIF.
          ELSE.
            ls_fieldinfo-table = ls_table_alias-table.

            READ TABLE mt_table_fields INTO ls_table_field
              WITH KEY table = ls_table_alias-table
                       field = ls_fieldinfo-field.

            IF sy-subrc <> 0.
              IF mv_log_handle IS INITIAL.
*           Message: Field '&1' does not belong to tables '&2'
                MESSAGE e036 WITH ls_fieldinfo-field ls_table_alias-table
                  RAISING field_not_found.
              ELSE.
                CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '036' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_table_alias-table ).
                RAISE field_not_found.
              ENDIF.
            ELSE.
              ls_fieldinfo-is_key = ls_table_field-keyflag.
            ENDIF.
          ENDIF.
        ELSE.
          READ TABLE mt_table_fields INTO ls_table_field
            WITH KEY field = ls_fieldinfo-field.

          IF sy-subrc <> 0.
            IF mv_log_handle IS INITIAL.
*         Message: Field '&1' does not belong to any of the tables
              MESSAGE e016 WITH ls_fieldinfo-field
                RAISING field_not_found.
            ELSE.
              CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '016' iv_msgv1 = ls_fieldinfo-field ).
              RAISE field_not_found.
            ENDIF.
          ELSE.
            ls_fieldinfo-table  = ls_table_field-table.
            ls_fieldinfo-is_key = ls_table_field-keyflag.
          ENDIF.
        ENDIF.

        MODIFY mt_fieldinfo FROM ls_fieldinfo.

      ENDLOOP.

* tackle with duplicated fields
      remove_duplicates( ).

* result set can be edited, if there is only one table and
* all key fields were selected

      DESCRIBE TABLE mt_table_alias LINES lv_lines.

      IF lv_lines = 1.
        LOOP AT mt_table_fields INTO ls_table_field
             WHERE keyflag = 'X'.
          READ TABLE mt_fieldinfo
            WITH KEY field = ls_table_field-field
            TRANSPORTING NO FIELDS.

          IF sy-subrc <> 0.
            CLEAR mv_can_edit.
            EXIT.
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR mv_can_edit.
      ENDIF.

    ELSE.
      v_comando = 'X'.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_tables.
* extracts table names from the FROM clause
* and fills up the MT_TABLE_ALIAS table

    DATA: lv_state       TYPE i,
          lv_tabix       TYPE i,
          lv_error       TYPE xfeld,
          lv_viewgrant   TYPE dd25l-viewgrant,

          ls_keyword     LIKE LINE OF mt_keywords,
          lt_from_words  TYPE lty_zhtdbt_string_tab,
          lt_keywords    TYPE lty_zhtdbt_string_tab,
          lt_operators   TYPE lty_zhtdbt_string_tab,
          lv_word        TYPE string,
          ls_table_alias LIKE LINE OF mt_table_alias.

    FIELD-SYMBOLS: <ls_table_alias> LIKE LINE OF mt_table_alias.


* get words from from_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'FROM'.
    IF sy-subrc = 0.

      prepare_from_text( CHANGING cv_string = ls_keyword-text ).

      CALL METHOD split_string
        EXPORTING
          iv_string = ls_keyword-text
        IMPORTING
          et_words  = lt_from_words.

      IF lt_from_words IS INITIAL.
        IF mv_log_handle IS INITIAL.
*     Message: No tables were found
          MESSAGE e013 RAISING no_tables_found.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '013' ).
          RAISE no_tables_found.
        ENDIF.
      ENDIF.

* list of possible keywords
      APPEND 'AS'      TO lt_keywords.
      APPEND 'INNER'   TO lt_keywords.
      APPEND 'LEFT'    TO lt_keywords.
      APPEND 'OUTER'   TO lt_keywords.
      APPEND 'JOIN'    TO lt_keywords.
      APPEND 'ON'      TO lt_keywords.
      APPEND 'IS'      TO lt_keywords.
      APPEND 'NOT'     TO lt_keywords.
      APPEND 'NULL'    TO lt_keywords.
      APPEND 'BETWEEN' TO lt_keywords.
      APPEND 'AND'     TO lt_keywords.

* list of possible operators
      APPEND '='       TO lt_operators.
      APPEND '<'       TO lt_operators.
      APPEND '>'       TO lt_operators.
      APPEND '<='      TO lt_operators.
      APPEND '>='      TO lt_operators.
      APPEND '=<'      TO lt_operators.
      APPEND '=>'      TO lt_operators.
      APPEND '<>'      TO lt_operators.
      APPEND '><'      TO lt_operators.
      APPEND 'EQ'      TO lt_operators.
      APPEND 'NE'      TO lt_operators.
      APPEND 'LT'      TO lt_operators.
      APPEND 'GT'      TO lt_operators.
      APPEND 'LE'      TO lt_operators.
      APPEND 'GE'      TO lt_operators.

* parse words

* The parser is a simple automat having 19 states defined as follows:

* <from_text>: 1 {dbtab} 2 [as 3 {alias}] 4 [[inner|[left] 5 outer ] 6 join 7 {dbtab} 8 [as 9 {alias}] 10 ON 11 <join_condition>]
* <join_condition>: {field} 12 (IS 13 NOT 14 NULL) | (BETWEEN 15 {value} 16 AND 17 {value}) | (<comp> 18 {field}) 19 [AND 20 <join_condition>]
* <comp>: =|<|>|<=|>=|EQ|NE|GT|LT|LE|GE

* 1 is the START state, 2, 4 and 19 are END states.

      lv_state = 1.

      LOOP AT lt_from_words INTO lv_word
           WHERE table_line IS NOT INITIAL.

        CASE lv_state.

          WHEN 1. "************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 1 -> 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  " store table name
              CONTINUE.
            ELSE.                                               " 1 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 2. "************************************************

*       check wether it is a keyword
            CASE lv_word.
              WHEN 'AS'.                                      " 2 -> 3
                lv_state = 3.
                CONTINUE.
              WHEN 'INNER'.                                   " 2 -> 6
                lv_state = 6.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN 'LEFT'.                                    " 2 -> 5
                lv_state = 5.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN 'OUTER'.                                   " 2 -> 6
                lv_state = 6.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN 'JOIN'.                                    " 2 -> 7
                lv_state = 7.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 2 -> 2
              ls_table_alias-table = lv_word.  " store table name
              CONTINUE.
            ELSE.                                               " 2 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 3. "************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 3 -> 4
              lv_state = 4.
              ls_table_alias-alias = lv_word. " store table alias
*         store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            ELSE.                                               " 3 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 4. "************************************************

            CASE lv_word.
              WHEN 'INNER'.                                   " 4 -> 6
                lv_state = 6.
                CONTINUE.
              WHEN 'LEFT'.                                    " 4 -> 5
                lv_state = 5.
                CONTINUE.
              WHEN 'OUTER'.                                   " 4 -> 6
                lv_state = 6.
                CONTINUE.
              WHEN 'JOIN'.                                    " 4 -> 7
                lv_state = 7.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 4 -> 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  " store table name
              CONTINUE.
            ELSE.                                               " 4 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 5. "************************************************

            CASE lv_word.
              WHEN 'OUTER'.                                   " 5 -> 6
                lv_state = 6.
                CONTINUE.
              WHEN 'JOIN'.                                    " 5 -> 7
                lv_state = 7.
                CONTINUE.
              WHEN OTHERS.                                      " 5 -> error
                lv_error = 'X'.
                EXIT.
            ENDCASE.

          WHEN 6. "************************************************

            IF lv_word = 'JOIN'.                              " 6 -> 7
              lv_state = 7.
              CONTINUE.
            ELSE.                                               " 6 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 7. "************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 7 -> 8
              lv_state = 8.
              ls_table_alias-table = lv_word. " store table name
              CONTINUE.
            ELSE.                                               " 7 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 8. "************************************************

            CASE lv_word.
              WHEN 'AS'.                                      " 8 -> 9
                lv_state = 9.
                CONTINUE.
              WHEN 'ON'.                                      " 8 -> 11
                lv_state = 11.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
            ENDCASE.

            lv_error = 'X'.                                     " 8 -> error
            EXIT.

          WHEN 9. "************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 9 -> 10
              lv_state = 10.
              ls_table_alias-alias = lv_word. " store table alias
*         store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            ELSE.                                               " 9 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 10. "***********************************************

            IF lv_word =  'ON'.                               " 10 -> 11
              lv_state = 11.
              CONTINUE.
            ELSE.                                               " 10 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 11. "***********************************************

*       check wether it is a valid field name (and no keyword)
            IF parse_check_fieldname(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 11 -> 12
              lv_state = 12.
              CONTINUE.
            ELSE.                                               " 11 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 12. "***********************************************

            CASE lv_word.
              WHEN 'IS'.                                      " 12 -> 13
                lv_state = 13.
                CONTINUE.
              WHEN 'BETWEEN'.                                 " 12 -> 15
                lv_state = 15.
                CONTINUE.
            ENDCASE.

*       check wether it is an operator
            READ TABLE lt_operators WITH KEY table_line = lv_word
              TRANSPORTING NO FIELDS.

            IF sy-subrc = 0.                                  " 12 -> 18
              lv_state = 18.
              CONTINUE.
            ELSE.                                               " 12 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 13. "***********************************************

            IF lv_word = 'NOT'.                               " 13 -> 14
              lv_state = 14.
              CONTINUE.
            ELSE.                                               " 13 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 14. "***********************************************

            IF lv_word = 'NULL'.                              " 14 -> 19
              lv_state = 19.
              CONTINUE.
            ELSE.                                               " 14 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 15. "***********************************************

*       check wether it's a valid value
            IF parse_check_value( lv_word ) = 'X'.            " 15 -> 16
              lv_state = 16.
              CONTINUE.
            ELSE.                                               " 15 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 16. "***********************************************

            IF lv_word = 'AND'.                               " 16 -> 17
              lv_state = 17.
              CONTINUE.
            ELSE.                                               " 16 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 17. "***********************************************

*       check wether it's a valid value
            IF parse_check_value( lv_word ) = 'X'.            " 17 -> 19
              lv_state = 19.
              CONTINUE.
            ELSE.                                               " 17 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

          WHEN 18. "***********************************************

*       check wether it is a valid field name (and no keyword)
            IF parse_check_fieldname(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 18 -> 19
              lv_state = 19.
              CONTINUE.
            ELSE.
*         check wether it's a valid value
              IF parse_check_value( lv_word ) = 'X'.          " 18 -> 19
                lv_state = 19.
                CONTINUE.
              ELSE.                                             " 18 -> error
                lv_error = 'X'.
                EXIT.
              ENDIF.
            ENDIF.

          WHEN 19. "***********************************************

            CASE lv_word.
              WHEN 'AND'.                                     " 19 -> 11
                lv_state = 11.
                CONTINUE.
              WHEN 'INNER'.                                   " 19 -> 6
                lv_state = 6.
                CONTINUE.
              WHEN 'LEFT'.                                    " 19 -> 5
                lv_state = 5.
                CONTINUE.
              WHEN 'OUTER'.                                   " 19 -> 6
                lv_state = 6.
                CONTINUE.
              WHEN 'JOIN'.                                    " 19 -> 7
                lv_state = 7.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = 'X'.            " 19 -> 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  " store table name
              CONTINUE.
            ELSE.                                               " 19 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.

        ENDCASE.

      ENDLOOP.

* ERROR state
      IF lv_error = 'X'.
        IF mv_log_handle IS INITIAL.
*     Message: '&1' was not expected in the FROM clause
          MESSAGE e008 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '008' iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

* check END state
      IF lv_state <> 2  AND
         lv_state <> 4  AND
         lv_state <> 19.   " an END state was not reached

        IF mv_log_handle IS INITIAL.
*     Message: FROM clause ended unexpectedly with '&1'
          MESSAGE e009 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '009' iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF ls_table_alias IS NOT INITIAL.
*   an END state was reached -> save last entry
        APPEND ls_table_alias TO mt_table_alias.
      ENDIF.

* get table fields from DDIC
      LOOP AT mt_table_alias INTO ls_table_alias.

        lv_tabix = sy-tabix.

*   check if already processed
        READ TABLE mt_table_fields
          WITH KEY table = ls_table_alias-table
          TRANSPORTING NO FIELDS.

        IF sy-subrc = 0.
          CONTINUE.
        ENDIF.

*   check if it is a transparent table
        SELECT tabname fieldname keyflag position
          FROM dd03vv
          APPENDING TABLE mt_table_fields
          WHERE tabname   = ls_table_alias-table    AND
                tabclass  = 'TRANSP'                AND
                as4local  = 'A'                     AND
                fieldname NOT LIKE '.%'             AND
                fieldname NOT LIKE '*%'             AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'
          ORDER BY position.

*   not a transparent table
        IF sy-subrc EQ 4.

*     check if it is a view
*     viewfield instead of fieldname, field alias may be defined in a view!
          SELECT viewname AS tabname viewfield keyflag objpos AS position
            FROM dd27s
            APPENDING TABLE mt_table_fields
            WHERE viewname  = ls_table_alias-table AND
                  as4local  = 'A' AND
*             possible to define * in views to include all fields from a table, and - to exclude a field
                  viewfield <> '*'                    AND
                  viewfield <> '-'                    AND
                  fieldname NOT LIKE '.%'             AND
                  fieldname NOT LIKE '*%'             AND
                  fieldname NOT LIKE '$_%' ESCAPE '$' AND
                  fieldname NOT LIKE '$%%' ESCAPE '$'
            ORDER BY position.

*     not a view
          IF sy-subrc EQ 4.

*       check if it is a Clustered table
            SELECT tabname fieldname keyflag position
              FROM dd03vv
              APPENDING TABLE mt_table_fields
              WHERE tabname   = ls_table_alias-table    AND
                    tabclass  = 'CLUSTER'               AND
                    as4local  = 'A'                     AND
                    fieldname NOT LIKE '.%'             AND
                    fieldname NOT LIKE '*%'             AND
                    fieldname NOT LIKE '$_%' ESCAPE '$' AND
                    fieldname NOT LIKE '$%%' ESCAPE '$'
              ORDER BY position.

*       not a Clustered table
            IF sy-subrc EQ 4.

*         check if it is a Pooled table
              SELECT tabname fieldname keyflag position
                FROM dd03vv
                APPENDING TABLE mt_table_fields
                WHERE tabname   = ls_table_alias-table    AND
                      tabclass  = 'POOL'                  AND
                      as4local  = 'A'                     AND
                      fieldname NOT LIKE '.%'             AND
                      fieldname NOT LIKE '*%'             AND
                      fieldname NOT LIKE '$_%' ESCAPE '$' AND
                      fieldname NOT LIKE '$%%' ESCAPE '$'
                ORDER BY position.

*         not a Pooled table
              IF sy-subrc EQ 4.
                IF mv_log_handle IS INITIAL.
*             Message: Table '&1' does not exist
                  MESSAGE e014 WITH ls_table_alias-table
                    RAISING table_not_exist.
                ELSE.
                  CALL METHOD add_message( iv_msgty = 'W' iv_msgid = 'ZSQL_FREE' iv_msgno = '014' iv_msgv1 = ls_table_alias-table ).
                  RAISE table_not_exist.
                ENDIF.
*         it is a Pooled table
              ELSE.
                ls_table_alias-type = 'P'.
                CLEAR mv_can_edit.
              ENDIF.

*       it is a Clustered table
            ELSE.
              ls_table_alias-type = 'C'.
              CLEAR mv_can_edit.
            ENDIF.

*     it is a view
          ELSE.

            ls_table_alias-type = 'V'.

            SELECT SINGLE viewgrant FROM dd25l INTO lv_viewgrant
              WHERE viewname = ls_table_alias-table AND
                    as4local = 'A'.

            IF sy-subrc EQ 0.
              IF lv_viewgrant EQ 'R'.
                CLEAR mv_can_edit.
              ENDIF.
            ENDIF.

          ENDIF.

*   it is a transparent table
        ELSE.
          ls_table_alias-type = 'T'.
        ENDIF.

        MODIFY mt_table_alias FROM ls_table_alias INDEX lv_tabix.

      ENDLOOP.

* complete missing table types
      LOOP AT mt_table_alias ASSIGNING <ls_table_alias>
           WHERE table IS INITIAL.

*   read the first record with the same table name
        READ TABLE mt_table_alias
          WITH KEY table = <ls_table_alias>-table
          INTO ls_table_alias.

        <ls_table_alias>-type = ls_table_alias-type.
      ENDLOOP.

*  SORT mt_table_fields BY table field.
*  DELETE ADJACENT DUPLICATES FROM mt_table_fields COMPARING table field.

* parse other tables (subqueries in the WHERE clause)
      CALL METHOD parse_adt_tables
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc <> 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = 'E'
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.
      ENDIF.
    ELSE.
      v_comando = 'X'.
    ENDIF.

  ENDMETHOD.                    "

  METHOD prepare_from_text.
* remove each '(' and ')'

    DATA: lv_length  TYPE i,
          lv_shift   TYPE i,
          lv_pos     TYPE i,
          lv_char(1) TYPE c.

    SEARCH cv_string FOR '%_HINT'.

    IF sy-subrc EQ 0.
      lv_pos = sy-fdpos - 1.
      cv_string = cv_string(lv_pos).
    ENDIF.

    lv_shift = -1.
    lv_length = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = '(' OR
         lv_char = ')'.
        lv_pos = lv_shift + 1.
        CONCATENATE cv_string(lv_shift) cv_string+lv_pos
          INTO cv_string SEPARATED BY space.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "

  METHOD prepare_sel_text.
* put a SPACE after each '(' and before each ')' so the parser
* can parse the words

    DATA: lv_length  TYPE i,
          lv_shift   TYPE i,
          lv_pos     TYPE i,
          lv_char(1) TYPE c.


    lv_shift = -1.
    lv_length = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = '('.
        lv_pos   =  lv_shift + 1.
        CONCATENATE cv_string(lv_pos) cv_string+lv_pos INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.

      IF lv_char = ')'.
        CONCATENATE cv_string(lv_shift) cv_string+lv_shift INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "


  METHOD rebuild_field_list.
* builds the field list of the SELECT clause into a string table

    DATA: ls_fieldinfo   LIKE LINE OF mt_fieldinfo,
          lv_string      TYPE string,
          lv_string2     TYPE string,
          ls_table_alias LIKE LINE OF mt_table_alias,
          lv_fieldname   TYPE fieldname.


    IF mt_fieldinfo IS INITIAL.
      MESSAGE e148 RAISING no_auth_for_columns.
    ENDIF.

* check that fields exist
    LOOP AT mt_fieldinfo INTO ls_fieldinfo WHERE orig_field NE '*'.

      READ TABLE mt_table_alias INTO ls_table_alias
        WITH KEY table = ls_fieldinfo-table.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &1 in table &2 (type &3)
          MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fieldinfo-field ls_fieldinfo-table '?' RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '038' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

      CASE ls_table_alias-type.

        WHEN 'T'.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = 'A' AND
                fieldname NOT LIKE '.%' AND
                fieldname NOT LIKE '*%' AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'.

        WHEN 'V'.

          SELECT SINGLE viewfield
          INTO lv_fieldname
          FROM dd27s
            WHERE viewname  = ls_fieldinfo-table AND
                  viewfield = ls_fieldinfo-field AND
                  as4local  = 'A' AND
                  fieldname NOT LIKE '.%' AND
                  fieldname NOT LIKE '*%' AND
                  fieldname NOT LIKE '$_%' ESCAPE '$' AND
                  fieldname NOT LIKE '$%%' ESCAPE '$'.

*      WHEN 'P'.
*
*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd03vv
*          WHERE tabname   = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = 'A' AND
*                fieldname NOT LIKE '.%' AND
*                fieldname NOT LIKE '*%' AND
*                fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                fieldname NOT LIKE '$%%' ESCAPE '$'.

        WHEN 'C' OR 'P'.

*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd16v
*          WHERE sqltab    = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = 'A' AND
*                fieldname NOT LIKE '.%' AND
*                fieldname NOT LIKE '*%' AND
*                fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                fieldname NOT LIKE '$%%' ESCAPE '$'.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = 'A' AND
                fieldname NOT LIKE '.%' AND
                fieldname NOT LIKE '*%' AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'.


      ENDCASE.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &1 in table &2 (type &3)
          MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fieldinfo-field ls_fieldinfo-table ls_table_alias-type RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '038' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDLOOP.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR: lv_string, lv_string2.

      IF ls_fieldinfo-agg_function IS INITIAL.    " aggragate function
        IF ls_fieldinfo-table_alias IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-table_alias '~' ls_fieldinfo-field INTO lv_string2.
        ELSE.
          MOVE ls_fieldinfo-orig_field TO lv_string2.
        ENDIF.

        CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY ' '.
      ELSE.
        CONCATENATE ls_fieldinfo-agg_function '(' INTO lv_string.

        IF ls_fieldinfo-distinctf = 'X'.
          CONCATENATE lv_string 'DISTINCT' INTO lv_string
            SEPARATED BY ' '.
        ENDIF.

        IF ls_fieldinfo-field = '*'.
          CONCATENATE lv_string '*' ')' INTO lv_string SEPARATED BY ' '.
        ELSE.
          IF ls_fieldinfo-table_alias IS NOT INITIAL.
            CONCATENATE ls_fieldinfo-table_alias '~' ls_fieldinfo-field INTO lv_string2.
          ELSE.
            MOVE ls_fieldinfo-orig_field TO lv_string2.
          ENDIF.
          CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY ' '.
          CONCATENATE lv_string  ')' INTO lv_string SEPARATED BY ' '.
        ENDIF.
      ENDIF.

      CONCATENATE lv_string 'AS' ls_fieldinfo-generated_field INTO lv_string SEPARATED BY ' '.
      SHIFT lv_string RIGHT BY 3 PLACES.
      APPEND lv_string TO ct_srccode.

    ENDLOOP.

  ENDMETHOD.                    "


  METHOD remove_duplicates.
* tackles with duplicates in the field list

    DATA: ls_fieldinfo      LIKE LINE OF mt_fieldinfo,
          ls_fieldinfo_copy LIKE LINE OF mt_fieldinfo,
          lv_same_cnt       TYPE i,
          lv_tabix          TYPE i,
          lv_string         TYPE string,
          lt_fieldinfo_copy LIKE mt_fieldinfo.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.
      IF ls_fieldinfo-field_alias IS NOT INITIAL.
        ls_fieldinfo-generated_field = ls_fieldinfo-field_alias.
      ELSEIF ls_fieldinfo-agg_function IS NOT INITIAL.
        CONCATENATE ls_fieldinfo-agg_function ls_fieldinfo-field
          INTO ls_fieldinfo-generated_field SEPARATED BY '_'.
      ELSE.
        ls_fieldinfo-generated_field = ls_fieldinfo-field.
      ENDIF.

*   CONNECTION is a reserved word, will cause a syntax error
      IF ls_fieldinfo-generated_field = 'CONNECTION'.
        ls_fieldinfo-generated_field = 'CONNECTION_'.
      ENDIF.

      TRANSLATE ls_fieldinfo-generated_field TO UPPER CASE.
      MODIFY mt_fieldinfo FROM ls_fieldinfo INDEX sy-tabix.
    ENDLOOP.

    lt_fieldinfo_copy[] = mt_fieldinfo[].

    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR lv_same_cnt.
      lv_tabix = sy-tabix.

      LOOP AT lt_fieldinfo_copy INTO ls_fieldinfo_copy
           FROM lv_tabix
           WHERE generated_field = ls_fieldinfo-generated_field.

        IF lv_tabix <> sy-tabix.

          IF ls_fieldinfo_copy-table = ls_fieldinfo-table.
            lv_same_cnt                 = lv_same_cnt + 1.
            ls_fieldinfo_copy-samecount = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY '_'.

            lv_string = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-generated_field lv_string
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY '_'.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

          IF ls_fieldinfo_copy-table <> ls_fieldinfo-table.
            IF ls_fieldinfo_copy-field_alias IS NOT INITIAL.
              ls_fieldinfo_copy-generated_field = ls_fieldinfo_copy-field_alias.
            ELSE.
              CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
                INTO lv_string SEPARATED BY '_'.
              ls_fieldinfo_copy-generated_field = lv_string.
            ENDIF.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

        ENDIF.

      ENDLOOP.

    ENDLOOP.

    mt_fieldinfo[] = lt_fieldinfo_copy[].

  ENDMETHOD.                    "


  METHOD check_inserted_orgcritdep.

    FIELD-SYMBOLS: <lt_inserted> TYPE ANY TABLE.

    ASSIGN it_inserted->* TO <lt_inserted>.

    IF sy-subrc NE 0.
      RAISE assign_error.
    ENDIF.



*             AUTHORITY-CHECK OBJECT 'S_TABU_LIN'
*             ID 'ORG_CRIT' FIELD ls_orgcrit_tabdep-org_crit
*             ID 'ACTVT' FIELD '02'
*             ID 'ORG_FIELD1' FIELD '__________'
*             ID 'ORG_FIELD2' FIELD '__________'
*             ID 'ORG_FIELD3' FIELD '__________'
*             ID 'ORG_FIELD4' FIELD '__________'
*             ID 'ORG_FIELD5' FIELD '__________'
*             ID 'ORG_FIELD6' FIELD '__________'
*             ID 'ORG_FIELD7' FIELD '__________'
*             ID 'ORG_FIELD8' FIELD '__________'.
*
*
*          IF sy-subrc = 1.
*            RAISE no_auth_for_inserted_records.
*          ENDIF.


  ENDMETHOD.                    "CHECK_INSERTED_ORGCRITDEP


ENDCLASS.                    "lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_command DEFINITION ABSTRACT.

  PUBLIC SECTION.

    DATA: mo_pipacs_command     TYPE REF TO lcl_htdb_cl_command,
          mt_srccode            TYPE lty_zhtdbt_string_tab,

          mr_lock_argument      TYPE REF TO data,
          mr_lock_argument_temp TYPE REF TO data,

          mv_last_display       TYPE lty_last_display_mode,
          mv_grid_modified      TYPE c,

          mv_colmn_header       TYPE c,
          mv_key_colmn_type     TYPE c,
          mv_command_type(2)    TYPE n.

    METHODS: execute_parsed_sql
      IMPORTING
        po_grid           TYPE REF TO cl_gui_alv_grid OPTIONAL
        po_tree           TYPE REF TO cl_gui_alv_tree OPTIONAL
        iv_simulation     TYPE char1 OPTIONAL
        iv_bg_proc        TYPE char1 OPTIONAL
        iv_bg_date        TYPE btcsdate OPTIONAL
        iv_bg_time        TYPE btcstime OPTIONAL
        iv_read_from_file TYPE flag OPTIONAL
      EXPORTING
        er_exception      TYPE REF TO cx_root
        et_srccode        TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        table_not_found
        parse_error
        exec_error
        error_occurred
        unlock_error
        arg_to_long
        foreign_lock
        foreign_lock_all_clients
        job_submit_error
        field_list_changed
        file_open_error
        no_auth_for_table,

* sima GET/SET cuccok
      set_commandtext IMPORTING p_commandtext TYPE gty_commandtext,
      get_type EXPORTING VALUE(ep_command_type) TYPE lty_commandtype,

      parse_commandtext
        IMPORTING
          p_on_load TYPE c OPTIONAL
          p_bf_test TYPE c OPTIONAL
        EXCEPTIONS
          error_occurred,

      constructor
        IMPORTING
          p_copy_from TYPE REF TO lcl_command OPTIONAL.


* VRANGES
**** value range cuccok begin
    DATA:
      it_ranges TYPE lty_zhdb_vrange_tab,
      is_x030l  TYPE x030l.

    DATA: mt_alias_ranges TYPE TABLE OF gty_alias_ranges,
          mt_ranges       TYPE TABLE OF gty_ranges.

**** value range cuccok end

* a jobb oldali fa itabja (tablanevek, value rangek) es node_key referencia table
    DATA: mt_outtab_tb     TYPE TABLE OF lty_zhtdb_alv_tab,
          mt_tab_node_xref TYPE TABLE OF gty_tab_node_xref.


* command type: select/update/delete/LAWB/script/select fae
    DATA: command_type    TYPE lty_commandtype,
          command_id      TYPE lty_commandid,
* hany sort erintett a command
          mv_dbcnt        TYPE i,
          mv_rowlen       TYPE i,
          mv_bytes        TYPE i,
* tree hierarchianban melyik szinten van
          treelevel       TYPE i,

* where text kulon
          where_text      TYPE gty_commandtext,

* command text mint string
          commandtext     TYPE gty_commandtext,
* generalt command text mint string
          gen_commandtext TYPE gty_commandtext,

* generalt text, obsolete lesz
          gen_text        TYPE source_table,
* original text, obsolete lesz (?)
          text            TYPE source_table,
          table_alias_tb  TYPE lty_zhtdb_table_aliases_tt,

*    DATA:  mv_tot_upd TYPE i,
*           mv_tot_ins TYPE i,
*           mv_tot_del TYPE i,
*           mv_upd TYPE i,
*           mv_ins TYPE i,
*           mv_del TYPE i,
* hany byte volt a teljes athozott result set
          mv_filtered     TYPE i,
          mv_pos          TYPE i.

    DATA:  alv_state TYPE i.

    DATA: mv_locked        TYPE c,
*           mv_locked_count TYPE i,

          mv_ctext_changed TYPE c.

  PRIVATE SECTION.



ENDCLASS.                    "LCL_COMMAND DEFINITION

CLASS lcl_select_command DEFINITION DEFERRED.

*----------------------------------------------------------------------*
*       CLASS lcl_application DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION.

  PUBLIC SECTION.


** brute force testing stuff

    TYPES: BEGIN OF mty_t_type,
             line(255),
*        LINE TYPE string,
           END OF mty_t_type.

    DATA:
      mv_log_handle TYPE balloghndl,
      ms_s_msg      TYPE bal_s_msg.

** brute force test end


    DATA: mv_tree_tb_width TYPE i,
          mv_result_height TYPE i.


    METHODS:

      remove_gen_programs,
      insert_stringtab_to_pos
        IMPORTING
          it_stringtab TYPE lty_zhtdbt_string_tab,

      check_s_tabu_dis
        IMPORTING
          iv_for_editing TYPE char1
          iv_tabname     TYPE tabname
        EXPORTING
          ev_auth        TYPE char1,

      issue_message
        IMPORTING
          iv_msgty        TYPE symsgty
          iv_msgno        TYPE symsgno
          iv_to_log       TYPE char1 DEFAULT ' '
          iv_msgid        TYPE symsgid DEFAULT sy-msgid
          iv_display_like TYPE char1 OPTIONAL
          iv_msgv1        TYPE any OPTIONAL
          iv_msgv2        TYPE any OPTIONAL
          iv_msgv3        TYPE any OPTIONAL
          iv_msgv4        TYPE any OPTIONAL,

      constructor,

      get_selected_word
        EXPORTING
          ep_word TYPE string,

      show_abap_docu,
      show_syntax_diagram,

      read_checktables
        IMPORTING
          sender  TYPE c
          i_ucomm TYPE sy-ucomm,

      create_txt_toolbar,

      handle_lq_ctx_sel
        IMPORTING
          sender  TYPE c
          e_ucomm TYPE sy-ucomm,

      handle_context_menu
        FOR EVENT context_menu OF cl_gui_abapedit "cl_gui_textedit
        IMPORTING menu sender,

      handle_f1_textedit
        FOR EVENT f1 OF cl_gui_abapedit, "cl_gui_textedit,


      handle_context_menu_selected
        FOR EVENT context_menu_selected OF cl_gui_abapedit "cl_gui_textedit
        IMPORTING fcode,

      handle_node_ctx_menu_sel_lq
        FOR EVENT node_context_menu_selected OF cl_gui_alv_tree
        IMPORTING fcode,

      handle_context_menu_tree_tb_n
        FOR EVENT node_context_menu_request OF cl_gui_alv_tree
        IMPORTING menu,

      handle_lq_context_menu
        IMPORTING
          sender   TYPE c
          e_object TYPE REF TO cl_ctmenu,


* tables tree
      handle_node_double_click
        FOR EVENT node_double_click OF cl_gui_alv_tree
        IMPORTING node_key,

*new*
      handle_dropdown_clicked
        FOR EVENT dropdown_clicked OF cl_gui_toolbar
        IMPORTING fcode posx posy.

    METHODS: refresh_status_indicators,
      display_table_grid,
      create_tb_tree_toolbar.

    METHODS:

      handle_function_selected
        FOR EVENT function_selected OF cl_gui_toolbar
        IMPORTING fcode,

      handle_function_selected_txt
        FOR EVENT function_selected OF cl_gui_toolbar
        IMPORTING fcode.
    METHODS:

      handle_context_menu_alv
        FOR EVENT context_menu_request OF cl_gui_alv_grid
        IMPORTING e_object sender,

      handle_menu_button
        FOR EVENT menu_button OF cl_gui_alv_grid
        IMPORTING e_object e_ucomm,

      handle_toolbar
        FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object e_interactive sender,

      handle_user_command
        FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm sender,

      handle_double_click
        FOR EVENT double_click OF cl_gui_alv_grid
        IMPORTING e_column e_row sender,

      handle_after_refresh
        FOR EVENT data_changed OF cl_gui_alv_grid.

    METHODS:
      set_column_settings IMPORTING p_mode TYPE sy-ucomm,
      set_key_field_settings IMPORTING p_mode TYPE sy-ucomm,
      set_column_headings,
      set_key_display_attributes,
      refresh_display.


ENDCLASS.                    "lcl_application DEFINITION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMANDS DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_commands DEFINITION.

  PUBLIC SECTION.

    TYPES: BEGIN OF gty_commands,
             seq_no     TYPE i,
             command_id TYPE lty_commandid,
             treelevel  TYPE i,
             command    TYPE REF TO lcl_command,
           END OF gty_commands.


    TYPES: BEGIN OF mty_ctypes_exclude,
             fcode TYPE rsmpe-func,
           END OF mty_ctypes_exclude.

    METHODS:
      transfer_text_to_command,

      generate_structure
        EXCEPTIONS
          empty_fieldinfo_tb
          command_is_not_select
          field_not_found,

      display
        IMPORTING
          po_grid TYPE REF TO cl_gui_alv_grid OPTIONAL
          po_tree TYPE REF TO cl_gui_alv_tree OPTIONAL,

      create_new_command
        IMPORTING
          p_command_type         TYPE lty_commandtype
          REFERENCE(p_copy_from) TYPE REF TO lcl_command OPTIONAL
          sql                    TYPE string OPTIONAL,
*                 p_during_initial_load TYPE c OPTIONAL,

      execute_command
        IMPORTING
          iv_mode           TYPE sy-ucomm
          iv_bg_proc        TYPE char1 OPTIONAL
          iv_bg_date        TYPE btcsdate OPTIONAL
          iv_bg_time        TYPE btcstime OPTIONAL
          iv_read_from_file TYPE flag OPTIONAL,

      parse_only_command
        IMPORTING
          p_on_load TYPE c OPTIONAL
        EXCEPTIONS
          no_id
          create_error
          no_parent
          parse_error,

      display_command,
      write_status_message.

    DATA:  command_count TYPE i VALUE 0.

    DATA: command_list    TYPE TABLE OF gty_commands,
          current_command TYPE REF TO lcl_command,
          prev_command    TYPE REF TO lcl_command.


ENDCLASS.                    "LCL_COMMANDS DEFINITION





*---------------------------------------------------------------------*
*       CLASS LCL_SELECT_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_select_command DEFINITION INHERITING FROM lcl_command.

  PUBLIC SECTION.

* backup tablebol select
    DATA: mo_pipacs_select TYPE REF TO lcl_htdb_cl_command_select.

    METHODS: execute_parsed_sql REDEFINITION,

      parse_commandtext REDEFINITION.

    METHODS:

      calculate_mv_rowlen,

      constructor
        IMPORTING
          p_copy_from TYPE REF TO lcl_select_command OPTIONAL.

    METHODS:
      assign_field_symbols.

    METHODS: assign_field_symbol
      IMPORTING p_fs           TYPE c
      CHANGING  VALUE(p_table) TYPE REF TO data.


    DATA: fcat                 TYPE lvc_t_fcat,
          prev_fcat            TYPE lvc_t_fcat,
          fieldinfo_tb         TYPE TABLE OF gty_fieldinfo,
          ddic_references      TYPE TABLE OF gty_ddicref,
          can_edit             TYPE c,

*           lock_results TYPE c,
          has_table_alias      TYPE c,
          has_duplicate_fields TYPE c,
          selected_rows        TYPE lvc_t_row,
          selected_rows2       TYPE lvc_t_roid.


    DATA: select_text   TYPE gty_commandtext,
          from_text     TYPE gty_commandtext,
          group_by_text TYPE gty_commandtext,
          having_text   TYPE gty_commandtext,
          order_by_text TYPE gty_commandtext.
*          sort_text TYPE gty_commandtext.

    DATA: result_table     TYPE REF TO data,
          display_table    TYPE REF TO data,
          deleted_table    TYPE REF TO data,
          updated_table    TYPE REF TO data,
          inserted_table   TYPE REF TO data,
          tree_table       TYPE REF TO data,
          returned_table   TYPE REF TO data,
          temp_table       TYPE REF TO data,
          undo_table       TYPE REF TO data,
          lawb_table       TYPE REF TO data,
          selfae_table     TYPE REF TO data,
          result_structure TYPE REF TO data,
          temp_structure   TYPE REF TO data,
          undo_structure   TYPE REF TO data.

    DATA: mv_read_from_file TYPE c.

*  PRIVATE SECTION.


ENDCLASS.                    "LCL_SELECT_COMMAND DEFINITION


DATA: g_application TYPE REF TO lcl_application,
      g_commands    TYPE REF TO lcl_commands.

DATA: gv_max_rowid TYPE i.

DATA: gt_dynpread TYPE TABLE OF dynpread.

DATA: gv_starttime TYPE i,
      gv_endtime   TYPE i,
      gv_deltatime TYPE i.

DATA: go_splitter_outer         TYPE REF TO cl_gui_splitter_container,
      go_splitter_inner         TYPE REF TO cl_gui_splitter_container,
      go_container_alv_tb       TYPE REF TO cl_gui_container,
      go_container_reklam       TYPE REF TO cl_gui_container,
      go_container_alv          TYPE REF TO cl_gui_container,
      go_container_textedit     TYPE REF TO cl_gui_container,
      go_container_for_inner_sp TYPE REF TO cl_gui_container.


*      g_html_viewer               TYPE REF TO cl_gui_html_viewer.


DATA: gt_selfae_jointext          TYPE source_table.
DATA: gc_nodekey_current_commands TYPE lvc_nkey.

DATA: gv_data_changed_finished TYPE c.

DATA: g_selected_nodekey TYPE lvc_nkey.

DATA: gv_autotest   TYPE c.

DATA: gt_outtab_tb                TYPE TABLE OF lty_zhtdb_alv_tab.


* changing the node style in the navtree
* tolnatej requirement
* must be global (in automation call)

*----------------------------------------------------------------------*
***INCLUDE ZHTDB_STATUS_0100O01 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  STATUS_0100  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM status_0100.

ENDMODULE.                 " STATUS_0100  OUTPUT

*&---------------------------------------------------------------------*
*&      Form  STATUS_0100
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM status_0100.

  DATA: l_hierarchy_header TYPE treev_hhdr,
        lt_events          TYPE cntl_simple_events,
        ls_events          TYPE cntl_simple_event,

        events             TYPE cntl_simple_events,
        event              TYPE cntl_simple_event.


  IF gv_0100_first_run = 'X'.  " first call of the screen

    SET PF-STATUS '100_MAIN'.
    SET TITLEBAR  '100_TITLE' WITH 'SQL'.

    gv_def_col_hdr = 'T'.
    gv_def_keycol_type = 'F'.

  ENDIF.

  IF g_application IS INITIAL.

    CREATE OBJECT g_application.

    CALL METHOD g_application->remove_gen_programs.

  ENDIF.


  IF go_splitter_outer IS INITIAL.

    g_application->mv_tree_tb_width = 25.
    g_application->mv_result_height = 50.



    CREATE OBJECT go_splitter_outer
      EXPORTING
        parent  = cl_gui_container=>default_screen " cl_gui_custom_container=>screen0 "go_container_main
        rows    = 2
        columns = 1.

    CALL METHOD go_splitter_outer->get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_for_inner_sp
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer->get_container
      EXPORTING
        row       = 2
        column    = 1
      RECEIVING
        container = go_container_alv
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CREATE OBJECT go_splitter_inner
      EXPORTING
        parent  = go_container_for_inner_sp
        rows    = 1
        columns = 3.

    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_textedit
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 2
      RECEIVING
        container = go_container_alv_tb
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 3
      RECEIVING
        container = go_container_reklam
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner->set_column_width
      EXPORTING
        id    = 3
        width = 30.

    go_splitter_inner->set_row_mode( mode = go_splitter_inner->mode_absolute ).

    CALL METHOD go_splitter_inner->set_column_sash
      EXPORTING
        id                = 2
        type              = cl_gui_splitter_container=>type_movable
        value             = cl_gui_splitter_container=>false
*         IMPORTING
*       RESULT            =
      EXCEPTIONS
        cntl_error        = 1
        cntl_system_error = 2
        OTHERS            = 3.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_refresh.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_view_excel.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_sum.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_check.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_subtot.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_info.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_help.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_layo-edit       = 'X'.
    gs_layo-zebra      = 'X'.
    gs_layo-stylefname = 'ZENITH_STYLE'.
    gs_layo-cwidth_opt = 'X'.
    gs_layo-ctab_fname = 'ZENITH_COLOR'.
    gs_layo-sel_mode   = 'D'.
    gs_layo-no_rowmove = 'X'.
    gs_layo-no_rowins  = 'X'.
    gs_layo-no_keyfix  = 'X'.
    gs_layo-smalltitle = 'X'.

    CREATE OBJECT g_alv
      EXPORTING
        i_parent = go_container_alv.

    CALL METHOD g_alv->set_ready_for_input
      EXPORTING
        i_ready_for_input = 0
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    SET HANDLER g_application->handle_toolbar               FOR ALL INSTANCES.
    SET HANDLER g_application->handle_user_command          FOR ALL INSTANCES.
    SET HANDLER g_application->handle_menu_button           FOR g_alv.
*    SET HANDLER g_application->handle_data_changed          FOR g_alv.
*    SET HANDLER g_application->handle_data_changed_finished FOR g_alv.
    SET HANDLER g_application->handle_double_click          FOR g_alv.
    SET HANDLER g_application->handle_context_menu_alv      FOR g_alv.

    gs_layo_tb-edit       = ' '.
    gs_layo_tb-cwidth_opt = 'X'.
    gs_layo_tb-sel_mode   = 'B'.

    CREATE OBJECT g_tree_tb
      EXPORTING
        parent                      = go_container_alv_tb
        node_selection_mode         = cl_gui_column_tree=>node_sel_mode_single
        item_selection              = ' '
        no_html_header              = 'X'
        no_toolbar                  = ''
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        illegal_node_selection_mode = 5
        failed                      = 6
        illegal_column_name         = 7.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->set_screen_update
      EXPORTING
        i_update = ' '.


    DATA: ls_fcat_tb TYPE lvc_s_fcat.

    ls_fcat_tb-fieldname = 'DDTEXT'.
    ls_fcat_tb-inttype = 'C'.
    ls_fcat_tb-intlen  = '255'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'TABLENAME'.
    ls_fcat_tb-rollname  = 'TABNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'FIELDNAME'.
    ls_fcat_tb-rollname  = 'FIELDNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'ALIAS'.
    ls_fcat_tb-rollname  = 'TABNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    LOOP AT gt_fcat_tb INTO gs_fcat_tb.
      IF gs_fcat_tb-fieldname = 'TABLENAME' OR
         gs_fcat_tb-fieldname = 'FIELDNAME' OR
         gs_fcat_tb-fieldname = 'ALIAS'.
        gs_fcat_tb-tech   = 'X'.
        gs_fcat_tb-no_out = 'X'.
      ENDIF.

      IF gs_fcat_tb-fieldname = 'DDTEXT'.
        gs_fcat_tb-coltext   = TEXT-145.
        gs_fcat_tb-tooltip   = TEXT-145.
        gs_fcat_tb-reptext   = TEXT-145.
        gs_fcat_tb-outputlen = 255.
        CLEAR: gs_fcat_tb-tech, gs_fcat_tb-no_out.
      ENDIF.

      MODIFY gt_fcat_tb FROM gs_fcat_tb.
    ENDLOOP.

    l_hierarchy_header-heading   = TEXT-137.
    l_hierarchy_header-width     = 40.
    l_hierarchy_header-width_pix = ''.

    CALL METHOD g_tree_tb->set_table_for_first_display
      EXPORTING
        is_hierarchy_header = l_hierarchy_header
      CHANGING
        it_fieldcatalog     = gt_fcat_tb
        it_outtab           = gt_outtab_tb
      EXCEPTIONS
        OTHERS              = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->get_registered_events
      IMPORTING
        events     = lt_events
      EXCEPTIONS
        cntl_error = 1
        OTHERS     = 2.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    ls_events-appl_event = ' '.
    ls_events-eventid = cl_gui_column_tree=>eventid_node_context_menu_req.
    APPEND ls_events TO lt_events.
*
*   ls_events-eventid = cl_gui_column_tree=>eventid_item_context_menu_req.
*   APPEND ls_events TO lt_events.

    ls_events-eventid = cl_gui_column_tree=>eventid_node_double_click.
    APPEND ls_events TO lt_events.

    CALL METHOD g_tree_tb->set_registered_events
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
        OTHERS                    = 4.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

*   SET HANDLER g_application->handle_function_selected      FOR g_toolbar_tb_tree.
    SET HANDLER g_application->handle_node_double_click      FOR g_tree_tb.
    SET HANDLER g_application->handle_node_ctx_menu_sel_lq   FOR g_tree_tb.
    SET HANDLER g_application->handle_context_menu_tree_tb_n FOR g_tree_tb.

*    CREATE OBJECT g_html_viewer
*      EXPORTING
*        parent = go_container_reklam.
*
*    DATA: lv_url(255) TYPE c.
*
*    CONCATENATE 'http://www.hovitaga.com/'
*    'oe_free_edition_reklam_tidy_20111028.php?h='
*    gc_hash
*    INTO lv_url.
*
*    CONDENSE lv_url NO-GAPS.
*
*    g_html_viewer->show_url( url = lv_url ).
    CREATE OBJECT o_event
      EXPORTING
        boton_borrar = 'X'.

    CREATE OBJECT o_alv
      EXPORTING
        o_container = go_container_reklam
        estructura  = 'ZTEMPS'
        o_event     = o_event.

    o_alv->registrar_enter( ).
    o_alv->registrar_mod( ).

    SELECT * FROM ztemps
      INTO TABLE i_sql
     WHERE clave = 'ZSQL_APC'
       AND ernam = sy-uname
     ORDER BY erdat DESCENDING erzet DESCENDING.

    o_alv->quitar_todos_botones_insercion( ).
    o_alv->set_field_text( campo = 'STRING' valor = 'SQL' ).
    o_alv->set_field_text( campo = 'SUBCLAVE' valor = 'Tabla' ).
    o_alv->set_field_text( campo = 'VALOR' valor = 'Grupo' ).
    o_alv->set_field_text( campo = 'TEXTO' valor = 'Comentario' ).
    o_alv->set_field_input( 'VALOR,TEXTO' ).
    o_alv->set_field_noout( 'CLAVE,INDICE,TEXTO,PERMANENTE' ).
    o_alv->set_orden( campo = 'ERDAT' down = 'X' ).
    o_alv->set_orden( campo = 'ERZET' down = 'X' ).

    o_alv->show( CHANGING tabla = i_sql ).

  ENDIF.

  IF g_textedit IS INITIAL.

    CREATE OBJECT g_textedit
      EXPORTING
        parent = go_container_textedit.

    SET HANDLER g_application->handle_context_menu FOR g_textedit.
    SET HANDLER g_application->handle_context_menu_selected FOR g_textedit.
    SET HANDLER g_application->handle_f1_textedit FOR g_textedit.

    event-eventid = cl_gui_textedit=>event_f1.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=>event_context_menu_selected.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=>event_context_menu.
    APPEND event TO events.

*REGISTER_EVENT_F1 ?

    CALL METHOD g_textedit->set_registered_events
      EXPORTING
        events                    = events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

* ZMI?
**  IF gt_dynpread IS NOT INITIAL.
**
**    CALL FUNCTION 'DYNP_UPDATE_FIELDS'
**      EXPORTING
**        dyname               = sy-repid
**        dynumb               = '0100'
**        request              = 'A'
**      TABLES
**        dynpfields           = gt_dynpread
**      EXCEPTIONS
**        invalid_abapworkarea = 1
**        invalid_dynprofield  = 2
**        invalid_dynproname   = 3
**        invalid_dynpronummer = 4
**        invalid_request      = 5
**        no_fielddescription  = 6
**        undefind_error       = 7
**        OTHERS               = 8.
**
**    IF sy-subrc <> 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
**                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.
**
**    CLEAR gt_dynpread.
**
**  ENDIF.

  IF gv_data_changed_finished EQ 'X'.

    CLEAR gv_data_changed_finished.

    CALL METHOD g_alv->set_focus
      EXPORTING
        control = g_alv
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ELSE.

    CALL METHOD g_textedit->set_focus
      EXPORTING
        control = g_textedit
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

  IF g_commands IS INITIAL.

    CREATE OBJECT g_commands.

    CALL METHOD g_application->create_tb_tree_toolbar.

    CALL METHOD g_commands->create_new_command
      EXPORTING
        p_command_type = 1.


  ENDIF.


ENDFORM.                    " STATUS_0100


*----------------------------------------------------------------------*
*       CLASS lcl_event_grid IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_grid IMPLEMENTATION.

  METHOD double_click.
    READ TABLE i_sql INTO l_sql INDEX e_row-index.
    IF sy-subrc = 0.
      SELECT SINGLE string FROM ztemps
        INTO l_sql-string
       WHERE clave = 'ZSQL_APC'
         AND subclave = l_sql-subclave
         AND indice = l_sql-indice.

      CLEAR i_lineas_sql.
      zcl_ap_string=>string2tabla( EXPORTING string   = l_sql-string
                                             longitud = 255
                                   CHANGING  tabla    = i_lineas_sql ).

**            zcl_ap_string=>string2tabla( EXPORTING string = l_sql-string
**                                         CHANGING tabla = l_select->text ).

*      CALL FUNCTION 'SWA_STRING_TO_TABLE'
*        EXPORTING
*          character_string           = l_sql-string
**         APPEND                     = ' '
*          LINE_SIZE                  = 255
**         CHECK_TABLE_TYPE           = ' '
*        IMPORTING
*          character_table            = i_lineas_sql
**         TOTAL_LENGTH               = TOTAL_LENGTH
**         LINE_SIZE_USED             = LINE_SIZE_USED
**         LINES_FILLED               = LINES_FILLED
**         LAST_LINE_LENGTH           = LAST_LINE_LENGTH
*        EXCEPTIONS
*          no_flat_charlike_structure = 1.

      CALL METHOD g_commands->create_new_command
        EXPORTING
          p_command_type = 1
          sql            = '*'.
    ENDIF.

  ENDMETHOD.                                               "double_click

  METHOD user_command.

    CASE e_ucomm .
      WHEN 'BORRAR'.
        o_alv->set_marca_filas_sel( EXPORTING campo = 'MANDT' CHANGING t_tabla = i_sql ).

        LOOP AT i_sql INTO l_sql WHERE mandt = 'X'.
          DELETE FROM ztemps
           WHERE clave = l_sql-clave
             AND subclave = l_sql-subclave
             AND indice = l_sql-indice.
          DELETE i_sql.
        ENDLOOP.
        o_alv->refrescar_grid( ).
    ENDCASE .

  ENDMETHOD.                                               "USER_COMMAND

  METHOD data_changed.
    DATA: ls_good     TYPE lvc_s_modi,
          i_cambios   TYPE lvc_t_modi,
          l_campo(40).
    FIELD-SYMBOLS <fs> TYPE any.

    i_cambios = er_data_changed->mt_good_cells.
    SORT i_cambios BY row_id.

    LOOP AT i_cambios INTO ls_good.
      AT NEW row_id.
        CLEAR l_sql.
        READ TABLE i_sql INTO l_sql INDEX ls_good-row_id.
      ENDAT.
      IF sy-subrc = 0.
        CONCATENATE 'L_SQL-' ls_good-fieldname INTO l_campo.
        ASSIGN (l_campo) TO <fs>.
        IF sy-subrc = 0.
          <fs> = ls_good-value.
        ENDIF.
      ENDIF.
      AT END OF row_id.
        MODIFY ztemps FROM l_sql.
      ENDAT.
    ENDLOOP.

  ENDMETHOD.                    "data_changed

ENDCLASS.                    "lcl_event_grid IMPLEMENTATION
*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100I01 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  PERFORM user_command_0100.

  CLEAR gv_0100_first_run.

ENDMODULE.                 " USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*&      Form  USER_COMMAND_0100
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100.

  CASE ok_code.


    WHEN 'SYNTAXD'.

*      PERFORM LOAD_DYNPRO USING '0100' sy-repid.
      CALL METHOD g_application->show_syntax_diagram.

    WHEN 'ABAPDOCU'.

      CALL METHOD g_application->show_abap_docu.

    WHEN 'EXEC' OR 'SIMULATE' OR 'EXEC_BG'.

      IF g_commands->current_command IS NOT INITIAL.


        CLEAR autotrace.
        CALL METHOD g_commands->execute_command
          EXPORTING
            iv_mode = ok_code.

      ELSE.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'I'
            iv_msgno        = '061'
            iv_display_like = 'E'.
*          message i061 DISPLAY LIKE 'E'.
      ENDIF.

  ENDCASE.

  CLEAR ok_code.

ENDFORM.                    " USER_COMMAND

*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100_EXITI1 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100_EXIT  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100_exit INPUT.

  PERFORM user_command_0100_exit.

ENDMODULE.                 " USER_COMMAND_0100_EXIT  INPUT
*&---------------------------------------------------------------------*
*&      Form  USER_COMMAND_0100_EXIT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100_exit .

  CASE ok_code.

    WHEN 'BACK' OR 'CANCEL' OR 'EXIT'.

      LEAVE TO SCREEN 0.

  ENDCASE.

ENDFORM.                    " USER_COMMAND_0100_EXIT



*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLAPPLICATION_I                           *
*&---------------------------------------------------------------------*


CLASS lcl_application IMPLEMENTATION.

  METHOD remove_gen_programs.

    DATA: lt_reports TYPE TABLE OF reposrc-progname,
          lv_report  TYPE reposrc-progname.

    SELECT progname
      INTO TABLE lt_reports
      FROM reposrc
      WHERE progname LIKE 'ZSQL_APC_TEMP%'.

    LOOP AT lt_reports INTO lv_report.

      CALL FUNCTION 'ENQUEUE_ES_PROG'
        EXPORTING
          mode_trdir     = 'E'
          name           = lv_report
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

      IF sy-subrc EQ 0.

*     delete program from the repository
        CALL FUNCTION 'RS_DELETE_PROGRAM'
          EXPORTING
            program            = lv_report
            suppress_checks    = 'X'
            suppress_popup     = 'X'
            with_includes      = ' '
            with_cua           = ' '
            with_documentation = ' '
            with_dynpro        = ' '
            with_textpool      = ' '
            skip_progress_ind  = 'X'
          EXCEPTIONS
            enqueue_lock       = 1
            object_not_found   = 2
            permission_failure = 3
            reject_deletion    = 4
            OTHERS             = 5.


        IF sy-subrc <> 0.

          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_display_like = 'W'
              iv_msgno        = sy-msgno
              iv_msgid        = sy-msgid.

        ENDIF.

        CALL FUNCTION 'DEQUEUE_ES_PROG'
          EXPORTING
            mode_trdir = 'E'
            name       = lv_report.

      ENDIF.

    ENDLOOP.


  ENDMETHOD.                    "remove_gen_programs



  METHOD issue_message.

    IF iv_msgid IS INITIAL.
      ms_s_msg-msgid = 'ZSQL_FREE'.
    ELSE.
      ms_s_msg-msgid = iv_msgid.
    ENDIF.

    IF iv_to_log EQ 'X' OR gv_autotest = 'X'.

      CLEAR ms_s_msg.

      IF iv_msgno IS INITIAL.
        RETURN.
      ENDIF.

      IF     iv_msgid = 'SD' AND iv_msgno = 94.
        RETURN.
      ELSEIF iv_msgid = 'FL' AND iv_msgno = 714.
        RETURN.
      ENDIF.

      ms_s_msg-msgno = iv_msgno.

      ms_s_msg-msgv1 = iv_msgv1.
      ms_s_msg-msgv2 = iv_msgv2.
      ms_s_msg-msgv3 = iv_msgv3.
      ms_s_msg-msgv4 = iv_msgv4.

      IF ms_s_msg-msgid IS INITIAL.
        ms_s_msg-msgid = 'ZSQL_FREE'.
      ENDIF.

      CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

      ms_s_msg-msgty = iv_msgty.
*      ms_s_msg-probclass = iv_probclass.

*      CALL FUNCTION 'BAL_LOG_MSG_CUMULATE'
*       EXPORTING
*         I_LOG_HANDLE               = mv_log_handle
*         I_S_MSG                    = ms_s_msg
*  *       I_COMPARE_ATTRIBUTES       = ' '
*  *       I_COMPARE_CONTEXT          = ' '
*  *       I_COMPARE_PARAMETERS       = ' '
*  *     IMPORTING
*  *       E_S_MSG_HANDLE             =
*  *       E_MSG_WAS_LOGGED           =
*  *       E_MSG_WAS_DISPLAYED        =
*       EXCEPTIONS
*         LOG_NOT_FOUND              = 1
*         MSG_INCONSISTENT           = 2
*         LOG_IS_FULL                = 3
*         OTHERS                     = 4
*                .
*      IF sy-subrc <> 0.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*               WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*      ENDIF.
*

      CALL FUNCTION 'BAL_LOG_MSG_ADD'
        EXPORTING
          i_log_handle = mv_log_handle
          i_s_msg      = ms_s_msg
        EXCEPTIONS
          OTHERS       = 1.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    ELSE.

      IF iv_msgno IS NOT INITIAL.
        MESSAGE ID     ms_s_msg-msgid
          TYPE         'S'
          NUMBER       iv_msgno
          DISPLAY LIKE iv_msgty " iv_display_like
          WITH         iv_msgv1 iv_msgv2 iv_msgv3 iv_msgv4 .
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "issue_message




  METHOD get_selected_word.

    DATA: l_from      TYPE i,
          l_to        TYPE i,
          l_from_line TYPE i,
          l_to_line   TYPE i,
          lt_text     TYPE source_table,
          l_text      LIKE LINE OF lt_text,
          lstr        TYPE string.
*          l_area      TYPE thead-tdname,


    CALL METHOD g_textedit->get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc <> 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
    CALL METHOD g_textedit->get_text
      IMPORTING
        table  = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'I'
          iv_msgno = '025'.
*      MESSAGE i025.
    ENDIF.

    READ TABLE lt_text INTO l_text INDEX l_from_line.

    lstr = l_text.

    CALL METHOD lcl_toolbox=>get_word_at_pos
      EXPORTING
        iv_string   = lstr
        iv_position = l_from
      IMPORTING
        ev_word     = ep_word.

  ENDMETHOD.                    "get_selected_word

  METHOD show_abap_docu.

    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: lt_search_results TYPE docu_search_abap,
          ls_search_results LIKE LINE OF lt_search_results.

    CALL FUNCTION 'ABAP_DOCU_SEARCH'
      EXPORTING
        keyword_or_text = l_word
      IMPORTING
        result          = lt_search_results.

    IF lt_search_results IS NOT INITIAL.

      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'S'
          iv_msgno = '062'
          iv_msgv1 = l_word.
*      MESSAGE s062 WITH l_word.

      DATA: l_name      TYPE thead-tdname.

      READ TABLE lt_search_results INTO ls_search_results INDEX 1.
      l_name = ls_search_results-object.

      CALL FUNCTION 'ABAP_DOCU_SHOW'
        EXPORTING
          area  = l_name(4)
          name  = l_name+4
          langu = sy-langu.

    ELSE.
*      MESSAGE w063 WITH l_word.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'W'
          iv_msgno = '063'
          iv_msgv1 = l_word.
    ENDIF.

  ENDMETHOD.                    "show_abap_docu


  METHOD show_syntax_diagram.


    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: l_keyword TYPE sy-repid.

    l_keyword = l_word.

    CALL FUNCTION 'RS_DISPLAY_SYNTAX_DIAGRAM'
      EXPORTING
        keyword = l_keyword.


  ENDMETHOD.                    "show_syntax_diagram




  METHOD constructor.


  ENDMETHOD.                    "lcl_application



  METHOD set_key_field_settings.

    DATA:           l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    IF p_mode = 'KEY_FIX'.
      l_select_command->mv_key_colmn_type = 'F'.
    ELSE.
      l_select_command->mv_key_colmn_type = 'N'.
    ENDIF.

  ENDMETHOD.                    "set_key_field_settings

  METHOD set_column_settings.

    DATA:
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    CASE p_mode.
      WHEN 'TXT_SHTXT'.
        l_select_command->mv_colmn_header = 'S'.
      WHEN 'TXT_GENFLD'.
        l_select_command->mv_colmn_header = 'G'.
      WHEN 'TXT_ALIAS'.
        l_select_command->mv_colmn_header = 'A'.
      WHEN 'TXT_FLD'.
        l_select_command->mv_colmn_header = 'T'.
    ENDCASE.

  ENDMETHOD.                    "set_column_settings

  METHOD handle_f1_textedit.

    CALL METHOD show_abap_docu.

  ENDMETHOD.                    "lcl_application



  METHOD handle_context_menu.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'PRETTY'
        text   = TEXT-023
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'ABAPDOCU'
        text   = TEXT-116
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'SYNTAXD'
        text   = TEXT-117
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_selected.

    CASE fcode.
      WHEN 'ABAPDOCU'.

        CALL METHOD show_abap_docu.

      WHEN 'SYNTAXD'.

        CALL METHOD show_syntax_diagram.

      WHEN 'PRETTY'.

        DATA: "l_text TYPE source_table,
              l_text TYPE rswsourcet.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
        CALL METHOD g_textedit->get_text
          IMPORTING
            table  = l_text
          EXCEPTIONS
*abaped            potential_data_loss = 1.
            OTHERS = 1.

        IF sy-subrc = 1.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'E'
              iv_msgno = '025'.
*          MESSAGE e025.
        ENDIF.

        IF l_text[] IS NOT INITIAL.


          CALL FUNCTION 'CREATE_PRETTY_PRINT_FORMAT'
            EXPORTING
              mode          = 'HIKEY'
            TABLES
              source        = l_text
            EXCEPTIONS
              syntax_errors = 1
              OTHERS        = 2.

          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.


*abaped    CALL METHOD g_textedit->set_text_as_r3table
          CALL METHOD g_textedit->set_text
            EXPORTING
              table  = l_text[]
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_alv.


  ENDMETHOD.                    "lcl_application


  METHOD handle_node_ctx_menu_sel_lq.

    CALL METHOD handle_lq_ctx_sel
      EXPORTING
        sender  = 'T'
        e_ucomm = fcode
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_tree_tb_n.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = 'T'
        e_object = menu
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD handle_lq_context_menu.

    DATA: lq_menu_inner               TYPE REF TO cl_ctmenu,
          lq_menu_outer               TYPE REF TO cl_ctmenu,
          lq_menu_selfae              TYPE REF TO cl_ctmenu,
          lq_menu_subquery            TYPE REF TO cl_ctmenu,
          lq_menu_table_i             TYPE REF TO cl_ctmenu,
          lq_menu_table_o             TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae        TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery      TYPE REF TO cl_ctmenu,
          lq_menu_table_i_prev        TYPE REF TO cl_ctmenu,
          lq_menu_table_o_prev        TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae_prev   TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery_prev TYPE REF TO cl_ctmenu,
          l_fcode                     TYPE ui_func,
          lt_dd08l                    TYPE TABLE OF dd08l,
          ls_table_alias              LIKE LINE OF g_commands->current_command->table_alias_tb,
          lstr(40)                    TYPE c,
          lstr4(40)                   TYPE c,
          lstr2                       TYPE string,
          lstr3                       TYPE string,
          lstr5                       TYPE string,
          lint                        TYPE i,
          ls_prev_linkedquery         LIKE gs_linkedquery,
          ls_linkedquery              LIKE gs_linkedquery,
*          l_prev_checktable TYPE dd08l-checktable,
*          l_prev_table TYPE dd08l-checktable,
*          l_prev_ddtext TYPE dd02t-ddtext,
*          l_prev_primpos TYPE dd05m-primpos,
          l_ddtext                    TYPE dd02t-ddtext.

    DATA: dd08v_ia    TYPE TABLE OF dd08v,
          dd05m_ia    TYPE TABLE OF dd05m,
          wa_dd05m_ia TYPE dd05m,
          state(1),
          l_tabname   TYPE dd08l-tabname.

*    CHECK g_commands->current_command->mv_locked IS INITIAL.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CALL METHOD e_object->add_separator
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK g_commands->current_command->command_type EQ gc_ctype_select OR
          g_commands->current_command->command_type EQ gc_ctype_selfae.

    LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias.

      CLEAR lt_dd08l.

      l_tabname = ls_table_alias-table.

      CALL FUNCTION 'DD_TBFK_GET'
        EXPORTING
*         FIELDNAME     = INCLFIELD
          get_state     = 'A'
          tabl_name     = l_tabname
          withtext      = 'X'
        IMPORTING
          got_state     = state
        TABLES
          dd05m_tab_a   = dd05m_ia
*         DD05M_TAB_N   = FK1_DD05M
          dd08v_tab_a   = dd08v_ia
*         DD08V_TAB_N   = FK1_DD08V
        EXCEPTIONS
          illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.

      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checkfield NE 'MANDT' OR checktable EQ 'T000'.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE as4local = 'A'
              AND tabname = wa_dd05m_ia-checktable
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = 'A'
                AND tabname = wa_dd05m_ia-checktable.

          IF sy-subrc NE 0.
*            message 'ZENITH:sdfgdsf' type 'E'.
          ENDIF.

        ENDIF.

        CONCATENATE ls_table_alias-alias '~' wa_dd05m_ia-forkey INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE wa_dd05m_ia-checktable '~' wa_dd05m_ia-checkfield INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE 'ON' lstr3 '=' lstr2 INTO lstr2 SEPARATED BY ' '.

        MOVE lstr2 TO lstr.

        lstr2 = lint.
        CONCATENATE 'LA_' lstr2 INTO l_fcode.
        CONDENSE l_fcode NO-GAPS.

        CLEAR gs_linkedquery.
        gs_linkedquery-fcode       = l_fcode.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-checktable.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos   TYPE TABLE OF gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.


    IF g_commands->current_command->mv_locked IS INITIAL.
      CREATE OBJECT lq_menu_inner.
      CREATE OBJECT lq_menu_outer.
      CREATE OBJECT lq_menu_subquery.
    ENDIF.

    CREATE OBJECT lq_menu_selfae.

    SORT gt_linkedquery BY checktable tabname primpos.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = '* ON'.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname '~' ls_linkedquery-fieldname INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-checkfield INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ELSE.
              CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ENDIF.

*              CONCATENATE ls_linkedquery-table '~' ls_linkedquery-field INTO lstr5.
*              CONDENSE lstr5  NO-GAPS.
*              CONCATENATE lstr4 lstr5 INTO lstr4 SEPARATED BY SPACE.
*
*              CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-checkfield INTO lstr3.
*              CONDENSE lstr3 NO-GAPS.
*
*              if lstr2 IS INITIAL.
*                CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
*              else.
*                CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
*              endif.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 1.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname  = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            CONCATENATE gs_linkedquery-fcode '_COMP' INTO l_fcode.
*            CONCATENATE 'I_' gs_linkedquery-fcode '_COMP' INTO l_fcode.
***            l_fcode = gs_linkedquery-fcode.

            gs_linkedquery_comp-fcode      = l_fcode.
            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

            CONCATENATE 'I_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_i_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_i_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'O_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_o_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_o_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'S_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_selfae_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_selfae_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'Q_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_subquery_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_subquery_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CLEAR l_fcode.

          ENDIF.

        ENDIF.

      ENDIF.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.

        IF g_commands->current_command->mv_locked IS INITIAL.
          CREATE OBJECT lq_menu_table_i.
          CREATE OBJECT lq_menu_table_o.
          CREATE OBJECT lq_menu_table_subquery.
        ENDIF.

        CREATE OBJECT lq_menu_table_selfae.

        CONCATENATE '(' gs_linkedquery-ddtext ')' INTO l_ddtext.
        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY ' '.

        IF g_commands->current_command->mv_locked IS INITIAL.

          CALL METHOD lq_menu_inner->add_submenu
            EXPORTING
              menu   = lq_menu_table_i
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_outer->add_submenu
            EXPORTING
              menu   = lq_menu_table_o
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_subquery->add_submenu
            EXPORTING
              menu   = lq_menu_table_subquery
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

        CALL METHOD lq_menu_selfae->add_submenu
          EXPORTING
            menu   = lq_menu_table_selfae
            text   = lstr
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      IF g_commands->current_command->mv_locked IS INITIAL.

        CONCATENATE 'I_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_i->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE 'O_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_o->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE 'Q_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_subquery->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CONCATENATE 'S_' gs_linkedquery-fcode INTO l_fcode.

      CALL METHOD lq_menu_table_selfae->add_function
        EXPORTING
          fcode  = l_fcode
          text   = gs_linkedquery-text
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      ls_prev_linkedquery = gs_linkedquery.

      IF g_commands->current_command->mv_locked IS INITIAL.
        lq_menu_table_i_prev        = lq_menu_table_i.
        lq_menu_table_o_prev        = lq_menu_table_o.
        lq_menu_table_subquery_prev = lq_menu_table_subquery.
      ENDIF.

      lq_menu_table_selfae_prev   = lq_menu_table_selfae.

    ENDLOOP.

    IF sender = 'T'.

      IF g_commands->current_command->mv_locked IS INITIAL.

        CALL METHOD lq_menu_inner->add_function
          EXPORTING
            fcode  = 'RELAT_I'
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_outer->add_function
          EXPORTING
            fcode  = 'RELAT_O'
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_subquery->add_function
          EXPORTING
            fcode  = 'RELAT_Q'
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CALL METHOD lq_menu_selfae->add_function
        EXPORTING
          fcode  = 'RELAT_S'
          text   = TEXT-028
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.
    lstr = TEXT-024.

    IF g_commands->current_command->mv_locked IS INITIAL.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_inner
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = TEXT-025.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_outer
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = TEXT-149.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_subquery
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD handle_function_selected_txt.

    CASE fcode.

      WHEN 'PRETTY'.

        IF g_commands->current_command->text IS NOT INITIAL.

**          CALL METHOD LCL_TOOLBOX=>pretty_printer
**            CHANGING
**              ct_source = g_commands->current_command->text.

          CALL FUNCTION 'PRETTY_PRINTER'
            EXPORTING
              inctoo             = ' '
            TABLES
              ntext              = g_commands->current_command->text
              otext              = g_commands->current_command->text
            EXCEPTIONS
              enqueue_table_full = 1
              include_enqueued   = 2
              include_readerror  = 3
              include_writeerror = 4
              OTHERS             = 5.
          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application


  METHOD handle_double_click.

    DATA: l_s_c   TYPE REF TO lcl_select_command,
          ls_fcat TYPE lvc_s_fcat.

    TRY.
        l_s_c ?= g_commands->current_command.

      CATCH cx_sy_move_cast_error.

    ENDTRY.

    READ TABLE l_s_c->fcat INTO ls_fcat
    WITH KEY fieldname = e_column.

    IF sy-subrc NE 0.
      EXIT.
    ENDIF.

    IF ls_fcat-rollname IS NOT INITIAL.
      CALL DIALOG 'RS_DD_DTEL_EDIT'
        EXPORTING
          mode    FROM 'S'
          objname FROM ls_fcat-rollname.
    ELSE.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty        = 'S'
          iv_msgno        = '115'
          iv_display_like = 'W'.
    ENDIF.

  ENDMETHOD.                    "lcl_application

*new*
  METHOD handle_dropdown_clicked.

    DATA: menu_dynamic TYPE REF TO cl_ctmenu.

    CREATE OBJECT menu_dynamic.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = 'T'
        e_object = menu_dynamic.

    CALL METHOD g_toolbar_tb_tree->track_context_menu
      EXPORTING
        context_menu = menu_dynamic
        posx         = posx
        posy         = posy.

  ENDMETHOD.                    "lcl_my_event_handler

  METHOD handle_node_double_click.

    DATA: lstr           TYPE string,
          ls_table_alias TYPE lty_zhtdb_table_aliases.

    CALL METHOD g_tree_tb->get_outtab_line
      EXPORTING
        i_node_key     = node_key
      IMPORTING
        e_outtab_line  = gs_outtab_tb
      EXCEPTIONS
        node_not_found = 1
        OTHERS         = 2.

    IF sy-subrc EQ 0.
      IF gs_outtab_tb-fieldname IS INITIAL.
        EXIT.
      ENDIF.
    ELSE.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

    READ TABLE g_commands->current_command->mt_ranges INTO gs_ranges
      WITH KEY table_alias = gs_outtab_tb-alias
               fieldname   = gs_outtab_tb-fieldname.

    IF sy-subrc NE 0.
*      MESSAGE e027.
      RETURN.
    ENDIF.

    CONCATENATE gs_ranges-fieldname 'IN' gs_ranges-node_text INTO lstr SEPARATED BY ' '.

    READ TABLE g_commands->current_command->table_alias_tb INTO ls_table_alias
      WITH KEY alias = gs_ranges-table_alias.

    IF sy-subrc EQ 0.
      IF ls_table_alias-alias IS NOT INITIAL.
        CONCATENATE ls_table_alias-alias '~' lstr INTO lstr.
      ENDIF.
    ELSE.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'E'
          iv_msgno = '027'.
*      MESSAGE e027.
    ENDIF.


    DATA: lt_vrange_text TYPE lty_zhtdbt_string_tab.

**    IF g_commands->current_command->where_text IS INITIAL.
**      CONCATENATE 'WHERE' lstr INTO lstr SEPARATED BY ' '.
**    ELSE.
**      CONCATENATE 'and' lstr INTO lstr SEPARATED BY ' '.
**    ENDIF.

    APPEND lstr TO lt_vrange_text.

    CALL METHOD insert_stringtab_to_pos
      EXPORTING
        it_stringtab = lt_vrange_text.

**    APPEND lstr TO l_text.

*abaped    CALL METHOD g_textedit->set_text_as_r3table
    CALL METHOD g_textedit->set_text
      EXPORTING
        table  = g_commands->current_command->text
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


**
**    CALL METHOD cl_gui_cfw=>dispatch
**      EXCEPTIONS
**        OTHERS = 1.
**
**    IF sy-subrc NE 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
**WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD insert_stringtab_to_pos.

    DATA: l_from            TYPE i,
          l_to              TYPE i,
          l_from_line       TYPE i,
          l_to_line         TYPE i,
          lv_lines          TYPE i,
          lv_middle_string  TYPE string,
          lt_text           TYPE source_table,
          lt_text_temp      TYPE source_table,
          l_text            LIKE LINE OF lt_text_temp,
          lstr              TYPE string,
          lstr2             TYPE string,
          lt_text_split     TYPE TABLE OF string,
          ls_sel_field_list TYPE string,
          lv_from_copy      TYPE i.

    CALL METHOD g_textedit->get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc <> 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
    CALL METHOD g_textedit->get_text
      IMPORTING
        table  = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'I'
          iv_msgno = '025'.
*      MESSAGE i025.
    ENDIF.

    DESCRIBE TABLE it_stringtab LINES lv_lines.
    READ TABLE lt_text INTO l_text INDEX l_from_line.
    READ TABLE it_stringtab INTO ls_sel_field_list INDEX 1.

    l_from = l_from - 1.

    IF l_from EQ 0.
      lstr2 = l_text.
      CLEAR lstr.
    ELSE.
      lstr  = l_text(l_from).
    ENDIF.

    l_text = l_text+l_from.
    lstr2  = l_text.

    IF lv_lines = 1.
      CONCATENATE lstr ls_sel_field_list lstr2 INTO lv_middle_string SEPARATED BY space.
    ELSE.
      CONCATENATE lstr ls_sel_field_list INTO lv_middle_string SEPARATED BY space.
    ENDIF.

    IF l_from_line > 1.
      lv_from_copy = l_from_line - 1.

      LOOP AT lt_text INTO lstr FROM 1 TO lv_from_copy.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.
    ENDIF.

    CALL METHOD lcl_toolbox=>split_string
      EXPORTING
        iv_string     = lv_middle_string
        iv_maxlen     = gc_line_length
      IMPORTING
        et_string_tab = lt_text_split.

    LOOP AT lt_text_split INTO lstr.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    LOOP AT it_stringtab INTO ls_sel_field_list FROM 2.

      CLEAR lt_text_split.

      IF sy-tabix = lv_lines.
        CONCATENATE ls_sel_field_list lstr2 INTO ls_sel_field_list
          SEPARATED BY space.
      ENDIF.

      CALL METHOD lcl_toolbox=>split_string
        EXPORTING
          iv_string     = ls_sel_field_list
          iv_maxlen     = gc_line_length
        IMPORTING
          et_string_tab = lt_text_split.

      LOOP AT lt_text_split INTO lstr.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.

    ENDLOOP.

    lv_from_copy = l_from_line + 1.

    LOOP AT lt_text INTO lstr FROM lv_from_copy.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    g_commands->current_command->text[] = lt_text_temp[].


  ENDMETHOD.                    "insert_stringtab_to_pos

  METHOD create_tb_tree_toolbar.

    DATA: lv_auth_ok TYPE c.

    CALL METHOD g_tree_tb->get_toolbar_object
      IMPORTING
        er_toolbar = g_toolbar_tb_tree
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK NOT g_toolbar_tb_tree IS INITIAL.

*new*
    SET HANDLER g_application->handle_dropdown_clicked  FOR g_toolbar_tb_tree.
    SET HANDLER g_application->handle_function_selected FOR g_toolbar_tb_tree.

    IF g_commands IS NOT INITIAL AND g_commands->current_command IS NOT INITIAL.

      lv_auth_ok = 'X'.

    ENDIF.


    CALL METHOD g_toolbar_tb_tree->delete_all_buttons
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


***    IF g_commands IS NOT INITIAL AND g_commands->current_command IS NOT INITIAL.
***      CHECK g_commands->current_command->mv_locked IS INITIAL.
***    ENDIF.

    DATA: lv_icontext TYPE iconquick.

    IF lv_auth_ok = 'X' AND ( g_commands->current_command->mv_locked = ' ' ).

      lv_icontext = TEXT-147.
      CALL METHOD g_toolbar_tb_tree->add_button
        EXPORTING
          fcode     = 'GET_TABLES'
          icon      = '@42@'
          butn_type = cntb_btype_button
          text      = ''
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

    lv_icontext = TEXT-050.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'DISPLAY'
        icon      = '@B_DISP@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-051.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'INDEXES'
        icon      = '@USEREL@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-052.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'TECH'
        icon      = '@B_DETL@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-053.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'GRAPH'
        icon      = '@56@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-054.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'TEXTTAB'
        icon      = '@B_TXDP@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-055.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'RUNTIMEOBJ'
        icon      = '@OBJELI@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-056.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'WHERE'
        icon      = '@B_BOOK@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-057.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'CONTENTS'
        icon      = '@B_LIST@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF lv_auth_ok = 'X' AND ( g_commands->current_command->mv_locked = ' ' ).
      lv_icontext = TEXT-058.
      CALL METHOD g_toolbar_tb_tree->add_button
        EXPORTING
          fcode     = 'VRANGES'
          icon      = '@BGMORE@'
          butn_type = cntb_btype_button
          text      = ''
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.
    ENDIF.

*new*

    lv_icontext = TEXT-169.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'LQA'
        icon      = '@B_TREE@'
        butn_type = cntb_btype_dropdown
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    "lcl_application

  METHOD create_txt_toolbar.

* nincs ilyen vaze

  ENDMETHOD.                    "lcl_application



  METHOD display_table_grid.

    DATA: ls_tb_alias_tb TYPE gty_table_aliases,
          l_command      TYPE REF TO lcl_command,
          ls_table       TYPE lty_zhtdb_alv_tab,
          l_node_text    TYPE lvc_value,
          l_new_node_key TYPE lvc_nkey,
          ls_node_style  TYPE lvc_s_layn,
          ls_rangename   TYPE lvc_value,
          ls_alias_range LIKE LINE OF l_command->mt_alias_ranges.


    l_command = g_commands->current_command.

*   CHECK l_command->mt_tab_node_xref IS INITIAL.
*   CLEAR l_command->mt_outtab_tb.

*   miert a where feltetel??
    DELETE l_command->mt_outtab_tb
      WHERE fieldname IS INITIAL.

*   CLEAR l_command->mt_outtab_tb.
    CLEAR l_command->mt_tab_node_xref.

    IF g_tree_tb IS INITIAL.
      RETURN.
    ENDIF.

    CALL METHOD g_tree_tb->delete_all_nodes
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    LOOP AT l_command->table_alias_tb INTO ls_tb_alias_tb.

      CLEAR ls_table.

      SELECT SINGLE ddtext
        INTO ls_table-ddtext
        FROM dd02t
        WHERE as4local   = 'A'                  AND
              tabname    = ls_tb_alias_tb-table AND
              ddlanguage = sy-langu.

      IF sy-subrc EQ 4.

        SELECT SINGLE ddtext
          INTO ls_table-ddtext
          FROM dd02t
          WHERE as4local = 'A'      AND
                tabname = ls_tb_alias_tb-table.

      ENDIF.

      IF ls_tb_alias_tb-alias IS NOT INITIAL.
        ls_table-alias     = ls_tb_alias_tb-alias.
      ELSE.
        ls_table-alias     = ls_tb_alias_tb-table.
      ENDIF.

      ls_table-tablename = ls_tb_alias_tb-table.

      APPEND ls_table TO l_command->mt_outtab_tb.

      READ TABLE l_command->mt_alias_ranges
      WITH KEY table_alias = ls_table-alias
      TRANSPORTING NO FIELDS.

      IF sy-subrc NE 0.
        CLEAR ls_alias_range.
        ls_alias_range-table_alias = ls_table-alias.

        APPEND ls_alias_range TO l_command->mt_alias_ranges.
      ENDIF.

    ENDLOOP.

*   add tables to tree
    LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS INITIAL.

      READ TABLE l_command->table_alias_tb INTO ls_tb_alias_tb
        WITH KEY alias = gs_outtab_tb-alias.

      IF ls_tb_alias_tb-table NE ls_tb_alias_tb-alias.
        CONCATENATE ls_tb_alias_tb-table 'as' ls_tb_alias_tb-alias INTO l_node_text SEPARATED BY ' '.
      ELSE.
        l_node_text = ls_tb_alias_tb-table.
      ENDIF.

*      SELECT SINGLE viewname
*      FROM dd25l
*      INTO ls_dd25l-viewname
*      WHERE AS4LOCAL = 'A'
*            and viewname = ls_tb_alias_tb-table.

      CASE ls_tb_alias_tb-type.
        WHEN 'T'.
          ls_node_style-exp_image = '@PO@'.
          ls_node_style-n_image = '@PO@'.
        WHEN 'V'.
          ls_node_style-exp_image = '@A2@'.
          ls_node_style-n_image = '@A2@'.
        WHEN 'C'.
          ls_node_style-exp_image = '@AP@'.
          ls_node_style-n_image = '@AP@'.
        WHEN 'P'.
          ls_node_style-n_image = '@AQ@'.
          ls_node_style-exp_image = '@AQ@'.
      ENDCASE.

      CALL METHOD g_tree_tb->add_node
        EXPORTING
          i_relat_node_key = ''
          i_relationship   = cl_gui_column_tree=>relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = l_node_text
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      gs_tab_node_xref-tablename = gs_outtab_tb-tablename.
      gs_tab_node_xref-alias     = gs_outtab_tb-alias.
      gs_tab_node_xref-node_key  = l_new_node_key.
      APPEND gs_tab_node_xref TO l_command->mt_tab_node_xref.

    ENDLOOP.

    ls_node_style-n_image = '@1E@'.

*   add fields
    LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS NOT INITIAL.

      READ TABLE l_command->mt_tab_node_xref
        INTO gs_tab_node_xref
        WITH KEY alias = gs_outtab_tb-alias.
*      WITH KEY tablename = gs_outtab_tb-tablename.

      IF sy-subrc NE 0.
*        MESSAGE i027.
        CONTINUE.
      ENDIF.

      IF gs_outtab_tb-tablename NE gs_outtab_tb-alias.
        CONCATENATE 'R_' gs_outtab_tb-alias '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      ELSE.
        CONCATENATE 'R_' gs_outtab_tb-tablename '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      ENDIF.

*      CONCATENATE 'R_' gs_outtab_tb-tablename '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      REPLACE ' ' WITH '' INTO ls_rangename.
      CONDENSE ls_rangename NO-GAPS.

      CALL METHOD g_tree_tb->add_node
        EXPORTING
          i_relat_node_key = gs_tab_node_xref-node_key
          i_relationship   = cl_gui_column_tree=>relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = ls_rangename
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD g_tree_tb->expand_node
        EXPORTING
          i_node_key = gs_tab_node_xref-node_key
        EXCEPTIONS
          OTHERS     = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDLOOP.

    CALL METHOD g_tree_tb->frontend_update
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD refresh_status_indicators.

    DATA: lstr           TYPE string,
          l_command_type TYPE lty_commandtype.

*      try.
*        l_s_c ?= g_commands->current_command.
*
*      catch cx_sy_move_cast_error.
*        EXIT.
*      endtry.

    CALL METHOD g_commands->current_command->get_type
      IMPORTING
        ep_command_type = l_command_type
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CASE l_command_type.
      WHEN gc_ctype_select OR
           gc_ctype_selfae OR
           gc_ctype_lawb.

      WHEN OTHERS.
        EXIT.
    ENDCASE.

    CLEAR gt_dynpread.

*      CLEAR: lstr, lstr2.
*
*      lstr2 = g_commands->current_command->mv_dbcnt.
*      CONCATENATE lstr 'Rows fetched:' lstr2 INTO lstr SEPARATED BY ' '.

    DATA: lv_cnt_updated  TYPE i,
          lv_cnt_inserted TYPE i,
          lv_cnt_deleted  TYPE i.

    MESSAGE i030 WITH g_commands->current_command->mv_dbcnt lv_cnt_updated lv_cnt_inserted lv_cnt_deleted INTO lstr.

****    MESSAGE i137 WITH lstr g_commands->current_command->mv_from g_commands->current_command->mv_to INTO lstr.

*new*
    DATA: lv_title TYPE lvc_title.

    lv_title = lstr.

    CALL METHOD g_alv->set_gridtitle
      EXPORTING
        i_gridtitle = lv_title.

*    gs_dynpread-fieldname = 'STATUS1'.
*    gs_dynpread-fieldvalue = lstr.
*    APPEND gs_dynpread TO gt_dynpread.
*
*    IF g_alv IS NOT INITIAL AND g_commands->current_command->mv_grid_modified IS NOT INITIAL.
*      CALL METHOD g_alv->set_toolbar_interactive
*        EXCEPTIONS
*          OTHERS = 1.
*
*      IF sy-subrc NE 0.
*        IF sy-msgno IS NOT INITIAL.
*          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
*                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*        ENDIF.
*      ENDIF.
*    ENDIF.
*
*    CALL METHOD cl_gui_cfw=>set_new_ok_code
*      EXPORTING
*        new_code = 'ENT'
*      IMPORTING
*        rc       = l_int
*      EXCEPTIONS
*        OTHERS   = 1.
*
*    IF sy-subrc NE 0.
*      IF sy-msgno IS NOT INITIAL.
*        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*      ENDIF.
*    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD handle_after_refresh.

  ENDMETHOD.                    "lcl_application

  METHOD check_s_tabu_dis.

    DATA: x030l_wa     TYPE x030l,
          activity(2)  TYPE c,
          client_indep TYPE c,
          lv_tddat     TYPE tddat,
          lv_tabname   TYPE tabname.

    CLEAR client_indep.

    lv_tabname = iv_tabname.
    TRANSLATE lv_tabname TO UPPER CASE.

*   determine activity
    IF iv_for_editing IS INITIAL.
      activity = '03'.
    ELSE.
      activity = '02'.
    ENDIF.

*   client independent?
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = lv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos = 0.
      client_indep = 'X'.
    ENDIF.

*   check normal table maintenace authority
    SELECT SINGLE * FROM tddat INTO lv_tddat
                    WHERE tabname = lv_tabname.

    IF sy-subrc <> 0  OR lv_tddat-cclass IS INITIAL.
      lv_tddat-cclass = '&NC&'.        " 'non classified table'
    ENDIF.

    ev_auth = 'X'.

    AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
                    ID     'ACTVT'      FIELD activity
                    ID     'DICBERCLS'  FIELD lv_tddat-cclass.

    IF sy-subrc <> 0.
      CLEAR ev_auth.
    ENDIF.

*   check authority for client independent changes
    IF client_indep   = 'X' AND
       iv_for_editing = 'X'.

      AUTHORITY-CHECK OBJECT 'S_TABU_CLI'
                      ID     'CLIIDMAINT' FIELD 'X'.

      IF sy-subrc <> 0.
        CLEAR ev_auth.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    " check_s_tabu_dis


  METHOD handle_toolbar.

    DATA: ls_toolbar        TYPE stb_button,
          lv_not_modified   TYPE c,
          lv_display_only   TYPE c,
          lv_undo_not_empty TYPE c,
          lv_read_from_file TYPE c,
          l_select          TYPE REF TO lcl_select_command.


    IF sender NE g_alv.
      EXIT.
    ENDIF.

    TRY.
        l_select ?= g_commands->current_command.

        lv_read_from_file = l_select->mv_read_from_file.

        IF l_select->alv_state EQ 0.
          lv_display_only = 'X'.
        ELSE.
          lv_display_only = ' '.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error5' TYPE 'E'.
    ENDTRY.

    IF <gt_undo> IS ASSIGNED AND <gt_undo> IS NOT INITIAL.
      lv_undo_not_empty = 'X'.
    ENDIF.

    IF g_commands->current_command->mv_grid_modified EQ 'X'.
      lv_not_modified = ' '.
    ELSE.
      lv_not_modified = 'X'.
    ENDIF.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    INSERT ls_toolbar INTO e_object->mt_toolbar INDEX 1.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=>mc_fc_select_all TO ls_toolbar-function.
    MOVE icon_select_all TO ls_toolbar-icon.
    MOVE TEXT-061 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=>mc_fc_deselect_all TO ls_toolbar-function.
    MOVE icon_deselect_all TO ls_toolbar-icon.
    MOVE TEXT-062 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 'TXT_MENU' TO ls_toolbar-function.
    MOVE icon_display_text TO ls_toolbar-icon.
    MOVE TEXT-063 TO ls_toolbar-quickinfo.
    MOVE 2 TO ls_toolbar-butn_type.
    MOVE space TO ls_toolbar-disabled.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object->mt_toolbar.



  ENDMETHOD.                    "lcl_application


  METHOD handle_function_selected.

    DATA: l_tabname         TYPE tabname,
          l_aliasname       TYPE string,
          l_texttabname     TYPE dd08v-tabname,
          fpopup            TYPE c,
          l_ok_code         TYPE sy-ucomm,
          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key        TYPE lvc_nkey,
          l_new_node_key    TYPE lvc_nkey,
          l_command         TYPE REF TO lcl_command,
          ls_table_alias_tb LIKE LINE OF l_command->table_alias_tb.


    CHECK g_commands->current_command IS NOT INITIAL.

*new*
    IF fcode+2(3) EQ 'LA_' OR fcode(5) EQ 'RELAT'.

      CALL METHOD handle_lq_ctx_sel
        EXPORTING
          sender  = 'T'
          e_ucomm = fcode
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ELSEIF fcode = 'GET_TABLES'.

      CALL METHOD g_commands->parse_only_command
        EXCEPTIONS
          no_id        = 1
          create_error = 2
          no_parent    = 3
          parse_error  = 4
          OTHERS       = 5.

      CASE sy-subrc.
        WHEN 1.
*          message s077 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '077'
              iv_display_like = 'E'.
          RETURN.
        WHEN 2.
*          message s076 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '076'
              iv_display_like = 'E'.
          RETURN.
        WHEN 3.
*          MESSAGE s050 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '050'
              iv_display_like = 'E'.
          RETURN.
        WHEN 4.
*  this would override detailed information
*          message s079 DISPLAY LIKE 'E'.
          RETURN.
        WHEN 5.
          RETURN.

      ENDCASE.

      RETURN.

    ENDIF.

    CALL METHOD g_tree_tb->get_selected_nodes
      CHANGING
        ct_selected_nodes = lt_selected_nodes
      EXCEPTIONS
        cntl_system_error = 1
        dp_error          = 2
        failed            = 3
        OTHERS            = 4.

    IF sy-subrc <> 0.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'E'
          iv_msgno = '031'.
*      MESSAGE e031.
    ENDIF.

    READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

    IF sy-subrc EQ 0.

      l_node_key = ls_selected_nodes-node_key.

      CLEAR gs_outtab_tb.

      CALL METHOD g_tree_tb->get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*         E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      IF sy-subrc <> 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      IF gs_outtab_tb IS INITIAL AND fcode NE 'VRANGES'.
        EXIT.
      ENDIF.

*     MOVE gs_outtab_tb-tablename TO l_aliasname.
*     MOVE ls_table_alias_tb-alias TO l_aliasname.
      MOVE gs_outtab_tb-alias TO l_aliasname.

      l_command = g_commands->current_command.

      READ TABLE l_command->table_alias_tb INTO ls_table_alias_tb
        WITH KEY alias = l_aliasname.

      IF sy-subrc NE 0.
        RETURN.
      ENDIF.

      IF fcode = 'VRANGES'             AND
         ls_table_alias_tb-type NE 'T' AND
         ls_table_alias_tb-type NE 'V'.
        MESSAGE i121 DISPLAY LIKE 'W' WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

      MOVE ls_table_alias_tb-table TO l_tabname.

*      IF l_aliasname IS INITIAL AND fcode EQ 'VRANGES'.
*        EXIT.
*      ENDIF.

    ELSE.
      RETURN.
    ENDIF.

    CASE fcode.

      WHEN 'GRAPH'.

        TYPE-POOLS: sdg1.
        DATA: obj_tab TYPE sdg1_obj,
              obj_def TYPE sdg1_obj1.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        obj_def-obj_name = l_tabname.
        obj_def-type     = 'TABL'.
        CLEAR obj_tab.
        APPEND obj_def TO obj_tab.

        CLEAR sy-msgno.
        CALL FUNCTION 'REPOSITORY_STRUCTURE_GRAPH'
          EXPORTING
            type    = 'TABL'
          TABLES
            objects = obj_tab
          EXCEPTIONS
            OTHERS  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      WHEN 'DISPLAY'.

        DATA: lv_type TYPE string.

        CASE ls_table_alias_tb-type.

          WHEN 'T'.
            lv_type = 'TABL'.

          WHEN 'V'.
            lv_type = 'VIEW'.

          WHEN 'C'.
            lv_type = 'SQLT'.

          WHEN 'P'.
            lv_type = 'SQLT'.

        ENDCASE.

        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation           = 'SHOW'
            object_name         = l_tabname
            object_type         = lv_type
*           ENCLOSING_OBJECT    =
*           POSITION            = ' '
*           DEVCLASS            =
*           INCLUDE             =
*           VERSION             = ' '
*           MONITOR_ACTIVATION  = 'X'
*           WB_MANAGER          =
*           IN_NEW_WINDOW       =
*           WITH_OBJECTLIST     = ' '
*           WITH_WORKLIST       = ' '
*         IMPORTING
*           NEW_NAME            =
*           WB_TODO_REQUEST     =
*         TABLES
*           OBJLIST             =
          EXCEPTIONS
            not_executed        = 1
            invalid_object_type = 2
            OTHERS              = 3.
        IF sy-subrc <> 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.


      WHEN 'TECH'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        PERFORM mem_export.
        SET PARAMETER ID 'DTB' FIELD l_tabname.
        CALL TRANSACTION 'SE13' AND SKIP FIRST SCREEN.

      WHEN 'INDEXES'.

*       if ddxx-tabclass ne 'TRANSP'.
*         Indexpflege nur fr transparente Tabellen mglich
*         message s807.
*       else.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'DD_LIST_INDEX'
          EXPORTING
            objname = l_tabname
          IMPORTING
            fcode   = l_ok_code.


      WHEN 'RUNTIMEOBJ'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        SUBMIT rutdbdsp AND RETURN WITH objname EQ l_tabname
                                   WITH display EQ 2.

*        SUBMIT rutntchk AND RETURN WITH tabname EQ l_tabname
*                                   WITH ttype   EQ 'TABL'
*                                   WITH status  EQ 'A'
*                                   WITH showonly EQ 'X'.

      WHEN 'TEXTTAB'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'DDUT_TEXTTABLE_GET'
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            texttable = l_texttabname.

        IF l_texttabname IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '032'
              iv_msgv1 = l_tabname.
*          MESSAGE i032 WITH l_tabname.
        ELSE.
          CLEAR fpopup.
          CALL DIALOG 'RS_DD_FIEL_SHOW'
            EXPORTING
              objname FROM l_texttabname.
        ENDIF.


      WHEN 'CONTENTS'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'RS_NAVIGATION_BREAK'.

        CLEAR sy-msgno.
        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation   = 'TAB_CONT'
            object_name = l_tabname
            object_type = 'TABL'
                          EXCEPTIONS
                          not_executed.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.

        ENDIF.

        CALL FUNCTION 'RS_NAVIGATION_BREAK_RESET'.


      WHEN 'WHERE'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'RS_NAVIGATION_BREAK'.

        CLEAR sy-msgno.
        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation          = 'CROSSREF'
            object_name        = l_tabname
            object_type        = 'DT'
            monitor_activation = 'X'
          EXCEPTIONS
            OTHERS             = 01.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL FUNCTION 'RS_NAVIGATION_BREAK_RESET'.
* VRANGES
      WHEN 'VRANGES'.

        DATA: it_fdiff       TYPE TABLE OF field_dif,
              it_dfies       TYPE TABLE OF dfies,
              is_fdiff       TYPE field_dif,
              lt_tables      TYPE TABLE OF rsdstabs,
              is_tables      TYPE rsdstabs,
              lt_ranges      TYPE rsds_trange,
              ls_range2      LIKE LINE OF lt_ranges, " TYPE rsds_range, "lty_zhdb_vrange-rsds_range,
              it_ranges2     TYPE rsds_trange,
              is_ranges2     LIKE LINE OF it_ranges2,
              is_ranges      LIKE LINE OF l_command->it_ranges,
              l_tabix        TYPE i,
              it_frange      TYPE rsds_frange_t,
              is_frange      LIKE LINE OF it_frange,
              ls_frange2     LIKE LINE OF it_frange,
              l_where_text   TYPE string,
              ls_alias_range LIKE LINE OF l_command->mt_alias_ranges,
              ls_rangename   TYPE lvc_value,
              lt_where       TYPE rsds_twhere,
              ls_where       TYPE rsds_where,
              l_line         LIKE LINE OF ls_where-where_tab,
              ls_node_style  TYPE lvc_s_layn,

              lt_field_desc  TYPE TABLE OF fldconvert,

              lt_fields      TYPE TABLE OF rsdsfields,
              ls_fields      TYPE rsdsfields.

        CLEAR lt_tables.

        CHECK l_command IS NOT INITIAL.

        READ TABLE l_command->mt_alias_ranges INTO ls_alias_range
          WITH KEY table_alias = l_aliasname.

        IF sy-subrc EQ 0.

*          if ls_table_alias_tb-type = 'C' or ls_table_alias_tb-type = 'P'.
*
*            LOOP AT l
*
*          endif.

          l_tabix = sy-tabix.

          READ TABLE l_command->it_ranges INTO is_ranges
          WITH KEY alias = l_aliasname.

          IF sy-subrc EQ 0.

            CLEAR lt_ranges.

            APPEND is_ranges-rsds_range TO lt_ranges.

            CALL FUNCTION 'FREE_SELECTIONS_RANGE_2_EX'
              EXPORTING
                field_ranges = lt_ranges
              IMPORTING
                expressions  = ls_alias_range-expr.

            LOOP AT lt_ranges INTO is_ranges2.

              LOOP AT is_ranges2-frange_t INTO is_frange.

                ls_fields-tablename = l_tabname.
                ls_fields-fieldname = is_frange-fieldname.

                APPEND ls_fields TO lt_fields.

              ENDLOOP.

            ENDLOOP.

          ENDIF.

        ENDIF.

        REFRESH: it_fdiff.
        is_fdiff-tabname = l_tabname.

        CLEAR it_dfies.
        CLEAR sy-msgno.

        CALL FUNCTION 'DDIF_NAMETAB_GET'
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            x030l_wa  = l_command->is_x030l
          TABLES
            dfies_tab = it_dfies
          EXCEPTIONS
            OTHERS    = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        IF l_command->is_x030l IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'E'
              iv_msgno = '033'
              iv_msgv1 = l_tabname.
*          MESSAGE e033 WITH l_tabname.
*       ELSEIF l_command->is_x030l-tabtype NE 'T'.
*         message 'ZENITH:is not selectable' TYPE 'E'.
*       ELSEIF l_command->is_x030l-align NE 0.
*         message 'ZENITH:has alignment - cannot continue' TYPE 'E'.
        ENDIF.

        is_tables-prim_tab = ls_table_alias_tb-table.
        APPEND is_tables TO lt_tables.

        IF ls_alias_range-sel_id IS INITIAL.
*         Init free selection dialog
          CLEAR sy-msgno.
          CALL FUNCTION 'FREE_SELECTIONS_INIT'
            EXPORTING
              expressions  = ls_alias_range-expr
            IMPORTING
              selection_id = ls_alias_range-sel_id
              expressions  = ls_alias_range-expr
            TABLES
              tables_tab   = lt_tables
              fields_tab   = lt_fields
              field_desc   = lt_field_desc
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.
        ENDIF.

*       Display free selection dialog
        CLEAR sy-msgno.
        CALL FUNCTION 'FREE_SELECTIONS_DIALOG'
          EXPORTING
            selection_id            = ls_alias_range-sel_id
            title                   = TEXT-077
            as_window               = 'X'
          IMPORTING
            expressions             = ls_alias_range-expr
            field_ranges            = lt_ranges
            number_of_active_fields = ls_alias_range-active
          TABLES
            fields_tab              = ls_alias_range-fields
          EXCEPTIONS
            OTHERS                  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
          EXIT.
        ENDIF.

        LOOP AT lt_ranges INTO ls_range2.
          DELETE l_command->it_ranges WHERE alias = l_aliasname.

          is_ranges-alias      = l_aliasname.
          is_ranges-rsds_range = ls_range2.
          APPEND is_ranges TO l_command->it_ranges.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CLEAR l_command->it_ranges.
        ENDIF.

        ls_node_style-n_image = '@1E@'.

        MODIFY l_command->mt_alias_ranges FROM ls_alias_range INDEX l_tabix.

        READ TABLE lt_ranges INTO ls_range2 INDEX 1.

        it_frange = ls_range2-frange_t.

        LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
             WHERE alias = l_aliasname    AND
                   fieldname IS NOT INITIAL.

          READ TABLE it_frange INTO is_frange
            WITH KEY fieldname = gs_outtab_tb-fieldname.

          IF sy-subrc NE 0.
            DELETE l_command->mt_outtab_tb
              WHERE alias     = l_aliasname              AND
                    fieldname = gs_outtab_tb-fieldname.

            DELETE l_command->mt_ranges
              WHERE table_alias = l_aliasname            AND
                    fieldname   = gs_outtab_tb-fieldname.
          ENDIF.

        ENDLOOP.

        LOOP AT it_frange INTO is_frange.

          CLEAR: it_ranges2, is_ranges2.
          is_ranges2-tablename = is_ranges-rsds_range-tablename.
          CLEAR ls_frange2.
          APPEND is_frange TO is_ranges2-frange_t.
          APPEND is_ranges2 TO it_ranges2.

          CALL FUNCTION 'FREE_SELECTIONS_RANGE_2_WHERE'
            EXPORTING
              field_ranges  = it_ranges2
            IMPORTING
              where_clauses = lt_where.

          READ TABLE lt_where INTO ls_where INDEX 1.

          CLEAR l_where_text.
          LOOP AT ls_where-where_tab INTO l_line.
            CONCATENATE l_where_text l_line-line INTO l_where_text SEPARATED BY ' '.
          ENDLOOP.

          CONDENSE l_where_text.

          IF l_where_text IS INITIAL.
            DELETE l_command->mt_outtab_tb
              WHERE alias       = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            DELETE l_command->mt_ranges
              WHERE table_alias = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            EXIT.
          ENDIF.

          READ TABLE l_command->mt_outtab_tb INTO gs_outtab_tb
            WITH KEY tablename = l_tabname
                     fieldname = is_frange-fieldname.

          IF sy-subrc NE 0.

            MOVE l_where_text TO gs_outtab_tb-ddtext.
*           CLEAR gs_outtab_tb-ddtext.
            gs_outtab_tb-alias     = l_aliasname.
            gs_outtab_tb-fieldname = is_frange-fieldname.

            CONCATENATE 'R_' l_aliasname '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
            REPLACE ' ' WITH '' INTO ls_rangename.
            CONDENSE ls_rangename NO-GAPS.

            APPEND gs_outtab_tb TO l_command->mt_outtab_tb.

            READ TABLE l_command->mt_tab_node_xref INTO gs_tab_node_xref
              WITH KEY alias = l_aliasname.
*              WITH KEY tablename = l_tabname.

            CLEAR l_new_node_key.
            CALL METHOD g_tree_tb->add_node
              EXPORTING
                i_relat_node_key = gs_tab_node_xref-node_key
                i_relationship   = cl_gui_column_tree=>relat_last_child
                is_outtab_line   = gs_outtab_tb
                i_node_text      = ls_rangename
                is_node_layout   = ls_node_style
              IMPORTING
                e_new_node_key   = l_new_node_key
              EXCEPTIONS
                OTHERS           = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

*          READ TABLE l_command->mt_ranges INTO gs_ranges
*          WITH KEY tablename = is_ranges-tablename fieldname = is_frange-fieldname.
**            gs_ranges-node_text = ls_rangename.
*          MODIFY l_command->mt_ranges FROM gs_ranges INDEX sy-tabix.

*          CALL METHOD g_tree_tb->EXPAND_NODE
*            EXPORTING
*              I_NODE_KEY = gs_tab_node_xref-node_key.

          ELSE.
            MOVE l_where_text TO gs_outtab_tb-ddtext.
            MODIFY l_command->mt_outtab_tb FROM gs_outtab_tb INDEX sy-tabix.
          ENDIF.

          READ TABLE l_command->mt_ranges INTO gs_ranges
            WITH KEY table_alias = l_aliasname
                     fieldname   = is_frange-fieldname.

          IF sy-subrc EQ 0.
            gs_ranges-where_text = l_where_text.
            gs_ranges-range      = is_frange-selopt_t.

            MODIFY l_command->mt_ranges FROM gs_ranges INDEX sy-tabix.
          ELSE.
            CLEAR gs_ranges.
*           gs_ranges-node_key    = l_new_node_key.
            gs_ranges-table_alias = l_aliasname.
            gs_ranges-fieldname   = is_frange-fieldname.
            gs_ranges-where_text  = l_where_text.
            gs_ranges-node_text   = ls_rangename.
            gs_ranges-range       = is_frange-selopt_t.

            APPEND gs_ranges TO l_command->mt_ranges.
          ENDIF.

        ENDLOOP.

        CLEAR sy-msgno.
        CALL METHOD g_tree_tb->frontend_update
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD cl_gui_cfw=>dispatch
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD display_table_grid
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application



  METHOD handle_user_command.

    DATA: l_select_command TYPE REF TO lcl_select_command,
          l_select         TYPE REF TO lcl_select_command,
          lt_cells         TYPE lvc_t_cell,

          ls_row           TYPE lvc_s_row,
          ls_column_id     TYPE lvc_s_col,
          ls_row_no        TYPE lvc_s_roid.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error33' TYPE 'E'.
    ENDTRY.

    CALL METHOD g_alv->get_selected_cells
      IMPORTING
        et_cell = lt_cells
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv->get_current_cell
      IMPORTING
        es_row_id = ls_row
        es_col_id = ls_column_id
        es_row_no = ls_row_no
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CASE e_ucomm.

      WHEN 'TXT_SHTXT'  OR
           'TXT_GENFLD' OR
           'TXT_ALIAS'  OR
           'TXT_FLD'.

        CALL METHOD me->set_column_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me->set_column_headings.
        CALL METHOD me->refresh_display.

      WHEN 'KEY_NONE' OR
           'KEY_FIX'.

        CALL METHOD me->set_key_field_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me->set_key_display_attributes.
        CALL METHOD me->refresh_display.

    ENDCASE.

    TRY.
        l_select ?= g_commands->current_command.

        IF l_select->mv_last_display EQ 'G'.
          CALL METHOD g_alv->set_selected_cells
            EXPORTING
              it_cells = lt_cells
            EXCEPTIONS
              OTHERS   = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD g_alv->set_current_cell_via_id
            EXPORTING
              is_row_id    = ls_row
              is_column_id = ls_column_id
              is_row_no    = ls_row_no
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    "lcl_application



  METHOD read_checktables.


    DATA: dd08v_ia            TYPE TABLE OF dd08v,
          dd05m_ia            TYPE TABLE OF dd05m,
          wa_dd05m_ia         TYPE dd05m,
          state(1),
          l_tabname           TYPE dd08l-tabname,
          lt_dd08l            TYPE TABLE OF dd08l,
          ls_table_alias      LIKE LINE OF g_commands->current_command->table_alias_tb,
          lstr(40)            TYPE c,
          lstr4(40)           TYPE c,
          lstr2               TYPE string,
          lstr3               TYPE string,
          lstr5               TYPE string,
          lint                TYPE i,
          ls_prev_linkedquery LIKE gs_linkedquery,
          ls_linkedquery      LIKE gs_linkedquery,
          l_ddtext            TYPE dd02t-ddtext.


    DATA: ls_info_tablf     TYPE lty_zhtdb_checktable_struc,
          lt_info_tablf     TYPE TABLE OF lty_zhtdb_checktable_struc,

          ls_info_tablf_out TYPE lty_zhtdb_checktable_struc_alv,
          lt_info_tablf_out TYPE TABLE OF lty_zhtdb_checktable_struc_alv,

          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key        TYPE lvc_nkey.


    IF sender = 'T'.

      CALL METHOD g_tree_tb->get_selected_nodes
        CHANGING
          ct_selected_nodes = lt_selected_nodes
        EXCEPTIONS
          cntl_system_error = 1
          dp_error          = 2
          failed            = 3
          OTHERS            = 4.
      IF sy-subrc <> 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'E'
            iv_msgno = '031'.
*        MESSAGE e031.
      ENDIF.


      READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

      l_node_key = ls_selected_nodes-node_key.

      CALL METHOD g_tree_tb->get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*         E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      l_tabname = gs_outtab_tb-tablename.

    ELSEIF sender = 'G'.
* obsolete
      RETURN.
    ENDIF.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CLEAR lt_dd08l.

    READ TABLE g_commands->current_command->table_alias_tb INTO ls_table_alias
    WITH KEY table = l_tabname.

    SELECT info_tablf~tabname info_tablf~fieldname info_tablf~forkey info_tablf~primpos
    INTO CORRESPONDING FIELDS OF TABLE lt_info_tablf
    FROM info_tablf INNER JOIN dd02l ON info_tablf~tabname = dd02l~tabname
    WHERE info_tablf~checktable = l_tabname AND dd02l~tabclass = 'TRANSP'.

    LOOP AT lt_info_tablf INTO ls_info_tablf.

      CLEAR: dd05m_ia, dd08v_ia.

      CALL FUNCTION 'DD_TBFK_GET'
        EXPORTING
          fieldname     = '*'
          get_state     = 'A'
          tabl_name     = ls_info_tablf-tabname
          withtext      = 'X'
        IMPORTING
          got_state     = state
        TABLES
          dd05m_tab_a   = dd05m_ia
*         DD05M_TAB_N   = FK1_DD05M
          dd08v_tab_a   = dd08v_ia
*         DD08V_TAB_N   = FK1_DD08V
        EXCEPTIONS
          illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checktable = l_tabname.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE tabname = wa_dd05m_ia-tabname
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = 'A'
                AND tabname = wa_dd05m_ia-tabname.

          IF sy-subrc NE 0.
*            message 'ZENITH:sdfgdsf' type 'E'.
          ENDIF.

        ENDIF.

        CONCATENATE wa_dd05m_ia-tabname '~' wa_dd05m_ia-checkfield INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE ls_table_alias-alias '~' wa_dd05m_ia-forkey INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE 'ON' lstr3 '=' lstr2 INTO lstr2 SEPARATED BY ' '.

        MOVE lstr2 TO lstr.

        lstr2 = lint.

        CLEAR gs_linkedquery.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-tabname.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos   TYPE TABLE OF gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.

    SORT gt_linkedquery BY checktable tabname primpos fieldname checkfield .
    DELETE ADJACENT DUPLICATES FROM gt_linkedquery COMPARING checktable tabname primpos fieldname checkfield.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
*           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

      AT END OF checktable.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = '* ON'.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname '~' ls_linkedquery-checkfield INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-fieldname INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ELSE.
              CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ENDIF.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 0.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname    = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

          ENDIF.

        ENDIF.

      ENDAT.

      ls_prev_linkedquery = gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.
*
*        CONCATENATE '(' gs_linkedquery-ddtext ')' INTO l_ddtext.
*        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY ' '.
*
*      endif.

    ENDLOOP.


    LOOP AT gt_linkedquery_comp INTO gs_linkedquery_comp.

      CLEAR ls_info_tablf_out.

      MOVE-CORRESPONDING gs_linkedquery_comp TO ls_info_tablf_out.

      ls_info_tablf_out-tabname = gs_linkedquery_comp-checktable.

      APPEND ls_info_tablf_out TO lt_info_tablf_out.

    ENDLOOP.

*    CONCATENATE 'Checktable Relationships for ' l_tabname INTO lstr SEPARATED BY ' '.
    MESSAGE i037 WITH l_tabname INTO lstr.

    DELETE lt_info_tablf_out WHERE tabname = l_tabname.

    DATA: ls_selfield  TYPE slis_selfield,
          lt_fcat_slis TYPE slis_t_fieldcat_alv,
          ls_fcat_slis TYPE slis_fieldcat_alv.

    ls_fcat_slis-col_pos       = 1.
    ls_fcat_slis-fieldname     = 'TABNAME'.
    ls_fcat_slis-rollname      = 'AS4TAB'.
    ls_fcat_slis-reptext_ddic  = 'Table name'.
    ls_fcat_slis-outputlen = 20.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 2.
    ls_fcat_slis-fieldname     = 'DDTEXT'.
    ls_fcat_slis-rollname      = 'AS4TEXT'.
    ls_fcat_slis-reptext_ddic  = 'Short text'.
    ls_fcat_slis-outputlen = 50.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 3.
    ls_fcat_slis-fieldname     = 'LONGTEXT'.
    ls_fcat_slis-rollname      = 'CHAR_512'.
    ls_fcat_slis-reptext_ddic  = 'Join condition'.
    ls_fcat_slis-outputlen = 512.
    APPEND ls_fcat_slis TO lt_fcat_slis.


    CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
      EXPORTING
        i_title               = lstr
*       I_SELECTION           = 'X'
*       I_ALLOW_NO_SELECTION  =
        i_zebra               = ' '
        i_screen_start_column = 3
        i_screen_start_line   = 2
        i_screen_end_column   = 200
        i_screen_end_line     = 30
*       I_CHECKBOX_FIELDNAME  =
*       I_LINEMARK_FIELDNAME  =
*       I_SCROLL_TO_SEL_LINE  = 'X'
        it_fieldcat           = lt_fcat_slis
        i_tabname             = 'L+FASY'
*       IT_EXCLUDING          =
*       I_CALLBACK_PROGRAM    =
*       I_CALLBACK_USER_COMMAND       =
*       IS_PRIVATE            =
      IMPORTING
        es_selfield           = ls_selfield
*       E_EXIT                =
      TABLES
        t_outtab              = lt_info_tablf_out
      EXCEPTIONS
        program_error         = 1
        OTHERS                = 2.
    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF ls_selfield-tabindex IS NOT INITIAL.

      DATA:
        l_jointext          TYPE string,
        lt_jointext         TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
        l_tablename         TYPE gty_linkedquery-checktable,
        l_alias             TYPE gty_linkedquery-checktable,
        l_select            TYPE REF TO lcl_select_command,
        l_from_text         TYPE string,
        l_where_text        TYPE string,
        l_gb_text           TYPE string,
        l_ob_text           TYPE string,
        l_fdpos             TYPE i,
        l_tabix             TYPE i,
        l_selfae_alias      TYPE string,
        ls_linkedquery_comp LIKE gs_linkedquery_comp.


      READ TABLE lt_info_tablf_out INTO ls_info_tablf_out
      INDEX ls_selfield-tabindex.

      IF sy-subrc NE 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'I'
            iv_msgno = '027'.
*        MESSAGE i027.
      ENDIF.

      READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
      WITH KEY checktable = ls_info_tablf_out-tabname.

      IF sy-subrc NE 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'I'
            iv_msgno = '027'.
*        MESSAGE i027.
      ELSE.
        l_tablename    = ls_linkedquery_comp-checktable.
        l_jointext     = ls_linkedquery_comp-longtext.
        l_selfae_alias = ls_linkedquery_comp-tabname.
      ENDIF.

      TRY.

          l_select ?= g_commands->current_command.

          l_from_text   = l_select->from_text.
          l_gb_text     = l_select->group_by_text.
          l_ob_text     = l_select->order_by_text.
          l_where_text  = l_select->where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands->current_command->text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

*      LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias_tb WHERE TABLE = L_TABLENAME.
*
*      ENDLOOP.
      READ TABLE g_commands->current_command->table_alias_tb TRANSPORTING NO FIELDS
      WITH KEY table = l_tablename.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename '~' INTO lstr.
        CONCATENATE l_alias '~' INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      CASE i_ucomm.

        WHEN 'RELAT_I'.
          CONCATENATE 'INNER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_O'.
          CONCATENATE 'LEFT OUTER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_Q'.
          CONCATENATE '( SELECT' l_tablename 'AS' l_alias l_jointext ')' INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_S'.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH 'ZSQL_OUTER_TABLE-' IGNORING CASE.

          CONCATENATE 'SELECT * FROM' l_tablename INTO lstr2 SEPARATED BY ' '.
          APPEND lstr2 TO lt_jointext.

          lstr2 = 'FOR ALL ENTRIES IN ZSQL_OUTER_TABLE'.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE 'WHERE' l_jointext INTO lstr2 SEPARATED BY ' '.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

      ENDCASE.


      IF i_ucomm EQ 'RELAT_S'.

        CALL METHOD cl_gui_cfw=>set_new_ok_code
          EXPORTING
            new_code = 'NEWSELFOR'
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ELSE.

        IF strlen( l_jointext ) < gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = l_jointext
*            IMPORTING
*              p_itab   = lt_jointext.
*
        ENDIF.

      ENDIF.

*      IF l_fdpos IS NOT INITIAL.
*
*        INSERT LINES OF lt_jointext INTO g_commands->current_command->text INDEX l_tabix.
*
*      ELSE.
*
*        APPEND LINES OF lt_jointext TO g_commands->current_command->text.
*
*      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands->display_command.

    ENDIF.



  ENDMETHOD.                    "lcl_application


  METHOD handle_lq_ctx_sel.

    CALL METHOD g_commands->transfer_text_to_command.

    IF e_ucomm(5) EQ 'RELAT'.

      CALL METHOD read_checktables
        EXPORTING
          sender  = sender
          i_ucomm = e_ucomm.


    ENDIF.

    IF e_ucomm+2(3) EQ 'LA_'.

      DATA: lstr                TYPE string,
            lstr2               TYPE string,
            l_jointext          TYPE string,
            lt_jointext         TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
            l_tablename         TYPE gty_linkedquery-checktable,
            l_alias             TYPE gty_linkedquery-checktable,
            l_jointype(3)       TYPE c,
            l_select            TYPE REF TO lcl_select_command,
            l_from_text         TYPE string,
            l_where_text        TYPE string,
            l_gb_text           TYPE string,
            l_ob_text           TYPE string,
            l_fdpos             TYPE i,
            l_tabix             TYPE i,
            l_ucomm             TYPE sy-ucomm,
            l_selfae_alias      TYPE string,
            ls_linkedquery_comp LIKE gs_linkedquery_comp,
            ls_linkedquery      LIKE gs_linkedquery,
            ls_table_alias_tb   LIKE LINE OF g_commands->current_command->table_alias_tb.


      l_ucomm = e_ucomm.

**      SEARCH l_ucomm FOR '_COMP'.
**
**      IF sy-fdpos EQ 0.

      REPLACE ALL OCCURRENCES OF 'I_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'I'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'O_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'O'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'S_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'S'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'Q_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'Q'.
      ENDIF.

      SEARCH l_ucomm FOR '_COMP'.

      IF sy-fdpos EQ 0.

        READ TABLE gt_linkedquery INTO ls_linkedquery
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '027'.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery-checktable.
          l_jointext     = ls_linkedquery-longtext.
          l_selfae_alias = ls_linkedquery-tabname.
        ENDIF.

      ELSE.

        READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '027'.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery_comp-checktable.
          l_jointext     = ls_linkedquery_comp-longtext.
          l_selfae_alias = ls_linkedquery_comp-tabname.
        ENDIF.

      ENDIF.


      LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias_tb WHERE table = l_tablename.

      ENDLOOP.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename '~' INTO lstr.
        CONCATENATE l_alias '~' INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      TRY.

          l_select ?= g_commands->current_command.

          l_from_text   = l_select->from_text.
          l_gb_text     = l_select->group_by_text.
          l_ob_text     = l_select->order_by_text.
          l_where_text  = l_select->where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands->current_command->text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

      CASE l_jointype.

        WHEN 'I'.
          CONCATENATE 'INNER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'O'.
          CONCATENATE 'LEFT OUTER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'S'.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH 'ZSQL_OUTER_TABLE-' IGNORING CASE.

          CONCATENATE 'SELECT * FROM' l_tablename INTO lstr2 SEPARATED BY ' '.
          APPEND lstr2 TO lt_jointext.

          lstr2 = 'FOR ALL ENTRIES IN ZSQL_OUTER_TABLE'.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE 'WHERE' l_jointext INTO lstr2 SEPARATED BY ' '.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

        WHEN 'Q'.

          MOVE l_jointext+3 TO l_jointext.

*          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
*          CONDENSE l_selfae_alias NO-GAPS.
*
*          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH l_tablename IGNORING CASE.

          CONCATENATE '( SELECT * FROM' l_tablename 'WHERE' l_jointext ')' INTO l_jointext SEPARATED BY ' '.

      ENDCASE.

      IF l_jointype NE 'S'.

        IF strlen( l_jointext ) < gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

        ENDIF.

      ELSE.

        CALL METHOD cl_gui_cfw=>set_new_ok_code
          EXPORTING
            new_code = 'NEWSELFOR'
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands->display_command.

    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD refresh_display.

    DATA: l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.

    CALL METHOD g_alv->set_frontend_fieldcatalog
      EXPORTING
        it_fieldcatalog = l_select_command->fcat
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv->refresh_table_display
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "refresh_display


  METHOD set_column_headings.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          ls_fieldinfo     TYPE gty_fieldinfo,
          lv_tabix         TYPE i,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.

    TRY.
        LOOP AT l_select_command->fcat INTO ls_fcat
             WHERE fieldname <> 'ZENITH_ROWID'    AND
                   fieldname <> 'ZENITH_SELECTED' AND
                   fieldname <> 'ZENITH_STYLE'    AND
                   fieldname <> 'ZENITH_COLOR'    AND
                   fieldname <> 'ZENITH_LOCKED_BY'.

          lv_tabix = sy-tabix.

          READ TABLE l_select_command->fieldinfo_tb INTO ls_fieldinfo
            WITH KEY generated_field = ls_fcat-fieldname.

          IF sy-subrc NE 0.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty = 'E'
                iv_msgno = '027'.
          ENDIF.

          CASE l_select_command->mv_colmn_header.
            WHEN 'S'.

              IF l_select_command->mv_last_display = 'G'.
                CLEAR: ls_fcat-coltext,
                       ls_fcat-scrtext_l,
                       ls_fcat-scrtext_m,
                       ls_fcat-scrtext_s,
                       ls_fcat-reptext.
              ELSE.
                ls_fcat-coltext   = ls_fcat-reptext.
                ls_fcat-scrtext_l = ls_fcat-reptext.
                ls_fcat-scrtext_m = ls_fcat-reptext.
                ls_fcat-scrtext_s = ls_fcat-reptext.
                ls_fcat-reptext   = ls_fcat-reptext.
              ENDIF.

            WHEN 'G'.
              ls_fcat-coltext = ls_fieldinfo-generated_field.

            WHEN 'A'.

              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.

            WHEN 'T'.
              ls_fcat-coltext = ls_fieldinfo-orig_field.

          ENDCASE.

          MODIFY l_select_command->fcat FROM ls_fcat INDEX lv_tabix.
        ENDLOOP.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

  ENDMETHOD.                    "lcl_application


  METHOD set_key_display_attributes.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.
    CHECK l_select_command->mv_last_display = 'G'.

*   set this property so it can be saved with the command

*   modify field catalog
    LOOP AT l_select_command->fcat INTO ls_fcat WHERE key_sel EQ 'X'.
      CASE l_select_command->mv_key_colmn_type.
        WHEN 'N'.
          CLEAR ls_fcat-key.
        WHEN 'F'.
          ls_fcat-key = 'X'.
      ENDCASE.

      MODIFY l_select_command->fcat FROM ls_fcat.
    ENDLOOP.

    gs_layo-no_keyfix = 'X'.

    CALL METHOD g_alv->set_frontend_layout
      EXPORTING
        is_layout = gs_layo
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    " set_key_display_attributes


  METHOD handle_menu_button.

    DATA: lv_display_only TYPE c.


    IF g_alv->is_ready_for_input( ) EQ 0.
      lv_display_only = 'X'.
    ELSE.
      lv_display_only = ' '.
    ENDIF.


    IF e_ucomm = 'TXT_MENU'.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_ALIAS'
          text   = TEXT-081
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_FLD'
          text   = TEXT-090
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_GENFLD'
          text   = TEXT-091
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_SHTXT'
          text   = TEXT-092
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_separator
        EXCEPTIONS
          OTHERS = 1.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'KEY_FIX'
          text   = TEXT-089
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'KEY_NONE'
          text   = TEXT-078
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "lcl_application

ENDCLASS.                    "lcl_application IMPLEMENTATION

*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLCOMMAND_I                               *
*&---------------------------------------------------------------------*


CLASS lcl_command IMPLEMENTATION.



  METHOD constructor.

    IF p_copy_from IS NOT INITIAL.

      it_ranges        = p_copy_from->it_ranges.
      is_x030l         = p_copy_from->is_x030l.

      mt_alias_ranges  = p_copy_from->mt_alias_ranges.
      mt_ranges        = p_copy_from->mt_ranges.
      mt_outtab_tb     = p_copy_from->mt_outtab_tb.
      mt_tab_node_xref = p_copy_from->mt_tab_node_xref.

      command_type     = p_copy_from->command_type.
      where_text       = p_copy_from->where_text.
      mv_dbcnt         = p_copy_from->mv_dbcnt.
      mv_bytes         = p_copy_from->mv_bytes.

      commandtext      = p_copy_from->commandtext.
      gen_commandtext  = p_copy_from->gen_commandtext.
      gen_text         = p_copy_from->gen_text.
      text             = p_copy_from->text.
      table_alias_tb   = p_copy_from->table_alias_tb.

    ENDIF.

  ENDMETHOD.                    "LCL_COMMAND



  METHOD execute_parsed_sql.

  ENDMETHOD.                    "LCL_COMMAND


  METHOD get_type.
    ep_command_type = me->command_type.
  ENDMETHOD.                    "LCL_COMMAND


  METHOD parse_commandtext.

  ENDMETHOD.                    "LCL_COMMAND


  METHOD set_commandtext.

    me->commandtext = p_commandtext.
    CONDENSE me->commandtext.
    CONCATENATE '' me->commandtext INTO me->commandtext SEPARATED BY ' '.

  ENDMETHOD.                    "LCL_COMMAND

ENDCLASS.                    "LCL_COMMAND IMPLEMENTATION



*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLSELECT_I                                *
*&---------------------------------------------------------------------*


CLASS lcl_select_command IMPLEMENTATION.


  METHOD calculate_mv_rowlen.

    DATA: ls_fcat TYPE lvc_s_fcat.

    CLEAR mv_rowlen.

    LOOP AT fcat INTO ls_fcat
         WHERE fieldname NE 'ZENITH_ROWID'    AND
               fieldname NE 'ZENITH_SELECTED' AND
               fieldname NE 'ZENITH_STYLE'    AND
               fieldname NE 'ZENITH_COLOR'    AND
               fieldname NE 'ZENITH_LOCKED_BY'.
      mv_rowlen = mv_rowlen + ls_fcat-intlen.
    ENDLOOP.

  ENDMETHOD.                    " calculate_mv_rowlen


  METHOD constructor.

    CALL METHOD super->constructor
      EXPORTING
        p_copy_from = p_copy_from.

    CREATE OBJECT mo_pipacs_select.
    mo_pipacs_command = mo_pipacs_select.

    IF p_copy_from IS NOT INITIAL.

      select_text = p_copy_from->select_text.
      from_text = p_copy_from->from_text.
      group_by_text = p_copy_from->group_by_text.
      having_text = p_copy_from->having_text.
      order_by_text = p_copy_from->order_by_text.

      can_edit = p_copy_from->can_edit.

      has_table_alias = p_copy_from->has_table_alias.
      group_by_text = p_copy_from->group_by_text.
      alv_state = p_copy_from->alv_state.
      has_duplicate_fields = p_copy_from->has_duplicate_fields.

      ddic_references = p_copy_from->ddic_references.
      fieldinfo_tb = p_copy_from->fieldinfo_tb.
      prev_fcat = p_copy_from->prev_fcat.
      fcat = p_copy_from->fcat.

    ENDIF.

  ENDMETHOD.                    " constructor



  METHOD assign_field_symbols.

    UNASSIGN: <gt_result>,
              <gt_temp>,
              <gt_undo>,

              <gs_result>,
              <gs_temp>,
              <gs_undo>.

    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'R'
      CHANGING
        p_table = me->result_table.
****    CALL METHOD me->assign_field_symbol
****      EXPORTING
****        p_fs    = 'X'
****      CHANGING
****        p_table = me->display_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'D'
      CHANGING
        p_table = me->deleted_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'I'
      CHANGING
        p_table = me->inserted_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'U'
      CHANGING
        p_table = me->updated_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'T'
      CHANGING
        p_table = me->temp_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'N'
      CHANGING
        p_table = me->undo_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'L'
      CHANGING
        p_table = me->lawb_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'S'
      CHANGING
        p_table = me->selfae_table.

  ENDMETHOD.                    " assign_field_symbols


  METHOD assign_field_symbol.

    CASE p_fs.
****      WHEN 'X'.
****        ASSIGN p_table->* TO <gt_display>.
*****        ASSIGN me->deleted_structure->* TO <gs_deleted>.

      WHEN 'R'.
        ASSIGN p_table->* TO <gt_result>.
        ASSIGN me->result_structure->* TO <gs_result>.

      WHEN 'T'.
        ASSIGN p_table->* TO <gt_temp>.
        ASSIGN me->temp_structure->* TO <gs_temp>.

      WHEN 'N'.
        ASSIGN p_table->* TO <gt_undo>.
        ASSIGN me->undo_structure->* TO <gs_undo>.

    ENDCASE.

  ENDMETHOD.                    " assign_field_symbol


  METHOD parse_commandtext.

    DATA: ls_table_alias LIKE LINE OF me->table_alias_tb.


    CALL METHOD super->parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE error_occurred.
      WHEN 2.
        RAISE error_occurred.
    ENDCASE.

    CLEAR table_alias_tb.

    CALL METHOD mo_pipacs_command->parse
      EXCEPTIONS
        parse_error = 1
        OTHERS      = 2.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL AND p_on_load IS INITIAL.
        IF p_bf_test IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno DISPLAY LIKE 'E'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSE.
*          CALL METHOD g_application->add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
*            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        ENDIF.

        RAISE error_occurred.
      ELSE.
        RAISE error_occurred.
      ENDIF.

    ENDIF.

    CALL METHOD mo_pipacs_select->get_texts
      IMPORTING
        ev_select_text   = select_text
        ev_from_text     = from_text
        ev_where_text    = where_text
        ev_group_by_text = group_by_text
        ev_having_text   = having_text
        ev_order_by_text = order_by_text.

    CALL METHOD mo_pipacs_select->get_fieldinfo
      IMPORTING
        et_fieldinfo = me->fieldinfo_tb.

    CALL METHOD mo_pipacs_select->get_table_alias
      IMPORTING
        et_table_alias = me->table_alias_tb.

    SORT me->table_alias_tb BY table alias.

    DELETE ADJACENT DUPLICATES FROM me->table_alias_tb COMPARING table alias.

    can_edit = mo_pipacs_select->can_edit( ).

    LOOP AT me->table_alias_tb INTO ls_table_alias.
      IF ls_table_alias-alias IS INITIAL.
        ls_table_alias-alias = ls_table_alias-table.

        MODIFY me->table_alias_tb FROM ls_table_alias INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    " parse_commandtext



  METHOD execute_parsed_sql.

    DATA: lv_job_name  TYPE btcjob,
          lv_job_count TYPE btcjobcnt,
          lx_root      TYPE REF TO cx_root,
          ls_celltab   TYPE lvc_s_styl,
          ls_fcat      TYPE lvc_s_fcat.

    FIELD-SYMBOLS: <lt_style> TYPE lvc_t_styl.

    CALL METHOD super->execute_parsed_sql
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      EXCEPTIONS
        table_not_found  = 1
        parse_error      = 2
        exec_error       = 3
        error_occurred   = 4
        unlock_error     = 5
        arg_to_long      = 6
        foreign_lock     = 7
        job_submit_error = 8
        OTHERS           = 9.

    CASE sy-subrc.
      WHEN 1.
        RAISE table_not_found.
      WHEN 2.
        RAISE parse_error.
      WHEN 3.
        RAISE exec_error.
      WHEN 4.
        RAISE error_occurred.
      WHEN 5.
        RAISE unlock_error.
      WHEN 6.
        RAISE arg_to_long.
      WHEN 7.
        RAISE foreign_lock.
      WHEN 8.
        RAISE job_submit_error.
      WHEN 9.
        RAISE error_occurred.
    ENDCASE.

    CALL METHOD mo_pipacs_command->execute
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      IMPORTING
        er_result        = returned_table
        ev_dbcnt         = mv_dbcnt
        er_lock_argument = mr_lock_argument_temp
        er_exc           = lx_root
        ev_job_name      = lv_job_name
        ev_job_count     = lv_job_count
        et_srccode       = et_srccode
      EXCEPTIONS
        parse_error      = 1
        exec_error       = 2
        job_submit_error = 3
        OTHERS           = 4.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 3.
        RAISE job_submit_error.
      WHEN 2 OR 4.
        er_exception = lx_root.
        RAISE exec_error.
    ENDCASE.

    IF iv_simulation IS INITIAL AND
       iv_bg_proc    IS INITIAL.

      FIELD-SYMBOLS: <lt_returned> TYPE ANY TABLE, <ls_lock_arg> TYPE any.

      ASSIGN mr_lock_argument_temp->* TO <ls_lock_arg>.

      IF sy-subrc EQ 0.
        CREATE DATA me->mr_lock_argument LIKE <ls_lock_arg>.
      ENDIF.

      ASSIGN returned_table->* TO <lt_returned>.
      IF sy-subrc = 0. "APC20160419

        CREATE DATA me->result_table LIKE <lt_returned>.
        ASSIGN result_table->* TO <gt_result>.

        <gt_result>[] = <lt_returned>[].

        CREATE DATA me->display_table LIKE <gt_result>.
        ASSIGN display_table->* TO <gt_display>.

        CREATE DATA me->temp_table LIKE <gt_result>.
        ASSIGN temp_table->* TO <gt_temp>.

        CREATE DATA me->temp_table LIKE <gt_result>.
        ASSIGN temp_table->* TO <gt_temp>.

        CREATE DATA me->undo_table LIKE <gt_result>.
        ASSIGN undo_table->* TO <gt_undo>.

        CREATE DATA me->tree_table LIKE <gt_result>.
        ASSIGN tree_table->* TO <gt_tree>.


        CREATE DATA me->result_structure LIKE LINE OF <gt_result>.
        ASSIGN me->result_structure->* TO <gs_result>.

        CREATE DATA me->temp_structure LIKE LINE OF <gt_temp>.
        ASSIGN me->temp_structure->* TO <gs_temp>.

        CREATE DATA me->undo_structure LIKE LINE OF <gt_undo>.
        ASSIGN me->undo_structure->* TO <gs_undo>.

        ls_celltab-style = cl_gui_alv_grid=>mc_style_disabled.

        LOOP AT <gt_result> ASSIGNING <gs_result>.
          ASSIGN COMPONENT 'ZENITH_ROWID' OF STRUCTURE <gs_result> TO <gf_result>.
          <gf_result> = sy-tabix.

          ASSIGN COMPONENT 'ZENITH_STYLE' OF STRUCTURE <gs_result> TO <lt_style>.
          CLEAR <lt_style>.

          LOOP AT me->fcat INTO ls_fcat
               WHERE fieldname <> 'ZENITH_ROWID'    AND
                     fieldname <> 'ZENITH_SELECTED' AND
                     fieldname <> 'ZENITH_STYLE'    AND
                     fieldname <> 'ZENITH_COLOR'    AND
                     fieldname <> 'ZENITH_LOCKED_BY'.
            ls_celltab-fieldname = ls_fcat-fieldname.
            INSERT ls_celltab INTO TABLE <lt_style>.
          ENDLOOP.

          MODIFY <gt_result> FROM <gs_result>.
          gv_max_rowid = sy-tabix.
        ENDLOOP.
      ENDIF.

      CALL METHOD calculate_mv_rowlen.

      mv_bytes = mv_rowlen * mv_dbcnt.
    ENDIF.

  ENDMETHOD.                    " execute_parsed_sql

ENDCLASS.                    "LCL_SELECT_COMMAND IMPLEMENTATION




*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLCOMMANDS_I                              *
*&---------------------------------------------------------------------*


CLASS lcl_commands IMPLEMENTATION.


  METHOD generate_structure.

    DATA: ls_fcat           TYPE lvc_s_fcat,
          ls_fieldinfo      TYPE lty_zhtdb_fieldinfo,
          l_select          TYPE REF TO lcl_select_command,
          lstr              TYPE string,
          length            TYPE i,
          ls_ref            TYPE gty_ddicref,
          ls_table_alias_tb LIKE LINE OF l_select->table_alias_tb.

    TRY.
        l_select ?= current_command.

        CLEAR l_select->fcat.
        CLEAR l_select->ddic_references.

*       build fieldcatalog

*      CALL METHOD l_select->mo_pipacs->get_fieldinfo
*        IMPORTING
*          et_fieldinfo = l_select->fieldinfo_tb.
*
        LOOP AT l_select->fieldinfo_tb INTO ls_fieldinfo.

          READ TABLE l_select->table_alias_tb INTO ls_table_alias_tb
            WITH KEY table = ls_fieldinfo-table.

          CLEAR ls_fcat.

          ls_fcat-col_opt = 'X'.

          IF ls_fieldinfo-agg_function IS NOT INITIAL.

            IF ls_fieldinfo-agg_function EQ 'COUNT'.
              ls_fcat-rollname = 'INT4'.
            ELSEIF ls_fieldinfo-agg_function EQ 'AVG'.
              ls_fcat-rollname = 'FLTP'.
            ENDIF.

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = strlen( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = '''' AND ls_fieldinfo-field_alias+length = ''''.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select->fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-agg_function TO UPPER CASE.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_table = ls_fieldinfo-table.
            ls_fcat-ref_field = ls_fieldinfo-field.

          ELSE.    " agg_function is not initial

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = strlen( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = '''' AND ls_fieldinfo-field_alias+length = ''''.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select->fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_field = ls_fieldinfo-field.
            ls_fcat-ref_table = ls_fieldinfo-table.
*           ls_fcat-f4availabl = 'X'.

          ENDIF.   " agg_function is not initial

          CASE l_select->mv_colmn_header.
            WHEN 'S'.
              CLEAR: ls_fcat-coltext, ls_fcat-scrtext_l, ls_fcat-scrtext_m, ls_fcat-scrtext_s, ls_fcat-reptext.
            WHEN 'G'.
              ls_fcat-coltext = ls_fieldinfo-generated_field.
            WHEN 'A'.
              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.
            WHEN 'T'.
              ls_fcat-coltext = ls_fieldinfo-orig_field.
          ENDCASE.

          IF ls_fcat-ref_field IS NOT INITIAL AND
             ls_fcat-ref_table IS NOT INITIAL.

            CASE ls_table_alias_tb-type.

              WHEN 'T'.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = 'A'.

              WHEN 'V'.

                SELECT SINGLE rollname keyflag AS fix_column keyflag AS key
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd27s
                    WHERE viewname  = ls_fcat-ref_table AND
                          viewfield = ls_fcat-ref_field AND
                          as4local  = 'A'.
*                          fieldname NOT LIKE '.%' AND
*                          fieldname NOT LIKE '*%' AND
*                          fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                          fieldname NOT LIKE '$%%' ESCAPE '$'

              WHEN 'C' OR 'P'.

*                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype
*                INTO CORRESPONDING FIELDS OF ls_fcat
*                FROM dd16v
*                  WHERE sqltab    = ls_fcat-ref_table AND
*                        fieldname = ls_fcat-ref_field.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = 'A'.

*                        in view already
*                        AS4LOCAL = 'A' AND
*                        fieldname NOT LIKE '.%' AND
*                        fieldname NOT LIKE '*%' AND
*                        fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                        fieldname NOT LIKE '$%%' ESCAPE '$'

            ENDCASE.

            IF sy-subrc NE 0.
              MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fcat-ref_field ls_fcat-ref_table ls_table_alias_tb-type RAISING field_not_found.
            ENDIF.

            CONCATENATE TEXT-143 ls_fcat-domname TEXT-144 ls_fcat-intlen INTO lstr
              SEPARATED BY space.

            ls_fcat-tooltip = lstr.

            CLEAR ls_fcat-fix_column.

            ls_ref-fieldname  = ls_fcat-fieldname.
            ls_ref-checktable = ls_fcat-checktable.
            ls_ref-ref_table  = ls_fcat-ref_table.
            ls_ref-ref_field  = ls_fcat-ref_field.
            ls_ref-key        = ls_fcat-key.

            APPEND ls_ref TO l_select->ddic_references.

            DATA: ls_dfies TYPE dfies,
                  lt_dfies TYPE TABLE OF dfies.

            CALL FUNCTION 'DDIF_FIELDINFO_GET'
              EXPORTING
                tabname        = ls_fcat-ref_table
                fieldname      = ls_fcat-ref_field
                langu          = sy-langu
              TABLES
                dfies_tab      = lt_dfies
              EXCEPTIONS
                not_found      = 1
                internal_error = 2
                OTHERS         = 3.

            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              READ TABLE lt_dfies INTO ls_dfies INDEX 1.

              IF sy-subrc EQ 0.
                MOVE ls_dfies-convexit TO ls_fcat-convexit.
                MOVE ls_dfies-scrtext_m TO ls_fcat-coltext.
                MOVE ls_dfies-scrtext_l TO  ls_fcat-scrtext_l.
                MOVE ls_dfies-scrtext_m TO  ls_fcat-scrtext_m.
                MOVE ls_dfies-scrtext_s TO  ls_fcat-scrtext_s.
                MOVE ls_dfies-reptext TO ls_fcat-reptext.
              ENDIF.

            ENDIF.

          ENDIF.

*        ls_fcat-no_convext = 'X'.

          IF ls_fcat-key EQ 'X'.
            ls_fcat-key_sel = 'X'.
            ls_fcat-edit = ' '.
          ENDIF.

          APPEND ls_fcat TO l_select->fcat.

        ENDLOOP.

        IF sy-subrc EQ 4.
          RAISE empty_fieldinfo_tb.
        ENDIF.

      CATCH cx_sy_move_cast_error.
        RAISE command_is_not_select.
    ENDTRY.

  ENDMETHOD.                    " generate_structure



  METHOD display.

    DATA: l_select       TYPE REF TO lcl_select_command,
          lv_show_grid   TYPE c,
          lo_result_tree TYPE REF TO cl_gui_alv_tree,
          lo_alv         TYPE REF TO cl_gui_alv_grid.


    TRY.
        l_select ?= current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    IF po_grid IS INITIAL AND
       po_tree IS INITIAL.
      IF l_select->mv_last_display = 'T'.
        lv_show_grid = ' '.
      ELSE.
        lv_show_grid = 'X'.
      ENDIF.
    ELSE.
      IF po_grid IS INITIAL.
        lv_show_grid = ' '.
      ELSE.
        lv_show_grid = 'X'.
      ENDIF.
    ENDIF.

    IF po_grid IS SUPPLIED.
      lo_alv = po_grid.
    ELSE.
      lo_alv = g_alv.
    ENDIF.

    IF <gt_result> IS ASSIGNED.

      CALL METHOD g_application->set_column_headings.
      CALL METHOD g_application->set_key_display_attributes.

      CALL METHOD lo_alv->set_table_for_first_display
        EXPORTING
          is_layout            = gs_layo
          it_toolbar_excluding = gt_toolbar_exclude
        CHANGING
          it_outtab            = <gt_result>
          it_fieldcatalog      = l_select->fcat
        EXCEPTIONS
          OTHERS               = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    IF lo_result_tree IS NOT INITIAL.
      CALL METHOD lo_result_tree->set_visible
        EXPORTING
          visible = ' '
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv->set_ready_for_input
      EXPORTING
        i_ready_for_input = l_select->alv_state
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv->set_selected_rows
      EXPORTING
        it_index_rows = l_select->selected_rows
        it_row_no     = l_select->selected_rows2
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD display_command.

    DATA: l_command_type     TYPE lty_commandtype,
          l_select_command   TYPE REF TO lcl_select_command,
          lv_tree_tb_width   TYPE i,
          lv_result_height   TYPE i,
          lv_tree_tb_visible TYPE c,
          lv_done            TYPE c.


    CHECK current_command IS NOT INITIAL.

    CALL METHOD current_command->get_type
      IMPORTING
        ep_command_type = l_command_type.


    IF l_command_type EQ gc_ctype_lawb.

      lv_tree_tb_width = 0.
      lv_result_height = g_application->mv_result_height.

      lv_tree_tb_visible = ' '.

    ELSEIF l_command_type EQ gc_ctype_select OR l_command_type EQ gc_ctype_selfae.

      lv_tree_tb_width = g_application->mv_tree_tb_width.
      lv_result_height = g_application->mv_result_height.

      lv_tree_tb_visible = 'X'.

    ENDIF.

    CALL METHOD go_splitter_inner->set_column_width
      EXPORTING
        id     = 2
        width  = lv_tree_tb_width
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer->set_row_height
      EXPORTING
        id     = 2
        height = lv_result_height
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->set_visible
      EXPORTING
        visible = lv_tree_tb_visible.

*abaped    CALL METHOD g_textedit->set_text_as_r3table
    CALL METHOD g_textedit->set_text
      EXPORTING
        table  = current_command->text[]
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    IF lv_done IS INITIAL.
      TRY.
          l_select_command ?= current_command.

          CALL METHOD l_select_command->assign_field_symbols.

          IF l_select_command->fcat[] IS NOT INITIAL AND <gt_result> IS ASSIGNED.

            CALL METHOD g_alv->set_visible
              EXPORTING
                visible = 'X'
              EXCEPTIONS
                OTHERS  = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

            IF <gt_result> IS ASSIGNED.
              CALL METHOD me->display.
            ENDIF.

          ELSE.

            IF command_count NE 1.

              CALL METHOD g_alv->set_visible
                EXPORTING
                  visible = ' '
                EXCEPTIONS
                  OTHERS  = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

          ENDIF.

        CATCH cx_sy_move_cast_error.
*        CALL METHOD l_select_command->display.
      ENDTRY.

    ENDIF.

    IF l_command_type NE gc_ctype_lawb AND l_command_type NE gc_ctype_script.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

    CALL METHOD cl_gui_cfw=>set_new_ok_code
      EXPORTING
        new_code = 'KAMU'
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD create_new_command.

    DATA: l_select              TYPE REF TO lcl_select_command,
          ls_text               LIKE LINE OF l_select->text,
          ls_commands           TYPE gty_commands,

          l_copy_sc             TYPE REF TO lcl_select_command,
          l_command_id          TYPE lty_commandid,

          lv_command_id_str(10) TYPE n.

    IF sy-subrc NE 0.
      g_selected_nodekey = gc_nodekey_current_commands.
    ENDIF.

    CASE p_command_type.

      WHEN gc_ctype_select.

        TRY.

            l_copy_sc ?= p_copy_from.

            CREATE OBJECT l_select
              EXPORTING
                p_copy_from = l_copy_sc.

          CATCH cx_sy_move_cast_error.
            CREATE OBJECT l_select.
        ENDTRY.

        l_select->command_type = p_command_type.
        ls_commands-command = l_select.

        CLEAR g_selected_nodekey.


        IF sql IS INITIAL.
          READ TABLE i_sql INTO l_sql INDEX 1.
          IF sy-subrc = 0.
            zcl_ap_string=>string2tabla( EXPORTING string = l_sql-string
                                         CHANGING  tabla  = l_select->text ).
          ELSE.
            ls_text =  'SELECT *'.
            APPEND ls_text TO l_select->text.
            ls_text =  'FROM '.
            APPEND ls_text TO l_select->text.
            ls_text =  'UP TO 200 ROWS'.
            APPEND ls_text TO l_select->text.
          ENDIF.
        ELSEIF sql = '*'.
          l_select->text = i_lineas_sql.
        ELSE.
          ls_text =  sql.
          APPEND ls_text TO l_select->text.
        ENDIF.


        l_select->mv_colmn_header   = gv_def_col_hdr.
        l_select->mv_key_colmn_type = gv_def_keycol_type.

        l_select->mv_last_display = 'G'.
        current_command = l_select.

        l_select->mv_command_type = l_select->command_type.


    ENDCASE.

    CALL METHOD g_textedit->set_readonly_mode
      EXPORTING
        readonly_mode = '0'.

    current_command->command_id = l_command_id.
    ls_commands-command_id = l_command_id.

    command_count = command_count + 1.
    ls_commands-seq_no = command_count.
    ls_commands-treelevel = current_command->treelevel.
    APPEND ls_commands TO command_list.

    IF command_count EQ 1.

      CLEAR prev_command.
    ENDIF.

    CALL METHOD g_commands->display_command.
**    CALL METHOD g_application->refresh_status_indicators.

    CALL METHOD g_application->create_tb_tree_toolbar.

    lv_command_id_str = current_command->command_id.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD execute_command.

    DATA: l_select_command  TYPE REF TO lcl_select_command,
          l_c_type          TYPE lty_commandtype,

          lo_tree           TYPE REF TO cl_gui_alv_tree,
          lx_root           TYPE REF TO cx_root,

          lv_message        TYPE string,
          lv_read_auth      TYPE c,
          ls_table_alias_tb LIKE LINE OF current_command->table_alias_tb.


    GET RUN TIME FIELD gv_starttime.

    IF sy-tcode = 'ZSQL_TEST'.
      IF current_command->command_type NE gc_ctype_select.
        RETURN.
      ENDIF.
    ENDIF.

    CALL METHOD transfer_text_to_command.

    TRY.
        l_select_command ?= current_command.

*          message 'ZENITH:Casting error3' TYPE 'E'.

        DATA: lv_log_handle LIKE g_application->mv_log_handle.

        IF gv_autotest = 'X'.
          lv_log_handle = g_application->mv_log_handle.
        ENDIF.

*CALL METHOD l_select_command->assign_field_symbols.
        CLEAR: v_es_report, v_comando.
        DATA: l_aux1      TYPE string, l_aux2 TYPE string,
              l_report(6).
        l_aux1 = current_command->commandtext.
        CONDENSE l_aux1 NO-GAPS.
        l_report = l_aux1.
        TRANSLATE l_report TO UPPER CASE.
        IF l_report = 'REPORT'.
          v_es_report = v_comando = 'X'.
          SPLIT l_aux1+6 AT '.' INTO l_aux1 l_aux2.
          CONDENSE l_aux1 NO-GAPS.
          v_nombre_report = l_aux1.
        ELSE.
          SPLIT current_command->commandtext AT 'FROM' INTO l_aux1 l_aux2.
          CONDENSE l_aux2.
          SPLIT l_aux2 AT ` ` INTO l_aux1 l_aux2.
        ENDIF.

        IF zcl_c=>existe( constante = 'USUARIO_AP' valor = sy-uname ) = ''.
          CLEAR v_es_report.
        ENDIF.

        READ TABLE i_sql INTO l_sql WITH KEY string = current_command->commandtext.
        IF sy-subrc = 0.
          DELETE i_sql INDEX sy-tabix.
          DELETE FROM ztemps
           WHERE clave = l_sql-clave
             AND subclave = l_sql-subclave
             AND indice = l_sql-indice.
        ENDIF.

*current_command->text
        ztemps-string = zcl_ap_string=>tabla2string( current_command->text ).

        SELECT indice string FROM ztemps
          INTO CORRESPONDING FIELDS OF *ztemps
         WHERE clave = l_sql-clave
           AND subclave = l_aux1.
          IF *ztemps-string = ztemps-string.
            DELETE FROM ztemps
             WHERE clave = l_sql-clave
               AND subclave = l_aux1
               AND indice = *ztemps-indice.
            DELETE i_sql WHERE clave = l_sql-clave
               AND subclave = l_aux1
               AND indice = *ztemps-indice.
          ENDIF.
        ENDSELECT.

        zcl_ap_temp=>set_string_st( clave = 'ZSQL_APC' subclave = l_aux1 string = ztemps-string permanente = 'X' indice_auto = 'X' ).

        CLEAR i_lineas.
*        l_linea = current_command->commandtext.
*        APPEND l_linea TO i_lineas.
*      zcl_ap_string=>string2tabla( EXPORTING string = current_command->commandtext
*                                   CHANGING tabla = i_lineas ).
        i_lineas = current_command->text.

        l_sql-subclave = l_aux1.
        l_sql-string = current_command->commandtext.
        INSERT l_sql INTO i_sql INDEX 1.
        o_alv->refrescar_grid( ).


        CALL METHOD l_select_command->mo_pipacs_select->create_new
          EXPORTING
            iv_command_id = current_command->command_id
            iv_command    = current_command->commandtext
            it_vranges    = current_command->it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.

          WHEN 1.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '077'
                iv_display_like = 'E'.
*                message s077 DISPLAY LIKE 'E'.
            RETURN.
          WHEN 2.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '076'
                iv_display_like = 'E'.
*                message s076 DISPLAY LIKE 'E'.
            RETURN.

        ENDCASE.

        l_select_command->mo_pipacs_command = l_select_command->mo_pipacs_select.


      CATCH cx_sy_move_cast_error.
*        message 'ZENITH:Casting error3' TYPE 'E'.
    ENDTRY.

    CALL METHOD current_command->parse_commandtext
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.

      WHEN 1.
*        message s079 DISPLAY LIKE 'E'.
        RETURN.
      WHEN 2.
*        message s079 DISPLAY LIKE 'E'.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '079'
            iv_display_like = 'E'.
        RETURN.

    ENDCASE.

    IF v_comando IS INITIAL. "APC20160419
      TRY.
          l_select_command ?= current_command.

          CALL METHOD l_select_command->assign_field_symbols.

          CALL METHOD me->generate_structure
            EXCEPTIONS
              empty_fieldinfo_tb    = 1
              command_is_not_select = 2
              OTHERS                = 3.

          CASE sy-subrc.
            WHEN 1.
              CALL METHOD g_application->issue_message
                EXPORTING
                  iv_msgty        = 'S'
                  iv_msgno        = '078'
                  iv_display_like = 'E'.
*            message s078 DISPLAY LIKE 'E'.
              RETURN.

            WHEN 2.
              CALL METHOD g_application->issue_message
                EXPORTING
                  iv_msgty        = 'S'
                  iv_msgno        = '080'
                  iv_display_like = 'E'.
*            message s080 DISPLAY LIKE 'E'.
              RETURN.

            WHEN 3.
              CALL METHOD g_application->issue_message
                EXPORTING
                  iv_msgty        = 'S'
                  iv_msgno        = '081'
                  iv_display_like = 'E'.
*            message s081 DISPLAY LIKE 'E'.
              RETURN.
          ENDCASE.

          CLEAR:

            l_select_command->mv_dbcnt,
            l_select_command->mv_bytes,
            l_select_command->mv_filtered,
            l_select_command->mv_pos,
            l_select_command->alv_state.

        CATCH cx_sy_move_cast_error.
      ENDTRY.
    ENDIF.

    LOOP AT current_command->table_alias_tb INTO ls_table_alias_tb.

      CALL METHOD g_application->check_s_tabu_dis
        EXPORTING
          iv_for_editing = ' '
          iv_tabname     = ls_table_alias_tb-table
        IMPORTING
          ev_auth        = lv_read_auth.

      IF lv_read_auth IS INITIAL.
        MESSAGE s125 DISPLAY LIKE 'E' WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

    ENDLOOP.

    DATA: lv_simulation TYPE c.

    IF iv_mode = 'SIMULATE'.
      lv_simulation = 'X'.
    ELSE.
      CLEAR lv_simulation.
    ENDIF.



    CALL METHOD current_command->execute_parsed_sql
      EXPORTING
        po_grid                  = g_alv
        po_tree                  = lo_tree
        iv_simulation            = lv_simulation
        iv_bg_proc               = iv_bg_proc
        iv_bg_date               = iv_bg_date
        iv_bg_time               = iv_bg_time
        iv_read_from_file        = iv_read_from_file
      IMPORTING
        er_exception             = lx_root
        et_srccode               = current_command->mt_srccode
      EXCEPTIONS
        table_not_found          = 1
        parse_error              = 2
        exec_error               = 3
        error_occurred           = 4
        unlock_error             = 5
        arg_to_long              = 6
        foreign_lock             = 7
        foreign_lock_all_clients = 8
        job_submit_error         = 9
        field_list_changed       = 10
        file_open_error          = 11
        no_auth_for_table        = 12
        OTHERS                   = 13.

    CASE sy-subrc.
      WHEN 0.

      WHEN 1.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '082'
            iv_display_like = 'E'.
*          message s082 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 2.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '079'
            iv_display_like = 'E'.
*          message s079 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 3.
        IF lx_root IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '083'
              iv_display_like = 'E'.
        ELSE.
          CALL METHOD lx_root->if_message~get_longtext
            RECEIVING
              result = lv_message.
          MESSAGE lv_message TYPE 'S' DISPLAY LIKE 'E'.
        ENDIF.

        RETURN.

      WHEN 4.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '083'
            iv_display_like = 'E'.
*          message s083 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 5.
        MESSAGE i073 DISPLAY LIKE 'W' WITH sy-msgv1.
        RETURN.

      WHEN 6.
        MESSAGE i069 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 7.
        MESSAGE i071 DISPLAY LIKE 'E' WITH sy-msgv1 sy-msgv2 sy-msgv3.
        RETURN.

      WHEN 8.
        MESSAGE i070 DISPLAY LIKE 'E' WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 9.
        MESSAGE i134 DISPLAY LIKE 'E'. " WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 10.
        MESSAGE i144 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 11.
        MESSAGE i145 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 12.
        MESSAGE s125 DISPLAY LIKE 'E' WITH sy-msgv1.
        RETURN.

      WHEN 13.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '084'
            iv_display_like = 'W'.
*          message s084 DISPLAY LIKE 'W'.
    ENDCASE.

    TRY.
        l_select_command ?= current_command.

        IF lv_simulation IS INITIAL AND
           iv_bg_proc    IS INITIAL.
          CALL METHOD me->display.
        ENDIF.

        l_select_command->mv_read_from_file = iv_read_from_file.

        IF iv_read_from_file EQ 'X'.
          CALL METHOD g_alv->set_toolbar_interactive.
        ENDIF.

        current_command->mv_grid_modified = ' '.

        IF lv_simulation IS INITIAL.
          CALL METHOD g_application->refresh_status_indicators.
        ENDIF.

        IF lv_simulation = 'X'.
          CLEAR l_select_command->fcat.
        ELSE.
          l_select_command->prev_fcat = l_select_command->fcat.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error4' TYPE 'E'.
    ENDTRY.

    CALL METHOD current_command->get_type
      IMPORTING
        ep_command_type = l_c_type.

    IF l_c_type NE gc_ctype_lawb.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

    IF iv_bg_proc IS INITIAL.
      IF lv_simulation = 'X'.
        MESSAGE s120.
      ELSE.
        CALL METHOD me->write_status_message.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD write_status_message.

    DATA: lstr2            TYPE string,
          lv_float         TYPE f,
          lv_p             TYPE p DECIMALS 3,
          l_select_command TYPE REF TO lcl_select_command.


    GET RUN TIME FIELD gv_endtime.
    gv_deltatime = ( gv_endtime - gv_starttime ) DIV 1000.

    lv_float = gv_deltatime / 1000.

    lv_p = lv_float.
    MOVE lv_p TO lstr2.

    TRY.
        l_select_command ?= current_command.

        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'S'
            iv_msgno = '047'
            iv_msgv1 = l_select_command->mv_dbcnt
            iv_msgv2 = lstr2
            iv_msgv3 = l_select_command->mv_bytes.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    " write_status_message


  METHOD transfer_text_to_command.

    DATA: l_text  TYPE source_table,
          ls_text LIKE LINE OF l_text,
          l_str   TYPE string.

    IF sy-tcode = 'ZSQL_TEST'.
      l_text[] = current_command->text[].
    ELSE.
      CALL METHOD g_textedit->get_text
        IMPORTING
          table  = l_text[]
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc = 1.
*        MESSAGE i025.
      ENDIF.
    ENDIF.

    IF current_command->text[] NE l_text[].
      IF current_command->mv_ctext_changed IS INITIAL.
        current_command->mv_ctext_changed = 'X'.
      ENDIF.
    ENDIF.

    current_command->text[] = l_text[].

    IF l_text IS NOT INITIAL.
      CALL METHOD lcl_toolbox=>pretty_printer
        CHANGING
          ct_source = l_text.

      LOOP AT l_text INTO ls_text.
        IF ls_text(1) NE '*'.
          CONCATENATE l_str ls_text INTO l_str SEPARATED BY ' '.
        ENDIF.
      ENDLOOP.

      CALL METHOD current_command->set_commandtext
        EXPORTING
          p_commandtext = l_str.
    ENDIF.

  ENDMETHOD.                    "transfer_text_to_command

  METHOD parse_only_command.

    DATA: l_select_command TYPE REF TO lcl_select_command.

    IF p_on_load EQ ' '.
      CALL METHOD transfer_text_to_command.
    ENDIF.
    TRY.
        l_select_command ?= current_command.

        DATA: lv_log_handle LIKE g_application->mv_log_handle.

        IF gv_autotest = 'X'.
          lv_log_handle = g_application->mv_log_handle.
        ENDIF.

        CALL METHOD l_select_command->mo_pipacs_select->create_new
          EXPORTING
            iv_command_id = current_command->command_id
            iv_command    = current_command->commandtext
            it_vranges    = current_command->it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.
          WHEN 1.
            RAISE no_id.
          WHEN 2.
            RAISE create_error.
        ENDCASE.

        l_select_command->mo_pipacs_command = l_select_command->mo_pipacs_select.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

    IF p_on_load EQ ' '.
****      CALL METHOD g_application->refresh_curr_tree_node_caption.
    ENDIF.

    CALL METHOD current_command->parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 2.
        RAISE parse_error.
    ENDCASE.

    IF p_on_load EQ ' '.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

  ENDMETHOD.                    " parse_only_command

ENDCLASS.                    "LCL_COMMANDS IMPLEMENTATION

*&---------------------------------------------------------------------*
*&      Form  mem_export
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mem_export .

  DATA: BEGIN OF mode,                 " Schnittstelle fr SE13
          show(1),
          edit(1),
        END OF mode.

  mode-show = 'X'.
  mode-edit = ' '.
  EXPORT mode TO MEMORY ID 'MOD'.


ENDFORM.                    " mem_export
