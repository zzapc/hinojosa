
class ZCLPP_APP_LOGISTICA definition
  public
  final
  create public .

public section.

  types:
    BEGIN OF ty_datos_entrega,
        vbeln      TYPE vbeln_vl,
        tp_stock   TYPE char5,
        estado     TYPE char5,
        kunnr      TYPE kunnr,
        name1      TYPE name1_gp,
        icono      TYPE char40,
        cant_entre TYPE z_cantidad_sin_dec,
        cant_pick  TYPE z_cantidad_sin_dec,
      END OF ty_datos_entrega .
  types:
    tty_datos_entrega TYPE STANDARD TABLE OF ty_datos_entrega .
  types:
    BEGIN OF ty_datos_pos_entrega,
        vbeln     TYPE vbeln_vl,
        posnr     TYPE posnr_vl,
        lfimg     TYPE z_cantidad_sin_dec,
        matnr     TYPE matnr,
        maktx     TYPE maktx,
        cant_pick TYPE z_cantidad_sin_dec,
*        icono  TYPE char40,
      END OF ty_datos_pos_entrega .
  types:
    tty_datos_pos_entrega TYPE STANDARD TABLE OF ty_datos_pos_entrega .
  types:
    tty_zesd_bobinas TYPE STANDARD TABLE OF zesd_bobinas .
  types:
    BEGIN OF ty_lotes_picking,
        charg     TYPE charg_d,
        cant_pick TYPE z_cantidad_sin_dec,
      END OF ty_lotes_picking .
  types:
    tty_lotes_picking TYPE STANDARD TABLE OF ty_lotes_picking .
  types:
    BEGIN OF ty_lotes_stock,
        charg     TYPE charg_d,
        cant_pick TYPE z_cantidad_sin_dec,
        ubicacion TYPE numc10,
      END OF ty_lotes_stock .
  types:
    tty_lotes_stock TYPE STANDARD TABLE OF ty_lotes_stock .
  types:
    BEGIN OF ty_ztsd0006,
        werks	     TYPE werks_d,
        tp_cliente TYPE char01,
        orden      TYPE int1,
        kunnr	     TYPE kunnr,
      END OF ty_ztsd0006 .
  types:
    tty_ztsd0006 TYPE STANDARD TABLE OF ty_ztsd0006 .

  class-data G_WERKS type WERKS_D .
  class-data G_CLIENTE_PROPIO type KUNNR .
  class-data GC_ICON_OK type CHAR40 .
  class-data GC_ICON_WARNING type CHAR40 .

  class-methods CLASS_CONSTRUCTOR .
  class-methods GET_CLIENTES
    exporting
      !OT_CLIENTES_HI type VRM_VALUES
      !OT_CLIENTES_EX type VRM_VALUES .
  class-methods GET_SELECCION_ENTREGAS
    importing
      !I_WERKS type WERKS_D
      !I_CLIENTE type KUNNR optional
      !I_ENTREGA type VBELN_VL optional
    exporting
      value(OT_ENTREGAS) type TTY_DATOS_ENTREGA
      !O_RC type CHAR2 .
  class-methods GET_POSICIONES_ENTREGA
    importing
      !I_WERKS type WERKS_D
      !I_VBELN type VBELN_VL
    exporting
      !OT_POS_ENTREGA type TTY_DATOS_POS_ENTREGA
      !O_RC type CHAR2 .
  class-methods LECTURA_CODBAR
    importing
      !I_WERKS type WERKS_D
      !I_CODBAR type CHAR28
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
      !I_MATNR type MATNR
      !I_CANT_ENTREGA type Z_CANTIDAD_SIN_DEC
      !I_CANT_PICKING type Z_CANTIDAD_SIN_DEC
    exporting
      !O_CHARG type CHARG_D
      !O_KG_LOTE type Z_CANTIDAD_SIN_DEC
      !O_DIFERENCIA type Z_CANTIDAD_SIN_DEC
      !O_RC type CHAR2 .
  class-methods ANYADIR_BOBINA_A_ENTREGA
    importing
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
      !I_CHARG type CHARG_D
      !I_BRGEW type BRGEW
    exporting
      !O_RC type CHAR2 .
  class-methods VALIDAR_CODBAR_BOBINA
    importing
      !I_WERKS type WERKS_D
      !I_CODBAR type CHAR28
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
      !I_MATNR type MATNR
      !I_CANT_ENTREGA type Z_CANTIDAD_SIN_DEC
      !I_CANT_PICKING type Z_CANTIDAD_SIN_DEC
    exporting
      !O_CHARG type CHARG_D
      !O_MATNR type MATNR
      !O_BRGEW type BRGEW
      !O_DIFERENCIA type Z_CANTIDAD_SIN_DEC
      !O_RC type CHAR2 .
  class-methods QUITAR_BOBINA_A_ENTREGA
    importing
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
      !I_CHARG type CHARG_D
      !I_BRGEW type Z_CANTIDAD_SIN_DEC
    exporting
      !O_RC type CHAR2 .
  class-methods CONSULTAR_PICKING_POS_ENTREGA
    importing
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR optional
    exporting
      !OT_LOTES_PICKING type TTY_LOTES_PICKING .
  class-methods GET_DATOS_STOCK
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_KUNNR type KUNNR
      !I_LGORT type LGORT_D
      !I_TP_CALIDAD type CHAR5
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
    exporting
      !OT_LOTES_STOCK type TTY_LOTES_STOCK .
  class-methods GET_SHORT_DESC_MATNR
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
    exporting
      !O_DESC type CHAR30 .
  class-methods GET_TP_STOCK
    importing
      !I_ZZSEGCAL type ZCOD_SC
    returning
      value(R_TP_STOCK) type CHAR5 .
  class-methods IMPRIMIR_FORM_HOJA_DE_PICKING
    importing
      !I_VBELN type VBELN_VL
    exporting
      !O_RC type CHAR02 .
  class-methods GET_DATA_TO_PRINT_HOJA_PICKING
    importing
      !I_WERKS type WERKS_D
      !I_VBELN type VBELN_VL
    exporting
      !OS_DATOS_ENTREGA type ZSSD_HOJA_DE_PICKING
      !O_RC type CHAR02 .
  class-methods VALIDAR_BOBINA_EXPEDIDA
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_CHARG type CHARG_D
      !I_CLIENTE type KUNNR
    exporting
      !O_RC type CHAR02 .
  class-methods GET_TP_CLIENTE
    importing
      !I_KUNNR type KUNNR
    returning
      value(O_TP_CLIENTE) type CHAR01 .
  class-methods QUITAR_BOBINAS_A_ENTREGAR
    importing
      !I_VBELN type VBELN_VL
      !I_POSNR type POSNR
      !I_CHARG type CHARG_D
      !I_BRGEW type Z_CANTIDAD_SIN_DEC
    exporting
      !O_RC type CHAR2 .
protected section.
private section.

  class-data GT_CLIENTES type TTY_ZTSD0006 .
endclass. "ZCLPP_APP_LOGISTICA definition
class ZCLPP_APP_LOGISTICA implementation.
  METHOD anyadir_bobina_a_entrega.

    DATA: wa_vbkok                  TYPE vbkok,
          lt_vbpok                  TYPE STANDARD TABLE OF vbpok,
          ls_vbpok                  LIKE LINE OF lt_vbpok,
          lt_prot                   TYPE STANDARD TABLE OF prott,
          ls_prot                   LIKE LINE OF lt_prot,
          ef_error_any              TYPE xfeld,
          ef_error_in_item_deletion TYPE xfeld,
          ef_error_in_pod_update    TYPE xfeld,
          ef_error_in_interface     TYPE xfeld,
          ef_error_in_goods_issue   TYPE xfeld,
          ef_error_in_final_check   TYPE xfeld,
          ef_error_partner_update   TYPE xfeld,
          ef_error_sernr_update     TYPE xfeld.

    CLEAR:  lt_vbpok[] , lt_prot[].
    CLEAR:  ls_vbpok , wa_vbkok.
    o_rc = '00'.

    wa_vbkok-vbeln_vl = i_vbeln.

    SELECT SINGLE werks , matnr , posnr , vgbel , vgpos , lgort
      INTO @DATA(ls_lips)
      FROM lips
      WHERE vbeln = @i_vbeln
        AND posnr = @i_posnr.

    IF NOT ls_lips-vgbel IS INITIAL.
      ls_vbpok-vbeln = ls_lips-vgbel. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-vgpos. " Item of an SD document
    ELSE.
      ls_vbpok-vbeln = i_vbeln. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-posnr. " Item of an SD document
    ENDIF.

* AHORA AÑADIMOS LA POSICION DE LA PARTICION DEL LOTE

    ls_vbpok-vbeln_vl = i_vbeln.
    ls_vbpok-posnr_vl = ls_lips-posnr.
    ls_vbpok-matnr    = ls_lips-matnr.
    INSERT ls_vbpok INTO TABLE lt_vbpok.

    CLEAR: ls_vbpok.
* AHORA AÑADIMOS LA POSICION DE LA PARTICION DEL LOTE
    ls_vbpok-vbeln_vl = i_vbeln.
    ls_vbpok-posnr_vl = ls_lips-posnr.
    ls_vbpok-vbeln    = ls_lips-vgbel. " Sales and distribution document
    ls_vbpok-posnn    = ls_lips-vgpos. " Item of an SD document

* CALCULAR LA SIGUIENTE POSICION DE LA PARTICION DEL LOTE
    SELECT MAX( posnr ) INTO @DATA(l_ult_posnr)
    FROM lips
    WHERE vbeln = @i_vbeln.

    IF l_ult_posnr(1) = 9.
      l_ult_posnr = l_ult_posnr + 1.
    ELSE.
      l_ult_posnr = '900001'.
    ENDIF.

    ls_vbpok-posnn      = l_ult_posnr. " POSICION CALCULADA DEL LOTE
    ls_vbpok-wms_rfpos  = l_ult_posnr. " POSICION CALCULADA DEL LOTE
    ls_vbpok-charg      = i_charg.
    ls_vbpok-matnr      = ls_lips-matnr.
    ls_vbpok-werks      = ls_lips-werks.
    ls_vbpok-lgort      = ls_lips-lgort.
    ls_vbpok-taqui      = 'X'.
    ls_vbpok-pikmg      = i_brgew.
    ls_vbpok-lfimg      = i_brgew.
    ls_vbpok-vrkme      = 'KG'.
    INSERT ls_vbpok INTO TABLE lt_vbpok.

    CALL FUNCTION 'WS_DELIVERY_UPDATE_2'
      EXPORTING
        vbkok_wa                  = wa_vbkok
        synchron                  = 'X'
*       NO_MESSAGES_UPDATE_1      = ' '
        commit                    = 'X'
        delivery                  = i_vbeln
        update_picking            = 'X'
*       NICHT_SPERREN_1           = ' '
*       IF_CONFIRM_CENTRAL        = ' '
*       IF_WMPP                   = ' '
*       IF_GET_DELIVERY_BUFFERED  = ' '
*       IF_NO_GENERIC_SYSTEM_SERVICE       = ' '
*       IF_DATABASE_UPDATE_1      = '1'
*       IF_NO_INIT_1              = ' '
*       IF_NO_READ_1              = ' '
*       IF_ERROR_MESSAGES_SEND    = 'X'
*       IF_NO_BUFFER_REFRESH      = ' '
*       IT_PARTNER_UPDATE         =
*       IT_SERNR_UPDATE           =
*       IF_NO_REMOTE_CHG_1        = ' '
*       IF_NO_MES_UPD_PACK        = ' '
*       IF_LATE_DELIVERY_UPD      = ' '
*       IF_TXT_REINITIALIZE       =
*       IF_BOR_INIT               = ' '
*       SPE_MES_NO_SEND_NODIAL    =
*       IF_BOR_REINITIALIZE       =
      IMPORTING
        ef_error_any              = ef_error_any
        ef_error_in_item_deletion = ef_error_in_item_deletion
        ef_error_in_pod_update    = ef_error_in_pod_update
        ef_error_in_interface     = ef_error_in_interface
        ef_error_in_goods_issue   = ef_error_in_goods_issue
        ef_error_in_final_check   = ef_error_in_final_check
        ef_error_partner_update   = ef_error_partner_update
        ef_error_sernr_update     = ef_error_sernr_update
      TABLES
        vbpok_tab                 = lt_vbpok
        prot                      = lt_prot
*       VERKO_TAB                 =
*       VERPO_TAB                 =
*       VBSUPCON_TAB_1            =
*       IT_VERPO_SERNR            =
*       IT_PACKING                =
*       IT_PACKING_SERNR          =
*       IT_REPACK                 =
*       it_handling_units_1       = t_handling_units_1
*       IT_OBJECTS                =
*       ET_CREATED_HUS            =
*       TVPOD_TAB                 =
*       IT_TEXTH                  =
*       IT_TEXTL                  =
*       IT_TMSTMP                 =
*       IT_OBJ_QUAN_CHG           =
*       IT_VBPOK_SPLIT            =
*       IT_BAPIADDR1              =
*       IT_HU_HEADER_EPC          =
*       IT_HU_ITEMS_EPC           =
*       IT_AAC_ITEM_BLOCK         =
*       IT_ORMNG_TABLE            =
*       SERNR_TAB                 =
*       IT_HURES                  =
      EXCEPTIONS
        error_message             = 1
        OTHERS                    = 2.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT' EXPORTING wait = 'X'.
      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
*         MODE_LIKP      = 'E'
*         MANDT          = SY-MANDT
          vbeln          = i_vbeln
*         X_VBELN        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
    ELSE.
      CALL FUNCTION 'ABAP4_ROLLBACK_WORK'.

      MESSAGE ID sy-msgid  TYPE 'I' NUMBER sy-msgno WITH sy-msgv1
                 sy-msgv2 sy-msgv3 sy-msgv4 DISPLAY LIKE 'E'.
      CALL FUNCTION 'DEQUEUE_ALL' EXPORTING _synchron = 'X'.

      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
*         MODE_LIKP      = 'E'
*         MANDT          = SY-MANDT
          vbeln          = i_vbeln
*         X_VBELN        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
*        o_rc = '01'.
*        EXIT.
      ENDIF.

      o_rc = '30'.
      EXIT.
    ENDIF.


  ENDMETHOD.
  METHOD class_constructor.

* Obtener usuario
    SELECT SINGLE parva
      INTO g_werks
      FROM usr05
      WHERE bname = sy-uname AND
            parid = 'WRK'.

    g_cliente_propio = |C{ g_werks }|.

*  Crear iconos para tabla de entregas.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name                  = icon_led_green
*       text                  = icon_text
*       info                  = icon_info
        add_stdinf            = ' '
      IMPORTING
        result                = gc_icon_ok
      EXCEPTIONS
        icon_not_found        = 1
        outputfield_too_short = 2
        OTHERS                = 3.
    IF sy-subrc <> 0.
    ENDIF.

    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name                  = icon_led_yellow
*       text                  = icon_text
*       info                  = icon_info
        add_stdinf            = ' '
      IMPORTING
        result                = gc_icon_warning
      EXCEPTIONS
        icon_not_found        = 1
        outputfield_too_short = 2
        OTHERS                = 3.
    IF sy-subrc <> 0.
    ENDIF.


  ENDMETHOD.
  method CONSULTAR_PICKING_POS_ENTREGA.


  IF i_posnr is SUPPLIED.

* Obtener lotes asociados a una posición de entrega.
    SELECT charg , lfimg
      INTO table @ot_lotes_picking
      FROM lips
      WHERE vbeln    = @i_vbeln and
            uecha    = @i_posnr and
            posnr like '900%'.
  else.

* Si no se informa la posición, buscamos en TODAS las posiciones de la entrega
    SELECT charg , lfimg
      INTO table @ot_lotes_picking
      FROM lips
      WHERE vbeln    = @i_vbeln and
*            uecha    = @i_posnr and
            posnr like '900%'.

  ENDIF.


  endmethod.
  METHOD get_clientes.

    CLEAR: ot_clientes_hi[] , ot_clientes_ex[].

      SELECT ztsd0006~kunnr , tp_cliente , name1
        INTO TABLE @DATA(lt_clientes)
        FROM ztsd0006
        JOIN kna1 ON ztsd0006~kunnr = kna1~kunnr
        WHERE ztsd0006~werks = @g_werks AND
              ztsd0006~lvorm = ' '
        ORDER BY tp_cliente , orden .

    LOOP AT lt_clientes INTO DATA(ls_cliente).
      CASE ls_cliente-tp_cliente.
        WHEN 'H'. "Clientes grupo Hinojosa
          APPEND INITIAL LINE TO ot_clientes_hi ASSIGNING FIELD-SYMBOL(<fs_clientes>).
          <fs_clientes>-key   = |{ ls_cliente-kunnr ALPHA = OUT }|.
          <fs_clientes>-text  = |{ ls_cliente-name1 }|.

        WHEN 'E' or 'X'. "Clientes externos
          APPEND INITIAL LINE TO ot_clientes_ex ASSIGNING <fs_clientes>.
          <fs_clientes>-key   = |{ ls_cliente-kunnr ALPHA = OUT }|.
          <fs_clientes>-text  = |{ ls_cliente-name1 }|.
        WHEN OTHERS.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_data_to_print_hoja_picking.


    CLEAR: os_datos_entrega.
    o_rc = '00'.

    CALL METHOD zclpp_app_logistica=>get_seleccion_entregas
      EXPORTING
        i_werks     = i_werks
        i_entrega   = i_vbeln
      IMPORTING
        ot_entregas = DATA(lt_entrega)
        o_rc        = o_rc.

    CHECK o_rc = '00'.

    TRY.
        DATA(ls_entrega) = lt_entrega[ 1 ].

        os_datos_entrega-werks  = i_werks .
        os_datos_entrega-vbeln  = |{ i_vbeln ALPHA = OUT }| .
        os_datos_entrega-kunnr  = |{ ls_entrega-kunnr ALPHA = OUT }| .

        CALL METHOD zcl_utils_hpap_pp=>get_datos_cliente
          EXPORTING
            i_kunnr = os_datos_entrega-kunnr
          IMPORTING
            o_name1 = os_datos_entrega-name1.

        os_datos_entrega-name1  = ls_entrega-name1 .
*        os_datos_entrega-btgew  = ls_entrega-cant_entre .
        os_datos_entrega-btgew  = |{ ls_entrega-cant_entre NUMBER = USER }|.
        CONDENSE os_datos_entrega-btgew NO-GAPS.
        os_datos_entrega-gewei  = 'KG' .

      CATCH cx_root .
        o_rc = '01'.
        EXIT.
    ENDTRY.

* DTM - Se obtiene la calidad
    SELECT SINGLE zzsegcal FROM likp
      WHERE vbeln EQ @i_vbeln
    INTO @DATA(lv_calidad).

    IF sy-subrc EQ 0.

      IF lv_calidad IS INITIAL.

        os_datos_entrega-zzsegcal = 'BOBINAS A'.

      ELSE.

        SELECT SINGLE texto FROM ztsd0004
          WHERE zzsegal EQ @lv_calidad
            AND spras EQ @sy-langu
        INTO @os_datos_entrega-zzsegcal.

        IF sy-subrc EQ 0.

          TRANSLATE os_datos_entrega-zzsegcal TO UPPER CASE.

        ENDIF.

      ENDIF.

    ENDIF.
* DTM

    CALL METHOD zclpp_app_logistica=>get_posiciones_entrega
      EXPORTING
        i_werks        = i_werks
        i_vbeln        = i_vbeln
      IMPORTING
        ot_pos_entrega = DATA(lt_pos_entrega)
        o_rc           = o_rc.

    CHECK o_rc = '00'.

    os_datos_entrega-vbeln = |{ i_vbeln ALPHA = OUT }|.
    LOOP AT lt_pos_entrega INTO DATA(ls_pos_entr).

      APPEND INITIAL LINE TO os_datos_entrega-pos[] ASSIGNING FIELD-SYMBOL(<fs_posicion>).
      <fs_posicion>-posnr = ls_pos_entr-posnr.
      <fs_posicion>-matnr = ls_pos_entr-matnr.
      <fs_posicion>-maktx = zcl_utils_hpap_pp=>get_descr_material( <fs_posicion>-matnr ).
*      <fs_posicion>-lfimg = |{ ls_pos_entr-lfimg } Kg|.
      <fs_posicion>-lfimg = |{ ls_pos_entr-lfimg NUMBER = USER }|.
      <fs_posicion>-meins = 'Kg'.
*<fs_posicion>-cant_pick = ls_pos_entr-cant_pick.   "Interesa mostrar?!?!?!


* Obtener lotes en stock que coincidan con este material y cliente.
      CALL METHOD zclpp_app_logistica=>get_datos_stock
        EXPORTING
          i_werks        = i_werks
          i_matnr        = <fs_posicion>-matnr
          i_kunnr        = os_datos_entrega-kunnr
          i_lgort        = '1040'
          i_tp_calidad   = ls_entrega-tp_stock
          i_vbeln        = i_vbeln
          i_posnr        = <fs_posicion>-posnr
        IMPORTING
          ot_lotes_stock = DATA(lt_stock_lotes).

      CHECK ls_entrega-tp_stock <> 'CAB' AND ls_entrega-tp_stock <> 'CAB 2'.

* Rellenar tabla de lotes de la posición, si tp_stock es BOB 2, asignar cliente de la entrega.
      LOOP AT lt_stock_lotes INTO DATA(ls_lote).

        APPEND INITIAL LINE TO <fs_posicion>-t_lotes_posicion[] ASSIGNING FIELD-SYMBOL(<fs_lote_pos>).

        <fs_lote_pos>-charg     = ls_lote-charg.
*        <fs_lote_pos>-clabs     = ls_lote-cant_pick.
        <fs_lote_pos>-clabs = |{ ls_lote-cant_pick NUMBER = USER }|.
        <fs_lote_pos>-ubicacion = |{ ls_lote-ubicacion ALPHA = OUT }|.

        IF ls_entrega-tp_stock = 'BOB 2'.
          <fs_lote_pos>-kunnr = os_datos_entrega-kunnr.
        ELSE.
          CALL METHOD zcl_utils_hpap_pp=>get_caracteristicas_lote
            EXPORTING
              i_matnr   = <fs_posicion>-matnr
              i_charg   = <fs_lote_pos>-charg
              i_tp_lote = 'B'
            IMPORTING
              o_kunnr   = <fs_lote_pos>-kunnr.

        ENDIF.

      ENDLOOP.

    ENDLOOP.


  ENDMETHOD.
  METHOD get_datos_stock.

    DATA: l_decision_empleo TYPE char13.
    DATA: l_objkey TYPE ausp-objek.

    CLEAR: ot_lotes_stock[].

    SELECT mchb~matnr, charg , clabs FROM mara
         JOIN mchb ON mara~matnr EQ mchb~matnr
         INTO TABLE @DATA(lt_charg)
        WHERE mara~matnr  = @i_matnr
          AND werks       = @i_werks
          AND lgort       = @i_lgort
          AND clabs NE 0.

    CHECK sy-subrc = 0.

    CASE i_tp_calidad.
      WHEN 'BOB'.   l_decision_empleo = 'DE A'.
      WHEN 'CAB'.   l_decision_empleo = 'DE A'.
      WHEN 'BOB 2'. l_decision_empleo = 'DE R'.
      WHEN 'CAB 2'. l_decision_empleo = 'DE R'.
    ENDCASE.

* Obtener lotes de todas las posiciones de la entrega que se está tratando, para discriminar esos lotes.
    CALL METHOD zclpp_app_logistica=>consultar_picking_pos_entrega
      EXPORTING
        i_vbeln          = i_vbeln
*        i_posnr          = i_posnr
      IMPORTING
        ot_lotes_picking = DATA(lt_lotes_picking).



    LOOP AT lt_charg INTO DATA(ls_charg).

      TRY. "NO mostrar lotes que ya esten en la entrega que se está tratando.
          DATA(ls_reg) = lt_lotes_picking[ charg = ls_charg-charg ].
          CONTINUE.
        CATCH cx_root .
      ENDTRY.


      CALL METHOD zclpp_seguimiento_pedidos=>get_caracteristicas_bobina
        EXPORTING
          i_matnr     = ls_charg-matnr
          i_charg     = ls_charg-charg
        IMPORTING
          o_kunnr     = DATA(l_kunnr)
          o_de        = DATA(l_de)
          o_ubicacion = DATA(l_ubic).

      CHECK l_de    = l_decision_empleo.

**      l_kunnr = |{ l_kunnr ALPHA = in }|.
      l_kunnr = |{ l_kunnr ALPHA = OUT }| .
      CHECK l_kunnr = i_kunnr.

      APPEND INITIAL LINE TO ot_lotes_stock ASSIGNING FIELD-SYMBOL(<fs_lote_stock>).
      <fs_lote_stock>-charg            = ls_charg-charg.
      <fs_lote_stock>-cant_pick        = ls_charg-clabs.
      <fs_lote_stock>-ubicacion        = l_ubic.

    ENDLOOP.



  ENDMETHOD.
  METHOD get_posiciones_entrega.

    DATA: lt_pos_entrega TYPE STANDARD TABLE OF bbp_inbd_d,
          lt_ret         TYPE STANDARD TABLE OF bapireturn,
          l_vbeln_in     TYPE vbeln_vl.

    CONSTANTS: lc_matnr TYPE matnr VALUE '000001019900000000'. "DTM - Non Standard Paper

    FIELD-SYMBOLS <fs_po_entrega> TYPE ty_datos_pos_entrega.

    CLEAR: ot_pos_entrega[].
    o_rc = '00'.


    l_vbeln_in = |{ i_vbeln ALPHA = IN }|.

    CALL FUNCTION 'BBP_INB_DELIVERY_GETDETAIL'
      EXPORTING
        if_delivery            = l_vbeln_in
      TABLES
        et_inb_delivery_detail = lt_pos_entrega
        return                 = lt_ret.
    IF line_exists( lt_ret[ type = 'E' ] ).
      o_rc = '01'.
      EXIT.
    ENDIF.


    LOOP AT lt_pos_entrega INTO DATA(ls_pos_entrega).

      IF ls_pos_entrega-deliv_item CP '90*'.
        CHECK <fs_po_entrega> IS ASSIGNED.
        <fs_po_entrega>-lfimg      = <fs_po_entrega>-lfimg + ls_pos_entrega-deliv_qty.
        <fs_po_entrega>-cant_pick  = <fs_po_entrega>-cant_pick + ls_pos_entrega-deliv_qty.
      ELSE.
* DTM - Se comprueba si el tipo de material es recorte (ZREC)
        SELECT SINGLE mtart FROM mara
          WHERE matnr EQ @ls_pos_entrega-material
        INTO @DATA(lv_mtart).

* DTM - Si el tipo de material es recorte (ZREC) no guardamos la línea en la tabla
        IF lv_mtart NE 'ZREC'. "AND ls_pos_entrega-material NE lc_matnr.
          APPEND INITIAL LINE TO ot_pos_entrega ASSIGNING  <fs_po_entrega> .

          <fs_po_entrega>-vbeln  = ls_pos_entrega-delivery.
          <fs_po_entrega>-posnr  = ls_pos_entrega-deliv_item.
          <fs_po_entrega>-matnr  = ls_pos_entrega-material.
          <fs_po_entrega>-lfimg  = ls_pos_entrega-deliv_qty.

          CALL METHOD zclpp_app_logistica=>get_short_desc_matnr
            EXPORTING
              i_werks = i_werks
              i_matnr = <fs_po_entrega>-matnr
            IMPORTING
              o_desc  = DATA(l_desc).
          <fs_po_entrega>-maktx = l_desc.
        ENDIF.
      ENDIF.
    ENDLOOP.

* Borrar posiciones con 0kg entrega.
    DELETE ot_pos_entrega WHERE lfimg = 0.

  ENDMETHOD.
  METHOD get_seleccion_entregas.

    CLEAR ot_entregas.
    o_rc = '00'.

* Obtener datos a partir del cliente.
    IF i_cliente IS NOT INITIAL.

      DATA: l_cli TYPE kunwe.
      l_cli = |{ i_cliente ALPHA = IN }|.

      SELECT likp~vbeln , likp~zzsegcal , vbuk~wbstk ,
             vbuk~kostk , kunnr
        INTO  TABLE @DATA(lt_likp)
        FROM likp
        INNER JOIN vbuk ON vbuk~vbeln = likp~vbeln
        WHERE vbuk~wbstk  <> 'C'           AND
**              likp~zzsegcal IN (' ','2') AND "DTM
              likp~lfart IN ('ZNLC','ZLF') AND
              likp~vbtyp = 'J' AND
              kunnr      = @l_cli AND
              vstel      = @i_werks.

    ENDIF.

* Obtener datos de la entrega
    IF i_entrega IS NOT INITIAL.
      DATA(l_entrega) = |{ i_entrega ALPHA = IN }|.

      SELECT likp~vbeln , likp~zzsegcal , vbuk~wbstk ,
             vbuk~kostk , kunnr
        INTO TABLE @lt_likp
        FROM likp
        INNER JOIN vbuk ON vbuk~vbeln = likp~vbeln
        WHERE vbuk~wbstk <> 'C'            AND
**              likp~zzsegcal IN (' ','2') AND "DTM
              likp~lfart IN ('ZNLC','ZLF') AND
              likp~vbtyp = 'J' AND
              likp~vbeln = @l_entrega AND
              vstel      = @i_werks.

    ENDIF.

* Convertir descriptivos de calidad y estado.
    LOOP AT lt_likp INTO DATA(ls_likp).

      APPEND INITIAL LINE TO ot_entregas ASSIGNING FIELD-SYMBOL(<fs_entrega>).
      <fs_entrega>-vbeln = ls_likp-vbeln.
      <fs_entrega>-kunnr = ls_likp-kunnr.

      CALL METHOD zcl_utils_hpap_pp=>get_datos_cliente
        EXPORTING
          i_kunnr = <fs_entrega>-kunnr
        IMPORTING
          o_name1 = <fs_entrega>-name1.

      CASE ls_likp-kostk.
        WHEN 'A'.
          <fs_entrega>-estado = 'PDTE'.
          <fs_entrega>-icono  = gc_icon_ok.
        WHEN 'B'.
          <fs_entrega>-estado = 'PICK'.
          <fs_entrega>-icono  = gc_icon_warning.
* DTM - Status picking completo
        WHEN 'C'.
          <fs_entrega>-estado = 'COMP'.
          <fs_entrega>-icono  = gc_icon_warning.
* DTM
        WHEN OTHERS.
          CLEAR <fs_entrega>.
          CONTINUE.
      ENDCASE.

      <fs_entrega>-tp_stock = get_tp_stock( ls_likp-zzsegcal ).

* Obtener kg.entrega y kg.picking de cada entrega.
      CALL METHOD zclpp_app_logistica=>get_posiciones_entrega
        EXPORTING
          i_werks        = i_werks
          i_vbeln        = <fs_entrega>-vbeln
        IMPORTING
          ot_pos_entrega = DATA(lt_pos_entre)
          o_rc           = DATA(l_rc).

      LOOP AT lt_pos_entre INTO DATA(ls_posic) WHERE NOT posnr CP '90*' .
        <fs_entrega>-cant_entre = <fs_entrega>-cant_entre + ls_posic-lfimg.
        <fs_entrega>-cant_pick  = <fs_entrega>-cant_pick  + ls_posic-cant_pick.
      ENDLOOP.

    ENDLOOP.

    IF sy-subrc <> 0.
      o_rc = '01'.
    ENDIF.

    DELETE ot_entregas WHERE vbeln IS INITIAL OR cant_entre = 0.

    DATA(l_lineas) = lines( ot_entregas[] ).
    IF l_lineas = 0.
      o_rc = '02'.
    ENDIF.
  ENDMETHOD.
  METHOD get_short_desc_matnr.

    SELECT SINGLE matkl , zzgramaje , zzancho
      INTO @DATA(ls_mara)
      FROM mara
      WHERE matnr = @i_matnr.

    SELECT SINGLE descrip_corta
      INTO @DATA(l_desc_corta)
      FROM ztpp0035
      WHERE werks    = @i_werks AND
            zcalidad = @ls_mara-matkl.

    o_desc = |{ l_desc_corta } { ls_mara-zzgramaje ALPHA = OUT }gr { ls_mara-zzancho ALPHA = OUT }mm|.

  ENDMETHOD.
  method GET_TP_CLIENTE.

*    H - Hinojosa , E - Externo
    IF gt_clientes is INITIAL.

      SELECT *
        INTO CORRESPONDING FIELDS OF TABLE @gt_clientes
        FROM ztsd0006
        JOIN kna1 ON ztsd0006~kunnr = kna1~kunnr
        WHERE ztsd0006~werks = @g_werks AND
              ztsd0006~lvorm = ' ' .

    ENDIF.

    TRY .
      o_tp_cliente = gt_clientes[ kunnr = i_kunnr ]-tp_cliente.
    CATCH cx_root.
      clear o_tp_cliente.
    ENDTRY.

  endmethod.
  METHOD get_tp_stock.

    CLEAR r_tp_stock.

    CASE i_zzsegcal.
      WHEN '1'. r_tp_stock = 'CAB'.
      WHEN '2'. r_tp_stock = 'BOB 2'.
      WHEN '3'. r_tp_stock = 'CAB 2'.
      WHEN ' '. r_tp_stock = 'BOB'.
      WHEN OTHERS.
    ENDCASE.

  ENDMETHOD.
  METHOD imprimir_form_hoja_de_picking.

    CONSTANTS: c_formulari  TYPE fpname VALUE 'ZESSDF_HOJA_PICKING_2021'.
    DATA: lv_padest       TYPE rspopname,
          fp_docparams    TYPE sfpdocparams,
          fp_outputparams TYPE sfpoutputparams.
    DATA: fm_name         TYPE rs38l_fnam.

    SELECT SINGLE vstel, vkorg
      INTO @DATA(wa_likp)
      FROM likp
      WHERE vbeln = @i_vbeln.


    CALL METHOD zclpp_app_logistica=>get_data_to_print_hoja_picking
      EXPORTING
        i_werks          = wa_likp-vstel "l_werks
        i_vbeln          = i_vbeln
**        i_vkorg          = wa_likp-vkorg
      IMPORTING
        os_datos_entrega = DATA(ls_datos_entrega)
        o_rc             = o_rc.

* Se comprueba si ha habido error para imprimir o no el formulario
    CHECK o_rc EQ 0. "DTM

    lv_padest = zcl_utils_hpap_pp=>determinar_disp_impresion( ).
    CLEAR fp_outputparams.
    fp_outputparams-dest = lv_padest.
    fp_outputparams-reqimm = 'X'.
    fp_outputparams-nodialog = ' '. " No diálogo
    fp_outputparams-reqnew = 'X'.
    fp_outputparams-copies    = 1.
    IF lv_padest IS NOT INITIAL.
      fp_outputparams-dest = lv_padest.
    ELSE.
      fp_outputparams-dest = 'LOCA'.
    ENDIF.

* Impresión de etiqueta de Notificación de defectos.
    CALL FUNCTION 'FP_JOB_OPEN'
      CHANGING
        ie_outputparams = fp_outputparams
      EXCEPTIONS
        cancel          = 1
        usage_error     = 2
        system_error    = 3
        internal_error  = 4
        OTHERS          = 5.
    IF sy-subrc <> 0.
      IF sy-ucomm NE 'CANC'. "DTM
        o_rc = '01'.
      ENDIF.
      EXIT.
    ENDIF.

    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
      EXPORTING
        i_name     = c_formulari
      IMPORTING
        e_funcname = fm_name.


    CALL FUNCTION fm_name
      EXPORTING
        /1bcdwb/docparams = fp_docparams
*       hoja_picking      = l_hoja_p
*       logo              = l_logo
        hoja_picking_2021 = ls_datos_entrega
      EXCEPTIONS
        usage_error       = 1
        system_error      = 2
        internal_error    = 3.

    CALL FUNCTION 'FP_JOB_CLOSE'
      EXCEPTIONS
        usage_error    = 1
        system_error   = 2
        internal_error = 3
        OTHERS         = 4.
    IF sy-subrc <> 0.
*   Implement suitable error handling here
    ENDIF.

  ENDMETHOD.
  METHOD lectura_codbar.

    o_rc = '00'.

    DATA(l_len) = strlen( i_codbar ).

    IF l_len < 10.
      o_rc = '01'. "Código de bobina incorrecto
      RETURN.
    ENDIF.

    CALL METHOD zclpp_app_logistica=>validar_codbar_bobina
      EXPORTING
        i_werks        = i_werks
        i_codbar       = i_codbar
        i_vbeln        = i_vbeln
        i_posnr        = i_posnr
        i_matnr        = i_matnr
        i_cant_entrega = i_cant_entrega
        i_cant_picking = i_cant_picking
      IMPORTING
        o_charg        = o_charg
        o_matnr        = DATA(l_matnr)
        o_brgew        = DATA(l_brgew)
        o_diferencia   = o_diferencia
        o_rc           = o_rc.

    o_kg_lote = CONV #( l_brgew ).

    CHECK o_rc ='00'.

    CALL METHOD zclpp_app_logistica=>anyadir_bobina_a_entrega
      EXPORTING
        i_vbeln = |{ i_vbeln ALPHA = in }|
        i_posnr = i_posnr
        i_charg = o_charg
        i_brgew = l_brgew
      IMPORTING
        o_rc    = o_rc.

  ENDMETHOD.
  METHOD quitar_bobina_a_entrega.

    DATA: wa_vbkok                  TYPE vbkok,
          lt_vbpok                  TYPE STANDARD TABLE OF vbpok,
          ls_vbpok                  LIKE LINE OF lt_vbpok,
          lt_prot                   TYPE STANDARD TABLE OF prott,
          ls_prot                   LIKE LINE OF lt_prot,
          ef_error_any              TYPE xfeld,
          ef_error_in_item_deletion TYPE xfeld,
          ef_error_in_pod_update    TYPE xfeld,
          ef_error_in_interface     TYPE xfeld,
          ef_error_in_goods_issue   TYPE xfeld,
          ef_error_in_final_check   TYPE xfeld,
          ef_error_partner_update   TYPE xfeld,
          ef_error_sernr_update     TYPE xfeld,
          l_brgew                   TYPE brgew.

    CLEAR:  lt_vbpok[] , lt_prot[].
    CLEAR:  ls_vbpok , wa_vbkok.
    o_rc = '00'.



    wa_vbkok-vbeln_vl = i_vbeln.

    SELECT SINGLE werks , matnr , posnr , vgbel , vgpos , lgort
      INTO @DATA(ls_lips)
      FROM lips
      WHERE vbeln = @i_vbeln
        AND posnr = @i_posnr.

    IF NOT ls_lips-vgbel IS INITIAL.
      ls_vbpok-vbeln = ls_lips-vgbel. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-vgpos. " Item of an SD document
    ELSE.
      ls_vbpok-vbeln = i_vbeln. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-posnr. " Item of an SD document
    ENDIF.

* AHORA AÑADIMOS LA POSICION DE LA PARTICION DEL LOTE

    ls_vbpok-vbeln_vl = i_vbeln.
    ls_vbpok-posnr_vl = ls_lips-posnr.
    ls_vbpok-matnr    = ls_lips-matnr.
    INSERT ls_vbpok INTO TABLE lt_vbpok.

    CLEAR: ls_vbpok.
* AHORA AÑADIMOS LA POSICION DE LA PARTICION DEL LOTE
    ls_vbpok-vbeln_vl = i_vbeln.
    ls_vbpok-posnr_vl = ls_lips-posnr.
    ls_vbpok-vbeln    = ls_lips-vgbel. " Sales and distribution document
    ls_vbpok-posnn    = ls_lips-vgpos. " Item of an SD document

* CALCULAR LA SIGUIENTE POSICION DE LA PARTICION DEL LOTE
*    CLEAR zposnr.
*    SELECT MAX( posnr ) INTO @DATA(l_ult_posnr)
*    FROM lips
*    WHERE vbeln = @i_vbeln.
    SELECT SINGLE posnr
      INTO @ls_vbpok-posnn
    FROM lips
    WHERE vbeln = @i_vbeln AND
          charg = @i_charg.

    IF sy-subrc <> 0.
      o_rc = '01'. "Bobina no encotrada en entrega
      EXIT.
    ENDIF.

    ls_vbpok-wms_rfpos  = ls_vbpok-posnn." POSICION CALCULADA DEL LOTE
    ls_vbpok-matnr      = ls_lips-matnr.
    ls_vbpok-charg      = i_charg.
    ls_vbpok-werks      = ls_lips-werks.
    ls_vbpok-lgort      = ls_lips-lgort.
*    ls_vbpok-taqui      = 'X'.
    l_brgew = i_brgew.
    ls_vbpok-pikmg      = l_brgew.
    ls_vbpok-lfimg      = l_brgew.
    ls_vbpok-vrkme      = 'KG'.
    ls_vbpok-lips_del   = 'X'.

    INSERT ls_vbpok INTO TABLE lt_vbpok.

*    ENDLOOP.

    CALL FUNCTION 'WS_DELIVERY_UPDATE_2'
      EXPORTING
        vbkok_wa                  = wa_vbkok
        synchron                  = 'X'
*       NO_MESSAGES_UPDATE_1      = ' '
        commit                    = 'X'
        delivery                  = i_vbeln
        update_picking            = 'X'
*       NICHT_SPERREN_1           = ' '
*       IF_CONFIRM_CENTRAL        = ' '
*       IF_WMPP                   = ' '
*       IF_GET_DELIVERY_BUFFERED  = ' '
*       IF_NO_GENERIC_SYSTEM_SERVICE       = ' '
*       IF_DATABASE_UPDATE_1      = '1'
*       IF_NO_INIT_1              = ' '
*       IF_NO_READ_1              = ' '
*       IF_ERROR_MESSAGES_SEND    = 'X'
*       IF_NO_BUFFER_REFRESH      = ' '
*       IT_PARTNER_UPDATE         =
*       IT_SERNR_UPDATE           =
*       IF_NO_REMOTE_CHG_1        = ' '
*       IF_NO_MES_UPD_PACK        = ' '
*       IF_LATE_DELIVERY_UPD      = ' '
*       IF_TXT_REINITIALIZE       =
*       IF_BOR_INIT               = ' '
*       SPE_MES_NO_SEND_NODIAL    =
*       IF_BOR_REINITIALIZE       =
      IMPORTING
        ef_error_any              = ef_error_any
        ef_error_in_item_deletion = ef_error_in_item_deletion
        ef_error_in_pod_update    = ef_error_in_pod_update
        ef_error_in_interface     = ef_error_in_interface
        ef_error_in_goods_issue   = ef_error_in_goods_issue
        ef_error_in_final_check   = ef_error_in_final_check
        ef_error_partner_update   = ef_error_partner_update
        ef_error_sernr_update     = ef_error_sernr_update
      TABLES
        vbpok_tab                 = lt_vbpok
        prot                      = lt_prot
*       VERKO_TAB                 =
*       VERPO_TAB                 =
*       VBSUPCON_TAB_1            =
*       IT_VERPO_SERNR            =
*       IT_PACKING                =
*       IT_PACKING_SERNR          =
*       IT_REPACK                 =
*       it_handling_units_1       = t_handling_units_1
*       IT_OBJECTS                =
*       ET_CREATED_HUS            =
*       TVPOD_TAB                 =
*       IT_TEXTH                  =
*       IT_TEXTL                  =
*       IT_TMSTMP                 =
*       IT_OBJ_QUAN_CHG           =
*       IT_VBPOK_SPLIT            =
*       IT_BAPIADDR1              =
*       IT_HU_HEADER_EPC          =
*       IT_HU_ITEMS_EPC           =
*       IT_AAC_ITEM_BLOCK         =
*       IT_ORMNG_TABLE            =
*       SERNR_TAB                 =
*       IT_HURES                  =
      EXCEPTIONS
        error_message             = 1
        OTHERS                    = 2.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT' EXPORTING wait = 'X'.
      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
*         MODE_LIKP      = 'E'
*         MANDT          = SY-MANDT
          vbeln          = i_vbeln
*         X_VBELN        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
    ELSE.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1
                 sy-msgv2 sy-msgv3 sy-msgv4 DISPLAY LIKE 'I'.
      CALL FUNCTION 'DEQUEUE_ALL' EXPORTING _synchron = 'X'.

      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
*         MODE_LIKP      = 'E'
*         MANDT          = SY-MANDT
          vbeln          = i_vbeln
*         X_VBELN        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
        o_rc = '01'.
        EXIT.
      ENDIF.

      o_rc = '01'.
*      o_rc = '30'.
*      EXIT.
    ENDIF.





    ENDMETHOD.
  METHOD quitar_bobinas_a_entregar.

    DATA: ls_vbkok                  TYPE vbkok,
          lt_vbpok                  TYPE STANDARD TABLE OF vbpok,
          ls_vbpok                  LIKE LINE OF lt_vbpok,
          lt_prot                   TYPE STANDARD TABLE OF prott,
          ls_prot                   LIKE LINE OF lt_prot,
          lv_error_any              TYPE xfeld,
          lv_error_in_item_deletion TYPE xfeld,
          lv_error_in_pod_update    TYPE xfeld,
          lv_error_in_interface     TYPE xfeld,
          lv_error_in_goods_issue   TYPE xfeld,
          lv_error_in_final_check   TYPE xfeld,
          lv_error_partner_update   TYPE xfeld,
          lv_error_sernr_update     TYPE xfeld,
          lv_brgew                  TYPE brgew.

    CLEAR: lt_vbpok[], lt_prot[], ls_vbpok, ls_vbkok.

    o_rc = '00'.

    ls_vbkok-vbeln_vl = i_vbeln.

    SELECT SINGLE werks, matnr, posnr, vgbel, vgpos, lgort
      FROM lips
      WHERE vbeln EQ @i_vbeln
        AND posnr EQ @i_posnr
    INTO @DATA(ls_lips).

    IF NOT ls_lips-vgbel IS INITIAL.

      ls_vbpok-vbeln = ls_lips-vgbel. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-vgpos. " Item of an SD document

    ELSE.

      ls_vbpok-vbeln = i_vbeln. " Sales and distribution document
      ls_vbpok-posnn = ls_lips-posnr. " Item of an SD document

    ENDIF.

* Se añade la posición de la partición del lote
    ls_vbpok-vbeln_vl = i_vbeln.
    ls_vbpok-posnr_vl = ls_lips-posnr.
    ls_vbpok-matnr    = ls_lips-matnr.

    INSERT ls_vbpok INTO TABLE lt_vbpok.

    CLEAR: ls_vbpok.

* Se obtienen los lotes de la entrega
    SELECT posnr, charg, brgew FROM lips
      WHERE vbeln EQ @i_vbeln
        AND vgpos EQ @ls_lips-vgpos
        AND posnr LIKE '9%'
    INTO TABLE @DATA(lt_lips).

    IF sy-subrc <> 0.

      o_rc = '01'. "Bobina no encotrada en entrega
      EXIT.

    ENDIF.

    LOOP AT lt_lips ASSIGNING FIELD-SYMBOL(<lfs_lips>).

      CLEAR: ls_vbpok.
      ls_vbpok-vbeln_vl   = i_vbeln.
      ls_vbpok-posnr_vl   = ls_lips-posnr.
      ls_vbpok-vbeln      = ls_lips-vgbel.
      ls_vbpok-posnn      = <lfs_lips>-posnr.
      ls_vbpok-wms_rfpos  = <lfs_lips>-posnr.
      ls_vbpok-matnr      = ls_lips-matnr.
      ls_vbpok-charg      = <lfs_lips>-charg.
      ls_vbpok-werks      = ls_lips-werks.
      ls_vbpok-lgort      = ls_lips-lgort.
      ls_vbpok-pikmg      = <lfs_lips>-brgew.
      ls_vbpok-lfimg      = <lfs_lips>-brgew.
      ls_vbpok-vrkme      = 'KG'.
      ls_vbpok-lips_del   = abap_true.

      INSERT ls_vbpok INTO TABLE lt_vbpok.

    ENDLOOP.

* Se borran todos los lotes de la entrega
    CALL FUNCTION 'WS_DELIVERY_UPDATE_2'
      EXPORTING
        vbkok_wa                  = ls_vbkok
        synchron                  = abap_true
        commit                    = abap_true
        delivery                  = i_vbeln
        update_picking            = abap_true
      IMPORTING
        ef_error_any              = lv_error_any
        ef_error_in_item_deletion = lv_error_in_item_deletion
        ef_error_in_pod_update    = lv_error_in_pod_update
        ef_error_in_interface     = lv_error_in_interface
        ef_error_in_goods_issue   = lv_error_in_goods_issue
        ef_error_in_final_check   = lv_error_in_final_check
        ef_error_partner_update   = lv_error_partner_update
        ef_error_sernr_update     = lv_error_sernr_update
      TABLES
        vbpok_tab                 = lt_vbpok
        prot                      = lt_prot
      EXCEPTIONS
        error_message             = 1
        OTHERS                    = 2.

* Si ha salido bien se graba sino, error
    IF sy-subrc EQ 0.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT' EXPORTING wait = abap_true.
      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
          vbeln          = i_vbeln
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

    ELSE.

      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1
                 sy-msgv2 sy-msgv3 sy-msgv4 DISPLAY LIKE 'I'.

      CALL FUNCTION 'DEQUEUE_ALL' EXPORTING _synchron = abap_true.

      CALL FUNCTION 'ENQUEUE_EVVBLKE'
        EXPORTING
          vbeln          = i_vbeln
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

      IF sy-subrc <> 0.

        o_rc = '01'.
        EXIT.

      ENDIF.

      o_rc = '01'.

    ENDIF.

  ENDMETHOD.
  METHOD validar_bobina_expedida.


    DATA l_objkey TYPE bapi1003_key-object.
    DATA lt_allocvaluesnum TYPE STANDARD TABLE OF bapi1003_alloc_values_num.
    DATA lt_allocvalueschar TYPE STANDARD TABLE OF bapi1003_alloc_values_char.
    DATA lw_allocvalueschar TYPE bapi1003_alloc_values_char.
    DATA lt_allocvaluescurr TYPE STANDARD TABLE OF bapi1003_alloc_values_curr.
    DATA lt_return TYPE STANDARD TABLE OF bapiret2.

    DATA: lv_matnr TYPE matnr.
    DATA: lv_werks TYPE werks_d.
    DATA: lv_lgort TYPE lgort_d.
    DATA: lv_werks_bob TYPE werks_d.
    DATA: lv_lgort_bob TYPE lgort_d.
    DATA: lv_kunnr TYPE kunnr.
    DATA  lv_vstel TYPE vstel.
    DATA  lv_kunnr_likp TYPE kunnr.
    DATA: lv_kunnr_bob TYPE kunnr.

    DATA: lv_zzsegcal TYPE likp-zzsegcal.

    o_rc = '00'.

    CALL METHOD zcl_utils_hpap_pp=>get_datos_material
      EXPORTING
        i_matnr = i_matnr
      IMPORTING
*       e_maktx =
        e_ancho = DATA(l_ancho).

* Si se trata de un cabo, no se valida la expedición.
    CHECK l_ancho > 1340.

    SELECT *
      FROM mseg
      INTO TABLE @DATA(lt_mseg)
      WHERE matnr = @i_matnr AND
            werks = @i_werks AND
            lgort = '1040'  AND
            charg = @i_charg
      ORDER BY budat_mkpf DESCENDING, cputm_mkpf DESCENDING.

    IF sy-subrc <> 0.
      o_rc = '05'. "La bobina & no existe en el almacén
      EXIT.
    ENDIF.

    DATA(l_bwart) = lt_mseg[ 1 ]-bwart.

    IF l_bwart = '601' OR l_bwart = '643'.

      o_rc = '15'. "  Bobina expedida previamente
      EXIT.
    ELSEIF l_bwart = '701'.

*     Comprobar si se ha expedido anteriormente 601 o 643
      LOOP AT lt_mseg INTO DATA(ls_mseg) WHERE bwart = '601' OR bwart = '643'.
        EXIT.
      ENDLOOP.
      IF sy-subrc EQ 0.
        o_rc = '15'. "  Bobina expedida previamente
        EXIT.
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD validar_codbar_bobina.

* •  Se validará que el almacén donde se encuentra la bobina se trate de un almacén de
*    picking (almacén 1040) En caso contrario, avisar de esta circunstancia: “Almacén incorrecto | F3 Cancelar”

* •	Se validará la correspondencia entre el tipo de calidad de la entrega y de la bobina leída.

* • Si la entrega es de bobinas buenas (ZSEGCAL = blanco), se validará que el cliente del lote
*   de la bobina sea igual al cliente de la entrega y que la bobina tenga decisión de empleo A.

* • Si la entrega es de bobinas de segunda (ZSEGCAL = 2), NO se validará que el cliente del lote
*   de la bobina sea igual al cliente de la entrega, pero SÍ que la bobina tenga decisión de empleo R.

* • Si la entrega es de cabos buenos (ZSEGCAL = 1), se validará que el cliente del lote de la
*   bobina sea C3000 o C3020, según el centro, o C2040 o C2070, y que la bobina tenga decisión empleo A.

    DATA l_objkey TYPE bapi1003_key-object.
    DATA lt_allocvaluesnum TYPE STANDARD TABLE OF bapi1003_alloc_values_num.
    DATA lt_allocvalueschar TYPE STANDARD TABLE OF bapi1003_alloc_values_char.
    DATA lw_allocvalueschar TYPE bapi1003_alloc_values_char.
    DATA lt_allocvaluescurr TYPE STANDARD TABLE OF bapi1003_alloc_values_curr.
    DATA lt_return TYPE STANDARD TABLE OF bapiret2.
    DATA: l_answer    TYPE c.

    o_rc = '00'.

    IF i_codbar(5) NE '00000'.
      o_charg = i_codbar(10).
    ELSE.
      DATA(l_len)       = strlen( i_codbar ).
      DATA(l_len_charg) = l_len - 10.
      IF l_len_charg < 0.
        o_rc = '01'.  "Código de bobina incorrecta
        EXIT.
      ENDIF.
      o_charg          = i_codbar+l_len_charg(10).
    ENDIF.

    TRANSLATE o_charg TO UPPER CASE.

    CALL METHOD zcl_utils_hpap_pp=>get_caracteristicas_lote
      EXPORTING
        i_matnr         = i_matnr
        i_charg         = o_charg
        i_tp_lote       = 'B' "Bobina
      IMPORTING
        o_de            = DATA(l_lobm_udcode)
        o_kunnr         = DATA(l_kunnr)
        o_fecha_fabric  = DATA(l_fecha_fabric)
        o_reproceso     = DATA(l_reproceso)
        o_motivo_reproc = DATA(l_motivo_reproc)
        o_rc            = o_rc.

    IF o_rc <> '00'.
      o_rc = '02'. "02 Bobina no encontrada
      EXIT.
    ENDIF.



* Verificamos el cliente y si está aprobado por calidad.
    CLEAR o_matnr.
    SELECT matnr , lgort , clabs INTO TABLE @DATA(lt_matnr)
    FROM mchb
    WHERE werks = @i_werks AND
          charg = @o_charg  AND
          clabs > 0 .
    IF sy-subrc <> 0.

*  Validar si bobina ya expedida
      CALL METHOD zclpp_app_logistica=>validar_bobina_expedida
        EXPORTING
          i_werks   = i_werks
          i_matnr   = i_matnr
          i_cliente = l_kunnr
          i_charg   = o_charg
        IMPORTING
          o_rc      = o_rc.

      IF o_rc <> '00'.
        EXIT.
      ENDIF.

      o_rc = '02'. "02 Bobina no encontrada
      EXIT.

    ENDIF.


    TRY.
        DATA(ls_mchb)  = lt_matnr[ 1 ].

* Material de bobina incorrecto.
        IF i_matnr <> ls_mchb-matnr.
          o_rc = '13'. "Material de bobina incorrecto.
          EXIT.
        ENDIF.

        o_matnr        = ls_mchb-matnr.
        o_brgew        = ls_mchb-clabs.

        IF ls_mchb-lgort <> '1040'.
          o_rc = '09'. " Almacén incorrecto
          EXIT.
        ENDIF.

      CATCH cx_root .
        o_rc = '02'. "02 Bobina no encontrada
        EXIT.
    ENDTRY.


*  Validar que la bobina no se haya leído ya para esta entrega, en cualquier posición.
    CALL METHOD zclpp_app_logistica=>consultar_picking_pos_entrega
      EXPORTING
        i_vbeln          = i_vbeln
      IMPORTING
        ot_lotes_picking = DATA(lt_lotes_pick).

    IF line_exists( lt_lotes_pick[ charg = o_charg ] ).
      o_rc = '14'. "Bobina ya leída.
      EXIT.
    ENDIF.

* Obtener datos de la entrega.
    SELECT SINGLE kunnr , zzsegcal , vstel
      INTO @DATA(ls_likp) "(lv_kunnr, lv_zzsegcal,lv_vstel , lv_kunnr_likp )
    FROM likp
      WHERE vbeln = @i_vbeln.

* Obtener ancho y calidad del material.
    SELECT SINGLE zzancho , matkl
      FROM mara
      INTO @DATA(ls_mara)
      WHERE matnr = @o_matnr.

***************************
* Validaciones 2ª calidad *
***************************

    CASE ls_likp-zzsegcal.
***** "Bobinas A *******
      WHEN space.
        IF l_lobm_udcode NE 'DE       A'.
          o_rc = '06'. "La calidad del lote & y del pedido no coinciden.
          EXIT.
        ENDIF.

        IF l_kunnr NE ls_likp-kunnr.
          o_rc = '07'. "Cliente incorrecto.
          EXIT.
        ENDIF.

****** "CABO A ************
      WHEN '1'.

        IF l_lobm_udcode NE 'DE       A'.
          o_rc = '06'."La calidad del lote & y del pedido no coinciden.
          EXIT.
        ENDIF.

        IF l_kunnr <> g_cliente_propio AND
           l_kunnr <> ls_likp-kunnr.
          o_rc = '07'. "El cliente del lote & y del pedido no coinciden.
          EXIT.
        ENDIF.

****** "Bobinas R *********
      WHEN '2'.
        IF l_lobm_udcode NE 'DE       R'.
          o_rc = '06'."La calidad del lote & y del pedido no coinciden.
          EXIT.
        ENDIF.

        CASE get_tp_cliente( ls_likp-kunnr ).
          WHEN 'H'. "
            IF get_tp_cliente( l_kunnr ) <> 'H' OR l_kunnr = g_cliente_propio.
              o_rc = '07'. "El cliente del lote & y del pedido no coinciden.
              EXIT.
            ENDIF.
          WHEN 'E' OR 'X'.
            IF ls_mara-matkl NE '10199'. "DTM - No valida si es HJNS Paper
              IF l_kunnr <> ls_likp-kunnr.
                o_rc = '07'. "El cliente del lote & y del pedido no coinciden.
                EXIT.
              ENDIF.
            ENDIF.
          WHEN OTHERS.
        ENDCASE.

*       68181 - 03/08/2021 - CMS - Validar bobina R tiene una antigüedad mínima de 15 días
        IF ls_mara-matkl NE '10199'. " Validación para calidad diferente de NSP

          TRY.
              l_fecha_fabric  = l_fecha_fabric + 15.
              IF l_fecha_fabric > sy-datum.
                o_rc = '16'. "Antigüedad de bobina 2ª < 15 días
**                EXIT. DTM
              ENDIF.
            CATCH cx_root .
              o_rc = '11'. "Bobina sin fecha fabricación
              EXIT.
          ENDTRY.

*         Validar REPROCESO.
          IF l_reproceso = '1' OR l_motivo_reproc IS NOT INITIAL.
            o_rc = '17'. "Bobina a reprocesar.
            EXIT.
          ENDIF.

        ENDIF.

***** "Cabos R ********
      WHEN '3'.
        IF l_lobm_udcode NE 'DE       R' AND
           l_lobm_udcode NE 'DE       A'.
          o_rc = '06'."La calidad del lote & y del pedido no coinciden.
          EXIT.
        ENDIF.

        CASE get_tp_cliente( ls_likp-kunnr ).
          WHEN 'H'. "
            o_rc = '07'. "El cliente del lote & y del pedido no coinciden.
            EXIT.
          WHEN 'E'.
            IF l_kunnr <> ls_likp-kunnr AND l_kunnr <> g_cliente_propio.
              o_rc = '07'. "El cliente del lote & y del pedido no coinciden.
              EXIT.
            ENDIF.
          WHEN OTHERS.
        ENDCASE.

    ENDCASE.
*z_cantidad_sin_dec
    DATA: l_diferencia TYPE z_cantidad_sin_dec.
    DATA: l_msg TYPE string.
    DATA(l_dif) = i_cant_entrega  - ( i_cant_picking + o_brgew ).

* Si se superan los kg de la entrega, mostrar ventana de confirmación, para continuar.
    IF l_dif < 0.
      l_diferencia = abs( l_dif ).
      o_diferencia = l_diferencia.
      o_rc = '12'. "Lectura de codbar cancelada por usuario al superar kg.entrega
    ENDIF.

  ENDMETHOD.
