*-------------------------------------------------------------------*
* Panaya code extraction tool                                       *
* Author: Panaya Ltd (www.panaya.com)                               *
* Version 24.06.02 Released on 02/06/2024                           *
* Mini Version 0                                                    *
* ETL Hash  1d0fcbf01ce27b18120264ada13b1560                        *
*-------------------------------------------------------------------*
* Copyright (c) 2023      Panaya Ltd. All rights reserved.          *
*                                                                   *
* Warning: This computer program is  protected by copyright law and *
* international treaties. Unauthorized reproduction or distribution *
* of the program, or any  portion of it, may result in severe civil *
* and criminal  penalties, and  will be  prosecuted  to the maximum *
* extent possible under the law.                                    *
*-------------------------------------------------------------------*
* THIS COMPUTER PROGRAM IS PROVIDED TO YOU STRICTLY ON AN "AS IS"   *
* BASIS. ALL CONDITIONS, REPRESENTATIONS AND WARRANTIES, WHETHER    *
* EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT      *
* LIMITATION, ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR  *
* A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS   *
* IN RELATION TO THIS COMPUTER PROGRAM, ARE HEREBY DISCLAIMED TO    *
* THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW BY PANAYA          *
* (INCLUDING ITS AFFILIATES, DIRECTORS, OFFICERS, EMPLOYEES, AGENTS,*
* CONTRACTORS, SUCCESSORS OR ASSIGNEES) AND ITS LICENSORS. WITHOUT  *
* DEROGATING FROM THE AFORESAID, PANAYA AND ITS LICENSORS MAKE NO   *
* REPRESENTATION, WARRANTY, OR GUARANTY AS TO THE RELIABILITY,      *
* QUALITY, SUITABILITY, AVAILABILITY, ACCURACY OR COMPLETENESS OF   *
* THIS COMPUTER PROGRAM. PANAYA (INCLUDING ITS AFFILIATES,          *
* DIRECTORS, OFFICERS, EMPLOYEES, AGENTS, CONTRACTORS, SUCCESSORS   *
* OR ASSIGNEES) AND ITS LICENSORS DO NOT REPRESENT OR WARRANT THAT  *
* (A) THE USE OF THIS COMPUTER PROGRAM WILL BE TIMELY,              *
* UNINTERRUPTED OR ERROR-FREE OR OPERATE IN COMBINATION WITH ANY    *
* OTHER HARDWARE, SOFTWARE, SYSTEM OR DATA, (B) THIS COMPUTER       *
* PROGRAM WILL MEET YOUR REQUIREMENTS OR EXPECTATIONS, (C) ERRORS   *
* OR DEFECTS WILL BE CORRECTED, OR (D) THIS COMPUTER PROGRAM IS     *
* FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.                      *
*-------------------------------------------------------------------*
* This version of the program is valid for SAP ERP 6.0              *
*-------------------------------------------------------------------*
REPORT ZPANAYA_EXTRACT_PROG_LIB.
CONSTANTS:  REL_SPECIFIC_KEY(2) TYPE C VALUE '2'.

*-------------------------------------------------------------------*
*--------- Panaya Extract Version ------------==========------------*
CONSTANTS: GENERAL_PART_VER(15)  TYPE C VALUE '24.06.02'.
*---------------------------------------------==========------------*
*                                              =========
CONSTANTS: REL_SPECIFIC_VER(15)   TYPE C VALUE '10_2005',
           HEADER_MINI_VERSION(4) TYPE C VALUE
               '0'."#EC NOTEXT
*                                              =========

CONSTANTS: NUM_OBJECT_TYPES       TYPE I VALUE 48.
TYPE-POOLS: ABAP.
DATA: UNICODELG           LIKE X030L-UNICODELG.
DATA: GV_ENDLINE       TYPE ABAP_CHAR1.
TYPES: T_FUNCTION_SOURCE TYPE RSSOURCE.
TYPES: BEGIN OF SM_RSDRI_S_RANGE_RFC,
         CHANM    TYPE CHAR30,
         SIGN     TYPE C,
         COMPOP   TYPE CHAR2,
         LOW(60)  TYPE C,
         HIGH(60) TYPE C,
       END OF SM_RSDRI_S_RANGE_RFC,

       BEGIN OF TS_EXCEL_SCI_HANA,
         OBJECT_TYPE          TYPE STRING,
         OBJECT_NAME          TYPE STRING,
         PACKAGE              TYPE STRING,
         APPL_COMP            TYPE STRING,
         PERSON_RESPONSIBLE   TYPE STRING,
         MESSAGE_TYPE         TYPE STRING,
         ERROR_MESSAGES       TYPE STRING,
         WARNING_MESSAGES     TYPE STRING,
         INFORMATION_MESSAGES TYPE STRING,
         MESSAGE_TEXT         TYPE STRING,
         CHECK_DESCRIPTION    TYPE STRING,
         CHECK_CLASS          TYPE STRING,
         MESSAGE_CODE         TYPE STRING,
         SUB_OBJECT_TYPE      TYPE STRING,
         SUB_OBJECT_NAME      TYPE STRING,
         LINE_NUMBER          TYPE STRING,
         COLUMN_NUMBER        TYPE STRING,
         PARAM1               TYPE STRING,
         PARAM2               TYPE STRING,
         PARAM3               TYPE STRING,
         PARAM4               TYPE STRING,
       END OF TS_EXCEL_SCI_HANA,

       TT_EXCEL_SCI_HANA TYPE TABLE OF TS_EXCEL_SCI_HANA,

       BEGIN OF TS_HANAA_SCI_CHECK,
         OBJTYPE     TYPE SCI_TYPID,
         OBJNAME     TYPE SOBJ_NAME,
         DEVCLASS    TYPE DEVCLASS,
         AUTHOR      TYPE RESPONSIBL,
         KIND        TYPE SCI_ERRTY,
         TEXT        TYPE SCI_MESSAGE,
         DESCRIPTION TYPE SCI_ALVCHKTXT,
         TEST        TYPE SEOCLSNAME,
         CODE        TYPE SCI_ERRC,
         SOBJTYPE    TYPE SCI_TYPID,
         SOBJNAME    TYPE SOBJ_NAME,
         LINE        TYPE SCI_LINE,
         COL         TYPE SCI_CLMN,
         PARAM1      TYPE SYCHAR80,
         PARAM2      TYPE SYCHAR80,
         PARAM3      TYPE SYCHAR20,
         PARAM4      TYPE SYCHAR20,
         ZZVARIANT   TYPE STRING,
         DETAIL      TYPE XSTRING,
         DETAILS_REF TYPE I,
       END OF TS_HANAA_SCI_CHECK,

       TT_HANAA_SCI_CHECK TYPE TABLE OF TS_HANAA_SCI_CHECK,

       BEGIN OF ZSCIS_SOURCE_LINK,
         TEXT    TYPE  CHAR80,
         INCLUDE TYPE  CHAR40,
         LINE    TYPE  INT4,
         PROGRAM TYPE  CHAR40,
       END OF ZSCIS_SOURCE_LINK,

       ZSCIT_SOURCE_LINK TYPE TABLE OF ZSCIS_SOURCE_LINK,

       BEGIN OF TS_HANA_SCI_CHECK_DETAILS,
         DETAILS_REF TYPE  I,
         TEXT        TYPE  CHAR80,
         INCLUDE     TYPE  CHAR40,
         LINE        TYPE  INT4,
         PROGRAM     TYPE  CHAR40,
       END OF TS_HANA_SCI_CHECK_DETAILS,

      TT_HANA_SCI_CHECK_DETAILS TYPE TABLE OF TS_HANA_SCI_CHECK_DETAILS,

       TT_SCI_CHECKVARIANT_NAMES TYPE TABLE OF  SCICHKV_HD-CHECKVNAME.

  TYPES: BEGIN OF ST_ATC_RESULT,
           DISPLAY_ID       TYPE GUID,
           TITLE            TYPE TEXT70,
           COUNT_PRIO1      TYPE INT4,
           COUNT_PRIO2      TYPE INT4,
           COUNT_PRIO3      TYPE INT4,
           COUNT_PRIO4      TYPE INT4,
           COUNT_PLNERR     TYPE INT4,
           SCHEDULED_ON_TS  TYPE TIMESTAMP,
           IS_MASS_TEST     TYPE CHAR1,
           IS_CENTRAL_RUN   TYPE CHAR1,
           CHK_PROFILE_NAME TYPE CHAR30,
           RUN_SERIES_NAME  TYPE CHAR16,
           SCHEDULED_SYS    TYPE SYSYSID,
         END OF ST_ATC_RESULT.

  TYPES: BEGIN OF ST_ATC_RESULT_DIS,
           DISPLAY_ID       TYPE GUID,
           TITLE            TYPE TEXT70,
           SCHEDULED_ON_TS  TYPE TIMESTAMP,
           CHK_PROFILE_NAME TYPE CHAR30,
           RUN_SERIES_NAME  TYPE CHAR16,
           SCHEDULED_SYS    TYPE SYSYSID,
         END OF ST_ATC_RESULT_DIS.

DATA: BEGIN OF LT_PROG_EXP.
    INCLUDE STRUCTURE TRDIR.
DATA: ADDED_BY_SMODILOG TYPE C,
      END OF LT_PROG_EXP.

TYPES: LT_PROG_TYPE LIKE LT_PROG_EXP OCCURS 0.

DATA: BEGIN OF STRUCTURE_FIELDS_TEMP.
    INCLUDE STRUCTURE DFIES.
DATA: ADMINFIELD TYPE ADMINFIELD,
      END OF STRUCTURE_FIELDS_TEMP.

DATA: BEGIN OF TABLE_TYPE_TEMP.
    INCLUDE STRUCTURE DD40L.
DATA: INTTYPE TYPE INTTYPE,
      INTLEN  TYPE INTLEN,
      END OF TABLE_TYPE_TEMP.

TYPES: STRUCTURE_FIELDS_TYPE     LIKE STRUCTURE_FIELDS_TEMP,
       STRUCTURE_FIELDS_TAB_TYPE TYPE TABLE OF STRUCTURE_FIELDS_TYPE,
       TABLE_TYPE_TYPE           LIKE TABLE_TYPE_TEMP,
       TABLE_TYPE_TAB_TYPE       TYPE TABLE OF TABLE_TYPE_TYPE.

* solman types
* Systems / SAP systems / SAP systems clients
TYPES: BEGIN OF SMSY_SYSTEM,
         SYSTEMNAME       TYPE  CHAR8, "smsy_name
         KONZS            TYPE KONZS,
         VERSION          TYPE CHAR10, "smsy_version,
         SYSTEMTYPE       TYPE CHAR10, "smsy_systype,
         LSYSTEMNAME      TYPE CHAR80, "smsy_lname,
         DESCR            TYPE CHAR80, "smsy_sysdescr,
         FLGSAP           TYPE FLAG, "smsy_flg_sap,
         ARCHITECTURE     TYPE CHAR15, "smsy_arch,
         URL              TYPE URL,
         LCR_NAME         TYPE CHAR80, "smsy_lcrsysname,
         PRODVERS         TYPE CHAR20, "smsyprodvers,
         INSTANCE         TYPE CHAR20, "smsyinstance,
         PLANNED          TYPE CHAR1, "smsy_flg_planned,
         PRODUCTIVE       TYPE CHAR1, "smsy_flg_produc,
         SYDATUM          TYPE SYDATUM,
         SYUZEIT          TYPE SYUZEIT,
         SYUNAME          TYPE SYUNAME,
         TRCODE           TYPE TCODE,
         GENERATOR        TYPE CHAR10, "smsy_flag,
         AKT_VERSION      TYPE CHAR10, "smsy_version,
         ENTITY_KEY       TYPE CHAR32, "smsy_entity_guid,
         SLDHOST          TYPE CHAR64, "sld_hostname,
         SLDPORT          TYPE NUMC5, "sld_portnumber,
         SLDNAMESPACE     TYPE CHAR40, "smsy_sld_nspace,
         SLD_NAME         TYPE CHAR255, "sldname,
         NO_ABAP_INCLUDED TYPE  CHAR1, "smsy_yesno,
         BU_PARTNER       TYPE  CHAR10, "aicustomer,
       END OF SMSY_SYSTEM,
       SMSY_SYSTEM_T TYPE STANDARD TABLE OF SMSY_SYSTEM.
TYPES: BEGIN OF SMSY_SYSTEM_SAP,
         SYSTEMNAME       TYPE  CHAR8, "smsy_name
         KONZS            TYPE KONZS,
         VERSION          TYPE CHAR10, "smsy_version,
         SYSTEMTYPE       TYPE CHAR10, "smsy_systype,
         ARCHITECTURE     TYPE CHAR15, "smsy_arch,
         SYSNR            TYPE CHAR2, "systnr,
         MESSSERVER       TYPE CHAR255, "messserver,
         INST_NUMBER      TYPE CHAR10, "smsy_inst_nr,
         DBSYS            TYPE SYDBSYS,
         SYDATUM          TYPE SYDATUM,
         SYUZEIT          TYPE SYUZEIT,
         SYUNAME          TYPE SYUNAME,
         TRCODE           TYPE TCODE,
         GENERATOR        TYPE CHAR10, "smsy_flag,
         AKT_VERSION      TYPE CHAR10, "smsy_version,
         TMSDOMNAM        TYPE TMSDOMNAM,
         DISPATCHER       TYPE CHAR255, "smsy_dispatcher,
         PORTNR           TYPE NUMC5, "smsy_portnr,
         TEMP_INACTIVE    TYPE  CHAR1, "smsy_flg_inactiv,
         SLDHOST          TYPE CHAR64, "sld_hostname,
         SLDPORT          TYPE NUMC5, "sld_portnumber,
         SLDNAMESPACE     TYPE CHAR40, "smsy_sld_nspace,
         SLD_NAME         TYPE CHAR255, "sldname,
         TMS_VIRTUAL      TYPE CHAR1, "smsy_flg_virtual,
         LICENSE_EXP      TYPE DATUM, "smsy_lic_date,
         PROTOCOL         TYPE CHAR10, "smsy_http_prot,
         NO_ABAP_INCLUDED TYPE FLAG, "smsy_yesno,
         MSG_SERVER_ID    TYPE CUSTKEY_T,
       END OF SMSY_SYSTEM_SAP,
       SMSY_SYSTEM_SAP_T TYPE STANDARD TABLE OF SMSY_SYSTEM_SAP.
TYPES: BEGIN OF SMSY_SYST_CLIENT,
         SYSTEMNAME  TYPE  CHAR8, "smsy_name
         KONZS       TYPE KONZS,
         MANDT       TYPE CHAR3, "smsy_mandt,
         VERSION     TYPE CHAR10, "smsy_version,
         SYSTEMTYPE  TYPE CHAR10, "smsy_systype,
         MTEXT       TYPE MTEXT_D,
         ORT01       TYPE ORT01,
         MWAER       TYPE MWAER,
         ADRNR       TYPE CHAR10,
         CCCATEGORY  TYPE CCCATEGORY,
         CCCORACTIV  TYPE CCCORACTIV,
         CCNOCLIIND  TYPE CCNOCLIIND,
         CCCOPYLOCK  TYPE CCCOPYLOCK,
         CCNOCASCAD  TYPE CCNOCASCAD,
         CCSOFTLOCK  TYPE CCSOFTLOCK,
         CCORIGCONT  TYPE CCORIGCONT,
         CCIMAILDIS  TYPE CCIMAILDIS,
         CCTEMPLOCK  TYPE CCTEMPLOCK,
         CHANGEUSER  TYPE AS4USER,
         CHANGEDATE  TYPE AS4DATE,
         LOGSYS      TYPE LOGSYS,
         SYDATUM     TYPE SYDATUM,
         SYUZEIT     TYPE SYUZEIT,
         SYUNAME     TYPE SYUNAME,
         TRCODE      TYPE TCODE,
         GENERATOR   TYPE CHAR10, "smsy_flag,
         AKT_VERSION TYPE CHAR10, "smsy_version,
         BU_PARTNER  TYPE BU_PARTNER,
       END OF SMSY_SYST_CLIENT,
       SMSY_SYST_CLIENT_T TYPE STANDARD TABLE OF SMSY_SYST_CLIENT.
TYPES: BEGIN OF SMSY_SYS_RELINST,
         SYSTEMNAME   TYPE  CHAR8, "smsy_name
         KONZS        TYPE KONZS,
         VERSION      TYPE CHAR10, "smsy_version,
         PRODUCT      TYPE CHAR20, "smsyproduct,
         INSTANCE     TYPE CHAR20, "smsyinstance,
         FLG_RELEVANT TYPE CHAR1, "smsy_flg_relevant_inst,
         SYDATUM      TYPE SYDATUM,
         SYUZEIT      TYPE SYUZEIT,
         SYUNAME      TYPE SYUNAME,
         TRCODE       TYPE TCODE,
         GENERATOR    TYPE CHAR10, "smsy_flag,
         AKT_VERSION  TYPE CHAR10, "smsy_version,
         ENTITY_KEY   TYPE CHAR32, "smsy_entity_guid,
         SYSTEM_ID    TYPE CHAR8, "smsy_subsys_name,
         SYSTEMTYPE   TYPE CHAR8, "smsy_systype,
         ADAPTIVEFLAG TYPE CHAR1, "smsy_adaptive,
         REFINSTANCE  TYPE CHAR20, "smsyinstance,
       END OF SMSY_SYS_RELINST,
       SMSY_SYS_RELINST_T TYPE STANDARD TABLE OF SMSY_SYS_RELINST.
* System products instances
TYPES: BEGIN OF SMSY_MAIN_INST,
         PRODUCT        TYPE CHAR20, "smsyproduct,
         INSTANCE       TYPE CHAR20, "smsyinstance,
         TEXT           TYPE CHAR30, "smsyinststxt,
         IMPL_RELEVANT  TYPE CHAR1, "smsy_impl_rel,
         MONIT_RELEVANT TYPE CHAR1, "smsy_monit_rel,
         DB_INSTANCE    TYPE CHAR1, "smsy_isdbinstance,
         TECH_INST      TYPE CHAR1, "smsy_techinst,
         LUSER          TYPE SYUNAME,
         LDATE          TYPE SYDATUM,
         LTIME          TYPE SYUZEIT,
         PROD_ABAB_INST TYPE FLAG, "smsy_yesno,
       END OF SMSY_MAIN_INST,
       SMSY_MAIN_INST_T TYPE STANDARD TABLE OF SMSY_MAIN_INST.
TYPES: BEGIN OF SMSY_MAIN_INST_SYST,
         SYSTEMNAME     TYPE  CHAR8, "smsy_name
         PRODUCT        TYPE CHAR20, "smsyproduct,
         INSTANCE       TYPE CHAR20, "smsyinstance,
         TEXT           TYPE CHAR30, "smsyinststxt,
         IMPL_RELEVANT  TYPE CHAR1, "smsy_impl_rel,
         MONIT_RELEVANT TYPE CHAR1, "smsy_monit_rel,
         DB_INSTANCE    TYPE CHAR1, "smsy_isdbinstance,
         TECH_INST      TYPE CHAR1, "smsy_techinst,
         LUSER          TYPE SYUNAME,
         LDATE          TYPE SYDATUM,
         LTIME          TYPE SYUZEIT,
         PROD_ABAB_INST TYPE FLAG, "smsy_yesno,
       END OF SMSY_MAIN_INST_SYST,
       SMSY_MAIN_INST_SYST_T TYPE STANDARD TABLE OF
SMSY_MAIN_INST_SYST .
* Components
TYPES: BEGIN OF SMSYPROCOM,
         SYSNAM     TYPE CHAR20,
         COMPONENT  TYPE CHAR30,
         RELEASE    TYPE CHAR10,
         PATCHLEVEL TYPE CHAR10,
         PATCH      TYPE CHAR20,
         COMP_TYPE  TYPE CHAR1,
         DESC_TEXT  TYPE CHAR80,
         LEAD_COMP  TYPE FLAG,
       END OF  SMSYPROCOM,
       SMSYPROCOM_T TYPE STANDARD TABLE OF SMSYPROCOM.
* Patches for systems
TYPES : BEGIN OF TY_SYST_PAT03,
          PATCH      TYPE PATCH,
          SHORT_TEXT TYPE PATCHTXT,
          STATUS     TYPE PATCHSTAT,
          DELIV_DATE TYPE PATDELDATE,
          DELIV_TIME TYPE PATDELTIME,
          RESPONSIBL TYPE PATCH_USER,
          IMPLE_DATE TYPE PATIMPDATE,
          IMPLE_TIME TYPE PATIMPTIME,
          L_IMPL_REL TYPE SYSAPRL,
          CONFLICTS  TYPE  PAT_CONFL,
          CONFIRMED  TYPE  CONFIRMED,
          BACKUP     TYPE TRKORR,
          FROM_REL   TYPE SYSAPRL,
          TO_REL     TYPE SYSAPRL,
          OS         TYPE SYOPSYS,
          DB         TYPE SYDBSYS,
          PATCH_TYPE TYPE PATCH_TYPE,
          ANCESTOR   TYPE PAT_ANCEST,
          STRICT_SEQ TYPE PAT_STRICT,
          NO_GEN     TYPE PAT_NOGEN,
          SPAMFIX    TYPE  PAT_SPAMFX,
          ADDON_ID   TYPE ADDONID,
          ADDON_REL  TYPE  ADDONRL,
          IGN_CONFLI TYPE IGN_CONFLI,
          AP_ANCEST  TYPE AP_ANCEST,
          EPSFILSIZ  TYPE  PATFILSIZ,
          HI_ANCEST  TYPE  PAT_HIAN,
          COMP_REL   TYPE PAT_COREL,
          COMPONENT  TYPE  PAT_COMP,
        END OF TY_SYST_PAT03,
        TY_SYST_PAT03_T TYPE STANDARD TABLE OF TY_SYST_PAT03.

TYPES : BEGIN OF TY_SYST_PAT03_OUT,
          SYSTEMNAME TYPE  CHAR8, "SMSY_NAME,
          PATCH      TYPE PATCH,
          SHORT_TEXT TYPE  PATCHTXT,
          STATUS     TYPE  PATCHSTAT,
          DELIV_DATE TYPE  PATDELDATE,
          DELIV_TIME TYPE  PATDELTIME,
          RESPONSIBL TYPE  PATCH_USER,
          IMPLE_DATE TYPE  PATIMPDATE,
          IMPLE_TIME TYPE  PATIMPTIME,
          L_IMPL_REL TYPE  SYSAPRL,
          CONFLICTS  TYPE  PAT_CONFL,
          CONFIRMED  TYPE  CONFIRMED,
          BACKUP     TYPE  TRKORR,
          FROM_REL   TYPE  SYSAPRL,
          TO_REL     TYPE  SYSAPRL,
          OS         TYPE  SYOPSYS,
          DB         TYPE  SYDBSYS,
          PATCH_TYPE TYPE  PATCH_TYPE,
          ANCESTOR   TYPE  PAT_ANCEST,
          STRICT_SEQ TYPE  PAT_STRICT,
          NO_GEN     TYPE  PAT_NOGEN,
          SPAMFIX    TYPE  PAT_SPAMFX,
          ADDON_ID   TYPE  ADDONID,
          ADDON_REL  TYPE  ADDONRL,
          IGN_CONFLI TYPE  IGN_CONFLI,
          AP_ANCEST  TYPE AP_ANCEST,
          EPSFILSIZ  TYPE  PATFILSIZ,
          HI_ANCEST  TYPE  PAT_HIAN,
          COMP_REL   TYPE  PAT_COREL,
          COMPONENT  TYPE  PAT_COMP,
        END OF TY_SYST_PAT03_OUT,
        TY_SYST_PAT03_OUT_T TYPE STANDARD TABLE OF TY_SYST_PAT03_OUT.

* OSS
TYPES : BEGIN OF AISYSNR_BUFFER_STRUCTURE,
          SID           TYPE CHAR3, "aisid,
          INSNR         TYPE CHAR10, "smsy_inst_nr,
          SYNAM         TYPE TEXT40, "aisynam,
          SYTYP         TYPE CHAR13, "aib0sdsytyp,
          PRODVERS      TYPE CHAR20, "smsyprodvers,
          DELETED       TYPE FLAG,
          MESSAGESERVER TYPE  CHAR20, "smsy_hostname,
        END OF AISYSNR_BUFFER_STRUCTURE.
TYPES : BEGIN OF AISYSNR_BUFFER,
          SYSNR         TYPE CHAR18, "aib0sdsysnr,
          KONZS         TYPE CHAR10, "obsolete
          SID           TYPE CHAR3, "aisid,
          INSNR         TYPE CHAR10, "smsy_inst_nr,
          SYNAM         TYPE TEXT40, "aisynam,
          SYTYP         TYPE CHAR13, "aib0sdsytyp,
          PRODVERS      TYPE CHAR20, "smsyprodvers,
          DELETED       TYPE FLAG,
          MESSAGESERVER TYPE  CHAR20, "smsy_hostname,
        END OF AISYSNR_BUFFER,
        AISYSNR_BUFFER_T TYPE STANDARD TABLE OF AISYSNR_BUFFER.
* Products / Product version per system
TYPES : BEGIN OF SMSY_SYST_PRODVR,
          SYSTEMNAME  TYPE CHAR8, "SMSY_NAME,
          PRODVERS    TYPE CHAR20, "SMSYPRODVERS,
          KONZS       TYPE KONZS,
          VERSION     TYPE CHAR10, "SMSY_VERSION,
          SYDATUM     TYPE SYDATUM,
          SYUZEIT     TYPE SYUZEIT,
          SYUNAME     TYPE SYUNAME,
          TRCODE      TYPE TCODE,
          GENERATOR   TYPE CHAR10, "SMSY_FLAG,
          AKT_VERSION TYPE CHAR10, "SMSY_VERSION,
          INSTANCE    TYPE CHAR20, "SMSYINSTANCE,
          FLG_USED    TYPE CHAR1, "SMSY_FLG_ACTIVE,
          MANUAL_SET  TYPE CHAR1, "SMSY_PV_MANUAL_SET,
        END OF SMSY_SYST_PRODVR,
        SMSY_SYST_PRODVR_T TYPE STANDARD TABLE OF SMSY_SYST_PRODVR.
TYPES: BEGIN OF SMSY_PRODUCT,
         PRODUCT         TYPE CHAR20, "smsyproduct,
         PRODUCTTXT      TYPE CHAR30, "smsy_prodstxt,
         NON_SAP_PRODUCT TYPE CHAR1, "smsy_yesno,
         INVISIBLE       TYPE CHAR1, "smsy_yesno,
         LUSER           TYPE SYUNAME,
         LDATE           TYPE SYDATUM,
         LTIME           TYPE SYUZEIT,
         FL_ADDON        TYPE CHAR1, "aisolar_bormflpaddon,
         MANUFACTURER    TYPE CHAR32, "smsy_manufacturer,
       END OF SMSY_PRODUCT,
       SMSY_PRODUCT_T TYPE STANDARD TABLE OF SMSY_PRODUCT.
TYPES: BEGIN OF SMSY_PROD_VERS,
         PRODUCTVERSION TYPE CHAR20, "smsyprodvers,
         PRODUCT        TYPE CHAR20, "smsyproduct,
         PREPRODVERS    TYPE CHAR20, "smsyprodvers,
         PRODVERSTXT    TYPE CHAR30, "smsy_prodvrsstxt,
         FL_ADDON       TYPE CHAR1, "aisolar_bormflpvaddon,
       END OF SMSY_PROD_VERS,
       SMSY_PROD_VERS_T TYPE STANDARD TABLE OF SMSY_PROD_VERS.
TYPES: BEGIN OF SM_SYSTEM_PRODUCTS,
         SYSTEMNAME  TYPE CHAR8, "SMSY_NAME
         PRODUCT     TYPE CHAR20, "SMSYPRODUCT
         PRODUCTTXT  TYPE CHAR30, "SMSY_PRODSTXT
         PRODVERS    TYPE CHAR20, "SMSYPRODVERS
         PRODVERSTXT TYPE CHAR30, "SMSY_PRODVRSSTXT
       END OF SM_SYSTEM_PRODUCTS,
       SM_SYSTEM_PRODUCTS_T TYPE STANDARD TABLE OF SM_SYSTEM_PRODUCTS.
TYPES: BEGIN OF SM_PROJECT_TYPE,
         PROJECT_ID TYPE CHAR10,
         CLASS      TYPE CHAR6,
         BEGIN_DATE LIKE SY-DATUM,
         END_DATE   LIKE SY-DATUM,
         GUID       TYPE HIER_GUID,
       END OF SM_PROJECT_TYPE.
TYPES: BEGIN OF SM_PROJECT_TREE,
         TREE_ID   TYPE CHAR32,
         EXTENSION TYPE CHAR15,
         NODE_ID   TYPE CHAR32,
         EXT_KEY   TYPE CHAR12,
       END OF SM_PROJECT_TREE.
TYPES: BEGIN OF SM_PROJECT_TREE_NODE,
         NODE_ID    TYPE CHAR32, "HIER_GUID
         NODE_TYPE  TYPE CHAR4, "HIER_NODET
         NODE_LEVEL TYPE NUMC4, "SEU_LEVEL
         PARENT_ID  TYPE CHAR32, "HIER_GUID
         TREE_ID    TYPE CHAR32, "HIER_GUID
         REFNODE_ID TYPE CHAR32, "HIER_GUID
       END OF SM_PROJECT_TREE_NODE.
TYPES: BEGIN OF SM_AGS_TBOM_HEAD,
         GUID        TYPE CHAR32, "AGS_TBOM_GUID
         DESCRIPTION TYPE CHAR255, "AGS_TBOM_DESCRIPTION
         DYNAMIC     TYPE CHAR1, "AGS_TBOM_TYPE_DYNAMIC
         E2ETRACE    TYPE CHAR1, "AGS_TBOM_TYPE_E2ETRACE
         STATIC      TYPE CHAR1, "AGS_TBOM_TYPE_STATIC
         STATUS      TYPE CHAR1, "AGS_TBOM_STATUS
         ORIG_SYS    TYPE CHAR8, "SYSYSID
         ORIG_CLIENT TYPE CHAR3, "TRCLIENT
         CREATEDBY   TYPE CHAR12, "HIER_FUSER
         CREATEDATE  TYPE SYDATUM, "HIER_FDATE
         CREATETIME  TYPE SYUZEIT, "HIER_FTIME
         UPDATEDBY   TYPE CHAR12, "HIER_LUSER
         UPDATEDATE  TYPE SYDATUM, "HIER_LDATE
         UPDATETIME  TYPE SYUZEIT, "HIER_LTIME
       END OF SM_AGS_TBOM_HEAD,
       SM_AGS_TBOM_HEAD_TAB TYPE TABLE OF SM_AGS_TBOM_HEAD.

TYPES: BEGIN OF SM_AGS_TBOM_BASE,
         GUID              TYPE CHAR32,  "AGS_TBOM_GUID
         AS4POS            TYPE DDPOSITION,
         PGMID             TYPE CHAR4,  "PGMID
         OBJECT            TYPE CHAR4, "TROBJTYPE
         OBJ_NAME          TYPE CHAR120, "TROBJ_NAME
         OBJ_SOURCE        TYPE CHAR1, "FLAG
         OBJ_CLASS_TYPE    TYPE CHAR4, "AGS_TBOM_ITEM_CLASS_TYPE
         OBJ_CLASS_VALUE   TYPE CHAR8, "AGS_TBOM_ITEM_CLASS_VALUE
         DEVCLASS          TYPE CHAR30, "DEVCLASS
         DLVUNIT           TYPE CHAR30, "DLVUNIT
         PARENT_PGMID      TYPE CHAR4, "PGMID
         PARENT_OBJECT     TYPE CHAR4, "TROBJTYPE
         PARENT_OBJ_NAME   TYPE CHAR120, "TROBJ_NAME
         SUB_OBJ_NAME(130) TYPE C, "AGS_TROBJNAME
         TAB_HAS_KEY       TYPE CHAR1, "AGS_TBOM_TAB_HAS
       END OF SM_AGS_TBOM_BASE,
       SM_AGS_TBOM_BASE_TAB TYPE TABLE OF SM_AGS_TBOM_BASE,

       BEGIN OF SM_DFURLS,
         NODE_ID  TYPE CHAR32, "HIER_GUID
         URL_TYPE TYPE CHAR20, "URLTYPE
         URL      TYPE CHAR255, "AGR_URL
         PRED_ID  TYPE CHAR32, "HIER_GUID
       END OF SM_DFURLS.

TYPES: BEGIN OF UVERS_HIST_REC_TYPE,
         FINDATE    TYPE SYDATUM,
         FINTIME    TYPE SYUZEIT,
         COMPONENT  TYPE CHAR30, "DLVUNIT
         NEWRELEASE TYPE CHAR10, "SAPRELEASE
         STARTDATE  TYPE SYDATUM,
         STARTTIME  TYPE SYUZEIT,
         ENDDATE    TYPE SYDATUM,
         ENDTIME    TYPE SYUZEIT,
         PUTSTATUS  TYPE CHAR1, "PUTSTATUS
         PUTTYPE    TYPE CHAR1, "PUTTYPE
         PUTMASTER  TYPE CHAR10,                           "PUTMODE10

         OLDRELEASE TYPE CHAR10, "SAPRELEASE
         MODEA01    TYPE CHAR1,                            "PUTMODE01

         MODEB01    TYPE CHAR1,                            "PUTMODE01

         MODEA10    TYPE CHAR10,                           "PUTMODE10
       END OF UVERS_HIST_REC_TYPE.

* BW extraction data types
TYPES: BEGIN OF TY_PROCESSLOG,
         TYPE         TYPE CHAR10, "rspc_type,
         EVENT_START  TYPE BTCEVENTID,
         EVENTP_START TYPE BTCEVTPARM,
         VARIANTE     TYPE CHAR30, "rspcprocesslog-variante,
         BATCHDATE    TYPE SYDATS, "rspcprocesslog-batchdate,
         BATCHTIME    TYPE SYTIME, "rspcprocesslog-batchtime,
         INSTANCE     TYPE CHAR30, "rspcprocesslog-instance,
       END OF TY_PROCESSLOG.

TYPES: BEGIN OF TY_RSLDPIO,
         LOGDPID    TYPE CHAR30, "rsldpio-logdpid,
         LOGSYS     TYPE LOGSYS, "rsldpio-logsys,
         OLTPSOURCE TYPE CHAR30, "rsldpio-oltpsource,
       END OF TY_RSLDPIO.

TYPES: BEGIN OF TY_RSISOSMAP,
         ISOURCE    TYPE CHAR30, "rsisosmap-isource,
         OLTPSOURCE TYPE CHAR30, "rsisosmap-oltpsource,
       END OF TY_RSISOSMAP.

TYPES: BEGIN OF TY_RSTRAN,
         TRANID     TYPE CHAR32,    "rstran-tranid,
         SOURCETYPE TYPE CHAR4,     "rstran-sourcetype,
         SOURCENAME TYPE SOBJ_NAME, "rstran-sourcename,
         TARGETTYPE TYPE CHAR4,     "rstran-targettype,
         TARGETNAME TYPE SOBJ_NAME, "rstran-targetname,
       END OF TY_RSTRAN.

TYPES: BEGIN OF TY_RSUPDINFO,
         UPDID    TYPE CHAR25, "rsupdid,
         INFOCUBE TYPE CHAR30, "rsupdinfo-infocube,
         ISOURCE  TYPE CHAR30, "rsupdinfo-isource,
       END OF TY_RSUPDINFO.

TYPES: BEGIN OF TY_RSOLTPSOURCE,
         OLTPSOURCE TYPE CHAR30, "rsoltpsource-oltpsource,
       END OF TY_RSOLTPSOURCE.

TYPES: BEGIN OF TY_RSDS,
         DATASOURCE TYPE CHAR30, "rsds-datasource,
       END OF TY_RSDS.

TYPES: BEGIN OF TY_RSDCUBE,
         INFOAREA TYPE CHAR30,    "rsdcube-infoarea,
         INFOCUBE TYPE CHAR30,    "rsdcube-infocube,
         TSTPNM   TYPE XUBNAME,   "rsdcube-tstpnm,
         TIMESTMP TYPE CHAR15,    "rstimestmp,"rsdcube-timestmp,
       END OF TY_RSDCUBE.

TYPES: BEGIN OF TY_RSDCUBE_TXT,
         LANGU    TYPE LANGU,
         INFOCUBE TYPE CHAR30,  "rsdcubet-infocube,
         TXTLG    TYPE TEXT60,
       END OF TY_RSDCUBE_TXT.

TYPES: BEGIN OF TY_RSDIOBJ,
         IOBJNM   TYPE CHAR30,  "rsdiobj-iobjnm,
         TSTPNM   TYPE XUBNAME,
         TIMESTMP TYPE CHAR15,  "rstimestmp,
       END OF TY_RSDIOBJ.

TYPES: BEGIN OF TY_RSDIOBJ_TXT,
         LANGU  TYPE LANGU,
         IOBJNM TYPE CHAR30,
         TXTLG  TYPE TEXT60,
       END OF TY_RSDIOBJ_TXT.

TYPES: BEGIN OF TY_RSDODSO,
         ODSOBJECT TYPE CHAR30, "rsdodso-odsobject,
         ODSOTYPE  TYPE CHAR1,  "rsdodso-odsotype,
         INFOAREA  TYPE CHAR30, "rsdodso-infoarea,
         TSTPNM    TYPE XUBNAME,
         TIMESTMP  TYPE CHAR15, "rstimestmp,
       END OF TY_RSDODSO.

TYPES: BEGIN OF TY_RSDODSO_TXT,
         ODSOBJECT TYPE CHAR30, "rsdodsot-odsobject,
         LANGU     TYPE LANGU,
         TXTLG     TYPE TEXT60,
       END OF TY_RSDODSO_TXT.

TYPES: BEGIN OF TY_RSPCCHAINATTR,
         CHAIN_ID       TYPE CHAR25,    "rspcchainattr-chain_id,
         APPLNM         TYPE CHAR30,    "rspcchainattr-applnm,
         OBJNM_OWNED_BY TYPE SOBJ_NAME, "rspcchainattr-objnm_owned_by,
       END OF TY_RSPCCHAINATTR.

TYPES: BEGIN OF TY_RSPCCHAINT,
         LANGU    TYPE  SPRAS,
         CHAIN_ID TYPE  CHAR25,
         TXTLG    TYPE  TEXT60,
       END OF TY_RSPCCHAINT.

TYPES: BEGIN OF TY_RSBKDTP,
         DTP      TYPE CHAR30, "rsbkdtp-dtp,
         SRC      TYPE CHAR45, "rsbkdtp-src,
         SRCTP    TYPE CHAR6,  "rsbkdtp-srctp,
         SRCTLOGO TYPE CHAR4,  "rsbkdtp-srctlogo,
         TGT      TYPE CHAR45, "rsbkdtp-tgt,
         TGTTP    TYPE CHAR6,  "rsbkdtp-tgttp,
         TGTTLOGO TYPE CHAR4,  " rsbkdtp-src,
       END OF TY_RSBKDTP.

TYPES: BEGIN OF TY_RSBKDTP_TXT,
         LANGU TYPE LANGU,
         DTP   TYPE CHAR30,     "rsbkdtpt-dtp,
         TXTLG TYPE TEXT60,     "rsbkdtpt-txtlg,
       END OF TY_RSBKDTP_TXT.

TYPES: BEGIN OF TY_AREA,
         INFOAREA   TYPE CHAR30,   "rsdarea-infoarea,
         OWNER      TYPE XUBNAME,  "rsdarea-owner,
         INFOAREA_P TYPE CHAR30,   "rsdarea-infoarea_p ,
         INFOAREA_C TYPE CHAR30,   "rsdarea-infoarea_c,
         INFOAREA_N TYPE CHAR30,   "rsdarea-infoarea_n,
         TSTPNM     TYPE XUBNAME,  "rsdarea-tstpnm,
         TIMESTMP   TYPE CHAR15,
       END OF TY_AREA.

TYPES: BEGIN OF TY_AREA_TXT,
         LANGU    TYPE LANGU,
         INFOAREA TYPE CHAR30,      "rsdareat-infoarea,
         TXTLG    TYPE TEXT60,      "rsdareat-txtlg,
       END OF TY_AREA_TXT.

TYPES: BEGIN OF TY_RSPCCHAIN,
         CHAIN_ID       TYPE  CHAR25,
         OBJVERS        TYPE  CHAR1,
         TYPE           TYPE  CHAR10,
         VARIANTE       TYPE  CHAR30,
         LNR            TYPE  CHAR10,
         EVENT_START    TYPE  CHAR32,
         EVENTP_START   TYPE  CHAR64,
         EVENTNO_START  TYPE  CHAR2,
         BACKLINK_START TYPE  CHAR1,
         EVENT_GREEN    TYPE  CHAR32,
         EVENTP_GREEN   TYPE  CHAR64,
         BACKLINK_GREEN TYPE  CHAR1,
         EVENT_RED      TYPE  CHAR32,
         EVENTP_RED     TYPE  CHAR64,
         BACKLINK_RED   TYPE  CHAR1,
         GREEN_EQ_RED   TYPE  CHAR1,
         WAIT           TYPE  CHAR10,
         MAIL_AT_RED    TYPE  CHAR30,
         MAIL_AT_GREEN  TYPE  CHAR30,
       END OF TY_RSPCCHAIN.

TYPES: BEGIN OF TY_RSPCCHAIN_OUT,
         CHAIN_ID        TYPE  CHAR25,
         OBJVERS         TYPE  CHAR1,
         TYPE            TYPE  CHAR10,
         VARIANTE        TYPE  CHAR30,
         LNR             TYPE  CHAR10,
         EVENT_START     TYPE  CHAR32,
         EVENTP_START    TYPE  CHAR64,
         EVENTNO_START   TYPE  CHAR2,
         BACKLINK_START  TYPE  CHAR1,
         EVENT_GREEN     TYPE  CHAR32,
         EVENTP_GREEN    TYPE  CHAR64,
         BACKLINK_GREEN  TYPE  CHAR1,
         EVENT_RED       TYPE  CHAR32,
         EVENTP_RED      TYPE  CHAR64,
         BACKLINK_RED    TYPE  CHAR1,
         GREEN_EQ_RED    TYPE  CHAR1,
         WAIT            TYPE  CHAR10,
         MAIL_AT_RED     TYPE  CHAR30,
         MAIL_AT_GREEN   TYPE  CHAR30,
         FIRST_USED_DATE TYPE  CHAR8,
         FIRST_USED_TIME TYPE  CHAR6,
         LAST_USED_DATE  TYPE  CHAR8,
         LAST_USED_TIME  TYPE  CHAR6,
         COUNT(10)       TYPE  N,
       END OF TY_RSPCCHAIN_OUT.

TYPES: BEGIN OF TY_TDEVC,
         DEVCLASS         TYPE   DEVCLASS,                 "  CHAR 30
         INTSYS           TYPE   INTSYS_OLD,               "  CHAR 10
         CONSYS           TYPE   CONSYS_OLD,               "  CHAR 10
         CTEXT            TYPE   AS4TEXTOLD,               "  CHAR  60
         KORRFLAG         TYPE   KORRFLAG,                 "  CHAR 1
         AS4USER          TYPE   AUTHOR3,                  "  CHAR 12
         PDEVCLASS        TYPE   DEVLAYER,                 "  CHAR 4
         DLVUNIT          TYPE   DLVUNIT,                  "  CHAR 30
         COMPONENT        TYPE   UFFCTR,                   "  CHAR 20
         NAMESPACE        TYPE   NAMESPACE,                "  CHAR 10
         TPCLASS          TYPE   TPCLASS,                  "  CHAR 1
         SHIPMENT         TYPE   SHIPMENT,                 "  CHAR 8
         PARENTCL         TYPE   PARENTCL,                 "  CHAR 30
         APPLICAT         TYPE   TRDEVCAPPL,               "  CHAR 2
         ERRSEVRTY        TYPE   ERRSEVRTY,                "  CHAR 4
         PERMINHER        TYPE   PERMINHER,                "  CHAR 1
         INTFPREFX        TYPE   INTFPREFX,                "  CHAR 6
         PACKTYPE         TYPE   PACKTYPE,                 "  CHAR 1
         RESTRICTED       TYPE   PACKRESTR,                "  CHAR 1
         MAINPACK         TYPE   MAINPACK,                 "  CHAR 1
         CREATED_BY       TYPE   CNAM,                     "  CHAR 12
         CREATED_ON       TYPE   RDIR_CDATE,               "  DATS 8
         CHANGED_BY       TYPE   UNAM,                     "  CHAR 12
         CHANGED_ON       TYPE   RDIR_UDATE,               "  DATS 8
         SRV_CHECK        TYPE   CHAR1,                    "  CHAR 1
         CLI_CHECK        TYPE   CHAR1,                    "  CHAR 1
         EXT_ALIAS        TYPE   CHAR6,                    "  CHAR 6
         PROJECT_GUID     TYPE   CHAR32,
         "PAK_PROJECT_GUID,   "  RAW 16
         PROJECT_PASSDOWN TYPE   CHAR1,                    "  CHAR  1
       END OF TY_TDEVC.

TYPES: BEGIN OF TY_ABAPTXT255,
         LINE TYPE TEXT255,
       END OF TY_ABAPTXT255.

TYPES: BEGIN OF TY_RSDCHABAS,
         CHABASNM TYPE CHAR30, "rsdchabas-chabasnm,
         INFOAREA TYPE CHAR30, "rsdchabas-infoarea,
         APPLNM   TYPE CHAR30, "rsdchabas-applnm,
       END OF TY_RSDCHABAS.

TYPES: TT_OPTIONS   TYPE TABLE OF RFC_DB_OPT,
       TT_FIELDS    TYPE TABLE OF RFC_DB_FLD,
       TT_ANY_TABLE TYPE TABLE OF TAB512.

* Usage record type
TYPES: BEGIN OF TY_RECORD,
         PERIOD     TYPE CHAR6,
         TYPE       TYPE CHAR1,
         TCODE      TYPE CHAR255, "SAPWLPFNRM-REPORT,
         USER       TYPE SAPWLUTACC,
         REMOT_DEST TYPE SAPWLRFCS-REMOT_DEST,
         JOBNAME    TYPE SY-CPROG,
         USAGE      TYPE P,
       END OF TY_RECORD,

       TT_RECORD TYPE TABLE OF TY_RECORD.

* Usage callers record for proxies/idocs
TYPES: BEGIN OF TY_USAGE_CALLER,
         CALLER(100) TYPE C,
         COUNT       TYPE I,
         LAST_USED   TYPE DATUM,
       END OF TY_USAGE_CALLER,

       TT_USAGE_CALLER TYPE TABLE OF TY_USAGE_CALLER.

TYPES: BEGIN OF TS_USER_ADDR,
         MANDT                TYPE USER_ADDR-MANDT,
         BNAME                TYPE USER_ADDR-BNAME,
         NAME_FIRST           TYPE USER_ADDR-NAME_FIRST,
         NAME_LAST            TYPE USER_ADDR-NAME_LAST,
         NAME_TEXT            TYPE USER_ADDR-NAME_TEXTC,
         DEPARTMENT           TYPE USER_ADDR-DEPARTMENT,
         CITY1                TYPE USER_ADDR-CITY1,
         FUNCTION             TYPE ADDR3_DATA-FUNCTION,
         ROOM_NUM             TYPE ADDR3_DATA-ROOMNUM_C,
         FLOOR                TYPE ADDR3_DATA-FLOOR_C,
         BUILDING             TYPE ADDR3_DATA-BUILDING_C,
         COMPANY_NAME         TYPE ADDR1_DATA-NAME1,
         COMPANY_COUNTRY      TYPE ADDR1_DATA-COUNTRY,
         COMPANY_COUNTRY_TEXT TYPE T005T-LANDX,
         COMPANY_REGION       TYPE ADDR1_DATA-REGION,
         COMPANY_REGION_TEXT  TYPE T005U-BEZEI,
       END OF TS_USER_ADDR,

       TT_USER_ADDR TYPE TABLE OF TS_USER_ADDR.

TYPES  BEGIN OF TS_USER_MSTR_REC.
INCLUDE TYPE TS_USER_ADDR.
TYPES: DATFM TYPE XUDATFM,   " Date format
       DCPFM TYPE XUDCPFM, " Decimal notation
       END OF TS_USER_MSTR_REC,

       TT_USER_MSTR_REC TYPE TABLE OF TS_USER_MSTR_REC.

TYPES: BEGIN OF TS_USR01,
         MANDT TYPE USR01-MANDT,
         BNAME TYPE USR01-BNAME,
         DATFM TYPE USR01-DATFM,
         DCPFM TYPE USR01-DCPFM,
       END OF TS_USR01,

       TT_USR01 TYPE TABLE OF TS_USR01.

TYPES: BEGIN OF TS_USER_DETAILS.
    INCLUDE TYPE TS_USER_MSTR_REC.
TYPES: HR_COUNTRY            TYPE STRING,
       HR_ORG_UNIT           TYPE STRING,
       HR_COMPANY_CODE       TYPE BUKRS,
       HR_COMPANY_NAME       TYPE BUTXT,
       HR_PERSONAL_AREA      TYPE PERSA,
       HR_PERSONAL_AREA_TEXT TYPE PBTXT,
       HR_SUB_AREA           TYPE BTRTL,
       HR_SUB_AREA_NAME      TYPE BTRTX,
       HR_BUS_AREA           TYPE GSBER,
       HR_BUS_AREA_NAME      TYPE GTEXT,
       HR_POSITION           TYPE STEXT,
       END OF TS_USER_DETAILS,

       TT_USERS_DETAILS TYPE TABLE OF TS_USER_DETAILS,

       TT_PA0105        TYPE TABLE OF PA0105,
       TT_HASH_PA0001   TYPE HASHED TABLE OF PA0001
                                            WITH UNIQUE KEY PERNR,
       TT_ORGEH         TYPE HASHED TABLE OF ORGEH
                                            WITH UNIQUE KEY TABLE_LINE,
       TT_BUKRS         TYPE HASHED TABLE OF BUKRS
                                            WITH UNIQUE KEY TABLE_LINE,
       TT_GSBER         TYPE HASHED TABLE OF GSBER
                                            WITH UNIQUE KEY TABLE_LINE,
       TT_PLANS         TYPE HASHED TABLE OF PLANS
                                            WITH UNIQUE KEY TABLE_LINE,
       TT_HRP1000       TYPE TABLE OF HRP1000,
       TT_T001          TYPE TABLE OF T001,
       TT_HASH_T500P    TYPE HASHED TABLE OF T500P
                                            WITH UNIQUE KEY PERSA,
       TT_HASH_T005T    TYPE HASHED TABLE OF T005T
                                            WITH UNIQUE KEY LAND1,
       TT_HASH_T005U    TYPE HASHED TABLE OF T005U
                                            WITH UNIQUE KEY LAND1 BLAND,
       TT_HASH_T001     TYPE HASHED TABLE OF T001
                                            WITH UNIQUE KEY BUKRS,
       TT_HASH_T001P    TYPE HASHED TABLE OF T001P
                                            WITH UNIQUE KEY WERKS BTRTL,
       TT_HASH_TGSBT    TYPE HASHED TABLE OF TGSBT
                                            WITH UNIQUE KEY SPRAS GSBER,

**   For Omega Master data values and texts
       BEGIN OF TS_BUSINESS_PARAM_TEXT_FIELDS,
         TABLE_NAME TYPE DD02L-TABNAME,
         LANG       TYPE TYPENAME,
         VALUE      TYPE TYPENAME,
         TEXT       TYPE TYPENAME,
       END OF TS_BUSINESS_PARAM_TEXT_FIELDS,
       TT_BUSINESS_PARAM_TEXT_FIELDS TYPE
         TABLE OF TS_BUSINESS_PARAM_TEXT_FIELDS,

       BEGIN OF TS_BUSINESS_PARAM_TEXT,
         BUSINESS_PARAM TYPE TYPENAME,
         LANG           TYPE SPRAS,
         VALUE          TYPE CHAR40,
         TEXT           TYPE CHAR40,
       END OF TS_BUSINESS_PARAM_TEXT,
       TT_BUSINESS_PARAM_TEXT TYPE TABLE OF TS_BUSINESS_PARAM_TEXT,

       BEGIN OF TS_BUSINESS_PARAM_REL_FIELDS,
         TABLE_NAME TYPE DD02L-TABNAME,
         VALUE      TYPE TYPENAME,
         VALUE_REL  TYPE TYPENAME,
       END OF TS_BUSINESS_PARAM_REL_FIELDS,
       TT_BUSINESS_PARAM_REL_FIELDS TYPE
         TABLE OF TS_BUSINESS_PARAM_REL_FIELDS,

       BEGIN OF TS_BUSINESS_PARAM_REL,
         BUSINESS_PARAM     TYPE TYPENAME,
         VALUE              TYPE CHAR40,
         BUSINESS_PARAM_REL TYPE TYPENAME,
         VALUE_REL          TYPE CHAR40,
       END OF TS_BUSINESS_PARAM_REL,
       TT_BUSINESS_PARAM_REL TYPE TABLE OF TS_BUSINESS_PARAM_REL,
**   End of Omega Master data values and texts

       BEGIN OF TS_TNAPR_KEY,
         KSCHL TYPE TNAPR-KSCHL,
         NACHA TYPE TNAPR-NACHA,
         KAPPL TYPE TNAPR-KAPPL,
       END OF TS_TNAPR_KEY,

       BEGIN OF TY_LAYOUT_USAGE,
         KSCHL          TYPE NA_KSCHL,
         NACHA          TYPE NA_NACHA,
         KAPPL          TYPE KAPPL,
         OBJTYPE        TYPE OJ_NAME,
         LAST_USED_DATE TYPE DATUM,
         COUNT          TYPE I,
       END OF TY_LAYOUT_USAGE,

       TT_HASH_LAYOUT_USAGE   TYPE HASHED TABLE OF TY_LAYOUT_USAGE
                            WITH UNIQUE KEY KSCHL NACHA KAPPL OBJTYPE,
       TY_SORTED_LAYOUT_USAGE TYPE SORTED TABLE OF TY_LAYOUT_USAGE
                            WITH NON-UNIQUE KEY KSCHL NACHA KAPPL.

TYPES: BEGIN OF T_UNIFIED_SOURCE,
         LINE(255) TYPE C,
       END OF T_UNIFIED_SOURCE,
       TT_UNIFIED_SOURCE TYPE TABLE OF T_UNIFIED_SOURCE,
       T_PROGRAM_TYPE    TYPE TABLE OF TRDIR,

       BEGIN OF FUNCTION_TYPE,
         FUNCNAME LIKE TFDIR-FUNCNAME,
       END OF FUNCTION_TYPE,
       BEGIN OF INFOTYPE_TYPE,
         TCODE(46) TYPE C,
         PROG      TYPE PROGRAM_ID,
         MODULE    TYPE UFPS_POSID,
         TYPE,
       END OF INFOTYPE_TYPE,

       T_FUNCTION_TYPE TYPE TABLE OF FUNCTION_TYPE,
       T_INFOTYPE_TYPE TYPE TABLE OF INFOTYPE_TYPE,

       BEGIN OF XML_LINE_TYPE,
         DATA(256) TYPE X,
       END OF XML_LINE_TYPE,
       XML_TAB_TYPE TYPE TABLE OF XML_LINE_TYPE,

       XML_DOCUMENT TYPE REF TO IF_IXML_DOCUMENT,
       XML_ELEMENT  TYPE REF TO IF_IXML_ELEMENT,

       BEGIN OF HANDLES_TYPE,
         NODE_REF TYPE XML_ELEMENT,
         WA       TYPE REF TO DATA,
       END OF HANDLES_TYPE,
       HANDLES_TAB_TYPE TYPE TABLE OF HANDLES_TYPE,

       BEGIN OF DDTYPES_TYPE,
         TYPEKIND LIKE DDTYPES-TYPEKIND,
         TYPENAME LIKE DDTYPES-TYPENAME,
       END OF DDTYPES_TYPE,

       BEGIN OF DATA_ELEMENT_TYPE,
         ROLLNAME LIKE DFIES-ROLLNAME,
         INTTYPE  LIKE DFIES-ROLLNAME,
         INTLEN   LIKE DFIES-INTLEN,
         DECIMALS LIKE DFIES-DECIMALS,
       END OF DATA_ELEMENT_TYPE,
       DATA_ELEMENT_TAB_TYPE TYPE TABLE OF DATA_ELEMENT_TYPE,

       BEGIN OF ETL_MESSAGE_TYPE,
         ORDER(5)     TYPE N,
         DATE         LIKE SY-DATUM,
         TIME         LIKE SY-UZEIT,
         MESSAGE(512) TYPE C,
       END OF ETL_MESSAGE_TYPE,

       BEGIN OF TY_ETL_NOTIFICATION,
         CODE       TYPE STRING,
         PARAMETERS TYPE STRING,
         MESSAGE    TYPE STRING,
       END OF TY_ETL_NOTIFICATION,

       BEGIN OF ETL_TIME_STATS_TYPE,
         STEP(512) TYPE C,
         STARTDATE TYPE AS4DATE,
         STARTTIME TYPE AS4TIME,
         ENDDATE   TYPE AS4DATE,
         ENDTIME   TYPE AS4TIME,
       END OF ETL_TIME_STATS_TYPE,

       BEGIN OF MODIFIED_OBJECT,
         OBJ_TYPE LIKE TADIR-OBJECT,
         OBJ_NAME LIKE TADIR-OBJ_NAME,
       END OF MODIFIED_OBJECT.

TYPES: TY_ETL_NOTIFICATION_T TYPE STANDARD TABLE OF TY_ETL_NOTIFICATION.

TYPES: BEGIN OF OUTREC,
         PERIOD  TYPE CHAR6,
         TCODE   TYPE CHAR255, "SAPWLPFNRM-REPORT,
         JOBNAME TYPE SY-CPROG,
         TYPE    TYPE CHAR1,
*           user    TYPE SAPWLUTACC,
         USAGE   TYPE NUM10,
       END OF OUTREC.

TYPES: BEGIN OF PROG_TYPE,
         PROG LIKE TADIR-OBJ_NAME,
       END OF PROG_TYPE,
       PROG_TAB_TYPE TYPE TABLE OF PROG_TYPE.

TYPES: BEGIN OF VANILLA_PROG_TYPE,
         PROG   LIKE TADIR-OBJ_NAME,
         ORIGIN TYPE I,
       END OF VANILLA_PROG_TYPE,
       VANILLA_PROG_TAB_TYPE TYPE TABLE OF VANILLA_PROG_TYPE.

* The MSXXLIST structure as it is in 46C
TYPES: BEGIN OF MSXXLIST_46_TYPE,
         NAME(20) TYPE C,
         HOST(20) TYPE C,
         SERV(20) TYPE C,
         MSGTYPES TYPE MSTYPES,
         HOSTADR  TYPE MSHOSTADR,
         SERVNO   TYPE MSSERVNO,
       END OF MSXXLIST_46_TYPE,
       MSXXLIST_46_TAB_TYPE TYPE TABLE OF MSXXLIST_46_TYPE.

TYPES: BEGIN OF SUBROUTINE_TYPE,
         SUBROUTINE TYPE STRING,
       END OF SUBROUTINE_TYPE,
       SUBROUTINE_TAB_TYPE TYPE TABLE OF SUBROUTINE_TYPE.

TYPES:
  BEGIN OF UPL_DATA,
*    SMD_LSID(8)  type C, "System ID
    SM_CCLPN(40)   TYPE C, "Program Name
    SM_CCLOT(4)    TYPE C, "Object Type
    SM_CCLON(40)   TYPE C, "Object Name
    SM_CCLNS(10)   TYPE C, "Namespace
    SM_CCLTP(4)    TYPE C, "Processing type
    SM_CCLNP(60)   TYPE C, "Processing block
    CALMONTH(6)    TYPE N, "Month in the year
    SM_CCLPE(8)    TYPE F,
    MONTH_USED     TYPE I,
    METHOD_INC(40) TYPE C,
  END OF UPL_DATA,
  UPL_DATA_TAB TYPE TABLE OF UPL_DATA.
TYPES: BEGIN OF T_BTE_UE,
         EVENT TYPE TBE01-EVENT,
         TEXT1 TYPE TBE01T-TEXT1,
         STDFB TYPE STDFU_BF,
       END OF T_BTE_UE.

DATA: G_WEB_DATA TYPE TABLE OF SWNCAGGWEBDEST.

DATA: G_WEB_BLACKLIST TYPE RANGE OF CHAR250_D.
DATA: GT_OBJ_WD       TYPE TABLE OF STRING. "WDABAP
DATA: G_PROXY_HEADERS TYPE STANDARD TABLE OF SPROXHDR.

TYPES:
  RA_WS_FILTER      TYPE RANGE OF WSHEADER-PREFIX,
  TT_WS_FILTER      TYPE TABLE OF RA_WS_FILTER,
  RA_WD_ABAP_FILTER TYPE RANGE OF STRING,
  TT_WD_ABAP_FILTER TYPE TABLE OF RA_WD_ABAP_FILTER.

DATA:
  LT_WS_FILTER      TYPE RA_WS_FILTER,
  LS_WS_FILTER      LIKE LINE OF LT_WS_FILTER,
  LT_WD_ABAP_FILTER TYPE RA_WD_ABAP_FILTER,
  LS_WD_ABAP_FILTER LIKE LINE OF LT_WD_ABAP_FILTER.

**********************************************************************
*** S/4 HANA ATC
**********************************************************************

TYPES:

  BEGIN OF ST_SCIR_REST,
    INSPECID   TYPE NUMC3,
    INSPECVERS TYPE NUMC3,
    CIUSER     TYPE CHAR12,
    OBJTYPE    TYPE CHAR4,
    OBJNAME    TYPE CHAR40,
    TEST       TYPE CHAR30,
    ERRCNT     TYPE INT2,
    CONSECCNT  TYPE INT2,
    SOBJNAME   TYPE CHAR40,
    SOBJTYPE   TYPE CHAR4,
    LINE       TYPE N LENGTH 6,
    COL        TYPE NUMC4,
    KIND       TYPE CHAR1,
    CODE       TYPE CHAR10,
    PARAM1     TYPE STRING,
    PARAM2     TYPE STRING,
    PARAM3     TYPE CHAR20,
    PARAM4     TYPE CHAR20,
    CHECKSUM1  TYPE INT4,
    EXCEPTN    TYPE CHAR1,
    INCLSPEC   TYPE CHAR1,
    DETAIL     TYPE XSTRING,
  END OF ST_SCIR_REST,

  TT_SCIR_REST TYPE TABLE OF ST_SCIR_REST,

  BEGIN OF ST_FINDING_EXTENSION,
    PACKAGE_NAME      TYPE STRING,
    EXC_VALIDITY      TYPE CHAR1,
    SINCE             TYPE TIMESTAMP,
    CONTACT_PERSON    TYPE STRING,
    DESCRIPTION_LINES TYPE STRING_TABLE,
  END OF ST_FINDING_EXTENSION,

  TT_FINDING_EXTENSION TYPE TABLE OF ST_FINDING_EXTENSION,

  BEGIN OF ST_MSG_METADATA,
    CODE  TYPE CHAR10,
    TITLE TYPE TEXT128,
  END OF ST_MSG_METADATA,

  TT_MSG_METADATA TYPE STANDARD TABLE OF ST_MSG_METADATA
                    WITH NON-UNIQUE KEY CODE,

  BEGIN OF ST_CHECK_METADATA,
    CLASS	   TYPE SEOCLSNAME,
    TITLE    TYPE TEXT256,
    MESSAGES TYPE TT_MSG_METADATA,
  END OF ST_CHECK_METADATA,

  TT_CHECK_METADATA     TYPE STANDARD TABLE OF ST_CHECK_METADATA,
  TT_CHECK_METADATA_KEY TYPE HASHED TABLE OF ST_CHECK_METADATA
                          WITH UNIQUE KEY CLASS,

  BEGIN OF TS_S4HANA_ATC_CHECK.
    INCLUDE TYPE TS_HANAA_SCI_CHECK.
TYPES:
  DESCRIPTION_LINES TYPE STRING,

  END OF TS_S4HANA_ATC_CHECK,

  TT_S4HANA_ATC_CHECK TYPE TABLE OF TS_S4HANA_ATC_CHECK.

**********************************************************************
*** S/4 HANA SI Types
**********************************************************************
 TYPES:
    BEGIN OF TY_CONV_TARGET_STACK_STR,
        PROD_NUMBER        TYPE CHAR20,
        PROD_DESC          TYPE CHAR100,
        PROD_VER_NUMBER    TYPE CHAR20,
        PROD_VER_NAME      TYPE CHAR100,
        STACK_NUMBER       TYPE CHAR20,
        STACK_NAME         TYPE CHAR100,
        STACK_SORT_SEQ     TYPE NUMC10,
        STACK_RELEASE_DATE TYPE BAPISDATE,
      END OF TY_CONV_TARGET_STACK_STR.
  TYPES:
    TY_CONV_TARGET_STACK_TAB TYPE TABLE OF TY_CONV_TARGET_STACK_STR.
TYPES:
  BEGIN OF TY_RC_RELE_CHK_RESULT_STR,
    "Below fields are from SDB
    SITEM_GUID                TYPE GUID_32,
    "Below fields are based on calculation
    APPLICABLE                TYPE C LENGTH 50,
    APPLICABLE_STAT           TYPE C LENGTH 4,
    MATCH_TARGET_REL_CATEGORY TYPE CHAR30,
    RELEVANT_STAT             TYPE C LENGTH 4,
    RELEVANT_STAT_INT         TYPE CHAR10,
    SUMMARY                   TYPE STRING,
    SUMMARY_INT               TYPE STRING,
    SQL_STR_INT               TYPE STRING,
  END OF TY_RC_RELE_CHK_RESULT_STR .
TYPES:
  TY_RC_RELE_CHK_RESULT_TAB TYPE STANDARD TABLE OF
  TY_RC_RELE_CHK_RESULT_STR .
TYPES:
  BEGIN OF TY_RELEV_CHK_HEADER_STR,
    START_TIME_UTC          TYPE TIMESTAMP,
    START_TIME_WH_TIMEZONE  TYPE STRING,
    END_TIME_UTC            TYPE TIMESTAMP,
    END_TIME_WH_TIMEZONE    TYPE STRING,
    RUNNING_TIME_IN_SECONDS TYPE I,
    SYSTEM_NAME             TYPE SY-SYSID,
    SYSTEM_CLIENT           TYPE SY-MANDT,
    CHECK_USER              TYPE SY-UNAME,
    SIMP_ITEM_CAT_VER_UTC   TYPE TIMESTAMP,
    NO_ENOUGH_ST03_DATA     TYPE FLAG,
    FWK_NOTE_NUMBER         TYPE CWBNTNUMM,
    FWK_NOTE_CURRENT_VER    TYPE CWBNTVERS,
    FWK_NOTE_MIN_REQ_VER    TYPE CWBNTVERS,
    FWK_NOTE_LATEST_IMPLED  TYPE CHAR1,
  END OF TY_RELEV_CHK_HEADER_STR .

TYPES:
  BEGIN OF TY_SMDB_CHECK_STR,
    SITEM_GUID           TYPE GUID_32,
    CHECK_GUID           TYPE GUID_32,
    CHECK_TYPE           TYPE C LENGTH 30,
    CHECK_IDENTIFIER     TYPE C LENGTH 80,
    CHECK_SUB_IDENTIFIER TYPE C LENGTH 80,
    "check_sub_identifier is used as entry point type
    SAP_NOTE             TYPE CWBNTNUMM,
    BF_CHK_STATE         TYPE SFW_R3STATE, "buz_func_chk_state
    CHECK_COUNT          TYPE I,
    CHECK_COUNT_OPTION   TYPE CHAR2,
    CHECK_CONDITION      TYPE CHAR3,
    CHECK_CLASS_USAGE    TYPE CHAR10,
  END OF TY_SMDB_CHECK_STR .
TYPES:
  TY_SMDB_CHECK_TAB TYPE TABLE OF TY_SMDB_CHECK_STR .

TYPES:
  BEGIN OF TY_SMDB_ITEM_STR,
    GUID                TYPE GUID_32,
    SEQ_AREA            TYPE CHAR10,
    SITEM_ID            TYPE C LENGTH 80,
    APP_AREA            TYPE C LENGTH 80,
    LOB_TECHNOLOGY      TYPE STRING,
    BUSINESS_AREA       TYPE STRING,
    PROC_STATUS         TYPE C LENGTH 30,
    PROC_STATUS_TEXT_EN TYPE C LENGTH 255,
    TITLE_EN            TYPE STRING,
    CHECK_CONDITION     TYPE CHAR3,
    EXPECTED_RELEV_STAT TYPE CHAR30, "this is only for test purpose
    REFER_GUID          TYPE GUID_32,
    COPY_GUID           TYPE GUID_32,
    COPY_STATUS         TYPE CHAR1,
  END OF TY_SMDB_ITEM_STR .
TYPES:
  TY_SMDB_ITEM_TAB TYPE TABLE OF TY_SMDB_ITEM_STR .

TYPES:
  BEGIN OF TY_PRE_CONS_CHK_RESULT_STR,
    RETURN_CODE  TYPE I,
    DESCRIPTIONS TYPE SALV_WD_T_STRING, "table of string
    CHECK_SUB_ID TYPE C LENGTH 80,
    "SI check_sub_identifier; used if same class for different SI
  END OF TY_PRE_CONS_CHK_RESULT_STR .
TYPES:
  TY_PRE_CONS_CHK_RESULT_TAB TYPE STANDARD TABLE OF
  TY_PRE_CONS_CHK_RESULT_STR .

TYPES:
  BEGIN OF TY_CONSIS_CHK_RESULT_STR,
    "Below fields are from SDB
    SITEM_GUID              TYPE GUID_32,
    SITEM_ID                TYPE C LENGTH 80,
    CHECK_CLASS             TYPE C LENGTH 80,
    SAP_NOTE                TYPE STRING,
    "Below fields are based on calculation
    RETURN_CODE             TYPE I,
    SKIPPABLE_ERROR         TYPE FLAG,
    SKIP_STATUS             TYPE C LENGTH 4,
    START_TIME              TYPE TIMESTAMP,
    START_TIME_WH_TIMEZONE  TYPE STRING,
    END_TIME                TYPE TIMESTAMP,
    END_TIME_WH_TIMEZONE    TYPE STRING,
    RUNNING_TIME_IN_SECONDS TYPE I,
    HEADER_INFO_TABLE       TYPE TIHTTPNVP, "salv_wd_t_string,
    CHK_CLAS_RESULT_XSTR    TYPE XSTRING,
  END OF TY_CONSIS_CHK_RESULT_STR .
TYPES:
  TY_CONSIS_CHK_RESULT_TAB TYPE STANDARD TABLE OF
  TY_CONSIS_CHK_RESULT_STR .

TYPES:
  BEGIN OF TY_CONSIS_CHK_RESULT_OUT_STR,
    "Below fields are from SDB
    SITEM_GUID                TYPE GUID_32,
    SITEM_TYPE                TYPE C LENGTH 15,
    SITEM_ID                  TYPE C LENGTH 80,
    CHECK_CLASS               TYPE C LENGTH 80,
    SAP_NOTE                  TYPE STRING,
    "Below fields are based on calculation
    RETURN_CODE               TYPE I,
    SKIPPABLE_ERROR           TYPE FLAG,
    SKIP_STATUS               TYPE C LENGTH 4,
    START_TIME                TYPE TIMESTAMP,
    START_TIME_WH_TIMEZONE    TYPE STRING,
    END_TIME                  TYPE TIMESTAMP,
    END_TIME_WH_TIMEZONE      TYPE STRING,
    RUNNING_TIME_IN_SECONDS   TYPE I,
    "Below fields are based on calculation
    APPLICABLE                TYPE C LENGTH 50,
    MATCH_TARGET_REL_CATEGORY TYPE CHAR30,
    RELEVANT_STAT_INT         TYPE CHAR10,
    SUMMARY                   TYPE STRING,
    SUMMARY_INT               TYPE STRING,
    SQL_STR_INT               TYPE STRING,
  END OF TY_CONSIS_CHK_RESULT_OUT_STR .
TYPES:
  TY_CONSIS_CHK_RESULT_OUT_TAB TYPE STANDARD TABLE OF
  TY_CONSIS_CHK_RESULT_OUT_STR .

TYPES:
  BEGIN OF TY_CONSIS_CHK_HEADER_OUT_STR,
    SITEM_GUID TYPE GUID_32,
    NUMERATOR  TYPE I,
    NAME       TYPE STRING,
    VALUE      TYPE STRING,
  END OF TY_CONSIS_CHK_HEADER_OUT_STR .
TYPES:
  TY_CONSIS_CHK_HEADER_OUT_TAB TYPE STANDARD TABLE OF
  TY_CONSIS_CHK_HEADER_OUT_STR .

TYPES:
  BEGIN OF TY_CONSIS_CHK_DETAILS_OUT_STR,
    SITEM_GUID   TYPE GUID_32,
    INDEX        TYPE I,
    CHECK_SUB_ID TYPE STRING,
    RETURN_CODE  TYPE STRING,
    DESCRIPTION  TYPE STRING,
  END OF TY_CONSIS_CHK_DETAILS_OUT_STR .
TYPES:
  TY_CONSIS_CHK_DETAILS_OUT_TAB TYPE STANDARD TABLE OF
  TY_CONSIS_CHK_DETAILS_OUT_STR.

TYPES:
  BEGIN OF TY_PRD_VERS,
    ID         TYPE CHAR20,
    NAME       TYPE CHAR30,
    VERSION    TYPE CHAR30,
    VENDOR     TYPE CHAR30,
    DESCRIPT   TYPE CHAR72,
    INSTSTATUS TYPE CHAR1,
    MOD_DATE   TYPE DATS,
    MOD_TIME   TYPE TIMS,
  END OF TY_PRD_VERS,

  BEGIN OF TY_STACKCOMPS,
    STACK_ID   TYPE CHAR20,
    INST_ID    TYPE CHAR20,
    PROD_ID    TYPE CHAR20,
    COMP_NAME  TYPE CHAR30,
    COMP_VERS  TYPE CHAR10,
    COMP_SPLVL TYPE NUMC4,
  END OF TY_STACKCOMPS,

  BEGIN OF TY_STACKHEADR,
    ID         TYPE CHAR20,
    QUEUE_ID   TYPE CHAR40,
    TYPE       TYPE CHAR10,
    PROD_ID    TYPE CHAR20,
    DESCRIPT   TYPE CHAR72,
    INSTSTATUS TYPE CHAR1,
    INST_DATE  TYPE DATS,
    INST_TIME  TYPE TIMS,
    RESPONSIBL TYPE CHAR12,
    GEN_VERS   TYPE CHAR5,
    GEN_DATE   TYPE DATS,
    GEN_TIME   TYPE TIMS,
  END OF TY_STACKHEADR.

**********************************************************************
* WDABAP
**********************************************************************

DATA: WD_HEADER_NODE             TYPE REF TO IF_IXML_ELEMENT,
      WD_COMPS_NODE              TYPE REF TO IF_IXML_ELEMENT,
      WD_USED_OBJECTS_NODE       TYPE REF TO IF_IXML_ELEMENT,
      WD_COMP_USAGE_NODE         TYPE REF TO IF_IXML_ELEMENT,
      WD_COMP_SYNTAX_ERRORS_NODE TYPE REF TO IF_IXML_ELEMENT,
      WD_INTF_IMPLEM_NODE        TYPE REF TO IF_IXML_ELEMENT,
      WD_APP_CONFIGURATIONS_NODE TYPE REF TO IF_IXML_ELEMENT.


DATA:
  WDY_CONTROLLER_TAB           TYPE TABLE OF WDY_CONTROLLER,
  WDY_CONTROLLER_WA            LIKE LINE OF  WDY_CONTROLLER_TAB,
  WDY_CONTROLLER_DESC_TAB      TYPE TABLE OF WDY_CONTROLLERT,
  WDY_CONTROLLER_DESC_WA       LIKE LINE OF  WDY_CONTROLLER_DESC_TAB,
  WDY_COMPO_USAGE_TAB          TYPE TABLE OF WDY_COMPO_USAGE,
  WDY_COMPO_USAGE_WA           LIKE LINE OF  WDY_COMPO_USAGE_TAB,
  WDY_COMPO_USAGE_TAB_LOCAL    TYPE TABLE OF WDY_COMPO_USAGE,
  WDY_INTF_IMPLEM_TAB          TYPE TABLE OF WDY_INTF_IMPLEM,
  WDY_INTF_IMPLEM_WA           LIKE LINE OF  WDY_INTF_IMPLEM_TAB,
  WDY_INTF_IMPLEM_TAB_LOCAL    TYPE TABLE OF WDY_INTF_IMPLEM,
  WDY_CTLR_COMPO_TAB           TYPE TABLE OF WDY_CTLR_COMPO,
  WDY_VIEW_TAB                 TYPE TABLE OF WDY_VIEW,
  WDY_VIEW_WA                  LIKE LINE OF WDY_VIEW_TAB,
  WDY_CONFIG_APPL_TAB          TYPE TABLE OF WDY_CONFIG_APPL,
  WDY_CONFIG_CU_APPL_TAB       TYPE TABLE OF WDY_CONFIG_APPL,
  WDY_CONFIG_CU_APPL_FS_TAB    TYPE TABLE OF WDY_CONFIG_APPL,
  WDY_CONFIG_APPL_WA           LIKE LINE OF WDY_CONFIG_APPL_TAB,
  WDY_APP_CONFIG_TAB_LOCAL     TYPE TABLE OF WDY_CONFIG_APPL,
  WDY_APP_PROPERTY_TAB         TYPE TABLE OF WDY_APP_PROPERTY,
  WDY_CU_APP_PROPERTY_TAB      TYPE TABLE OF WDY_APP_PROPERTY,
  WDY_APP_PROPERTY_WA          LIKE LINE OF WDY_APP_PROPERTY_TAB,
  LV_COUNTER                   TYPE I,
  WDY_COMPONENT_TAB            TYPE TABLE OF WDY_COMPONENT,
  WDY_COMPONENT_DESC_TAB       TYPE TABLE OF WDY_COMPONENTT,
  WDY_COMPONENT_DESC_WA        LIKE LINE OF WDY_COMPONENT_DESC_TAB,
  WDY_APPLICATION_TAB          TYPE TABLE OF WDY_APPLICATION,
  WDY_CUST_FOR_SAP_APPS_TAB    TYPE TABLE OF WDY_APPLICATION,
  WDY_CUST_FOR_SAP_APPS_WA     LIKE LINE OF WDY_CUST_FOR_SAP_APPS_TAB,
  WDY_APPLICATION_WA           LIKE LINE OF WDY_APPLICATION_TAB,
  WD_CHECK_RESULTS_TAB         TYPE TT_HANAA_SCI_CHECK,
  WD_CHECK_RESULTS_TAB_LOCAL   TYPE TT_HANAA_SCI_CHECK,
  WDY_APPLICATION_NAME         LIKE LINE OF WDY_APPLICATION_TAB,
  WDY_CTLR_PARAM_TAB           TYPE TABLE OF WDY_CTLR_PARAM,
  WDY_CTLR_PARAM_WA            LIKE LINE OF WDY_CTLR_PARAM_TAB,
  WDY_CTLR_COMPO_WA            LIKE LINE OF WDY_CTLR_COMPO_TAB,
  WDY_CTLR_COMPO_DESC_TAB      TYPE TABLE OF WDY_CTLR_COMPOT,
  WDY_CTLR_COMPO_DESC_WA       LIKE LINE OF WDY_CTLR_COMPO_DESC_TAB,
  WDY_APPLICATION_DESC_TAB     TYPE TABLE OF WDY_APPLICATIONT,
  WDY_APPLICATIION_CU_DESC_TAB TYPE TABLE OF WDY_APPLICATIONT,
  WDY_APPLICATION_DESC_WA      LIKE LINE OF WDY_APPLICATION_DESC_TAB,
  WDY_APP_DESC_LOCAL_TAB       TYPE TABLE OF WDY_APPLICATIONT,
  COMP_NAME_TAB                TYPE TABLE OF WDY_COMPONENT_NAME,
  COMP_NAME_TAB_RA             TYPE RANGE OF WDY_COMPONENT_NAME,
  COMP_NAME_TAB_RA_WA          LIKE LINE OF COMP_NAME_TAB_RA,
  COMP_NAME_TAB_WA             LIKE LINE OF COMP_NAME_TAB_RA,
  APP_NAME_TAB_RA              TYPE RANGE OF WDY_APPLICATION_NAME,
  APP_NAME_TAB_RA_WA           LIKE LINE OF APP_NAME_TAB_RA,
  APPS_FOR_CUST_COMPS_RA       TYPE RANGE OF WDY_APPLICATION_NAME,
  APPS_FOR_CUST_COMPS_WA       LIKE LINE OF APPS_FOR_CUST_COMPS_RA,
  COMP_WDY_CUST_TAB            TYPE TABLE OF WDY_APPLICATION_NAME,
  CUST_APP_CONFIGS_TAB         TYPE TABLE OF WDY_CONFIG_ID,
  CUST_APP_CONFIGS_WA          LIKE LINE OF CUST_APP_CONFIGS_TAB,
  COMP_WDY_CUST_WA             LIKE LINE OF COMP_WDY_CUST_TAB,
  WDY_COMPONENT_WA             LIKE LINE OF WDY_COMPONENT_TAB,
  COMP_NAME_WA                 LIKE LINE OF COMP_NAME_TAB,
  START_OF_CMP_FOR_METHOD      TYPE SY-TABIX,
  END_OF_CMP_FOR_METHOD        TYPE SY-TABIX,
  SINGLE_METHOD_PARAM_TAB      TYPE TABLE OF WDY_CTLR_PARAM,
  SINGLE_METHOD_PARAM_WA       LIKE LINE OF SINGLE_METHOD_PARAM_TAB,
  WD_CUST_APP_FOR_STD_CMP_NODE TYPE REF TO IF_IXML_ELEMENT,
  WD_CUSTOM_CTRL_HEADER_NODE   TYPE REF TO IF_IXML_ELEMENT,
  WD_COMP_CONTROLLERS_NODE     TYPE REF TO IF_IXML_ELEMENT,
  WD_CUSTOM_CONTROLLER_NODE    TYPE REF TO IF_IXML_ELEMENT,
  WD_METHOD_NODE               TYPE REF TO IF_IXML_ELEMENT,
  WDY_VIEWS_HEADER_NODE        TYPE REF TO IF_IXML_ELEMENT,
  WDY_VIEW_NODE                TYPE REF TO IF_IXML_ELEMENT,
  WDY_WINDOW_HEADER_NODE       TYPE REF TO IF_IXML_ELEMENT,
  WDY_WINDOW_NODE              TYPE REF TO IF_IXML_ELEMENT,
  WDY_CONTROLLER_NODE          TYPE REF TO IF_IXML_ELEMENT,
  WDY_WINDOWS_HEADER_NODE      TYPE REF TO IF_IXML_ELEMENT,
  WDY_APPLICATIONS_HEADER_NODE TYPE REF TO IF_IXML_ELEMENT,
  WDY_APPLICATION_NODE         TYPE REF TO IF_IXML_ELEMENT,
  WD_COMPO_DESCRIPTIONS_NODE   TYPE REF TO IF_IXML_ELEMENT,
  WDY_COMPONENT_DESC_TAB_LOCAL TYPE TABLE OF WDY_COMPONENTT,
  WDY_APP_PROPERTY_TAB_LOCAL   TYPE TABLE OF WDY_APP_PROPERTY.
*---------WDABAP-----------------------------*

*---------Enhancements-----------------------------*
DATA:
  ENH_SPOTS_NODE TYPE REF TO IF_IXML_ELEMENT,
  ENH_SPOT_NODE  TYPE REF TO IF_IXML_ELEMENT.
*---------Enhancements-----------------------------*

DATA: GT_MESSAGE_TAB TYPE STRINGTAB.

CLASS CL_IXML DEFINITION LOAD.

* Includes
INCLUDE <ICON>.

* Type-pools
TYPE-POOLS: ABAP, SLIS, VRM.

* Constants definition
*                                             =======
CONSTANTS: XML_VERSION(10)       TYPE C VALUE '1.12'.
*                                             =======

** Account's Constants **
CONSTANTS:
* Is account on trial
  IS_ON_TRIAL             TYPE C VALUE 'X', "#EC NOTEXT
* Account Environment - US/EU
  PROD_ACCOUNT_ENV(5) TYPE C VALUE 'EU',"#EC NOTEXT
* Prod AccountId
  PROD_ACCOUNT_ID(20) TYPE C VALUE '6719', "#EC NOTEXT
* Prod AccountName
  PROD_ACCOUNT_NAME(50)        TYPE C
  VALUE 'GrupoHinojosa_S4Convert', "#EC NOTEXT
* ETL Hash Value
  ETL_HASH(50)                 TYPE C
  VALUE '1d0fcbf01ce27b18120264ada13b1560', "#EC NOTEXT
* Generation Date
  ETL_GEN_DATE(8)              TYPE C VALUE
  '20240607', "#EC NOTEXT
* Account Hash
  ACCOUNT_UID(50)              TYPE C VALUE
  '7fe83502_18ff2332aef__3453', "#EC NOTEXT
* Rest service address
  C_REST_SERVICE_ADDRESS(150)  TYPE C VALUE
  'http://emea.panaya.com', "#EC NOTEXT
* Rest service suffix
  C_REST_SERVICE_SUFFIX(50)    TYPE C VALUE
  '/rest/public/etl/getSapExtractorData', "#EC NOTEXT
* Rest validation path
  C_REST_VALIDATION_PATH(50)   TYPE C VALUE
  'app/general/pages/publicApi/', "#EC NOTEXT
* Rest service validation suffix
  C_REST_VALIDATION_SUFFIX(50) TYPE C VALUE
  'etlValidationAppIndex.html#/displayEtlStatus?', "#EC NOTEXT
* Target SAP S/4HANA Version
  C_TARGET_S4HANA_VERSION(20)  TYPE C VALUE
  '73555000103300011057', "#EC NOTEXT
  C_TARGET_S4HANA_VERSION_DESC(100)  TYPE C VALUE
    'SAP S/4HANA 2023 01 (02/2024) FPS', "#EC NOTEXT

*-------------------------------------------------------------------
*-IF YOU ADD A FLAG PLEASE MAKE SURE YOU ADD IT TO
*-ADD_RUN_PARAMETERS and to ADD_DOCUMENT_HEADER messages
*-------------------------------------------------------------------
  IS_PATCH                     TYPE C VALUE ' ',
  CUST_EDIT_PARAMS             TYPE C VALUE 'X',
  OVERRIDE_PARAM_DEFAULTS      TYPE C VALUE 'X',
  EXTRACT_OMEGA_MASTER_DATA    TYPE C VALUE '',
  USERS_HR_DATA_BULK_SIZE      TYPE I VALUE 500,
  EXTRACT_UPL_DATA             TYPE C VALUE ' ',
  GET_ONLY_CUST_UPL            TYPE C VALUE ' ',
  IA_DATA_ONLY                 TYPE C VALUE ' ',
  EXTRACT_PROXY_CALLERS        TYPE C VALUE 'X',
  EXTRACT_SCI_HANA_CHECK       TYPE C VALUE 'X',
  EXTRACT_SI_S4_CHECK          TYPE C VALUE ' ',
  EXTRACT_ATC_S4_CHECK         TYPE C VALUE 'X',
  EXTRACT_HN_SIZING_CHECK      TYPE C VALUE ' ',
  EXTRACT_WD_METHOD_CODE       TYPE C VALUE 'X',
  MAX_IDOC_USAGE_PAIRS         TYPE I VALUE 1000,
  MAX_IDOC_USAGE_TIME          TYPE SY-UZEIT VALUE '004500', "hhmmss
  MAX_PROXY_USAGE_TIME         TYPE SY-UZEIT VALUE '004500', "hhmmss
  LOCAL_IDOC_USAGE_TIME        TYPE SY-UZEIT VALUE '004500', "hhmmss
  LOCAL_PROXY_USAGE_TIME       TYPE SY-UZEIT VALUE '004500', "hhmmss
  MAX_PROXIES_VIA_RFC          TYPE I VALUE 100,
  LAYOUTS_USAGE_DAYS_SLICE     TYPE I VALUE 30,
  LAYOUTS_USAGE_DAYS_SLICE_RFC TYPE I VALUE 7,
  TESTING_DATA_ONLY            TYPE C VALUE ' ',
  TBOM_EXTRACTION              TYPE C VALUE ' ',
  EXTRACT_LAYOUT_USAGE_DAYS    TYPE I VALUE 365,
  EXTRACT_USER_FORMATS         TYPE C VALUE '',
  ADD_ABAP_QUERIES             TYPE C VALUE ' ',
  ADD_GEN_PROGRAMS             TYPE C VALUE ' ',
  MAX_MAINS                    TYPE I VALUE 500,
  WARN_TABLE_SIZE              TYPE I VALUE 100000,
  UPL_MONTH_NUMBER             TYPE I VALUE 12,
  ENABLE_AUTO_UPLOAD           TYPE C VALUE ' ',

* Extract full usage data - ST03N. To turn on the extraction
* of the full usage data set the SPACE to 'X' as follows:
  EXTRACT_FULL_USAGE           TYPE C VALUE ' ',

* Extract workflow data. To turn on the extraction of the
* workflow data set the SPACE to 'X' as follows:
  EXTRACT_WORKFLOW_DATA        TYPE C VALUE ' ',

* Show error for not Production RFC. To turn of the error
* please set the SPACE to 'X' as follows:
  DONT_SHOW_ERROR_ON_RFC       TYPE C VALUE 'X',

* Rqeuire restriction for security
  REQUIRE_SECURITY             TYPE C VALUE ' '.

* constants that the user can change through the params screen
DATA:
  COMPRESS_RESULT_FILE          TYPE C VALUE ' ',
  EXTRACT_USER_DATA             TYPE C VALUE 'X',
  SHOW_LOGIN_NAME               TYPE C VALUE 'X',
  SHOW_SERVERS_NAME             TYPE C VALUE 'X',
  GET_AGR_USERS_LOCAL           TYPE C VALUE 'X',
  GET_AGR_USERS_RFC             TYPE C VALUE 'X',
  EXTRACT_SOLAR_DATA            TYPE C VALUE ' ',
  NO_WEB_USAGE                  TYPE C VALUE ' ',
  EXTRACT_PROXY_DATA            TYPE C VALUE 'X',
  EXTRACT_IDOCS_USAGE           TYPE C VALUE 'X',
  EXTRACT_LAYOUTS_USAGE         TYPE C VALUE 'X',
  EXTRACT_DEBUG                 TYPE C VALUE ' ',
  AGR_USERS_ROW_COUNT           TYPE I VALUE 50000,
  WHERE_USED_MAX_LINES          TYPE INT4 VALUE 5000000,
  MONTHS_BACK_USAGE             TYPE I VALUE 3,
  USAGE_EXTRACTION_DAYS         TYPE I VALUE 730,
  EXTRACT_TOTAL_INSTANCE        TYPE C VALUE ' ',
  DISABLE_SYNTAX_CHECK          TYPE C VALUE ' ',
  DISABLE_GUI_STATUS_EXTRACT    TYPE C VALUE ' ',
  CRS_EXTRACTION_MONTHS         TYPE I VALUE 18,
  PROD_CRS_EXTRACTION_MONTHS    TYPE I VALUE 36,
  ROLES_EXTRACTION_PERIOD       TYPE I VALUE 6,
  SKIP_VALIDATION               TYPE C VALUE ' ',
  EXTRACT_WD_DATA               TYPE C VALUE 'X',
  EXTRACT_WD_SYNTAX_CHECK       TYPE C VALUE 'X',
  EXTRACT_USER_HR_DATA          TYPE C VALUE '',
  NO_SUET_DATA                  TYPE C VALUE ' ',
  EXTRACT_LAYOUTS_USAGE_VIA_RFC TYPE C VALUE 'X',
  EXTRACT_SCI_HANA_PERFORMANCE  TYPE C VALUE 'X',
  EXTRACT_TEXT_ELEMENTS         TYPE C VALUE 'X',
  GET_USAGE_DELTA               TYPE C VALUE 'X',
  SI_UPLOAD_EXISTS              TYPE C VALUE ' ',
  EXTRACT_FIORI_DATA            TYPE C VALUE 'X',
  EXTRACT_SUSG_DATA             TYPE C VALUE ' ',
  EXTRACT_WHERE_USED_LIST       TYPE C VALUE 'X',

* Require SOLMAN RFC. To turn of the error
* please set the 'X' to SPACE as follows:
  REQUIRE_SOLMAN_RFC            TYPE C VALUE ' '.

TYPES:
  BEGIN OF TY_EXTRACT_USAGE_DATE,
    SYSTEM_NAME          TYPE SYSYSID,
    LAST_EXTRACTION_DATE TYPE DATUM,
  END OF TY_EXTRACT_USAGE_DATE,

  TT_EXTRACT_USAGE_DATE TYPE HASHED TABLE OF TY_EXTRACT_USAGE_DATE
                        WITH UNIQUE KEY SYSTEM_NAME.

TYPES: BEGIN OF FILE_TYPE,
         DIRNAME     TYPE DIRNAME_AL11,
         NAME        TYPE FILENAME_AL11,
         TYPE(10)    TYPE C,
         LEN(8)      TYPE P,
         OWNER(8)    TYPE C,
         MTIME(6)    TYPE P,
         MODE(9)     TYPE C,
         USEABLE(1)  TYPE C,
         SUBRC(4)    TYPE C,
         ERRNO(3)    TYPE C,
         ERRMSG(40)  TYPE C,
         MOD_DATE    TYPE D,
         MOD_TIME(8) TYPE C,
         SEEN(1)     TYPE C,
         CHANGED(1)  TYPE C,
       END OF FILE_TYPE,

       BEGIN OF FILE_LIST_HELP,
         NAME        TYPE FILENAME_AL11,
         LEN(8)      TYPE P,
         OWNER(8)    TYPE C,
         MTIME(6)    TYPE P,
         MOD_DATE    TYPE D,
         MOD_TIME(8) TYPE C,
         SEEN(1)     TYPE C,
         CHANGED(1)  TYPE C,
       END OF FILE_LIST_HELP,

       FILE_LIST_TYPE TYPE TABLE OF FILE_TYPE,
       FILE_LIST_TABLE_HELP TYPE TABLE OF FILE_LIST_HELP.

DATA: GT_USAGE_EXTRACT_DATES    TYPE TT_EXTRACT_USAGE_DATE,
      GT_USAGE_EXTRACT_DATES_WS TYPE TT_EXTRACT_USAGE_DATE,
      USG_EXT_DATES_WA          LIKE LINE OF GT_USAGE_EXTRACT_DATES.



** End of Account's Constants **

** General ETL Constants **
CONSTANTS:
  ROOT_ELEMENT_NAME(30)        TYPE C VALUE 'ROOT_ELEMENT',
  BUFFER_MAX_SIZE              TYPE I VALUE 10000000,
  CDATA_END_REPLACE(15)        TYPE C VALUE
  '&xml_cdata_end&', "#EC NOTEXT
  SKIP_EMPTY_TAGS              TYPE C VALUE 'X',
  ENCODING(10)                 TYPE C VALUE 'UTF-8',
  ALLOWED_CHARS(58)            TYPE C VALUE
  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_^$~!#%&-{}()@`''.\/:',
  ORIGIN_SOURCE                TYPE I VALUE 1,
  ORIGIN_TARGET                TYPE I VALUE 2,
  SAPRL_46C                    TYPE SAPRL VALUE '46C',
  EHP7_RELEASE                 TYPE SAPRELEASE VALUE '617',
  MAX_SELECT_OPTIONS           TYPE I VALUE 1000,
  MAX_SEL_OPT_LARGE_DATA       TYPE I VALUE 500,
  SCI_MAX_LINES                TYPE INT4 VALUE 5000000,
* Test mode definiton - do not change
  PANAYA_TEST_MODE             TYPE C VALUE 'X',

  C_PANAYA_PRD_RFC(10)         TYPE C VALUE 'PANAYA_PRD',
  C_PANAYA_BW_RFC(10)          TYPE C VALUE 'PANAYA_BW',
  C_PANAYA_SM_RFC(10)          TYPE C VALUE 'PANAYA_SM',
  C_PANAYA_ATC_RFC(10)         TYPE C VALUE 'PANAYA_ATC',
  C_PANAYA_SI_RFC(10)          TYPE C VALUE 'PANAYA_SI',

  C_FUNCTIONAL_DB(30)          TYPE C VALUE 'FUNCTIONAL_DB',
  C_FUNCTIONAL_DB_ADDITION(30) TYPE C VALUE 'FUNCTIONAL_DB_ADDITION',
  C_PERFORMANCE_DB(30)         TYPE C VALUE 'PERFORMANCE_DB',
  C_S4HANA_READINESS(30)       TYPE C VALUE 'S4HANA_READINESS',

  C_FRAMEWORK_NOTE             TYPE STRING VALUE '2399707',
  C_CHK_CLAS_TCI_NOTE          TYPE STRING VALUE '2502552',

  C_ATC_DAYS_CHECK             TYPE NUMC2 VALUE 30,
  C_SCI_DAYS_CHECK             TYPE NUMC2 VALUE 30.

** Rest Validation Constants **
CONSTANTS:
  C_TRUE_STRING(4)  TYPE C VALUE 'true',
  C_FALSE_STRING(5) TYPE C VALUE 'false'.
CONSTANTS:
  C_LAST_USG_EXTRAT_BEG_TAG(17)    TYPE C
  VALUE '<usageExtraction>', "#EC NOTEXT
  C_LAST_USG_EXTRAT_END_TAG(18)    TYPE C
   VALUE '</usageExtraction>', "#EC NOTEXT
  C_SYSTEM_NAME_BEGIN_TAG(8)       TYPE C
  VALUE '<system>', "#EC NOTEXT
  C_SYSTEM_NAME_END_TAG(9)         TYPE C
  VALUE '</system>', "#EC NOTEXT
  C_USG_EXTRACT_D_BEGIN_TAG(6)     TYPE C
  VALUE '<date>', "#EC NOTEXT
  C_USG_EXTRACT_D_END_TAG(7)       TYPE C
  VALUE '</date>', "#EC NOTEXT
  C_SAP_HASHED_VER_BEGIN_TAG(18)   TYPE C
  VALUE '<sapHashedVersion>', "#EC NOTEXT
  C_SAP_HASHED_VER_END_TAG(19)     TYPE C
  VALUE '</sapHashedVersion>', "#EC NOTEXT
  C_IS_VER_ABOVE_MINIMAL_BEGIN(23) TYPE C VALUE
    '<isVersionAboveMinimal>', "#EC NOTEXT
  C_IS_VER_ABOVE_MINIMAL_END(24)   TYPE C VALUE
    '</isVersionAboveMinimal>', "#EC NOTEXT
  C_IS_CODE_MATCH_BEGIN(13)        TYPE C
  VALUE '<isCodeMatch>', "#EC NOTEXT
  C_IS_CODE_MATCH_END(14)          TYPE C
  VALUE '</isCodeMatch>', "#EC NOTEXT

  C_ERROR_VERSION_MSG_JOB(58)      TYPE C VALUE
'You are using a version below the minimal required version',"#EC NOTEXT

  C_ERROR_VERSION_MSG1(28)         TYPE C VALUE
  'You are using a version that', "#EC NOTEXT
  C_ERROR_VERSION_MSG2(37)         TYPE C VALUE
   'is below the minimal required version', "#EC NOTEXT
  C_ERROR_VERSION_ABORT(27)        TYPE C VALUE
  'Extraction will be aborted' , "#EC NOTEXT

  C_UPDATE_MSG(44)                 TYPE C VALUE
  'Please update your code from the Panaya Site', "#EC NOTEXT
  C_VERSION_MISMATCH_MSG(43)       TYPE C VALUE
  'You are using an outdated extractor version'. "#EC NOTEXT


* ETL Notifications Constants:
CONSTANTS: NOTIFICATION_PARAMS_DELIMITER(3) TYPE C VALUE '~*~'.
CONSTANTS: IDOCS_USAGE_TIME_LIMIT(25)       TYPE C
              VALUE 'IDOCS_USAGE_TIME_LIMIT',
           IDOCS_USAGE_AGGREGATED(25)       TYPE C
              VALUE 'IDOCS_USAGE_AGGREGATED',
           PROXIES_USAGE_TIME_LIMIT(25)     TYPE C
              VALUE 'PROXIES_USAGE_TIME_LIMIT',
           PROXIES_USAGE_RFC_LIMIT(25)      TYPE C
              VALUE 'PROXIES_USAGE_RFC_LIMIT',
           AGR_USERS_COUNT_DIFF(25)         TYPE C
              VALUE 'AGR_USERS_COUNT_DIFF',
           VALIDATION_CONNECTION_ERROR(27)  TYPE C
                VALUE 'VALIDATION_CONNECTION_ERROR',
           VALIDATION_VERSION_MISMATCH(27)  TYPE C
                VALUE 'VALIDATION_VERSION_MISMATCH',
           VALIDATION_MINIMAL_VER_ERROR(28) TYPE C
               VALUE 'VALIDATION_MINIMAL_VER_ERROR',
           VALIDATION_SUCCESS(18)           TYPE C
                         VALUE 'VALIDATION_SUCCESS',
           VALIDATION_MANUALLY_PRESSED(40)  TYPE C
                VALUE 'VALIDATION_MANUALLY_PRESSED',
           SCI_HANA_ERROR_EXECUTE(23)       TYPE C
                     VALUE 'SCI_HANA_ERROR_EXECUTE',
           SCI_HANA_IS_NOT_CAPABLE(24)      TYPE C
                    VALUE 'SCI_HANA_IS_NOT_CAPABLE',
           ATC_S4_ERROR_EXECUTE(23)         TYPE C
                       VALUE 'ATC_S4_ERROR_EXECUTE',
           HANA_SIZING_ERROR_EXECUTE(25)    TYPE C
                  VALUE 'HANA_SIZING_ERROR_EXECUTE'.



TABLES: TFDIR, FUNCT, TFTIT, PROGDIR, SSCRFIELDS.
* Types definition


*---------------------------------------------------------------------*
*  Global Data definition
*---------------------------------------------------------------------*
TABLES: TDEVC, TRDIR, TADIR.

DATA: ACTIVE_INDUSTRY_SOLUTION(30) TYPE C VALUE SPACE.

DATA: G_SAPWORKDIR              TYPE SDOK_CHTRD,
      G_FILESIZE                TYPE I,
      G_IREF_ROOT_ELEM          TYPE REF TO IF_IXML_ELEMENT,
      G_IREF_PIXML              TYPE REF TO IF_IXML,
      G_IREF_PDOCUMENT          TYPE REF TO IF_IXML_DOCUMENT,
      G_IREF_PSTREAMFACTORY     TYPE REF TO IF_IXML_STREAM_FACTORY,
      GT_CONVERTED_DATA         TYPE XML_TAB_TYPE,
      G_FILE_APPEND_MODE        TYPE CHAR01 VALUE SPACE,
      G_OSTREAM                 TYPE REF TO IF_IXML_OSTREAM,
      G_BUFFER_ITAB             TYPE XML_TAB_TYPE,
      G_STRX                    TYPE XSTRING,
      GV_TABIX                  TYPE SY-TABIX,
      G_PROGS_ADDED_BY_SMODILOG TYPE PROG_TAB_TYPE WITH HEADER LINE,
      G_VANILLA_PROGRAMS        TYPE VANILLA_PROG_TAB_TYPE
          WITH HEADER LINE,
      NEW_LINE                  TYPE STRING,
      CURR_OBJECT_TYPE          TYPE I,
      PERCENTAGE                TYPE P DECIMALS 2,
      OBJ_PERC                  TYPE P DECIMALS 2,
      SAPWORKDIR                TYPE SDOK_CHTRD,
      NEW_SAPWORKDIR            TYPE SDOK_CHTRD,
      FILENAME                  LIKE RLGRAP-FILENAME,
      NAMESPACES                TYPE TABLE OF TRNSPACET,
      NAMESPACE                 LIKE LINE OF NAMESPACES,
      STAT_EXCLUDE              TYPE TABLE OF SY-UCOMM,
      ERROR(20)                 TYPE C,
      PAC_SIZE                  TYPE I,
      REST_MAJOR_VERSION_ERR    TYPE FLAG,
      REST_VERSION_MISMATCH_ERR TYPE FLAG,

* If fallback is active, connection to rest service failed
      REST_FALLBACK_ACTIVE      TYPE FLAG,
      REST_CONVERTED_ETL_DATE   TYPE DATUM.

DATA: SEL_FILENAME      TYPE STRING,
      PATH              TYPE STRING,
      GV_BACK_PATH      TYPE STRING,
      FULLPATH(128)     TYPE C,
      INITIAL_DIRECTORY TYPE STRING,
      DEFAULT_EXTENSION TYPE STRING,
      DEFAULT_FILENAME  TYPE STRING,
      FILE_FILTER       TYPE STRING,
      USER_ACTION       TYPE I,
      NO_USAGE.

* Development Class Objects list
DATA: GT_TADIR             TYPE TABLE OF TADIR,
      GS_TADIR             LIKE LINE OF GT_TADIR,
      GS_OBJECTLIST        TYPE RSEUI_SET,
      GT_OBJ_FUNC          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_PROG          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_TYPEPOOL      TYPE TABLE OF RSEUI_SET,
      GT_OBJ_TRNS          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_LGDB          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_MESG          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_TABL          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_VIEW          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_DELM          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_CTAB          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_TTYP          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_DOMN          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_TYPE          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_CLAS          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_APPL          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_UEXT          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_SSFO          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_FORM          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_OSOA_D        TYPE TABLE OF RSEUI_SET,
      GT_OBJ_SHI3          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_SXCI          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_WEBI          TYPE TABLE OF RSEUI_SET,
      GT_OBJ_ENHO          TYPE TABLE OF RSEUI_SET,

      GT_ETL_MESSAGE       TYPE TABLE OF ETL_MESSAGE_TYPE
          WITH HEADER LINE,
      GT_ETL_JOBLOG        TYPE TABLE OF ETL_MESSAGE_TYPE
          WITH HEADER LINE,
*     Messages from selection screen are saved in GT_SCR_MESSAGE and
*     appended to GT_ETL_MESSAGE because in START-OF-SELECTION we clean
*     up GT_ETL_MESSAGE and we want to keep the messages added in
*     AT SELECTION-SCREEN events.
      GT_SCR_MESSAGE       TYPE TABLE OF ETL_MESSAGE_TYPE
          WITH HEADER LINE,
      GT_ETL_TIME_STAT     TYPE TABLE OF ETL_TIME_STATS_TYPE
          WITH HEADER LINE,
      GT_ETL_NOTIFICATIONS TYPE TABLE OF TY_ETL_NOTIFICATION,
      GT_MODIF             TYPE TABLE OF SMODILOG WITH HEADER LINE,
      MODIFIED_OBJECTS     TYPE TABLE OF MODIFIED_OBJECT
          WITH HEADER LINE,
      ABAP_QUERY_PROGS     TYPE TABLE OF RSEUI_SET WITH HEADER LINE,
      L_FILENAME           TYPE STRING,
      FILE_EXISTS(1)       TYPE C,
      LEN                  TYPE I,
      FILE_LEN             TYPE I,
      STARTTIME            TYPE AS4TIME,
      STARTDATE            TYPE DATUM,
      RFC_SYSID            TYPE SYSYSID,
      RFC_SAPRL            TYPE SYSAPRL,
      SM_SYSID             TYPE SYSYSID,
      SM_SAPRL             TYPE SYSAPRL,
      SERVERS              TYPE TABLE OF MSXXLIST,
      TEMP_FILENAME        TYPE RLGRAP-FILENAME,
      TEMP_FORE_FILENAME   TYPE STRING,
      TEMP_BACK_FILENAME   LIKE RLGRAP-FILENAME,
      SUCC_MESS            TYPE STRING,
      LAST_CHAR            TYPE C,
      ERROR_MSG            TYPE STRING,
      GT_RFCS              TYPE STANDARD TABLE OF RFCDISPLAY.

DATA: LT_TDEVC  TYPE TABLE OF TDEVC,
      LS_TDEVC  TYPE TDEVC,
      LT_TDEVCT TYPE TABLE OF TDEVCT.

DATA: ANSWER(1)        TYPE C,
      QUESTION         TYPE STRING,
      RFC_DATA         LIKE RFCSI,
      RFC_MANDT        LIKE RFCDISPLAY-RFCCLIENT,
      RFC_USER         LIKE RFCDISPLAY-RFCUSER,
      SYSTEM_SEPERATOR TYPE C,
      GC_SM_RFC        LIKE RFCDES-RFCDEST,
      GV_BW_RFC        LIKE RFCDES-RFCDEST VALUE C_PANAYA_BW_RFC,
      GV_LOGSYS        TYPE LOGSYS.

DATA: GT_BTE_UE TYPE TABLE OF T_BTE_UE.

DATA: G_EXTRACT_UPL.

DATA: G_IS_EHP7                      TYPE FLAG VALUE SPACE,
      G_IS_CAPABLE_EXTRACT_SCI_HANA  TYPE FLAG,
      G_IS_CAN_SCI_HANA_PERFORMANCE  TYPE FLAG,
      G_IS_CAPABLE_EXTRACT_SI_CHECKS TYPE FLAG,
      G_OLD_EXCEL_FUNC_DB            TYPE STRING,
      G_OLD_EXCEL_FUNC_DB_ADD        TYPE STRING,
      G_OLD_EXCEL_PER_DB             TYPE STRING,
      G_FULLNAME_FUNC_DB             TYPE STRING,
      G_FULLNAME_FUNC_DB_ADD         TYPE STRING,
      G_FULLNAME_PER_DB              TYPE STRING,
      G_AT_RFC                       TYPE STRING.

DATA: GT_NEXT_ORDER(5)       TYPE N VALUE 0.
DATA: GT_NEXT_ORDER_JOBLOG(5)       TYPE N VALUE 0.

DATA: C_ERROR_VERSION_MSG_FULL(66) TYPE C.
CONCATENATE 'You are using a version that is below '        "#EC NOTEXT
      'the minimal required version'                        "#EC NOTEXT
      INTO C_ERROR_VERSION_MSG_FULL.

RANGES: CUSTOMER_OBJECTS FOR DD03L-PRECFIELD,
        CUST_NAMESPACE_RNG FOR TADIR-OBJ_NAME,
        G_APP_STRUC FOR TADIR-OBJ_NAME,
        G_INC_STRUC FOR TADIR-OBJ_NAME,
        G_VIEW_WITH_AST FOR TADIR-OBJ_NAME,
        EXCL_NAMESPACES FOR TDEVC-NAMESPACE,
        THIRD_PARTY_NS FOR TDEVC-NAMESPACE,
        G_CUST_PROGS FOR TRDIR-NAME,
        G_TABNAME_INDEX FOR DD02L-TABNAME.

*---------------------------------------------------------------------*
*   Selection Screen
*---------------------------------------------------------------------*

SELECTION-SCREEN BEGIN OF SCREEN 101 AS SUBSCREEN.
* Objects
SELECTION-SCREEN BEGIN OF BLOCK B1.

* Displayed only if connection to internet failed
SELECTION-SCREEN BEGIN OF BLOCK BX WITH FRAME TITLE TITL9.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(5) ICON1.
SELECTION-SCREEN COMMENT 7(70) WARN_VAL.
SELECTION-SCREEN:  END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(30) BUT3 USER-COMMAND VALID.
SELECTION-SCREEN END OF LINE.


SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(5) ICON2.
SELECTION-SCREEN COMMENT 7(70) WARN1.
SELECTION-SCREEN:  END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 7(70) WARN2.
SELECTION-SCREEN:  END OF LINE.

SELECTION-SCREEN END OF BLOCK BX.

* Test Compress
SELECTION-SCREEN BEGIN OF BLOCK ZP WITH FRAME TITLE TZIP.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(5) ICON_CMP MODIF ID CMP.
SELECTION-SCREEN COMMENT 7(70) T_CMPRSW MODIF ID CMP.
SELECTION-SCREEN:  END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(30) BUTZ USER-COMMAND TEST_COMPRESS
  MODIF ID CMP.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK ZP.

* XML File type
SELECTION-SCREEN BEGIN OF BLOCK B2 WITH FRAME TITLE TITL2.

* Local file
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_FILE FOR FIELD P_FILEN.
SELECTION-SCREEN POSITION 25.
PARAMETERS  P_FILEN(128) TYPE C.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN ULINE /4(66).

* Usage only
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS FULLEXT RADIOBUTTON GROUP RDEX DEFAULT 'X' USER-COMMAND FTYP.
SELECTION-SCREEN COMMENT 4(34) TIT_FULL FOR FIELD FULLEXT.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS USAGEONL  RADIOBUTTON GROUP RDEX.
SELECTION-SCREEN COMMENT 4(34) TIT_US FOR FIELD USAGEONL.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN ULINE /4(66).

* Server file
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS R_BACK RADIOBUTTON GROUP RAD2 DEFAULT 'X' USER-COMMAND FTYP.
SELECTION-SCREEN COMMENT 4(34) TIT_BACK FOR FIELD R_BACK.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_BKDR FOR FIELD P_BACK.
SELECTION-SCREEN POSITION 25.
PARAMETERS P_BACK LIKE RLGRAP-FILENAME MODIF ID SRV.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  R_FORE  RADIOBUTTON GROUP RAD2.
SELECTION-SCREEN COMMENT 4(34) TIT_FORE FOR FIELD R_FORE.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_FRDR FOR FIELD P_FORE.
SELECTION-SCREEN POSITION 25.
PARAMETERS  P_FORE  LIKE RLGRAP-FILENAME  MODIF ID LCL.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK B2.

* RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B3 WITH FRAME TITLE TITL3.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(50) TEXT1 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(40) TEXT2 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) TEXT0 FOR FIELD P_RFCDES.
PARAMETERS: P_RFCDES LIKE RFCDES-RFCDEST DEFAULT C_PANAYA_PRD_RFC
*OBLIGATORY
.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B3.

* System's Roles
SELECTION-SCREEN BEGIN OF BLOCK B7 WITH FRAME TITLE TITL7.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(22) TEXT7 FOR FIELD P_ROLE MODIF ID TRL.
PARAMETERS: P_ROLE(18) AS LISTBOX VISIBLE LENGTH 18 OBLIGATORY
              MODIF ID TRL.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.

SELECTION-SCREEN: COMMENT 6(22) TEXT8 FOR FIELD P_TRROLE MODIF ID TRL.
PARAMETERS: P_TRROLE(18) AS LISTBOX VISIBLE LENGTH 18 OBLIGATORY
              MODIF ID TRL.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B7.

* SolMan RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B5 WITH FRAME TITLE TITL5.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:P_SET_SM TYPE FLAG USER-COMMAND SET_SM.
SELECTION-SCREEN: COMMENT 2(1) BLANK3 FOR FIELD P_SET_SM.
SELECTION-SCREEN: COMMENT 6(51) TEXT3.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) TEXT4 FOR FIELD P_SM_RFC.
PARAMETERS: P_SM_RFC LIKE RFCDES-RFCDEST DEFAULT GC_SM_RFC.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN END OF BLOCK B5.

* BW RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B6 WITH FRAME TITLE TITL6.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:P_SET_BW TYPE FLAG  USER-COMMAND SET_BW.
SELECTION-SCREEN: COMMENT 2(1) BLANK5 FOR FIELD P_SET_BW.
SELECTION-SCREEN: COMMENT 6(51) TEXT5.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) TEXT6 FOR FIELD P_BW_RFC.
PARAMETERS: P_BW_RFC LIKE RFCDES-RFCDEST DEFAULT GV_BW_RFC.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN END OF BLOCK B6.

**********************************************************************
* SUSG Zip Attachment block
**********************************************************************

SELECTION-SCREEN BEGIN OF BLOCK BUSG WITH FRAME TITLE TSUSG.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 6(18) T_SUSG MODIF ID USG FOR FIELD P_SUSG.
PARAMETERS P_SUSG(140) TYPE C VISIBLE LENGTH 32
MODIF ID USG LOWER CASE.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN COMMENT 1(60) T_E_SUSG MODIF ID USG.

PARAMETERS PSRV_SUS(140) TYPE C NO-DISPLAY.

SELECTION-SCREEN SKIP.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(10) UP_SUSG USER-COMMAND UPLOAD_SUSG
MODIF ID USG.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK BUSG.

**********************************************************************
* Execution Simplification Items
**********************************************************************
SELECTION-SCREEN BEGIN OF BLOCK B_SI WITH FRAME TITLE TITL_SI.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS CREUSESI TYPE CHAR1 AS CHECKBOX DEFAULT SPACE MODIF ID SIC
  USER-COMMAND SI_REUSE.
SELECTION-SCREEN COMMENT 3(65) TREUSESI MODIF ID SIC FOR FIELD CREUSESI.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN ULINE MODIF ID SIC.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT (65) TEXT_SI1  MODIF ID SIR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) T_SI_RFC FOR FIELD P_SI_RFC
  MODIF ID SIR.
PARAMETERS: P_SI_RFC LIKE RFCDES-RFCDEST MODIF ID SIR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT (70) T_SI_NO1 MODIF ID SIR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT (70) T_SI_NO2 MODIF ID SIR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT (70) T_SI_NO3 MODIF ID SIR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT (70) T_SI_NO4 MODIF ID SIR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (65) C_CUR_ST MODIF ID SIR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (65) C_CUR_NT MODIF ID SIR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (65) C_TCI_NT MODIF ID SIR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK B_SI.

**********************************************************************
* Execution S4Hana ATC Extractor
**********************************************************************
SELECTION-SCREEN BEGIN OF BLOCK BS4X WITH FRAME TITLE TITL_S4.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS: C_ATCRES TYPE C RADIOBUTTON GROUP ATC MODIF ID ATC
                      USER-COMMAND HANA_ATC DEFAULT 'X'.
SELECTION-SCREEN: COMMENT 3(37) T_ATCRES  MODIF ID ATC
FOR FIELD C_ATCRES.
PARAMETERS: C_ATCEXL TYPE C RADIOBUTTON GROUP ATC MODIF ID ATC.
SELECTION-SCREEN: COMMENT 43(62) T_ATCEXL
MODIF ID ATC FOR FIELD C_ATCEXL.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: COMMENT 43(62) T_ATCEX2
MODIF ID ATC.

SELECTION-SCREEN: ULINE MODIF ID ATC.

**********************************************************************
* Choose from previously executed list
**********************************************************************

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) T_AT_RFC FOR FIELD P_AT_RFC
  MODIF ID ATR.
PARAMETERS: P_AT_RFC LIKE RFCDES-RFCDEST MODIF ID ATR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(44) T_AT_VAR MODIF ID ATR.
SELECTION-SCREEN POSITION 46.
SELECTION-SCREEN PUSHBUTTON (10) BTN_ATC USER-COMMAND ATC_VAR
  MODIF ID ATR.
SELECTION-SCREEN POSITION 57.
SELECTION-SCREEN: COMMENT (30) T_AT_TXT MODIF ID ATR.
SELECTION-SCREEN END OF LINE.

PARAMETERS: P_AT_DAT TYPE DATS NO-DISPLAY.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(18) T_AT_GID FOR FIELD P_AT_GID
MODIF ID HID.
PARAMETERS: P_AT_GID TYPE CHAR32 MODIF ID HID.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 57(60) T_AT_DAT MODIF ID ERR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 57(60) T_AT_SY1 MODIF ID ERR.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 57(60) T_AT_SY2 MODIF ID ERR.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK BS4X.

**********************************************************************
* Get HANA sizing report results
**********************************************************************
SELECTION-SCREEN BEGIN OF BLOCK HNAS WITH FRAME TITLE TTL_HANA.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 6(26) T_HN_SIZ
  FOR FIELD P_HN_SIZ MODIF ID HNS.
PARAMETERS  P_HN_SIZ LIKE RLGRAP-FILENAME MODIF ID HNS.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS PSRV_HN(128) TYPE C NO-DISPLAY.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 6(10) UPL_SIZ
  USER-COMMAND UPL_HANA_SIZ MODIF ID HNS.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK HNAS.

**********************************************************************

* Execution Hana Code Inspector results
SELECTION-SCREEN BEGIN OF BLOCK B8 WITH FRAME TITLE TITL8.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  R_SCIHAS  RADIOBUTTON GROUP HANA MODIF ID B8
                      USER-COMMAND HANA_SCI DEFAULT 'X'.
SELECTION-SCREEN COMMENT 3(37) TSCI_HAS MODIF ID B8
FOR FIELD R_SCIHAS.
PARAMETERS  R_SCIXLS  RADIOBUTTON GROUP HANA MODIF ID B8.
SELECTION-SCREEN COMMENT 43(24) TSCI_XLS MODIF ID B8
FOR FIELD R_SCIXLS.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(4)  ISCI_W MODIF ID SHC.
SELECTION-SCREEN COMMENT 5(73) TSCI_W MODIF ID SHC.
SELECTION-SCREEN:  END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 5(73) TSCI_W1 MODIF ID SHC.
SELECTION-SCREEN:  END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 5(73) TSCI_W2 MODIF ID SHC.
SELECTION-SCREEN:  END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(38) TXLS_FD MODIF ID XLS
FOR FIELD PXLS_FD.
SELECTION-SCREEN POSITION 42.
PARAMETERS  PXLS_FD(128) TYPE C  MODIF ID XLS.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(38) TXLS_FDA MODIF ID XLS
FOR FIELD PXLS_FDA.
SELECTION-SCREEN POSITION 42.
PARAMETERS  PXLS_FDA(128) TYPE C  MODIF ID XLS .
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(38) TXLS_PER MODIF ID XLS
FOR FIELD PXLS_PER.
SELECTION-SCREEN POSITION 42.
PARAMETERS  PXLS_PER(128) TYPE C MODIF ID XLS .
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(10) UP_EXCEL USER-COMMAND UPLOAD_XLS MODIF
 ID XLS.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS  PSRV_FD(128) TYPE C NO-DISPLAY.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS  PSRV_FDA(128) TYPE C NO-DISPLAY.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS  PSRV_PER(128) TYPE C NO-DISPLAY.
SELECTION-SCREEN: END OF LINE.

PARAMETERS: SCI_FD_D TYPE DATS NO-DISPLAY,
            SCI_FDAD TYPE DATS NO-DISPLAY,
            SCI_PERD TYPE DATS NO-DISPLAY.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(60) TSCI1DAT MODIF ID ERR.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(60) TSCI2DAT MODIF ID ERR.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(60) TSCI3DAT MODIF ID ERR.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(37) TSCI_USR MODIF ID SCI
FOR FIELD SCI_USR.
SELECTION-SCREEN POSITION 45 .
PARAMETERS: SCI_USR  TYPE SCI_DYNP-USR DEFAULT SY-UNAME MODIF ID SCI.

SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.

SELECTION-SCREEN COMMENT 1(34) TIT_FD MODIF ID SCI
FOR FIELD SCI_FD.
SELECTION-SCREEN POSITION 45.
PARAMETERS: SCI_FD  TYPE SCI_DYNP-INSP MODIF ID SCI.
PARAMETERS: SCI_FDV TYPE SCI_DYNP-INSP_V MODIF ID SCI.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(43) TIT_FDA MODIF ID SCI
FOR FIELD SCI_FDA.
SELECTION-SCREEN POSITION 45.
PARAMETERS: SCI_FDA  TYPE SCI_DYINSP-INSP MODIF ID SCI.
PARAMETERS: SCI_FDAV TYPE SCI_DYINSP-INSP_V MODIF ID SCI.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(43) TIT_PER MODIF ID SCI
FOR FIELD SCI_PER.
SELECTION-SCREEN POSITION 45.
PARAMETERS: SCI_PER  TYPE SCI_DY300-O_I1 MODIF ID SCI.
PARAMETERS: SCI_PERV TYPE SCI_DY300-O_I1_V MODIF ID SCI.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B8.

SELECT-OPTIONS: DEVCLASS FOR TDEVC-DEVCLASS.
PARAMETERS: VANILLA AS CHECKBOX DEFAULT ' '.
PARAMETERS: FIRSTBLK AS CHECKBOX DEFAULT ' '.
PARAMETERS: POPUP_OK AS CHECKBOX DEFAULT 'X'.

SELECTION-SCREEN END   OF BLOCK B1.
SELECTION-SCREEN END OF SCREEN 101.

SELECTION-SCREEN BEGIN OF SCREEN 102 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK B10 WITH FRAME TITLE B_PARAMS.

* Usage parameters block
SELECTION-SCREEN: BEGIN OF BLOCK B_USAGE WITH FRAME TITLE USAGE_T.

SELECTION-SCREEN: BEGIN OF LINE,
*     Usage period (days)
COMMENT (31) USGDAY_T FOR FIELD P_USGDAY.
PARAMETERS: P_USGDAY LIKE USAGE_EXTRACTION_DAYS DEFAULT
                     USAGE_EXTRACTION_DAYS.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Total instance usage data
  COMMENT (31) TOTINS_T FOR FIELD P_TOTINS.
PARAMETERS: P_TOTINS TYPE FLAG DEFAULT EXTRACT_TOTAL_INSTANCE.
*     Exclude web services usage
SELECTION-SCREEN COMMENT 39(32) WEBUSG_T FOR FIELD P_WEBUSG.
PARAMETERS: P_WEBUSG TYPE FLAG DEFAULT NO_WEB_USAGE.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Extract Layout usage
  COMMENT (31) LYOUTU_T FOR FIELD P_LYOUTU.
PARAMETERS: P_LYOUTU TYPE FLAG DEFAULT EXTRACT_LAYOUTS_USAGE.
*     Extract Layout usage via RFC
SELECTION-SCREEN COMMENT 39(32) LAYUSR_T FOR FIELD P_LAYUSR.
PARAMETERS: P_LAYUSR TYPE FLAG DEFAULT
                     EXTRACT_LAYOUTS_USAGE_VIA_RFC.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Extract Proxies data
  COMMENT (31) PROXYD_T FOR FIELD P_PROXYD.
PARAMETERS: P_PROXYD TYPE FLAG DEFAULT EXTRACT_PROXY_DATA.
*     Extract Idoc usage
SELECTION-SCREEN COMMENT 39(32) IDOCUS_T FOR FIELD P_IDOCUS.
PARAMETERS: P_IDOCUS TYPE FLAG DEFAULT EXTRACT_IDOCS_USAGE.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Get delta / full usage data
COMMENT (31) USGDLT_T FOR FIELD P_USGDLT.
PARAMETERS: P_USGDLT TYPE FLAG DEFAULT GET_USAGE_DELTA.

SELECTION-SCREEN COMMENT 39(32) SUSG_T FOR FIELD P_SUSG_P.
PARAMETERS: P_SUSG_P TYPE FLAG DEFAULT EXTRACT_SUSG_DATA AS
CHECKBOX USER-COMMAND UPDATE_PARAMS.

SELECTION-SCREEN: END OF LINE,
END OF BLOCK B_USAGE.

* Data parameters block
SELECTION-SCREEN: BEGIN OF BLOCK B_DATA WITH FRAME TITLE DATA_T,
  BEGIN OF LINE,
*     Full user names
    COMMENT (31) USERDA_T FOR FIELD P_USERDA.
PARAMETERS: P_USERDA TYPE FLAG DEFAULT EXTRACT_USER_DATA.
*     SAP users additional data
SELECTION-SCREEN COMMENT 39(32) USERHR_T FOR FIELD P_USERHR.
PARAMETERS: P_USERHR TYPE FLAG DEFAULT EXTRACT_USER_HR_DATA.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Mask user names
  COMMENT (31) LOGNAM_T FOR FIELD P_LOGNAM.
PARAMETERS: P_LOGNAM TYPE FLAG.
*     Mask server names
SELECTION-SCREEN COMMENT 39(32) SRVRNM_T FOR FIELD P_SRVRNM.
PARAMETERS: P_SRVRNM TYPE FLAG DEFAULT SHOW_SERVERS_NAME.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Roles usage-RFC to curr. Sys
  COMMENT (31) AGRUSL_T FOR FIELD P_AGRUSL.
PARAMETERS: P_AGRUSL TYPE FLAG DEFAULT GET_AGR_USERS_LOCAL.
*     Roles usage-RFC to diff. Sys
SELECTION-SCREEN COMMENT 39(32) AGRUSR_T FOR FIELD P_AGRUSR.
PARAMETERS: P_AGRUSR TYPE FLAG DEFAULT GET_AGR_USERS_RFC.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Solution Manager data
  COMMENT (31) SOLARD_T FOR FIELD P_SOLARD.
PARAMETERS: P_SOLARD TYPE FLAG DEFAULT EXTRACT_SOLAR_DATA.
*     Extract HANA performance
SELECTION-SCREEN COMMENT 39(32) SCIPRF_T FOR FIELD P_SCIPRF.
PARAMETERS: P_SCIPRF TYPE FLAG DEFAULT
                     EXTRACT_SCI_HANA_PERFORMANCE.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Extract WebDynpro data
  COMMENT (31) WDDATA_T FOR FIELD P_WDDATA.
PARAMETERS: P_WDDATA TYPE FLAG DEFAULT EXTRACT_WD_DATA.
*     Extract CSI WD checks
SELECTION-SCREEN COMMENT 39(32) WDSNTX_T FOR FIELD P_WDSNTX.
PARAMETERS: P_WDSNTX TYPE FLAG DEFAULT EXTRACT_WD_SYNTAX_CHECK.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
* Extract Fiori Data
COMMENT (31) UI5_T FOR FIELD P_UI5.
PARAMETERS: P_UI5 TYPE FLAG DEFAULT EXTRACT_FIORI_DATA.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Limit no. of Idoc/Proxies
  COMMENT (31) MNTHBC_T FOR FIELD P_MNTHBC.
PARAMETERS: P_MNTHBC LIKE MONTHS_BACK_USAGE DEFAULT
                     MONTHS_BACK_USAGE.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Transports period (months)
  COMMENT (31) CRSMNT_T FOR FIELD P_CRSMNT.
PARAMETERS: P_CRSMNT LIKE CRS_EXTRACTION_MONTHS DEFAULT
                     CRS_EXTRACTION_MONTHS.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Prod Transports period (months)
  COMMENT (31) PRDCRS_T FOR FIELD P_PRDCRS.
PARAMETERS: P_PRDCRS LIKE PROD_CRS_EXTRACTION_MONTHS DEFAULT
                     PROD_CRS_EXTRACTION_MONTHS.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
* roles extraction period
  COMMENT (31) ROLPER_T FOR FIELD P_ROLPER.
PARAMETERS: P_ROLPER LIKE ROLES_EXTRACTION_PERIOD DEFAULT
                     ROLES_EXTRACTION_PERIOD.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Limit no. of role usage
  COMMENT (31) AGRROW_T FOR FIELD P_AGRROW.
PARAMETERS: P_AGRROW LIKE AGR_USERS_ROW_COUNT DEFAULT
                     AGR_USERS_ROW_COUNT.
SELECTION-SCREEN: END OF LINE,
END OF BLOCK B_DATA.

* Run mode parameters block
SELECTION-SCREEN: BEGIN OF BLOCK B_RUNMOD WITH FRAME TITLE RUNMOD_T,

  BEGIN OF LINE,
*     Disable ETL ver. Validation
    COMMENT (31) SKPVLD_T FOR FIELD P_SKPVLD.
PARAMETERS: P_SKPVLD TYPE FLAG DEFAULT SKIP_VALIDATION.
*     Enable RFC to SolMan
SELECTION-SCREEN COMMENT 39(32) SOLMAN_T FOR FIELD P_SOLMAN.
PARAMETERS: P_SOLMAN TYPE FLAG DEFAULT REQUIRE_SOLMAN_RFC.
SELECTION-SCREEN: END OF LINE,
BEGIN OF LINE,
COMMENT (31) COMPRS_T FOR FIELD P_COMPRS.
PARAMETERS: P_COMPRS TYPE FLAG DEFAULT COMPRESS_RESULT_FILE AS
CHECKBOX USER-COMMAND UPDATE_PARAMS.
SELECTION-SCREEN: END OF LINE,
END OF BLOCK B_RUNMOD.

* Troubleshooting parameters block
SELECTION-SCREEN: BEGIN OF BLOCK B_TRBLST WITH FRAME TITLE TRBLST_T,
  BEGIN OF LINE,
*     Add debug messages to log
    COMMENT (31) DEBUGX_T FOR FIELD P_DEBUGX.
PARAMETERS: P_DEBUGX TYPE FLAG DEFAULT EXTRACT_DEBUG.
*     Disable syntax checks
SELECTION-SCREEN COMMENT 39(32) SNTXCK_T FOR FIELD P_SNTXCK.
PARAMETERS: P_SNTXCK TYPE FLAG DEFAULT DISABLE_SYNTAX_CHECK.
SELECTION-SCREEN: END OF LINE,

BEGIN OF LINE,
*     Exclude GUI status
  COMMENT (31) GUISTT_T FOR FIELD P_GUISTT.
PARAMETERS: P_GUISTT TYPE FLAG DEFAULT DISABLE_GUI_STATUS_EXTRACT.
*     Extract text elements
SELECTION-SCREEN COMMENT 39(32) TXTELM_T FOR FIELD P_TXTELM.
PARAMETERS: P_TXTELM TYPE FLAG DEFAULT EXTRACT_TEXT_ELEMENTS.
SELECTION-SCREEN: END OF LINE,
END OF BLOCK B_TRBLST.

SELECTION-SCREEN BEGIN OF BLOCK B11 WITH FRAME TITLE B_EXCLUD.
* Programs to exclude from extractor run.
  SELECT-OPTIONS S_PRGEXC FOR TRDIR-NAME NO INTERVALS.
* Devcs to exclude from extractor run.
  SELECT-OPTIONS S_DVCEXC FOR TDEVC-DEVCLASS NO INTERVALS.
* Namespaces to exclude from extractor run.
  SELECT-OPTIONS S_NSPEXC FOR TDEVC-NAMESPACE NO INTERVALS.
SELECTION-SCREEN END OF BLOCK B11.

SELECTION-SCREEN END OF BLOCK B10.

SELECTION-SCREEN END OF SCREEN 102.

SELECTION-SCREEN BEGIN OF SCREEN 103 AS SUBSCREEN.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS C_UPLOAD AS CHECKBOX DEFAULT ' ' USER-COMMAND UPLD.
SELECTION-SCREEN COMMENT 4(30) UPLD_T
FOR FIELD C_UPLOAD.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN SKIP.
* Login credentials
SELECTION-SCREEN BEGIN OF BLOCK B20 WITH FRAME TITLE B_LOGIN.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS: C_APIPAS TYPE C RADIOBUTTON GROUP API MODIF ID LGN
USER-COMMAND API_SELEC DEFAULT 'X'.
SELECTION-SCREEN: COMMENT 6(18) T_APIPAS
MODIF ID LGN FOR FIELD C_APIPAS.

PARAMETERS: C_APITOK TYPE C RADIOBUTTON GROUP API MODIF ID LGN.
SELECTION-SCREEN: COMMENT 27(15) T_APITOK  MODIF ID LGN
FOR FIELD C_APITOK.
SELECTION-SCREEN END OF LINE.

* Username
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(10) USER_T FOR FIELD P_USER MODIF ID LGN.
PARAMETERS  P_USER(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.
* Password
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(10) PASS_T FOR FIELD P_PASS MODIF ID LGN.
PARAMETERS  P_PASS(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.
* TOKEN
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(10) TOKEN_T FOR FIELD P_TOKEN MODIF ID LGN.
PARAMETERS  P_TOKEN TYPE STRING LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.
* Account name notice
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(50) ACNT_I MODIF ID LGN.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 5(50) ACNT_N MODIF ID LGN.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN END OF BLOCK B20.

* Proxy configuration
SELECTION-SCREEN BEGIN OF BLOCK B22 WITH FRAME TITLE B_PROXY.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(14) PRXHST_T FOR FIELD P_PRXHST MODIF ID
LGN.
PARAMETERS P_PRXHST(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(14) PRXPRT_T FOR FIELD P_PRXPRT MODIF ID
LGN.
PARAMETERS P_PRXPRT(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(14) PRXUSR_T FOR FIELD P_PRXUSR MODIF ID
LGN.
PARAMETERS P_PRXUSR(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(14) PRXPSS_T FOR FIELD P_PRXPSS MODIF ID
LGN.
PARAMETERS P_PRXPSS(50) TYPE C LOWER CASE MODIF ID LGN.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK B22.

* Compress & Login validations
SELECTION-SCREEN BEGIN OF BLOCK B21 WITH FRAME TITLE B_VALID.
SELECTION-SCREEN SKIP.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(30) BUT4 USER-COMMAND TEST_LOGIN
  MODIF ID LGN.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN SKIP.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON 1(30) BUT5 USER-COMMAND TEST_COMPRESS
  MODIF ID LGN.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK B21.
SELECTION-SCREEN END OF SCREEN 103.

SELECTION-SCREEN BEGIN OF TABBED BLOCK TABS_BLOCK FOR 35 LINES.
SELECTION-SCREEN TAB (24) TABMAIN USER-COMMAND UCOMM1
  DEFAULT SCREEN 101.

SELECTION-SCREEN TAB (17) TABPARAM USER-COMMAND UCOMM2
  DEFAULT SCREEN 102.

SELECTION-SCREEN TAB (17) TABAUTO USER-COMMAND UCOMM3
  DEFAULT SCREEN 103.

SELECTION-SCREEN END OF BLOCK TABS_BLOCK.

*---------------------------------------------------------------------*
*   LOAD-OF-PROGRAM
*---------------------------------------------------------------------*
LOAD-OF-PROGRAM.
  DATA : LT_RFCDES TYPE STANDARD TABLE OF RFCDES,
         LS_RFCDES LIKE LINE OF LT_RFCDES,
         LV_VALID  TYPE FLAG.

* Get SM connection
  SELECT *
  FROM RFCDES BYPASSING BUFFER
  INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
  WHERE
  RFCTYPE = '3' AND
   RFCDEST = C_PANAYA_SM_RFC.

  SORT LT_RFCDES.

* Set first valid connection as default
  LOOP AT LT_RFCDES INTO LS_RFCDES.
    PERFORM CHECK_SM_RFC_DEST
    USING LS_RFCDES-RFCDEST
          ABAP_TRUE" Validate
    CHANGING LV_VALID.

    IF NOT LV_VALID IS INITIAL.
      GC_SM_RFC = LS_RFCDES-RFCDEST.
      EXIT.
    ENDIF.
  ENDLOOP.


* Get ATC connection
  SELECT *
  FROM RFCDES BYPASSING BUFFER
  INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
  WHERE
  RFCTYPE = '3' AND
  RFCDEST = C_PANAYA_ATC_RFC.

* Set first valid connection as default
  LOOP AT LT_RFCDES INTO LS_RFCDES.
    P_AT_RFC = C_PANAYA_ATC_RFC.
  ENDLOOP.

* Get SI connection
  SELECT *
  FROM RFCDES BYPASSING BUFFER
  INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
  WHERE
  RFCTYPE = '3' AND
  RFCDEST = C_PANAYA_SI_RFC.

* Set first valid connection as default
  LOOP AT LT_RFCDES INTO LS_RFCDES.
    P_SI_RFC = C_PANAYA_SI_RFC.
  ENDLOOP.

* Check BW Tables Availability
  PERFORM CHECK_BW_RFC_DEST  USING GV_BW_RFC
                                   ABAP_TRUE" Validate
                             CHANGING LV_VALID.
  IF LV_VALID IS INITIAL.
    CLEAR GV_BW_RFC.
  ENDIF.

*---------------------------------------------------------------------*
*   AT SELECTION-SCREEN
*---------------------------------------------------------------------*
AT SELECTION-SCREEN.
  DATA:
    FCODE                 TYPE SY-UCOMM,
    LV_NOTIFICATION_PARAM TYPE STRING,
    LV_SUCCESS            TYPE FLAG,
    LV_ERROR              TYPE C.
  FCODE = SY-UCOMM.

  IF SY-DYNNR = 1000.

    EXTRACT_SCI_HANA_PERFORMANCE = P_SCIPRF.

    PERFORM GET_SCI_INSPECTION_DATES.

*   Check if the ETL version matches the current system version
    PERFORM CHECK_ETL_VERSION.

*   Check if the current client is not '000'
    IF SY-MANDT = '000'.
      PERFORM RAISE_ERROR USING
'The program cannot be executed in client 000.'.            "#EC NOTEXT
    ENDIF.

*   Check that the user has authorizations to read sources
    PERFORM TEST_AUTH_READ_SOURCE USING 'SAPLS38E'
                                      'NONE'
                                      ''.

*   Prepare the popup screen texts.
    PERFORM CREATE_POPUP_TEXT CHANGING QUESTION.
    IF SY-UCOMM = 'SJOB' .

      G_FULLNAME_FUNC_DB      = PSRV_FD.
      G_FULLNAME_FUNC_DB_ADD  = PSRV_FDA.
      G_FULLNAME_PER_DB       = PSRV_PER.

      PERFORM CHECK_SI_TARGET_STACK CHANGING LV_ERROR.
      IF LV_ERROR = ABAP_TRUE.
        CLEAR SSCRFIELDS-UCOMM.
        EXIT.
      ENDIF.

      PERFORM VALIDITY_CHECKS CHANGING LV_ERROR.
      IF LV_ERROR = ABAP_TRUE.
        CLEAR SSCRFIELDS-UCOMM.
        EXIT.
      ENDIF.

      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
*         TITLEBAR              = ' '
          TEXT_QUESTION         = QUESTION
          DISPLAY_CANCEL_BUTTON = ' '
        IMPORTING
          ANSWER                = ANSWER.

      IF ANSWER = '2'.
*          clearing this field couses the program to cancel the
*          "execute in backround" action
        CLEAR SSCRFIELDS-UCOMM.
      ENDIF.
    ENDIF.

*   Check that this is not ehp7 system and the user tried to run it in
*   foreground
    IF NOT G_IS_EHP7 IS INITIAL AND NOT R_FORE IS INITIAL.
*     First of all deactivate the exectute in background option
      APPEND 'SJOB' TO STAT_EXCLUDE.
      CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
        EXPORTING
          P_STATUS  = SY-PFKEY
        TABLES
          P_EXCLUDE = STAT_EXCLUDE.

      PERFORM RAISE_ERROR USING
'In EHP7 system, please run the ETL only in background mode'.
    ENDIF.

*   Local file checks
*   -----------------
    IF NOT R_FORE IS INITIAL AND SY-UCOMM NE 'FTYP'
    AND SY-BATCH IS INITIAL.
      IF P_FORE IS INITIAL.
        MESSAGE E003(HRPAYIEPAYROLL).
      ELSE.

        PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
                                  CHANGING  P_FORE
                                            FULLPATH.

        PERFORM CHECK_FILENAME USING FULLPATH.

        L_FILENAME = FULLPATH.

        CLEAR FILE_EXISTS.
        CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_EXIST
          EXPORTING
            FILE   = L_FILENAME
          RECEIVING
            RESULT = FILE_EXISTS
          EXCEPTIONS
            OTHERS = 4.

        IF SY-SUBRC = 0.
          IF FILE_EXISTS = 'X' AND PANAYA_TEST_MODE IS INITIAL.
            MESSAGE W000(26) WITH
              'File already exists and will be overridden'. "#EC NOTEXT
          ENDIF.
        ELSE.
          MESSAGE E503(0U) WITH P_FORE.
        ENDIF.
      ENDIF.
    ENDIF.

*   Server file checks
*   ------------------
    IF NOT R_BACK IS INITIAL AND SY-UCOMM NE 'FTYP'.
*         AND SY-UCOMM NE SPACE.

*       Save the value of the screen field.
      PATH = P_BACK.
      GV_BACK_PATH =  P_BACK.

*       Create the full file name.
      CONCATENATE P_BACK FILENAME INTO FULLPATH.
      PERFORM CHECK_FILENAME USING FULLPATH.


*       Check if the file already exists
      OPEN DATASET FULLPATH FOR INPUT IN BINARY MODE.
      IF SY-SUBRC = 8.
*         The file doesn't exist, Open the file for writing
        OPEN DATASET FULLPATH FOR OUTPUT IN BINARY MODE.
        IF NOT SY-SUBRC IS INITIAL.
          CLOSE DATASET P_BACK.
          MESSAGE E502(0U) WITH FULLPATH.
        ENDIF.
        CLOSE DATASET FULLPATH.

*         Delete the file after opening it
        DELETE DATASET FULLPATH.

      ELSE.
        CLOSE DATASET FULLPATH.
        MESSAGE W000(26) WITH
        'File already exists and will be overridden'.       "#EC NOTEXT
      ENDIF.

      IF SY-UCOMM = 'ONLI' AND SY-BATCH IS INITIAL AND
         PANAYA_TEST_MODE IS INITIAL.

        MESSAGE
          'Please select background execution mode (F9)'    "#EC NOTEXT
           TYPE 'S' DISPLAY LIKE 'E'.

        CLEAR SSCRFIELDS-UCOMM.
        EXIT.
      ENDIF.
    ENDIF.

*  activate 'Execute in background' only what foreground mode is active
    IF R_FORE = 'X'.
      CLEAR STAT_EXCLUDE.
      APPEND 'SJOB' TO STAT_EXCLUDE.
    ELSEIF R_BACK = 'X'.
      CLEAR STAT_EXCLUDE.
      APPEND 'ONLI' TO STAT_EXCLUDE.
    ENDIF.

    APPEND 'PRIN' TO STAT_EXCLUDE.

    CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
      EXPORTING
        P_STATUS  = SY-PFKEY
      TABLES
        P_EXCLUDE = STAT_EXCLUDE.

*   Check button
    IF FCODE EQ  'VALID'.
      GT_ETL_MESSAGE-MESSAGE =
      'Client has pressed the validation button '.          "#EC NOTEXT
      PERFORM ADD_NOTIFICATION USING VALIDATION_MANUALLY_PRESSED
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.
      PERFORM OPEN_VALIDATION_PAGE.
    ENDIF.

    CASE FCODE.

      WHEN 'UPDATE_PARAMS'.
        COMPRESS_RESULT_FILE = P_COMPRS.
        EXTRACT_SUSG_DATA = P_SUSG_P.
      WHEN 'TEST_LOGIN'.
        PERFORM TEST_LOGIN.

      WHEN 'TEST_COMPRESS'.
        PERFORM TEST_COMPRESS USING 'X' CHANGING LV_SUCCESS.

      WHEN 'UPLOAD_XLS'.

        DATA: LV_FAIL_FUNC TYPE C.
        DATA: LV_FAIL_PERF TYPE C.

        CLEAR G_FULLNAME_FUNC_DB.
        CLEAR G_FULLNAME_FUNC_DB_ADD.
        CLEAR G_FULLNAME_PER_DB.

        IF EXTRACT_ATC_S4_CHECK IS INITIAL AND
          EXTRACT_SCI_HANA_CHECK IS NOT INITIAL.

          PERFORM SAVE_EXCEL_AS_TEXT_IN_APP_SRV
            USING
              PXLS_FD
              C_FUNCTIONAL_DB
            CHANGING
              PSRV_FD.

          IF PSRV_FD IS INITIAL.
            LV_FAIL_FUNC = ABAP_TRUE.
          ENDIF.

        ENDIF.

        IF EXTRACT_SCI_HANA_CHECK IS NOT INITIAL.

          PERFORM SAVE_EXCEL_AS_TEXT_IN_APP_SRV
            USING
              PXLS_FDA
              C_FUNCTIONAL_DB_ADDITION
            CHANGING
              PSRV_FDA.

          IF PSRV_FDA IS INITIAL.
            LV_FAIL_FUNC = ABAP_TRUE.
          ENDIF.

        ENDIF.

        IF EXTRACT_SCI_HANA_PERFORMANCE = ABAP_TRUE.

          PERFORM SAVE_EXCEL_AS_TEXT_IN_APP_SRV
            USING
              PXLS_PER
              C_PERFORMANCE_DB
            CHANGING
              PSRV_PER.


          IF PSRV_PER IS INITIAL.
            LV_FAIL_PERF = ABAP_TRUE.
          ENDIF.

        ENDIF.

        G_OLD_EXCEL_FUNC_DB = PXLS_FD.
        G_OLD_EXCEL_FUNC_DB_ADD = PXLS_FDA.
        G_OLD_EXCEL_PER_DB = PXLS_PER.

        IF LV_FAIL_FUNC EQ ABAP_TRUE OR
           LV_FAIL_PERF EQ ABAP_TRUE.
          MESSAGE S899(EZ) WITH
            'Upload of the Excel files has Failed'          "#EC NOTEXT
             DISPLAY LIKE 'E'.
        ELSE.
          MESSAGE S899(EZ) WITH
            'Finished uploading the excel files'.           "#EC NOTEXT
        ENDIF.

      WHEN 'UPL_HANA_SIZ'.
        PERFORM GET_HANA_SIZING_RESULTS
          USING P_HN_SIZ
          CHANGING PSRV_HN.

      WHEN 'ATC_VAR'.

        PERFORM CHOOSE_ATC_VARIANT.

      WHEN 'UPLOAD_SUSG'.
        PERFORM SAVE_SUSG_IN_APP_SRV USING P_SUSG
                                     CHANGING PSRV_SUS.

        IF PSRV_SUS IS NOT INITIAL.
          MESSAGE S899(EZ) WITH
            'File was successfully uploaded'.               "#EC NOTEXT
        ENDIF.

      WHEN OTHERS.

    ENDCASE.
  ENDIF.

AT SELECTION-SCREEN ON P_FORE.
  IF NOT R_FORE IS INITIAL AND SY-UCOMM NE 'FTYP'
  AND SY-BATCH IS INITIAL.
    PERFORM GET_LAST_CHAR USING P_FORE
                  CHANGING LAST_CHAR.

    IF LAST_CHAR NE '\'.
      ERROR_MSG = 'Directory must end with \'.              "#EC NOTEXT
      PERFORM RAISE_ERROR USING ERROR_MSG.
    ENDIF.
    IF P_FORE = '\'.
      ERROR_MSG =
      'Directory name must be entered'.                     "#EC NOTEXT
      PERFORM RAISE_ERROR USING ERROR_MSG.
    ENDIF.

  ENDIF.

AT SELECTION-SCREEN ON P_BACK.
  IF NOT R_BACK IS INITIAL AND SY-UCOMM NE 'FTYP'.
    PERFORM GET_LAST_CHAR USING P_BACK
                  CHANGING LAST_CHAR.
    IF NOT P_BACK IS INITIAL AND LAST_CHAR NE '/' AND LAST_CHAR NE '\'.
      ERROR_MSG =
      'Directory must end with \ or /'.                     "#EC NOTEXT
      PERFORM RAISE_ERROR USING ERROR_MSG.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON P_RFCDES.
  CLEAR GT_MESSAGE_TAB[].
  CLEAR :  GV_LOGSYS.
  IF NOT P_RFCDES IS INITIAL.
*   Check RFC destination
    PERFORM CHECK_RFC_DEST_EXISTANCE.
  ELSE.
    RFC_SYSID = SY-SYSID.
    CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET'
      IMPORTING
        P_LOGSYS                       = GV_LOGSYS
      EXCEPTIONS
        OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
        OTHERS                         = 2.
    IF SY-SUBRC <> 0.
    ENDIF.
    CALL FUNCTION 'RFC_SYSTEM_INFO'
      IMPORTING
        RFCSI_EXPORT = RFC_DATA.
    RFC_SYSID = RFC_DATA-RFCSYSID.
    RFC_SAPRL = RFC_DATA-RFCSAPRL.
  ENDIF.

AT SELECTION-SCREEN ON P_SM_RFC.
  DATA : LV_FLAG TYPE FLAG.
* Check SM rfc destination
  PERFORM CHECK_SM_RFC_DEST
  USING P_SM_RFC
        ABAP_FALSE" Message
  CHANGING LV_FLAG.

AT SELECTION-SCREEN ON P_SET_SM.
  IF P_SET_SM IS INITIAL.
    CLEAR P_SM_RFC.
  ELSE.
    P_SM_RFC = C_PANAYA_SM_RFC.
  ENDIF.

AT SELECTION-SCREEN ON P_BW_RFC.
  DATA : LV_FLAG TYPE FLAG.

  GV_BW_RFC = P_BW_RFC.
* Check BW rfc destination
  PERFORM CHECK_BW_RFC_DEST
  USING GV_BW_RFC
        ABAP_FALSE" Message
  CHANGING LV_FLAG.

AT SELECTION-SCREEN ON P_SET_BW.
  IF P_SET_BW IS INITIAL.
    CLEAR P_BW_RFC.
  ELSE.
    P_BW_RFC =  C_PANAYA_BW_RFC.
    GV_BW_RFC = P_BW_RFC.
  ENDIF.

AT SELECTION-SCREEN ON P_SI_RFC.
  DATA: LV_FLAG TYPE FLAG.

  PERFORM CHECK_SI_RFC_DEST
    USING P_SI_RFC ABAP_FALSE
    CHANGING LV_FLAG.

AT SELECTION-SCREEN ON P_AT_RFC.

  CHECK EXTRACT_ATC_S4_CHECK EQ ABAP_TRUE.

  DATA : LV_FLAG TYPE FLAG.

  PERFORM CHECK_ATC_RFC_DEST
  USING P_AT_RFC
        ABAP_FALSE" Message
  CHANGING LV_FLAG.

  IF G_AT_RFC NE P_AT_RFC AND
      SY-BATCH EQ ABAP_FALSE.
    CLEAR: P_AT_GID,
           T_AT_TXT.

    G_AT_RFC = P_AT_RFC.
  ENDIF.

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_USERDA.
  MESSAGE I000(CONV) WITH
'SECURITY - SAP users full n' 'ames extraction'.            "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_LOGNAM.
  MESSAGE I000(CONV) WITH
    'SECURITY - Replace user nam' 'es with XXX'.            "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SRVRNM.
  MESSAGE I000(CONV) WITH
    'SECURITY - Replace server n' 'ames with XXX'.          "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_AGRUSL.
  MESSAGE I000(CONV) WITH
    'ROLES - Roles usage extraction (used onl'              "#EC NOTEXT
    'y when the RFC system is the current system)'.         "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_AGRUSR.
  MESSAGE I000(CONV) WITH
    'ROLES - Roles usage extraction (used only wh'          "#EC NOTEXT
    'en the RFC system is a different system)'.             "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SOLARD.
  MESSAGE I000(CONV) WITH
    'SOLMAN - ETL mark II data e' 'xtraction'.              "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_WEBUSG.
  MESSAGE I000(CONV) WITH
    'USAGE - Determines whether to use old usag'            "#EC NOTEXT
    'e function with no web usage or usage func'            "#EC NOTEXT
    'tion with web usage (web usage used for We'            "#EC NOTEXT
    'bservices)'.                                           "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_PROXYD.
  MESSAGE I000(CONV) WITH
    'DISABLE_EXTRACTION - Proxies data extraction'.         "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_IDOCUS.
  MESSAGE I000(CONV) WITH
    'USAGE - Idoc usage extraction'.                        "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_LYOUTU.
  MESSAGE I000(CONV) WITH
    'USAGE - Layout usage extraction (retrieve'             "#EC NOTEXT
    'd only when the RFC system is the current s'           "#EC NOTEXT
    'ystem)'.                                               "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_DEBUGX.
  MESSAGE I000(CONV) WITH
    'R&D INTERNAL - Add debug messages to the jo'           "#EC NOTEXT
    'b log'.                                                "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_AGRROW.
  MESSAGE I000(CONV) WITH
    'ROLES - The number of role usage data extra'           "#EC NOTEXT
    'cted in one go'.                                       "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_MNTHBC.
  MESSAGE I000(CONV) WITH
    'USAGE - The number of months Usage history t'          "#EC NOTEXT
    'hat will be extracted (ONLY for Idoc /Proxi'           "#EC NOTEXT
    'es)'.                                                  "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_USGDAY.
  MESSAGE I000(CONV) WITH
    'USAGE - The number of days of Usage histor'            "#EC NOTEXT
    'y that will be extracted'.                             "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_TOTINS.
  MESSAGE I000(CONV) WITH
    'USAGE - Extract the TOTAL instance as par'             "#EC NOTEXT
    't of the usage, not only the usage on the i'           "#EC NOTEXT
    'nstances'.                                             "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SNTXCK.
  MESSAGE I000(CONV) WITH
    'DISABLE_EXTRACTION - Perform syntax check o'           "#EC NOTEXT
    'n the extracted programs'.                             "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_GUISTT.
  MESSAGE I000(CONV) WITH
    'DISABLE_EXTRACTION - GUI status extractio'             "#EC NOTEXT
    'n - relevant for testing activities'.                  "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SOLMAN.
  MESSAGE I000(CONV) WITH
    'SOLMAN - Enforce the user to fill in an RF'            "#EC NOTEXT
    'C to Solman'.                                          "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_CRSMNT.
  MESSAGE I000(CONV) WITH
    'R&D INTERNAL - The number of months of CR hi'          "#EC NOTEXT
    'story that will be extracted from the curren'          "#EC NOTEXT
    't system'.                                             "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_PRDCRS.
  MESSAGE I000(CONV) WITH
    'R&D INTERNAL - The number of months of CR hi'          "#EC NOTEXT
    'story that will be extracted from the RFC sy'          "#EC NOTEXT
    'stem'.                                                 "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_ROLPER.
  MESSAGE I000(CONV) WITH
    'R&D INTERNAL - The month number of Roles lo'           "#EC NOTEXT
    'g data that will be extracted from the curre'          "#EC NOTEXT
    'nt system (CDHDR&CDPOS)'.                              "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SKPVLD.
  MESSAGE I000(CONV) WITH
    'GENERAL - Skip ETL Version Server Validation'.         "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_WDDATA.
  MESSAGE I000(CONV) WITH
    'DISABLE EXTRACTION - Extract WebDynpro Data'.          "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_USERHR.
  MESSAGE I000(CONV) WITH
    'SECURITY - SAP users full names extraction w'          "#EC NOTEXT
    'ith additional HR data'.                               "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_LAYUSR.
  MESSAGE I000(CONV) WITH
    'USAGE - Layout usage extraction via RFC (ret'          "#EC NOTEXT
    'rieved when the RFC system is not the curren'          "#EC NOTEXT
    't system)'.                                            "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_USGDLT.
  MESSAGE I000(CONV) WITH
    'USAGE - Get delta / full usage data.'.                 "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_SCIPRF.
  MESSAGE I000(CONV) WITH
    'GENERAL - Extract HANA Performance'.                   "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_WDSNTX.
  MESSAGE I000(CONV) WITH
    'DISABLE SCI WD - Do not check WebDynpro Dat'           "#EC NOTEXT
    'a with SCI'.

AT SELECTION-SCREEN ON HELP-REQUEST FOR P_TXTELM.
  MESSAGE I000(CONV) WITH
    'Extract text elements'.                                "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR S_PRGEXC.
  MESSAGE I000(CONV) WITH
    'Programs to exclude from the extractor run.'.          "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR S_DVCEXC.
  MESSAGE I000(CONV) WITH
    'Development classes to exclud'                         "#EC NOTEXT
    'e from the extractor run.'.                            "#EC NOTEXT

AT SELECTION-SCREEN ON HELP-REQUEST FOR S_NSPEXC.
  MESSAGE I000(CONV) WITH
    'Namespaces to exclude from the extractor run.'.        "#EC NOTEXT

AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FORE.
*------------------------------------------------
* Select local folder.
  CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_BROWSE
    EXPORTING
*     WINDOW_TITLE    =
      INITIAL_FOLDER  = INITIAL_DIRECTORY
    CHANGING
      SELECTED_FOLDER = PATH
    EXCEPTIONS
      CNTL_ERROR      = 1
      ERROR_NO_GUI    = 2
      OTHERS          = 3.

  CALL METHOD CL_GUI_CFW=>FLUSH
    EXCEPTIONS
      CNTL_SYSTEM_ERROR = 1
      CNTL_ERROR        = 2
      OTHERS            = 3.

  CHECK NOT PATH IS INITIAL.
* Create full file name including path.
  PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
                          CHANGING PATH
                                   FULLPATH.

  LEN = STRLEN( FULLPATH ).

* Check filename is not too long
  IF LEN > 128.
    MESSAGE I000(CONV) WITH 'The chosen file name too long.' "#EC NOTEXT
' Maximum length of the filename is 128 chars'.             "#EC NOTEXT
  ELSE.
    INITIAL_DIRECTORY = PATH.
    P_FORE = PATH.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_SUSG.
*------------------------------------------------

  DATA: EXENSION    TYPE STRING,
        FILE_FILTER TYPE STRING.

  PERFORM CHOOSE_FILE_DESKTOP USING EXENSION FILE_FILTER
                              CHANGING P_SUSG.


AT SELECTION-SCREEN ON VALUE-REQUEST FOR PXLS_FD.

  DATA: EXTENSION    TYPE STRING,
        FILE_FILTER TYPE STRING.

  EXTENSION = '*.xls'.
  CONCATENATE '(*.xls)|*.xls|CSV (MS-DOS) (*.txt)|'         "#EC NOTEXT
              '*.txt|'                                      "#EC NOTEXT
              INTO FILE_FILTER.

  PERFORM CHOOSE_FILE_DESKTOP
    USING
      EXTENSION
      FILE_FILTER
    CHANGING
      PXLS_FD.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR PXLS_FDA.

  DATA: EXTENSION    TYPE STRING,
        FILE_FILTER TYPE STRING.

  EXTENSION = '*.xls'.
  CONCATENATE '(*.xls)|*.xls|CSV (MS-DOS) (*.txt)|'         "#EC NOTEXT
              '*.txt|'                                      "#EC NOTEXT
              INTO FILE_FILTER.

  PERFORM CHOOSE_FILE_DESKTOP
    USING
      EXTENSION
      FILE_FILTER
    CHANGING
      PXLS_FDA.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR PXLS_PER.

  DATA: EXTENSION    TYPE STRING,
        FILE_FILTER TYPE STRING.

  EXTENSION = '*.xls'.
  CONCATENATE '(*.xls)|*.xls|CSV (MS-DOS) (*.txt)|'         "#EC NOTEXT
              '*.txt|'                                      "#EC NOTEXT
              INTO FILE_FILTER.

  PERFORM CHOOSE_FILE_DESKTOP
    USING
      EXTENSION
      FILE_FILTER
    CHANGING
      PXLS_PER.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_HN_SIZ.

  DATA: EXTENSION    TYPE STRING,
        FILE_FILTER TYPE STRING.

  EXTENSION = '*.txt'.
  FILE_FILTER = '(*.txt)|*.txt'.

  PERFORM CHOOSE_FILE_DESKTOP
    USING
      EXTENSION
      FILE_FILTER
    CHANGING
      P_HN_SIZ.

AT SELECTION-SCREEN OUTPUT.

  DATA:
    MESS_TEXT TYPE STRING.

*--------------------------
* In case of EHP7, set background to be turned on by default.
* In other cases - set foreground to be turned on by default
* ( only on the first time the screen is shown ).
  IF G_IS_EHP7 = 'X'.
    R_FORE = ' '.
    R_BACK = 'X'.
  ENDIF.

* Write icon
  WRITE ICON_MESSAGE_WARNING AS ICON TO ICON1.
  WRITE ICON_MESSAGE_ERROR   AS ICON TO ICON2.
* Lock not relevant fields
  LOOP AT SCREEN.

    IF COMPRESS_RESULT_FILE IS INITIAL AND
      SCREEN-GROUP1 EQ 'CMP'.

      SCREEN-ACTIVE = '0'.
      SCREEN-INVISIBLE = '1'.
      MODIFY SCREEN.

    ENDIF.

    " If Simiens security flag,
    " than only background file allowed.
    " file & RFC input is disabled.
    IF REQUIRE_SECURITY = ABAP_TRUE.

      CASE SCREEN-NAME.

        WHEN 'R_FORE'   OR
             'TIT_FORE'.
          SCREEN-INPUT = '0'.
          SCREEN-OUTPUT = '1'.
          SCREEN-ACTIVE = '0'.
          MODIFY SCREEN.

        WHEN 'R_BACK'   OR
             'P_BACK'   OR
             'P_RFCDES' OR
             'P_SM_RFC' OR
             'P_BW_RFC'.

          SCREEN-INPUT  = '0'.
          SCREEN-OUTPUT = '1'.
          MODIFY SCREEN.
        WHEN 'P_SET_SM'.

          IF REQUIRE_SOLMAN_RFC = ABAP_TRUE.
            SCREEN-INPUT = '0'.
            SCREEN-OUTPUT = '1'.
            SCREEN-ACTIVE = '0'.
            MODIFY SCREEN.
          ENDIF.

        WHEN OTHERS.
      ENDCASE.
    ELSE.
      CASE SCREEN-NAME.
        WHEN 'P_SET_BW' OR
             'P_SET_SM'.
          SCREEN-INPUT = '0'.
          SCREEN-OUTPUT = '1'.
          SCREEN-ACTIVE = '0'.
          MODIFY SCREEN.
      ENDCASE.

    ENDIF.

    IF R_FORE IS INITIAL
      AND SCREEN-NAME = 'P_FORE'.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '1'.
      SCREEN-INVISIBLE = '0'.
      MODIFY SCREEN.
    ENDIF.
    IF R_BACK IS INITIAL
      AND SCREEN-NAME = 'P_BACK'.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '1'.
      SCREEN-INVISIBLE = '0'.
      MODIFY SCREEN.
    ENDIF.
    IF SCREEN-NAME = 'P_FILEN'.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '1'.
      MODIFY SCREEN.
    ENDIF.
    IF SCREEN-NAME+0(8) = 'DEVCLASS'
      OR SCREEN-NAME+0(10) = '%_DEVCLASS'
      OR SCREEN-NAME = 'VANILLA'
      OR SCREEN-NAME = 'FIRSTBLK'
      OR SCREEN-NAME = 'POPUP_OK'.

      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
    ENDIF.

    IF ( NOT IS_ON_TRIAL = 'X' ).
      IF SCREEN-GROUP1 = 'TRL'.
        SCREEN-INPUT = '0'.
        SCREEN-OUTPUT = '0'.
        SCREEN-INVISIBLE = '1'.
        SCREEN-ACTIVE = 0.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

*   Display Block if fallback is active
    IF REST_FALLBACK_ACTIVE = 'X'.

      IF SCREEN-GROUP1 = 'BX' OR SCREEN-NAME = 'TITL9'
        OR SCREEN-NAME = 'ICON1'  OR SCREEN-NAME = 'WARN_VAL' OR
        SCREEN-NAME = 'BUT3'.

        SCREEN-INVISIBLE = '0'.
        SCREEN-ACTIVE = 1.
        MODIFY SCREEN.
      ENDIF.

      IF SCREEN-NAME = 'ICON2' OR SCREEN-NAME = 'WARN1' OR
        SCREEN-NAME = 'WARN2'.

        SCREEN-INVISIBLE = '1'.
        SCREEN-ACTIVE = '0'.

        MODIFY SCREEN.

      ENDIF.

    ELSE.

*     if version mismatch error , make room for all the warnings
      IF REST_VERSION_MISMATCH_ERR EQ 'X' OR REST_MAJOR_VERSION_ERR
        EQ 'X'.

        IF SCREEN-GROUP1 = 'BX' OR SCREEN-NAME = 'TITL9'
        OR SCREEN-NAME = 'ICON2' OR SCREEN-NAME = 'WARN1'
          OR SCREEN-NAME = 'WARN2'.

          SCREEN-INVISIBLE = '0'.
          SCREEN-ACTIVE = 1.
          MODIFY SCREEN.

        ELSEIF SCREEN-NAME = 'BUT3'
          OR SCREEN-NAME = 'ICON1' OR SCREEN-NAME = 'WARN_VAL'.
          SCREEN-INVISIBLE = '1'.
          SCREEN-ACTIVE = 0.
          MODIFY SCREEN.

        ENDIF.

      ELSE.

        IF SCREEN-GROUP1 = 'BX' OR SCREEN-NAME = 'TITL9'
        OR SCREEN-NAME = 'ICON1' OR
          SCREEN-NAME = 'BUT3' OR SCREEN-NAME = 'ICON2' OR
          SCREEN-NAME = 'WARN1' OR SCREEN-NAME = 'WARN2' OR
          SCREEN-NAME = 'WARN_VAL'.


          SCREEN-INVISIBLE = '1'.
          SCREEN-ACTIVE = 0.
          MODIFY SCREEN.
        ENDIF.

      ENDIF.


    ENDIF.

    IF ( NOT IS_ON_TRIAL = 'X' ).
      IF SCREEN-GROUP1 = 'B7' OR SCREEN-NAME = 'TITL7'.

        SCREEN-INVISIBLE = '1'.
        SCREEN-ACTIVE = 0.
        MODIFY SCREEN.

      ENDIF.

    ENDIF.

    " Invisible SCI Hana fields, if not needed.
    PERFORM INVISIBLE_SCI_HANA_FIELDS.

    " Determine visibility
    PERFORM SI_CHECK_DETERMINE.
    PERFORM ATC_S4_CHECK_DETERMINE.
    PERFORM HANA_SIZING_DETERMINE.
    PERFORM SUSG_DETERMINE.

    PERFORM INIT_ERROR_TEXTS.


    IF SCREEN-NAME = 'TABPARAM' AND CUST_EDIT_PARAMS IS INITIAL.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
    ENDIF.

    IF SCREEN-NAME = 'TABAUTO' AND
       ( ENABLE_AUTO_UPLOAD IS INITIAL OR
         NOT R_FORE IS INITIAL OR
         SY-SAPRL < '700').
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
      CLEAR C_UPLOAD.
    ENDIF.

    IF SCREEN-GROUP1 = 'LGN'
      AND C_UPLOAD IS INITIAL
      AND NOT ENABLE_AUTO_UPLOAD IS INITIAL.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
      CLEAR: P_USER, P_PASS.
    ENDIF.

    IF ( SCREEN-NAME = 'P_PASS' OR SCREEN-NAME = 'P_PRXPSS'
       OR SCREEN-NAME = 'P_TOKEN' )
      AND NOT ENABLE_AUTO_UPLOAD IS INITIAL.
      IF NOT C_UPLOAD IS INITIAL.
        SCREEN-INVISIBLE = '1'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

    IF ( SCREEN-NAME = 'P_PASS' OR SCREEN-NAME  = 'PASS_T' )
      AND C_UPLOAD IS NOT INITIAL
      AND C_APIPAS IS INITIAL
      AND NOT ENABLE_AUTO_UPLOAD IS INITIAL.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
    ENDIF.

    IF ( SCREEN-NAME = 'P_TOKEN' OR SCREEN-NAME  = 'TOKEN_T' )
      AND C_UPLOAD IS NOT INITIAL
      AND C_APITOK IS INITIAL
      AND NOT ENABLE_AUTO_UPLOAD IS INITIAL.
      SCREEN-INPUT = '0'.
      SCREEN-OUTPUT = '0'.
      SCREEN-INVISIBLE = '1'.
      SCREEN-ACTIVE = 0.
      MODIFY SCREEN.
    ENDIF.

  ENDLOOP.

  %_S_PRGEXC_%_APP_%-TEXT = 'Programs'.
  %_S_DVCEXC_%_APP_%-TEXT = 'Development Classes'.
  %_S_NSPEXC_%_APP_%-TEXT = 'Namespaces'.

* if major version error , abort program
  IF REST_MAJOR_VERSION_ERR EQ 'X' AND SKIP_VALIDATION <> 'X'.

    IF R_FORE <> 'X' AND SY-BATCH EQ 'X'.

      MESS_TEXT = C_ERROR_VERSION_MSG_JOB.


      PERFORM ADD_MESSAGE USING MESS_TEXT
                         ABAP_TRUE.
      LEAVE PROGRAM.

    ELSE.

      CALL FUNCTION 'POPUP_TO_INFORM'
        EXPORTING
          TITEL = 'Error'  "#EC NOTEXT
          TXT1  = C_ERROR_VERSION_MSG_FULL
          TXT2  = C_ERROR_VERSION_ABORT
          TXT3  = C_UPDATE_MSG
*         TXT4  = sx4
        .

      LEAVE PROGRAM.

    ENDIF.

  ENDIF.

  DATA: LT_ERROR TYPE STRINGTAB.
  PERFORM CHECK_MANDATORY_FIELDS USING ABAP_TRUE CHANGING LT_ERROR.

*---------------------------------------------------------------------*
*   INITIALIZATION
*---------------------------------------------------------------------*
INITIALIZATION.

  DATA: NAME                  TYPE VRM_ID,
        LIST                  TYPE VRM_VALUES,
        VALUE                 LIKE LINE OF LIST,
        VALIDATION_RESULT(30) TYPE C,
        LV_NOTIFICATION_PARAM TYPE STRING.

  " If security flag,
  " then only background file avalible.
  " and constants RFCs
  IF REQUIRE_SECURITY = ABAP_TRUE.
    R_FORE = ABAP_FALSE.
    R_BACK = ABAP_TRUE.

    IF REQUIRE_SOLMAN_RFC = ABAP_TRUE.
      P_SM_RFC = C_PANAYA_SM_RFC.
      P_SET_SM = ABAP_TRUE.
    ELSEIF NOT GC_SM_RFC IS INITIAL.
      P_SET_SM = ABAP_TRUE.
    ENDIF.

    IF NOT GV_BW_RFC IS INITIAL.
      P_SET_BW = ABAP_TRUE.
    ENDIF.

  ENDIF.

  IF ( SHOW_LOGIN_NAME EQ ABAP_TRUE ).
    P_LOGNAM = ABAP_FALSE.
  ELSE.
    P_LOGNAM = ABAP_TRUE.
  ENDIF.


  REST_CONVERTED_ETL_DATE = ETL_GEN_DATE.

  PERFORM IS_EHP7_SYSTEM CHANGING G_IS_EHP7.

* tabs titles
  TABMAIN = 'Panaya Code Extract Tool'.                     "#EC NOTEXT
  TABPARAM = 'Parameters'.                                  "#EC NOTEXT
  TABAUTO = 'Automatic Upload'.                             "#EC NOTEXT

* blocks in params tab titles
  B_EXCLUD = 'Objects To Exclude From Extraction'.          "#EC NOTEXT
  B_PARAMS = 'Extractor Parameters'.                        "#EC NOTEXT
  USAGE_T  = 'Usage'.                                       "#EC NOTEXT
  DATA_T   = 'Data'.                                        "#EC NOTEXT
  RUNMOD_T = 'Run Mode'.                                    "#EC NOTEXT
  TRBLST_T = 'Troubleshooting'.                             "#EC NOTEXT

* params titles
  USERDA_T = 'Full user names'.                             "#EC NOTEXT
  LOGNAM_T = 'Mask user names'.                             "#EC NOTEXT
  SRVRNM_T = 'Mask server names'.                           "#EC NOTEXT
  AGRUSL_T = 'Roles usage-RFC to curr. Sys'.                "#EC NOTEXT
  AGRUSR_T = 'Roles usage-RFC to diff. Sys'.                "#EC NOTEXT
  SOLARD_T = 'Solution Manager data'.                       "#EC NOTEXT
  WEBUSG_T = 'Exclude web services usage'.                  "#EC NOTEXT
  PROXYD_T = 'Extract Proxies data'.                        "#EC NOTEXT
  IDOCUS_T = 'Extract Idoc usage'.                          "#EC NOTEXT
  LYOUTU_T = 'Extract Layout usage'.                        "#EC NOTEXT
  DEBUGX_T = 'Add debug messages to log'.                   "#EC NOTEXT
  AGRROW_T = 'Limit no. of role usage'.                     "#EC NOTEXT
  MNTHBC_T = 'Limit no. of Idoc/Proxies'.                   "#EC NOTEXT
  COMPRS_T = 'Compress Result File'.                        "#EC NOTEXT
  USGDAY_T = 'Usage period (days)'.                         "#EC NOTEXT
  TOTINS_T = 'Total instance usage data'.                   "#EC NOTEXT
  SNTXCK_T = 'Disable syntax checks'.                       "#EC NOTEXT
  GUISTT_T = 'Exclude GUI status'.                          "#EC NOTEXT
  SOLMAN_T = 'Enable RFC to SolMan'.                        "#EC NOTEXT
  CRSMNT_T = 'Transports period (months)'.                  "#EC NOTEXT
  PRDCRS_T = 'Prod Transports period (months)'.             "#EC NOTEXT
  ROLPER_T = 'Roles log period (months)'.                   "#EC NOTEXT
  SKPVLD_T = 'Disable ETL ver. Validation'.                 "#EC NOTEXT
  WDDATA_T = 'Extract WebDynpro data'.                      "#EC NOTEXT
  USERHR_T = 'SAP users additional data'.                   "#EC NOTEXT
  LAYUSR_T = 'Extract Layout usage via RFC'.                "#EC NOTEXT
  SCIPRF_T = 'Extract HANA performance'.                    "#EC NOTEXT
  WDSNTX_T = 'Extract CSI WD checks'.                       "#EC NOTEXT
  TXTELM_T = 'Extract text elements'.                       "#EC NOTEXT
  USGDLT_T = 'Extract delta usage'.                         "#EC NOTEXT
  UI5_T    = 'Extract Fiori Data'.                          "#EC NOTEXT
  SUSG_T   = 'Attach SUSG Data'.                            "#EC NOTEXT

* exclude objects titles
*  PRGEXC_T = 'Programs'.
*  DVCEXC_T = 'Development Classes'.
*  NSPEXC_T = 'Namespaces'.

* Automatic upload titles
  B_LOGIN = 'Login Credentials'.                            "#EC NOTEXT
  T_APITOK = 'Login via token'.                             "#EC NOTEXT
  T_APIPAS = 'Login via password'.                          "#EC NOTEXT
  UPLD_T  = 'Upload extraction to Panaya'.                  "#EC NOTEXT
  USER_T  = 'User'.                                         "#EC NOTEXT
  PASS_T  = 'Password'.                                     "#EC NOTEXT
  TOKEN_T = 'Token'.                                        "#EC NOTEXT
  B_VALID = 'Login and Compress Validations'.               "#EC NOTEXT
  BUT4    = 'Validate Login to Panaya'.                     "#EC NOTEXT
  BUT5    = 'Validate compress command'.                    "#EC NOTEXT
  CONCATENATE ICON_MESSAGE_INFORMATION
              'File will be uploaded to Panaya system:'     "#EC NOTEXT
              INTO ACNT_I SEPARATED BY SPACE.
  ACNT_N = PROD_ACCOUNT_NAME.
  B_PROXY = 'Proxy Configuration (optional)'.               "#EC NOTEXT
  PRXHST_T = 'Proxy Host'.                                  "#EC NOTEXT
  PRXPRT_T = 'Proxy Port'.                                  "#EC NOTEXT
  PRXUSR_T = 'Proxy User'.                                  "#EC NOTEXT
  PRXPSS_T = 'Proxy Password'.                              "#EC NOTEXT

*--------------
*  TIT1 = 'Panaya code extract tool'.
*  obj_name = 'Repository objects'.
  TITL2 = 'Execution mode'.                                 "#EC NOTEXT

  CONCATENATE 'Target system for Authorization Roles '      "#EC NOTEXT
  'and Usage extraction'                                    "#EC NOTEXT
  INTO TITL3 RESPECTING BLANKS.
  TITL5 =
'Solution Manager target system for Systems extraction'.    "#EC NOTEXT
  TITL6 = 'BW target system for BW extraction'.             "#EC NOTEXT
  TITL7 = 'Systems'' Roles in the Landscape'.               "#EC NOTEXT
  TIT_US = 'Usage only'.                                    "#EC NOTEXT
  TIT_FULL = 'Full Extraction'.                             "#EC NOTEXT
  TIT_FORE = 'Foreground mode'.                             "#EC NOTEXT
  TIT_FRDR = 'Directory'.                                   "#EC NOTEXT
  TIT_BACK = 'Background mode (Recommended)'.               "#EC NOTEXT
  TIT_BKDR = 'Directory'.                                   "#EC NOTEXT
  TIT_FILE = 'Extraction file name'.                        "#EC NOTEXT
  TEXT0 = 'RFC destination'.                                "#EC NOTEXT
  CONCATENATE ICON_MESSAGE_INFORMATION
              'Please note that the RFC destination must'   "#EC NOTEXT
              INTO TEXT1 SEPARATED BY SPACE.


  WARN_VAL =
  'You might be using an outdated extractor version'.       "#EC NOTEXT

  WARN2 = C_UPDATE_MSG.

*  TEXT1 = 'Please note that the RFC destination should'.
  TEXT2 = 'always point to your Production system.'.        "#EC NOTEXT
  TEXT3 = 'RFC destination to Solution Manager system'.     "#EC NOTEXT
  TEXT4 = 'RFC Destination'.                                "#EC NOTEXT
  TEXT5 = 'RFC Destination to BW system'.                   "#EC NOTEXT
  TEXT6 = 'RFC Destination'.                                "#EC NOTEXT
  TEXT7 = 'Current System''s Role'.                         "#EC NOTEXT
  TEXT8 = 'Target System''s Role'.                          "#EC NOTEXT

  TSUSG = 'SUSG Upload'.
  T_SUSG = 'SUSG File'.
  UP_SUSG = 'Upload'.

  CONCATENATE ICON_MESSAGE_ERROR
              'Cannot attach SUSG without Compression'      "#EC NOTEXT
              INTO T_E_SUSG SEPARATED BY SPACE.

  TITL9 = 'Warning'.                                        "#EC NOTEXT
  BUT3  = 'Validate Extractor Version'.                     "#EC NOTEXT

  TZIP = 'Test Automatic Compression (Background Only)'.    "#EC NOTEXT
  WRITE ICON_MESSAGE_WARNING AS ICON TO ICON_CMP.
  T_CMPRSW = 'Automatic result file compression is active'. "#EC NOTEXT
  BUTZ = 'Validate compress command'.                       "#EC NOTEXT

  " Set Simplificaton Items titles.
  IF EXTRACT_SI_S4_CHECK EQ ABAP_TRUE.
    TITL_SI = 'Simplification Item Checks'.                 "#EC NOTEXT
    T_SI_RFC = 'RFC Destination'.                           "#EC NOTEXT

    TREUSESI = 'Use previous Simplification Check Data'.    "#EC NOTEXT


    CONCATENATE 'Run Simplification Item Check'             "#EC NOTEXT
            'via RFC:'                                      "#EC NOTEXT
    INTO TEXT_SI1 SEPARATED BY SPACE.
*
    C_CUR_ST = 'Current system notes version:'.             "#EC NOTEXT

    CONCATENATE
    'Before you proceed, you should verify that the'        "#EC NOTEXT
    'Target System' INTO T_SI_NO1 SEPARATED BY SPACE.       "#EC NOTEXT
    CONCATENATE 'has the latest version of notes:'          "#EC NOTEXT
    '2399707, 2502552' INTO T_SI_NO2 SEPARATED BY SPACE.

    CONCATENATE
    'Additionally please make sure, SI Catalog contains'    "#EC NOTEXT
    'target system: '                                       "#EC NOTEXT
    INTO T_SI_NO3 SEPARATED BY SPACE.

    T_SI_NO4 = C_TARGET_S4HANA_VERSION_DESC.

  ENDIF.

  " Set ATC checks for S4 conversion titles.
  IF EXTRACT_ATC_S4_CHECK EQ ABAP_TRUE.

    TITL_S4  = 'ATC for SAP S/4HANA'.                       "#EC NOTEXT

    T_ATCRES = 'Choose from previously executed list'.      "#EC NOTEXT

    CONCATENATE 'Choose from a file(SAP Fiori App Custom '  "#EC NOTEXT
    'Code Migration format)'                                "#EC NOTEXT
    INTO T_ATCEXL.
    T_ATCEX2 = 'No ICR support for this case'.              "#EC NOTEXT

    T_AT_RFC = 'RFC Destination'.                           "#EC NOTEXT
    T_AT_VAR =
    'Choose "SAP S/4HANA Readiness Check" result:'.         "#EC NOTEXT
    BTN_ATC = 'Choose'.                                     "#EC NOTEXT

    CONCATENATE 'The ATC check is more than'                "#EC NOTEXT
    C_ATC_DAYS_CHECK
                'days old.'                                 "#EC NOTEXT
                INTO T_AT_DAT SEPARATED BY SPACE.

    T_AT_SY1 =
    'The Readiness Check result is from another system.'.   "#EC NOTEXT
    CONCATENATE
    'Run ATC with an object provider pointing to '          "#EC NOTEXT
    SY-SYSID(3)
    '.'
    INTO T_AT_SY2 RESPECTING BLANKS.

  ENDIF.

  " Set titles for HANA sizing report section.
  IF EXTRACT_HN_SIZING_CHECK EQ ABAP_TRUE.
    TTL_HANA  = 'HANA sizing report'.                       "#EC NOTEXT
    T_HN_SIZ = 'HANA sizing results (.txt)'.                "#EC NOTEXT
    UPL_SIZ = 'Upload'.                                     "#EC NOTEXT
  ENDIF.

  " Set SCI Hana titles.
  IF EXTRACT_SCI_HANA_CHECK EQ ABAP_TRUE OR
     EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_TRUE.

    PERFORM SET_SCI_HANA_TITLES.

    " Set selection screen titles elements.
    TITL8 = 'HANA SAP Code Inspector execution mode'.       "#EC NOTEXT

    TSCI_HAS = 'Choose from previously executed list'.      "#EC NOTEXT
    TSCI_XLS = 'Choose from files'.                         "#EC NOTEXT
    WRITE ICON_MESSAGE_WARNING AS ICON TO ISCI_W.

    CONCATENATE 'System is missing the necessary '          "#EC NOTEXT
    'SAP Code Inspector check variants'                     "#EC NOTEXT
    INTO TSCI_W.
    TSCI_W1 =
    'required to extract HANA data.'.                       "#EC NOTEXT

    CONCATENATE 'Please follow the instructions '           "#EC NOTEXT
            'in SAP notes: 1912445, 1935918'                "#EC NOTEXT
            INTO TSCI_W2.

    TXLS_FD  = 'Excel File for FUNCTIONAL_DB'.              "#EC NOTEXT
    TXLS_FDA = 'Excel File for FUNCTIONAL_DB_ADDITION'.     "#EC NOTEXT

    CONCATENATE 'The FUNCTIONAL_DB check is more than'      "#EC NOTEXT
                 C_SCI_DAYS_CHECK 'days old.'               "#EC NOTEXT
    INTO TSCI1DAT SEPARATED BY SPACE.
    CONCATENATE 'The FUNCTIONAL_DB_ADD check is more than'  "#EC NOTEXT
                 C_SCI_DAYS_CHECK 'days old.'               "#EC NOTEXT
    INTO TSCI2DAT SEPARATED BY SPACE.
    CONCATENATE 'The PERFRORMANCE_DB check is more than'    "#EC NOTEXT
                 C_SCI_DAYS_CHECK 'days old.'               "#EC NOTEXT
    INTO TSCI3DAT SEPARATED BY SPACE.

    IF EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_TRUE.
      TXLS_PER = 'Excel File for PERFORMANCE_DB'.           "#EC NOTEXT
    ENDIF.

    UP_EXCEL = 'Upload'.                                    "#EC NOTEXT

  ELSE.
    P_SCIPRF = EXTRACT_SCI_HANA_PERFORMANCE = ABAP_FALSE.
  ENDIF.

  " Check if ETL should extract SCI Hana check
  " and the system have the the corresponding
  " check variants for running hana code inspector
  " according to SAP Note 1935918
  PERFORM CHECK_VERSION_SCI_FOR_HANA.

  IF G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_FALSE.
    R_SCIXLS = ABAP_TRUE.
    R_SCIHAS = ABAP_FALSE.
  ENDIF.

* call Panaya REST service to get data
* from panaya servers
  PERFORM GET_REST_SERVICE_DATA
    USING C_REST_SERVICE_ADDRESS
    CHANGING
      REST_MAJOR_VERSION_ERR
      REST_VERSION_MISMATCH_ERR
      REST_FALLBACK_ACTIVE.

* Determine displayed message
  IF REST_MAJOR_VERSION_ERR EQ 'X'.
    WARN1 = C_ERROR_VERSION_MSG_FULL.
  ELSE.
    WARN1 = C_VERSION_MISMATCH_MSG.
  ENDIF.


* build notif param
  IF REST_FALLBACK_ACTIVE = 'X'.

    GT_ETL_MESSAGE-MESSAGE =
    'Failed to validate the version against the server'.    "#EC NOTEXT

    PERFORM ADD_NOTIFICATION USING VALIDATION_CONNECTION_ERROR
                                   LV_NOTIFICATION_PARAM
                                   GT_ETL_MESSAGE-MESSAGE.
  ELSE.
    IF REST_VERSION_MISMATCH_ERR EQ 'X'.

      GT_ETL_MESSAGE-MESSAGE =
      'There is a newer version than the one being used '.  "#EC NOTEXT

      PERFORM ADD_NOTIFICATION USING VALIDATION_VERSION_MISMATCH
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.
    ELSEIF REST_MAJOR_VERSION_ERR EQ 'X'.

      GT_ETL_MESSAGE-MESSAGE =
      'Client version is below the minimal version '.       "#EC NOTEXT

      PERFORM ADD_NOTIFICATION USING VALIDATION_MINIMAL_VER_ERROR
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.
    ELSE.

      GT_ETL_MESSAGE-MESSAGE =
      'Client is using the latest version '.                "#EC NOTEXT
      PERFORM ADD_NOTIFICATION USING VALIDATION_SUCCESS
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.
    ENDIF.
  ENDIF.

  CONCATENATE 'ETL_' SY-SYSID '_' SY-DATUM '_' SY-UZEIT '.xml'
              INTO FILENAME.

  FILE_FILTER = 'XML'.
  DEFAULT_EXTENSION = 'XML'.
  DEFAULT_FILENAME = FILENAME.
  INITIAL_DIRECTORY = SAPWORKDIR.

  PERFORM GET_SAPWORKDIR.

  P_FILEN = FILENAME.
  P_FORE = SAPWORKDIR.

* Set the default background filename
  CALL FUNCTION 'FILE_GET_NAME_USING_PATH'
    EXPORTING
      LOGICAL_PATH               = 'TMP'
      FILE_NAME                  = FILENAME
    IMPORTING
      FILE_NAME_WITH_PATH        = P_BACK
    EXCEPTIONS
      PATH_NOT_FOUND             = 1
      MISSING_PARAMETER          = 2
      OPERATING_SYSTEM_NOT_FOUND = 3
      FILE_SYSTEM_NOT_FOUND      = 4
      OTHERS                     = 5.

  IF SY-SUBRC IS INITIAL.
* Putting only the directory in the screen field, withou the filename.
* If the directory is not empty.
    IF ( P_BACK NE FILENAME ).
      LEN = STRLEN( P_BACK ).
      FILE_LEN = STRLEN( FILENAME ).
      LEN = LEN - FILE_LEN.
      P_BACK = P_BACK(LEN).

*     Get the relevant system seperator.
      LEN = LEN - 1.
      SYSTEM_SEPERATOR = P_BACK+LEN(1).
    ELSE.
      CLEAR P_BACK.
    ENDIF.
  ELSE.
    CLEAR P_BACK.
  ENDIF.

  GV_BACK_PATH = P_BACK.

  OBJ_PERC = 100 / NUM_OBJECT_TYPES.

  SET TITLEBAR 'UE' OF PROGRAM 'SAPLS_SEARCH'
          WITH 'Panaya code extract tool'.                  "#EC NOTEXT

* Fill in the System's Role's value list
  IF ( IS_ON_TRIAL = 'X' ).
    VALUE-KEY = 'DEV'.
    VALUE-TEXT = 'Development'.                             "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'TST'.
    VALUE-TEXT = 'Testing/QA'.                              "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'PRD'.
    VALUE-TEXT = 'Production'.                              "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'SANDBOX'.
    VALUE-TEXT = 'Sandbox'.                                 "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'EDUCATION'.
    VALUE-TEXT = 'Education/Training'.                      "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'PRD_COPY'.
    VALUE-TEXT = 'Copy of Production'.                      "#EC NOTEXT
    APPEND VALUE TO LIST.
    VALUE-KEY = 'OTHER'.
    VALUE-TEXT = 'Unspecified'.                             "#EC NOTEXT
    APPEND VALUE TO LIST.

    NAME = 'P_ROLE'.
    CALL FUNCTION 'VRM_SET_VALUES'
      EXPORTING
        ID     = NAME
        VALUES = LIST.

    NAME = 'P_TRROLE'.
    CALL FUNCTION 'VRM_SET_VALUES'
      EXPORTING
        ID     = NAME
        VALUES = LIST.
  ENDIF.

* Initialize the known third party namespaces.
  PERFORM INIT_THIRD_PARTY_RANGE.

  CLEAR CUSTOMER_OBJECTS.
  CUSTOMER_OBJECTS-SIGN   = 'I'.
  CUSTOMER_OBJECTS-OPTION = 'CP'.
  CUSTOMER_OBJECTS-LOW    = 'Z*'. APPEND CUSTOMER_OBJECTS.
  CUSTOMER_OBJECTS-LOW    = 'Y*'. APPEND CUSTOMER_OBJECTS.
  CUSTOMER_OBJECTS-LOW    = '/1BCDWB/IQ*'. APPEND CUSTOMER_OBJECTS.
  CUSTOMER_OBJECTS-LOW    = '/1BCDWB/LIQ*'. APPEND CUSTOMER_OBJECTS.

  CLEAR CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-SIGN = 'I'.
  CUST_NAMESPACE_RNG-OPTION = 'CP'.
  CUST_NAMESPACE_RNG-LOW = 'Z*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'Y*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'LZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'LY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPLZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPLY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'DBZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'DBY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPMZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPMY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'MZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'MY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPDBZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPDBY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'FZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'FY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPFZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPFY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'DZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'DY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPDZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPDY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'MSTZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'MSTY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'UZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'UY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPUZ*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'SAPUY*'. APPEND CUST_NAMESPACE_RNG.
  CUST_NAMESPACE_RNG-LOW = 'MP9*'. APPEND CUST_NAMESPACE_RNG.

  PERFORM POPULATE_VOFM_PROGRAMS_RNG
    TABLES CUST_NAMESPACE_RNG[].

  CLEAR EXCL_NAMESPACES.
  EXCL_NAMESPACES-SIGN = 'I'.
  EXCL_NAMESPACES-OPTION = 'EQ'.
  EXCL_NAMESPACES-LOW = '/VIRSA/'.
  APPEND EXCL_NAMESPACES.
  EXCL_NAMESPACES-LOW = '/ICORP/'.
  APPEND EXCL_NAMESPACES.
  EXCL_NAMESPACES-LOW = '/1SAP1/'.
  APPEND EXCL_NAMESPACES.


* Find non-SAP namespaces
  SELECT * FROM TRNSPACET
  INTO TABLE NAMESPACES
  WHERE ( SAPFLAG = SPACE
  AND     CHANGEUSER <> 'SAP' )
  OR    ( NAMESPACE IN THIRD_PARTY_NS ) .

  IF SY-SUBRC IS INITIAL.
    LOOP AT NAMESPACES INTO NAMESPACE.
      CONCATENATE NAMESPACE-NAMESPACE '*' INTO CUSTOMER_OBJECTS-LOW.
      APPEND CUSTOMER_OBJECTS.
    ENDLOOP.
  ENDIF.

* SI Additions
  PERFORM GET_SI_VERSION_AND_NOTES.

* Activate 'Execute in background' when background mode is active
* (default active)
  CLEAR STAT_EXCLUDE.
  APPEND 'ONLI' TO STAT_EXCLUDE.
  APPEND 'PRIN' TO STAT_EXCLUDE.

  CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
    EXPORTING
      P_STATUS  = SY-PFKEY
    TABLES
      P_EXCLUDE = STAT_EXCLUDE.

*---------------------------------------------------------------------*
*   START-OF-SELECTION
*---------------------------------------------------------------------*
START-OF-SELECTION.
*------------------

  DATA: LV_ERROR TYPE C.

  G_FULLNAME_FUNC_DB      = PSRV_FD.
  G_FULLNAME_FUNC_DB_ADD  = PSRV_FDA.
  G_FULLNAME_PER_DB       = PSRV_PER.

  IF CUST_EDIT_PARAMS = 'X'.
    PERFORM UPDATE_FLAGS_FROM_SEL.
  ENDIF.

  PERFORM GET_SCI_INSPECTION_DATES.

  PERFORM VALIDITY_CHECKS CHANGING LV_ERROR.
  CHECK LV_ERROR = ABAP_FALSE.

  PERFORM CHECK_SI_TARGET_STACK CHANGING LV_ERROR.
  CHECK LV_ERROR = ABAP_FALSE.

  IF SY-BATCH IS INITIAL.
*  Confirm whith the user the extraction from the wanted systems.
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
*       TITLEBAR              = ' '
*       DIAGNOSE_OBJECT       = ' '
        TEXT_QUESTION         = QUESTION
        DISPLAY_CANCEL_BUTTON = ' '
      IMPORTING
        ANSWER                = ANSWER.

*   If chose to continue
    CHECK ANSWER = '1'.
  ENDIF.

* Set the temporary file names
  PERFORM SET_TEMP_FILENAMES.

  GV_BACK_PATH = P_BACK.

* Generate the full file name.
  IF R_FORE IS INITIAL.

    CONCATENATE 'ETL_' SY-SYSID '_' SY-DATUM '_'
      SY-UZEIT '.xml'                                       "#EC NOTEXT
      INTO FILENAME.

    DEFAULT_FILENAME = FILENAME.
    P_FILEN = FILENAME.

    PERFORM CORRECT_SERVER_PATH CHANGING P_BACK.
    CONCATENATE P_BACK P_FILEN INTO P_BACK.
  ELSE.
    PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
                     CHANGING P_FORE
                              P_FORE.
  ENDIF.

  IF P_RFCDES IS INITIAL.
    P_RFCDES = 'NONE'.
  ENDIF.
  IF NOT TESTING_DATA_ONLY IS INITIAL.
    NO_SUET_DATA = 'X'.
  ENDIF.

* Start the run
  CONCATENATE 'Started running ETL version '                "#EC NOTEXT
              REL_SPECIFIC_VER
              GENERAL_PART_VER
  INTO SUCC_MESS
  SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING SUCC_MESS ABAP_TRUE.

* Check that the program is not running in background with foreground
* option
  IF NOT SY-BATCH IS INITIAL AND NOT R_FORE IS INITIAL.
    PERFORM RAISE_ERROR USING
          'Please select background execution mode '.       "#EC NOTEXT
  ENDIF.

  CLEAR: G_APP_STRUC, G_INC_STRUC, GT_ETL_MESSAGE, G_VIEW_WITH_AST.
  REFRESH: GT_ETL_MESSAGE, GT_MODIF.

* append lines of messages that where found in the selection screen
  LOOP AT GT_SCR_MESSAGE.
    PERFORM ADD_MESSAGE USING GT_SCR_MESSAGE-MESSAGE ABAP_FALSE.
  ENDLOOP.
  CLEAR GT_SCR_MESSAGE[].

  PERFORM INIT.
  PERFORM VERSION_SPECIFIC_INIT.

* Create the main factory and the initial document
  PERFORM CREATE_XML_DOCUMENT.

* Create the root element of the XML
  PERFORM XML_HEADER USING G_IREF_PDOCUMENT ROOT_ELEMENT_NAME
                     CHANGING G_IREF_ROOT_ELEM.

  PERFORM OPEN_XML_FILE.

* Add data to the XML
  PERFORM ADD_DATA_TO_XML.

  PERFORM CLOSE_XML_FILE.

*----------------
END-OF-SELECTION.
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
*       FORM create_xml_document                                      *
*---------------------------------------------------------------------*
FORM CREATE_XML_DOCUMENT.

  DATA: L_ENCODING TYPE STRING,
        I_ENCODING TYPE REF TO IF_IXML_ENCODING.

* create the main factory
  G_IREF_PIXML = CL_IXML=>CREATE( ).

* create the initial document
  G_IREF_PDOCUMENT = G_IREF_PIXML->CREATE_DOCUMENT( ).

  L_ENCODING = ENCODING.
  I_ENCODING = G_IREF_PIXML->CREATE_ENCODING( CHARACTER_SET = L_ENCODING
                                                      BYTE_ORDER = '0' )
                                                      .
  CALL METHOD G_IREF_PDOCUMENT->SET_ENCODING( ENCODING = I_ENCODING ).

ENDFORM.                          " create_xml_document
*---------------------------------------------------------------------*
*       FORM SET_TEMP_FILENAMES                                       *
*---------------------------------------------------------------------*
FORM SET_TEMP_FILENAMES.

  DATA: PATH_TAB TYPE TABLE OF STRING,
        CURR_PATH TYPE STRING,
        PATH_LENGTH TYPE I,
        FILE_SEPARATOR TYPE C,
        LEN TYPE I,
        COMP TYPE I.

* Set temp filename
  CONCATENATE 'temp' '_' SY-DATUM '_' SY-UZEIT '.xml'
   INTO TEMP_FILENAME.

* Check if foreground or background mode was set
  IF NOT R_FORE IS INITIAL.
    CONCATENATE P_FORE TEMP_FILENAME INTO TEMP_FORE_FILENAME.
  ELSE.
    CONCATENATE P_BACK TEMP_FILENAME INTO TEMP_BACK_FILENAME.
  ENDIF.
ENDFORM.                    "SET_TEMP_FILENAMES

*---------------------------------------------------------------------*
*       FORM BUILD_TEMP_FILENAME                                      *
*---------------------------------------------------------------------*
FORM BUILD_TEMP_FILENAME USING FILEPATH
                               SEPARATOR
                         CHANGING NEW_FILE_PATH.

  DATA: PATH_TAB TYPE TABLE OF STRING,
       CURR_PATH TYPE STRING,
       PATH_LENGTH TYPE I.

*   Split the filename at file separator. Concatenate all
*   path components except the last one that will be the temporary
*   filename.
  SPLIT FILEPATH AT SEPARATOR INTO TABLE PATH_TAB.
  DESCRIBE TABLE PATH_TAB LINES PATH_LENGTH.
  DELETE PATH_TAB INDEX PATH_LENGTH.
  LOOP AT PATH_TAB INTO CURR_PATH.
    IF SY-TABIX = 1.
      NEW_FILE_PATH = CURR_PATH.
    ELSE.
      CONCATENATE NEW_FILE_PATH SEPARATOR CURR_PATH
      INTO NEW_FILE_PATH.
    ENDIF.
  ENDLOOP.
  CONCATENATE NEW_FILE_PATH SEPARATOR TEMP_FILENAME
    INTO NEW_FILE_PATH.

ENDFORM.                    "BUILD_TEMP_FILENAME

*---------------------------------------------------------------------*
*       FORM open_xml_file                                            *
*---------------------------------------------------------------------*
FORM OPEN_XML_FILE.

  DATA: HEADER_STRING TYPE STRING.

* Initialize stream factory
  G_IREF_PSTREAMFACTORY = G_IREF_PIXML->CREATE_STREAM_FACTORY( ).
  G_OSTREAM = G_IREF_PSTREAMFACTORY->CREATE_OSTREAM_ITABLE(
                                             TABLE = G_BUFFER_ITAB ).
  CALL METHOD G_OSTREAM->SET_PRETTY_PRINT
    EXPORTING
      PRETTY_PRINT = 'X'.

  CONCATENATE '<?xml version="1.0" encoding="' "#EC NOTEXT
  ENCODING '"?>'
              INTO HEADER_STRING.

  CALL METHOD G_OSTREAM->WRITE_STRING
    EXPORTING
      STRING = HEADER_STRING.
  PERFORM APPEND_STRING_TO_FILE USING '<ROOT_ELEMENT>'.

ENDFORM.                    "open_xml_file

*---------------------------------------------------------------------*
*       FORM close_xml_file                                           *
*---------------------------------------------------------------------*
FORM CLOSE_XML_FILE.

  DATA: STREAM_SIZE TYPE I,
        MSG_LINE1(70) TYPE C,
        MSG_LINE2(70) TYPE C,
        MSG_LINE3(70) TYPE C.

  DATA: LV_TICKET TYPE STRING.

  PERFORM APPEND_STRING_TO_FILE USING '</ROOT_ELEMENT>'.

* flush the buffered data to the file - last time
  STREAM_SIZE = G_OSTREAM->GET_NUM_WRITTEN_RAW( ).
  PERFORM APPEND_ITAB_TO_FILE USING STREAM_SIZE G_BUFFER_ITAB.

* Write the file to original location
  PERFORM MOVE_FILE USING TEMP_FORE_FILENAME
                          TEMP_BACK_FILENAME
                          P_FORE
                          P_BACK
                          R_FORE.

* Compress ETL File Without Upload
  PERFORM COMPRESS_WITHOUT_UPLOAD.

* Compress and Upload to Panaya
  PERFORM COMPRESS_AND_UPLOAD CHANGING LV_TICKET.

* Display finish message
  IF PANAYA_TEST_MODE IS INITIAL.
    MSG_LINE1 =
    'The data extraction was finished successfully.'. "#EC NOTEXT
    IF NO_USAGE = 'X'.
      MSG_LINE2 =
      'Please note: No usage statistics were found.'. "#EC NOTEXT
      MSG_LINE3 =
      'Contact Panaya support for assistance.'. "#EC NOTEXT
      IF POPUP_OK = 'X'.
        CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT_LO'
          EXPORTING
            TITEL        = 'Panaya' "#EC NOTEXT
            TEXTLINE1    = MSG_LINE1
            TEXTLINE2    = MSG_LINE2
            TEXTLINE3    = MSG_LINE3
            START_COLUMN = 15
            START_ROW    = 6.
      ELSE.
        WRITE:/ MSG_LINE1.
        WRITE:/ MSG_LINE2.
        WRITE:/ MSG_LINE3.
      ENDIF.
    ELSE.
      IF POPUP_OK = 'X'.

        CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT_LO'
          EXPORTING
            TITEL        = 'Panaya' "#EC NOTEXT
            TEXTLINE1    = MSG_LINE1
            START_COLUMN = 15
            START_ROW    = 6.
      ELSE.
        WRITE:/ MSG_LINE1.
        WRITE:/ MSG_LINE2.
        WRITE:/ MSG_LINE3.
      ENDIF.

    ENDIF.
  ENDIF.

ENDFORM.                    "close_xml_file

*---------------------------------------------------------------------*
*       FORM append_string_to_file                                    *
*---------------------------------------------------------------------*
FORM APPEND_STRING_TO_FILE USING STR TYPE STRING.

  CALL METHOD G_OSTREAM->WRITE_STRING
    EXPORTING
      STRING = NEW_LINE.
  CALL METHOD G_OSTREAM->WRITE_STRING
    EXPORTING
      STRING = STR.
  CALL METHOD G_OSTREAM->WRITE_STRING
    EXPORTING
      STRING = NEW_LINE.

ENDFORM.                    "append_string_to_file

*---------------------------------------------------------------------*
*       FORM append_xml_element_to_file                               *
*---------------------------------------------------------------------*
FORM APPEND_XML_ELEMENT_TO_FILE USING
                                I_ELEMENT TYPE REF TO IF_IXML_ELEMENT
                                I_REMOVE_NODE TYPE C.

  DATA: STREAM_SIZE TYPE I.

  STREAM_SIZE = G_OSTREAM->GET_NUM_WRITTEN_RAW( ).

  IF ( STREAM_SIZE > BUFFER_MAX_SIZE ).
    PERFORM APPEND_ITAB_TO_FILE USING STREAM_SIZE G_BUFFER_ITAB.
    G_OSTREAM = G_IREF_PSTREAMFACTORY->CREATE_OSTREAM_ITABLE(
                                             TABLE = G_BUFFER_ITAB ).
    CALL METHOD G_OSTREAM->SET_PRETTY_PRINT
      EXPORTING
        PRETTY_PRINT = 'X'.
    CLEAR G_BUFFER_ITAB.
  ENDIF.

  CALL METHOD G_OSTREAM->WRITE_STRING
    EXPORTING
      STRING = NEW_LINE.
  CALL METHOD I_ELEMENT->RENDER( OSTREAM = G_OSTREAM ).

  IF I_REMOVE_NODE = 'X'.
    CALL METHOD I_ELEMENT->REMOVE_NODE.
    CLEAR I_ELEMENT.
  ENDIF.

ENDFORM.                    "append_xml_element_to_file

*---------------------------------------------------------------------*
*       FORM update_progress                                          *
*---------------------------------------------------------------------*
FORM UPDATE_PROGRESS USING TEXT.

  DATA: BATCH_TEXT(50) TYPE C,
        CURR_STEP(2) TYPE C,
        TOTAL_STEPS(2) TYPE C,
        STEPS_TEXT(50) TYPE C,
        PROGRESS_TEXT(512) TYPE C.

  CURR_OBJECT_TYPE = CURR_OBJECT_TYPE + 1.
  PERCENTAGE = PERCENTAGE + OBJ_PERC.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      PERCENTAGE = PERCENTAGE
      TEXT       = TEXT.

*  IF SY-BATCH = 'X'.
  CURR_STEP = CURR_OBJECT_TYPE.
  TOTAL_STEPS = NUM_OBJECT_TYPES.
  CONCATENATE '(' CURR_STEP ')' INTO STEPS_TEXT.
  CONCATENATE TEXT STEPS_TEXT INTO PROGRESS_TEXT SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING PROGRESS_TEXT ABAP_TRUE.

  PERFORM ADD_USED_MEMORY_TO_LOG.
*  ENDIF.

ENDFORM.                    "update_progress

*---------------------------------------------------------------------*
*       FORM add_structure_to_xml                                     *
*---------------------------------------------------------------------*
FORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES STRUCTURE DFIES
              USING VALUE(L_IREF_ELEM)   TYPE REF TO IF_IXML_ELEMENT
              VALUE(L_OREF_DESCR_SOURCE) TYPE REF TO CL_ABAP_STRUCTDESCR
              VALUE(FS_TEMP_DATA)        TYPE ANY.

  IF NOT L_TAB_DFIES IS INITIAL.
    PERFORM DFIES_TO_XML TABLES L_TAB_DFIES
                         USING G_IREF_PDOCUMENT L_IREF_ELEM
                               FS_TEMP_DATA SKIP_EMPTY_TAGS.
  ELSE.
    PERFORM DESCR_TO_XML USING L_OREF_DESCR_SOURCE->COMPONENTS
                               G_IREF_PDOCUMENT L_IREF_ELEM
                               FS_TEMP_DATA SKIP_EMPTY_TAGS.
  ENDIF.

ENDFORM.                          " add_structure_to_xml

*---------------------------------------------------------------------*
*       FORM descr_to_xml                                             *
*---------------------------------------------------------------------*
FORM DESCR_TO_XML USING VALUE(PI_TAB_DESCR) TYPE ABAP_COMPDESCR_TAB
                  VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
                  VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
                  VALUE(PI_VALUE)     TYPE ANY
                  VALUE(PI_CONTENT)   TYPE BOOLEAN.

  DATA:
        L_FIELD LIKE LINE OF PI_TAB_DESCR,
        L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_NAME  TYPE STRING,
        L_VALUE TYPE STRING.
  FIELD-SYMBOLS: <FS_VALUE>.

  LOOP AT PI_TAB_DESCR INTO L_FIELD.
    L_NAME = L_FIELD-NAME.
    ASSIGN COMPONENT L_FIELD-NAME OF STRUCTURE PI_VALUE
                                     TO <FS_VALUE>.
    IF SY-SUBRC <> 0.
      CLEAR L_VALUE.
    ELSE.
      L_VALUE = <FS_VALUE>.
    ENDIF.

*   If the value of the current attribute is initial and empty
*   attributes should not be written - skip this field
*   Initial value for numeric data types doesn't is not skipped
    IF <FS_VALUE> IS INITIAL AND NOT PI_CONTENT IS INITIAL AND
       NOT ( L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_NUM OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_PACKED OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_HEX OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_FLOAT OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT1 OR
        L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT2 OR
        L_FIELD-TYPE_KIND = '%' ).
      CONTINUE.
    ENDIF.

*   Replace login name to XXX
    IF SHOW_LOGIN_NAME IS INITIAL AND ( L_NAME = 'CREATED_BY' OR
    L_NAME = 'CHANGED_BY' OR L_NAME = 'AS4USER' OR L_NAME =
    'USERNAME' OR
    L_NAME = 'UNAM' OR L_NAME = 'CNAM' OR L_NAME = 'ANAM' OR
    L_NAME = 'GENUSER' OR L_NAME = 'AUTHOR' OR L_NAME = 'MOD_USER' OR
    L_NAME = 'MODBE' OR L_NAME = 'CREATE_USR' OR L_NAME =
    'CHANGE_USR' OR
    L_NAME = 'CHANGEUSER' OR L_NAME = 'CREATEDBY' OR L_NAME =
    'CHANGEDBY' OR
     L_NAME = 'CWBUSER' OR L_NAME = 'RESPUSER' OR L_NAME = 'LASTUSER' OR
        L_NAME = 'RESPONSIBL' OR L_NAME = 'FIRSTUSER' OR
        L_NAME = 'UNAME' OR L_NAME = 'USERNAME' OR L_NAME = 'BNAME'
       OR L_NAME = 'RFCUSER' ) AND L_VALUE <> 'SAP'.
      L_VALUE = 'XXX'.
    ENDIF.

    IF SHOW_SERVERS_NAME IS INITIAL AND
      ( L_NAME = 'RFCHOST').
      L_VALUE = 'XXX'.
    ENDIF.
    CALL METHOD PI_ELEM->SET_ATTRIBUTE
      EXPORTING
        NAME  = L_NAME
        VALUE = L_VALUE.
  ENDLOOP.

ENDFORM.                               " DESCR_TO_XML

*---------------------------------------------------------------------*
*       FORM dfies_to_xml                                             *
*---------------------------------------------------------------------*
FORM DFIES_TO_XML TABLES   PI_TAB_DFIES STRUCTURE DFIES
                  USING VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
                        VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
                        VALUE(PI_VALUE)     TYPE ANY
                        VALUE(PI_CONTENT)   TYPE BOOLEAN.

  DATA:
        L_DFIES TYPE DFIES,
        L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_ELEM  TYPE REF TO IF_IXML_ELEMENT,
        L_NAME  TYPE STRING,
        L_VALUE TYPE STRING.
  FIELD-SYMBOLS: <FS_VALUE>.

  LOOP AT PI_TAB_DFIES INTO L_DFIES.

    L_NAME = L_DFIES-FIELDNAME.
    ASSIGN COMPONENT L_DFIES-FIELDNAME OF STRUCTURE PI_VALUE
                                       TO <FS_VALUE>.
    IF SY-SUBRC <> 0.
      CLEAR L_VALUE.
    ELSE.
      L_VALUE = <FS_VALUE>.
    ENDIF.

*   If the value of the current attribute is initial and empty
*   attributes should not be written - skip this field
*   Initial value for numeric data types doesn't is not skipped
    IF <FS_VALUE> IS INITIAL AND NOT PI_CONTENT IS INITIAL AND
      NOT ( L_DFIES-INTTYPE = 'X' OR L_DFIES-INTTYPE = 'I' OR
        L_DFIES-INTTYPE = 'b' OR L_DFIES-INTTYPE = 's' OR
        L_DFIES-INTTYPE = 'P' OR L_DFIES-INTTYPE = 'F' OR
        L_DFIES-INTTYPE = 'N' ).
      CONTINUE.
    ENDIF.

    CALL METHOD PI_ELEM->SET_ATTRIBUTE
      EXPORTING
        NAME  = L_NAME
        VALUE = L_VALUE.

  ENDLOOP.

ENDFORM.                               " dfies_to_xml

*---------------------------------------------------------------------*
*       FORM add_attribute_to_node                                    *
*---------------------------------------------------------------------*
FORM ADD_ATTRIBUTE_TO_NODE USING
                        VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
                        VALUE(PI_ATTR_NAME) TYPE STRING
                        VALUE(PI_VALUE)     TYPE ANY.

  DATA: L_VALUE TYPE STRING.

  L_VALUE = PI_VALUE.

  IF L_VALUE IS INITIAL AND NOT SKIP_EMPTY_TAGS IS INITIAL.
    EXIT.
  ENDIF.

  CALL METHOD PI_ELEM->SET_ATTRIBUTE
    EXPORTING
      NAME  = PI_ATTR_NAME
      VALUE = L_VALUE.

ENDFORM.                    "add_attribute_to_node

*---------------------------------------------------------------------*
*       FORM xml_header                                               *
*---------------------------------------------------------------------*
FORM XML_HEADER USING VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
                      VALUE(PI_XML_ROOT)  TYPE C
                CHANGING VALUE(PC_ELEM)   TYPE REF TO IF_IXML_ELEMENT.

  DATA:
        L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_RESULT  TYPE I,
        L_NAME  TYPE STRING.

  L_NAME = PI_XML_ROOT .
  L_ELEM = PI_PDOCUMENT->CREATE_ELEMENT( NAME = L_NAME ).
  L_RESULT = PI_PDOCUMENT->APPEND_CHILD( L_ELEM ).
  PC_ELEM = L_ELEM.

ENDFORM.                          " xml_header

*---------------------------------------------------------------------*
*       FORM create_xml_node                                          *
*---------------------------------------------------------------------*
FORM CREATE_XML_NODE USING
                     VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
                     VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
                     VALUE(PI_XML_NODE)    TYPE STRING
                   CHANGING VALUE(PC_ELEM) TYPE REF TO IF_IXML_ELEMENT.

  PC_ELEM = PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
                                  NAME   = PI_XML_NODE
                                  PARENT = PARENT_ELEMENT ).

ENDFORM.                          " create_xml_node

**---------------------------------------------------------------------*
**       FORM create_xml_node_value                                    *
**---------------------------------------------------------------------*
*FORM CREATE_XML_NODE_VALUE USING
*                     VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
*                     VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
*                     VALUE(PI_XML_NODE)    TYPE STRING
*                     VALUE(PI_VALUE)       TYPE ANY.
*
*  DATA: CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT.
*
*  PERFORM CREATE_XML_NODE_VALUE_CDATA USING  PI_PDOCUMENT
*                                             PARENT_ELEMENT
*                                             PI_XML_NODE
*                                             PI_VALUE
*                                             SPACE
*                                      CHANGING CDATA_ELEM.
*
*ENDFORM.                          " create_xml_node_value

*---------------------------------------------------------------------*
*       FORM create_xml_node_value_cdata                              *
*---------------------------------------------------------------------*
FORM CREATE_XML_NODE_VALUE_CDATA USING
                     VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
                     VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
                     VALUE(PI_XML_NODE)    TYPE STRING
                     VALUE(PI_VALUE)       TYPE ANY
                     VALUE(PI_WITH_CDATA)  TYPE C
                     CHANGING
                     VALUE(PC_ELEM)        TYPE REF TO IF_IXML_ELEMENT.

  DATA: L_VALUE TYPE STRING.

  IF PI_WITH_CDATA = 'X'.

    DATA: RVAL TYPE REF TO IF_IXML_CDATA_SECTION.
    L_VALUE = PI_VALUE.
    CALL METHOD PI_PDOCUMENT->CREATE_CDATA_SECTION
      EXPORTING
        CDATA = L_VALUE
      RECEIVING
        RVAL  = RVAL.

    PC_ELEM =  PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
                                     NAME   = PI_XML_NODE
*                                    value  = l_value
                                     PARENT = PARENT_ELEMENT ).

    CALL METHOD PC_ELEM->APPEND_CHILD
      EXPORTING
        NEW_CHILD = RVAL.

  ELSE.
    L_VALUE = PI_VALUE.
    PC_ELEM =  PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
                                     NAME   = PI_XML_NODE
                                     VALUE  = L_VALUE
                                     PARENT = PARENT_ELEMENT ).
  ENDIF.

ENDFORM.                          " create_xml_node_value

*---------------------------------------------------------------------*
*       FORM add_itab_to_xml_simple                                   *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_XML_SIMPLE
                 TABLES   I_TAB_SAP_DATA
                 USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
                          L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT
                          I_REC_TAG        TYPE STRING.

  DATA: DUMMY_TAB_HANDLES TYPE HANDLES_TAB_TYPE.

  PERFORM ADD_ITAB_TO_XML TABLES I_TAB_SAP_DATA DUMMY_TAB_HANDLES
                          USING  L_IREF_PDOCUMENT L_IREF_ROOT_ELEM
                                 I_REC_TAG.
ENDFORM.                          " add_itab_to_xml_simple

*---------------------------------------------------------------------*
*       FORM add_itab_to_xml                                          *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_XML
                 TABLES   I_TAB_SAP_DATA
                          I_TAB_HANDLES    TYPE HANDLES_TAB_TYPE
                 USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
                          L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT
                          I_REC_TAG        TYPE STRING.
  DATA: L_IREF_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_DATA  TYPE REF TO DATA,
        LINES_NUM TYPE I,
        STR_LINES_NUM TYPE STRING.
* Get the table size
  DESCRIBE TABLE I_TAB_SAP_DATA LINES LINES_NUM.
* If the size of the table is larger than the constant, write a warning.
  IF LINES_NUM > WARN_TABLE_SIZE.
    STR_LINES_NUM = LINES_NUM.
    CONCATENATE 'WARNING!! Table tag:' I_REC_TAG "#EC NOTEXT
         'contains' STR_LINES_NUM 'rows' INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  SORT I_TAB_SAP_DATA.

  FIELD-SYMBOLS: <FS_TEMP_TABLE> TYPE TABLE.
  FIELD-SYMBOLS: <FS_TEMP_DATA>.
  FIELD-SYMBOLS: <FS_TEMP> TYPE ANY.

  DATA L_OREF_DESCR_SOURCE TYPE REF TO CL_ABAP_STRUCTDESCR.
  DATA: L_TAB_DFIES TYPE TABLE OF DFIES.
  DATA: TEMP_WA_REF TYPE REF TO DATA.

  ASSIGN I_TAB_SAP_DATA[] TO <FS_TEMP_TABLE>.
  CREATE DATA L_DATA LIKE LINE OF <FS_TEMP_TABLE>.
  ASSIGN L_DATA->* TO <FS_TEMP_DATA>.

  PERFORM GET_VARIABLE_TYPE_FIELDS TABLES   L_TAB_DFIES
                                   USING    <FS_TEMP_DATA>
                                   CHANGING L_OREF_DESCR_SOURCE
                                            I_REC_TAG.

* Create XML doc with content
  LOOP AT <FS_TEMP_TABLE> INTO <FS_TEMP_DATA>.
    IF NOT I_REC_TAG IS INITIAL.
      PERFORM CREATE_XML_NODE USING L_IREF_PDOCUMENT L_IREF_ROOT_ELEM
                                    I_REC_TAG
                           CHANGING L_IREF_ELEM.
    ELSE.
      L_IREF_ELEM = L_IREF_ROOT_ELEM.
    ENDIF.

    PERFORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES
                                 USING  L_IREF_ELEM
                                        L_OREF_DESCR_SOURCE
                                        <FS_TEMP_DATA>.

    I_TAB_HANDLES-NODE_REF = L_IREF_ELEM.

    CREATE DATA I_TAB_HANDLES-WA LIKE <FS_TEMP_DATA>.
    ASSIGN I_TAB_HANDLES-WA->* TO <FS_TEMP>.
    <FS_TEMP> = <FS_TEMP_DATA>.
    APPEND I_TAB_HANDLES.
  ENDLOOP.

ENDFORM.                          " add_itab_to_xml

*---------------------------------------------------------------------*
*       FORM add_itab_to_file_simple                                  *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_FILE_SIMPLE
                 TABLES   I_TAB_SAP_DATA
                 USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
                          I_REC_TAG        TYPE STRING.

  DATA: L_IREF_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT,
        L_DATA  TYPE REF TO DATA.

  SORT I_TAB_SAP_DATA.

  FIELD-SYMBOLS: <FS_TEMP_TABLE> TYPE TABLE.
  FIELD-SYMBOLS: <FS_TEMP_DATA>.
  FIELD-SYMBOLS: <FS_TEMP> TYPE ANY.

  DATA L_OREF_DESCR_SOURCE TYPE REF TO CL_ABAP_STRUCTDESCR.
  DATA: L_TAB_DFIES TYPE TABLE OF DFIES.
  DATA: TEMP_WA_REF TYPE REF TO DATA.

  ASSIGN I_TAB_SAP_DATA[] TO <FS_TEMP_TABLE>.
  CREATE DATA L_DATA LIKE LINE OF <FS_TEMP_TABLE>.
  ASSIGN L_DATA->* TO <FS_TEMP_DATA>.

  PERFORM GET_VARIABLE_TYPE_FIELDS TABLES   L_TAB_DFIES
                                   USING    <FS_TEMP_DATA>
                                   CHANGING L_OREF_DESCR_SOURCE
                                            I_REC_TAG.

  L_IREF_ROOT_ELEM = L_IREF_PDOCUMENT->GET_ROOT_ELEMENT( ).

* Create XML doc with content
  LOOP AT <FS_TEMP_TABLE> INTO <FS_TEMP_DATA>.
    IF NOT I_REC_TAG IS INITIAL.
      PERFORM CREATE_XML_NODE USING L_IREF_PDOCUMENT
                                    L_IREF_ROOT_ELEM
                                    I_REC_TAG
                           CHANGING L_IREF_ELEM.
    ELSE.
      L_IREF_ELEM = L_IREF_ROOT_ELEM.
    ENDIF.

    PERFORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES
                                 USING  L_IREF_ELEM
                                        L_OREF_DESCR_SOURCE
                                        <FS_TEMP_DATA>.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING L_IREF_ELEM
                                             'X'.
  ENDLOOP.

ENDFORM.                          " add_itab_to_xml

*---------------------------------------------------------------------*
*       FORM get_variable_type_fields                                 *
*---------------------------------------------------------------------*
FORM GET_VARIABLE_TYPE_FIELDS TABLES L_TAB_DFIES STRUCTURE DFIES
             USING VALUE(REC)
             CHANGING
             VALUE(L_OREF_DESCR_SOURCE) TYPE REF TO CL_ABAP_STRUCTDESCR
             VALUE(VAR_TYPE_NAME)       TYPE STRING.

  DATA: L_TABNAME TYPE  DD02L-TABNAME.
  DATA: L_TABNAME_STRING TYPE  STRING.

  L_OREF_DESCR_SOURCE ?=
         CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( REC ).

  SEARCH L_OREF_DESCR_SOURCE->ABSOLUTE_NAME FOR '\TYPE='.
  IF SY-SUBRC = 0.
    SY-FDPOS = SY-FDPOS + STRLEN( '\TYPE=' ) .
    L_TABNAME = L_OREF_DESCR_SOURCE->ABSOLUTE_NAME+SY-FDPOS.
    L_TABNAME_STRING = L_TABNAME.
    CALL FUNCTION 'LOAN_CHECK_STRUCTURE_INIT'
      EXPORTING
        I_STRUCTURE_TABNAME = L_TABNAME
      TABLES
        IT_DFIES            = L_TAB_DFIES
      EXCEPTIONS
        OTHERS              = 4.
    IF VAR_TYPE_NAME IS INITIAL.
      VAR_TYPE_NAME = L_TABNAME_STRING.
    ENDIF.
  ENDIF.

ENDFORM.                          " get_variable_type_fields

*---------------------------------------------------------------------*
*       FORM append_itab_to_file                                      *
*---------------------------------------------------------------------*
FORM APPEND_ITAB_TO_FILE USING I_STREAM_SIZE TYPE I
                               I_TAB_CONVERTED_DATA TYPE XML_TAB_TYPE.

  DATA: L_OREF TYPE REF TO CX_ROOT,
        TEXT   TYPE STRING.
  DATA: L_FILE  TYPE STRING.
  DATA: LS_FILE TYPE XML_LINE_TYPE.
  DATA: L_REMAINING_SIZE TYPE I.
  DATA: L_RECSIZE        TYPE I.

  IF NOT R_FORE IS INITIAL.
    L_FILE =  TEMP_FORE_FILENAME.
    CALL METHOD CL_GUI_FRONTEND_SERVICES=>GUI_DOWNLOAD
      EXPORTING
        BIN_FILESIZE            = I_STREAM_SIZE
        FILENAME                = L_FILE
        FILETYPE                = 'BIN'
        APPEND                  = G_FILE_APPEND_MODE
      CHANGING
        DATA_TAB                = I_TAB_CONVERTED_DATA
      EXCEPTIONS
        FILE_WRITE_ERROR        = 1
        NO_BATCH                = 2
        GUI_REFUSE_FILETRANSFER = 3
        INVALID_TYPE            = 4
        NO_AUTHORITY            = 5
        UNKNOWN_ERROR           = 6
        HEADER_NOT_ALLOWED      = 7
        SEPARATOR_NOT_ALLOWED   = 8
        FILESIZE_NOT_ALLOWED    = 9
        HEADER_TOO_LONG         = 10
        DP_ERROR_CREATE         = 11
        DP_ERROR_SEND           = 12
        DP_ERROR_WRITE          = 13
        UNKNOWN_DP_ERROR        = 14
        ACCESS_DENIED           = 15
        DP_OUT_OF_MEMORY        = 16
        DISK_FULL               = 17
        DP_TIMEOUT              = 18
        FILE_NOT_FOUND          = 19
        DATAPROVIDER_EXCEPTION  = 20
        CONTROL_FLUSH_ERROR     = 21
        NOT_SUPPORTED_BY_GUI    = 22
        ERROR_NO_GUI            = 23
        OTHERS                  = 24.

    IF SY-SUBRC <> 0.
      DATA: EXPLAN TYPE STRING.
      IF SY-SUBRC = 17.
        EXPLAN = 'Disk is full'. "#EC NOTEXT
      ELSE.
        EXPLAN = SY-SUBRC.
      ENDIF.
      CONCATENATE 'Problem writing to file: ' "#EC NOTEXT
      EXPLAN INTO EXPLAN.
      PERFORM RAISE_ERROR USING EXPLAN.
    ENDIF.
  ENDIF.

* Server file
  IF NOT R_BACK IS INITIAL.
* Open file
    IF G_FILE_APPEND_MODE IS INITIAL.
      OPEN DATASET TEMP_BACK_FILENAME  FOR OUTPUT IN BINARY MODE.
    ELSE.
      OPEN DATASET TEMP_BACK_FILENAME  FOR APPENDING IN BINARY MODE.
    ENDIF.
* Write file
    L_REMAINING_SIZE = I_STREAM_SIZE.
    LOOP AT I_TAB_CONVERTED_DATA INTO LS_FILE.
      IF L_REMAINING_SIZE < 256.
        L_RECSIZE = L_REMAINING_SIZE.
      ELSE.
        L_RECSIZE = 256.
      ENDIF.

      TRANSFER LS_FILE TO TEMP_BACK_FILENAME  LENGTH L_RECSIZE.
      SUBTRACT L_RECSIZE FROM L_REMAINING_SIZE.
    ENDLOOP.
* Close file
    CLOSE DATASET TEMP_BACK_FILENAME .
    IF SY-SUBRC IS INITIAL.
*      MESSAGE s171(26) WITH p_back.
*     File & created
    ELSE.
*      MESSAGE e005(ps).
*     Cannot close output file
    ENDIF.
  ENDIF.

* The first time we write the file in overwrite mode, then we switch
* to append mode
  IF G_FILE_APPEND_MODE IS INITIAL.
    G_FILE_APPEND_MODE = 'X'.
  ENDIF.

ENDFORM.                    "append_itab_to_file
*&---------------------------------------------------------------------*
*&      Form  MOVE_FILE
*&---------------------------------------------------------------------*
*       Move file from initial location to the location specified by
*       user
*----------------------------------------------------------------------*
FORM MOVE_FILE USING P_TEMP_FORE_FILE
                     P_TEMP_BACK_FILE
                     P_ORIG_FORE_FILE
                     P_ORIG_BACK_FILE
                     P_IS_FORE.

  DATA: EXPLAN        TYPE STRING,
        ERROR_MSG     TYPE STRING,
        CURR_LINE_LEN TYPE I,
        DATA(256)     TYPE C,
        FILENAME1     TYPE STRING,
        FILENAME2     TYPE STRING.
  DATA: L_OREF     TYPE REF TO CX_ROOT,
        TEXT       TYPE STRING,
        TEXT_LEN   TYPE I,
        PARAM1(50) TYPE C,
        PARAM2(50) TYPE C,
        PARAM3(50) TYPE C,
        PARAM4(50) TYPE C.


  IF NOT P_IS_FORE IS INITIAL.

*   Copy the file to original location
    FILENAME1 = P_TEMP_FORE_FILE.
    FILENAME2 = P_ORIG_FORE_FILE.
    CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_COPY
      EXPORTING
        SOURCE             = FILENAME1
        DESTINATION        = FILENAME2
        OVERWRITE          = 'X'
      EXCEPTIONS
        CNTL_ERROR         = 1
        ERROR_NO_GUI       = 2
        WRONG_PARAMETER    = 3
        DISK_FULL          = 4
        ACCESS_DENIED      = 5
        FILE_NOT_FOUND     = 6
        DESTINATION_EXISTS = 7
        UNKNOWN_ERROR      = 8
        PATH_NOT_FOUND     = 9
        DISK_WRITE_PROTECT = 10
        DRIVE_NOT_READY    = 11
        OTHERS             = 12.

    IF SY-SUBRC <> 0.
      IF SY-SUBRC = 4.
        EXPLAN = 'Disk is full'. "#EC NOTEXT
      ELSE.
        EXPLAN = SY-SUBRC.
      ENDIF.
      CONCATENATE 'Problem writing to file: ' "#EC NOTEXT
      P_ORIG_FORE_FILE
        EXPLAN INTO EXPLAN.
      PERFORM RAISE_ERROR USING EXPLAN.
    ENDIF.

*   Delete the temporary file
    DATA: RC TYPE I.
    CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_DELETE
      EXPORTING
        FILENAME           = P_TEMP_FORE_FILE
      CHANGING
        RC                 = RC
      EXCEPTIONS
        FILE_DELETE_FAILED = 1
        CNTL_ERROR         = 2
        ERROR_NO_GUI       = 3
        FILE_NOT_FOUND     = 4
        ACCESS_DENIED      = 5
        UNKNOWN_ERROR      = 6
        OTHERS             = 7.
    IF SY-SUBRC <> 0.
      EXPLAN = SY-SUBRC.
      MESSAGE E001(00) WITH 'Problem deleting file: ' "#EC NOTEXT
      P_TEMP_FORE_FILE
       ' return code (RC) = ' RC. "#EC NOTEXT
    ENDIF.

  ELSE.
*    Open the temp file
    OPEN DATASET P_TEMP_BACK_FILE FOR INPUT IN BINARY
      MODE MESSAGE ERROR_MSG.

    OPEN DATASET P_ORIG_BACK_FILE FOR OUTPUT IN BINARY MODE
       MESSAGE ERROR_MSG.

*   Transfer the data to destination file
    DO.
      READ DATASET P_TEMP_BACK_FILE INTO DATA LENGTH CURR_LINE_LEN.
      IF SY-SUBRC <> 0.
        TRANSFER DATA TO P_ORIG_BACK_FILE
           LENGTH CURR_LINE_LEN.
        EXIT.
      ENDIF.
      TRANSFER DATA TO P_ORIG_BACK_FILE LENGTH CURR_LINE_LEN.
    ENDDO.

*   Close both files
    CLOSE DATASET P_TEMP_BACK_FILE.
    CLOSE DATASET P_ORIG_BACK_FILE.

*   Delete the file from current directory
    DELETE DATASET P_TEMP_BACK_FILE.

    IF SY-SUBRC <> 0.
      MESSAGE E001(00) WITH 'Problem deleting file: ' "#EC NOTEXT
      P_TEMP_BACK_FILE
        ' SUBC: ' SY-SUBRC.
      EXIT.
    ENDIF.
  ENDIF.
ENDFORM.                    " MOVE_FILE

*&---------------------------------------------------------------------*
*&  Include           ZETL_FILE_API
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*&      Form  SPLIT_PATH
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->PATH       text
*      -->DIR        text
*      -->FILENAME   text
*      -->EXTENSION  text
*----------------------------------------------------------------------*
FORM SPLIT_PATH USING FILEPATH
                CHANGING DRIVE
                         EXTENSION
                         NAME
                         NAME_WITH_EXT
                         PATH.


  DATA: SEPERATOR TYPE C,
   PATH_PARTS TYPE TABLE OF STRING,
  FILE TYPE STRING,
  FILEPARTS TYPE TABLE OF STRING,
  I TYPE I,
  TEMP TYPE STRING.

  CL_GUI_FRONTEND_SERVICES=>GET_FILE_SEPARATOR(
    CHANGING FILE_SEPARATOR = SEPERATOR ).

  DRIVE = FILEPATH(1).
  SPLIT FILEPATH AT SEPERATOR INTO TABLE PATH_PARTS.
  I = LINES( PATH_PARTS ).
  READ TABLE PATH_PARTS INTO NAME_WITH_EXT INDEX I.
  DELETE FILEPARTS INDEX I.

  SPLIT NAME_WITH_EXT AT '.' INTO TABLE FILEPARTS.
  I = LINES( FILEPARTS ).
  READ TABLE FILEPARTS INTO EXTENSION INDEX I.
  DELETE FILEPARTS INDEX I.

  LOOP AT PATH_PARTS INTO TEMP.
    CONCATENATE PATH TEMP INTO PATH SEPARATED BY SEPERATOR.
  ENDLOOP.
  PATH = PATH+1.
  CLEAR TEMP.
  LOOP AT FILEPARTS INTO TEMP.
    CONCATENATE NAME TEMP INTO NAME SEPARATED BY SEPERATOR.
  ENDLOOP.

  NAME = NAME+1.

ENDFORM.                    "SPLIT_PATH

*&---------------------------------------------------------------------*
*&      Form  get_extension
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->FILEPATH   text
*      -->EXTENSION  text
*----------------------------------------------------------------------*
FORM GET_EXTENSION USING FILEPATH
                         EXTENSION.

  DATA: DRIVE TYPE STRING,
        NAME TYPE STRING,
        NAME_WITH_EXT TYPE STRING,
        PATH TYPE STRING.

  PERFORM SPLIT_PATH USING FILEPATH
                CHANGING DRIVE
                         EXTENSION
                         NAME
                         NAME_WITH_EXT
                         PATH.

ENDFORM.                    "get_extension

*&---------------------------------------------------------------------*
*&      Form  add_used_memory_to_log
*&---------------------------------------------------------------------*
FORM ADD_USED_MEMORY_TO_LOG.

  DATA: MEM_SIZE     TYPE ABAP_MSIZE,
        MEM(25)      TYPE C,
        MEM_TEXT(50) TYPE C.

*    IF sy-batch = 'X'.
*   Used memory log message
  CALL METHOD CL_ABAP_MEMORY_UTILITIES=>GET_TOTAL_USED_SIZE
    IMPORTING
      SIZE = MEM_SIZE.
  MEM = MEM_SIZE.
  CONCATENATE 'Used memory:' MEM                            "#EC NOTEXT
  INTO MEM_TEXT SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING MEM_TEXT ABAP_TRUE.
*    ENDIF.

ENDFORM.                 " add_used_memory_to_log

*&---------------------------------------------------------------------*
*&      Form  ADD_NOTIFICATION
*&---------------------------------------------------------------------*
*       This form handles addition of record to GT_ETL_NOTIFICATIONS
*       ( notifications created during ETL run )
*----------------------------------------------------------------------*
FORM ADD_NOTIFICATION USING P_CODE
                            P_PARAMETERS
                            P_MESSAGE.

  DATA: LS_NOTIFICATION TYPE TY_ETL_NOTIFICATION.

  LS_NOTIFICATION-CODE       = P_CODE.
  LS_NOTIFICATION-PARAMETERS = P_PARAMETERS.
  CONDENSE LS_NOTIFICATION-PARAMETERS NO-GAPS.
  LS_NOTIFICATION-MESSAGE    = P_MESSAGE.

  APPEND LS_NOTIFICATION TO GT_ETL_NOTIFICATIONS.

ENDFORM.                    "ADD_NOTIFICATION

*&---------------------------------------------------------------------*
*&      Form  GET_USAGE_BY_MONTHS_BACK
*&---------------------------------------------------------------------*
FORM GET_USAGE_BY_MONTHS_BACK USING KEY1
                                    KEY2
                                    KEY3
                                    KEY4
                                    USAGE_TYPE
                           CHANGING CALLERS TYPE TT_USAGE_CALLER.

  DATA: LV_BEGDA TYPE DATUM,
        LV_ENDDA TYPE DATUM.

  DATA: LV_MONTHS_BACK TYPE I.

* Set first end date and begin date to be
* from today to beginning of the month
  LV_ENDDA = SY-DATUM.
  LV_BEGDA = LV_ENDDA.
  LV_BEGDA+6(2) = '01'.

* Calculate months back according to the day of the month
  IF LV_ENDDA+6(2) GT '15'.
    LV_MONTHS_BACK = MONTHS_BACK_USAGE.
  ELSE.
    LV_MONTHS_BACK = MONTHS_BACK_USAGE + 1.
  ENDIF.

  DO LV_MONTHS_BACK TIMES.

    CASE USAGE_TYPE.
      WHEN 'PROXIES'.
        PERFORM GET_PROXY_USAGE_BY_DATES USING KEY1
                                               KEY2
                                               LV_BEGDA
                                               LV_ENDDA
                                      CHANGING CALLERS.
      WHEN 'IDOCS'.
        PERFORM GET_IDOCS_USAGE_BY_DATES USING KEY1
                                               KEY2
                                               KEY3
                                               KEY4
                                               LV_BEGDA
                                               LV_ENDDA
                                      CHANGING CALLERS.
    ENDCASE.

*   If there is data for current month, return it.
*   If not, check for next month back
    IF NOT CALLERS[] IS INITIAL.
      EXIT.
    ELSE.
*     Calculate previous month
      LV_ENDDA = LV_BEGDA - 1.
      LV_BEGDA = LV_ENDDA.
      LV_BEGDA+6(2) = '01'.
    ENDIF.
  ENDDO.

ENDFORM.                    "GET_USAGE_BY_MONTHS_BACK

*&---------------------------------------------------------------------*
*&      Form  GET_PROXY_USAGE_BY_DATES
*&---------------------------------------------------------------------*
FORM GET_PROXY_USAGE_BY_DATES USING NAMESPACE
                                    INTERFACE
                                    START_DATE TYPE DATUM
                                    END_DATE TYPE DATUM
                           CHANGING CALLERS TYPE TT_USAGE_CALLER.

  DATA: LV_TIMEZONE TYPE TIMEZONE.

  DATA: LS_FILTER       TYPE SXI_MESSAGE_FILTER,
        LT_MESSAGE_LIST TYPE SXI_MESSAGE_DATA_LIST,
        LV_SUBRC        TYPE STRING,
        LV_LINES        TYPE I.

  DATA: LS_CALLER TYPE TY_USAGE_CALLER.

  DATA: LV_LOG_MESSAGE TYPE STRING.

  FIELD-SYMBOLS: <CALLER> LIKE LINE OF CALLERS.

* Set dates for filter
  CONVERT DATE START_DATE TIME '000000'
    INTO TIME STAMP LS_FILTER-FROM_TIME TIME ZONE LV_TIMEZONE.
  CONVERT DATE END_DATE TIME '235959'
    INTO TIME STAMP LS_FILTER-TO_TIME TIME ZONE LV_TIMEZONE.

* Set Namespace and Interface
  LS_FILTER-IB_NS = NAMESPACE.
  LS_FILTER-IB_NAME = INTERFACE.

  CONCATENATE 'PROXY USAGE - NAMESPACE:' NAMESPACE
              'INTERFACE:' INTERFACE
              'PERIOD:' START_DATE
              'START TIME:' SY-UZEIT
   INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

* If extraction is from prod, get the usage by direct SELECT
* with grouping by callers
  IF RFC_SYSID = SY-SYSID AND NOT EXTRACT_PROXY_CALLERS IS INITIAL.
    CONCATENATE LV_LOG_MESSAGE '- BY SELECT'
      INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

    SELECT EMAS~OB_SYSTEM AS CALLER
           COUNT( DISTINCT EMAS~MSGGUID ) AS COUNT
      FROM SXMSPMAST AS MAST
      JOIN SXMSPEMAS AS EMAS ON EMAS~MSGGUID = MAST~MSGGUID
                            AND EMAS~PID = MAST~PID
      INTO CORRESPONDING FIELDS OF TABLE CALLERS
     WHERE MAST~EXETIMEST GE LS_FILTER-FROM_TIME
       AND MAST~EXETIMEST LE LS_FILTER-TO_TIME
       AND EMAS~IB_NAME = LS_FILTER-IB_NAME
       AND EMAS~IB_NS = LS_FILTER-IB_NS
     GROUP BY EMAS~OB_SYSTEM.

    IF SY-SUBRC = 0.
      LOOP AT CALLERS ASSIGNING <CALLER>.
        <CALLER>-LAST_USED = END_DATE.
      ENDLOOP.
    ENDIF.
  ELSE.
    CONCATENATE LV_LOG_MESSAGE '- BY RFC'
      INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

*   If usage is selected via RFC, limit to max 50 messages
*   In this case, there will be no specific caller but only
*   number of messages
    CALL FUNCTION 'SXMB_GET_MESSAGE_LIST' DESTINATION P_RFCDES
      EXPORTING
        IM_FILTER            = LS_FILTER
        IM_MESSAGE_COUNT     = 50
      IMPORTING
        EX_MESSAGE_DATA_LIST = LT_MESSAGE_LIST
*       EX_RESULT            =
*       EX_FIRST_TS          =
      EXCEPTIONS
        NOT_AUTHORIZED       = 1
        INTERNAL_ERROR       = 2
        TOO_MANY_MESSAGES    = 3
        NO_MESSAGE           = 4
        OTHERS               = 5.

    IF SY-SUBRC EQ 0.
      DESCRIBE TABLE LT_MESSAGE_LIST LINES LV_LINES.
      IF LV_LINES > 0.
        LS_CALLER-COUNT = LV_LINES.
        LS_CALLER-LAST_USED = END_DATE.
        APPEND LS_CALLER TO CALLERS.
      ENDIF.
    ELSE.
      LV_SUBRC = SY-SUBRC.
      CONCATENATE 'PROXY USAGE - NAMESPACE:' NAMESPACE 'INTERFACE:'
                  INTERFACE 'DATE:' START_DATE 'SUBRC:' LV_SUBRC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
  ENDIF.

  PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_FALSE.

ENDFORM.                    " GET_PROXY_USAGE_BY_DATES

*&---------------------------------------------------------------------*
*&      Form  GET_IDOCS_USAGE_BY_DATES
*&---------------------------------------------------------------------*
FORM GET_IDOCS_USAGE_BY_DATES
                        USING DIRECTION
                              MESSAGE_TYPE
                              PARTNER
                              PARTNER_TYPE
                              START_DATE TYPE DATUM
                              END_DATE TYPE DATUM
                     CHANGING IDOC_PARTNER_USAGE TYPE TT_USAGE_CALLER.

  DATA:
    TAB_DATA              TYPE TABLE OF TAB512,
    SEL                   TYPE TABLE OF RFC_DB_OPT,
    SEL_WA                LIKE LINE OF SEL,
    FIELDS_TAB            TYPE TABLE OF RFC_DB_FLD,
    FIELDS_WA             LIKE LINE OF FIELDS_TAB,
    LS_IDOC_PARTNER_USAGE TYPE TY_USAGE_CALLER,
    LV_SUBRC              TYPE STRING,
    LV_LINES              TYPE I,
    LV_IDOCTY             TYPE EDIPIDOCTP.

  CONCATENATE 'Idoc Usage m:' MESSAGE_TYPE                  "#EC NOTEXT
   ' p:' PARTNER                                            "#EC NOTEXT
      ' d:' END_DATE INTO GT_ETL_MESSAGE-MESSAGE.           "#EC NOTEXT
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

  FIELDS_WA-FIELDNAME = 'IDOCTP'.
  APPEND FIELDS_WA TO FIELDS_TAB.

  REFRESH TAB_DATA.
  REFRESH SEL.
  CONCATENATE ' DIRECT = ''' DIRECTION '''' INTO SEL_WA-TEXT.
  APPEND SEL_WA TO SEL.
  CONCATENATE ' AND MESTYP = ''' MESSAGE_TYPE '''' INTO SEL_WA-TEXT.
  APPEND SEL_WA TO SEL.
  CONCATENATE ' AND CREDAT >= ''' START_DATE '''' INTO SEL_WA-TEXT.
  APPEND SEL_WA TO SEL.
  CONCATENATE ' AND CREDAT <= ''' END_DATE '''' INTO SEL_WA-TEXT.
  APPEND SEL_WA TO SEL.

* Partner will be initial when there are lots of IDoc Partner pair,
* and we get aggrigated data per IDoc message.
  IF NOT PARTNER IS INITIAL.
    IF ( DIRECTION = '1' ). " Outbound
      CONCATENATE ' AND RCVPRN = ''' PARTNER '''' INTO SEL_WA-TEXT.
      APPEND SEL_WA TO SEL.
      CONCATENATE ' AND RCVPRT = ''' PARTNER_TYPE '''' INTO SEL_WA-TEXT.
      APPEND SEL_WA TO SEL.
    ELSE. " Inbound
      CONCATENATE ' AND SNDPRN = ''' PARTNER '''' INTO SEL_WA-TEXT.
      APPEND SEL_WA TO SEL.
      CONCATENATE ' AND SNDPRT = ''' PARTNER_TYPE '''' INTO SEL_WA-TEXT.
      APPEND SEL_WA TO SEL.
    ENDIF.
  ENDIF.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'EDIDC'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR LV_SUBRC.
    CASE SY-SUBRC.
      WHEN 1. LV_SUBRC = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. LV_SUBRC = 'TABLE_WITHOUT_DATA'.
      WHEN 3. LV_SUBRC = 'OPTION_NOT_VALID'.
      WHEN 4. LV_SUBRC = 'FIELD_NOT_VALID'.
      WHEN 5. LV_SUBRC = 'NOT_AUTHORIZED'.
      WHEN 6. LV_SUBRC = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. LV_SUBRC = 'OTHERS'.
    ENDCASE.

    CONCATENATE
'Extract idocs usage: RFC_READ_TABLE, Error:'               "#EC NOTEXT
          LV_SUBRC 'Idoc:' MESSAGE_TYPE                     "#EC NOTEXT
          'Partner:' PARTNER                                "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ELSE.
*   Check how many messages returned
    DESCRIBE TABLE TAB_DATA LINES LV_LINES.
    IF LV_LINES > 0.
*     Get the iDoc type
*     (in an Inbound we don't have it in the profile metadata)
      READ TABLE TAB_DATA INDEX 1 INTO LV_IDOCTY.
      LS_IDOC_PARTNER_USAGE-CALLER = LV_IDOCTY.
      LS_IDOC_PARTNER_USAGE-COUNT = LV_LINES.
      LS_IDOC_PARTNER_USAGE-LAST_USED = END_DATE.
      APPEND LS_IDOC_PARTNER_USAGE TO IDOC_PARTNER_USAGE.
    ENDIF.
  ENDIF.

ENDFORM.                    "GET_IDOCS_USAGE_BY_DATES
*---------------------------------------------------------------------*
*       FORM ADD_TIME_STAT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_STEP                                                        *
*  -->  P_STARTTIME                                                   *
*---------------------------------------------------------------------*
FORM ADD_TIME_STAT USING P_STEP P_STARTTIME P_STARTDATE.
*----------------------------------------------------------------------*
* Begin change 13 made on 01/05/2013                                   *
*----------------------------------------------------------------------*
  DATA: SUBRC TYPE I,
        TABIX TYPE I.
* Check if there is already an entry in the time stat
  READ TABLE GT_ETL_TIME_STAT WITH KEY STEP = P_STEP.
  SUBRC = SY-SUBRC.
  TABIX = SY-TABIX.

  GET TIME.
  GT_ETL_TIME_STAT-ENDTIME = SY-UZEIT.

* if the process ended exactly at midnight - add 1 sec to
* prevent it from staying initial
  IF GT_ETL_TIME_STAT-ENDTIME IS INITIAL.
    GT_ETL_TIME_STAT-ENDTIME = '000001'.
  ENDIF.

  GT_ETL_TIME_STAT-ENDDATE = SY-DATUM.

  IF SUBRC IS INITIAL.
    MODIFY GT_ETL_TIME_STAT INDEX TABIX.
  ELSE.
    GT_ETL_TIME_STAT-STEP = P_STEP.

    IF P_STARTDATE IS INITIAL.
      GT_ETL_TIME_STAT-STARTDATE = SY-DATUM.
    ELSE.
      GT_ETL_TIME_STAT-STARTDATE = P_STARTDATE.
    ENDIF.

    IF P_STARTTIME IS INITIAL.
      GT_ETL_TIME_STAT-STARTTIME = SY-UZEIT.
    ELSE.
      GT_ETL_TIME_STAT-STARTTIME = P_STARTTIME.
    ENDIF.

*   if the process started exactly at midnight - add 1 sec to
*   prevent it from staying initial
    IF GT_ETL_TIME_STAT-STARTTIME IS INITIAL.
      GT_ETL_TIME_STAT-STARTTIME = '000001'.
    ENDIF.

    APPEND GT_ETL_TIME_STAT.
  ENDIF.
*----------------------------------------------------------------------*
* End change 13 made on 01/05/2013                                     *
*----------------------------------------------------------------------*
ENDFORM.                    "ADD_TIME_STAT
*&---------------------------------------------------------------------*
*&      Form  REPLACE_ALL_OCCURRENCES
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM REPLACE_ALL_OCCURRENCES
  USING
    IV_STRING       TYPE STRING
    IV_CHAR         TYPE STRING
    IV_REPLACE_WITH TYPE STRING
  CHANGING
    CV_STRING  TYPE STRING.

  CV_STRING = IV_STRING.

  REPLACE ALL OCCURRENCES OF IV_CHAR
  IN CV_STRING WITH IV_REPLACE_WITH.

ENDFORM.                    "REPLACE_ALL_OCCURRENCES

*&---------------------------------------------------------------------*
*&      Form  rfc_read_table
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_9673   text
*      -->P_P_BW_RFC  text
*      -->P_LT_OPTIONS  text
*      -->P_LT_FIELDS  text
*      <--P_LT_RSOLTPSOURCE  text
*----------------------------------------------------------------------*
FORM RFC_READ_TABLE  USING    IV_TABLE_NAME TYPE  DD02L-TABNAME
                              IV_DEST       TYPE  RFCDEST
                              IT_OPTIONS    TYPE  TT_OPTIONS
                              IT_FIELDS     TYPE  TT_FIELDS
                     CHANGING CT_DATA       TYPE  ANY TABLE.

  DATA: LT_TAB TYPE TABLE OF TAB512.
  DATA: LT_FIELDS   TYPE  TT_FIELDS.

  DATA: LV_MSG(150)  TYPE C,
        LV_RFC_ERROR TYPE RFCLOG_D,
        LV_STEP(512) TYPE C.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.
  DATA: LS_DATA TYPE REF TO DATA.
  FIELD-SYMBOLS: <FS_DATA>    TYPE ANY,
                 <FS_TAB512>  TYPE TAB512,
                 <FS_FIELD>   TYPE RFC_DB_FLD.
  FIELD-SYMBOLS: <FS_OUTPUT>  TYPE ANY.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.
  LT_FIELDS[] = IT_FIELDS[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_DEST
    EXPORTING
      QUERY_TABLE           = IV_TABLE_NAME
*     delimiter             = space
*     no_data               = space
*     rowskips              = 0
    TABLES
      OPTIONS               = IT_OPTIONS
      FIELDS                = LT_FIELDS
      DATA                  = LT_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7 MESSAGE LV_RFC_ERROR
      COMMUNICATION_FAILURE = 8 MESSAGE LV_RFC_ERROR
      OTHERS                = 9.

  CASE SY-SUBRC.
    WHEN 1.
      CONCATENATE 'Table:' IV_TABLE_NAME                    "#EC NOTEXT
       'Not Available'                                      "#EC NOTEXT
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 2.
      CONCATENATE 'Table:' IV_TABLE_NAME                    "#EC NOTEXT
      'Without Data'                                        "#EC NOTEXT
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 3.
      CONCATENATE 'Option Not Valid For Table: '            "#EC NOTEXT
      IV_TABLE_NAME
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 4.
      CONCATENATE 'Field Not Valid: ' IV_TABLE_NAME         "#EC NOTEXT
                   INTO LV_MSG SEPARATED BY SPACE.
    WHEN 5.
      CONCATENATE 'No authorizations reading from table: '  "#EC NOTEXT
            IV_TABLE_NAME
            INTO LV_MSG SEPARATED BY SPACE.
    WHEN 6.
      CONCATENATE 'Data Buffer Exceeded. Table: '           "#EC NOTEXT
      IV_TABLE_NAME
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 7 OR 8.
      LV_MSG = LV_RFC_ERROR(50).
  ENDCASE.

* Save table data
  CREATE DATA LS_DATA LIKE LINE OF CT_DATA.
  ASSIGN LS_DATA->* TO <FS_OUTPUT>.
  LOOP AT LT_TAB ASSIGNING <FS_TAB512>.
    CLEAR <FS_OUTPUT>.
    LOOP AT LT_FIELDS ASSIGNING <FS_FIELD>.
      ASSIGN COMPONENT <FS_FIELD>-FIELDNAME
        OF STRUCTURE <FS_OUTPUT> TO <FS_DATA>.
      <FS_DATA> = <FS_TAB512>-WA+<FS_FIELD>-OFFSET(<FS_FIELD>-LENGTH).
    ENDLOOP.
    INSERT <FS_OUTPUT> INTO TABLE CT_DATA.
  ENDLOOP.

* Update Status
  CONCATENATE 'Extract' IV_TABLE_NAME                       "#EC NOTEXT
   INTO LV_STEP SEPARATED BY SPACE.
  PERFORM ADD_TIME_STAT USING LV_STEP
      L_STARTTIME L_STARTDATE.

  IF NOT LV_MSG IS INITIAL.
    CONCATENATE 'Extraction failed. Error:'                 "#EC NOTEXT
     LV_MSG
           INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.
ENDFORM.                    " rfc_read_table

*&---------------------------------------------------------------------*
*&      Form  rfc_read_table_with_row_count
*&---------------------------------------------------------------------*
*       Read table from an rfc destination with option for lines limit
*----------------------------------------------------------------------*
*      -->IV_TABLE_NAME - table name
*      -->IV_DEST  - RFC Destination name
*      -->IT_OPTIONS  - select options for the query
*      -->IT_FIELDS - field to retreive from the query
*      -->ROW_COUNT - Number of lines to read (send 0 to read all)
*      <--P_LT_RSOLTPSOURCE  text
*----------------------------------------------------------------------*

FORM RFC_READ_TABLE_WITH_ROWCOUNT
                          USING IV_TABLE_NAME TYPE DD02L-TABNAME
                                IV_DEST       TYPE RFCDEST
                                IT_OPTIONS    TYPE TT_OPTIONS
                                IT_FIELDS     TYPE TT_FIELDS
                                ROW_COUNT     TYPE SOID-ACCNT
                          CHANGING CT_DATA    TYPE  ANY TABLE.

  DATA: LT_TAB TYPE TABLE OF TAB512.

  DATA: LV_MSG(150)  TYPE C,
        LV_RFC_ERROR TYPE RFCLOG_D,
        LV_STARTTIME TYPE SYUZEIT,
        LV_STEP(512) TYPE C.

  DATA: SY_SUBC TYPE I.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_DEST
    EXPORTING
      QUERY_TABLE           = IV_TABLE_NAME
*     delimiter             = space
*     no_data               = space
*     rowskips              = 0
      ROWCOUNT              = ROW_COUNT
    TABLES
      OPTIONS               = IT_OPTIONS
      FIELDS                = IT_FIELDS
      DATA                  = LT_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7 MESSAGE LV_RFC_ERROR
      COMMUNICATION_FAILURE = 8 MESSAGE LV_RFC_ERROR
      OTHERS                = 9.

  SY_SUBC = SY-SUBRC.

  CT_DATA[] = LT_TAB[].

* Update Status
  CONCATENATE 'Extract' IV_TABLE_NAME                       "#EC NOTEXT
  INTO LV_STEP SEPARATED BY SPACE.
  PERFORM ADD_TIME_STAT USING LV_STEP
      L_STARTTIME L_STARTDATE.

  CASE SY_SUBC.
    WHEN 1.
      CONCATENATE 'Table:' IV_TABLE_NAME                    "#EC NOTEXT
      'Not Available'                                       "#EC NOTEXT
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 2.
      CONCATENATE 'Table:' IV_TABLE_NAME                    "#EC NOTEXT
      'Without Data'                                        "#EC NOTEXT
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 3.
      CONCATENATE 'Option Not Valid For Table: '            "#EC NOTEXT
      IV_TABLE_NAME
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 4.
      CONCATENATE 'Field Not Valid: ' IV_TABLE_NAME         "#EC NOTEXT
                   INTO LV_MSG SEPARATED BY SPACE.
    WHEN 5.
      CONCATENATE 'No authorizations reading from table: '  "#EC NOTEXT
            IV_TABLE_NAME
            INTO LV_MSG SEPARATED BY SPACE.
    WHEN 6.
      CONCATENATE 'Data Buffer Exceeded. Table: '           "#EC NOTEXT
      IV_TABLE_NAME
                  INTO LV_MSG SEPARATED BY SPACE.
    WHEN 7 OR 8.
      LV_MSG = LV_RFC_ERROR(50).
  ENDCASE.

  IF NOT LV_MSG IS INITIAL.
    CONCATENATE 'Extraction failed. Error:'                 "#EC NOTEXT
    LV_MSG INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.
ENDFORM.                    " rfc_read_table_with_rowcount
*&---------------------------------------------------------------------*
*&      Form  get_rfc_structure
*&---------------------------------------------------------------------*
FORM GET_RFC_STRUCTURE TABLES O_FIELDS STRUCTURE RFC_FIELDS
                         USING  I_TABLE_NAME
                                IV_DEST.

  DATA: FIELD_WA LIKE LINE OF O_FIELDS,
        SUBRC    TYPE C.

  CALL FUNCTION 'RFC_GET_STRUCTURE_DEFINITION' DESTINATION IV_DEST
    EXPORTING
      TABNAME          = I_TABLE_NAME
    TABLES
      FIELDS           = O_FIELDS
    EXCEPTIONS
      TABLE_NOT_ACTIVE = 1
      OTHERS           = 2.

  IF SY-SUBRC <> 0.
    SUBRC = SY-SUBRC.
    CONCATENATE 'SOLAR:8.1 Warning:failed getting '         "#EC NOTEXT
                'rfc structure'                             "#EC NOTEXT
                    I_TABLE_NAME
                    'exited with subrc' SUBRC               "#EC NOTEXT
                  INTO GT_ETL_MESSAGE-MESSAGE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.
ENDFORM.                                      "get_rfc_structure

*&---------------------------------------------------------------------*
*&      Form  check_bw_rfc_dest
*&---------------------------------------------------------------------*
FORM CHECK_BW_RFC_DEST USING    IV_RFC_DEST TYPE RFCDEST
                                IV_VALIDATE TYPE FLAG
                       CHANGING EV_VALID    TYPE FLAG.

  DATA : LV_ERR_MSG TYPE STRING,
         BW_SYSID   TYPE SYSYSID,
         BW_SAPRL   TYPE SYSAPRL.

* BW RFC entered
  CHECK NOT IV_RFC_DEST IS INITIAL.

  PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
                                        IV_VALIDATE
                                  CHANGING EV_VALID
                                           BW_SYSID
                                           BW_SAPRL.

* Tables Accessibility Check
* RFC is valid - ev_valid = true
  IF NOT EV_VALID IS INITIAL.
    PERFORM CHECK_BW_TABLES_ACCESSIBILITY.
*   BW connection and BW tables checked
*   check BW data sources use the PRD RFC system as
*   source system - otherwise no DataSource will be
*   extracted and no BW impact found
    PERFORM CHECK_BW_DATA_SOURCES.
  ENDIF.
ENDFORM.                    " check_bw_rfc_dest

*---------------------------------------------------------------------*
*       FORM check_bw_data_sources                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CHECK_BW_DATA_SOURCES.

  DATA: LV_C_PRODSYS TYPE CHAR12,
        LT_OPTIONS   TYPE TABLE OF RFC_DB_OPT,
        LT_FIELDS    TYPE TABLE OF RFC_DB_FLD,
        LS_OPTIONS   TYPE RFC_DB_OPT,
        LS_FIELDS    TYPE RFC_DB_FLD.
  DATA: LT_TAB          TYPE TABLE OF TAB512.
  DATA: LT_RSOLTPSOURCE TYPE TABLE OF TY_RSOLTPSOURCE,
        LT_RSDS         TYPE TABLE OF TY_RSDS.
  DATA: LV_MESSAGE      TYPE STRING.

* The data sources are correlated with prod sys
  CHECK NOT GV_LOGSYS IS INITIAL AND
        NOT P_BW_RFC IS INITIAL.

* Set prodsys in char for rfc options
  CONCATENATE '''' GV_LOGSYS '''' INTO LV_C_PRODSYS.

* Check 3X DS available in BW sys with PROD RFC source
* Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
  INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_BW_RFC
    EXPORTING
      QUERY_TABLE          = 'RSOLTPSOURCE'
      ROWCOUNT             = 1
    TABLES
      OPTIONS              = LT_OPTIONS
      FIELDS               = LT_FIELDS
      DATA                 = LT_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
  ENDIF.
  LT_RSOLTPSOURCE[] = LT_TAB[].

  CLEAR: LT_TAB[], LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.

* Check 7X DS available in BW sys with PROD RFC source
* Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'DATASOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
  INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_BW_RFC
    EXPORTING
      QUERY_TABLE          = 'RSDS'
      ROWCOUNT             = 1
    TABLES
      OPTIONS              = LT_OPTIONS
      FIELDS               = LT_FIELDS
      DATA                 = LT_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
  ENDIF.
  LT_RSDS[] = LT_TAB[].

* No DataSources available in BW system with the PRD source system
  IF LT_RSDS[] IS INITIAL AND
     LT_RSOLTPSOURCE[] IS INITIAL.

    IF NOT R_FORE IS INITIAL.
      MESSAGE W001(00) WITH
      'No BW DataSources available with source system :'    "#EC NOTEXT
      GV_LOGSYS
      ' with RFC to BW system :'                            "#EC NOTEXT
      P_BW_RFC.
    ELSE.
*     Add to ETL messages
      CONCATENATE
      'No BW DataSources available with source system:'     "#EC NOTEXT
       GV_LOGSYS
      'with RFC to BW system:'                              "#EC NOTEXT
      P_BW_RFC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
  ENDIF.

ENDFORM.                    "CHECK_BW_DATA_SOURCES

*&---------------------------------------------------------------------*
*&      Form  check_bw_tables_accessibility
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_BW_TABLES_ACCESSIBILITY .

  CHECK NOT P_BW_RFC IS INITIAL.

  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCPROCESSLOG' P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSLDPIO'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSISOSMAP'     P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSTRAN'        P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSUPDINFO'     P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSOLTPSOURCE'  P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDS'          P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDCUBE'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDCUBET'      P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDIOBJ'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDIOBJT'      P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDODSO'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDODSOT'      P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAINATTR' P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAIN'     P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAINT'    P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSBKDTP'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSBKDTPT'      P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TADIR'         P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDAREA'       P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDAREAT'      P_BW_RFC.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TDEVC'         P_BW_RFC.

ENDFORM.                    " check_bw_tables_accessibility
*---------------------------------------------------------------------*
*       FORM test_rfc_table_accessibility
*
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_TABNAME                                                     *
*---------------------------------------------------------------------*
FORM TEST_RFC_TABLE_ACCESSIBILITY USING IV_TABNAME TYPE TABNAME
                                        IV_RFCDEST TYPE RFCDES-RFCDEST.

  DATA: LT_TAB     TYPE TABLE OF TAB512,
        LT_OPTIONS TYPE TABLE OF RFC_DB_OPT,
        LT_FIELDS  TYPE TABLE OF RFC_DB_FLD.

  DATA: LV_MSG       TYPE STRING,
        LV_RFC_ERROR TYPE RFCLOG_D,
        LV_ERR_MSG   TYPE STRING.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_RFCDEST
    EXPORTING
      QUERY_TABLE           = IV_TABNAME
      DELIMITER             = SPACE
      NO_DATA               = 'X'  "space
      ROWSKIPS              = 0
      ROWCOUNT              = 1
    TABLES
      OPTIONS               = LT_OPTIONS
      FIELDS                = LT_FIELDS
      DATA                  = LT_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7 MESSAGE LV_RFC_ERROR
      COMMUNICATION_FAILURE = 8 MESSAGE LV_RFC_ERROR
      OTHERS                = 9.

  CASE SY-SUBRC.

    WHEN 1.
      CONCATENATE 'Table:' IV_TABNAME 'Not Available'       "#EC NOTEXT
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 2.
      CONCATENATE 'Table:' IV_TABNAME 'Without Data'        "#EC NOTEXT
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 3.
      CONCATENATE 'Option Not Valid For Table: ' IV_TABNAME "#EC NOTEXT
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 4.
      CONCATENATE 'Field Not Valid For Table: ' IV_TABNAME  "#EC NOTEXT
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 5.
      CONCATENATE 'No authorizations reading from table: '  "#EC NOTEXT
      IV_TABNAME
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 6.
      CONCATENATE 'Data Buffer Exceeded. Table: '           "#EC NOTEXT
      IV_TABNAME
                        INTO LV_MSG SEPARATED BY SPACE.
    WHEN 7 OR 8.
      LV_MSG = LV_RFC_ERROR(50).
  ENDCASE.

  IF NOT LV_MSG IS INITIAL.
    IF NOT R_FORE IS INITIAL.
      PERFORM RAISE_ERROR USING LV_MSG.
    ELSE.
      APPEND LV_MSG TO GT_ETL_MESSAGE.
    ENDIF.
  ENDIF.
ENDFORM.                    "test_rfc_table_accessibility
*&---------------------------------------------------------------------*
*&      Form  validate_rfc_connection
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IV_RFC_DEST  text
*      -->P_IV_VALIDATE  text
*      <--P_EV_VALID  text
*----------------------------------------------------------------------*
FORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST TYPE RFCDEST
                                   IV_VALIDATE TYPE FLAG
                             CHANGING EV_VALID TYPE FLAG
                                      EV_SYSID TYPE SYSYSID
                                      EV_SAPRL TYPE SYSAPRL.

  DATA : LS_RFCDES     TYPE RFCDES,
         LS_RFCDISPLAY TYPE RFCDISPLAY,
         LV_ERR_MSG    TYPE STRING,
         RFC_ERROR     TYPE RFCLOG_D,
         LV_FAILED     TYPE FLAG,
         LS_RFCSI      TYPE RFCSI,
         SUBRC_STR     TYPE STRING.

  EV_VALID = ABAP_TRUE.

* Get RFC basic data
  SELECT SINGLE *
  FROM RFCDES
  INTO LS_RFCDES
  WHERE
  RFCDEST = IV_RFC_DEST.

  IF SY-SUBRC IS INITIAL.
*   Get RFC connections data
    CALL FUNCTION 'RFCDES2RFCDISPLAY'
      EXPORTING
        IMPORT_RFCDES           = LS_RFCDES
        AUTHORITY_CHECK         = ABAP_TRUE
      IMPORTING
        EXPORT_RFCDISPLAY       = LS_RFCDISPLAY
      EXCEPTIONS
        FORMAT_ERROR            = 1
        AUTHORITY_NOT_AVAILABLE = 2
        OTHERS                  = 3.

    IF SY-SUBRC IS INITIAL.
*     Check the RFC connection - auth and validity
      CALL FUNCTION 'RFC_READ_R3_DESTINATION'
        EXPORTING
          DESTINATION             = IV_RFC_DEST
          AUTHORITY_CHECK         = ABAP_TRUE
*         BYPASS_BUF              = 'X'
        EXCEPTIONS
          AUTHORITY_NOT_AVAILABLE = 1
          DESTINATION_NOT_EXIST   = 2
          INFORMATION_FAILURE     = 3
          INTERNAL_FAILURE        = 4
          OTHERS                  = 5.

      IF SY-SUBRC IS INITIAL.
        CALL FUNCTION 'RFC_SYSTEM_INFO'
          DESTINATION IV_RFC_DEST
          IMPORTING
            RFCSI_EXPORT          = LS_RFCSI
          EXCEPTIONS
            SYSTEM_FAILURE        = 1 MESSAGE RFC_ERROR
            COMMUNICATION_FAILURE = 2 MESSAGE RFC_ERROR.

        IF SY-SUBRC <> 0.
          IF IV_VALIDATE IS INITIAL.
            CONCATENATE
            'Could not connect to RFC destination'          "#EC NOTEXT
                        IV_RFC_DEST
                        RFC_ERROR
                        INTO LV_ERR_MSG
                  SEPARATED BY SPACE.
            PERFORM RAISE_ERROR USING LV_ERR_MSG.
            LEAVE TO SCREEN SY-DYNNR.
          ELSE.
            EV_VALID = ABAP_FALSE.
          ENDIF.
        ELSE.       "SUBRC = 0 for func RFC_SYSTEM_INFO
          EV_SYSID = LS_RFCSI-RFCSYSID.
          EV_SAPRL = LS_RFCSI-RFCSAPRL.
        ENDIF.       "SUBRC for func RFC_SYSTEM_INFO

*       To get a logon screen at the next 'normal' RFC call
*       it is required to close the connection opend by RFC_SYSTEM_INFO
        CALL FUNCTION 'RFC_CONNECTION_CLOSE'
          EXPORTING
            DESTINATION = IV_RFC_DEST
          EXCEPTIONS
            OTHERS      = 1.
      ELSE.                "SUBRC <> 0 for func RFC_READ_R3_DESTINATION
        SUBRC_STR = SY-SUBRC.
        IF IV_VALIDATE IS INITIAL.
          CONCATENATE 'Could not connect to RFC destination '
               IV_RFC_DEST
               'Subrc: ' SUBRC_STR
               RFC_ERROR
               INTO LV_ERR_MSG
         SEPARATED BY SPACE.                                "#EC NOTEXT
          PERFORM RAISE_ERROR USING LV_ERR_MSG.
          LEAVE TO SCREEN SY-DYNNR.
        ELSE.
          EV_VALID = ABAP_FALSE.
        ENDIF.
      ENDIF.           "SUBRC for func RFC_READ_R3_DESTINATION
    ELSE.            "SUBRC <> 0 for func RFCDES2RFCDISPLAY
      SUBRC_STR = SY-SUBRC.
      IF IV_VALIDATE IS INITIAL.
        "LEON
        CONCATENATE 'RFC destination' IV_RFC_DEST
        'does not exist or is not R/3 connection. Subrc: '  "#EC NOTEXT
        SUBRC_STR
        INTO LV_ERR_MSG
        SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_ERR_MSG.
        LEAVE TO SCREEN SY-DYNNR.
      ELSE.
        EV_VALID = ABAP_FALSE.
      ENDIF.
    ENDIF.           " SUBRC for func RFCDES2RFCDISPLAY
  ELSE. "SUBRC <> 0 for query from RFCDES
    SUBRC_STR = SY-SUBRC.
    IF IV_VALIDATE IS INITIAL.
      CONCATENATE 'RFC destination' IV_RFC_DEST
      'does not exist or is not R/3 connection. Subrc: '    "#EC NOTEXT
      SUBRC_STR
      INTO LV_ERR_MSG
      SEPARATED BY SPACE.
      PERFORM RAISE_ERROR USING LV_ERR_MSG.
      LEAVE TO SCREEN SY-DYNNR.
    ELSE.
      EV_VALID = ABAP_FALSE.
    ENDIF.
  ENDIF.             "SUBRC for query from RFCDES
ENDFORM.                    " validate_rfc_connection

*&---------------------------------------------------------------------*
*&      Form  get_fugr_from_fugr_prog
*&---------------------------------------------------------------------*
* Given a function group program name, return the function group name
*----------------------------------------------------------------------*
FORM GET_FUGR_FROM_FUGR_PROG USING FUNCTION_GROUP_PROG
                             CHANGING FUNCTION_GROUP_NAME.

  DATA: NAME           LIKE RS38L-INCLUDE,
        NAMESPACE      LIKE RS38L-NAMESPACE,
        FUGR_PROG_NAME LIKE  RS38L-INCLUDE.

  FUGR_PROG_NAME = FUNCTION_GROUP_PROG.
  CALL FUNCTION 'RS_NAME_SPLIT_NAMESPACE'
    EXPORTING
      NAME_WITH_NAMESPACE    = FUGR_PROG_NAME
    IMPORTING
      NAMESPACE              = NAMESPACE
      NAME_WITHOUT_NAMESPACE = NAME
    EXCEPTIONS
      DELIMITER_ERROR        = 1
      OTHERS                 = 2.
  IF SY-SUBRC <> 0.
    NAMESPACE = ''.
  ENDIF.

  IF NAME CP 'SAPL*'.
    CONCATENATE NAMESPACE NAME+4 INTO FUNCTION_GROUP_NAME.
  ELSE.
    CONCATENATE NAMESPACE NAME INTO FUNCTION_GROUP_NAME.
  ENDIF.

ENDFORM.                    "get_fugr_from_fugr_prog
*---------------------------------------------------------------------*
*       FORM check_filename                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  FILENAME                                                      *
*---------------------------------------------------------------------*
FORM CHECK_FILENAME USING FILENAME.

  DATA: TEMP_FILENAME LIKE RLGRAP-FILENAME,
        LEN           TYPE I,
        LAST_CHARS(4) TYPE C.


  DESCRIBE FIELD FILENAME LENGTH LEN IN CHARACTER MODE.
  IF LEN > 128.
    PERFORM RAISE_ERROR USING
'File name too long. Maximum length is 128 chars'.          "#EC NOTEXT
    LEAVE TO SCREEN SY-DYNNR.
  ENDIF.

  LEN = STRLEN( FILENAME ).
  LEN = LEN - 4.
  LAST_CHARS = FILENAME+LEN(4).
  IF LAST_CHARS <> '.XML' AND LAST_CHARS <> '.xml'.         "#EC NOTEXT
    PERFORM RAISE_ERROR USING
    'File name suffix must be .xml'.                        "#EC NOTEXT
    LEAVE TO SCREEN SY-DYNNR.
  ENDIF.


* Check if the filename contains invalid characters
  TEMP_FILENAME = FILENAME.

  DATA TEMP_FILENAME_STR TYPE STRING.
  TEMP_FILENAME_STR = TEMP_FILENAME.
  TRANSLATE TEMP_FILENAME_STR TO UPPER CASE.
  TEMP_FILENAME = TEMP_FILENAME_STR.

  IF TEMP_FILENAME CN ALLOWED_CHARS.
    PERFORM RAISE_ERROR USING
      'File name is not valid.'.                            "#EC NOTEXT
    LEAVE TO SCREEN SY-DYNNR.
  ENDIF.

ENDFORM.                    "check_filename

*&---------------------------------------------------------------------*
*&      Form  extract_badis
*&---------------------------------------------------------------------*
FORM EXTRACT_BADIS.

  DATA: BADIS_NODE  TYPE XML_ELEMENT.

*---
* Set Object list
*  IF s_devcls[] IS INITIAL.
*    r_fctr_id[] = s_object[].
*  ELSE.
*    FREE r_fctr_id.
*    LOOP AT gt_objectlist INTO gs_objectlist WHERE obj_type = 'SXSD'.
*      CLEAR r_fctr_id.
*      r_fctr_id-sign   = 'I'.
*      r_fctr_id-option = 'EQ'.
*      r_fctr_id-low    = gs_objectlist-obj_name.
*      APPEND r_fctr_id.
*    ENDLOOP.
*  ENDIF.
*  CHECK NOT r_fctr_id[] IS INITIAL.

** Create a child node for the BADIs node
*  PERFORM create_xml_node USING g_iref_pdocument g_iref_root_elem
*                                'BADIS'
*                          CHANGING badis_node.

ENDFORM.                    " extract_badis

*---------------------------------------------------------------------*
*       FORM INIT                                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM INIT.
  DATA: SYSUBRC_CHAR(02) TYPE N.

* Set the package size for data selections.

* In foreground mode, the size is set very high so that each
* select..end select will fetch all the records once - this is
* because writing to file (locally) during select..end select
* closes the DB cursor
  IF NOT R_FORE IS INITIAL.
    PAC_SIZE = 10000000.
  ELSE.
* In background mode, the selection will fetch pac_size records
* in each round trip
    PAC_SIZE = 10000.
  ENDIF.

* Set the start time
  GET TIME.
  STARTTIME = SY-UZEIT.
  STARTDATE = SY-DATUM.

  IF NOT SHOW_SERVERS_NAME IS INITIAL.
*   Get the production system landscape
    PERFORM GET_RFC_SERVER_LIST CHANGING SYSUBRC_CHAR.
  ENDIF.

ENDFORM.                    "INIT

*---------------------------------------------------------------------*
*       FORM GET_RFC_SERVER_LIST                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM GET_RFC_SERVER_LIST CHANGING P_SYSUBRC_CHAR TYPE N.

  DATA: LT_MSXXLIST_46 TYPE MSXXLIST_46_TAB_TYPE,
        LS_MSXXLIST_46 LIKE LINE OF LT_MSXXLIST_46,
        LS_SERVER      TYPE MSXXLIST.

* The server name and host were lengthened in struct msxxlist in
* versions higer than 4.6C. So if the RFC system is 4.6C, the data needs
* to be converted from the old struct to the new one.
  IF RFC_SAPRL = SAPRL_46C.

*   Get the production system landscape into the old struct
    CALL FUNCTION 'TH_SERVER_LIST' DESTINATION P_RFCDES
      TABLES
        LIST           = LT_MSXXLIST_46
      EXCEPTIONS
        NO_SERVER_LIST = 1
        OTHERS         = 2.

    IF SY-SUBRC <> 0.
      P_SYSUBRC_CHAR = SY-SUBRC.
      CONCATENATE
      'Did not get list of '                                "#EC NOTEXT
      'servers from RFC destination '                       "#EC NOTEXT
      'exception '                                          "#EC NOTEXT
        P_SYSUBRC_CHAR INTO GT_ETL_MESSAGE-MESSAGE
                  SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    CLEAR SERVERS[].

*   Move into the new struct.
    LOOP AT LT_MSXXLIST_46 INTO LS_MSXXLIST_46.
      MOVE-CORRESPONDING LS_MSXXLIST_46 TO LS_SERVER.
      APPEND LS_SERVER TO SERVERS.
    ENDLOOP.

  ELSE.

*   Get the production system landscape without struct conversion
    CALL FUNCTION 'TH_SERVER_LIST' DESTINATION P_RFCDES
      TABLES
        LIST           = SERVERS
      EXCEPTIONS
        NO_SERVER_LIST = 1
        OTHERS         = 2.

    IF SY-SUBRC <> 0.
      P_SYSUBRC_CHAR = SY-SUBRC.
      CONCATENATE 'Did not get list of '                    "#EC NOTEXT
      'servers from RFC destination '                       "#EC NOTEXT
         'exception '                                       "#EC NOTEXT
          P_SYSUBRC_CHAR INTO GT_ETL_MESSAGE-MESSAGE
                  SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

  ENDIF.

ENDFORM.                    "GET_RFC_SERVER_LIST

*---------------------------------------------------------------------*
*       FORM INIT_THIRD_PARTY_RANGE                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM INIT_THIRD_PARTY_RANGE.

  CLEAR THIRD_PARTY_NS.
  THIRD_PARTY_NS-SIGN = 'I'.
  THIRD_PARTY_NS-OPTION = 'EQ'.

* Fill all the known third party namespaces

  THIRD_PARTY_NS-LOW = '/AEB/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/ALOGIS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/APPLICON/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/ARINSO/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BEE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BETASYS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BGADDON/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BKC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BMC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BMCCTRLM/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/BMCCTRLS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CAUNI/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIDEON/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIRRUS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVBB/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVBL/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVBR/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVBS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVHF/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVIN/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVKD/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVMD/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CIVWD/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/COCKPIT/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/CWLD/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/DSN/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/DVSREPRO/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/EHR/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/EPIUSE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/ERPSOLUT/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IBBJ/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IBMMON/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/INPUNCTO/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IRM/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IRMGLB/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IRMIPM/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/IXOS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/KCP/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/KERN/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/KINTANA/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/LUMINATE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/MRSS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/NEXTEVO/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/ODT9/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PANAYA/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PATROL/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PBS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PDO/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PEC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PRECISE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PSI/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PSIIC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/PSYNG/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/REALTIME/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/ROMANIA/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/RSC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/RTC/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/RWD/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SBB/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SEAL/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SER/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SIE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SPMEAT/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SUNW/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/SYSLINK/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/TCX/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/TECCOM/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/THE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/USE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSW/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSWAEB/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSWBASE/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSWERP/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSWERPA/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/WSWGTS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/YAMBS/'. APPEND THIRD_PARTY_NS.
  THIRD_PARTY_NS-LOW = '/OPT/'. APPEND THIRD_PARTY_NS.

ENDFORM.                    "INIT_THIRD_PARTY_RANGE

*---------------------------------------------------------------------*
*       FORM TEST_AUTH_READ_SOURCE                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_TABNAME                                                     *
*---------------------------------------------------------------------*
FORM TEST_AUTH_READ_SOURCE USING P_SOURCE_NAME TYPE PROGNAME
                                 P_RFC_DEST TYPE RFCDEST
                                 P_SHOW_NAME_IN_MSG.
* 'NONE'

  DATA: LT_SOURCE     TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
        LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
        RFC_ERROR     TYPE RFCLOG_D,
        MSG1          TYPE STRING,
        MSG2          TYPE STRING.

  CALL FUNCTION 'RPY_PROGRAM_READ' DESTINATION P_RFC_DEST
    EXPORTING
      LANGUAGE              = 'E'
      PROGRAM_NAME          = P_SOURCE_NAME
      ONLY_SOURCE           = 'X'
    TABLES
      SOURCE                = LT_SOURCE
      SOURCE_EXTENDED       = LT_SOURCE_EXT
    EXCEPTIONS
      CANCELLED             = 1
      NOT_FOUND             = 2
      PERMISSION_ERROR      = 3
      SYSTEM_FAILURE        = 4 MESSAGE RFC_ERROR
      COMMUNICATION_FAILURE = 5 MESSAGE RFC_ERROR
      OTHERS                = 6.

* An authorization error
  IF SY-SUBRC = 3.
    IF NOT P_SHOW_NAME_IN_MSG IS INITIAL.
      CONCATENATE 'The user has no '                        "#EC NOTEXT
      'authorizations reading source '                      "#EC NOTEXT
P_SOURCE_NAME
                    INTO MSG1 SEPARATED BY SPACE.
    ELSE.
      CONCATENATE  'The user has no authorizations'         "#EC NOTEXT
                   'reading source'                         "#EC NOTEXT
                   INTO MSG1 SEPARATED BY SPACE.
    ENDIF.

    IF P_RFC_DEST = 'NONE'.
      MSG2 = ' in your current system.'.                    "#EC NOTEXT
    ELSE.
      CONCATENATE ' in system ' P_RFC_DEST '.'              "#EC NOTEXT
                  INTO MSG2 SEPARATED BY SPACE.
    ENDIF.

    MESSAGE E000(CONV) WITH MSG1 MSG2.

* An RFC error
  ELSEIF SY-SUBRC = 4 OR SY-SUBRC = 5.
    MSG1 = RFC_ERROR.
    PERFORM RAISE_ERROR USING MSG1.

* Other problems reading the source
  ELSEIF NOT SY-SUBRC IS INITIAL.
    IF NOT P_SHOW_NAME_IN_MSG IS INITIAL.
      CONCATENATE 'There is a problem reading source '      "#EC NOTEXT
       P_SOURCE_NAME
       INTO MSG1 SEPARATED BY SPACE.
    ELSE.
      MSG1 = 'There is a problem reading source'.           "#EC NOTEXT
    ENDIF.

    IF P_RFC_DEST = 'NONE'.
      MSG2 = ' in your current system.'.                    "#EC NOTEXT
    ELSE.
      CONCATENATE ' in system ' P_RFC_DEST '.'              "#EC NOTEXT
                  INTO MSG2 SEPARATED BY SPACE.
    ENDIF.

    MESSAGE E000(CONV) WITH MSG1 MSG2.
  ENDIF.

ENDFORM.                    "TEST_AUTH_READ_SOURCE

*---------------------------------------------------------------------*
*       FORM CREATE_POPUP_TEXT                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_QUESTION                                                    *
*---------------------------------------------------------------------*
FORM CREATE_POPUP_TEXT CHANGING P_QUESTION.

  DATA:
    DIAG_TEXT1 TYPE STRING,
    DIAG_TEXT2 TYPE STRING,
    DIAG_TEXT3 TYPE STRING,
    TEXT_LINE1 TYPE STRING,
    ANSWER(1)  TYPE C.

  DIAG_TEXT1 = 'You are about to extract the following:'.   "#EC NOTEXT

  CONCATENATE 'Technical objects from SAP system - '        "#EC NOTEXT
  SY-SYSID
  '(' SY-MANDT ')' INTO DIAG_TEXT2 SEPARATED BY SPACE.

  CONCATENATE 'Usage statistics from SAP system - '         "#EC NOTEXT
  RFC_DATA-RFCSYSID '(' RFC_MANDT ')'
  INTO DIAG_TEXT3 SEPARATED BY SPACE.

  TEXT_LINE1 = 'Do you wish to proceed?'.                   "#EC NOTEXT


  IF USAGEONL IS INITIAL.
    CONCATENATE DIAG_TEXT1 DIAG_TEXT2 DIAG_TEXT3 TEXT_LINE1
    INTO QUESTION SEPARATED BY SPACE.
  ELSE.
    CONCATENATE DIAG_TEXT1 DIAG_TEXT3 TEXT_LINE1
    INTO QUESTION SEPARATED BY SPACE.
  ENDIF.

ENDFORM.                     " CREATE_POPUP_TEXT

*---------------------------------------------------------------------*
*       FORM BUILD_LOCAL_FILE_NAME                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILEN                                                       *
*  -->  P_PATH                                                        *
*  -->  P_FULLPATH                                                    *
*---------------------------------------------------------------------*
FORM BUILD_LOCAL_FILE_NAME USING
                           P_FILEN
                     CHANGING P_PATH
                              P_FULLPATH.
  DATA:
    LAST_CHAR TYPE I.
*  Check if the user enterde a directory with '\' at the end
  LAST_CHAR = STRLEN( P_PATH ).
  LAST_CHAR = LAST_CHAR - 1.


  IF P_PATH+LAST_CHAR = '\'.
    CONCATENATE P_PATH DEFAULT_FILENAME INTO P_FULLPATH.
  ELSE.
    CONCATENATE P_PATH '\' INTO P_PATH.
    CONCATENATE P_PATH DEFAULT_FILENAME
    INTO P_FULLPATH.
  ENDIF.

ENDFORM.                     "BUILD_LOCAL_FILE_NAME

*---------------------------------------------------------------------*
*       FORM CORRECT_SERVER_PATH                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_PATH                                                        *
*---------------------------------------------------------------------*
FORM CORRECT_SERVER_PATH CHANGING P_PATH.
  DATA:
    FILE_SEPARATOR TYPE C,
    LAST_CHAR      TYPE I.

  IF NOT P_PATH IS INITIAL.

    LAST_CHAR = STRLEN( P_PATH ).
    LAST_CHAR = LAST_CHAR - 1.

    SEARCH P_PATH FOR '/'.
    IF SY-SUBRC IS INITIAL.
      FILE_SEPARATOR = '/'.
    ELSE.
      FILE_SEPARATOR = '\'.
    ENDIF.

    IF P_PATH+LAST_CHAR NE FILE_SEPARATOR.
      CONCATENATE P_PATH FILE_SEPARATOR INTO P_PATH.
    ENDIF.
  ENDIF.

ENDFORM.                      "CORRECT_SERVER_PATH

*---------------------------------------------------------------------*
*       FORM GET_LAST_CHAR                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_DIRECTORY                                                   *
*  -->  P_LAST_CHAR                                                   *
*---------------------------------------------------------------------*
FORM GET_LAST_CHAR USING P_DIRECTORY
                           P_LAST_CHAR.
  DATA:
    ERROR_MSG       TYPE STRING,
    LAST_CHAR_PLACE TYPE I.
*       Check if the user entered a directory at all
  IF NOT P_DIRECTORY IS INITIAL.
*         Check if the user entered a directory with '\' at the end
    LAST_CHAR_PLACE = STRLEN( P_DIRECTORY ).
    LAST_CHAR_PLACE = LAST_CHAR_PLACE - 1.
    P_LAST_CHAR = P_DIRECTORY+LAST_CHAR_PLACE.
  ELSE.
    CLEAR P_LAST_CHAR.
  ENDIF.
ENDFORM.                    "GET_LAST_CHAR

*&---------------------------------------------------------------------*
*&      Form  get_last_month_date
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_TO_DATE  text
*----------------------------------------------------------------------*
FORM GET_LAST_MONTH_DATE CHANGING CV_TO_DATE TYPE BTCRELDT.
  DATA: LV_DAYS_MONTH TYPE BUTAG, "/osp/dt_day,
        LV_MONTH      TYPE  MONAT,
        LV_YEAR       TYPE  GJAHR.

  LV_MONTH = CV_TO_DATE+4(2).
  LV_YEAR  = CV_TO_DATE(4).

  CALL FUNCTION 'NUMBER_OF_DAYS_PER_MONTH_GET'
    EXPORTING
      PAR_MONTH = LV_MONTH
      PAR_YEAR  = LV_YEAR
    IMPORTING
      PAR_DAYS  = LV_DAYS_MONTH.

  CV_TO_DATE+6(2) = LV_DAYS_MONTH.
ENDFORM.                    " get_last_month_date

*&---------------------------------------------------------------------*
*&      Form  ADD_MESSAGE
*&---------------------------------------------------------------------*
*       This form handles addition of record to ETL_MESSAGES  (
*       messages created during ETL run ) and ETL_JOBLOG ( joblog
*       created during backround run of the ETL )
*----------------------------------------------------------------------*
FORM ADD_MESSAGE USING MESS_TEXT
                       IS_JOBLOG.

  DATA: MESS_RECORD TYPE ETL_MESSAGE_TYPE.

* Handle other data ( message, date and time )
  MESS_RECORD-DATE = SY-DATUM.
  MESS_RECORD-TIME = SY-UZEIT.
  MESS_RECORD-MESSAGE = MESS_TEXT.

* Add to ETL messages
*(only messages that are not intended for the job log)
  IF IS_JOBLOG IS INITIAL.
*   Handle order counter
    MESS_RECORD-ORDER = GT_NEXT_ORDER.
    ADD 1 TO GT_NEXT_ORDER.

    APPEND MESS_RECORD TO GT_ETL_MESSAGE.
  ENDIF.

* Add to the job log (the xml tag and the SM37 log).
* In Debug mode - all messages should appear in the job log
  IF NOT IS_JOBLOG IS INITIAL OR NOT EXTRACT_DEBUG IS INITIAL.
*   Handle order counter
    MESS_RECORD-ORDER = GT_NEXT_ORDER_JOBLOG.
    ADD 1 TO GT_NEXT_ORDER_JOBLOG.

*   Add to the job log tag
    APPEND MESS_RECORD TO GT_ETL_JOBLOG.
*   Add to the job log in SM37
    PERFORM RAISE_MESSAGE USING MESS_TEXT.
  ENDIF.

ENDFORM.                    "ADD_MESSAGE

*&---------------------------------------------------------------------*
*&      Form  RAISE_ERROR
*&---------------------------------------------------------------------*
*       Raises an error to the screen
*----------------------------------------------------------------------*
FORM RAISE_ERROR USING MESS_TEXT.

  DATA: MESS_1 TYPE STRING,
        MESS_2 TYPE STRING,
        MESS_3 TYPE STRING.

  PERFORM SPLIT_MESSAGE USING MESS_TEXT
                        CHANGING MESS_1
                                 MESS_2
                                 MESS_3.

  IF REQUIRE_SECURITY = ABAP_TRUE.

    PERFORM RAISE_DISPLAY_LIKE_ERROR
      USING
        MESS_TEXT
      CHANGING
        MESS_1
        MESS_2
        MESS_3.

  ELSE.
    MESSAGE E000(CONV) WITH MESS_1 MESS_2 MESS_3.
  ENDIF.

ENDFORM.                    "RAISE_ERROR

*&---------------------------------------------------------------------*
*&      Form  RAISE_MESSAGE
*&---------------------------------------------------------------------*
*       Raises the message for the joblog
*----------------------------------------------------------------------*
FORM RAISE_MESSAGE USING MESS_TEXT.

  DATA: MESS_1 TYPE STRING,
        MESS_2 TYPE STRING,
        MESS_3 TYPE STRING.

  PERFORM SPLIT_MESSAGE USING MESS_TEXT
                        CHANGING MESS_1
                                 MESS_2
                                 MESS_3.

  MESSAGE S899(EZ) WITH MESS_1 MESS_2 MESS_3.

ENDFORM.                    "RAISE_MESSAGE

*&---------------------------------------------------------------------*
*&      Form  SPLIT_MESSAGE
*&---------------------------------------------------------------------*
*       Split a message to three message variants (50chars per variant)
*----------------------------------------------------------------------*
FORM SPLIT_MESSAGE USING MESS_TEXT
                   CHANGING  MESS_1 TYPE STRING
                             MESS_2 TYPE STRING
                             MESS_3 TYPE STRING.

  CONSTANTS: C_MESS TYPE STRING VALUE 'MESS_'.
  CONSTANTS: C_MAX_WORD_LENGTH TYPE I VALUE '50'.

  DATA: LT_WORDS TYPE STRINGTAB.
  DATA: LV_WORD TYPE STRING.
  DATA: LV_MESSAGE_INDEX TYPE NUMC1 VALUE 0.
  DATA: LV_NEW_LENGH TYPE I.
  DATA: LV_INDEX TYPE I.

  DATA: LV_VARIABLE_NAME TYPE STRING.

  FIELD-SYMBOLS: <VALUE> TYPE STRING.
  FIELD-SYMBOLS: <WORD>  TYPE STRING.

  SPLIT MESS_TEXT AT SPACE INTO TABLE LT_WORDS.

  LOOP AT LT_WORDS ASSIGNING <WORD>.
    IF STRLEN( <WORD> ) > C_MAX_WORD_LENGTH.
      LV_WORD = <WORD>+C_MAX_WORD_LENGTH.
      LV_INDEX = SY-TABIX.
      ADD 1 TO LV_INDEX.
      INSERT LV_WORD INTO LT_WORDS INDEX LV_INDEX.
      <WORD> = <WORD>(C_MAX_WORD_LENGTH).
    ENDIF.
  ENDLOOP.

  LOOP AT LT_WORDS INTO LV_WORD.

    CONCATENATE C_MESS LV_MESSAGE_INDEX INTO LV_VARIABLE_NAME.
    ASSIGN (LV_VARIABLE_NAME) TO <VALUE>.

    IF SY-TABIX > 1.
      LV_NEW_LENGH = STRLEN( <VALUE> ) + STRLEN( LV_WORD ).
    ENDIF.

    IF LV_NEW_LENGH >= C_MAX_WORD_LENGTH OR SY-TABIX = 1.
      LV_MESSAGE_INDEX = LV_MESSAGE_INDEX + 1.
      CONCATENATE C_MESS LV_MESSAGE_INDEX INTO LV_VARIABLE_NAME.
      ASSIGN (LV_VARIABLE_NAME) TO <VALUE>.

      IF LV_MESSAGE_INDEX > 1.
        CONCATENATE SPACE LV_WORD INTO LV_WORD RESPECTING BLANKS.
      ENDIF.

      <VALUE> = LV_WORD.

    ELSE.

      CONCATENATE <VALUE> LV_WORD INTO <VALUE> SEPARATED BY SPACE.

    ENDIF.

  ENDLOOP.

ENDFORM.                    "SPLIT_MESSAGE

*&---------------------------------------------------------------------*
*&      Form  ADD_TIME
*&---------------------------------------------------------------------*
FORM ADD_TIME USING TIME_TO_ADD LIKE SY-UZEIT
           CHANGING END_TIME LIKE SY-UZEIT
                    END_DATE LIKE SY-DATUM.

  CALL FUNCTION 'C14B_ADD_TIME'
    EXPORTING
      I_STARTTIME = SY-UZEIT
      I_STARTDATE = SY-DATUM
      I_ADDTIME   = TIME_TO_ADD
    IMPORTING
      E_ENDTIME   = END_TIME
      E_ENDDATE   = END_DATE.

ENDFORM.                    "ADD_TIME

*&---------------------------------------------------------------------*
*----FORM OPEN_VALIDATION_PAGE
*&---------------------------------------------------------------------*
FORM OPEN_VALIDATION_PAGE.
  DATA:
    ADDRESS          TYPE STRING,
    SPEC_KEY_CONV(2) TYPE C.

  SPEC_KEY_CONV = REL_SPECIFIC_KEY.
  CONCATENATE C_REST_SERVICE_ADDRESS '/'
  C_REST_VALIDATION_PATH
  C_REST_VALIDATION_SUFFIX
  'accountUID=' ACCOUNT_UID                                 "#EC NOTEXT
  '&abapHash=' ETL_HASH '&abapVersion='                     "#EC NOTEXT
  SPEC_KEY_CONV '&etlVersion='                              "#EC NOTEXT
  GENERAL_PART_VER '&miniVersion=' HEADER_MINI_VERSION      "#EC NOTEXT
  INTO
  ADDRESS.

* Open a web page to validate the version
  CALL METHOD CL_GUI_FRONTEND_SERVICES=>EXECUTE
    EXPORTING
      DOCUMENT               = ADDRESS
*     APPLICATION            =
*     PARAMETER              =
*     DEFAULT_DIRECTORY      =
*     MAXIMIZED              =
*     MINIMIZED              =
*     SYNCHRONOUS            =
    EXCEPTIONS
      CNTL_ERROR             = 1
      ERROR_NO_GUI           = 2
      BAD_PARAMETER          = 3
      FILE_NOT_FOUND         = 4
      PATH_NOT_FOUND         = 5
      FILE_EXTENSION_UNKNOWN = 6
      ERROR_EXECUTE_FAILED   = 7
      OTHERS                 = 8.
  IF SY-SUBRC <> 0.
    ERROR_MSG = 'Error generating the validation page'.     "#EC NOTEXT
    PERFORM RAISE_ERROR USING ERROR_MSG.
  ENDIF.


ENDFORM.                    "OPEN_VALIDATION_PAGE


*&---------------------------------------------------------------------*
*&      Form  CHOOSE_FILE_DESKTOP
*&---------------------------------------------------------------------*
* F4 to select file
*----------------------------------------------------------------------*
FORM CHOOSE_FILE_DESKTOP USING EXENSION TYPE STRING
                               FILE_FILTER TYPE STRING
                         CHANGING CV_FILE.

  DATA:
    T_FILES       TYPE FILETABLE,
    S_FILES       TYPE FILE_TABLE,
    V_CHANGED     TYPE INT4,
    V_RCODE       TYPE INT4,
    V_ACTION      TYPE INT4,
    V_FILE_FILTER TYPE STRING.

* Call dialog to navigate to file
  CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_OPEN_DIALOG
    EXPORTING
      DEFAULT_EXTENSION       = EXENSION                    "#EC NOTEXT
      FILE_FILTER             = FILE_FILTER                 "#EC NOTEXT
      INITIAL_DIRECTORY       = 'C:\'
      MULTISELECTION          = SPACE
    CHANGING
      FILE_TABLE              = T_FILES
      RC                      = V_RCODE
      USER_ACTION             = V_ACTION
    EXCEPTIONS
      FILE_OPEN_DIALOG_FAILED = 1
      CNTL_ERROR              = 2
      ERROR_NO_GUI            = 3
      OTHERS                  = 4.

  IF SY-SUBRC <> 0.
    MESSAGE E208(00) WITH 'FILE_OPEN_DIALOG'.
  ENDIF.

  CALL METHOD CL_GUI_CFW=>FLUSH.

* Only continue if User hasn't cancelled
  CHECK: V_ACTION = 0.

* Determine filename
  READ TABLE T_FILES INDEX 1 INTO S_FILES.
  IF SY-SUBRC <> 0.
    MESSAGE E208(00).
  ENDIF.

  CV_FILE = S_FILES-FILENAME.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  choose_excel_file
*&---------------------------------------------------------------------*
* F4 For to select excel file
*----------------------------------------------------------------------*
FORM CHOOSE_EXCEL_FILE
  CHANGING
    CV_FILE.

  DATA:
    T_FILES       TYPE FILETABLE,
    S_FILES       TYPE FILE_TABLE,
    V_CHANGED     TYPE INT4,
    V_RCODE       TYPE INT4,
    V_ACTION      TYPE INT4,
    V_FILE_FILTER TYPE STRING.

  CONCATENATE '(*.xls)|*.xls|CSV (MS-DOS) (*.txt)|'         "#EC NOTEXT
              '*.txt|'                                      "#EC NOTEXT
              INTO V_FILE_FILTER.

* Call dialog to navigate to file
  CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_OPEN_DIALOG
    EXPORTING
      DEFAULT_EXTENSION       = '*.xls'                     "#EC NOTEXT
      FILE_FILTER             = V_FILE_FILTER
      INITIAL_DIRECTORY       = 'C:\'
      MULTISELECTION          = SPACE
    CHANGING
      FILE_TABLE              = T_FILES
      RC                      = V_RCODE
      USER_ACTION             = V_ACTION
    EXCEPTIONS
      FILE_OPEN_DIALOG_FAILED = 1
      CNTL_ERROR              = 2
      ERROR_NO_GUI            = 3
      OTHERS                  = 4.

  IF SY-SUBRC <> 0.
    MESSAGE E208(00) WITH 'FILE_OPEN_DIALOG'.
  ENDIF.

  CALL METHOD CL_GUI_CFW=>FLUSH.

* Only continue if User hasn't cancelled
  CHECK: V_ACTION = 0.

* Determine filename to open Excel document
  READ TABLE T_FILES INDEX 1 INTO S_FILES.
  IF SY-SUBRC <> 0.
    MESSAGE E208(00).
  ENDIF.  "sy-subrc = 0

  CV_FILE = S_FILES-FILENAME.

ENDFORM.                    "CHOOSE_EXCEL_FILE

*&---------------------------------------------------------------------*
*&      Form  GET_DIR_LIST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->DIRLIST    text
*      -->DIR_NAME   text
*----------------------------------------------------------------------*
FORM GET_DIR_LIST CHANGING DIRLIST TYPE FILE_LIST_TYPE
                           DIR_NAME.

  DATA H_PATH(75) TYPE C.
  DATA LT_FILE_LIST TYPE TABLE OF FILE_TYPE.

  CALL 'C_SAPGPARAM' ID 'NAME' FIELD 'DIR_HOME'
  ID 'VALUE' FIELD H_PATH.

  PERFORM FILL_FILE_LIST USING H_PATH '*'
                         CHANGING LT_FILE_LIST.

  DIRLIST = LT_FILE_LIST.
  DIR_NAME = H_PATH.

ENDFORM.                    "GET_DIR_LIST

*&---------------------------------------------------------------------*
*&      Form  fill_file_list
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->A_DIR_NAME      text
*      -->A_GENERIC_NAME  text
*      -->A_MUST_CS       text
*----------------------------------------------------------------------*
FORM FILL_FILE_LIST USING A_DIR_NAME A_GENERIC_NAME
                    CHANGING CT_FILE_LIST.

  DATA: FILE TYPE FILE_TYPE.

  DATA: BEGIN OF FILE_KEY,
          DIRNAME TYPE DIRNAME_AL11,
          NAME    TYPE FILENAME_AL11,
        END OF FILE_KEY.

  DATA: FILE_LIST TYPE FILE_TYPE OCCURS 100 WITH HEADER LINE.

  DATA: ERRCNT(2) TYPE P VALUE 0.

  CALL 'C_DIR_READ_FINISH'
      ID 'ERRNO'  FIELD FILE_LIST-ERRNO
      ID 'ERRMSG' FIELD FILE_LIST-ERRMSG.

  CALL 'C_DIR_READ_START' ID 'DIR'    FIELD A_DIR_NAME
                          ID 'FILE'   FIELD A_GENERIC_NAME
                          ID 'ERRNO'  FIELD FILE-ERRNO
                          ID 'ERRMSG' FIELD FILE-ERRMSG.
  IF SY-SUBRC <> 0.
  ENDIF.

  DO.
    CLEAR FILE.
    CALL 'C_DIR_READ_NEXT'
      ID 'TYPE'   FIELD FILE-TYPE
      ID 'NAME'   FIELD FILE-NAME
      ID 'LEN'    FIELD FILE-LEN
      ID 'OWNER'  FIELD FILE-OWNER
      ID 'MTIME'  FIELD FILE-MTIME
      ID 'MODE'   FIELD FILE-MODE
      ID 'ERRNO'  FIELD FILE-ERRNO
      ID 'ERRMSG' FIELD FILE-ERRMSG.
    FILE-DIRNAME = A_DIR_NAME.
    MOVE SY-SUBRC TO FILE-SUBRC.
    CASE SY-SUBRC.
      WHEN 0.
        CLEAR: FILE-ERRNO, FILE-ERRMSG.
        CASE FILE-TYPE(1).
          WHEN 'F'.                    " normal file.
            PERFORM FILENAME_USEABLE USING FILE-NAME FILE-USEABLE.
          WHEN 'f'.                    " normal file.
            PERFORM FILENAME_USEABLE USING FILE-NAME FILE-USEABLE.
          WHEN OTHERS. " directory, device, fifo, socket,...
            MOVE ''  TO FILE-USEABLE.
        ENDCASE.
        IF FILE-LEN = 0.
          MOVE '' TO FILE-USEABLE.
        ENDIF.
      WHEN 1.
        EXIT.
      WHEN OTHERS.                     " SY-SUBRC >= 2
        ADD 1 TO ERRCNT.
        IF ERRCNT > 10.
          EXIT.
        ENDIF.
        IF SY-SUBRC = 5.
          MOVE: '???' TO FILE-TYPE,
                '???' TO FILE-OWNER,
                '???' TO FILE-MODE.
        ELSE.
*         ULINE.
*         WRITE: / 'C_DIR_READ_NEXT', 'SUBRC', SY-SUBRC.
        ENDIF.
        MOVE '' TO FILE-USEABLE.
    ENDCASE.
    PERFORM P6_TO_DATE_TIME_TZ(RSTR0400) USING FILE-MTIME
                                               FILE-MOD_TIME
                                               FILE-MOD_DATE.

    MOVE-CORRESPONDING FILE TO FILE_LIST.
    APPEND FILE_LIST.

  ENDDO.

  CALL 'C_DIR_READ_FINISH'
      ID 'ERRNO'  FIELD FILE_LIST-ERRNO
      ID 'ERRMSG' FIELD FILE_LIST-ERRMSG.
  IF SY-SUBRC <> 0.
    WRITE: / 'C_DIR_READ_FINISH', 'SUBRC', SY-SUBRC.
  ENDIF.

  SORT FILE_LIST BY MTIME DESCENDING NAME ASCENDING.
  DELETE FILE_LIST[] WHERE TYPE = 'directory'
  OR NAME CP '*.old'
  OR NAME CP '*.cmd'
  OR NAME CP '*.log'
  OR NAME CP '*.env'
  OR NAME CP '*.bin'
  OR NAME CP '*.pid'
  OR NAME NS '.'.
  CT_FILE_LIST = FILE_LIST[].

ENDFORM.                    "FILL_FILE_LIST

*EJECT
FORM FILENAME_USEABLE USING A_NAME A_USEABLE.
*----================------------------------
  DATA L_NAME(75).

  L_NAME = A_NAME.
  IF L_NAME(4) = 'core' .
    A_USEABLE = ''.
  ELSE.
    A_USEABLE = 'X'.
  ENDIF.
ENDFORM.                    "FILENAME_USEABLE

*&---------------------------------------------------------------------*
*&      Form  update_flags_from_sel
*&---------------------------------------------------------------------*
* If the user can change the ETL run params - update their value from
* the screen
*----------------------------------------------------------------------*
FORM UPDATE_FLAGS_FROM_SEL.

  EXTRACT_USER_DATA = P_USERDA.
  SHOW_SERVERS_NAME = P_SRVRNM.
  GET_AGR_USERS_LOCAL = P_AGRUSL.
  GET_AGR_USERS_RFC = P_AGRUSR.
  EXTRACT_SOLAR_DATA = P_SOLARD.
  NO_WEB_USAGE = P_WEBUSG.
  EXTRACT_PROXY_DATA = P_PROXYD.
  EXTRACT_IDOCS_USAGE = P_IDOCUS.
  EXTRACT_LAYOUTS_USAGE = P_LYOUTU.
  EXTRACT_DEBUG = P_DEBUGX.
  AGR_USERS_ROW_COUNT = P_AGRROW.
  MONTHS_BACK_USAGE = P_MNTHBC.
  USAGE_EXTRACTION_DAYS = P_USGDAY.
  EXTRACT_TOTAL_INSTANCE = P_TOTINS.
  DISABLE_SYNTAX_CHECK = P_SNTXCK.
  DISABLE_GUI_STATUS_EXTRACT = P_GUISTT.
  REQUIRE_SOLMAN_RFC = P_SOLMAN.
  CRS_EXTRACTION_MONTHS = P_CRSMNT.
  PROD_CRS_EXTRACTION_MONTHS = P_PRDCRS.
  ROLES_EXTRACTION_PERIOD = P_ROLPER.
  SKIP_VALIDATION = P_SKPVLD.
  EXTRACT_WD_DATA = P_WDDATA.
  EXTRACT_USER_HR_DATA = P_USERHR.
  EXTRACT_LAYOUTS_USAGE_VIA_RFC = P_LAYUSR.
  EXTRACT_SCI_HANA_PERFORMANCE = P_SCIPRF.
  EXTRACT_WD_SYNTAX_CHECK = P_WDSNTX.
  EXTRACT_TEXT_ELEMENTS = P_TXTELM.
  GET_USAGE_DELTA = P_USGDLT.
  COMPRESS_RESULT_FILE = P_COMPRS.
  EXTRACT_SUSG_DATA = P_SUSG_P.

  IF P_LOGNAM = ABAP_TRUE.
    SHOW_LOGIN_NAME = ABAP_FALSE.
  ELSE.
    SHOW_LOGIN_NAME = ABAP_TRUE.
  ENDIF.

ENDFORM.                    "UPDATE_FLAGS_FROM_SEL

*&---------------------------------------------------------------------*
*&      Form  RAISE_FIELD_MESSAGE
*&---------------------------------------------------------------------*
*       Raises the message for the joblog
*----------------------------------------------------------------------*
FORM DISPLAY_ERROR_MESSAGE USING MESS_TEXT.

  DATA: MESS_1 TYPE STRING,
        MESS_2 TYPE STRING,
        MESS_3 TYPE STRING.

  APPEND MESS_TEXT TO GT_MESSAGE_TAB.

  PERFORM SPLIT_MESSAGE USING MESS_TEXT
                        CHANGING MESS_1
                                 MESS_2
                                 MESS_3.

  MESSAGE S899(EZ) WITH MESS_1 MESS_2 MESS_3 DISPLAY LIKE 'E'.

ENDFORM.                    "RAISE_FIELD_MESSAGE
*&---------------------------------------------------------------------*
*&      Form  CHECK_SI_RFC_DEST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_SI_RFC  text
*      -->P_ABAP_FALSE  text
*      <--P_LV_FLAG  text
*----------------------------------------------------------------------*
FORM CHECK_SI_RFC_DEST  USING    IV_RFC_DEST
                                 IV_VALIDATE
                        CHANGING EV_VALID.

  DATA : LV_ERR_MSG TYPE STRING,
         SI_SYSID   TYPE SYSYSID,
         SI_SAPRL   TYPE SYSAPRL.

  DATA: LV_STRING TYPE STRING.

  DATA: LV_FUNCNAME_REL  TYPE RS38L_FNAM  VALUE
'/SDF/GEN_FUNCS_S4_RELEVAN_CHK'.

  CHECK EXTRACT_SI_S4_CHECK EQ ABAP_TRUE.
  CHECK G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_TRUE.

* SI RFC entered
  CHECK NOT IV_RFC_DEST IS INITIAL.

  PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
                                        IV_VALIDATE
                                  CHANGING EV_VALID
                                           SI_SYSID
                                           SI_SAPRL.

* Tables Accessibility Check
* RFC is valid - ev_valid = true
  IF NOT EV_VALID IS INITIAL.

*   Get the function exit's program
    CALL FUNCTION 'FUNCTION_EXISTS' DESTINATION IV_RFC_DEST
      EXPORTING
        FUNCNAME           = LV_FUNCNAME_REL
      EXCEPTIONS
        FUNCTION_NOT_EXIST = 1
        OTHERS             = 2.

    IF SY-SUBRC <> 0.

      LV_STRING = IV_RFC_DEST.
      CONDENSE LV_STRING NO-GAPS.

      CONCATENATE 'The RFC system:'                         "#EC NOTEXT
      LV_STRING
      'is incapable of performing SI checks.'               "#EC NOTEXT
      INTO LV_ERR_MSG RESPECTING BLANKS
      SEPARATED BY SPACE.

      PERFORM DISPLAY_ERROR_MESSAGE
                  USING
                     LV_ERR_MSG.

    ENDIF.

  ENDIF.

ENDFORM.                    " CHECK_SI_RFC_DEST

*&---------------------------------------------------------------------*
*&      Form  get_sci_inspection_dates
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_SCI_INSPECTION_DATES .

  TYPES: BEGIN OF TY_CHECK,
           INSPECNAME TYPE SCI_DYNP-INSP,
           INSPECVERS TYPE SCI_DYNP-INSP_V,
         END OF TY_CHECK.

  DATA: LT_SCIINS_INF TYPE STANDARD TABLE OF SCIINS_INF.
  DATA: LS_SCIINS_INF TYPE SCIINS_INF.

  DATA: LT_CHECKS TYPE STANDARD TABLE OF TY_CHECK.
  DATA: LS_CHECKS TYPE TY_CHECK.

  IF EXTRACT_SCI_HANA_CHECK EQ ABAP_FALSE AND
     EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_FALSE.
    EXIT.
  ENDIF.

  IF R_SCIHAS EQ ABAP_TRUE.

    IF SCI_FD IS NOT INITIAL.
      LS_CHECKS-INSPECNAME = SCI_FD.
      LS_CHECKS-INSPECVERS = SCI_FDV.

      APPEND LS_CHECKS TO LT_CHECKS.
    ENDIF.


    IF SCI_FDA IS NOT INITIAL.
      LS_CHECKS-INSPECNAME = SCI_FDA.
      LS_CHECKS-INSPECVERS = SCI_FDAV.

      APPEND LS_CHECKS TO LT_CHECKS.
    ENDIF.

    IF SCI_PER IS NOT INITIAL.
      LS_CHECKS-INSPECNAME = SCI_PER.
      LS_CHECKS-INSPECVERS = SCI_PERV.

      APPEND LS_CHECKS TO LT_CHECKS.
    ENDIF.

    CHECK LT_CHECKS IS NOT INITIAL.

    SELECT * FROM SCIINS_INF
      INTO TABLE LT_SCIINS_INF
      FOR ALL ENTRIES IN LT_CHECKS
      WHERE CIUSER = SCI_USR AND
            INSPECNAME EQ LT_CHECKS-INSPECNAME AND
            INSPECVERS EQ LT_CHECKS-INSPECVERS.

    READ TABLE LT_SCIINS_INF INTO LS_SCIINS_INF
        WITH KEY INSPECNAME = SCI_FD.
    IF SY-SUBRC EQ 0.
      SCI_FD_D = LS_SCIINS_INF-EXECDATE.
    ENDIF.

    READ TABLE LT_SCIINS_INF INTO LS_SCIINS_INF
        WITH KEY INSPECNAME = SCI_FDA.
    IF SY-SUBRC EQ 0.
      SCI_FDAD = LS_SCIINS_INF-EXECDATE.
    ENDIF.

    READ TABLE LT_SCIINS_INF INTO LS_SCIINS_INF
        WITH KEY INSPECNAME = SCI_PER.
    IF SY-SUBRC EQ 0.
      SCI_PERD = LS_SCIINS_INF-EXECDATE.
    ENDIF.

  ELSEIF R_SCIXLS EQ ABAP_TRUE.

    PERFORM GET_FILE_DATE USING PXLS_FD CHANGING SCI_FD_D.
    PERFORM GET_FILE_DATE USING PXLS_FDA CHANGING SCI_FDAD.
    PERFORM GET_FILE_DATE USING PXLS_PER CHANGING SCI_PERD.

  ENDIF.

ENDFORM.                    " get_sci_inspection_dates
*&---------------------------------------------------------------------*
*&      Form  GET_FILE_DATE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->p_directory  text
*      <--c_date  text
*----------------------------------------------------------------------*
FORM GET_FILE_DATE  USING    P_DIRECTORY
                    CHANGING C_DATE.


  DATA: LT_FILE_TABLE TYPE TABLE OF FILE_INFO,
        LS_FILE_TABLE LIKE LINE OF LT_FILE_TABLE.
  DATA: LT_PARTS TYPE TABLE OF STRING.
  DATA: LV_FILTER TYPE STRING.
  DATA: LV_COUNT TYPE I.
  DATA: LV_DIR TYPE STRING.
  DATA: LINES TYPE I.

  LV_DIR = P_DIRECTORY.

  SPLIT LV_DIR AT '\' INTO TABLE LT_PARTS.
  DESCRIBE TABLE LT_PARTS LINES LINES.
  READ TABLE LT_PARTS INTO LV_FILTER INDEX LINES.

  REPLACE FIRST OCCURRENCE OF LV_FILTER IN LV_DIR WITH ''.

  CL_GUI_FRONTEND_SERVICES=>DIRECTORY_LIST_FILES(
    EXPORTING
      DIRECTORY                   = LV_DIR         " Directory To Search
      FILTER                      = LV_FILTER      " File filter
      FILES_ONLY     = 'X'          " Return only Files, no Directories
    CHANGING
      FILE_TABLE     = LT_FILE_TABLE  " Return Table for the Found Files
      COUNT          = LV_COUNT       " Number of Files/Dir Found
  EXCEPTIONS
    CNTL_ERROR                  = 1   " Control error
    DIRECTORY_LIST_FILES_FAILED = 2   " Couldnt list files in the dir
    WRONG_PARAMETER             = 3   " Incorrect param combination
    ERROR_NO_GUI                = 4   " No GUI available
    NOT_SUPPORTED_BY_GUI        = 5   " GUI does not support this
    OTHERS                      = 6
  ).

  IF SY-SUBRC EQ 0.
    READ TABLE LT_FILE_TABLE INTO LS_FILE_TABLE INDEX 1.
    C_DATE = LS_FILE_TABLE-CREATEDATE.
  ENDIF.

ENDFORM.                    " GET_FILE_DATE
*&---------------------------------------------------------------------*
*&      Form  get_sapworkdir
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_SAPWORKDIR.

* Run this only if the program is running in foreground
  IF SY-BATCH IS INITIAL.

*   Set the default foreground filename
    TRY.
        CALL FUNCTION 'IW_C_GET_SAPWORKDIR'
          IMPORTING
            SAPWORKDIR = SAPWORKDIR.
        CONCATENATE SAPWORKDIR '\' INTO SAPWORKDIR.
      CATCH CX_ROOT.
        CONCATENATE 'Error while ' 'SAPWORKDIR extraction'  "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDTRY.
  ENDIF.
  IF SAPWORKDIR IS INITIAL.
    SAPWORKDIR = 'C:\'.
  ENDIF.
ENDFORM.                    "get_sapworkdir

*&---------------------------------------------------------------------*
*&      Form  check_etl_version
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM CHECK_ETL_VERSION.
  IF SY-SAPRL < '700'.
    MESSAGE E000(CONV)
    WITH 'ETL version & SAP version are different.'         "#EC NOTEXT
         ' Please contact Panaya customer support.'.        "#EC NOTEXT
  ENDIF.
ENDFORM.                    "check_etl_version

*&---------------------------------------------------------------------*
*&      Form  version_specific_init
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM VERSION_SPECIFIC_INIT.

  DATA: CVERS_WA TYPE CVERS.
  DATA: LV_SUCCESS TYPE FLAG.

  GV_ENDLINE = CL_ABAP_CHAR_UTILITIES=>NEWLINE.
  CONCATENATE SPACE GV_ENDLINE  INTO NEW_LINE.

  IF ENABLE_AUTO_UPLOAD IS NOT INITIAL AND
     C_UPLOAD IS NOT INITIAL.

    PERFORM GET_VANILLA_PROGRAM_SERVICE CHANGING LV_SUCCESS. "elad
    IF LV_SUCCESS IS INITIAL.
      PERFORM FILL_VANILLA_PROGRAMS.
    ENDIF.

  ELSE.
    PERFORM FILL_VANILLA_PROGRAMS.
  ENDIF.

  PERFORM INIT_WEB_BLACKLIST.

* Get Unicode-length
  CALL FUNCTION 'DD_GET_UCLEN'
    IMPORTING
      UCLEN = UNICODELG.

* Find active business set (industry solution)
  SELECT SINGLE BSET
    FROM SFW_ACTIVE_B1
    INTO ACTIVE_INDUSTRY_SOLUTION
    WHERE VERSION = 'A'.

* In case we didn't find any active business set, we look for specific
* IS installed as add-on
  IF SY-SUBRC IS NOT INITIAL.

    SELECT SINGLE * FROM CVERS
    INTO CVERS_WA WHERE COMPONENT = 'P3A'.

    IF SY-SUBRC IS INITIAL.
      ACTIVE_INDUSTRY_SOLUTION = 'AFS'.
    ENDIF.

  ENDIF.
ENDFORM.                    "version_specific_init

*---------------------------------------------------------------------*
*       FORM version_specific_header_attrib
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VERSION_SPECIFIC_HEADER_ATTRIB USING HEADER_NODE TYPE XML_ELEMENT
.
* Add the mini version attribute (for vanilla programs validation)
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'MINI_VERSION'
                                      HEADER_MINI_VERSION.
  MESSAGE S899(EZ) WITH 'MINI_VERSION =' HEADER_MINI_VERSION.

ENDFORM.                    "version_specific_header_attrib

*&---------------------------------------------------------------------*
*&      Form  fill_vanilla_programs
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM FILL_VANILLA_PROGRAMS.
*Cloned Program Names

ENDFORM.                    "fill_vanilla_programs

*&---------------------------------------------------------------------*
*&      Form  VALIDATE_FILE
*&---------------------------------------------------------------------*
*       Read the file till the end and validate that it ends with
*       ROOT_ELEMENT
*----------------------------------------------------------------------*
FORM VALIDATE_FILE USING P_ORIG_FORE_FILE
                         P_ORIG_BACK_FILE
                         P_IS_FORE.

  DATA: L_FILE      TYPE STRING,
        L_LENGTH    TYPE I,
        DATA        TYPE TABLE OF STRING,
        EXPLAN      TYPE STRING,
        NO_OF_LINES TYPE I,
        LAST_LINE   TYPE STRING,
        ERROR_MSG   TYPE STRING,
        CURR_LINE   TYPE STRING.

  IF NOT P_IS_FORE IS INITIAL.

* Read the file
    L_FILE = P_ORIG_FORE_FILE.
    CALL METHOD CL_GUI_FRONTEND_SERVICES=>GUI_UPLOAD
      EXPORTING
        FILENAME                = L_FILE
        FILETYPE                = 'ASC'
      IMPORTING
        FILELENGTH              = L_LENGTH
      CHANGING
        DATA_TAB                = DATA
      EXCEPTIONS
        FILE_OPEN_ERROR         = 1
        FILE_READ_ERROR         = 2
        NO_BATCH                = 3
        GUI_REFUSE_FILETRANSFER = 4
        INVALID_TYPE            = 5
        NO_AUTHORITY            = 6
        UNKNOWN_ERROR           = 7
        BAD_DATA_FORMAT         = 8
        HEADER_NOT_ALLOWED      = 9
        SEPARATOR_NOT_ALLOWED   = 10
        HEADER_TOO_LONG         = 11
        UNKNOWN_DP_ERROR        = 12
        ACCESS_DENIED           = 13
        DP_OUT_OF_MEMORY        = 14
        DISK_FULL               = 15
        DP_TIMEOUT              = 16
        OTHERS                  = 17.

    IF SY-SUBRC <> 0.
      EXPLAN = SY-SUBRC.
      MESSAGE E001(00)
      WITH 'Problem reading file for validation: '          "#EC NOTEXT
        P_ORIG_FORE_FILE ' return code (RC) = ' EXPLAN.     "#EC NOTEXT
    ENDIF.

* Check that the last line is </ROOT_ELEMENT>. If not - show an error.
    DESCRIBE TABLE DATA LINES NO_OF_LINES.
    READ TABLE DATA INDEX NO_OF_LINES INTO LAST_LINE.
    IF LAST_LINE <> '</ROOT_ELEMENT>'.
      MESSAGE E001(00) WITH
       'The file was created cut.'                          "#EC NOTEXT
        'Please rerun the program to create a new file.'.   "#EC NOTEXT
    ENDIF.

  ELSE.

*  Read file
    OPEN DATASET P_ORIG_BACK_FILE FOR INPUT IN TEXT MODE ENCODING
    UTF-8
        MESSAGE ERROR_MSG.

    IF NOT SY-SUBRC IS INITIAL.
      MESSAGE E001(00) WITH 'Problem reading file: '        "#EC NOTEXT
       P_ORIG_BACK_FILE
      ' SUBC: ' ERROR_MSG.
      EXIT.
    ENDIF.

* Check that the last line is </ROOT_ELEMENT>. If not - show an error.
    DO.
      READ DATASET P_ORIG_BACK_FILE INTO CURR_LINE.
      IF SY-SUBRC <> 0.
        EXIT.
      ENDIF.
      LAST_LINE = CURR_LINE.
    ENDDO.
    IF LAST_LINE <> '</ROOT_ELEMENT>'.
      MESSAGE E001(00) WITH
      'The file was created cut.'                           "#EC NOTEXT
      'Please rerun the program to create a new file.'.     "#EC NOTEXT
    ENDIF.

    CLOSE DATASET P_ORIG_BACK_FILE.

  ENDIF.
ENDFORM.                    "VALIDATE_FILE

*&---------------------------------------------------------------------*
*&      Form  IS_EHP7_SYSTEM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->G_IS_EHP7  text
*----------------------------------------------------------------------*
FORM IS_EHP7_SYSTEM CHANGING G_IS_EHP7.

  DATA: CURR_RELEASE TYPE SAPRELEASE.

* Check that the system is EHP7 system
  SELECT SINGLE RELEASE FROM CVERS
  INTO CURR_RELEASE
  WHERE COMPONENT = 'SAP_APPL'.

  IF SY-SUBRC IS INITIAL AND CURR_RELEASE = EHP7_RELEASE.
    G_IS_EHP7 = 'X'.
  ENDIF.

ENDFORM.                    "IS_EHP7_SYSTEM

*&---------------------------------------------------------------------*
*&      Form  INIT_WEB_BLACKLIST
*&---------------------------------------------------------------------*
FORM INIT_WEB_BLACKLIST.

  DATA: LS_WEB_BLACKLIST LIKE LINE OF G_WEB_BLACKLIST.

  LS_WEB_BLACKLIST-SIGN   = 'I'.
  LS_WEB_BLACKLIST-OPTION = 'CP'.

* Suffix
  LS_WEB_BLACKLIST-LOW = '*.PNG'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.HTM'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.ICO'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.CSS'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.PDF'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.XDP'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.XFD'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.ASP'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.JSP'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.CFC'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.CFM'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.TXT'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.DLL'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.XML'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.PHP'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.KEY'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.INI'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.PL'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.TCL'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.JSPA'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.JPG'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.GIF'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.SWF'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.JSF'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.JS'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '*.XLS'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.

* Prefix
  LS_WEB_BLACKLIST-LOW = '/SAP/BC/GUI/SAP/ITS/*'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '/SAP/PUBLIC/BC/UR*'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
  LS_WEB_BLACKLIST-LOW = '/SAP/PUBLIC/BC/ITS*'.
  APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.

ENDFORM.                    " INIT_WEB_BLACKLIST

*---------------------------------------------------------------------*
*   FORM GET_REST_SERVICE_DATA                                        *
*---------------------------------------------------------------------*
*   Call panaya REST service to get data from panaya servers needed   *
*   for the extractor run.                                            *
*---------------------------------------------------------------------*
FORM GET_REST_SERVICE_DATA USING REST_ADDRESS
      CHANGING
        IS_MAJOR_VERSION_ERROR  TYPE FLAG
        IS_VERSION_MISMATCH     TYPE FLAG
        IS_FALLBACK_ACTIVE      TYPE FLAG.

  DATA: LV_SERVICE_SUCCESS TYPE FLAG,
        LV_SERVICE_RESULT  TYPE STRING.

  CLEAR: IS_VERSION_MISMATCH, IS_MAJOR_VERSION_ERROR.

* call the REST service
  PERFORM CALL_PANAYA_REST_SERVICE
    USING REST_ADDRESS
    CHANGING LV_SERVICE_SUCCESS LV_SERVICE_RESULT.

* validate server version
  PERFORM VALIDATE_SERVER_VERSION
    USING
      LV_SERVICE_SUCCESS
      LV_SERVICE_RESULT
    CHANGING
      IS_MAJOR_VERSION_ERROR
      IS_VERSION_MISMATCH
      IS_FALLBACK_ACTIVE.

* get last usage extraction date
  PERFORM GET_LAST_USAGE_EXTRACTION_DATE
    USING
      LV_SERVICE_SUCCESS
      LV_SERVICE_RESULT.

ENDFORM.                    "GET_REST_SERVICE_DATA

*---------------------------------------------------------------------*
*   FORM CALL_PANAYA_REST_SERVICE                                     *
*---------------------------------------------------------------------*
*   Call Panaya REST service and returns the XML answer               *
*---------------------------------------------------------------------*
FORM CALL_PANAYA_REST_SERVICE
  USING
    REST_ADDRESS
  CHANGING
    IS_SUCCESS TYPE FLAG
    RETURN_XML TYPE STRING.

  DATA: LO_HTTP_CLIENT TYPE REF TO IF_HTTP_CLIENT,
        LV_SERVICE_URL TYPE STRING,
        LV_RESULT      TYPE STRING,
        LV_VALUE       TYPE STRING.

  CLEAR IS_SUCCESS.

  CONCATENATE C_REST_SERVICE_ADDRESS  C_REST_SERVICE_SUFFIX
  '/' ACCOUNT_UID '/' ETL_HASH '/'
  REL_SPECIFIC_KEY '/' GENERAL_PART_VER '/' HEADER_MINI_VERSION
  INTO
  LV_SERVICE_URL.

* add message to etl log
  GT_ETL_MESSAGE-MESSAGE = LV_SERVICE_URL.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

* Connect to rest service
  CL_HTTP_CLIENT=>CREATE_BY_URL(
    EXPORTING
      URL                = LV_SERVICE_URL
    IMPORTING
      CLIENT             = LO_HTTP_CLIENT
    EXCEPTIONS
      ARGUMENT_NOT_FOUND = 1
      PLUGIN_NOT_ACTIVE  = 2
      INTERNAL_ERROR     = 3
      OTHERS             = 4 ).

  IF SY-SUBRC <> '0'.
    EXIT.
  ENDIF.

  LO_HTTP_CLIENT->SEND(
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2 ).

  IF SY-SUBRC <> '0'.
    EXIT.
  ENDIF.

  LO_HTTP_CLIENT->RECEIVE(
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3 ).

  IF SY-SUBRC <> '0'.
    EXIT.
  ENDIF.

  RETURN_XML = LO_HTTP_CLIENT->RESPONSE->GET_CDATA( ).

  CONCATENATE 'Panaya service result' RETURN_XML INTO       "#EC NOTEXT
  GT_ETL_MESSAGE-MESSAGE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

  IS_SUCCESS = 'X'.

ENDFORM.                    "CALL_PANAYA_REST_SERVICE

*---------------------------------------------------------------------*
*   FORM validate_server_version                                      *
*---------------------------------------------------------------------*
FORM VALIDATE_SERVER_VERSION
  USING
    LV_SERVICE_SUCCESS      TYPE FLAG
    LV_SERVICE_RESULT       TYPE STRING
  CHANGING
    IS_MAJOR_VERSION_ERROR  TYPE FLAG
    IS_VERSION_MISMATCH     TYPE FLAG
    IS_FALLBACK_ACTIVE      TYPE FLAG.

  DATA:
    IS_VERSION_OK         TYPE STRING,
    LV_VER_VALIDATION_XML TYPE STRING,
    LV_STR_WA             TYPE STRING.

* if validation shouldn't run
  IF SKIP_VALIDATION IS NOT INITIAL.
    IS_FALLBACK_ACTIVE = 'X'.
    EXIT.
  ENDIF.

  CLEAR: IS_VERSION_MISMATCH, IS_MAJOR_VERSION_ERROR.

  IF LV_SERVICE_SUCCESS IS INITIAL OR
     NOT LV_SERVICE_RESULT CS C_SAP_HASHED_VER_BEGIN_TAG.
    IS_FALLBACK_ACTIVE = 'X'.
    PERFORM VERSION_VALIDATION_FALLBACK CHANGING IS_VERSION_OK.
    IF IS_VERSION_OK <> 'X'.
      IS_VERSION_MISMATCH = 'X'.
    ENDIF.
    EXIT.
  ENDIF.

* take only the XML part that relates to version validation.
  PERFORM GET_FIELD_VALUE
    USING
      LV_SERVICE_RESULT
      C_SAP_HASHED_VER_BEGIN_TAG
      C_SAP_HASHED_VER_END_TAG
      'X'
    CHANGING
      LV_VER_VALIDATION_XML.

* check is version above minimal
  PERFORM GET_FIELD_VALUE
    USING
      LV_VER_VALIDATION_XML
      C_IS_VER_ABOVE_MINIMAL_BEGIN
      C_IS_VER_ABOVE_MINIMAL_END
      ' '
    CHANGING
      LV_STR_WA.

* If version is above minimal , check is code match.
  IF LV_STR_WA = C_TRUE_STRING.
    PERFORM GET_FIELD_VALUE
      USING
        LV_VER_VALIDATION_XML
        C_IS_CODE_MATCH_BEGIN
        C_IS_CODE_MATCH_END
        ' '
      CHANGING
        LV_STR_WA.

    IF LV_STR_WA = C_TRUE_STRING.
      IS_VERSION_MISMATCH = ''.
    ELSE.
      IS_VERSION_MISMATCH = 'X'.
    ENDIF.
  ELSE.
    IS_MAJOR_VERSION_ERROR = 'X'.
  ENDIF.

ENDFORM.                    "validate_server_version

*---------------------------------------------------------------------*
*   FORM GET_LAST_USAGE_EXTRACTION_DATE                               *
*---------------------------------------------------------------------*
FORM GET_LAST_USAGE_EXTRACTION_DATE
  USING
    LV_SERVICE_SUCCESS      TYPE FLAG
    LV_SERVICE_RESULT       TYPE STRING.

  DATA:
    LS_USAGE_EXTRACT_DATES TYPE TY_EXTRACT_USAGE_DATE,
    LV_LAST_DATES_XML      TYPE STRING,
    LT_SPLITTED_RESULTS    TYPE TABLE OF STRING,
    LV_SPLIT_SIZE          TYPE I,
    LV_OFFSET              TYPE I,
    LV_STR_WA              TYPE STRING.

  FIELD-SYMBOLS:
    <SPLITTED_LINE>         TYPE STRING.

  IF LV_SERVICE_SUCCESS IS INITIAL.
    EXIT.
  ENDIF.

* take only the XML part that relates to last usage extraction dates.
  PERFORM GET_FIELD_VALUE
    USING
      LV_SERVICE_RESULT
      C_LAST_USG_EXTRAT_BEG_TAG
      C_LAST_USG_EXTRAT_END_TAG
      'X'
    CHANGING
      LV_LAST_DATES_XML.

  IF LV_LAST_DATES_XML IS INITIAL.
    EXIT.
  ENDIF.

  SPLIT LV_LAST_DATES_XML
    AT C_LAST_USG_EXTRAT_BEG_TAG
    INTO TABLE LT_SPLITTED_RESULTS.

* format every result to TY_EXTRACT_USAGE_DATE structure
  LOOP AT LT_SPLITTED_RESULTS ASSIGNING <SPLITTED_LINE> FROM 2.
    CLEAR LS_USAGE_EXTRACT_DATES.

*   get system name
    PERFORM GET_FIELD_VALUE USING <SPLITTED_LINE>
      C_SYSTEM_NAME_BEGIN_TAG
      C_SYSTEM_NAME_END_TAG
      ' '
      CHANGING LV_STR_WA.
    LS_USAGE_EXTRACT_DATES-SYSTEM_NAME = LV_STR_WA.

*   get last extraction date
    PERFORM GET_FIELD_VALUE USING <SPLITTED_LINE>
      C_USG_EXTRACT_D_BEGIN_TAG
      C_USG_EXTRACT_D_END_TAG
      ' '
      CHANGING LV_STR_WA.
    LS_USAGE_EXTRACT_DATES-LAST_EXTRACTION_DATE = LV_STR_WA.

    INSERT LS_USAGE_EXTRACT_DATES INTO TABLE GT_USAGE_EXTRACT_DATES_WS.
  ENDLOOP.

ENDFORM.                    "GET_LAST_USAGE_EXTRACTION_DATE

*&---------------------------------------------------------------------*
*&      Form   version_validation_fallback
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM VERSION_VALIDATION_FALLBACK CHANGING IS_VERSION_OK.

  IS_VERSION_OK = 'X'.

ENDFORM.                    "version_validation_fallback

*------------------------------------------------------------------
* FORM GET_FIELD_VALUE
*------------------------------------------------------------------
FORM GET_FIELD_VALUE
  USING
    P_XML_STRING      TYPE STRING
    P_FIELD_BEGIN_TAG
    P_FIELD_END_TAG
    P_INCLUDE_TAGS    TYPE FLAG
  CHANGING
    P_FIELD_VALUE     TYPE STRING.

  DATA:
    BEGIN_TAG_OFFSET   TYPE I VALUE -1,
    END_TAG_OFFSET     TYPE I VALUE 0,
    SUB_SECTION_OFFSET TYPE I,
    FIELD_VALUE_LENGTH TYPE I.

  CLEAR P_FIELD_VALUE.

* get first occurrence of begin tag
  FIND P_FIELD_BEGIN_TAG IN P_XML_STRING
    MATCH OFFSET BEGIN_TAG_OFFSET.

* get last occurrence of end tag
  WHILE SY-SUBRC IS INITIAL.
    SUB_SECTION_OFFSET = END_TAG_OFFSET + 1.
    FIND P_FIELD_END_TAG IN SECTION OFFSET SUB_SECTION_OFFSET
      OF P_XML_STRING MATCH OFFSET END_TAG_OFFSET.
  ENDWHILE.

  IF BEGIN_TAG_OFFSET > -1 AND END_TAG_OFFSET > 0.
*   if need to return the value encapsulated with the tags
    IF P_INCLUDE_TAGS = 'X'.
      END_TAG_OFFSET = END_TAG_OFFSET + STRLEN( P_FIELD_END_TAG ).
*   if need to return only the value
    ELSE.
      BEGIN_TAG_OFFSET = BEGIN_TAG_OFFSET + STRLEN( P_FIELD_BEGIN_TAG ).
    ENDIF.

    FIELD_VALUE_LENGTH = END_TAG_OFFSET - BEGIN_TAG_OFFSET.
    P_FIELD_VALUE = P_XML_STRING+BEGIN_TAG_OFFSET(FIELD_VALUE_LENGTH).
  ENDIF.

ENDFORM.                    "get_field_value

*&---------------------------------------------------------------------*
*&      Form  check_ver_sci_hana_syntax
*&---------------------------------------------------------------------*
* Check validation system for SCI Hana syntax checks.
*----------------------------------------------------------------------*
FORM CHECK_VER_SCI_HANA_SYNTAX
  USING
    IT_SCI_CHECK_VARIANTS TYPE TT_SCI_CHECKVARIANT_NAMES
  CHANGING
    C_IS_VALID TYPE FLAG.

  C_IS_VALID  = ABAP_TRUE.

  READ TABLE IT_SCI_CHECK_VARIANTS
  WITH KEY TABLE_LINE = C_FUNCTIONAL_DB
  TRANSPORTING NO FIELDS.

  IF SY-SUBRC <> 0.
    C_IS_VALID = ABAP_FALSE.
  ENDIF.

  READ TABLE IT_SCI_CHECK_VARIANTS
  WITH KEY TABLE_LINE = C_FUNCTIONAL_DB_ADDITION
  TRANSPORTING NO FIELDS.

  IF SY-SUBRC <> 0.
    C_IS_VALID = ABAP_FALSE.
  ENDIF.

ENDFORM.                    "check_ver_sci_hana_syntax

*&---------------------------------------------------------------------*
*&      Form  check_ver_sci_hana_performance
*&---------------------------------------------------------------------*
* Check validation system for SCI Hana performance.
*----------------------------------------------------------------------*
FORM CHECK_VER_SCI_HANA_PERFORMANCE
  USING
    IT_SCI_CHECK_VARIANTS TYPE TT_SCI_CHECKVARIANT_NAMES
  CHANGING
    C_IS_VALID TYPE FLAG.

  CLEAR C_IS_VALID.

  READ TABLE IT_SCI_CHECK_VARIANTS
  WITH KEY TABLE_LINE = 'PERFORMANCE_DB'
  TRANSPORTING NO FIELDS.

  IF SY-SUBRC = 0.
    C_IS_VALID = ABAP_TRUE.
  ENDIF.

ENDFORM.                    "check_ver_sci_hana_performance

*&---------------------------------------------------------------------*
*&      Form  get_sci_hana_variants_name
*&---------------------------------------------------------------------*
* get SCI HANA check variants from DB .
*----------------------------------------------------------------------*
FORM GET_SCI_HANA_VARIANTS_NAME
  CHANGING
    CT_SCI_CHECK_VARIANTS TYPE TT_SCI_CHECKVARIANT_NAMES.

  SELECT CHECKVNAME                                     "#EC CI_NOFIRST
  INTO TABLE CT_SCI_CHECK_VARIANTS
  FROM SCICHKV_HD
  WHERE CHECKVNAME IN (C_FUNCTIONAL_DB,
                       C_FUNCTIONAL_DB_ADDITION,
                       C_PERFORMANCE_DB).


ENDFORM.                    "get_sci_hana_variants_name

*&---------------------------------------------------------------------*
*&      Form  check_version_sci_for_hana
*&---------------------------------------------------------------------*
* Check validation system for SCI for Hana
*----------------------------------------------------------------------*
FORM CHECK_VERSION_SCI_FOR_HANA.

  DATA:
    LT_SCI_CHECK_VARIANTS TYPE TABLE OF SCICHKV_HD-CHECKVNAME.

  CLEAR G_IS_CAPABLE_EXTRACT_SCI_HANA.
  CLEAR G_IS_CAN_SCI_HANA_PERFORMANCE.

  " Check if should extract hana data.
  IF EXTRACT_SCI_HANA_CHECK EQ ABAP_FALSE AND
     EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_FALSE.
    RETURN.
  ENDIF.

  " Get the sci hana check variants from the db.
  PERFORM GET_SCI_HANA_VARIANTS_NAME
    CHANGING
      LT_SCI_CHECK_VARIANTS.

  " Check if the system support HANA syntax check.
  PERFORM CHECK_VER_SCI_HANA_SYNTAX
    USING
      LT_SCI_CHECK_VARIANTS
    CHANGING
      G_IS_CAPABLE_EXTRACT_SCI_HANA.

  " Check if the system has SCI Hana check variants.
  IF G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_FALSE AND
     C_ATCRES EQ ABAP_TRUE.

    GT_ETL_MESSAGE-MESSAGE =
    'System HANA Code Inspector version isn''t valid'.      "#EC NOTEXT

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM ADD_NOTIFICATION USING SCI_HANA_IS_NOT_CAPABLE
                                   LV_NOTIFICATION_PARAM
                                   GT_ETL_MESSAGE-MESSAGE.

  ELSEIF EXTRACT_SCI_HANA_PERFORMANCE = ABAP_TRUE.

    " Check if the system support HANA performance check.
    PERFORM CHECK_VER_SCI_HANA_PERFORMANCE
      USING
        LT_SCI_CHECK_VARIANTS
      CHANGING
        G_IS_CAN_SCI_HANA_PERFORMANCE.

    IF G_IS_CAN_SCI_HANA_PERFORMANCE = ABAP_FALSE.

      CONCATENATE 'System HANA Code Inspector doesn''t '    "#EC NOTEXT
                  'support performance check'               "#EC NOTEXT
                  INTO GT_ETL_MESSAGE-MESSAGE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      PERFORM ADD_NOTIFICATION USING SCI_HANA_IS_NOT_CAPABLE
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.

    ENDIF.

  ENDIF.

ENDFORM.                    "check_version_sci_for_hana

*&---------------------------------------------------------------------*
*&      Form  VALIDATE_HANA_SCI_INPUTS
*&---------------------------------------------------------------------*
* Check validation of selection screen inputs for SCI Hana checks.
*----------------------------------------------------------------------*
FORM VALIDATE_HANA_SCI_INPUT
    USING
      P_VARIANT
      IV_INPECTION_NAME
      IV_INSPECTION_VERSION
    CHANGING
      P_ERROR.

  IF P_VARIANT = C_FUNCTIONAL_DB OR
     P_VARIANT = C_FUNCTIONAL_DB_ADDITION OR
     P_VARIANT = C_PERFORMANCE_DB.

    CHECK G_IS_CAPABLE_EXTRACT_SCI_HANA EQ ABAP_TRUE.
* radio button for sci from variant is true
    CHECK R_SCIHAS EQ ABAP_TRUE.

    IF P_VARIANT = C_PERFORMANCE_DB AND
       EXTRACT_SCI_HANA_PERFORMANCE = ABAP_FALSE.
      EXIT.
    ENDIF.

    IF P_VARIANT = C_FUNCTIONAL_DB AND
       EXTRACT_ATC_S4_CHECK = ABAP_TRUE.
      EXIT.
    ENDIF.

  ENDIF.

  " Check if the inpection name exists and
  " contain the Check variant p_variant.
  PERFORM VALIDATE_HANA_SCI_VARIANT
    USING
      IV_INPECTION_NAME
      IV_INSPECTION_VERSION
      P_VARIANT
    CHANGING
      P_ERROR.

  CHECK P_ERROR = ABAP_FALSE.

  IF IV_INPECTION_NAME IS INITIAL AND SY-UCOMM <> 'HANA_SCI'.
    P_ERROR = ABAP_TRUE.

    EXIT.
  ENDIF.


ENDFORM.                    "VALIDATE_HANA_SCI_INPUTS

*&---------------------------------------------------------------------*
*&      Form  VALIDATE_HANA_SCI_VARIANT
*&---------------------------------------------------------------------*
* Check inspection validation that contains the corresponding
* check variants.
*----------------------------------------------------------------------*
FORM VALIDATE_HANA_SCI_VARIANT
  USING
    IV_INPECTION_NAME
    IV_INSPECTION_VERSTION
    IV_VARIANT_NAME
  CHANGING
    C_ERROR TYPE C.

  DATA:
    LO_CI_INSPECTION TYPE REF TO CL_CI_INSPECTION,
    LV_ERROR_MSG     TYPE STRING.

  IF IV_INPECTION_NAME IS INITIAL.
    RETURN.
  ENDIF.

  " Get existing inspection.
  CL_CI_INSPECTION=>GET_REF(
    EXPORTING
      P_USER          =  SCI_USR                 " Code Inspector: User
      P_NAME          =  IV_INPECTION_NAME
      " Code Inspector: Element Name of an Inspection
      P_VERS          =  IV_INSPECTION_VERSTION
      " Code Inspector: Version Number of Element (ObjM, Inspec)
*p_for_deletion  = ''    " CI: To Delete, Only Run Through Part of
*Method
    RECEIVING
      P_REF           =  LO_CI_INSPECTION
      " Reference to Relevant Inspection
    EXCEPTIONS
      INSP_NOT_EXISTS = 1
      OTHERS          = 2
  ).

  IF SY-SUBRC <> 0.

    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  " Load inspection data.
  LO_CI_INSPECTION->GET_INFO(
    EXCEPTIONS
      INSP_NOT_EXISTS           = 1
      CHKV_NOT_EXISTS           = 2
      MISSING_CHKV_PARAMETER    = 3
      OBJS_NOT_EXISTS           = 4
      MISSING_OBJS_PARAMETER    = 5
      OBJECT_MAY_NOT_BE_CHECKED = 6
      OBJECT_NOT_EXISTS         = 7
      INVALID_REQUEST           = 8
      OTHERS                    = 9
  ).

  IF SY-SUBRC <> 0.

    MESSAGE ID SY-MSGID TYPE 'S' NUMBER SY-MSGNO DISPLAY LIKE SY-MSGTY
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.

    C_ERROR = ABAP_TRUE.
  ENDIF.

  " Check if the inspection's check variant
  " is the same of check variant name of the imported parameter.
  IF LO_CI_INSPECTION->CHKV->CHKVINF-CHECKVNAME <> IV_VARIANT_NAME.

    CONCATENATE
    'Please select inspection name '                        "#EC NOTEXT
    'that contains the check variant'                       "#EC NOTEXT
                 IV_VARIANT_NAME
                 INTO LV_ERROR_MSG SEPARATED BY SPACE.

    PERFORM DISPLAY_ERROR_MESSAGE
      USING
        LV_ERROR_MSG .

    C_ERROR = ABAP_TRUE.

    " Check if the inspection is performed.
    " 'O' Not Done, 'B' Batch Planned, 'R' Running, 'X' Performed
  ELSEIF LO_CI_INSPECTION->INSPECINF-EXECSTATUS <> 'X'.

    CONCATENATE  'Please select inspection '                "#EC NOTEXT
    'name that already executed'                            "#EC NOTEXT
                 IV_VARIANT_NAME
                 INTO LV_ERROR_MSG SEPARATED BY SPACE.

    PERFORM DISPLAY_ERROR_MESSAGE
      USING
        LV_ERROR_MSG .

    C_ERROR = ABAP_TRUE.

  ENDIF.

  FREE LO_CI_INSPECTION.

ENDFORM.                    "VALIDATE_HANA_SCI_VARIANT

*&---------------------------------------------------------------------*
*&      Form  add_attr_hana_sci_to_header
*&---------------------------------------------------------------------*
* Add fields inputs of SCI Hana check to header attributes node.
*----------------------------------------------------------------------*
FORM ADD_ATTR_HANA_SCI_TO_HEADER
  USING
   IO_HEADER_NODE.

  " Check If the ETL flag to extract SCI Hana checks.
  IF EXTRACT_SCI_HANA_CHECK EQ ABAP_FALSE AND
     EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_FALSE.
    RETURN.
  ENDIF.

  " Set if ETL is capable to extract SCI Hana.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_HANA_IS_CAPABLE_TO_EXTRACT'
                                  G_IS_CAPABLE_EXTRACT_SCI_HANA.
  MESSAGE S899(EZ) WITH 'SCI_HANA_IS_CAPABLE_TO_EXTRACT ='
  G_IS_CAPABLE_EXTRACT_SCI_HANA.

  IF G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_TRUE.

    " Set if ETL is capable to extract SCI Hana performance.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
    'SCI_HANA_IS_CAPABLE_TO_PERFORMANCE'
                                    G_IS_CAN_SCI_HANA_PERFORMANCE.
    MESSAGE S899(EZ) WITH 'SCI_HANA_IS_CAPABLE_TO_PERFORMANCE ='
    G_IS_CAN_SCI_HANA_PERFORMANCE.


    " Set inspections names of exists Hana SCI list.
    IF R_SCIHAS IS NOT INITIAL.

      PERFORM ADD_ATTR_SCI_PARAMS_TO_HEADER CHANGING IO_HEADER_NODE.

    ENDIF.

  ENDIF.

  " Set Hana from excel
  IF R_SCIXLS IS NOT INITIAL.

    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
    'SCI_HANA_FROM_EXCEL'
     R_SCIXLS.

    MESSAGE S899(EZ) WITH 'SCI_HANA_FROM_EXCEL =' R_SCIXLS.

  ENDIF.

  PERFORM ADD_ATTR_SCI_DATES_TO_HEADER CHANGING IO_HEADER_NODE.

ENDFORM.                    "add_attr_hana_sci_to_header

*&---------------------------------------------------------------------*
*&      Form  set_sci_hana_titles
*&---------------------------------------------------------------------*
* Set SCI Hana titles
*----------------------------------------------------------------------*
FORM SET_SCI_HANA_TITLES.

  TSCI_USR = 'Person Responsible'.                          "#EC NOTEXT
  TIT_FD = 'Inspection Name for FUNCTIONAL_DB'.             "#EC NOTEXT
  TIT_FDA = 'Inspection Name for FUNCTIONAL_DB_ADDITION'.   "#EC NOTEXT

  IF EXTRACT_SCI_HANA_PERFORMANCE  = ABAP_TRUE.
    TIT_PER = 'Inspection Name for PERFORMANCE_DB'.         "#EC NOTEXT
  ENDIF.

ENDFORM.                    "set_sci_hana_titles

*&---------------------------------------------------------------------*
*&      Form  invisible_sci_hana_fields
*&---------------------------------------------------------------------*
* Invisible SCI Hana fields, if not needed or if the extraction
* in execute mode.
*----------------------------------------------------------------------*
FORM INVISIBLE_SCI_HANA_FIELDS.

  DATA:
    LV_IS_INVISIBLE TYPE FLAG.

  " If SCI Hana extract not needed
  " or user select execute mode
  " hide the screen elements.
  IF EXTRACT_SCI_HANA_CHECK = ABAP_FALSE AND
     EXTRACT_SCI_HANA_PERFORMANCE = ABAP_FALSE AND
   ( SCREEN-NAME            = 'B8'       OR
     SCREEN-NAME            = 'TITL8'    OR
     SCREEN-GROUP1          = 'XLS'      OR
     SCREEN-GROUP1          = 'B8'       OR
     SCREEN-GROUP1 = 'SCI'               OR
     SCREEN-GROUP1 = 'SHC'                OR
     SCREEN-GROUP1 = 'XLS' ).

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF EXTRACT_SCI_HANA_CHECK = ABAP_FALSE AND
         ( SCREEN-NAME = 'TXLS_FDA' OR
           SCREEN-NAME =  'PXLS_FDA').

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF ( EXTRACT_SCI_HANA_CHECK = ABAP_FALSE OR
    G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_FALSE ) AND
       ( SCREEN-NAME = 'TIT_FDA' OR
         SCREEN-NAME = 'SCI_FDA' OR
         SCREEN-NAME = 'SCI_FDAV' OR
         SCREEN-NAME = 'SCI_FD' OR
         SCREEN-NAME = 'SCI_FDV' OR
         SCREEN-NAME = 'TIT_FD' ).

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF EXTRACT_SCI_HANA_PERFORMANCE = ABAP_FALSE AND
         ( SCREEN-NAME = 'TXLS_PER' OR
           SCREEN-NAME =  'PXLS_PER').

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF G_IS_CAN_SCI_HANA_PERFORMANCE = ABAP_FALSE AND
       ( SCREEN-NAME = 'TIT_PER' OR
         SCREEN-NAME = 'SCI_PER' OR
         SCREEN-NAME = 'SCI_PERV' ).

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF ( G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_TRUE OR
           R_SCIXLS IS NOT INITIAL )             AND
           SCREEN-GROUP1 = 'SHC'.

    LV_IS_INVISIBLE = ABAP_TRUE.

  ELSEIF G_IS_CAPABLE_EXTRACT_SCI_HANA = ABAP_FALSE AND
         SCREEN-GROUP1 = 'SCI'.

    LV_IS_INVISIBLE = ABAP_TRUE.

  ENDIF.

  IF R_SCIHAS IS INITIAL   AND
         SCREEN-GROUP1 = 'SCI'.
    LV_IS_INVISIBLE = ABAP_TRUE.
  ELSEIF R_SCIXLS IS INITIAL   AND
         SCREEN-GROUP1 = 'XLS' .

    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF LV_IS_INVISIBLE EQ ABAP_TRUE.

    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = '0'.
    SCREEN-INVISIBLE = '1'.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.

  ENDIF.

ENDFORM.                    "invisible_sci_hana_fields

*&---------------------------------------------------------------------*
*&      Form  ADD_CONTROLLER_NODE_BY_TYPE
*&---------------------------------------------------------------------*
*       read controller data by type (window, controller, view, ccont)
*----------------------------------------------------------------------*
*      -->P_CURR_NODE        text
*      -->P_COMPONENT_LINE   text
*      -->P_CONTROLLER_LINE  text
*----------------------------------------------------------------------*
FORM ADD_CONTROLLER_NODE_BY_TYPE USING
      P_CURR_NODE TYPE REF TO IF_IXML_ELEMENT
      P_COMPONENT_LINE  TYPE WDY_COMPONENT
      P_CONTROLLER_LINE TYPE WDY_CONTROLLER.

  DATA:
    WD_METHOD_CODE_NODE TYPE REF TO IF_IXML_ELEMENT,
    METHOD_CODE         TYPE STRING.

  DATA:
            FIELD_NAME TYPE STRING.

  DATA: R_DESCR TYPE REF TO CL_ABAP_STRUCTDESCR,
        WA_COMP TYPE ABAP_COMPDESCR.

  FIELD-SYMBOLS:
  <FS> TYPE ANY.

  PERFORM ADD_ATTRIBUTE_TO_NODE
              USING
                  P_CURR_NODE
                  'NAME'
                  P_CONTROLLER_LINE-CONTROLLER_NAME.

  PERFORM ADD_ATTRIBUTE_TO_NODE
              USING
                 P_CURR_NODE
                 'MASTER_COMPONENT'
                 P_COMPONENT_LINE-COMPONENT_NAME.

  SORT WDY_CONTROLLER_DESC_TAB.


*           read description for the customer controller
  READ TABLE WDY_CONTROLLER_DESC_TAB
  WITH KEY COMPONENT_NAME = P_COMPONENT_LINE-COMPONENT_NAME
           CONTROLLER_NAME = P_CONTROLLER_LINE-CONTROLLER_NAME
           LANGU = SY-LANGU
  INTO WDY_CONTROLLER_DESC_WA BINARY SEARCH.

  IF SY-SUBRC EQ 0.
    PERFORM ADD_ATTRIBUTE_TO_NODE
                USING
                   P_CURR_NODE
                    'DESCRIPTION'
                    WDY_CONTROLLER_DESC_WA-DESCRIPTION.


  ENDIF.

*---Read all methods for component
  READ TABLE WDY_CTLR_COMPO_TAB TRANSPORTING NO FIELDS WITH KEY
       COMPONENT_NAME = P_COMPONENT_LINE-COMPONENT_NAME
       CONTROLLER_NAME = P_CONTROLLER_LINE-CONTROLLER_NAME BINARY SEARCH
       .

  IF SY-SUBRC = 0.

*           go through every method
    LOOP AT WDY_CTLR_COMPO_TAB INTO WDY_CTLR_COMPO_WA FROM SY-TABIX.

*               Add method params:
*               Create a child node for the methods node
      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT P_CURR_NODE
                                  'METHOD'
                            CHANGING WD_METHOD_NODE.


      IF EXTRACT_WD_METHOD_CODE EQ 'X'. " Extract code section


*   Add the Program Source data to the current program
        METHOD_CODE = WDY_CTLR_COMPO_WA-CODE_BODY.


        REPLACE ALL OCCURRENCES OF '&GT' IN METHOD_CODE WITH  '>' .
        REPLACE ALL OCCURRENCES OF '&gt' IN METHOD_CODE WITH  '>' .
        REPLACE ALL OCCURRENCES OF '&LT' IN METHOD_CODE WITH  '<'.
        REPLACE ALL OCCURRENCES OF '&lt' IN METHOD_CODE WITH  '<'.

        REPLACE ALL OCCURRENCES OF REGEX '##' IN METHOD_CODE  WITH ' '.

        REPLACE ALL OCCURRENCES OF ']]>'
          IN METHOD_CODE WITH CDATA_END_REPLACE.

        REPLACE ALL OCCURRENCES OF '?XML' IN METHOD_CODE WITH
        '&XML_START_TAG&'.
        REPLACE ALL OCCURRENCES OF '?xml' IN METHOD_CODE WITH
        '&XML_START_TAG&'.

*       Add method code as cdata
        PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
                                            WD_METHOD_NODE
                                              'METHOD_CODE'
                                               METHOD_CODE 'X'
                                        CHANGING WD_METHOD_CODE_NODE.


        IF WD_METHOD_CODE_NODE IS NOT INITIAL.

          PERFORM ADD_ATTRIBUTE_TO_NODE
              USING
                 WD_METHOD_CODE_NODE
                  'COMPONENT_NAME'
                  WDY_CTLR_COMPO_WA-COMPONENT_NAME.

          PERFORM ADD_ATTRIBUTE_TO_NODE
                USING
                   WD_METHOD_CODE_NODE
                    'CONTROLLER_NAME'
                    WDY_CTLR_COMPO_WA-CONTROLLER_NAME.

          PERFORM ADD_ATTRIBUTE_TO_NODE
                USING
                   WD_METHOD_CODE_NODE
                    'METHOD_NAME'
                    WDY_CTLR_COMPO_WA-CMPNAME.

        ENDIF.

      ENDIF.

*   add method data
      R_DESCR ?=
        CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( WDY_CTLR_COMPO_WA ).
      LOOP AT R_DESCR->COMPONENTS INTO WA_COMP.

        IF WA_COMP-NAME <> 'CODE_BODY'.
          ASSIGN COMPONENT WA_COMP-NAME OF STRUCTURE
          WDY_CTLR_COMPO_WA TO <FS>.

          IF SY-SUBRC EQ 0.

            FIELD_NAME = WA_COMP-NAME.
            PERFORM ADD_ATTRIBUTE_TO_NODE
                        USING
                            WD_METHOD_NODE
                            FIELD_NAME
                            <FS>.
          ENDIF.

        ENDIF.

      ENDLOOP.

*   read method description
      READ TABLE WDY_CTLR_COMPO_DESC_TAB WITH KEY
         COMPONENT_NAME = P_COMPONENT_LINE-COMPONENT_NAME
         CONTROLLER_NAME = P_CONTROLLER_LINE-CONTROLLER_NAME
         CMPNAME        = WDY_CTLR_COMPO_WA-CMPNAME
         LANGU          = SY-LANGU

      INTO WDY_CTLR_COMPO_DESC_WA   BINARY SEARCH.

      IF SY-SUBRC EQ 0.

        PERFORM ADD_ATTRIBUTE_TO_NODE
                    USING
                       WD_METHOD_NODE
                        'DESCRIPTION'
                        WDY_CTLR_COMPO_DESC_WA-DESCRIPTION.

      ENDIF.

*   for every method, add its parameters:
*---        Read all methods for component
      SORT WDY_CTLR_PARAM_TAB.
      READ TABLE WDY_CTLR_PARAM_TAB TRANSPORTING NO FIELDS WITH KEY
             COMPONENT_NAME = P_COMPONENT_LINE-COMPONENT_NAME
             CONTROLLER_NAME = P_CONTROLLER_LINE-CONTROLLER_NAME
             CMPNAME        = WDY_CTLR_COMPO_WA-CMPNAME BINARY SEARCH.

      CLEAR: START_OF_CMP_FOR_METHOD, END_OF_CMP_FOR_METHOD.

      IF SY-SUBRC = 0.

        START_OF_CMP_FOR_METHOD = SY-TABIX.
*                 go through every method

        LOOP AT WDY_CTLR_PARAM_TAB INTO WDY_CTLR_PARAM_WA FROM
        START_OF_CMP_FOR_METHOD.

          AT END OF CMPNAME.
            END_OF_CMP_FOR_METHOD = SY-TABIX.
            APPEND LINES OF WDY_CTLR_PARAM_TAB FROM
            START_OF_CMP_FOR_METHOD TO END_OF_CMP_FOR_METHOD TO
            SINGLE_METHOD_PARAM_TAB.

            PERFORM ADD_ITAB_TO_XML_SIMPLE
                        TABLES
                           SINGLE_METHOD_PARAM_TAB
                        USING
                           G_IREF_PDOCUMENT
                           WD_METHOD_NODE
                           'METHOD_PARAM'.

            REFRESH SINGLE_METHOD_PARAM_TAB[].
            EXIT.
          ENDAT.

        ENDLOOP.
        " LOOP AT WDY_CTLR_PARAM_TAB INTO
        " WDY_CTLR_PARAM_WA FROM start_of_cmp_for_method

      ENDIF.

      AT END OF CONTROLLER_NAME.

        EXIT.

      ENDAT.

    ENDLOOP.
    " LOOP AT WDY_CTLR_COMPO_TAB INTO WDY_CTLR_compo_wa FROM sy-tabix
  ENDIF.

ENDFORM.                    "ADD_CONTROLLER_NODE_BY_TYPE

*&---------------------------------------------------------------------*
*&      Form  ADD_INTERFACE_IMPL_DATA_TO_XML
*&---------------------------------------------------------------------*
*       add interface implementations
*----------------------------------------------------------------------*
*      -->P_WDY_COMPONENT_WA  text
*----------------------------------------------------------------------*
FORM ADD_INTERFACE_IMPL_DATA_TO_XML  USING  P_WDY_COMPONENT_WA
      TYPE WDY_COMPONENT.

  DATA:
    COMPO_INTER_INDEX_START TYPE SY-TABIX,
    COMPO_INTER_INDEX_END   TYPE SY-TABIX.

*    read interface implementations
  READ TABLE WDY_INTF_IMPLEM_TAB TRANSPORTING NO FIELDS WITH KEY
    COMPONENT_NAME = P_WDY_COMPONENT_WA-COMPONENT_NAME BINARY SEARCH.

  IF SY-SUBRC EQ 0.
    CLEAR: COMPO_INTER_INDEX_END, COMPO_INTER_INDEX_START.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
    WD_USED_OBJECTS_NODE
                                'INTERFACE_IMPLEMENTATIONS'
                          CHANGING WD_INTF_IMPLEM_NODE.

    COMPO_INTER_INDEX_START = SY-TABIX.

    LOOP AT WDY_INTF_IMPLEM_TAB INTO WDY_INTF_IMPLEM_WA FROM
    COMPO_INTER_INDEX_START.

      AT END OF COMPONENT_NAME.

        COMPO_INTER_INDEX_END = SY-TABIX.
        APPEND LINES OF WDY_INTF_IMPLEM_TAB
        FROM COMPO_INTER_INDEX_START TO COMPO_INTER_INDEX_END TO
        WDY_INTF_IMPLEM_TAB_LOCAL.

        PERFORM ADD_ITAB_TO_XML_SIMPLE
          TABLES
             WDY_INTF_IMPLEM_TAB_LOCAL
          USING
             G_IREF_PDOCUMENT
             WD_INTF_IMPLEM_NODE
             'INTERFACE_IMPLEMENTATION'.

        REFRESH WDY_INTF_IMPLEM_TAB_LOCAL[].

        EXIT.
      ENDAT.

    ENDLOOP.
    " loop at wdy_intf_implem_tab into wdy_intf_implem_wa
    "from compo_usage_index_start

  ENDIF.

ENDFORM.                    " ADD_INTERFACE_IMPL_DATA_TO_XML
*&---------------------------------------------------------------------*
*&      Form  ADD_COMP_DESCRIPTIONS_TO_XML
*&---------------------------------------------------------------------*
*       add component descriptions
*----------------------------------------------------------------------*
*      -->P_WDY_COMPONENT_WA  text
*----------------------------------------------------------------------*
FORM ADD_COMP_DESCRIPTIONS_TO_XML  USING    P_WDY_COMPONENT_WA.

  DATA:
    DESC_START_INDEX TYPE SY-TABIX,
    DESC_END_INDEX   TYPE SY-TABIX.

  CLEAR:
  DESC_START_INDEX, DESC_END_INDEX.

*   add component description
  READ TABLE WDY_COMPONENT_DESC_TAB INTO WDY_COMPONENT_DESC_WA
  WITH KEY COMPONENT_NAME = WDY_COMPONENT_WA-COMPONENT_NAME BINARY
  SEARCH .
  IF SY-SUBRC EQ 0.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_COMPS_NODE
                                'COMPONENT_DESCRIPTIONS'
                          CHANGING WD_COMPO_DESCRIPTIONS_NODE.

    DESC_START_INDEX = SY-TABIX.

    LOOP AT WDY_COMPONENT_DESC_TAB INTO WDY_COMPONENT_DESC_WA FROM
    DESC_START_INDEX.

      AT END OF COMPONENT_NAME.

        DESC_END_INDEX = SY-TABIX.
        APPEND LINES OF WDY_COMPONENT_DESC_TAB
        FROM DESC_START_INDEX TO DESC_END_INDEX TO
        WDY_COMPONENT_DESC_TAB_LOCAL.

        PERFORM ADD_ITAB_TO_XML_SIMPLE
          TABLES
              WDY_COMPONENT_DESC_TAB_LOCAL
          USING
             G_IREF_PDOCUMENT
             WD_COMPO_DESCRIPTIONS_NODE
             'COMPONENT_DESCRIPTION'.

        REFRESH WDY_COMPONENT_DESC_TAB_LOCAL[].
        EXIT.

      ENDAT.

    ENDLOOP.

  ENDIF.

ENDFORM.                    " ADD_COMP_DESCRIPTIONS_TO_XML

*&---------------------------------------------------------------------*
*&      Form  RAISE_DISPLAY_LIKE_ERROR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->MESS_TEXT  text
*      -->MESS_1     text
*      -->MESS_2     text
*      -->MESS_3     text
*----------------------------------------------------------------------*
FORM RAISE_DISPLAY_LIKE_ERROR
  USING
    MESS_TEXT
  CHANGING
    MESS_1
    MESS_2
    MESS_3.

  MESSAGE S899(EZ) DISPLAY LIKE 'E' WITH MESS_1 MESS_2 MESS_3.
  LEAVE TO SCREEN SY-DYNNR.

ENDFORM.                    "raise_display_like_error

*&---------------------------------------------------------------------*
*&      Form  save_excel_as_text_in_app_srv
*&---------------------------------------------------------------------*
* Save excel file from client in application server
* as text file with tab delimiter.
*----------------------------------------------------------------------*
FORM SAVE_EXCEL_AS_TEXT_IN_APP_SRV
  USING
    IV_EXCEL_FILE
    IV_VARIANT
  CHANGING
    CV_FULLNAME.

  TYPE-POOLS:TRUXS.

  DATA:
    LV_TEXT_FILE      TYPE          STRING,
    LT_EXCEL_SCI_HANA TYPE          TT_EXCEL_SCI_HANA,
    LS_EXCEL_SCI_HANA LIKE LINE  OF LT_EXCEL_SCI_HANA,
    FILE              TYPE          RLGRAP-FILENAME,
    STRING_TO_FILE    TYPE          STRING,
    LV_INDEX          TYPE          I,
    LI_TAB_RAW_DATA   TYPE          TRUXS_T_TEXT_DATA,
    LV_MESSAGE        TYPE          STRING,
    EXTENSION_VALUE   TYPE          STRING,
    LV_FILE_NAME      TYPE          PCFILE-PATH.

  FIELD-SYMBOLS:
    <COMP> TYPE STRING.

  IF IV_EXCEL_FILE IS INITIAL.
    EXIT.
  ENDIF.

  FILE = IV_EXCEL_FILE.

* checking the file extension is xls or txt
  LV_FILE_NAME = IV_EXCEL_FILE.

  PERFORM GET_EXTENSION USING IV_EXCEL_FILE
                        CHANGING EXTENSION_VALUE.

  IF SY-SUBRC <> 0 OR
    ( EXTENSION_VALUE <> 'XLS' AND EXTENSION_VALUE <> 'TXT' ).

    CONCATENATE
      'SCI HANA Excel path for'                             "#EC NOTEXT
      IV_VARIANT
      'is not valid.'                                       "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.

    LEAVE TO SCREEN SY-DYNNR.
    EXIT.

  ENDIF.

  IF EXTENSION_VALUE = 'XLS'.

    CALL FUNCTION 'TEXT_CONVERT_XLS_TO_SAP'
      EXPORTING
*       I_FIELD_SEPERATOR    =
*       I_LINE_HEADER        = 'X'
        I_TAB_RAW_DATA       = LI_TAB_RAW_DATA
        I_FILENAME           = FILE
      TABLES
        I_TAB_CONVERTED_DATA = LT_EXCEL_SCI_HANA
      EXCEPTIONS
        CONVERSION_FAILED    = 1
        OTHERS               = 2.

  ELSEIF EXTENSION_VALUE = 'TXT'.

    DATA DELIMITER TYPE CHAR01 VALUE
          CL_ABAP_CHAR_UTILITIES=>HORIZONTAL_TAB.

    STRING_TO_FILE =  FILE.
    CALL FUNCTION 'GUI_UPLOAD'
      EXPORTING
        FILENAME            = STRING_TO_FILE
        FILETYPE            = 'ASC'
        HAS_FIELD_SEPARATOR = DELIMITER
      TABLES
        DATA_TAB            = LT_EXCEL_SCI_HANA
      EXCEPTIONS
        OTHERS              = 1.

  ENDIF.

  IF SY-SUBRC <> 0.
    CONCATENATE
      'SCI HANA Excel format for'                           "#EC NOTEXT
      IV_VARIANT
      'is not valid'                                        "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.

    LEAVE TO SCREEN SY-DYNNR.
    EXIT.
  ENDIF.

  CALL METHOD CL_GUI_CFW=>FLUSH.

  PERFORM VALIDATE_SCI_HANA_EXCEL
    USING
      LT_EXCEL_SCI_HANA
      IV_VARIANT.

* Delete the header.
  DELETE LT_EXCEL_SCI_HANA INDEX 1.

  PERFORM SET_TMP_FILENAME
    USING
      IV_VARIANT
      GV_BACK_PATH
    CHANGING
     LV_TEXT_FILE.

  OPEN DATASET LV_TEXT_FILE FOR OUTPUT IN TEXT MODE ENCODING UTF-8.

  IF SY-SUBRC NE 0.

    CONCATENATE
    'Cann''t Save SCI HANA Excel for'                       "#EC NOTEXT
    IV_VARIANT
    'on application server'                                 "#EC NOTEXT
    INTO LV_MESSAGE SEPARATED BY SPACE.

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.

    LEAVE TO SCREEN SY-DYNNR.
    EXIT.

  ENDIF.

  LOOP AT LT_EXCEL_SCI_HANA INTO LS_EXCEL_SCI_HANA.

    CLEAR STRING_TO_FILE.

    DO.
      LV_INDEX = SY-INDEX.

      ASSIGN COMPONENT SY-INDEX
      OF STRUCTURE LS_EXCEL_SCI_HANA TO <COMP>.

      IF SY-SUBRC <> 0.
        EXIT.
      ENDIF.

      IF SY-INDEX = 1.
        CONCATENATE STRING_TO_FILE <COMP> INTO STRING_TO_FILE.
      ELSE.
        CONCATENATE STRING_TO_FILE <COMP> INTO STRING_TO_FILE
        SEPARATED BY CL_ABAP_CHAR_UTILITIES=>HORIZONTAL_TAB.
      ENDIF.

    ENDDO.

    TRANSFER STRING_TO_FILE TO LV_TEXT_FILE.

  ENDLOOP.

  CLOSE DATASET LV_TEXT_FILE.

  CV_FULLNAME = LV_TEXT_FILE.

ENDFORM.                    "save_excel_as_text_in_app_srv


*&---------------------------------------------------------------------*
*&      Form  validate_sci_hana_excel
*&---------------------------------------------------------------------*
* Validate sci hana excel file
*----------------------------------------------------------------------*
FORM VALIDATE_SCI_HANA_EXCEL
  USING
    IT_EXCEL_SCI_HANA TYPE TT_EXCEL_SCI_HANA
    IV_VARIANT.

  DATA:
    LT_VALID_HEADER_NAMES TYPE TABLE OF STRING,
    LV_INDEX              TYPE I,
    LV_MESSAGE            TYPE STRING.

  FIELD-SYMBOLS:
    <LS_EXCEL_SCI_HANA> LIKE LINE OF IT_EXCEL_SCI_HANA,
    <LV_COMP>           TYPE         STRING,
    <LV_VALID_HEADER>   TYPE         STRING.

  READ TABLE IT_EXCEL_SCI_HANA INDEX 1 ASSIGNING <LS_EXCEL_SCI_HANA>.

  IF SY-SUBRC NE 0.

    CONCATENATE
    'SCI HANA Excel format for'                             "#EC NOTEXT
    IV_VARIANT
    ' is not valid'                                         "#EC NOTEXT
    INTO LV_MESSAGE.

    PERFORM RAISE_ERROR USING LV_MESSAGE.

    LEAVE TO SCREEN SY-DYNNR.
    EXIT.
  ENDIF.

  APPEND 'Object Type'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Object Name'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Package'                                          "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  "'Applicatn Component' or 'Applic. Component' or 'Appl. Component'
  APPEND 'Appl'                                             "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Person Responsible for a Dev. Object'             "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Message Type'                                     "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Error Messages'                                   "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'WarningMessages'                                  "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Information Messages'                             "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Message Text'                                     "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Check Description'                                "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Check Class'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Message code'                                     "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Object Type'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Object Name'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Line Number'                                      "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Column Number for Message'                        "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Results Parameter'                                "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Results Parameter'                                "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Results Parameter'                                "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.
  APPEND 'Results Parameter'                                "#EC NOTEXT
  TO LT_VALID_HEADER_NAMES.

  DO.
    LV_INDEX = SY-INDEX.
    ASSIGN COMPONENT SY-INDEX
    OF STRUCTURE <LS_EXCEL_SCI_HANA> TO <LV_COMP>.

    IF SY-SUBRC NE 0.
      EXIT.
    ENDIF.

    READ TABLE LT_VALID_HEADER_NAMES INDEX LV_INDEX
    ASSIGNING <LV_VALID_HEADER>.

    IF SY-SUBRC NE 0.

      CONCATENATE
      'SCI HANA Excel for'                                  "#EC NOTEXT
      IV_VARIANT
      'is not valid! Excel have more columns then expected ' "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.

      PERFORM RAISE_ERROR USING LV_MESSAGE.

      LEAVE TO SCREEN SY-DYNNR.
      EXIT.

    ENDIF.

    IF <LV_COMP> NS <LV_VALID_HEADER>.
      LV_MESSAGE = LV_INDEX.

      CONCATENATE
      'SCI HANA Excel for'                                  "#EC NOTEXT
      IV_VARIANT
      'is not valid! Column number'                         "#EC NOTEXT
      LV_MESSAGE
      'should be'
      <LV_VALID_HEADER>
      INTO LV_MESSAGE SEPARATED BY SPACE.

      PERFORM RAISE_ERROR USING LV_MESSAGE.

      LEAVE TO SCREEN SY-DYNNR.

      EXIT.
    ENDIF.

  ENDDO.

ENDFORM.                    "validate_sci_hana_excel


*---------------------------------------------------------------------*
*       FORM set_sci_hana_tmp_filename                                *
*---------------------------------------------------------------------*
FORM SET_TMP_FILENAME
  USING
    IV_NAME
    IV_PATH TYPE STRING
  CHANGING
    CV_FULLNAME TYPE STRING.

* Set temp filename
  CONCATENATE 'temp' '_' IV_NAME '_'                        "#EC NOTEXT
  SY-DATUM '_' SY-UZEIT '.txt'                              "#EC NOTEXT
   INTO CV_FULLNAME.

  CONCATENATE IV_PATH CV_FULLNAME INTO CV_FULLNAME.

ENDFORM.                    "SET_TEMP_FILENAMES

*&---------------------------------------------------------------------*
*&      Form  GET_AUTO_UPLOAD_HTTP_CLIENT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->UV_URL          text
*      -->CO_HTTP_CLIENT  text
*----------------------------------------------------------------------*
FORM GET_AUTO_UPLOAD_HTTP_CLIENT USING UV_URL TYPE STRING
                                 CHANGING CO_HTTP_CLIENT TYPE REF TO
                                 IF_HTTP_CLIENT.

  DATA: LV_ERROR_MSG      TYPE STRING,
        LV_SUBRC          TYPE STRING,
        LV_MESSAGE        TYPE STRING,
        LV_PROXY_HOST     TYPE STRING,
        LV_PROXY_PORT     TYPE STRING,
        LV_PROXY_USER     TYPE STRING,
        LV_PROXY_PASSWORD TYPE STRING.

  LV_PROXY_HOST = P_PRXHST.
  LV_PROXY_PORT = P_PRXPRT.
  LV_PROXY_USER = P_PRXUSR.
  LV_PROXY_PASSWORD = P_PRXPSS.

  CONCATENATE 'Creating HTTP connection to URL'             "#EC NOTEXT
              UV_URL
              ', PROXY HOST:'
              LV_PROXY_HOST
              ', PROXY PORT:'
              LV_PROXY_PORT
              ', PROXY USER:'
              LV_PROXY_USER
              INTO LV_MESSAGE SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.

  CL_HTTP_CLIENT=>CREATE_BY_URL(
    EXPORTING
      URL                = UV_URL
      PROXY_HOST         = LV_PROXY_HOST
      PROXY_SERVICE      = LV_PROXY_PORT
      SSL_ID             = 'ANONYM'
    IMPORTING
      CLIENT             = CO_HTTP_CLIENT
    EXCEPTIONS
      ARGUMENT_NOT_FOUND = 1
      PLUGIN_NOT_ACTIVE  = 2
      INTERNAL_ERROR     = 3
      OTHERS             = 4 ).

  IF SY-SUBRC <> '0'.
    LV_SUBRC = SY-SUBRC.
    CONCATENATE 'Upload request create faild SUBRC -'       "#EC NOTEXT
    LV_SUBRC
      INTO LV_ERROR_MSG.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
    RETURN.
  ENDIF.

  CO_HTTP_CLIENT->PROPERTYTYPE_LOGON_POPUP = CO_HTTP_CLIENT->CO_DISABLED
  .

  IF ( LV_PROXY_USER IS NOT INITIAL AND LV_PROXY_PASSWORD IS NOT INITIAL
  ).

    CO_HTTP_CLIENT->AUTHENTICATE(
      EXPORTING
        PROXY_AUTHENTICATION = 'X'
        USERNAME             = LV_PROXY_USER
        PASSWORD             = LV_PROXY_PASSWORD ).

  ENDIF.

ENDFORM.                    "GET_AUTO_UPLOAD_HTTP_CLIENT

*&---------------------------------------------------------------------*
*& Login
*&---------------------------------------------------------------------*
FORM LOGIN_VIA_API CHANGING CV_RESPONSE TYPE STRING
                            CV_SUCCESS  TYPE FLAG.

  DATA: LO_HTTP_CLIENT TYPE REF TO IF_HTTP_CLIENT.

  DATA: LV_URL  TYPE STRING,
        LV_USER TYPE STRING,
        LV_PASS TYPE STRING.

  DATA: LV_RESULT TYPE STRING,
        LV_LENGTH TYPE I.

  DATA: LV_SUBRC  TYPE STRING,
        SUBRC     TYPE SYSUBRC,
        ERRORTEXT TYPE STRING.

* Build URL
  LV_URL = C_REST_SERVICE_ADDRESS.
  REPLACE 'http://' IN LV_URL WITH 'https://'.

  IF C_APIPAS EQ ABAP_TRUE.
    CONCATENATE LV_URL '/api/login' INTO LV_URL.            "#EC NOTEXT
  ELSEIF C_APITOK EQ ABAP_TRUE.
    CONCATENATE LV_URL '/api/accesstoken' INTO LV_URL.      "#EC NOTEXT
  ENDIF.


  PERFORM GET_AUTO_UPLOAD_HTTP_CLIENT
              USING
                 LV_URL
              CHANGING
                 LO_HTTP_CLIENT.

  CONCATENATE 'Performing Login via API, user'              "#EC NOTEXT
              P_USER
              INTO ERRORTEXT SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING ERRORTEXT ABAP_TRUE.

* Add content type to header
  LO_HTTP_CLIENT->REQUEST->SET_HEADER_FIELD(
    EXPORTING
      NAME = 'Content-Type'                                 "#EC NOTEXT
      VALUE = 'application/x-www-form-urlencoded').         "#EC NOTEXT

* Add username to header
  LV_USER = P_USER.
  LO_HTTP_CLIENT->REQUEST->SET_FORM_FIELD(
    EXPORTING
      NAME = 'username'                                     "#EC NOTEXT
      VALUE = LV_USER ).

* Add password to header
  IF C_APIPAS EQ ABAP_TRUE.

    LV_PASS = P_PASS.
    LO_HTTP_CLIENT->REQUEST->SET_FORM_FIELD(
      EXPORTING
        NAME = 'password'                                   "#EC NOTEXT
        VALUE = LV_PASS ).

  ELSEIF C_APITOK EQ ABAP_TRUE.

    LV_PASS = P_TOKEN.
    LO_HTTP_CLIENT->REQUEST->SET_FORM_FIELD(
      EXPORTING
        NAME = 'token'                                      "#EC NOTEXT
        VALUE = LV_PASS ).

  ENDIF.

* Set request method to POST
  LO_HTTP_CLIENT->REQUEST->SET_METHOD(
    EXPORTING
      METHOD = IF_HTTP_REQUEST=>CO_REQUEST_METHOD_POST ).

  CALL METHOD LO_HTTP_CLIENT->SEND(
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      HTTP_INVALID_TIMEOUT       = 4
      OTHERS                     = 5 ).

  IF SY-SUBRC <> 0.
    CALL METHOD LO_HTTP_CLIENT->GET_LAST_ERROR
      IMPORTING
        CODE    = SUBRC
        MESSAGE = ERRORTEXT.
    LV_SUBRC = SUBRC.
    CONCATENATE 'Login request send failed SUBRC -' LV_SUBRC "#EC NOTEXT
      'MESSAGE -' ERRORTEXT INTO CV_RESPONSE SEPARATED BY SPACE.
    RETURN.
  ENDIF.

  CALL METHOD LO_HTTP_CLIENT->RECEIVE
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      OTHERS                     = 4.

  IF SY-SUBRC <> 0.
    CALL METHOD LO_HTTP_CLIENT->GET_LAST_ERROR
      IMPORTING
        CODE    = SUBRC
        MESSAGE = ERRORTEXT.
    LV_SUBRC = SUBRC.
    CONCATENATE 'Login request receive failed SUBRC -'      "#EC NOTEXT
    LV_SUBRC
      'MESSAGE -' ERRORTEXT INTO CV_RESPONSE SEPARATED BY SPACE.
    RETURN.
  ELSE.
    LV_RESULT = LO_HTTP_CLIENT->RESPONSE->GET_CDATA( ).
    IF LV_RESULT CP '*token*'.
      CV_RESPONSE = LV_RESULT+10.
      LV_LENGTH = STRLEN( CV_RESPONSE ).
      LV_LENGTH = LV_LENGTH - 2.
      CV_RESPONSE = CV_RESPONSE(LV_LENGTH).
      CV_SUCCESS = 'X'.
    ELSE.
      CV_RESPONSE = LV_RESULT.
    ENDIF.
  ENDIF.

ENDFORM.                    "LOGIN_VIA_API
*&---------------------------------------------------------------------*
*& Test Login
*&---------------------------------------------------------------------*
FORM TEST_LOGIN.

  DATA: LV_RESPONSE TYPE STRING,
        LV_SUCCESS  TYPE FLAG.

  PERFORM LOGIN_VIA_API CHANGING LV_RESPONSE LV_SUCCESS.

  IF LV_SUCCESS IS INITIAL.
    PERFORM RAISE_ERROR USING LV_RESPONSE.
  ELSE.
    PERFORM RAISE_MESSAGE USING 'Login Successful'.         "#EC NOTEXT
  ENDIF.

ENDFORM.                    "TEST_LOGIN
*&---------------------------------------------------------------------*
*& Test GZIP
*&---------------------------------------------------------------------*
FORM TEST_COMPRESS USING IV_DISPLAY_MSG TYPE FLAG
                   CHANGING CV_SUCCESS TYPE FLAG.

  DATA : LS_SXPGCOSTAB TYPE SXPGCOSTAB,
         LV_STATUS     LIKE EXTCMDEXEX-STATUS,
         LV_SUBRC      TYPE STRING,
         LV_MSG        TYPE STRING.

  SELECT SINGLE *
    FROM SXPGCOSTAB
    INTO LS_SXPGCOSTAB
    WHERE NAME = 'ZZ_COMPRESS_ETL'.

  IF SY-SUBRC <> 0 AND NOT IV_DISPLAY_MSG IS INITIAL.
    IF C_UPLOAD EQ ABAP_TRUE.
      PERFORM RAISE_ERROR
      USING 'Command ZZ_COMPRESS_ETL doesn`t exist'.        "#EC NOTEXT
      LEAVE TO SCREEN SY-DYNNR.
    ELSE.
      PERFORM DISPLAY_ERROR_MESSAGE
      USING 'Command ZZ_COMPRESS_ETL doesn`t exist'.        "#EC NOTEXT
      WRITE ICON_MESSAGE_ERROR AS ICON TO ICON_CMP.
      LEAVE TO SCREEN SY-DYNNR.
    ENDIF.
  ELSE.
    CALL FUNCTION 'SXPG_COMMAND_EXECUTE'
      EXPORTING
        COMMANDNAME                   = 'ZZ_COMPRESS_ETL'
        ADDITIONAL_PARAMETERS         = '-V'
      IMPORTING
        STATUS                        = LV_STATUS
      EXCEPTIONS
        NO_PERMISSION                 = 1
        COMMAND_NOT_FOUND             = 2
        PARAMETERS_TOO_LONG           = 3
        SECURITY_RISK                 = 4
        WRONG_CHECK_CALL_INTERFACE    = 5
        PROGRAM_START_ERROR           = 6
        PROGRAM_TERMINATION_ERROR     = 7
        X_ERROR                       = 8
        PARAMETER_EXPECTED            = 9
        TOO_MANY_PARAMETERS           = 10
        ILLEGAL_COMMAND               = 11
        WRONG_ASYNCHRONOUS_PARAMETERS = 12
        CANT_ENQ_TBTCO_ENTRY          = 13
        JOBCOUNT_GENERATION_ERROR     = 14
        OTHERS                        = 15.

    IF SY-SUBRC IS INITIAL AND LV_STATUS = 'O'.
      CV_SUCCESS = 'X'.
      WRITE ICON_CHECKED AS ICON TO ICON_CMP.
      IF NOT IV_DISPLAY_MSG IS INITIAL.
        PERFORM RAISE_MESSAGE
        USING 'ZZ_COMPRESS_ETL command defined'.            "#EC NOTEXT
      ENDIF.
    ELSEIF C_UPLOAD EQ ABAP_TRUE.
      IF NOT IV_DISPLAY_MSG IS INITIAL.
        LV_SUBRC = SY-SUBRC.
        CONCATENATE 'Error executing ZZ_COMPRESS_ETL'       "#EC NOTEXT
                  'command. SUBRC-'                         "#EC NOTEXT
                  LV_SUBRC 'STATUS-'
                  LV_STATUS INTO LV_MSG SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_MSG.
      ENDIF.
    ELSE.
      CONCATENATE 'Error executing ZZ_COMPRESS_ETL'         "#EC NOTEXT
                  'command. SUBRC-'                         "#EC NOTEXT
                  LV_SUBRC 'STATUS-'
                  LV_STATUS INTO LV_MSG SEPARATED BY SPACE.
      PERFORM DISPLAY_ERROR_MESSAGE
      USING LV_MSG.                                         "#EC NOTEXT
      WRITE ICON_MESSAGE_ERROR AS ICON TO ICON_CMP.
      LEAVE TO SCREEN SY-DYNNR.
    ENDIF.
  ENDIF.

ENDFORM.                    "TEST_COMPRESS
*&---------------------------------------------------------------------*
*& Compress and Upload
*&---------------------------------------------------------------------*
FORM COMPRESS_AND_UPLOAD CHANGING CV_TICKET TYPE STRING.

  DATA: LV_TOKEN            TYPE STRING,
        LV_LOGIN_SUCCESS    TYPE FLAG,
        LV_COMPRESS_SUCCESS TYPE FLAG,
        LV_GZIP_NAME        TYPE STRING,
        LV_ERROR_MSG        TYPE STRING,
        LV_MESSAGE          TYPE STRING.

  CHECK NOT ENABLE_AUTO_UPLOAD IS INITIAL
    AND NOT C_UPLOAD IS INITIAL.

* Compress file
  PERFORM COMPRESS_FILE USING P_BACK
                     CHANGING LV_GZIP_NAME LV_COMPRESS_SUCCESS.
  CHECK NOT LV_COMPRESS_SUCCESS IS INITIAL.

* Login and recieve token
  PERFORM LOGIN_VIA_API CHANGING LV_TOKEN LV_LOGIN_SUCCESS.

  IF LV_LOGIN_SUCCESS IS INITIAL.
    CONCATENATE 'Error in login -' LV_TOKEN                 "#EC NOTEXT
    INTO LV_ERROR_MSG
      SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
  ELSE.
    PERFORM PREPARE_DATA_AND_UPLOAD USING LV_TOKEN LV_GZIP_NAME
                                 CHANGING CV_TICKET.
    IF NOT CV_TICKET IS INITIAL.
      PERFORM RAISE_MESSAGE
      USING 'File uploaded successfully to Panaya'          "#EC NOTEXT
      .
      PERFORM RAISE_MESSAGE USING CV_TICKET.
    ENDIF.
  ENDIF.

ENDFORM.                    "COMPRESS_AND_UPLOAD

FORM COMPRESS_WITHOUT_UPLOAD.

  CHECK COMPRESS_RESULT_FILE IS NOT INITIAL AND
    C_UPLOAD IS INITIAL AND
    R_FORE IS INITIAL.

  DATA: LV_COMPRESS_SUCCESS TYPE FLAG,
        LV_GZIP_NAME        TYPE STRING,
        LV_TEMP_MESSAGE     TYPE STRING,
        LV_ETL_RESULT       TYPE STRING.

  LV_ETL_RESULT = P_BACK.

  IF PSRV_SUS IS NOT INITIAL.

    PERFORM ARCHIVE_ETL_FILES USING LV_ETL_RESULT
                                    PSRV_SUS
                              CHANGING LV_ETL_RESULT
                                       LV_COMPRESS_SUCCESS.

    IF LV_COMPRESS_SUCCESS IS INITIAL.

      CONCATENATE '!!!Could not Archive' P_BACK             "#EC NOTEXT
      INTO LV_TEMP_MESSAGE SEPARATED BY SPACE.

      PERFORM RAISE_MESSAGE USING LV_TEMP_MESSAGE.

      LV_TEMP_MESSAGE =
      'Check ZZ_COMPRESS_ETL Configuration in SM49'.        "#EC NOTEXT

      PERFORM RAISE_MESSAGE USING LV_TEMP_MESSAGE.

    ENDIF.

  ENDIF.

* compress file
  PERFORM COMPRESS_FILE USING LV_ETL_RESULT
                     CHANGING LV_GZIP_NAME LV_COMPRESS_SUCCESS.

  IF LV_COMPRESS_SUCCESS IS INITIAL.

    CONCATENATE '!!!Could not compress' P_BACK              "#EC NOTEXT
    INTO LV_TEMP_MESSAGE SEPARATED BY SPACE.

    PERFORM RAISE_MESSAGE USING LV_TEMP_MESSAGE.

    LV_TEMP_MESSAGE =
    'Check ZZ_COMPRESS_ETL Configuration in SM49'.          "#EC NOTEXT

    PERFORM RAISE_MESSAGE USING LV_TEMP_MESSAGE.

  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*& Archive ETL files using Tar
*&---------------------------------------------------------------------*
FORM ARCHIVE_ETL_FILES USING IV_FILE_NAME
                             IV_SUSG_NAME
                       CHANGING CV_TAR_NAME TYPE STRING
                                CV_SUCCESS TYPE FLAG.

  DATA: LV_PARAMS     LIKE SXPGCOLIST-PARAMETERS,
        STATUS        LIKE EXTCMDEXEX-STATUS,
        EXIT_CODE     LIKE EXTCMDEXEX-EXITCODE,
        LV_EXIT_CODE  TYPE STRING,
        EXEC_PROTOCOL TYPE BTCXPM OCCURS 0,
        LV_SUBRC      TYPE STRING,
        LV_ERROR_MSG  TYPE STRING.

  DATA: TAR_FILE TYPE STRING.

  CONCATENATE IV_FILE_NAME '.tar' INTO TAR_FILE.

  IF EXTRACT_SUSG_DATA = ABAP_FALSE.
    CONCATENATE TAR_FILE IV_FILE_NAME INTO LV_PARAMS
    SEPARATED BY SPACE.
  ELSE.
    CONCATENATE TAR_FILE IV_FILE_NAME IV_SUSG_NAME INTO LV_PARAMS
    SEPARATED BY SPACE.
  ENDIF.

* Execute the zipping command
  CALL FUNCTION 'SXPG_COMMAND_EXECUTE'
    EXPORTING
      COMMANDNAME                   = 'ZZ_ARCHIVE_ETL'
      ADDITIONAL_PARAMETERS         = LV_PARAMS
    IMPORTING
      STATUS                        = STATUS
      EXITCODE                      = EXIT_CODE
    TABLES
      EXEC_PROTOCOL                 = EXEC_PROTOCOL
    EXCEPTIONS
      NO_PERMISSION                 = 1
      COMMAND_NOT_FOUND             = 2
      PARAMETERS_TOO_LONG           = 3
      SECURITY_RISK                 = 4
      WRONG_CHECK_CALL_INTERFACE    = 5
      PROGRAM_START_ERROR           = 6
      PROGRAM_TERMINATION_ERROR     = 7
      X_ERROR                       = 8
      PARAMETER_EXPECTED            = 9
      TOO_MANY_PARAMETERS           = 10
      ILLEGAL_COMMAND               = 11
      WRONG_ASYNCHRONOUS_PARAMETERS = 12
      CANT_ENQ_TBTCO_ENTRY          = 13
      JOBCOUNT_GENERATION_ERROR     = 14
      OTHERS                        = 15.

  IF SY-SUBRC IS INITIAL AND STATUS = 'O'.
    CONCATENATE IV_FILE_NAME '.tar' INTO CV_TAR_NAME.
    CV_SUCCESS = 'X'.
  ELSEIF C_UPLOAD = ABAP_TRUE.
    LV_SUBRC = SY-SUBRC.
    LV_EXIT_CODE = EXIT_CODE.
    CONCATENATE 'Error in compress. subrc -'                "#EC NOTEXT
    LV_SUBRC ', status -'                                   "#EC NOTEXT
    STATUS
      ', exit code -' LV_EXIT_CODE                          "#EC NOTEXT
      INTO LV_ERROR_MSG SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*& Compress ETL file using GZIP
*&---------------------------------------------------------------------*
FORM COMPRESS_FILE USING IV_FILE_NAME
                CHANGING CV_GZIP_NAME TYPE STRING
                         CV_SUCCESS TYPE FLAG.

  DATA: LV_PARAMS     LIKE SXPGCOLIST-PARAMETERS,
        STATUS        LIKE EXTCMDEXEX-STATUS,
        EXIT_CODE     LIKE EXTCMDEXEX-EXITCODE,
        LV_EXIT_CODE  TYPE STRING,
        EXEC_PROTOCOL TYPE BTCXPM OCCURS 0,
        LV_SUBRC      TYPE STRING,
        LV_ERROR_MSG  TYPE STRING.

  LV_PARAMS = IV_FILE_NAME.

* Execute the zipping command
  CALL FUNCTION 'SXPG_COMMAND_EXECUTE'
    EXPORTING
      COMMANDNAME                   = 'ZZ_COMPRESS_ETL'
      ADDITIONAL_PARAMETERS         = LV_PARAMS
    IMPORTING
      STATUS                        = STATUS
      EXITCODE                      = EXIT_CODE
    TABLES
      EXEC_PROTOCOL                 = EXEC_PROTOCOL
    EXCEPTIONS
      NO_PERMISSION                 = 1
      COMMAND_NOT_FOUND             = 2
      PARAMETERS_TOO_LONG           = 3
      SECURITY_RISK                 = 4
      WRONG_CHECK_CALL_INTERFACE    = 5
      PROGRAM_START_ERROR           = 6
      PROGRAM_TERMINATION_ERROR     = 7
      X_ERROR                       = 8
      PARAMETER_EXPECTED            = 9
      TOO_MANY_PARAMETERS           = 10
      ILLEGAL_COMMAND               = 11
      WRONG_ASYNCHRONOUS_PARAMETERS = 12
      CANT_ENQ_TBTCO_ENTRY          = 13
      JOBCOUNT_GENERATION_ERROR     = 14
      OTHERS                        = 15.

  IF SY-SUBRC IS INITIAL AND STATUS = 'O'.
    CONCATENATE IV_FILE_NAME '.gz' INTO CV_GZIP_NAME.
    CV_SUCCESS = 'X'.
  ELSEIF C_UPLOAD = ABAP_TRUE.
    LV_SUBRC = SY-SUBRC.
    LV_EXIT_CODE = EXIT_CODE.
    CONCATENATE 'Error in compress. subrc -'                "#EC NOTEXT
    LV_SUBRC ', status -'                                   "#EC NOTEXT
    STATUS
      ', exit code -' LV_EXIT_CODE                          "#EC NOTEXT
      INTO LV_ERROR_MSG SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
  ENDIF.

ENDFORM.                    "COMPRESS_FILE
*&---------------------------------------------------------------------*
*& Upload ETL file
*&---------------------------------------------------------------------*
FORM PREPARE_DATA_AND_UPLOAD USING IV_TOKEN TYPE STRING
                               IV_GZIP_NAME TYPE STRING
                             CHANGING CV_TICKET TYPE STRING.

  DATA: LV_DATA_BIN TYPE XSTRING,
        LV_DATA_LEN TYPE I.

  PERFORM GET_GZIP_DATA USING IV_GZIP_NAME
                     CHANGING LV_DATA_BIN LV_DATA_LEN.
  CHECK LV_DATA_LEN GT 0.

  PERFORM UPLOAD_VIA_API USING IV_TOKEN
                               IV_GZIP_NAME
                               LV_DATA_BIN
                               LV_DATA_LEN
                      CHANGING CV_TICKET.

ENDFORM.                    "PREPARE_DATA_AND_UPLOAD
*&---------------------------------------------------------------------*
*& Compress ETL file
*&---------------------------------------------------------------------*
FORM GET_GZIP_DATA USING IV_FILE_NAME TYPE STRING
                CHANGING CV_DATA_BIN TYPE XSTRING
                         CV_DATA_LEN TYPE I.
  DATA: LV_ERROR TYPE STRING,
        LV_SUBRC TYPE STRING.

  IF NOT IV_FILE_NAME IS INITIAL.
    OPEN DATASET IV_FILE_NAME FOR INPUT IN BINARY MODE MESSAGE LV_ERROR.

    IF SY-SUBRC = 0.
      READ DATASET IV_FILE_NAME INTO CV_DATA_BIN.
      CV_DATA_LEN = XSTRLEN( CV_DATA_BIN ).
      CLOSE DATASET IV_FILE_NAME.
    ELSE.
      LV_SUBRC = SY-SUBRC.
      CONCATENATE 'Error opening compressed file. subrc-'   "#EC NOTEXT
       LV_SUBRC
        ', error -' LV_ERROR                                "#EC NOTEXT
        INTO LV_ERROR SEPARATED BY SPACE.
      PERFORM RAISE_ERROR USING LV_ERROR.
    ENDIF.
  ENDIF.

ENDFORM.                    "GET_GZIP_DATA
*&---------------------------------------------------------------------*
*& Upload ETL file
*&---------------------------------------------------------------------*
FORM UPLOAD_VIA_API USING IV_TOKEN TYPE STRING
                      IV_FILE_NAME TYPE STRING
                      IV_DATA TYPE XSTRING
                      IV_DATA_LEN TYPE I
                    CHANGING CV_TICKET TYPE STRING.

  DATA: LO_HTTP_CLIENT         TYPE REF TO IF_HTTP_CLIENT,
        LO_PART                TYPE REF TO IF_HTTP_ENTITY,
        LV_RESPONSE            TYPE STRING,
        LV_CONTENT_DISPOSITION TYPE STRING,
        LV_URL                 TYPE STRING.

  DATA: SUBRC               TYPE SYSUBRC,
        ERRORTEXT           TYPE STRING,
        LV_SUBRC            TYPE STRING,
        LV_ADDITIONAL_SUBRC TYPE STRING,
        LV_ERROR_MSG        TYPE STRING.

  LV_URL = C_REST_SERVICE_ADDRESS.
  REPLACE 'http://' IN LV_URL WITH 'https://'.
  CONCATENATE LV_URL '/api/accounts/'                       "#EC NOTEXT
  PROD_ACCOUNT_ID '/etl/upload'                             "#EC NOTEXT
    INTO LV_URL.

  PERFORM GET_AUTO_UPLOAD_HTTP_CLIENT
              USING
                 LV_URL
              CHANGING
                 LO_HTTP_CLIENT.

  CONCATENATE 'Uploading ETL to URL'                        "#EC NOTEXT
              LV_URL
              INTO LV_ERROR_MSG SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING LV_ERROR_MSG ABAP_TRUE.

* Set request method to POST
  LO_HTTP_CLIENT->REQUEST->SET_METHOD(
    EXPORTING
      METHOD = IF_HTTP_REQUEST=>CO_REQUEST_METHOD_POST ).

* Set content type to multipart/*
  LO_HTTP_CLIENT->REQUEST->SET_HEADER_FIELD(
    EXPORTING
      NAME = 'Content-Type'                                 "#EC NOTEXT
      VALUE = 'multipart/*' ).                              "#EC NOTEXT

* Add token to header
  LO_HTTP_CLIENT->REQUEST->SET_HEADER_FIELD(
    EXPORTING
      NAME = 'X-Auth-Token'                                 "#EC NOTEXT
      VALUE = IV_TOKEN ).

* Add file the multipart
  LO_PART = LO_HTTP_CLIENT->REQUEST->IF_HTTP_ENTITY~ADD_MULTIPART( ).

  CONCATENATE 'form-data; name="extractionFile"; filename="' "#EC NOTEXT
    IV_FILE_NAME '"' INTO LV_CONTENT_DISPOSITION.

  LO_PART->SET_HEADER_FIELD(
    EXPORTING
      NAME = 'Content-Disposition'                          "#EC NOTEXT
      VALUE = LV_CONTENT_DISPOSITION ).

  LO_PART->SET_DATA(
    EXPORTING
      DATA   = IV_DATA
      OFFSET = 0
      LENGTH = IV_DATA_LEN ).

  CALL METHOD LO_HTTP_CLIENT->SEND(
    EXPORTING
      TIMEOUT                    = 90000000
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      HTTP_INVALID_TIMEOUT       = 4
      OTHERS                     = 5 ).

  IF SY-SUBRC <> 0.
    LV_SUBRC = SY-SUBRC.
    CALL METHOD LO_HTTP_CLIENT->GET_LAST_ERROR
      IMPORTING
        CODE    = SUBRC
        MESSAGE = ERRORTEXT.

    LV_ADDITIONAL_SUBRC = SUBRC.
    CONCATENATE 'Upload request send faild SUBRC -' LV_SUBRC "#EC NOTEXT
      'last error -' LV_ADDITIONAL_SUBRC                    "#EC NOTEXT
      ERRORTEXT INTO LV_ERROR_MSG
      SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
    RETURN.
  ENDIF.

  CALL METHOD LO_HTTP_CLIENT->RECEIVE
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      OTHERS                     = 4.

  IF SY-SUBRC <> 0.
    CALL METHOD LO_HTTP_CLIENT->GET_LAST_ERROR
      IMPORTING
        CODE    = SUBRC
        MESSAGE = ERRORTEXT.

    LV_ADDITIONAL_SUBRC = SUBRC.
    CONCATENATE 'Upload request receive faild SUBRC -'      "#EC NOTEXT
    LV_SUBRC
      'last error -' LV_ADDITIONAL_SUBRC                    "#EC NOTEXT
      ERRORTEXT INTO LV_ERROR_MSG
      SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING LV_ERROR_MSG.
    RETURN.
  ELSE.
    LV_RESPONSE = LO_HTTP_CLIENT->RESPONSE->GET_CDATA( ).
    IF LV_RESPONSE CP '*ticketId*'.
      CV_TICKET = LV_RESPONSE.
    ELSE.
      PERFORM RAISE_ERROR USING LV_RESPONSE.
    ENDIF.
  ENDIF.

ENDFORM.                    "UPLOAD_VIA_API

*&---------------------------------------------------------------------*
*&      Form  GET_SI_VERSION_AND_NOTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_SI_VERSION_AND_NOTES .

  TYPES:
    BEGIN OF TY_NOTE_STAT_STR,
      NUMBER                 TYPE NUMC10,
      ACTION                 TYPE STRING,
      TARGET_STACK           TYPE CHAR20,
      CURRENT_VERSION        TYPE NUMC4,
      CURRENT_VERSION_STR    TYPE STRING,
      IMPLEMENTED            TYPE FLAG,
      STATUS                 TYPE CHAR1,
      MIN_REQUIRED_VER       TYPE NUMC4,
      MIN_REQUIRED_VER_STR   TYPE STRING,
      MIN_VER_IMPLMENTED     TYPE CHAR1,
      LATEST_VER_IMPLEMENTED TYPE CHAR1,
    END OF TY_NOTE_STAT_STR .
  TYPES:
    TY_NOTE_STAT_TAB TYPE TABLE OF TY_NOTE_STAT_STR .

  DATA: LS_NOTE_STATUS TYPE TY_NOTE_STAT_STR.
  DATA: LV_NOTE TYPE CWBNTNUMM.

  DATA: LC_CLASS TYPE SEOCLSNAME VALUE '/SDF/CL_RC_CHK_UTILITY'.
  DATA: LS_SEOCLASS TYPE  SEOCLASS .

  DATA: LT_NOTES TYPE TABLE OF CWBNTNUMM.

  DATA: LV_TARGET_STACK(20) TYPE C.

  FIELD-SYMBOLS: <FS_MSG_FIELD> LIKE C_CUR_NT.

  CHECK EXTRACT_SI_S4_CHECK = ABAP_TRUE.

  LV_TARGET_STACK = C_TARGET_S4HANA_VERSION.

  SELECT SINGLE *
    FROM SEOCLASS
    INTO LS_SEOCLASS
    WHERE CLSNAME = LC_CLASS.


  IF LV_TARGET_STACK IS INITIAL OR LV_TARGET_STACK CS '&'.
    G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_FALSE.

    CONCATENATE '@1A@'
    'The Target Stack Version is not set.' INTO             "#EC NOTEXT
    C_CUR_NT.
    C_TCI_NT = '      Cannot Run the Extract'.              "#EC NOTEXT

    EXIT.
  ENDIF.

  IF SY-SUBRC <> 0.

    G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_FALSE.
    CONCATENATE '@1A@'
    'System is missing the necessary '                      "#EC NOTEXT
    'Notes to run the SI Checks.'                           "#EC NOTEXT
    INTO C_CUR_NT.
    CONCATENATE '  Please Implement the following notes:'   "#EC NOTEXT
    C_FRAMEWORK_NOTE ',' C_CHK_CLAS_TCI_NOTE
    INTO C_TCI_NT.

    EXIT.

  ENDIF.


  APPEND C_FRAMEWORK_NOTE TO LT_NOTES.
  APPEND C_CHK_CLAS_TCI_NOTE TO LT_NOTES.

  LOOP AT LT_NOTES INTO LV_NOTE.

    IF LV_NOTE EQ C_FRAMEWORK_NOTE.
      ASSIGN C_CUR_NT TO <FS_MSG_FIELD>.
    ELSE.
      ASSIGN C_TCI_NT TO <FS_MSG_FIELD>.
    ENDIF.

    CALL METHOD (LC_CLASS)=>CHECK_NOTE_STATUS
      EXPORTING
        IV_NOTE_NUMBER  = LV_NOTE
        IV_ACTION       = 'RC_SITM_CK'
        IV_TARGET_STACK = LV_TARGET_STACK
      RECEIVING
        RS_NOTE_STATUS  = LS_NOTE_STATUS.

    CASE LS_NOTE_STATUS-LATEST_VER_IMPLEMENTED.
      WHEN 'Y'.
        "Latest version &P1& of SAP Note &P2& is implemented.

        CONCATENATE 'Latest version'                        "#EC NOTEXT
                    LS_NOTE_STATUS-CURRENT_VERSION_STR
                    'of SAP Note'                           "#EC NOTEXT
                    LV_NOTE
                    'is implemented'                        "#EC NOTEXT
                    INTO <FS_MSG_FIELD> SEPARATED BY SPACE.
        CONCATENATE ICON_LED_GREEN <FS_MSG_FIELD> INTO <FS_MSG_FIELD>.

      WHEN 'N'.

        IF LS_NOTE_STATUS-MIN_VER_IMPLMENTED = 'N'.
          IF LS_NOTE_STATUS-IMPLEMENTED = ABAP_TRUE.
            "Required version of SAP Note &P1& is &P2&.
            "Implemented version is &P3&.

            CONCATENATE 'Required version of SAP Note'      "#EC NOTEXT
                    LV_NOTE
                    'is'                                    "#EC NOTEXT
                    LS_NOTE_STATUS-MIN_REQUIRED_VER_STR
                    'Implemented version is'                "#EC NOTEXT
                    LS_NOTE_STATUS-CURRENT_VERSION_STR
                    INTO <FS_MSG_FIELD> SEPARATED BY SPACE.

          ELSE.
            "Minimum required version &P1& of SAP Note &P2& not
            "implemented.

            CONCATENATE 'Minimum required version'          "#EC NOTEXT
                    LS_NOTE_STATUS-MIN_REQUIRED_VER_STR
                    'of SAP Note'                           "#EC NOTEXT
                     LV_NOTE
                    'not implemented.'                      "#EC NOTEXT
                    INTO <FS_MSG_FIELD> SEPARATED BY SPACE.

            G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_FALSE.
            EXIT.
          ENDIF.
          CONCATENATE ICON_LED_RED <FS_MSG_FIELD> INTO <FS_MSG_FIELD>.
        ELSE.
          "Implemented version &P2& of SAP Note &P1& is out-of-date.

          CONCATENATE 'Implemented version'                 "#EC NOTEXT
                      LS_NOTE_STATUS-CURRENT_VERSION_STR
                      'of SAP Note'                         "#EC NOTEXT
                      LV_NOTE
                      'is out-of-date.'                     "#EC NOTEXT
                      INTO <FS_MSG_FIELD> SEPARATED BY SPACE.

          CONCATENATE ICON_LED_YELLOW <FS_MSG_FIELD> INTO
<FS_MSG_FIELD>.
        ENDIF.

      WHEN OTHERS.
        "Implementation status of SAP Note &P1& is unknown.
        CONCATENATE 'Implementation status of SAP Note'     "#EC NOTEXT
              LV_NOTE
              'is unknown'                                  "#EC NOTEXT
              INTO <FS_MSG_FIELD> SEPARATED BY SPACE.
        CONCATENATE ICON_DUMMY <FS_MSG_FIELD> INTO <FS_MSG_FIELD>.

        G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_FALSE.
        EXIT.
    ENDCASE.

  ENDLOOP.

  G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_TRUE.

ENDFORM.                    " GET_SI_VERSION_AND_NOTES
*&---------------------------------------------------------------------*
*&      Form  CHECK_SI_TARGET_STACK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_SI_TARGET_STACK CHANGING ERROR TYPE FLAG.
  DATA: LT_CONV_TARG_STACK TYPE TY_CONV_TARGET_STACK_TAB .
  DATA: LC_SI_CLASS TYPE SEOCLSNAME VALUE '/SDF/CL_RC_CHK_UTILITY'.
  DATA: LV_MESSAGE TYPE STRING.

  CHECK C_TARGET_S4HANA_VERSION IS NOT INITIAL.
  CHECK EXTRACT_SI_S4_CHECK IS NOT INITIAL.

  "Check if SI class exist if not raise error
  SELECT COUNT(*)
    FROM SEOCLASS
    WHERE CLSNAME = LC_SI_CLASS.

  IF SY-SUBRC <> 0.
    LV_MESSAGE = 'SI Catalog is not installed in your local system.'.
    CALL FUNCTION 'POPUP_FOR_INTERACTION'
      EXPORTING
        HEADLINE              = 'Cannot run Extractor'
        TEXT1                 = LV_MESSAGE
        TICON                 = 'E'
        BUTTON_1              = 'OK'.
     ERROR = 'X'.
     EXIT.
  ENDIF.


  "check Target Stack exist in SMDB.
  CALL METHOD (LC_SI_CLASS)=>GET_TARGET_S4_VERSION
    IMPORTING
      ET_VERSION             = LT_CONV_TARG_STACK
    EXCEPTIONS
      SMDB_CONTNET_NOT_FOUND = 1
      ERROR                  = 2
      OTHERS                 = 3 .

  READ TABLE LT_CONV_TARG_STACK TRANSPORTING NO FIELDS
    WITH KEY STACK_NUMBER = C_TARGET_S4HANA_VERSION.

  IF SY-SUBRC <> 0.
    CONCATENATE 'The target version of your SI catalog '
                'does not match the version of your project: '
                 C_TARGET_S4HANA_VERSION_DESC
                'Please download it from SAP SUPPORT PORTAL '
     INTO LV_MESSAGE.

    CALL FUNCTION 'POPUP_FOR_INTERACTION'
       EXPORTING
         HEADLINE      = 'Cannot run Extarctor'
         TEXT1         = 'The target version of your SI catalog '
         TEXT2         = 'does not match the version of your project: '
         TEXT3         = C_TARGET_S4HANA_VERSION_DESC
         TEXT4         = 'Please download it from SAP SUPPORT PORTAL'
         TICON         = 'E'
         BUTTON_1      = 'OK, I will Update'.
     ERROR = 'X'.
     EXIT.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SI_CHECK_DETERMINE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM SI_CHECK_DETERMINE .

  DATA:
      LV_IS_INVISIBLE TYPE FLAG.

  " If S/4 HANA extract not needed
  " or user select execute mode
  " hide the screen elements.
  IF EXTRACT_SI_S4_CHECK = ABAP_FALSE AND
   ( SCREEN-GROUP1            = 'SIC'  OR
     SCREEN-GROUP1            = 'SIR' ).

    LV_IS_INVISIBLE = ABAP_TRUE.

  ELSE.

    " If incapable of extracting SI.
    IF G_IS_CAPABLE_EXTRACT_SI_CHECKS = ABAP_FALSE.

      IF EXTRACT_SI_S4_CHECK = ABAP_TRUE AND
    ( SCREEN-NAME             EQ 'C_CUR_NT' OR
      SCREEN-NAME             EQ 'C_TCI_NT' ).

        LV_IS_INVISIBLE = ABAP_FALSE.

      ENDIF.
    ENDIF.

    IF SI_UPLOAD_EXISTS EQ ABAP_TRUE.

      IF CREUSESI EQ ABAP_TRUE AND
           ( SCREEN-GROUP1 = 'SIR' AND
             SCREEN-NAME NE 'CREUSESI' AND
             SCREEN-NAME NE 'TREUSESI' AND
             SCREEN-NAME NE 'TREUSEWR' ).

        LV_IS_INVISIBLE = ABAP_TRUE.

      ENDIF.

      IF CREUSESI EQ ABAP_FALSE AND
         SCREEN-NAME EQ 'TREUSEWR' .

        LV_IS_INVISIBLE = ABAP_TRUE.
      ENDIF.

    ELSE.

      IF SCREEN-GROUP1 = 'SIC'.
        LV_IS_INVISIBLE = ABAP_TRUE.
      ENDIF.

    ENDIF.

  ENDIF.

  IF LV_IS_INVISIBLE EQ ABAP_TRUE.

    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = 0.
    SCREEN-INVISIBLE = 1.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.

  ENDIF.

ENDFORM.                    "si_check_determine

*&---------------------------------------------------------------------*
*&      Form  ATC_S4_CHECK_DETERMINE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ATC_S4_CHECK_DETERMINE .

  DATA:
      LV_IS_INVISIBLE TYPE FLAG.

  " If SCI Hana extract not needed
  " or user select execute mode
  " hide the screen elements.
  IF EXTRACT_ATC_S4_CHECK = ABAP_FALSE AND
   ( SCREEN-NAME              = 'BS4X' OR
     SCREEN-GROUP1            = 'ATC'  OR
     SCREEN-GROUP1            = 'ATR'  OR
     SCREEN-GROUP1            = 'ATX' ).

    LV_IS_INVISIBLE = ABAP_TRUE.

  ELSEIF EXTRACT_ATC_S4_CHECK = ABAP_TRUE AND
         ( SCREEN-NAME = 'SCI_FD' OR
           SCREEN-NAME = 'TXLS_FD' OR
           SCREEN-NAME = 'PXLS_FD' OR
           SCREEN-NAME = 'SCI_FDV' OR
           SCREEN-NAME = 'TIT_FD' ).

    LV_IS_INVISIBLE = ABAP_TRUE.

  ENDIF.

  IF EXTRACT_ATC_S4_CHECK = ABAP_TRUE.

    IF SCREEN-GROUP1 = 'ATC' OR
       SCREEN-GROUP1 = 'ATX'.

      LV_IS_INVISIBLE = ABAP_TRUE.

    ENDIF.
  ENDIF.

  IF EXTRACT_ATC_S4_CHECK = ABAP_TRUE.
    IF C_ATCRES EQ ABAP_TRUE AND
         SCREEN-GROUP1 = 'ATX'.

      LV_IS_INVISIBLE = ABAP_TRUE.

    ELSEIF C_ATCEXL EQ ABAP_TRUE AND
       SCREEN-GROUP1 = 'ATR'.

      LV_IS_INVISIBLE = ABAP_TRUE.

    ENDIF .
  ENDIF.

  IF SCREEN-GROUP1 = 'HID'.
    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF LV_IS_INVISIBLE EQ ABAP_TRUE.

    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = '0'.
    SCREEN-INVISIBLE = '1'.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.

  ENDIF.

ENDFORM.                    "atc_s4_check_determine

*&---------------------------------------------------------------------*
*&      Form  SUSG_DETERMINE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM SUSG_DETERMINE .

  DATA: LV_IS_INVISIBLE TYPE FLAG.

  IF EXTRACT_SUSG_DATA EQ ABAP_FALSE.
    IF SCREEN-GROUP1 = 'USG'.
      LV_IS_INVISIBLE = ABAP_TRUE.
    ENDIF.
  ELSEIF EXTRACT_SUSG_DATA EQ ABAP_TRUE.
    IF COMPRESS_RESULT_FILE EQ ABAP_FALSE.
      IF SCREEN-GROUP1 = 'USG' AND
        SCREEN-NAME NE 'T_E_SUSG'.
        LV_IS_INVISIBLE = ABAP_TRUE.
      ENDIF.
    ELSEIF COMPRESS_RESULT_FILE EQ ABAP_TRUE.
      IF SCREEN-NAME EQ 'T_E_SUSG'.
        LV_IS_INVISIBLE = ABAP_TRUE.
      ENDIF.
    ENDIF.
  ENDIF.

  IF LV_IS_INVISIBLE EQ ABAP_TRUE.

    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = '0'.
    SCREEN-INVISIBLE = '1'.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.

  ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  CHECK_FILES_UPLOAD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_FILES_UPLOAD CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_STRING TYPE STRING.

  IF EXTRACT_ATC_S4_CHECK EQ ABAP_TRUE AND
     EXTRACT_SCI_HANA_CHECK EQ ABAP_TRUE.
    CHECK R_SCIXLS = ABAP_TRUE.

    IF G_FULLNAME_FUNC_DB_ADD IS INITIAL AND
      EXTRACT_SCI_HANA_CHECK EQ ABAP_TRUE.

      LV_STRING =
      'Please attach DB_FUNCTIONAL_ADDITION Excel File'.    "#EC NOTEXT
      APPEND LV_STRING TO LT_ERROR_MESSAGES.
    ENDIF.

  ELSEIF EXTRACT_ATC_S4_CHECK EQ ABAP_FALSE AND
         EXTRACT_SCI_HANA_CHECK EQ ABAP_TRUE.

    CHECK R_SCIXLS = ABAP_TRUE.

    IF G_FULLNAME_FUNC_DB IS INITIAL.

      LV_STRING = 'Please attach DB_FUNCTIONAL Excel File'. "#EC NOTEXT
      APPEND LV_STRING TO LT_ERROR_MESSAGES.
    ENDIF.
    IF G_FULLNAME_FUNC_DB_ADD IS INITIAL.

      LV_STRING =
      'Please attach DB_FUNCTIONAL_ADDITION Excel File'.    "#EC NOTEXT
      APPEND LV_STRING TO LT_ERROR_MESSAGES.
    ENDIF.

  ENDIF.

  IF EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_TRUE.
    CHECK R_SCIXLS = ABAP_TRUE.
    IF G_FULLNAME_PER_DB IS INITIAL.

      LV_STRING = 'Please attach PERFORMANCE_DB Excel File'. "#EC NOTEXT
      APPEND LV_STRING TO LT_ERROR_MESSAGES.
    ENDIF.
  ENDIF.

ENDFORM.                    "check_files_upload
*&---------------------------------------------------------------------*
*&      Form  CHECK_MANDATORY_FIELDS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM CHECK_MANDATORY_FIELDS  USING P_MARK
                             CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  PERFORM VALIDATE_SM_RFC USING P_MARK
                            CHANGING LT_ERROR_MESSAGES.

  PERFORM VALIDATE_HANA_SCI USING P_MARK
                            CHANGING LT_ERROR_MESSAGES.

  PERFORM VALIDATE_HANA_SIZING USING P_MARK
                            CHANGING LT_ERROR_MESSAGES.

  PERFORM VALIDATE_ATC_VARIANT USING P_MARK
                               CHANGING LT_ERROR_MESSAGES.

  PERFORM VALIDATE_SUSG_FILE USING P_MARK
                             CHANGING LT_ERROR_MESSAGES.

ENDFORM.                    "check_mandatory_fields
*&---------------------------------------------------------------------*
*&      Form  ADD_ATTR_S4HANA_CONV_TO_HEADER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_HEADER_NODE  text
*----------------------------------------------------------------------*
FORM ADD_ATTR_S4HANA_CONV_TO_HEADER  USING
   IO_HEADER_NODE.

  DATA: LT_RESULT_CATALOG TYPE TABLE OF ST_ATC_RESULT.
  DATA: LS_RESULT_CATALOG TYPE ST_ATC_RESULT.
  DATA: LV_SI_RFC_DEST TYPE STRING.
  DATA: LV_ATC_RESULT_CHECK_DESC TYPE CHAR30.
  DATA: LV_ATC_SYSTEM_NAME TYPE CHAR3.

  " Check If the ETL flag to extract SI S/4 Hana checks.
  IF EXTRACT_SI_S4_CHECK = ABAP_TRUE.
    " Set target S/4 HANA Stack Version.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
                                        'TARGET_S4HANA_VERSION'
                                        C_TARGET_S4HANA_VERSION.
    MESSAGE S899(EZ) WITH 'TARGET_S4HANA_VERSION'
    C_TARGET_S4HANA_VERSION.

    IF P_SI_RFC IS NOT INITIAL.
      LV_SI_RFC_DEST = P_SI_RFC.
    ENDIF.

    " Set RFC Destination for SI
    PERFORM ADD_ATTRIBUTE_TO_NODE
      USING IO_HEADER_NODE 'SI_RFC_DEST' P_SI_RFC.

    MESSAGE S899(EZ) WITH 'SI_RFC_DEST' P_SI_RFC.

    IF P_SI_RFC IS NOT INITIAL.
      DATA: LV_SI_RFC TYPE RFCSI.
      CALL FUNCTION 'RFC_SYSTEM_INFO' DESTINATION P_SI_RFC
        IMPORTING
          RFCSI_EXPORT = LV_SI_RFC.

      PERFORM ADD_ATTRIBUTE_TO_NODE
        USING IO_HEADER_NODE 'SI_TARGET_SYSTEM_ID' LV_SI_RFC-RFCSYSID.

      MESSAGE S899(EZ) WITH 'SI_TARGET_SYSTEM_ID' LV_SI_RFC-RFCSYSID.
    ELSE.
      MESSAGE S899(EZ) WITH 'SI_TARGET_SYSTEM_ID' SY-SYSID.
    ENDIF.

    IF CREUSESI = ABAP_TRUE.

      " Set RFC Destination for SI
      PERFORM ADD_ATTRIBUTE_TO_NODE
        USING IO_HEADER_NODE 'REUSE_SI' ABAP_TRUE.

      MESSAGE S899(EZ) WITH 'REUSE_SI' ABAP_TRUE.

    ENDIF.

  ENDIF.

  IF EXTRACT_ATC_S4_CHECK = ABAP_TRUE.
     CALL FUNCTION 'SATC_CI_GET_RESULT_CATALOG' DESTINATION P_AT_RFC
        IMPORTING
          E_RESULT_CATALOG = LT_RESULT_CATALOG
        EXCEPTIONS
          NOT_AUTHORIZED   = 1
          OTHERS           = 2.

    READ TABLE LT_RESULT_CATALOG INTO LS_RESULT_CATALOG
      WITH KEY DISPLAY_ID = P_AT_GID.

    LV_ATC_RESULT_CHECK_DESC = LS_RESULT_CATALOG-TITLE.
    LV_ATC_SYSTEM_NAME = LS_RESULT_CATALOG-TITLE(3).

    " Set RFC Destination for ATC
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
                                        'NW75_RFC_DEST'
                                        P_AT_RFC.

    MESSAGE S899(EZ) WITH 'NW75_RFC_DEST'
    P_AT_RFC.

    " Set RFC Destination for ATC
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
                                        'SYSNAME_ATC_CHECK'
                                        LV_ATC_SYSTEM_NAME.

    MESSAGE S899(EZ) WITH 'SYSNAME_ATC_CHECK'
      LV_ATC_SYSTEM_NAME.

    " Set ATC Execution Date
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
                                        'ATC_EXE_DATE'
                                        P_AT_DAT.

    MESSAGE S899(EZ) WITH 'ATC_EXE_DATE'
      P_AT_DAT.

    "Set ATC result chosen
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
                                        'ATC_READINESS_CHECK'
                                        LV_ATC_RESULT_CHECK_DESC.

    MESSAGE S899(EZ) WITH 'ATC_READINESS_CHECK'
      LV_ATC_RESULT_CHECK_DESC.

  ENDIF.

ENDFORM.                    " ADD_ATTR_S4HANA_CONV_TO_HEADER

*&---------------------------------------------------------------------*
*&      Form  VALIDITY_CHECKS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM VALIDITY_CHECKS CHANGING RV_ERROR TYPE C.

  DATA LV_MESSAGE TYPE STRING.
  DATA: LT_ERROR_MESSAGES TYPE STRINGTAB.

  CHECK USAGEONL = ABAP_FALSE.

  PERFORM CHECK_MANDATORY_FIELDS USING ABAP_FALSE
                                 CHANGING LT_ERROR_MESSAGES.

  PERFORM CHECK_FILES_UPLOAD CHANGING LT_ERROR_MESSAGES.

  IF LT_ERROR_MESSAGES IS NOT INITIAL.
    READ TABLE LT_ERROR_MESSAGES INTO LV_MESSAGE INDEX 1.
    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    RV_ERROR = ABAP_TRUE.
    EXIT.
  ENDIF.

  READ TABLE GT_MESSAGE_TAB INTO LV_MESSAGE INDEX 1.
  IF SY-SUBRC = 0.
    RV_ERROR = ABAP_TRUE.
    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    RV_ERROR = ABAP_TRUE.
    EXIT.
  ENDIF.

ENDFORM.                    " VALIDITY_CHECKS
*&---------------------------------------------------------------------*
*&      Form  CHECK_ATC_RFC_DEST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_AT_RFC  text
*      -->P_ABAP_FALSE  text
*      <--P_LV_FLAG  text
*----------------------------------------------------------------------*
FORM CHECK_ATC_RFC_DEST  USING  IV_RFC_DEST TYPE RFCDEST
                                IV_VALIDATE TYPE FLAG
                       CHANGING EV_VALID    TYPE FLAG.

  DATA: LS_SYSID TYPE SYSYSID,
        LS_SAPRL TYPE SYSAPRL.

  DATA: RFC_MANDT  LIKE RFCDISPLAY-RFCCLIENT,
        RFC_USER   LIKE RFCDISPLAY-RFCUSER,
        LV_MESSAGE TYPE STRING,
        LV_RFC_TYPE TYPE RFCDES-RFCTYPE.

* ATC RFC entered
  CHECK NOT IV_RFC_DEST IS INITIAL.

* Don't try connecting to local
  SELECT SINGLE RFCTYPE  FROM RFCDES
    INTO LV_RFC_TYPE
    WHERE RFCDEST = IV_RFC_DEST.

  IF LV_RFC_TYPE EQ 'I'.
    EV_VALID = ABAP_TRUE.
    RFC_USER = SY-UNAME.
  ELSE.
    PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
                                          IV_VALIDATE
                                    CHANGING EV_VALID
                                             LS_SYSID
                                             LS_SAPRL.

    IF EV_VALID = ABAP_FALSE.
      PERFORM RAISE_ERROR
                  USING
                     'RFC Destination is not valid'.          "#EC NOTEXT

      EXIT.
    ENDIF.

    CALL FUNCTION 'RFC_READ_R3_DESTINATION'
      EXPORTING
        DESTINATION             = IV_RFC_DEST
      IMPORTING
        CLIENT                  = RFC_MANDT
        USER                    = RFC_USER
      EXCEPTIONS
        AUTHORITY_NOT_AVAILABLE = 1
        DESTINATION_NOT_EXIST   = 2
        INFORMATION_FAILURE     = 3
        INTERNAL_FAILURE        = 4
        OTHERS                  = 5.
  ENDIF.

  CALL FUNCTION 'AUTHORITY_CHECK' DESTINATION IV_RFC_DEST
    EXPORTING
      USER                = RFC_USER
      OBJECT              = 'S_Q_ADM'
      FIELD1              = 'ACTVT'
      VALUE1              = '03'
      FIELD2              = 'ATC_OBJTYP'
      VALUE2              = '02'
    EXCEPTIONS
      USER_DONT_EXIST     = 1
      USER_IS_AUTHORIZED  = 2
      USER_NOT_AUTHORIZED = 3
      USER_IS_LOCKED      = 4
      OTHERS              = 5.

  IF NOT ( SY-SUBRC = 0 OR
           SY-SUBRC = 2 ).

    CONCATENATE 'The RFC User:'                             "#EC NOTEXT
    RFC_USER ', missing the authorization'                  "#EC NOTEXT
    'object: S_Q_ADM, Activity: 03, ATC_OBJTYP: 02'         "#EC NOTEXT
    INTO LV_MESSAGE SEPARATED BY SPACE.

    PERFORM RAISE_ERROR USING LV_MESSAGE.
    EXIT.

  ENDIF.

  CALL FUNCTION 'AUTHORITY_CHECK' DESTINATION IV_RFC_DEST
    EXPORTING
      USER                = RFC_USER
      OBJECT              = 'S_DEVELOP'
      FIELD1              = 'ACTVT'
      VALUE1              = '03'
    EXCEPTIONS
      USER_DONT_EXIST     = 1
      USER_IS_AUTHORIZED  = 2
      USER_NOT_AUTHORIZED = 3
      USER_IS_LOCKED      = 4
      OTHERS              = 5.

  IF NOT ( SY-SUBRC = 0 OR
           SY-SUBRC = 2 ).

    CONCATENATE 'The RFC User:'                             "#EC NOTEXT
    RFC_USER ', missing the authorization'                  "#EC NOTEXT
    'object: S_DEVELOP , Activity: 03'                      "#EC NOTEXT
    INTO LV_MESSAGE SEPARATED BY SPACE.

    PERFORM RAISE_ERROR USING LV_MESSAGE.
    EXIT.

  ENDIF.

ENDFORM.                    " CHECK_ATC_RFC_DEST
*&---------------------------------------------------------------------*
*&      Form  CHOOSE_ATC_VARIANT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHOOSE_ATC_VARIANT .

  DATA: LT_RESULT_CATALOG TYPE TABLE OF ST_ATC_RESULT.
  DATA: LT_RESULT_CATALOG_DIS TYPE TABLE OF ST_ATC_RESULT_DIS.
  DATA: LS_RESULT_CATALOG TYPE ST_ATC_RESULT.
  DATA: LS_RESULT_CATALOG_DIS TYPE ST_ATC_RESULT_DIS.
  DATA: LT_RETURN LIKE DDSHRETVAL OCCURS 0 WITH HEADER LINE.
  DATA: LT_DYNPFIELDS TYPE STANDARD TABLE OF DYNPREAD.
  DATA: LS_DYNPFIELDS TYPE DYNPREAD.
  DATA: LV_VAR_GUID TYPE GUID.
  DATA: LV_VAR_NAME TYPE STRING.
  DATA: LV_ATC_DATE TYPE DATE.
  DATA: LV_TIMS TYPE TIMS.

  CLEAR: LT_DYNPFIELDS, LS_DYNPFIELDS.

  IF P_AT_RFC IS INITIAL.

    PERFORM DISPLAY_ERROR_MESSAGE
      USING 'No RFC for Netweaver 750+ was specified'.      "#EC NOTEXT

    EXIT.
  ENDIF.

  CALL FUNCTION 'SATC_CI_GET_RESULT_CATALOG' DESTINATION P_AT_RFC
    IMPORTING
      E_RESULT_CATALOG = LT_RESULT_CATALOG
    EXCEPTIONS
      NOT_AUTHORIZED   = 1
      OTHERS           = 2.

  IF SY-SUBRC = 1.
* Implement suitable error handling here

    PERFORM DISPLAY_ERROR_MESSAGE
      USING 'Not authorized to recieve ATC check Results'.  "#EC NOTEXT

    EXIT.

  ELSEIF SY-SUBRC = 2.

    PERFORM DISPLAY_ERROR_MESSAGE
      USING 'RFC Connection to ATC is not correct'.         "#EC NOTEXT

    EXIT.
  ENDIF.

  DELETE LT_RESULT_CATALOG WHERE CHK_PROFILE_NAME NP
    'S4HANA_READINESS*'.

  LOOP AT LT_RESULT_CATALOG INTO LS_RESULT_CATALOG.
    MOVE-CORRESPONDING LS_RESULT_CATALOG TO LS_RESULT_CATALOG_DIS.
    APPEND LS_RESULT_CATALOG_DIS TO LT_RESULT_CATALOG_DIS.
  ENDLOOP.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      RETFIELD   = 'DISPLAY_ID'   "field of internal table
      VALUE_ORG  = 'S'
    TABLES
      VALUE_TAB  = LT_RESULT_CATALOG_DIS
      RETURN_TAB = LT_RETURN.

  IF LT_RETURN[] IS INITIAL.
    EXIT.
  ENDIF.

  LV_VAR_GUID = LT_RETURN-FIELDVAL.
  READ TABLE LT_RESULT_CATALOG_DIS INTO LS_RESULT_CATALOG_DIS
  WITH KEY DISPLAY_ID = LV_VAR_GUID.
  LV_VAR_NAME = LS_RESULT_CATALOG_DIS-TITLE.

  CONVERT TIME STAMP LS_RESULT_CATALOG_DIS-SCHEDULED_ON_TS
      TIME ZONE SY-ZONLO
  INTO DATE LV_ATC_DATE TIME LV_TIMS.

  CLEAR: LT_DYNPFIELDS, LS_DYNPFIELDS.

  P_AT_GID = LV_VAR_GUID.
  T_AT_TXT = LV_VAR_NAME.
  P_AT_DAT = LV_ATC_DATE.

ENDFORM.                    " CHOOSE_ATC_VARIANT

*&---------------------------------------------------------------------*
*& Form hana_sizing_determine
*&---------------------------------------------------------------------*
FORM HANA_SIZING_DETERMINE.

  IF EXTRACT_HN_SIZING_CHECK = ABAP_FALSE AND SCREEN-GROUP1 = 'HNS'.
    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = '0'.
    SCREEN-INVISIBLE = '1'.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.
  ENDIF.

ENDFORM.                    "hana_sizing_determine

*&---------------------------------------------------------------------*
*& Form get_hana_sizing_result_file
*&---------------------------------------------------------------------*
FORM GET_HANA_SIZING_RESULTS
  USING IV_FILE_NAME TYPE RLGRAP-FILENAME
  CHANGING CV_SERVER_FILE_NAME.

  TYPE-POOLS:TRUXS.

  DATA:
    LT_RESULT           TYPE TABLE OF STRING,
    LV_SERVER_FILE_NAME TYPE STRING,
    LV_ERROR_FOUND      TYPE BOOLEAN VALUE ABAP_FALSE.

* if the user already uploaded file to server, delete it
  IF CV_SERVER_FILE_NAME IS NOT INITIAL.
    DELETE DATASET CV_SERVER_FILE_NAME.
    CLEAR CV_SERVER_FILE_NAME.
  ENDIF.

  PERFORM CHECK_HANA_SIZING_FILE_NAME
    USING IV_FILE_NAME
    CHANGING LV_ERROR_FOUND.
  CHECK LV_ERROR_FOUND IS INITIAL.

  PERFORM GET_HANA_SIZING_FILE_DATA
    USING IV_FILE_NAME
    CHANGING LT_RESULT LV_ERROR_FOUND.
  CHECK LV_ERROR_FOUND IS INITIAL.

  PERFORM UPL_HANA_SIZING_DATA_TO_SERVER
    USING LT_RESULT
    CHANGING LV_SERVER_FILE_NAME LV_ERROR_FOUND.
  CHECK LV_ERROR_FOUND IS INITIAL.

  CV_SERVER_FILE_NAME = LV_SERVER_FILE_NAME.

  MESSAGE S899(EZ) WITH 'File uploaded successfully'.       "#EC NOTEXT
ENDFORM.                    "get_hana_sizing_result_file

*&---------------------------------------------------------------------*
*& Form check_hana_sizing_file_name
*&---------------------------------------------------------------------*
FORM CHECK_HANA_SIZING_FILE_NAME
  USING IV_FILE_NAME TYPE RLGRAP-FILENAME
  CHANGING CV_ERROR_FOUND TYPE BOOLEAN.

  DATA:
    LV_FILE_NAME_LEN  TYPE I,
    LV_FILE_NAME_WA   TYPE PCFILE-PATH,
    LV_FILE_EXTENSION TYPE STRING,
    LV_MESSAGE        TYPE STRING.

  IF IV_FILE_NAME IS INITIAL.
    PERFORM DISPLAY_ERROR_MESSAGE
      USING 'No file was chosen'.                           "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

  LV_FILE_NAME_LEN = STRLEN( IV_FILE_NAME ).
  IF LV_FILE_NAME_LEN > 66.
    PERFORM DISPLAY_ERROR_MESSAGE
USING 'File path + name must not exceed 66 characters'.     "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

*** checking the file extension is txt
  LV_FILE_NAME_WA = IV_FILE_NAME.
  DATA LV_FILE_NAME_STR TYPE STRING.
  LV_FILE_NAME_STR = LV_FILE_NAME_WA.
  TRANSLATE LV_FILE_NAME_STR TO UPPER CASE.
  LV_FILE_NAME_WA = LV_FILE_NAME_STR.

  CALL FUNCTION 'PC_SPLIT_COMPLETE_FILENAME'
    EXPORTING
      COMPLETE_FILENAME = LV_FILE_NAME_WA " The file name to be split
    IMPORTING
      EXTENSION         = LV_FILE_EXTENSION " The file extension
    EXCEPTIONS
      INVALID_DRIVE     = 1
      INVALID_EXTENSION = 2
      INVALID_NAME      = 3
      INVALID_PATH      = 4
      OTHERS            = 5.

  IF SY-SUBRC <> 0.
    CLEAR LV_MESSAGE.
    CASE SY-SUBRC.
      WHEN 1. LV_MESSAGE = 'invalid drive'.                 "#EC NOTEXT
      WHEN 2. LV_MESSAGE = 'invalid extension'.             "#EC NOTEXT
      WHEN 3. LV_MESSAGE = 'invalid name'.                  "#EC NOTEXT
      WHEN 4. LV_MESSAGE = 'invalid path'.                  "#EC NOTEXT
      WHEN 5. LV_MESSAGE = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'File name check error:' LV_MESSAGE         "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.
    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

  IF LV_FILE_EXTENSION <> 'TXT'.
    PERFORM DISPLAY_ERROR_MESSAGE
USING 'HANA sizing result file should be a ".TXT" file'.    "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

ENDFORM.                    "check_hana_sizing_file_name

*&---------------------------------------------------------------------*
*& Form get_hana_sizing_file_data
*&---------------------------------------------------------------------*
FORM GET_HANA_SIZING_FILE_DATA
  USING IV_FILE_NAME TYPE RLGRAP-FILENAME
  CHANGING CT_RESULT TYPE STRINGTAB
           CV_ERROR_FOUND TYPE BOOLEAN.

  DATA:
    LV_FILE_NAME   TYPE STRING,
    LT_RESULT      TYPE STRINGTAB,
    LV_RESULT_WA   LIKE LINE OF LT_RESULT,
    LV_RESULT_SIZE TYPE I,
    LV_MESSAGE     TYPE STRING.

  CLEAR CT_RESULT[].

  LV_FILE_NAME = IV_FILE_NAME.
  CALL FUNCTION 'GUI_UPLOAD'
    EXPORTING
      FILENAME = LV_FILE_NAME
      FILETYPE = 'ASC'
    TABLES
      DATA_TAB = LT_RESULT
    EXCEPTIONS
      OTHERS   = 1.

  IF SY-SUBRC <> 0.
    PERFORM DISPLAY_ERROR_MESSAGE
      USING 'HANA sizing result file is not valid'.         "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

  CALL METHOD CL_GUI_CFW=>FLUSH.

  IF LT_RESULT[] IS INITIAL.
    PERFORM DISPLAY_ERROR_MESSAGE USING
'HANA sizing result file is empty. Check file content.'.    "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

  LV_RESULT_SIZE = LINES( LT_RESULT ).
  IF LV_RESULT_SIZE > 3.
    READ TABLE LT_RESULT INTO LV_RESULT_WA INDEX 3.
    IF LV_RESULT_WA NS 'SIZING RESULTS IN GB'.
      CONCATENATE
        'Could not find sizing results in chosen file.'     "#EC NOTEXT
        'Check file content.'                               "#EC NOTEXT
        INTO LV_MESSAGE SEPARATED BY SPACE.
      PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
      CV_ERROR_FOUND = ABAP_TRUE. EXIT.
    ENDIF.
  ENDIF.

  CT_RESULT[] = LT_RESULT[].
ENDFORM.                    "get_hana_sizing_file_data

*&---------------------------------------------------------------------*
*& Form upl_hana_sizing_data_to_server
*&---------------------------------------------------------------------*
FORM UPL_HANA_SIZING_DATA_TO_SERVER
  USING IT_RESULT TYPE STRINGTAB
  CHANGING CV_SERVER_FILE_NAME TYPE STRING
           CV_ERROR_FOUND TYPE BOOLEAN.

  DATA:
    LV_SERVER_FILE_NAME TYPE STRING,
    LV_RESULT_WA        TYPE STRING.

  CLEAR CV_SERVER_FILE_NAME.

  PERFORM SET_TMP_FILENAME
    USING 'hana_sizing' GV_BACK_PATH                        "#EC NOTEXT
    CHANGING LV_SERVER_FILE_NAME.

  OPEN DATASET LV_SERVER_FILE_NAME FOR OUTPUT IN TEXT MODE
    ENCODING UTF-8.

  IF SY-SUBRC <> 0.
    PERFORM DISPLAY_ERROR_MESSAGE USING
'Could not save HANA sizing results on application server.'. "#EC NOTEXT
    CV_ERROR_FOUND = ABAP_TRUE. EXIT.
  ENDIF.

  LOOP AT IT_RESULT INTO LV_RESULT_WA.
    TRANSFER LV_RESULT_WA TO LV_SERVER_FILE_NAME.
  ENDLOOP.

  CLOSE DATASET LV_SERVER_FILE_NAME.

  CV_SERVER_FILE_NAME = LV_SERVER_FILE_NAME.

ENDFORM.                    "upl_hana_sizing_data_to_server

*&---------------------------------------------------------------------*
*&      Form  INIT_ERROR_TEXTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM INIT_ERROR_TEXTS.

  DATA: LV_IS_INVISIBLE TYPE BOOLEAN.

  IF SCREEN-GROUP1 = 'ERR'.
    LV_IS_INVISIBLE = ABAP_TRUE.
  ENDIF.

  IF LV_IS_INVISIBLE EQ ABAP_TRUE.

    SCREEN-INPUT = '0'.
    SCREEN-OUTPUT = '0'.
    SCREEN-INVISIBLE = '1'.
    SCREEN-ACTIVE = 0.
    MODIFY SCREEN.

  ENDIF.

ENDFORM.                    " INIT_ERROR_TEXTS
*&---------------------------------------------------------------------*
*&      Form  CHECK_ERROR_FIELDS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LT_ERROR  text
*----------------------------------------------------------------------*
FORM VALIDATE_SCI_DATES  USING P_MARK TYPE BOOLEAN
                         CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  IF EXTRACT_ATC_S4_CHECK = ABAP_TRUE.

    PERFORM CHECK_SCI_DATE USING P_AT_DAT
                                'T_AT_DAT'
                                'ATC'
                                P_MARK
                                C_ATC_DAYS_CHECK
                         CHANGING LT_ERROR_MESSAGES.

  ENDIF.

  IF EXTRACT_SCI_HANA_CHECK = ABAP_TRUE AND
      EXTRACT_ATC_S4_CHECK = ABAP_FALSE.

    PERFORM CHECK_SCI_DATE USING SCI_FD_D
                                 'TSCI1DAT'
                                 C_FUNCTIONAL_DB
                                 P_MARK
                                 C_SCI_DAYS_CHECK
                           CHANGING LT_ERROR_MESSAGES.

  ENDIF.

  IF EXTRACT_SCI_HANA_CHECK = ABAP_TRUE.

    PERFORM CHECK_SCI_DATE USING SCI_FDAD
                                 'TSCI2DAT'
                                 C_FUNCTIONAL_DB_ADDITION
                                 P_MARK
                                 C_SCI_DAYS_CHECK
                           CHANGING LT_ERROR_MESSAGES.

  ENDIF.

  IF EXTRACT_SCI_HANA_PERFORMANCE = ABAP_TRUE.

    PERFORM CHECK_SCI_DATE USING SCI_PERD
                               'TSCI3DAT'
                               C_PERFORMANCE_DB
                               P_MARK
                               C_SCI_DAYS_CHECK
                           CHANGING LT_ERROR_MESSAGES.

  ENDIF.

ENDFORM.                    " CHECK_ERROR_FIELDS
*&---------------------------------------------------------------------*
*&      Form  ADD_ATTR_SCI_DATES_TO_HEADER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_ATTR_SCI_DATES_TO_HEADER CHANGING IO_HEADER_NODE.

  " Set if ETL is capable to extract SCI Hana.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_FUNCTIONAL_DB_DATE'
  SCI_FD_D.

  MESSAGE S899(EZ) WITH 'SCI_FUNCTIONAL_DB_DATE ='
  SCI_FD_D.

  " Set if ETL is capable to extract SCI Hana.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_FUNCTIONAL_DB_ADD_DATE'
  SCI_FDAD.

  MESSAGE S899(EZ) WITH 'SCI_FUNCTIONAL_DB_ADD_DATE ='
  SCI_FDAD.

  " Set if ETL is capable to extract SCI Hana.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_PERFORMANCE_DB_DATE'
  SCI_PERD.

  MESSAGE S899(EZ) WITH 'SCI_PERFORMANCE_DB_DATE ='
  SCI_PERD.

ENDFORM.                    " ADD_ATTR_SCI_DATES_TO_HEADER
*&---------------------------------------------------------------------*
*&      Form  ADD_ATTR_SCI_PARANS_TO_HEADER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_IO_HEADER_NODE  text
*----------------------------------------------------------------------*
FORM ADD_ATTR_SCI_PARAMS_TO_HEADER  CHANGING IO_HEADER_NODE.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
      'SCI_HANA_FROM_EXECUTED_LIST'
                                      R_SCIHAS.
  MESSAGE S899(EZ) WITH 'SCI_HANA_FROM_EXECUTED_LIST =' R_SCIHAS.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE 'SCI_HANA_USER'
                                  SCI_USR.
  MESSAGE S899(EZ) WITH 'SCI_HANA_USER =' SCI_USR.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_HANA_FUNCTIONAL_DB'
                                  SCI_FD.
  MESSAGE S899(EZ) WITH 'SCI_HANA_FUNCTIONAL_DB =' SCI_FD.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_HANA_FUNCTIONAL_DB_VERSION'
                                  SCI_FDV.
  MESSAGE S899(EZ) WITH 'SCI_HANA_FUNCTIONAL_DB_VERSION ='
SCI_FDV.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_HANA_FUNCTIONAL_DB_ADDITION'
                                  SCI_FDA.
  MESSAGE S899(EZ) WITH 'SCI_HANA_FUNCTIONAL_DB_ADDITION ='
SCI_FDA.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
  'SCI_HANA_FUNCTIONAL_DB_ADDITION_VERSION'
                                  SCI_FDAV.
  MESSAGE S899(EZ) WITH
  'SCI_HANA_FUNCTIONAL_DB_ADDITION_VERSION='
  SCI_FDAV.

  IF G_IS_CAN_SCI_HANA_PERFORMANCE = ABAP_TRUE.

    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
    'SCI_HANA_PERFORMANCE_DB' SCI_PER.

    MESSAGE S899(EZ) WITH 'SCI_HANA_PERFORMANCE_DB =' SCI_PER.

    PERFORM ADD_ATTRIBUTE_TO_NODE USING IO_HEADER_NODE
    'SCI_HANA_PERFORMANCE_DB_VERSION' SCI_PERV.

    MESSAGE S899(EZ) WITH 'SCI_HANA_PERFORMANCE_DB_VERSION ='
    SCI_PERV.

  ENDIF.

ENDFORM.                    " ADD_ATTR_SCI_PARANS_TO_HEADER
*&---------------------------------------------------------------------*
*&      Form  CHECK_SCI_DATE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_SCI_FD_D  text
*      <--P_LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM CHECK_SCI_DATE  USING    P_DATE_VALUE
                              P_SCREEN_FIELD
                              P_VARIANT
                              P_MARK
                              P_DAYS
                     CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: DIFF TYPE I.
  DATA: LS_ERROR TYPE STRING.

  IF P_DATE_VALUE IS NOT INITIAL AND
    P_DATE_VALUE NE '00000000'.
    DIFF = SY-DATUM - P_DATE_VALUE.
    IF DIFF > C_SCI_DAYS_CHECK.

      IF P_MARK EQ ABAP_TRUE.

        LOOP AT SCREEN.

          IF SCREEN-NAME = P_SCREEN_FIELD.
            SCREEN-INVISIBLE = 0.
            SCREEN-OUTPUT = 1.
            SCREEN-ACTIVE = 1.
            SCREEN-COLOR = 5.
            SCREEN-INTENSIFIED = 1.
            MODIFY SCREEN.
          ENDIF.

        ENDLOOP.

      ENDIF.

      CONCATENATE 'The' P_VARIANT                           "#EC NOTEXT
      'check is more than a' P_DAYS 'old'                   "#EC NOTEXT
      INTO LS_ERROR SEPARATED BY SPACE.

      APPEND LS_ERROR TO LT_ERROR_MESSAGES.

    ENDIF.
  ENDIF.

ENDFORM.                    " CHECK_SCI_DATE

*&---------------------------------------------------------------------*
*&      Form  FIND_APPC_MODULE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->NODES      text
*      -->APPC       text
*      -->MODULE     text
*----------------------------------------------------------------------*
FORM FIND_APPC_MODULE TABLES NODES STRUCTURE SNODETEXT
                      USING  APPC TYPE SNODETEXT
                      CHANGING MODULE TYPE SNODETEXT.
ENDFORM.                    "FIND_APPC_MODULE

*&---------------------------------------------------------------------*
*&      Form  validate_atc_variant
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK             text
*      -->LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_ATC_VARIANT USING P_MARK
                            CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_EMPTY_GUID TYPE CHAR32.
  DATA: LV_MESSAGE TYPE STRING.

  IF EXTRACT_ATC_S4_CHECK EQ ABAP_TRUE AND
    C_ATCRES EQ ABAP_TRUE.
    IF ( P_AT_GID IS INITIAL OR
         P_AT_GID = LV_EMPTY_GUID ) AND
      P_MARK = ABAP_FALSE.

      LV_MESSAGE = 'Please choose an ATC Run'.              "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

    ELSEIF ( P_AT_GID IS INITIAL OR
         P_AT_GID = LV_EMPTY_GUID ) AND
          P_MARK = ABAP_TRUE.

      LOOP AT SCREEN.
        IF SCREEN-NAME = 'T_AT_VAR'.
          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

  FIND FIRST OCCURRENCE OF SY-SYSID IN T_AT_TXT.
  IF SY-SUBRC IS NOT INITIAL AND T_AT_TXT IS NOT INITIAL.
    IF P_MARK EQ ABAP_TRUE.

      LOOP AT SCREEN.

        IF SCREEN-NAME = 'T_AT_SY1' OR
          SCREEN-NAME = 'T_AT_SY2'.
          SCREEN-INVISIBLE = 0.
          SCREEN-OUTPUT = 1.
          SCREEN-ACTIVE = 1.
          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.
        ENDIF.

      ENDLOOP.

    ENDIF.

    CONCATENATE 'Run ATC with an object provider'           "#EC NOTEXT
        'pointing to '                                      "#EC NOTEXT
        SY-SYSID INTO LV_MESSAGE RESPECTING BLANKS.
    APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

  ENDIF.

ENDFORM.                    "validate_atc_variant

*&---------------------------------------------------------------------*
*&      Form  validate_sm_rfc
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK             text
*      -->LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_SM_RFC USING P_MARK
                     CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_MESSAGE TYPE STRING.

  IF P_SM_RFC IS INITIAL AND P_SOLMAN IS NOT INITIAL.
    IF P_MARK = ABAP_FALSE.

      LV_MESSAGE =
'Please fill RFC destination to Solution Manager system'.   "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

    ELSEIF P_MARK = ABAP_TRUE.

      LOOP AT SCREEN.

        IF SCREEN-NAME = 'TEXT4'.
          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.
        ENDIF.

      ENDLOOP.
    ENDIF.
  ENDIF.

ENDFORM.                    "validate_sm_rfc

*&---------------------------------------------------------------------*
*&      Form  validate_hana_sci
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK             text
*      -->LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_HANA_SCI USING P_MARK
                       CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.


  PERFORM VALIDATE_HANA_SCI_INPUTS USING P_MARK
                                   CHANGING LT_ERROR_MESSAGES.


  PERFORM VALIDATE_SCI_DATES USING P_MARK
                             CHANGING LT_ERROR_MESSAGES.

ENDFORM.                    "validate_hana_sci

*&---------------------------------------------------------------------*
*&      Form  validate_hana_sizing
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK             text
*      -->LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_HANA_SIZING USING P_MARK
                            CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_MESSAGE TYPE STRING VALUE 0.

  IF EXTRACT_HN_SIZING_CHECK = ABAP_TRUE.
    IF ( P_HN_SIZ IS NOT INITIAL AND PSRV_HN IS INITIAL ).
      CONCATENATE
      'HANA sizing results '
      'file was not uploaded'                               "#EC NOTEXT
      INTO LV_MESSAGE.
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.
    ENDIF.
  ENDIF.

ENDFORM.                    "validate_hana_sizing


*&---------------------------------------------------------------------*
*&      Form  validate_hana_sci_inputs
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK             text
*      -->LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_HANA_SCI_INPUTS USING P_MARK
                            CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_ERROR TYPE C.
  DATA: LV_MESSAGE TYPE STRING VALUE 0.

  IF EXTRACT_SCI_HANA_CHECK = ABAP_TRUE.

    PERFORM VALIDATE_HANA_SCI_INPUT
      USING
         C_FUNCTIONAL_DB
         SCI_FD
         SCI_FDV
      CHANGING
         LV_ERROR.

    IF P_MARK = ABAP_FALSE AND
       LV_ERROR = ABAP_TRUE.

      LV_MESSAGE =
  'Please fill Inspection Name for FUNCTIONAL_DB'.          "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

    ELSEIF P_MARK = ABAP_TRUE AND
           LV_ERROR = ABAP_TRUE.

      LOOP AT SCREEN.

        IF SCREEN-NAME = 'TIT_FD'.

          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.

        ENDIF.

      ENDLOOP.

    ENDIF.

    CLEAR LV_ERROR.

    PERFORM VALIDATE_HANA_SCI_INPUT
      USING
         C_FUNCTIONAL_DB_ADDITION
         SCI_FDA
         SCI_FDAV
      CHANGING
         LV_ERROR.

    IF P_MARK = ABAP_FALSE AND
       LV_ERROR = ABAP_TRUE.

      LV_MESSAGE =
  'Please fill Inspection Name for FUNCTIONAL_DB_ADDITION'. "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

    ELSEIF P_MARK = ABAP_TRUE AND
           LV_ERROR = ABAP_TRUE.

      LOOP AT SCREEN.

        IF SCREEN-NAME = 'TIT_FDA'.
          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.
        ENDIF.

      ENDLOOP.

    ENDIF.

  ENDIF.

  IF EXTRACT_SCI_HANA_PERFORMANCE = ABAP_TRUE.

    CLEAR LV_ERROR.

    PERFORM VALIDATE_HANA_SCI_INPUT
      USING
         C_PERFORMANCE_DB
         SCI_PER
         SCI_PERV
      CHANGING
         LV_ERROR.

    IF P_MARK = ABAP_FALSE AND
       LV_ERROR = ABAP_TRUE AND
       P_SCIPRF = ABAP_TRUE.

      LV_MESSAGE =
      'Please fill Inspection Name for PERFORMANCE_DB'.     "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.

    ELSEIF P_MARK = ABAP_TRUE AND
           LV_ERROR = ABAP_TRUE AND
           P_SCIPRF = ABAP_TRUE.

      LOOP AT SCREEN.
        IF SCREEN-NAME = 'TIT_PER'.
          SCREEN-COLOR = 5.
          SCREEN-INTENSIFIED = 1.
          MODIFY SCREEN.
        ENDIF.
      ENDLOOP.

    ENDIF.
  ENDIF.

ENDFORM.                    "validate_hana_sci_inputs

*&---------------------------------------------------------------------*
*&      Form  SAVE_SUSG_IN_APP_SRV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_SUSG  text
*----------------------------------------------------------------------*
FORM SAVE_SUSG_IN_APP_SRV  USING IV_FILE
                           CHANGING CV_UPLOADED.

  DATA: LV_FULL_PATH    TYPE STRING,
        LV_FILENAME     TYPE STRING,
        LV_FILENAME_EXT TYPE STRING,
        LV_PATH         TYPE STRING,
        LV_EXTENSION    TYPE STRING.

  DATA LV_LINE TYPE X LENGTH 1000.
  DATA LV_MAX_LEN TYPE I.

  DATA L_FILELENGTH TYPE I.
  DATA L_LINES TYPE I.
  DATA L_LEN TYPE I.

  DATA LT_CONTENT_AS_TABLE LIKE TABLE OF LV_LINE.
  DATA LV_FILE_DATASET TYPE STRING.
  DATA LV_MESSAGE TYPE STRING.

  IF IV_FILE IS INITIAL.
    LV_MESSAGE = 'No SUSG file to upload'.                  "#EC NOTEXT

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    CLEAR SY-UCOMM.
    LEAVE TO SCREEN SY-DYNNR.
    EXIT.
  ENDIF.

  LV_FULL_PATH = IV_FILE.

  PERFORM SPLIT_FILENAME USING LV_FULL_PATH
                         CHANGING
                           LV_FILENAME
                           LV_FILENAME_EXT
                           LV_PATH
                           LV_EXTENSION.

  CL_GUI_FRONTEND_SERVICES=>GUI_UPLOAD(
    EXPORTING
      FILENAME                = LV_FULL_PATH
      FILETYPE                = 'BIN'
    IMPORTING
      FILELENGTH              = L_FILELENGTH
    CHANGING
      DATA_TAB                = LT_CONTENT_AS_TABLE
    EXCEPTIONS
      FILE_OPEN_ERROR         = 1
      FILE_READ_ERROR         = 2
      NO_BATCH                = 3
      GUI_REFUSE_FILETRANSFER = 4
      INVALID_TYPE            = 5
      NO_AUTHORITY            = 6
      UNKNOWN_ERROR           = 7
      BAD_DATA_FORMAT         = 8
      HEADER_NOT_ALLOWED      = 9
      SEPARATOR_NOT_ALLOWED   = 10
      HEADER_TOO_LONG         = 11
      UNKNOWN_DP_ERROR        = 12
      ACCESS_DENIED           = 13
      DP_OUT_OF_MEMORY        = 14
      DISK_FULL               = 15
      DP_TIMEOUT              = 16
      NOT_SUPPORTED_BY_GUI    = 17
      ERROR_NO_GUI            = 18
      OTHERS                  = 19
  ).
  IF SY-SUBRC <> 0.
*   MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*     WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  CONCATENATE GV_BACK_PATH LV_FILENAME_EXT INTO
  LV_FILE_DATASET.

  CONDENSE LV_FILE_DATASET.
  TRANSLATE LV_FILE_DATASET USING ' _'.

  DESCRIBE TABLE LT_CONTENT_AS_TABLE LINES L_LINES.
  LV_MAX_LEN = XSTRLEN( LV_LINE ).
  L_LEN = LV_MAX_LEN.

  OPEN DATASET LV_FILE_DATASET FOR OUTPUT IN BINARY MODE.

  IF SY-SUBRC IS NOT INITIAL.

    LV_MESSAGE = 'Could not Write SUSG file to server'.     "#EC NOTEXT

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    CLEAR SY-UCOMM.
    LEAVE TO SCREEN SY-DYNNR.
    EXIT.

  ENDIF.

  LOOP AT LT_CONTENT_AS_TABLE INTO LV_LINE.

    IF SY-TABIX = L_LINES.
      L_LEN = L_FILELENGTH MOD LV_MAX_LEN.
    ENDIF.

    TRANSFER LV_LINE TO LV_FILE_DATASET LENGTH L_LEN.

  ENDLOOP.

  CLOSE DATASET LV_FILE_DATASET.

  CV_UPLOADED = LV_FILE_DATASET.

ENDFORM.

*---------------------------------------------------------------------*
* FORM GET_DATE_BEFORE_MONTHS                                         *
*---------------------------------------------------------------------*
FORM GET_DATE_BEFORE_MONTHS
  USING NUM_OF_MONTHS TYPE I
  CHANGING DATE TYPE DATUM.

  DATA: LV_MONTHS_BACK TYPE I.
  LV_MONTHS_BACK = 0 - NUM_OF_MONTHS.

* Calculate the date according to months back parameter
  CALL FUNCTION 'CALCULATE_DATE'
    EXPORTING
*     DAYS              = '0'
      MONTHS            = LV_MONTHS_BACK
      START_DATE        = SY-DATUM
    IMPORTING
      RESULT_DATE       = DATE.

ENDFORM.                    "GET_DATE_BEFORE_MONTHS

*&---------------------------------------------------------------------*
*&      Form  SPLIT_FILENAME
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IV_FILE  text
*      <--P_LV_NAME  text
*      <--P_LV_PATH  text
*----------------------------------------------------------------------*
FORM SPLIT_FILENAME  USING    IV_FILE
                     CHANGING CV_NAME
                              CV_NAME_EXT
                              CV_PATH
                              CV_EXTENSION.

  DATA: LV_FILE  TYPE STRING,
        PATH     TYPE STRING,
        FILE_EXT TYPE STRING,
        EXT      TYPE STRING,
        LINES    TYPE I,
        LT_FILE  TYPE STANDARD TABLE OF STRING,
        LT_PATH  TYPE STANDARD TABLE OF STRING.

  DATA: LV_MESSAGE TYPE STRING.

  LV_FILE = IV_FILE.

  TRANSLATE LV_FILE USING '/\'.
  PATH = LV_FILE.

  SPLIT LV_FILE AT '\' INTO TABLE LT_PATH.
  DESCRIBE TABLE LT_PATH LINES LINES.
  IF LINES > 1.
    READ TABLE LT_PATH INTO FILE_EXT INDEX LINES.
    DELETE LT_PATH INDEX LINES.
  ELSE.

    LV_MESSAGE = 'Invalid Path for SUSG file'.              "#EC NOTEXT

    PERFORM DISPLAY_ERROR_MESSAGE USING LV_MESSAGE.
    CLEAR SY-UCOMM.
    LEAVE TO SCREEN SY-DYNNR.
    EXIT.

  ENDIF.

  SPLIT FILE_EXT AT '.' INTO TABLE LT_FILE.
  DESCRIBE TABLE LT_FILE LINES LINES.
  IF LINES > 1.
    READ TABLE LT_FILE INTO EXT INDEX LINES.
    DELETE LT_FILE INDEX LINES.
  ENDIF.

  CONCATENATE LINES OF LT_PATH INTO CV_PATH SEPARATED BY '/'.
  CONCATENATE LINES OF LT_FILE INTO CV_NAME SEPARATED BY '.'.
  CV_EXTENSION = EXT.
  CV_NAME_EXT = FILE_EXT.


ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  VALIDATE_SUSG_FILE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_MARK  text
*      <--P_LT_ERROR_MESSAGES  text
*----------------------------------------------------------------------*
FORM VALIDATE_SUSG_FILE  USING    P_MARK
                         CHANGING LT_ERROR_MESSAGES TYPE STRINGTAB.

  DATA: LV_MESSAGE TYPE STRING.

  IF EXTRACT_SUSG_DATA = ABAP_TRUE.
    IF ( P_SUSG IS NOT INITIAL AND PSRV_SUS IS INITIAL ).
     LV_MESSAGE = 'SUSG File was selected but not uploaded'. "#EC NOTEXT
      APPEND LV_MESSAGE TO LT_ERROR_MESSAGES.
    ENDIF.
  ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  GET_VANILLA_PROGRAM_SERVICE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_VANILLA_PROGRAM_SERVICE CHANGING CV_SUCCESS TYPE FLAG.

  DATA: LR_HTTP_CLIENT TYPE REF TO IF_HTTP_CLIENT.
  DATA: LT_VANILLA_PROGRAM TYPE TABLE OF STRING.
  DATA: LV_URL TYPE STRING.
  DATA: LV_SUBRC TYPE SY-SUBRC.
  DATA: LV_SUBRC_C TYPE STRING.
  DATA: LV_RESPONSE TYPE STRING.
  DATA: LV_PROG TYPE STRING.
  DATA: LV_ORIGIN TYPE STRING.
  DATA: LV_ERROR_TEXT TYPE STRING.
  DATA  LV_RESPONSE_CODE TYPE I.
  DATA  LV_RESPONSE_REASON TYPE STRING.
  DATA  LV_MESSAGE TYPE STRING.
  DATA  LV_LINES(7) TYPE C.
  DATA  LV_HTTP_CODE(4) TYPE C.
  DATA  LX_ERROR TYPE REF TO CX_SY_CONVERSION_NO_NUMBER.

  FIELD-SYMBOLS: <FS_PROG> TYPE STRING.

  CLEAR CV_SUCCESS.

  LV_URL = C_REST_SERVICE_ADDRESS.

  CONCATENATE LV_URL
              '/rest/public/etl/getVanillaToExtractText/'   "#EC NOTEXT
              ACCOUNT_UID INTO LV_URL.

  LV_MESSAGE = 'Getting vanilla programs list from server. URL:'. "#EC NOTEXT
  PERFORM ADD_MESSAGE
    USING LV_MESSAGE
          ABAP_TRUE.
  PERFORM ADD_MESSAGE
    USING LV_URL
          ABAP_TRUE.

  CL_HTTP_CLIENT=>CREATE_BY_URL(
   EXPORTING
     URL                = LV_URL
     SSL_ID             = 'ANONYM'
   IMPORTING
     CLIENT             = LR_HTTP_CLIENT
   EXCEPTIONS
     ARGUMENT_NOT_FOUND = 1
     PLUGIN_NOT_ACTIVE  = 2
     INTERNAL_ERROR     = 3
     OTHERS             = 4 ).
  IF SY-SUBRC <> 0.
    LV_SUBRC_C = LV_SUBRC.
    CONCATENATE
       'Get Vanilla programs request receive failed on create http client. SUBRC - '  "#EC NOTEXT
       LV_SUBRC_C INTO lv_message
       SEPARATED BY SPACE.
      PERFORM RAISE_MESSAGE USING LV_MESSAGE.
    EXIT.
  ENDIF.

  CALL METHOD LR_HTTP_CLIENT->SEND
    EXPORTING
      TIMEOUT                    = 900
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      HTTP_INVALID_TIMEOUT       = 4
      OTHERS                     = 5 .
  IF SY-SUBRC <> 0.
    LV_SUBRC_C = LV_SUBRC.
    CONCATENATE
     'Get Vanilla programs request receive failed on http send. SUBRC - '  "#EC NOTEXT
      LV_SUBRC_C INTO LV_MESSAGE
      SEPARATED BY SPACE.
    PERFORM RAISE_MESSAGE USING LV_MESSAGE.
    EXIT.
  ENDIF.

  CALL METHOD LR_HTTP_CLIENT->RECEIVE
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      OTHERS                     = 4.

  IF SY-SUBRC <> 0.

    CALL METHOD LR_HTTP_CLIENT->GET_LAST_ERROR
      IMPORTING
        CODE    = LV_SUBRC
        MESSAGE = LV_ERROR_TEXT.

    LV_SUBRC_C = LV_SUBRC.
    CONCATENATE
     'Get Vanilla programs request receive failed on http receive. SUBRC - '  "#EC NOTEXT
      LV_SUBRC_C 'last error - '                                              "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.
    PERFORM RAISE_MESSAGE USING LV_MESSAGE.
    PERFORM RAISE_MESSAGE USING LV_ERROR_TEXT.
    EXIT.
  ELSE.
    TRY.
      LR_HTTP_CLIENT->RESPONSE->GET_STATUS(
        IMPORTING CODE = LV_RESPONSE_CODE
                  reason = LV_RESPONSE_REASON ).

      IF LV_RESPONSE_CODE NE 200.
        WRITE LV_RESPONSE_CODE TO LV_HTTP_CODE.
        CONCATENATE 'HTTP response code:' LV_HTTP_CODE
          INTO LV_MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE
          USING LV_MESSAGE
                ABAP_TRUE.
        CONCATENATE 'Error message:'
                     LV_RESPONSE_REASON
          INTO LV_MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE
          USING LV_MESSAGE
                ABAP_TRUE.
         RETURN.
      ENDIF.

      LV_RESPONSE = LR_HTTP_CLIENT->RESPONSE->GET_CDATA( ).
      SPLIT LV_RESPONSE AT ';' INTO TABLE LT_VANILLA_PROGRAM.
      LOOP AT LT_VANILLA_PROGRAM ASSIGNING <FS_PROG>.
        SPLIT <FS_PROG> AT ',' INTO LV_PROG LV_ORIGIN.
        G_VANILLA_PROGRAMS-PROG = LV_PROG.
        G_VANILLA_PROGRAMS-ORIGIN = LV_ORIGIN.
        APPEND G_VANILLA_PROGRAMS.
      ENDLOOP.

      IF SY-SUBRC EQ 0.
        CV_SUCCESS = 'X'.
        DESCRIBE TABLE g_vanilla_programs.
        WRITE SY-TFILL TO LV_LINES.
        CONCATENATE 'Retrieved'
                    LV_LINES
                    'vanilla programs from service.'
          INTO LV_MESSAGE SEPARATED BY SPACE.
        CONDENSE LV_MESSAGE.

      ELSE.
        LV_MESSAGE = 'Vanilla programs list returned empty.'.
      ENDIF.

      PERFORM ADD_MESSAGE
        USING LV_MESSAGE
              ABAP_TRUE.

      CATCH CX_SY_CONVERSION_NO_NUMBER INTO LX_ERROR.
        PERFORM ADD_MESSAGE
          USING 'Error during http parsing:'
            ABAP_TRUE.
        LV_MESSAGE = LX_ERROR->IF_MESSAGE~GET_LONGTEXT( ).
        PERFORM add_message
          USING lv_message
            abap_true.
        CLEAR CV_SUCCESS.
        RETURN.
    ENDTRY.

  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
*       form add_data_to_xml                                          *
*---------------------------------------------------------------------*
FORM ADD_DATA_TO_XML.

  PERFORM ADD_DOCUMENT_HEADER.

  PERFORM ADD_RUN_PARAMETERS.

  IF USAGEONL IS INITIAL.
*   extract s/4 hana simplification list items
    PERFORM EXTRACT_S4HANA_SI_REPORT.

*   first we fetch the "customer" (non-sap) development classes. then,
* we get the list of objects for these dev. classes. the list of objects
*   is divided into lists per object type
    PERFORM EXTRACT_DEVELOPMENT_CLASSES.
    IF TESTING_DATA_ONLY IS INITIAL.
      PERFORM EXTRACT_REPOSITORY_OBJECTS.
    ENDIF.

    IF VANILLA = 'X'.
      IF FIRSTBLK = 'X'.
*     execute only first round
        PERFORM EXTRACT_MODULE_APP_COMP.
        PERFORM EXTRACT_HR_DATA.
        PERFORM EXTRACT_BUSINESS_OBJECTS.
      ENDIF.

*     execute every round
      PERFORM EXTRACT_REL_DEV_CLASS_COMP.
    ENDIF.

    PERFORM EXTRACT_FUNCTIONS.

*   the extraction of programs must occur after the extraction of
*   functions, since we add a program entry for each function group
    PERFORM EXTRACT_PROGRAMS.

    PERFORM EXTRACT_TRANSACTIONS.
    PERFORM EXTRACT_LOGICAL_DATABASES.
    PERFORM EXTRACT_MESSAGES.
    PERFORM EXTRACT_VANILLA_SOURCE.

*   find sap types with customer append structures/customer include.
*   the etl also extracts these sap "modified" types in the relevant
*   extraction forms
    PERFORM FIND_APPEND_STRUCTURES.
    PERFORM FIND_CUSTOMER_INCLUDES.

*   find sap views that include * notion, and at least one of the
*   tables that are included in the view has customer append structure/
*   customer include
    PERFORM FIND_VIEW_WITH_ASTRIX.

    PERFORM EXTRACT_TABLES.
    PERFORM EXTRACT_VANILLA_TABL_CUST_INDX.

    PERFORM EXTRACT_VIEWS.
    PERFORM EXTRACT_FOREIGN_KEYS.
    PERFORM EXTRACT_DATA_ELEMENTS.
*    perform extract_table_types.
    PERFORM EXTRACT_DOMAINS.

*   runtime representation of types
    PERFORM EXTRACT_DATA_TYPES.

    PERFORM EXTRACT_SOFTWARE_COMPONENTS.

    IF TESTING_DATA_ONLY IS INITIAL.
      PERFORM EXTRACT_USER_EXITS.
      PERFORM EXTRACT_MODIFICATIONS.
      PERFORM EXTRACT_AUTHORIZATIONS.
    ENDIF.

    PERFORM EXTRACT_PRODUCT_VERSIONS.
    PERFORM EXTRACT_SUPPORT_PACKAGES.
    PERFORM EXTRACT_DEV_CLASSES.
    PERFORM EXTRACT_NAMESPACES.
    PERFORM EXTRACT_OMG_MASTER_DATA_TEXTS.
    PERFORM EXTRACT_OMG_MASTER_DATA_RELS.

    IF TESTING_DATA_ONLY IS INITIAL.
      PERFORM EXTRACT_INFOTYPE_TEXTS.
      PERFORM EXTRACT_IDOCS.
      PERFORM EXTRACT_FUGR_INCLUDES_STATUS.
      PERFORM EXTRACT_FORMS.
      PERFORM EXTRACT_LAYOUTS.

      PERFORM EXTRACT_WEB_SERVICES.

*   this part will be performed only in ecc6
      IF VANILLA = ''.
        PERFORM EXTRACT_INDUSTRY_SOLUTION.
      ENDIF.

      PERFORM EXTRACT_USERS_DATA.
      PERFORM EXTRACT_BW_EXTRACTORS.
      PERFORM EXTRACT_USERS.
      PERFORM EXTRACT_BW_DATA.
      PERFORM ADD_ENHANCEMENTS_DATA.
    ENDIF.
    IF NO_SUET_DATA IS INITIAL.
      PERFORM EXTRACT_AREA_MENUS.
      PERFORM EXTRACT_VOFM_USER_EXITS.
      PERFORM EXTRACT_BTE_USER_EXITS.
      PERFORM EXTRACT_SALES_USER_EXITS.
      PERFORM EXTRACT_BADI_IMP.

      IF NOT EXTRACT_WORKFLOW_DATA IS INITIAL.
        PERFORM EXTRACT_WORKFLOWS.
      ENDIF.

      PERFORM EXTRACT_LSMW.
      PERFORM EXTRACT_SAP_SCRIPT_FORMS.
      PERFORM EXTRACT_LANGUAGES_INSTALLED.
      PERFORM EXTRACT_LANDSCAPE_DETAILS.
      PERFORM EXTRACT_HARDWARE_PLATFORM.
      PERFORM EXTRACT_GATEWAY_CONNECTIONS.
    ENDIF.

    IF TESTING_DATA_ONLY IS INITIAL.
      PERFORM GET_RFC_LIST.
      PERFORM ADD_RFCS_LIST.
      PERFORM EXTRACT_SYSTEM_PARAMETERS.
      PERFORM GET_SM_DATA.
    ENDIF.

*   extract hana code inspetor check, if needed.
    PERFORM EXTRACT_HANA_CODE_INSPECTOR.

*   extract s/4 hana convertion atc checks
    PERFORM EXTRACT_S4HANA_ATC_CHECKS.

*   extract s/4 hana sizing report results
    PERFORM EXTRACT_HANA_SIZING_RESULT.

*   extract Fiori & SAPUI5 applications
    PERFORM EXTRACT_FIORI_APP.

*   extract ODATA services
    PERFORM EXTRACT_ODATA_SERVICE.

*   extract ODATA services usage
    PERFORM EXTRACT_ODATA_USAGE.

*   extract Where Used List
    PERFORM EXTRACT_WHERE_USED_LIST.

*   check if we need to extract wd data
    IF EXTRACT_WD_DATA EQ 'X'.
      PERFORM ADD_WD_DATA.
    ENDIF.
  ELSE.
    PERFORM EXTRACT_AUTH_USAGE_ONLY.
    PERFORM EXTRACT_IDOCS_USAGE_ONLY.
  ENDIF.

* extract proxies data in any case (usage only)
  IF NOT EXTRACT_PROXY_DATA IS INITIAL.
    PERFORM EXTRACT_PROXIES.
  ENDIF.

  PERFORM EXTRACT_USAGE.

  IF TESTING_DATA_ONLY IS INITIAL.
    PERFORM EXTRACT_UPL_DATA.
    PERFORM ADD_SERVERS_LIST.
    PERFORM GET_SOLAR_RAW_DATA.
  ENDIF.

  PERFORM ADD_TIME_STATS.
  PERFORM ADD_ETL_ERROR_MESSAGES.
  PERFORM ADD_ETL_NOTIFICATIONS.
  PERFORM ADD_ETL_JOBLOG.

ENDFORM.                          " add_data_to_xml

*&---------------------------------------------------------------------*
*&      Form  add_document_header
*&---------------------------------------------------------------------*
FORM ADD_DOCUMENT_HEADER.

  DATA: HEADER_NODE       TYPE XML_ELEMENT.
  DATA: CODE_VERSION(15)  TYPE C.

  DATA:
    LV_TEXT                   TYPE CHAR10,
    LV_LICENSE                TYPE CHAR10,
    LV_MODE                   TYPE CHAR10,
    LV_LOGSYS                 TYPE LOGSYS,
    LV_RFC_SYSID              TYPE SY-SYSID,
    LV_RFC_MANDT              TYPE SY-MANDT,
    LV_IS_HASH_USERNAME_USAGE TYPE FLAG,
    LV_RFC_USER_NAME          TYPE USR02-BNAME,
    LV_AUTH_OBJ               TYPE UST12-OBJCT,
    LT_AUTH_VALUES            TYPE TABLE OF USVALUES.

  DATA: K_RELEASE TYPE SYSAPRL,
        K_PATCH   TYPE SYCHAR05.
  DATA: HOST TYPE STRING.

* Create a child node for the Header node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'HEADER'
                          CHANGING HEADER_NODE.
*---
* Set Date
  LV_TEXT = SY-DATUM.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'DATE' LV_TEXT.

* Set Time
  LV_TEXT = SY-UZEIT.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TIME' LV_TEXT.

* Set execution mode
  IF R_BACK IS INITIAL.
    LV_MODE = 'FOREGROUND'.
  ELSE.
    LV_MODE = 'BACKGROUND'.
  ENDIF.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'MODE'
                                      LV_MODE.
* Set Application Server
  IF SHOW_SERVERS_NAME IS INITIAL.
    HOST = 'XXX'.
  ELSE.
    HOST = SY-HOST.
  ENDIF.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'APPLICATION_SERVER'
                                      HOST.
  MESSAGE S899(EZ) WITH 'APPLICATION_SERVER =' SY-HOST.

* Set System ID name
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_ID' SY-SYSID.
  MESSAGE S899(EZ) WITH 'SYSTEM_ID =' SY-SYSID.

* Set Client number
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'CLIENT' SY-MANDT.
  MESSAGE S899(EZ) WITH 'CLIENT =' SY-MANDT.

* Set Operating System
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'OPERATING_SYSTEM'
                                      SY-OPSYS.
  MESSAGE S899(EZ) WITH 'OPERATING_SYSTEM =' SY-OPSYS.

* Set SAP System Release
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_RELEASE'
                                      SY-SAPRL.
  MESSAGE S899(EZ) WITH 'SYSTEM_RELEASE =' SY-SAPRL.

* Set Installation number
  CALL FUNCTION 'SLIC_GET_LICENCE_NUMBER'
    IMPORTING
      LICENSE_NUMBER = LV_LICENSE.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'INSTALLATION_NUMBER'
                                      LV_LICENSE.
  MESSAGE S899(EZ) WITH 'INSTALLATION_NUMBER =' LV_LICENSE.

* Set User name
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'USER_NAME' SY-UNAME.
  MESSAGE S899(EZ) WITH 'USER_NAME =' SY-UNAME.

* Set Export Tool Version
  CONCATENATE GENERAL_PART_VER REL_SPECIFIC_VER
    INTO CODE_VERSION SEPARATED BY '.'.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXPORT_TOOL_VERSION'
                                      CODE_VERSION.
  MESSAGE S899(EZ) WITH 'EXPORT_TOOL_VERSION =' CODE_VERSION.

* Set Is Patch flag
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'IS_PATCH' IS_PATCH.
  MESSAGE S899(EZ) WITH 'IS_PATCH =' IS_PATCH.

* Set Can the customer edit run params
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'CUST_EDIT_PARAMS'
                                      CUST_EDIT_PARAMS.
  MESSAGE S899(EZ) WITH 'CUST_EDIT_PARAMS =' CUST_EDIT_PARAMS.

* Set Can the customer use automatic upload
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'ENABLE_AUTO_UPLOAD'
                                      ENABLE_AUTO_UPLOAD.
  MESSAGE S899(EZ) WITH 'ENABLE_AUTO_UPLOAD =' ENABLE_AUTO_UPLOAD.

* Set Target System
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM'
                                      P_RFCDES.
  MESSAGE S899(EZ) WITH 'TARGET_SYSTEM =' P_RFCDES.

* Set Target System Id ( production system id )
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_ID'
                                      RFC_SYSID.
  MESSAGE S899(EZ) WITH 'TARGET_SYSTEM_ID =' RFC_SYSID.

* Set Target system release
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_REL'
                                      RFC_SAPRL.
  MESSAGE S899(EZ) WITH 'TARGET_SYSTEM_REL =' RFC_SAPRL.

  IF ( IS_ON_TRIAL = 'X' ).
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_ROLE'
                                        P_ROLE.
    MESSAGE S899(EZ) WITH 'SYSTEM_ROLE =' P_ROLE.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_ROLE'
                                               P_TRROLE.
    MESSAGE S899(EZ) WITH 'TARGET_SYSTEM_ROLE =' P_TRROLE.
  ENDIF.

* Set Prod Account Environment
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'PROD_ACCOUNT_ENV'
                                      PROD_ACCOUNT_ENV.
  MESSAGE S899(EZ) WITH 'PROD_ACCOUNT_ENV =' PROD_ACCOUNT_ENV.

* Set Prod Account Id
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'PROD_ACCOUNT_ID'
                                      PROD_ACCOUNT_ID.
  MESSAGE S899(EZ) WITH 'PROD_ACCOUNT_ID =' PROD_ACCOUNT_ID.

* Set ETL vanilla extraction flag
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'VANILLA_EXTRACTION'
                                      VANILLA.

* Set SM Target System
  IF NOT P_SM_RFC IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM'
                                      P_SM_RFC.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM =' P_SM_RFC.

*   Set SM System Id
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_ID'
                                        SM_SYSID.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM_ID =' SM_SYSID.

*   Set SM system release
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_REL'
                                        SM_SAPRL.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM_REL =' SM_SAPRL.

  ENDIF.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'PRD_LOGSYS'
                                      GV_LOGSYS.
  MESSAGE S899(EZ) WITH 'PRD_LOGSYS =' GV_LOGSYS.

  CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET'
    IMPORTING
      P_LOGSYS                       = LV_LOGSYS
    EXCEPTIONS
      OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
      OTHERS                         = 2.
  IF SY-SUBRC <> 0.
    LV_LOGSYS = 'UNDEFINED'.
  ENDIF.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'LOCAL_LOGSYS'
                                      LV_LOGSYS.
  MESSAGE S899(EZ) WITH 'LOCAL_LOGSYS =' LV_LOGSYS.

* Add unicode length of the current system
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'UCLEN' UNICODELG.
  MESSAGE S899(EZ) WITH 'UCLEN =' UNICODELG.

* Add current Logon Language
  LV_TEXT = SY-LANGU.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'LOGIN_LANGU' LV_TEXT.
  MESSAGE S899(EZ) WITH 'LOGIN_LANGU =' LV_TEXT.

* Add active industry solution when applicable
  IF ACTIVE_INDUSTRY_SOLUTION NE SPACE.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
       'ACTIVE_INDUSTRY_SOLUTION' ACTIVE_INDUSTRY_SOLUTION.
    MESSAGE S899(EZ) WITH 'ACTIVE_INDUSTRY_SOLUTION ='
          ACTIVE_INDUSTRY_SOLUTION.
  ENDIF.

* Add usage only
  IF  NOT USAGEONL IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'USAGE_ONLY'
                                        USAGEONL.
    MESSAGE S899(EZ) WITH 'USAGE_ONLY =' USAGEONL.
  ENDIF.

  IF NOT OVERRIDE_PARAM_DEFAULTS IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
                                        'OVERRIDE_PARAM_DEFAULTS'
                                        OVERRIDE_PARAM_DEFAULTS.
  ENDIF.
  MESSAGE S899(EZ) WITH 'OVERRIDE_PARAM_DEFAULTS ='
                          OVERRIDE_PARAM_DEFAULTS.

  MESSAGE S899(EZ) WITH 'IA_DATA_ONLY =' IA_DATA_ONLY.


  MESSAGE S899(EZ) WITH 'EXTRACT_WD_DATA ='
                           EXTRACT_WD_DATA.

  MESSAGE S899(EZ) WITH 'EXTRACT_WD_METHOD_CODE ='
                           EXTRACT_WD_METHOD_CODE.

  MESSAGE S899(EZ) WITH 'EXTRACT_WD_SYNTAX_CHECK ='
                           EXTRACT_WD_SYNTAX_CHECK.

  MESSAGE S899(EZ) WITH 'REQUIRE_SECURITY ='
                           REQUIRE_SECURITY.

  MESSAGE S899(EZ) WITH 'REQUIRE_SOLMAN_RFC =' REQUIRE_SOLMAN_RFC.

  MESSAGE S899(EZ) WITH 'TESTING_DATA_ONLY =' TESTING_DATA_ONLY.

  MESSAGE S899(EZ) WITH 'TBOM_EXTRACTION =' TBOM_EXTRACTION.

  MESSAGE S899(EZ) WITH 'NO_SUET_DATA =' NO_SUET_DATA.

  MESSAGE S899(EZ) WITH 'EXTRACT_DEBUG =' EXTRACT_DEBUG.

  MESSAGE S899(EZ) WITH 'NO_WEB_USAGE =' NO_WEB_USAGE.

  MESSAGE S899(EZ) WITH 'EXTRACT_PROXY_DATA =' EXTRACT_PROXY_DATA.

  MESSAGE S899(EZ) WITH 'EXTRACT_PROXY_CALLERS ='
                          EXTRACT_PROXY_CALLERS.


  MESSAGE S899(EZ) WITH 'EXTRACT_IDOCS_USAGE ='
                          EXTRACT_IDOCS_USAGE.

  MESSAGE S899(EZ) WITH 'EXTRACT_LAYOUTS_USAGE ='
                          EXTRACT_LAYOUTS_USAGE.

  MESSAGE S899(EZ) WITH 'LAYOUTS_USAGE_DAYS_SLICE ='
                          LAYOUTS_USAGE_DAYS_SLICE.

  MESSAGE S899(EZ) WITH 'EXTRACT_LAYOUTS_USAGE_VIA_RFC ='
                           EXTRACT_LAYOUTS_USAGE_VIA_RFC.

  MESSAGE S899(EZ) WITH 'LAYOUTS_USAGE_DAYS_SLICE_RFC ='
                           LAYOUTS_USAGE_DAYS_SLICE_RFC.

  MESSAGE S899(EZ) WITH 'EXTRACT_FULL_USAGE =' EXTRACT_FULL_USAGE.


  MESSAGE S899(EZ) WITH 'EXTRACT_WORKFLOW_DATA ='
      EXTRACT_WORKFLOW_DATA.

  MESSAGE S899(EZ) WITH 'GET_AGR_USERS_RFC =' GET_AGR_USERS_RFC.

  MESSAGE S899(EZ) WITH 'GET_AGR_USERS_LOCAL =' GET_AGR_USERS_LOCAL.

  MESSAGE S899(EZ) WITH 'EXTRACT_TOTAL_INSTANCE ='
    EXTRACT_TOTAL_INSTANCE.

  MESSAGE S899(EZ) WITH 'DISABLE_SYNTAX_CHECK =' DISABLE_SYNTAX_CHECK.


  MESSAGE S899(EZ) WITH 'DISABLE_GUI_STATUS_EXTRACT ='
                          DISABLE_GUI_STATUS_EXTRACT.

  MESSAGE S899(EZ) WITH 'EXTRACT_UPL_DATA ='
                          EXTRACT_UPL_DATA.

* Add version specific header attributes
  PERFORM VERSION_SPECIFIC_HEADER_ATTRIB USING HEADER_NODE.

* Add kernel data
  PERFORM GET_KERNEL_DATA CHANGING K_RELEASE
                                   K_PATCH.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'KERNEL_RELEASE'
                                      K_RELEASE.
  MESSAGE S899(EZ) WITH 'KERNEL_RELEASE =' K_RELEASE.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'KERNEL_PATCH'
                                      K_PATCH.
  MESSAGE S899(EZ) WITH 'KERNEL_PATCH =' K_PATCH.


  MESSAGE S899(EZ) WITH 'EXTRACT_USER_DATA =' EXTRACT_USER_DATA.

  MESSAGE S899(EZ) WITH 'EXTRACT_USER_HR_DATA =' EXTRACT_USER_HR_DATA.

  MESSAGE S899(EZ) WITH
  'USERS_HR_DATA_BULK_SIZE =' USERS_HR_DATA_BULK_SIZE.

  MESSAGE S899(EZ) WITH
  'EXTRACT_OMEGA_MASTER_DATA =' EXTRACT_OMEGA_MASTER_DATA.

* Set SM Target System
  IF NOT P_SM_RFC IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM'
                                      P_SM_RFC.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM =' P_SM_RFC.

*   Set SM System Id
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_ID'
                                        SM_SYSID.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM_ID =' SM_SYSID.

*   Set SM system release
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_REL'
                                        SM_SAPRL.
    MESSAGE S899(EZ) WITH 'SM_SYSTEM_REL =' SM_SAPRL.

  ENDIF.

* Set bw extraction system data
  IF NOT P_BW_RFC IS INITIAL.
*   BW system
    PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_DESTINATION'
                                        P_BW_RFC.
    MESSAGE S899(EZ) WITH 'BW_DESTINATION =' P_BW_RFC.

    CALL FUNCTION 'SCT2_GET_T000_ENTRY_RFC' DESTINATION P_BW_RFC
      IMPORTING
        EV_SYSID              = LV_RFC_SYSID
        EV_MANDT              = LV_RFC_MANDT
      EXCEPTIONS
        SYSTEM_FAILURE        = 1
        COMMUNICATION_FAILURE = 2.
    IF NOT SY-SUBRC IS INITIAL.
    ELSE.
*     Set BW System ID
      PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_SYSID'
                                      LV_RFC_SYSID.
      MESSAGE S899(EZ) WITH 'BW_SYSID =' LV_RFC_SYSID.

*     Set BW Client
      PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_CLIENT'
                                        LV_RFC_MANDT.
      MESSAGE S899(EZ) WITH 'BW_CLIENT =' LV_RFC_MANDT.
    ENDIF.
  ENDIF.

* Set the local system and target system's types
  PERFORM ADD_SYSTEM_TYPES_TO_HEADER USING HEADER_NODE.

* Logging to job log of ETL execution settings
  MESSAGE S899(EZ) WITH 'FILE NAME =' P_BACK.
  MESSAGE S899(EZ) WITH 'TEMP FILE NAME=' TEMP_BACK_FILENAME.
  MESSAGE S899(EZ) WITH 'PACKET SIZE=' PAC_SIZE.
  MESSAGE S899(EZ) WITH 'AGR_USERS_ROW_COUNT=' AGR_USERS_ROW_COUNT.
  MESSAGE S899(EZ) WITH 'USAGE_EXTRACTION_DAYS='
                           USAGE_EXTRACTION_DAYS.
  MESSAGE S899(EZ) WITH 'MONTHS_BACK_USAGE=' MONTHS_BACK_USAGE.

  " Set Hana code inspector data
  PERFORM ADD_ATTR_HANA_SCI_TO_HEADER
    USING
       HEADER_NODE.

  PERFORM ADD_ATTR_S4HANA_CONV_TO_HEADER
    USING
       HEADER_NODE.


  " Check if usernames in usage will extract with hashed values.
  LV_IS_HASH_USERNAME_USAGE = ABAP_TRUE.

* If the prod system is the current, there is
* no need to go through the RFC
  IF RFC_SYSID = SY-SYSID.

    AUTHORITY-CHECK OBJECT 'S_TOOLS_EX'
       ID 'AUTH' FIELD 'S_TOOLS_EX_A'.

    IF SY-SUBRC EQ 0.
      LV_IS_HASH_USERNAME_USAGE = ABAP_FALSE.
    ENDIF.

  ELSE. " Authority check via RFC

    LV_RFC_USER_NAME = RFC_USER.
    LV_AUTH_OBJ = 'S_TOOLS_EX'.

    FREE LT_AUTH_VALUES.
    CALL FUNCTION 'SUSR_USER_AUTH_FOR_OBJ_GET' DESTINATION P_RFCDES
      EXPORTING
        USER_NAME             = LV_RFC_USER_NAME
        SEL_OBJECT            = LV_AUTH_OBJ
      TABLES
        VALUES                = LT_AUTH_VALUES
      EXCEPTIONS
        USER_NAME_NOT_EXIST   = 1
        NOT_AUTHORIZED        = 2
        INTERNAL_ERROR        = 3
        SYSTEM_FAILURE        = 4
        COMMUNICATION_FAILURE = 5
        OTHERS                = 6.

    IF SY-SUBRC EQ 0.

      LOOP AT LT_AUTH_VALUES TRANSPORTING NO FIELDS
        WHERE OBJCT = 'S_TOOLS_EX'    AND
              FIELD  = 'AUTH'         AND
            ( VON    = 'S_TOOLS_EX_A' OR
              VON    = '*' ).

        LV_IS_HASH_USERNAME_USAGE = ABAP_FALSE.
      ENDLOOP.

    ENDIF.
  ENDIF.


  PERFORM ADD_ATTRIBUTE_TO_NODE
    USING
      HEADER_NODE
      'IS_HASH_USERNAME_USAGE'
       LV_IS_HASH_USERNAME_USAGE.

  MESSAGE S899(EZ) WITH 'IS_HASH_USERNAME_USAGE ='
  LV_IS_HASH_USERNAME_USAGE.

* Set EXTRACT_TEXT_ELEMENTS flag
  PERFORM ADD_ATTRIBUTE_TO_NODE
    USING
      HEADER_NODE
      'EXTRACT_TEXT_ELEMENTS'
      EXTRACT_TEXT_ELEMENTS.

  MESSAGE S899(EZ)
    WITH
      'EXTRACT_TEXT_ELEMENTS ='
      EXTRACT_TEXT_ELEMENTS.

* Set GET_USAGE_DELTA flag
  PERFORM ADD_ATTRIBUTE_TO_NODE
    USING
      HEADER_NODE
      'GET_USAGE_DELTA'
      GET_USAGE_DELTA.

  MESSAGE S899(EZ)
    WITH
      'GET_USAGE_DELTA ='
      GET_USAGE_DELTA.

* Set ATC_FROM_FIORI flag
  PERFORM ADD_ATTRIBUTE_TO_NODE
    USING
      HEADER_NODE
      'ATC_FROM_FIORI'
      C_ATCEXL.

  MESSAGE S899(EZ)
    WITH
      'ATC_FROM_FIORI ='
      C_ATCEXL.

  IF PSRV_SUS IS NOT INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE
      USING
        HEADER_NODE
        'S_USAGE_ATTACHED'
        'X'.
  ENDIF.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING HEADER_NODE 'X'.

ENDFORM.                    " add_document_header

*---------------------------------------------------------------------*
*       FORM GET_KERNEL_DATA                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  EV_KRELEASE                                                   *
*  -->  EV_KLEVEL                                                     *
*---------------------------------------------------------------------*
FORM GET_KERNEL_DATA CHANGING EV_KRELEASE
                              EV_KLEVEL.

  TYPES: BEGIN OF T_KERNEL_VERSION,
            KEY(21) TYPE C,
            DATA(69) TYPE C,
         END OF T_KERNEL_VERSION.

  DATA: LT_KERNEL_VERSION TYPE TABLE OF T_KERNEL_VERSION
                          WITH HEADER LINE,
        LS_KERNEL_VERSION TYPE T_KERNEL_VERSION.

  CALL 'SAPCORE' ID 'ID' FIELD 'VERSION'
                 ID 'TABLE' FIELD LT_KERNEL_VERSION-*SYS*.

  READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 12.
  EV_KRELEASE = LS_KERNEL_VERSION-DATA.
  READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 15.
  EV_KLEVEL = LS_KERNEL_VERSION-DATA.

ENDFORM.                    "GET_KERNEL_DATA
*&---------------------------------------------------------------------*
*&      Form  ADD_SYSTEM_TYPES_TO_HEADER
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM ADD_SYSTEM_TYPES_TO_HEADER
  USING IV_HEADER_NODE TYPE REF TO IF_IXML_ELEMENT.

  DATA: LS_LOCAL_SYSTEM  TYPE T000,
        LS_TARGET_SYSTEM TYPE T000,
        LS_RFCDES        TYPE RFCDES,
        LS_RFCDISPLAY    TYPE RFCDISPLAY.

  DATA: LV_PREFIX TYPE STRING,
        LV_SUFFIX TYPE STRING,
        LV_TARGET_MANDT TYPE MANDT.

  DATA: OPTIONS   TYPE TABLE OF RFC_DB_OPT,
        FIELDS    TYPE TABLE OF RFC_DB_FLD,
        T000_ITAB TYPE TABLE OF T000.

* Local system's type
  SELECT SINGLE *
    FROM T000
    INTO CORRESPONDING FIELDS OF LS_LOCAL_SYSTEM
   WHERE MANDT EQ SY-MANDT.

  IF SY-SUBRC IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IV_HEADER_NODE
      'LOCAL_SYSTEM_TYPE' LS_LOCAL_SYSTEM-CCCATEGORY.
    MESSAGE S899(EZ) WITH 'LOCAL_SYSTEM_TYPE ='
            LS_LOCAL_SYSTEM-CCCATEGORY.
  ENDIF.

* Target system's type
  SELECT SINGLE *
    FROM RFCDES BYPASSING BUFFER
    INTO CORRESPONDING FIELDS OF LS_RFCDES
    WHERE RFCDEST EQ P_RFCDES.

  IF SY-SUBRC IS INITIAL.
    SPLIT LS_RFCDES-RFCOPTIONS AT ',M=' INTO LV_PREFIX LV_SUFFIX.
    IF SY-SUBRC IS INITIAL AND NOT LV_SUFFIX IS INITIAL.
      LV_TARGET_MANDT = LV_SUFFIX(3).
    ENDIF.
  ENDIF.

* Get target system T000 table
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'T000'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = OPTIONS
      FIELDS               = FIELDS
      DATA                 = T000_ITAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC IS INITIAL AND NOT T000_ITAB IS INITIAL.
    IF NOT LV_TARGET_MANDT IS INITIAL.
*     Read target T000 with mandt
      READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
        WITH KEY MANDT = LV_TARGET_MANDT.
      IF NOT SY-SUBRC IS INITIAL.
*       Fallback: Mandt not found Read target T000 with cccategory = 'P'
        CONCATENATE
          'No results in target system T000 table' "#EC NOTEXT
          'for target MANDT found:' LV_TARGET_MANDT "#EC NOTEXT
          'Reading T000 with cccategory = P' "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
          WITH KEY CCCATEGORY = 'P'.
      ENDIF.
    ELSE.
*     Fallback: No mandt: Read target T000 with cccategory = 'P'
      CONCATENATE
        'Failed to get MANDT, Reading target system T000' "#EC NOTEXT
        'table with cccategory = P' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
        WITH KEY CCCATEGORY = 'P'.
    ENDIF.
  ENDIF.

  IF NOT LS_TARGET_SYSTEM IS INITIAL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING IV_HEADER_NODE
      'TARGET_SYSTEM_TYPE' LS_TARGET_SYSTEM-CCCATEGORY.

    MESSAGE S899(EZ) WITH 'TARGET_SYSTEM_TYPE ='
      LS_TARGET_SYSTEM-CCCATEGORY.
  ENDIF.

ENDFORM.                    " ADD_SYSTEM_TYPES_TO_HEADER

*&---------------------------------------------------------------------*
*&      Form  ADD_RUN_PARAMETERS
*&---------------------------------------------------------------------*
FORM ADD_RUN_PARAMETERS.
  TYPES:
    BEGIN OF KEY_VALUE_PAIR_TYPE,
      NAME TYPE CHAR255,
      VALUE TYPE CHAR50,
    END OF KEY_VALUE_PAIR_TYPE.

  DATA: LS_KEY_VALUE TYPE KEY_VALUE_PAIR_TYPE,
        LT_KEY_VALUE TYPE TABLE OF KEY_VALUE_PAIR_TYPE.

  DATA: HEADER_NODE       TYPE XML_ELEMENT.
  DATA: CODE_VERSION(15)  TYPE C.

* Extract current run parameters
  PERFORM APPEND_STRING_TO_FILE USING '<ETL_RUN_PARAMS>'.

  LS_KEY_VALUE-NAME = 'COMPRESS_RESULT_FILE'.
  LS_KEY_VALUE-VALUE = COMPRESS_RESULT_FILE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'OVERRIDE_PARAM_DEFAULTS'.
  LS_KEY_VALUE-VALUE = OVERRIDE_PARAM_DEFAULTS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'R_FORE'.
  LS_KEY_VALUE-VALUE = R_FORE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'TBOM_EXTRACTION'.
  LS_KEY_VALUE-VALUE = TBOM_EXTRACTION.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'SKIP_VALIDATION'.
  LS_KEY_VALUE-VALUE = SKIP_VALIDATION.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.


  LS_KEY_VALUE-NAME = 'IS_ON_TRIAL'.
  LS_KEY_VALUE-VALUE =  IS_ON_TRIAL .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'PROD_ACCOUNT_ENV'.
  LS_KEY_VALUE-VALUE = PROD_ACCOUNT_ENV .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'PROD_ACCOUNT_ID'.
  LS_KEY_VALUE-VALUE = PROD_ACCOUNT_ID .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'REQUIRE_SOLMAN_RFC'.
  LS_KEY_VALUE-VALUE = REQUIRE_SOLMAN_RFC .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'DISABLE_GUI_STATUS_EXTRACT'.
  LS_KEY_VALUE-VALUE = DISABLE_GUI_STATUS_EXTRACT .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'DISABLE_SYNTAX_CHECK'.
  LS_KEY_VALUE-VALUE = DISABLE_SYNTAX_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'GET_AGR_USERS_RFC'.
  LS_KEY_VALUE-VALUE = GET_AGR_USERS_RFC.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'GET_AGR_USERS_LOCAL'.
  LS_KEY_VALUE-VALUE = GET_AGR_USERS_LOCAL.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'AGR_USERS_ROW_COUNT'.
  LS_KEY_VALUE-VALUE = AGR_USERS_ROW_COUNT.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_USER_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_USER_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_USER_HR_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_USER_HR_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'USERS_HR_DATA_BULK_SIZE'.
  LS_KEY_VALUE-VALUE = USERS_HR_DATA_BULK_SIZE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_OMEGA_MASTER_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_OMEGA_MASTER_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'SHOW_LOGIN_NAME'.
  LS_KEY_VALUE-VALUE = SHOW_LOGIN_NAME.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'SHOW_SERVERS_NAME'.
  LS_KEY_VALUE-VALUE = SHOW_SERVERS_NAME.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'USAGE_EXTRACTION_DAYS'.
  LS_KEY_VALUE-VALUE = USAGE_EXTRACTION_DAYS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MONTHS_BACK_USAGE'.
  LS_KEY_VALUE-VALUE = MONTHS_BACK_USAGE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_TOTAL_INSTANCE'.
  LS_KEY_VALUE-VALUE = EXTRACT_TOTAL_INSTANCE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'NO_WEB_USAGE '.
  LS_KEY_VALUE-VALUE = NO_WEB_USAGE .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_IDOCS_USAGE'.
  LS_KEY_VALUE-VALUE = EXTRACT_IDOCS_USAGE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_LAYOUTS_USAGE'.
  LS_KEY_VALUE-VALUE = EXTRACT_LAYOUTS_USAGE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'LAYOUTS_USAGE_DAYS_SLICE'.
  LS_KEY_VALUE-VALUE = LAYOUTS_USAGE_DAYS_SLICE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_LAYOUTS_USAGE_VIA_RFC'.
  LS_KEY_VALUE-VALUE = EXTRACT_LAYOUTS_USAGE_VIA_RFC.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'LAYOUTS_USAGE_DAYS_SLICE_RFC'.
  LS_KEY_VALUE-VALUE = LAYOUTS_USAGE_DAYS_SLICE_RFC.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_UPL_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_UPL_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'GET_ONLY_CUST_UPL'.
  LS_KEY_VALUE-VALUE = GET_ONLY_CUST_UPL.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'UPL_MONTH_NUMBER'.
  LS_KEY_VALUE-VALUE = UPL_MONTH_NUMBER.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'DONT_SHOW_ERROR_ON_RFC'.
  LS_KEY_VALUE-VALUE = DONT_SHOW_ERROR_ON_RFC.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'ADD_GEN_PROGRAMS'.
  LS_KEY_VALUE-VALUE = ADD_GEN_PROGRAMS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'ADD_ABAP_QUERIES'.
  LS_KEY_VALUE-VALUE = ADD_ABAP_QUERIES.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_SOLAR_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_SOLAR_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_PROXY_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_PROXY_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_PROXY_CALLERS'.
  LS_KEY_VALUE-VALUE = EXTRACT_PROXY_CALLERS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_SCI_HANA_CHECK'.
  LS_KEY_VALUE-VALUE = EXTRACT_SCI_HANA_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_SCI_HANA_PERFORMANCE'.
  LS_KEY_VALUE-VALUE = EXTRACT_SCI_HANA_PERFORMANCE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_SI_S4_CHECK'.
  LS_KEY_VALUE-VALUE = EXTRACT_SI_S4_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_ATC_S4_CHECK'.
  LS_KEY_VALUE-VALUE = EXTRACT_ATC_S4_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_HN_SIZING_CHECK'.
  LS_KEY_VALUE-VALUE = EXTRACT_HN_SIZING_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'NO_SUET_DATA'.
  LS_KEY_VALUE-VALUE = NO_SUET_DATA .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_FULL_USAGE'.
  LS_KEY_VALUE-VALUE = EXTRACT_FULL_USAGE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_WORKFLOW_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_WORKFLOW_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'TESTING_DATA_ONLY'.
  LS_KEY_VALUE-VALUE = TESTING_DATA_ONLY.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'LOCAL_PROXY_USAGE_TIME'.
  LS_KEY_VALUE-VALUE = LOCAL_PROXY_USAGE_TIME.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'IA_DATA_ONLY'.
  LS_KEY_VALUE-VALUE = IA_DATA_ONLY.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MAX_MAINS'.
  LS_KEY_VALUE-VALUE = MAX_MAINS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'WARN_TABLE_SIZE'.
  LS_KEY_VALUE-VALUE = WARN_TABLE_SIZE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MAX_IDOC_USAGE_PAIRS'.
  LS_KEY_VALUE-VALUE = MAX_IDOC_USAGE_PAIRS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MAX_IDOC_USAGE_TIME'.
  LS_KEY_VALUE-VALUE = MAX_IDOC_USAGE_TIME.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'LOCAL_IDOC_USAGE_TIME'.
  LS_KEY_VALUE-VALUE = LOCAL_IDOC_USAGE_TIME .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MAX_PROXY_USAGE_TIME'.
  LS_KEY_VALUE-VALUE = MAX_PROXY_USAGE_TIME .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'MAX_PROXIES_VIA_RFC'.
  LS_KEY_VALUE-VALUE = MAX_PROXIES_VIA_RFC .
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_DEBUG'.
  LS_KEY_VALUE-VALUE = EXTRACT_DEBUG.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'CRS_EXTRACTION_MONTHS'.
  LS_KEY_VALUE-VALUE = CRS_EXTRACTION_MONTHS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'PROD_CRS_EXTRACTION_MONTHS'.
  LS_KEY_VALUE-VALUE = PROD_CRS_EXTRACTION_MONTHS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'ROLES_EXTRACTION_PERIOD'.
  LS_KEY_VALUE-VALUE = ROLES_EXTRACTION_PERIOD.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'PAC_SIZE'.
  LS_KEY_VALUE-VALUE = PAC_SIZE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_WD_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_WD_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_WD_METHOD_CODE'.
  LS_KEY_VALUE-VALUE = EXTRACT_WD_METHOD_CODE.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_WD_SYNTAX_CHECK'.
  LS_KEY_VALUE-VALUE = EXTRACT_WD_SYNTAX_CHECK.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'REQUIRE_SECURITY'.
  LS_KEY_VALUE-VALUE = REQUIRE_SECURITY.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_LAYOUT_USAGE_DAYS'.
  LS_KEY_VALUE-VALUE = EXTRACT_LAYOUT_USAGE_DAYS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_USER_FORMATS'.
  LS_KEY_VALUE-VALUE = EXTRACT_USER_FORMATS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'IS_PATCH'.
  LS_KEY_VALUE-VALUE = IS_PATCH.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_TEXT_ELEMENTS'.
  LS_KEY_VALUE-VALUE = EXTRACT_TEXT_ELEMENTS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'CUST_EDIT_PARAMS'.
  LS_KEY_VALUE-VALUE = CUST_EDIT_PARAMS.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'ENABLE_AUTO_UPLOAD'.
  LS_KEY_VALUE-VALUE = ENABLE_AUTO_UPLOAD.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'GET_USAGE_DELTA'.
  LS_KEY_VALUE-VALUE = GET_USAGE_DELTA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'TARGET_S4HANA_VERSION'.
  LS_KEY_VALUE-VALUE = C_TARGET_S4HANA_VERSION.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'ATC_FROM_FIORI'.
  LS_KEY_VALUE-VALUE = C_ATCEXL.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_SUSG_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_SUSG_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_FIORI_DATA'.
  LS_KEY_VALUE-VALUE = EXTRACT_FIORI_DATA.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  LS_KEY_VALUE-NAME = 'EXTRACT_WHERE_USED_LIST'.
  LS_KEY_VALUE-VALUE = EXTRACT_WHERE_USED_LIST.
  CONDENSE LS_KEY_VALUE-VALUE.
  APPEND LS_KEY_VALUE TO LT_KEY_VALUE.

  DATA: LV_TABIX_NUMC TYPE NUMC4.
* excluded programs
  LOOP AT S_PRGEXC.
    LV_TABIX_NUMC = SY-TABIX.
    CONCATENATE 'USER_EXCLUDED_PROGRAM_' LV_TABIX_NUMC
      INTO LS_KEY_VALUE-NAME.
    CONCATENATE S_PRGEXC-SIGN S_PRGEXC-OPTION S_PRGEXC-LOW
                S_PRGEXC-HIGH
      INTO LS_KEY_VALUE-VALUE SEPARATED BY SPACE.
    APPEND LS_KEY_VALUE TO LT_KEY_VALUE.
  ENDLOOP.

* excluded devcs
  LOOP AT S_DVCEXC.
    LV_TABIX_NUMC = SY-TABIX.
    CONCATENATE 'USER_EXCLUDED_DEVC_' LV_TABIX_NUMC
      INTO LS_KEY_VALUE-NAME.
    CONCATENATE S_DVCEXC-SIGN S_DVCEXC-OPTION S_DVCEXC-LOW
                S_DVCEXC-HIGH
      INTO LS_KEY_VALUE-VALUE SEPARATED BY SPACE.
    APPEND LS_KEY_VALUE TO LT_KEY_VALUE.
  ENDLOOP.

* excluded namespaces
  LOOP AT S_NSPEXC.
    LV_TABIX_NUMC = SY-TABIX.
    CONCATENATE 'USER_EXCLUDED_NAMESPACE_' LV_TABIX_NUMC
      INTO LS_KEY_VALUE-NAME.
    CONCATENATE S_NSPEXC-SIGN S_NSPEXC-OPTION S_NSPEXC-LOW
                S_NSPEXC-HIGH
      INTO LS_KEY_VALUE-VALUE SEPARATED BY SPACE.
    APPEND LS_KEY_VALUE TO LT_KEY_VALUE.
  ENDLOOP.

* last usage extraction date from extractor itself
  CLEAR LV_TABIX_NUMC.
  LOOP AT GT_USAGE_EXTRACT_DATES INTO USG_EXT_DATES_WA.
    LV_TABIX_NUMC = LV_TABIX_NUMC + 1.
    CONCATENATE 'USAGE_EXTRACT_DATES_' LV_TABIX_NUMC
      INTO LS_KEY_VALUE-NAME.
    CONCATENATE USG_EXT_DATES_WA-SYSTEM_NAME
                USG_EXT_DATES_WA-LAST_EXTRACTION_DATE
      INTO LS_KEY_VALUE-VALUE SEPARATED BY SPACE.
    APPEND LS_KEY_VALUE TO LT_KEY_VALUE.
  ENDLOOP.

* last usage extraction date from WS
  CLEAR LV_TABIX_NUMC.
  LOOP AT GT_USAGE_EXTRACT_DATES_WS INTO USG_EXT_DATES_WA.
    LV_TABIX_NUMC = LV_TABIX_NUMC + 1.
    CONCATENATE 'USAGE_EXTRACT_DATES_WS_' LV_TABIX_NUMC
      INTO LS_KEY_VALUE-NAME.
    CONCATENATE USG_EXT_DATES_WA-SYSTEM_NAME
                USG_EXT_DATES_WA-LAST_EXTRACTION_DATE
      INTO LS_KEY_VALUE-VALUE SEPARATED BY SPACE.
    APPEND LS_KEY_VALUE TO LT_KEY_VALUE.
  ENDLOOP.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_KEY_VALUE
              USING G_IREF_PDOCUMENT
                                       'ETL_RUN_PARAM'.
  PERFORM APPEND_STRING_TO_FILE USING '</ETL_RUN_PARAMS>'.

ENDFORM.                    "ADD_RUN_PARAMETERS

*&---------------------------------------------------------------------*
*&      Form  extract_repository_objects
*&---------------------------------------------------------------------*
FORM EXTRACT_REPOSITORY_OBJECTS.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_OBJ_NAME FOR TADIR-OBJ_NAME.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
                          'Extracting repository objects'. "#EC NOTEXT

  PERFORM ADD_SMODILOG_PROGRAMS.

  CHECK NOT GT_TADIR[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<REPOSITORY_OBJECTS>'.

* Add the Repository Objects Data
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES GT_TADIR
                                 USING G_IREF_PDOCUMENT
                                       'TADIR'.

  PERFORM APPEND_STRING_TO_FILE USING '</REPOSITORY_OBJECTS>'.

  FREE GT_TADIR.

  PERFORM ADD_TIME_STAT USING 'Extract rep objects' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_repository_objects

*---------------------------------------------------------------------*
*       FORM ADD_SMODILOG_PROGRAMS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM ADD_SMODILOG_PROGRAMS.

  DATA: MODIFIED_PROGS TYPE TABLE OF SMODILOG WITH HEADER LINE.

  CHECK VANILLA = ''.

* Find all the customer modified programs (vanilla only)
  SELECT * FROM SMODILOG
  INTO TABLE MODIFIED_PROGS
  WHERE SUB_TYPE = 'REPS'
  AND   SUB_NAME NOT IN CUST_NAMESPACE_RNG
  AND   INACTIVE = SPACE.

* Add TADIR entries for the programs (for types other then 'PROG'
* there are no entries in TADIR)
  IF NOT MODIFIED_PROGS[] IS INITIAL.
    SELECT * FROM TADIR
    APPENDING TABLE GT_TADIR
    FOR ALL ENTRIES IN MODIFIED_PROGS
    WHERE PGMID = 'R3TR' AND OBJECT = 'PROG' AND
          OBJ_NAME = MODIFIED_PROGS-OBJ_NAME.
  ENDIF.
  SORT GT_TADIR.
  DELETE ADJACENT DUPLICATES FROM GT_TADIR.
ENDFORM.                    "ADD_SMODILOG_PROGRAMS

 FORM EXTRACT_MODULE_APP_COMP.
 ENDFORM.

 FORM EXTRACT_HR_DATA.
 ENDFORM.                    " extract_hr_data

 FORM EXTRACT_BUSINESS_OBJECTS.
 ENDFORM.                    " extract_business_objects

 FORM EXTRACT_REL_DEV_CLASS_COMP.
 ENDFORM.                    " EXTRACT_RELATION_DEV_CLASS_COMP

*---------------------------------------------------------------------*
*       FORM GET_FUGR_PROGRAM_NAME
*---------------------------------------------------------------------*
FORM GET_FUGR_PROGRAM_NAME
      USING    FUNCTION_GROUP_NAME LIKE  RS38L-INCLUDE
      CHANGING PROGRAM_NAME TYPE RS38L-INCLUDE
               NAME LIKE RS38L-INCLUDE
               NAMESPACE LIKE RS38L-NAMESPACE.

  CALL FUNCTION 'RS_NAME_SPLIT_NAMESPACE'
    EXPORTING
      NAME_WITH_NAMESPACE    = FUNCTION_GROUP_NAME
    IMPORTING
      NAMESPACE              = NAMESPACE
      NAME_WITHOUT_NAMESPACE = NAME
    EXCEPTIONS
      DELIMITER_ERROR        = 1
      OTHERS                 = 2.
  IF SY-SUBRC <> 0.
    NAMESPACE = ''.
  ENDIF.

  IF NAME CP 'SAPL*'.
    CONCATENATE NAMESPACE NAME INTO PROGRAM_NAME.
  ELSE.
    CONCATENATE NAMESPACE 'SAPL' NAME INTO PROGRAM_NAME.
  ENDIF.

ENDFORM.                    "get_fugr_program_name
*---------------------------------------------------------------------*
*       FORM extract_functions
*---------------------------------------------------------------------*
FORM EXTRACT_FUNCTIONS.

  DATA: LT_FUNC            TYPE T_FUNCTION_TYPE,
        TITLE_NODE         TYPE XML_ELEMENT,
        FUNCTIONS_NODE     TYPE XML_ELEMENT,
        LT_FUNCTIONS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LT_OBJ_FUNC        TYPE TABLE OF RSEUI_SET,
        LS_OBJ_PROG        TYPE RSEUI_SET,
        LV_PROGNAME        TYPE RPY_PROG-PROGNAME,
        LV_FUGR            LIKE RS38L-INCLUDE,
        LT_INCLUDE         TYPE TABLE OF RPY_REPO WITH HEADER LINE,
        LT_FUPARAREF       TYPE TABLE OF FUPARAREF.

* For Function: RPY_FUNCTIONMODULE_READ/RPY_FUNCTIONMODULE_READ_NEW
  DATA: LV_GLOBAL_FLAG        LIKE RS38L-GLOBAL,
        LV_REMOTE_CALL        LIKE RS38L-REMOTE,
        LV_UPDATE_TASK        LIKE RS38L-UTASK,
        LV_SHORT_TEXT         LIKE TFTIT-STEXT,
        LV_FUNCTION_POOL      LIKE RS38L-AREA,
        LT_IMPORT_PARAMETER   TYPE TABLE OF RSIMP,
        LT_CHANGING_PARAMETER TYPE TABLE OF RSCHA,
        LT_EXPORT_PARAMETER   TYPE TABLE OF RSEXP,
        LT_TABLES_PARAMETER   TYPE TABLE OF RSTBL,
        LT_EXCEPTION_LIST     TYPE TABLE OF RSEXC,
        LT_DOCUMENTATION      TYPE TABLE OF RSFDO,
        LT_SOURCE             TYPE TABLE OF T_FUNCTION_SOURCE ,
        LV_PNAME              TYPE TFDIR-PNAME,
        RC                    LIKE SY-SUBRC,
        FUGR_NAME_PART        LIKE RS38L-INCLUDE,
        FUGR_NAMESPACE        LIKE RS38L-NAMESPACE,
        UXX_INCLUDE           TYPE TFDIR-PNAME,
        FLAG                  TYPE BOOLEAN,
        INCLUDE_NAME          LIKE D010INC-INCLUDE,
        FUNCNAME              LIKE  RS38L-NAME,
        FUNC_INCLUDE          LIKE  RS38L-INCLUDE,
        INC_NAME              LIKE TRDIR-NAME.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  FIELD-SYMBOLS: <LS_FUNC> LIKE LINE OF LT_FUNC.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.
  PERFORM UPDATE_PROGRESS USING
'Extracting function groups & function modules'. "#EC NOTEXT

* Add ALL function group includes to the programs list
* ----------------------------------------------------
  LOOP AT GT_OBJ_FUNC INTO GS_OBJECTLIST.

*   Get the function group's program name
    LV_FUGR = GS_OBJECTLIST-OBJ_NAME.
    PERFORM GET_FUGR_PROGRAM_NAME USING LV_FUGR
                                  CHANGING LV_PROGNAME
                                           FUGR_NAME_PART
                                           FUGR_NAMESPACE.

*   Get the function modules of the current func. group
    SELECT * FROM TFDIR
    APPENDING CORRESPONDING FIELDS OF TABLE LT_FUNC
    WHERE  PNAME = LV_PROGNAME.

*   Continue collecting function group includes only if the current
*   processed
*   function group is not a fugr of an ABAP query. (includes of AQ are
*   added as programs in a previous step)
*   Pay attention that the function modules of the function group are
*   collected
    CHECK LV_FUGR NP '/1BCDWB/IQ*'.

*   Add Function group's program to the list of programs - will
*   be read with the rest of the programs
    CLEAR LS_OBJ_PROG.
    LS_OBJ_PROG-OBJ_TYPE = 'PROG'.
    LS_OBJ_PROG-OBJ_NAME = LV_PROGNAME.
    APPEND LS_OBJ_PROG TO GT_OBJ_PROG.

*   Add the UXX include (doesn't return in function group includes list)
    CONCATENATE FUGR_NAMESPACE 'L' FUGR_NAME_PART 'UXX' INTO
           UXX_INCLUDE.
    LS_OBJ_PROG-OBJ_NAME = UXX_INCLUDE.
    APPEND LS_OBJ_PROG TO GT_OBJ_PROG.

*   Get the function group includes
    REFRESH LT_INCLUDE.

*   Get active include
    SELECT INCLUDE FROM D010INC
    INTO   INCLUDE_NAME
    WHERE MASTER = LV_PROGNAME
    AND   INCLUDE NOT LIKE 'L%V__'
    AND   INCLUDE NOT LIKE 'L%$__'.
      LT_INCLUDE-INCLNAME = INCLUDE_NAME.
      APPEND LT_INCLUDE.
    ENDSELECT.

*   Get inactive include
    SELECT INCLUDE FROM RSEUINC
    INTO   INCLUDE_NAME
    WHERE MASTER = LV_PROGNAME
    AND   INCLUDE NOT LIKE 'L%V__'
    AND   INCLUDE NOT LIKE 'L%$__'.
      LT_INCLUDE-INCLNAME = INCLUDE_NAME.
      APPEND LT_INCLUDE.
    ENDSELECT.

    IF LT_INCLUDE[] IS INITIAL.

      PERFORM READ_PROGRAM_INCLUDES TABLES LT_INCLUDE
                                    USING LV_PROGNAME.

      IF LT_INCLUDE[] IS INITIAL.
        CONCATENATE 'FUGRINC: ' LV_PROGNAME
'2. not found includes in db tables and in source scan' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      ELSE.
        CONCATENATE 'FUGRINC: ' LV_PROGNAME
'3. found includes in source scan' "#EC NOTEXT
INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      ENDIF.

    ELSE.
      CONCATENATE 'FUGRINC: ' LV_PROGNAME
      '1. found includes in db tables' "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
    ENDIF.

*   Add the function group includes as programs,
*   In the case of vanilla extraction, add standard
*   includes instead of customer's.
    LOOP AT LT_INCLUDE.
      PERFORM IS_CUSTOMER_DEV_INCLUDE USING LT_INCLUDE-INCLNAME
                                      CHANGING FLAG.
      IF ( FLAG NE VANILLA ).
        LS_OBJ_PROG-OBJ_NAME = LT_INCLUDE-INCLNAME.
        APPEND LS_OBJ_PROG TO GT_OBJ_PROG.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  FREE GT_OBJ_FUNC.

  CHECK NOT LT_FUNC[] IS INITIAL.
  SORT LT_FUNC.
* Get all functions for Extracting BTE user exits
  PERFORM GET_BTE_USER_EXITS USING LT_FUNC.

* Create a child node for the Functions node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'FUNCTIONS'
                          CHANGING FUNCTIONS_NODE.

* Add Functions data
  PERFORM ADD_ITAB_TO_XML TABLES LT_FUNC LT_FUNCTIONS_NODES
                          USING G_IREF_PDOCUMENT FUNCTIONS_NODE
                                'FUNCTION'.

  PERFORM APPEND_STRING_TO_FILE USING '<FUNCTIONS>'.

* Extract the function modules data to the xml
* --------------------------------------------
  LOOP AT LT_FUNCTIONS_NODES.

    ASSIGN LT_FUNCTIONS_NODES-WA->* TO <LS_FUNC>.
    CHECK SY-SUBRC = 0.

    CLEAR: LV_GLOBAL_FLAG, LV_REMOTE_CALL, LV_UPDATE_TASK,
           LV_SHORT_TEXT, LV_FUNCTION_POOL.
    FREE:  LT_IMPORT_PARAMETER, LT_CHANGING_PARAMETER,
           LT_EXPORT_PARAMETER, LT_TABLES_PARAMETER,
           LT_EXCEPTION_LIST, LT_DOCUMENTATION, LT_SOURCE.

*   Get function parameters
    SELECT *
    FROM   FUPARAREF
    INTO   TABLE LT_FUPARAREF
    WHERE  FUNCNAME = <LS_FUNC>-FUNCNAME.

*   Get Function meta data
    PERFORM READ_FUNCTION_MODULE_INTERFACE
                                 TABLES LT_IMPORT_PARAMETER
                                        LT_CHANGING_PARAMETER
                                        LT_EXPORT_PARAMETER
                                        LT_TABLES_PARAMETER
                                        LT_EXCEPTION_LIST
                                        LT_DOCUMENTATION
                                        LT_SOURCE
                                 USING  <LS_FUNC>-FUNCNAME
                                 CHANGING LV_GLOBAL_FLAG
                                          LV_REMOTE_CALL
                                          LV_UPDATE_TASK
                                          LV_SHORT_TEXT
                                          LV_FUNCTION_POOL
                                          RC.
    IF RC <> 0.
      CLEAR ERROR.
      CASE RC.
        WHEN 1. ERROR = 'error_message'. "#EC NOTEXT
        WHEN 2. ERROR = 'function_not_found'. "#EC NOTEXT
        WHEN 3. ERROR = 'invalid_name'. "#EC NOTEXT
        WHEN 4. ERROR = 'others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
'extract functions: read_function_module_interface, ' "#EC NOTEXT
'function:' "#EC NOTEXT
<LS_FUNC>-FUNCNAME 'Error:'  "#EC NOTEXT
ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
        SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    CHECK RC = 0.

*   Get the function group of the current function module
    SELECT SINGLE PNAME FROM TFDIR
    INTO LV_PNAME
    WHERE  FUNCNAME = <LS_FUNC>-FUNCNAME.
    IF SY-SUBRC = 0.
      PERFORM GET_FUGR_FROM_FUGR_PROG USING LV_PNAME
                                     CHANGING LV_FUGR.
    ELSE.
      CLEAR LV_FUGR.
    ENDIF.

*   Find the function's include file name
    FUNCNAME = <LS_FUNC>-FUNCNAME.
    CALL FUNCTION 'FUNCTION_INCLUDE_INFO'
      CHANGING
        FUNCNAME            = FUNCNAME
        INCLUDE             = FUNC_INCLUDE
      EXCEPTIONS
        FUNCTION_NOT_EXISTS = 1
        INCLUDE_NOT_EXISTS  = 2
        GROUP_NOT_EXISTS    = 3
        NO_SELECTIONS       = 4
        NO_FUNCTION_INCLUDE = 5
        OTHERS              = 6.

    IF SY-SUBRC <> 0.
    ENDIF.

*   Add Function meta data - Parameters
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                        'GLOBAL_FLAG' LV_GLOBAL_FLAG.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                        'REMOTE_CALL' LV_REMOTE_CALL.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                        'UPDATE_TASK' LV_UPDATE_TASK.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                        'SHORT_TEXT' LV_SHORT_TEXT.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                       'FUNCTION_POOL' LV_FUGR.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
                                       'INCLUDE_NAME' FUNC_INCLUDE.

*   Create node for parameters table
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LT_FUNCTIONS_NODES-NODE_REF
                                  'PARAMETERS_TABLE'
                            CHANGING TITLE_NODE.

*   Add the function parameters table to the XML
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FUPARAREF
                            USING G_IREF_PDOCUMENT TITLE_NODE
                                  'FUPARAREF'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                       LT_FUNCTIONS_NODES-NODE_REF 'X'.
    DELETE LT_FUNCTIONS_NODES.

  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '</FUNCTIONS>'.

  PERFORM ADD_TIME_STAT USING 'Extract functions' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                          " extract_functions
*&---------------------------------------------------------------------*
*&      Form  GET_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM GET_BTE_USER_EXITS USING I_FUNC_BTE TYPE T_FUNCTION_TYPE.
  DATA: LS_BTE_UE   TYPE T_BTE_UE.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  DATA: LT_TBE02 TYPE TABLE OF TBE02,
        LV_TEXT1 TYPE TBE01T-TEXT1,
        LV_XLBSE TYPE TBE01-XLBSE.

  DATA: LT_FMRFC TYPE TABLE OF FMRFC,
        LT_FMSAP TYPE TABLE OF FMSAP,
        LT_FMPRT TYPE TABLE OF FMPRT,
        LT_FMCUS TYPE TABLE OF FMCUS.

  DATA: LT_TPS02 TYPE TABLE OF TPS02.

  DATA: LT_APSAP TYPE TABLE OF APSAP,
        LT_APPRT TYPE TABLE OF APPRT,
        LT_APCUS TYPE TABLE OF APCUS.

  FIELD-SYMBOLS: <TBE02> LIKE LINE OF LT_TBE02,
                 <FMRFC> LIKE LINE OF LT_FMRFC,
                 <FMSAP> LIKE LINE OF LT_FMSAP,
                 <FMPRT> LIKE LINE OF LT_FMPRT,
                 <FMCUS> LIKE LINE OF LT_FMCUS.

  FIELD-SYMBOLS: <TPS02> LIKE LINE OF LT_TPS02,
                 <APSAP> LIKE LINE OF LT_APSAP,
                 <APPRT> LIKE LINE OF LT_APPRT,
                 <APCUS> LIKE LINE OF LT_APCUS.

  FIELD-SYMBOLS: <BTE_UE> LIKE LINE OF GT_BTE_UE.

  CHECK NO_SUET_DATA IS INITIAL.

  SELECT DISTINCT EVENT FROM TBE02
  INTO CORRESPONDING FIELDS OF TABLE LT_TBE02
  WHERE ATTR_TYPE = 'A'.

  LOOP AT LT_TBE02 ASSIGNING <TBE02>.
    CLEAR: LS_BTE_UE, LV_XLBSE, LV_TEXT1,
           LT_FMRFC[], LT_FMSAP[], LT_FMPRT[], LT_FMCUS[].

*   Get XLBSE from tbe01
    SELECT SINGLE XLBSE FROM TBE01
    INTO LV_XLBSE
    WHERE EVENT = <TBE02>-EVENT.

*   Get text1 from tbe01t
    SELECT SINGLE TEXT1 FROM TBE01T
    INTO LV_TEXT1
    WHERE EVENT = <TBE02>-EVENT
    AND   SPRAS = SY-LANGU.

    LS_BTE_UE-EVENT = <TBE02>-EVENT.
    LS_BTE_UE-TEXT1 = LV_TEXT1.

    IF LV_XLBSE IS INITIAL.
      CALL FUNCTION 'BF_FUNCTIONS_FIND'
        EXPORTING
          I_EVENT       = <TBE02>-EVENT
        TABLES
          T_FMRFC       = LT_FMRFC
        EXCEPTIONS
          NOTHING_FOUND = 1
          OTHERS        = 2.

      LOOP AT LT_FMRFC ASSIGNING <FMRFC>.
        LS_BTE_UE-STDFB = <FMRFC>-FUNCT.
        APPEND LS_BTE_UE TO GT_BTE_UE.
      ENDLOOP.

    ELSE.
      CALL FUNCTION 'BF_FUNCTIONS_READ'
        EXPORTING
          I_EVENT    = <TBE02>-EVENT
          I_NO_XLBSE = 'X'
        TABLES
          T_FMSAP    = LT_FMSAP
          T_FMPRT    = LT_FMPRT
          T_FMCUS    = LT_FMCUS.

      LOOP AT LT_FMSAP ASSIGNING <FMSAP> WHERE EVENT = <TBE02>-EVENT.
        LS_BTE_UE-STDFB = <FMSAP>-FUNCT.
        APPEND LS_BTE_UE TO GT_BTE_UE.
      ENDLOOP.

      LOOP AT LT_FMPRT ASSIGNING <FMPRT> WHERE EVENT = <TBE02>-EVENT.
        LS_BTE_UE-STDFB = <FMPRT>-FUNCT.
        APPEND LS_BTE_UE TO GT_BTE_UE.
      ENDLOOP.

      LOOP AT LT_FMCUS ASSIGNING <FMCUS> WHERE EVENT = <TBE02>-EVENT.
        LS_BTE_UE-STDFB = <FMCUS>-FUNCT.
        APPEND LS_BTE_UE TO GT_BTE_UE.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

  SELECT DISTINCT PROCS FROM TPS02
  INTO CORRESPONDING FIELDS OF TABLE LT_TPS02
  WHERE ATTR_TYPE = 'A'.

  LOOP AT LT_TPS02 ASSIGNING <TPS02>.
    CLEAR: LS_BTE_UE, LV_XLBSE, LV_TEXT1,
           LT_APSAP[], LT_APPRT[], LT_APCUS[].

    SELECT SINGLE XLBSE FROM TPS01
    INTO LV_XLBSE
    WHERE PROCS = <TPS02>-PROCS.

    SELECT SINGLE TEXT1 FROM TPS01T
    INTO LV_TEXT1
    WHERE PROCS = <TPS02>-PROCS
    AND   SPRAS = SY-LANGU.

    LS_BTE_UE-EVENT = <TPS02>-PROCS.
    LS_BTE_UE-TEXT1 = LV_TEXT1.

    IF LV_XLBSE IS INITIAL.
      CALL FUNCTION 'PC_FUNCTIONS_READ'
        EXPORTING
          I_PROCS = <TPS02>-PROCS
        TABLES
          T_FMSAP = LT_APSAP
          T_FMPRT = LT_APPRT
          T_FMCUS = LT_APCUS.
    ELSE.
      CALL FUNCTION 'PC_FUNCTIONS_READ'
        EXPORTING
          I_PROCS    = <TPS02>-PROCS
          I_NO_XLBSE = 'X'
        TABLES
          T_FMSAP    = LT_APSAP
          T_FMPRT    = LT_APPRT
          T_FMCUS    = LT_APCUS.
    ENDIF.

    LOOP AT LT_APSAP ASSIGNING <APSAP> WHERE PROCS = <TPS02>-PROCS.
      LS_BTE_UE-STDFB = <APSAP>-FUNCT.
      APPEND LS_BTE_UE TO GT_BTE_UE.
    ENDLOOP.

    LOOP AT LT_APPRT ASSIGNING <APPRT> WHERE PROCS = <TPS02>-PROCS.
      LS_BTE_UE-STDFB = <APPRT>-FUNCT.
      APPEND LS_BTE_UE TO GT_BTE_UE.
    ENDLOOP.

    LOOP AT LT_APCUS ASSIGNING <APCUS> WHERE PROCS = <TPS02>-PROCS.
      LS_BTE_UE-STDFB = <APCUS>-FUNCT.
      APPEND LS_BTE_UE TO GT_BTE_UE.
    ENDLOOP.
  ENDLOOP.

* Delete records that dont have a customer FM
  LOOP AT GT_BTE_UE ASSIGNING <BTE_UE>.
    READ TABLE I_FUNC_BTE WITH KEY FUNCNAME = <BTE_UE>-STDFB
      BINARY SEARCH TRANSPORTING NO FIELDS.
    IF SY-SUBRC <> 0.
      DELETE GT_BTE_UE.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " GET_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*&      Form  READ_PROGRAM_INCLUDES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_INCLUDE  text
*      -->P_LV_PROGNAME  text
*----------------------------------------------------------------------*
FORM READ_PROGRAM_INCLUDES TABLES INCLUDE_TABLE
                            USING INCLNAME LIKE TRDIR-NAME.

** !! code from: RS_GET_LOW_LEVEL_INCLUDES (not for programs only)
  DATA: SEDI_TK TYPE  STOKESX OCCURS 0.
  DATA: TK LIKE SEDI_TK WITH HEADER LINE.
  DATA: TK_INDEX     LIKE SY-TABIX,
        INCL         LIKE TRDIR-NAME,
        DEVCLASS     LIKE TADIR-DEVCLASS,
        SOURCE_TABLE TYPE RSWSOURCET,
        MSG(132),
        WRD(30),
        ROW          LIKE TK-ROW,
        COL          LIKE TK-COL.
  DATA: BEGIN OF KW OCCURS 10,
          LINE(30),
        END OF KW.
  DATA  BEGIN OF STM OCCURS 1000.
          INCLUDE STRUCTURE SSTMNT.
  DATA  END OF STM.
  DATA  BEGIN OF LV OCCURS 100.
          INCLUDE STRUCTURE SLEVEL.
  DATA  END OF LV.
  DATA: TRDIR_WA LIKE TRDIR.

  REFRESH INCLUDE_TABLE.

  READ REPORT INCLNAME INTO SOURCE_TABLE.
  REFRESH: KW, TK, STM, LV. CLEAR: KW, TK, STM, LV.

  KW = 'INCLUDE'.            APPEND KW.
  SCAN ABAP-SOURCE SOURCE_TABLE
                           TOKENS     INTO TK
                           STATEMENTS INTO STM
                           LEVELS     INTO LV
*                          OVERFLOW INTO OVERFLOW_AREA
           KEYWORDS FROM KW
*          program from src_name
           WITH ANALYSIS
           WITH INCLUDES
           WITHOUT TRMAC
           MESSAGE INTO MSG
           WORD    INTO WRD
           INCLUDE INTO INCL
           LINE    INTO ROW
           OFFSET  INTO COL.

  IF NOT SY-SUBRC IS INITIAL.
    EXIT.
  ENDIF.

  LOOP AT STM.
    READ TABLE TK INDEX STM-FROM.
    IF TK-STR = 'INCLUDE'.
      TK_INDEX = STM-FROM + 1.
      READ TABLE TK INDEX TK_INDEX.
      IF TK-STR NE 'STRUCTURE' AND TK-STR NE 'TYPE' AND
         TK-STR(1) NE '<' AND TK-STR(1) NE '>' AND TK-STR(1) NE '%' .
        INCLUDE_TABLE = TK-STR.
        SELECT SINGLE * FROM TRDIR INTO TRDIR_WA
          WHERE NAME = INCLUDE_TABLE.
        IF SY-SUBRC = 0.
          APPEND INCLUDE_TABLE.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                   " READ_PROGRAM_INCLUDES

*---------------------------------------------------------------------*
*       FORM get_class_data
*---------------------------------------------------------------------*
FORM GET_CLASS_DATA TABLES METHODS_INCLUDES STRUCTURE  RPY_REPO
                    USING CLSNAME TYPE  SEOCLSNAME
                    CHANGING MAIN_INCLUDE_NAME TYPE PROGRAMM.

  DATA: CLASSKEY         TYPE SEOCLSKEY,
        SOURCE_LINE      TYPE EDPLINE,
        MAIN_INC_TYPE(2) TYPE C,
        TADIR_REC        LIKE TADIR,
        OBJ_NAME         TYPE TROBJ_NAME,
        OREF             TYPE REF TO IF_OO_CLASS_INCL_NAMING,
        MTDS_W_INCL      TYPE SEOP_METHODS_W_INCLUDE,
        MTDS_REC         TYPE LINE OF SEOP_METHODS_W_INCLUDE,
        SECTION          TYPE TROBJTYPE,
        INCLUDE          TYPE PROGRAMM,
        APPENDAGE        TYPE SEOP_INCLUDE_APPENDAGE,
        TMDIR_REC        TYPE TMDIR.


  CLASS CL_OO_INCLUDE_NAMING DEFINITION LOAD.

* Check if this is a class or an interface and determine the main
* include type accordingly
  SELECT SINGLE *
  FROM TADIR
  INTO TADIR_REC
  WHERE OBJ_NAME = CLSNAME AND
        ( OBJECT = SEOK_R3TR_CLASS OR
          OBJECT = SEOK_R3TR_INTERFACE ).                   "#EC WARNOK

  IF NOT SY-SUBRC IS INITIAL.
    EXIT.
  ENDIF.

* Check if there are implemented methods to this class. If not -
* don't continue.
  SELECT SINGLE *
  FROM TMDIR
  INTO TMDIR_REC
  WHERE CLASSNAME = CLSNAME.

  IF NOT SY-SUBRC IS INITIAL.
    EXIT.
  ENDIF.

* Get the class name
  OBJ_NAME = TADIR_REC-OBJ_NAME.
  OREF ?= CL_OO_INCLUDE_NAMING=>GET_INSTANCE_BY_TRKEY(
            PGMID = TADIR_REC-PGMID
            OBJECT = TADIR_REC-OBJECT
            OBJ_NAME = OBJ_NAME ).

  MAIN_INCLUDE_NAME = OREF->CLASS_POOL.


* If class source was not found - raise exception.
  IF SY-SUBRC <> 0.
    RAISE CLASS_WAS_NOT_FOUND.
  ENDIF.

* Get the includes of the methods
  MTDS_W_INCL = OREF->GET_ALL_METHOD_INCLUDES( ).

  LOOP AT MTDS_W_INCL INTO MTDS_REC.
    APPEND MTDS_REC-INCNAME TO METHODS_INCLUDES.
  ENDLOOP.

* Get public
  SECTION = 'CPUB'.
  INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
  APPEND INCLUDE TO METHODS_INCLUDES.

* Get private
  SECTION = 'CPRI'.
  INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
  APPEND INCLUDE TO METHODS_INCLUDES.

* Get protected
  SECTION = 'CPRO'.
  INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
  APPEND INCLUDE TO METHODS_INCLUDES.

* Add type and locals
  INCLUDE = OREF->TYPE_DEP.
  APPEND INCLUDE TO METHODS_INCLUDES.
  INCLUDE = OREF->LOCALS_OLD.
  APPEND INCLUDE TO METHODS_INCLUDES.

* Get class locals
  APPENDAGE = 'DEF'.
  INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
  APPEND INCLUDE TO METHODS_INCLUDES.
  APPENDAGE = 'IMP'.
  INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
  APPEND INCLUDE TO METHODS_INCLUDES.
  APPENDAGE = 'MAC'.
  INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
  APPEND INCLUDE TO METHODS_INCLUDES.

ENDFORM.                    "GET_CLASS_DATA

*---------------------------------------------------------------------*
*       FORM extract_programs
*---------------------------------------------------------------------*
FORM EXTRACT_PROGRAMS.

  DATA: LT_PROG            TYPE LT_PROG_TYPE WITH HEADER LINE,
        LT_PROGRAMS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LS_PROGRAM_NODE    LIKE LINE OF LT_PROGRAMS_NODES,
        PROGRAMS_NODE      TYPE XML_ELEMENT,
        LV_IS_WITH_SOUCE_EXT  TYPE C,
        GET_PROGRAM_DATA   TYPE C,

        CLASS_NAME TYPE SEOCLSNAME,
        METHODS_INCLUDES TYPE TABLE OF RPY_REPO,
        CURR_INCLUDE TYPE RPY_REPO,
        MAIN_INCLUDE_NAME TYPE PROGRAMM,
        CLASS_INCLUDES TYPE PROG_TAB_TYPE,
        CLASS_INCLUDES_WA LIKE LINE OF CLASS_INCLUDES,
        PROG_NUM TYPE I,
        PROG_NUM_TEXT TYPE STRING,
        PROG_COUNTER TYPE I,
        PROG_BULK TYPE I,
        PROG_BULK_MOD TYPE I,
        PROG_BULK_STR TYPE STRING.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.
  RANGES: R_NAME FOR TRDIR-NAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting programs'. "#EC NOTEXT

  SORT GT_OBJ_PROG.
  DELETE ADJACENT DUPLICATES FROM GT_OBJ_PROG.

* Set Object list
  LOOP AT GT_OBJ_PROG INTO GS_OBJECTLIST.
    CLEAR R_NAME.
    R_NAME-SIGN   = 'I'.
    R_NAME-OPTION = 'EQ'.
    R_NAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_NAME.
  ENDLOOP.

* Pay attention !!! extract functions/dev. classes uses this global
* data, so make sure that the 'free' occurs AFTER these extractions
  FREE GT_OBJ_PROG.

* Add also type group programs
  LOOP AT GT_OBJ_TYPEPOOL INTO GS_OBJECTLIST.
    CLEAR R_NAME.
    R_NAME-SIGN   = 'I'.
    R_NAME-OPTION = 'EQ'.
    CONCATENATE '%_C' GS_OBJECTLIST-OBJ_NAME INTO R_NAME-LOW.
    APPEND R_NAME.
  ENDLOOP.

* Add object oriented
  LOOP AT GT_OBJ_CLAS INTO GS_OBJECTLIST.
    CLASS_NAME = GS_OBJECTLIST-OBJ_NAME.
    CLEAR METHODS_INCLUDES[].
    PERFORM GET_CLASS_DATA TABLES METHODS_INCLUDES
                           USING CLASS_NAME
                           CHANGING MAIN_INCLUDE_NAME.

    IF ( NOT MAIN_INCLUDE_NAME IS INITIAL ).
      R_NAME-SIGN   = 'I'.
      R_NAME-OPTION = 'EQ'.
      R_NAME-LOW = MAIN_INCLUDE_NAME.
      APPEND R_NAME.
    ENDIF.

    LOOP AT METHODS_INCLUDES INTO CURR_INCLUDE.
      R_NAME-LOW = CURR_INCLUDE-INCLNAME.
      APPEND R_NAME.

      CLASS_INCLUDES_WA-PROG = CURR_INCLUDE-INCLNAME.
      APPEND CLASS_INCLUDES_WA TO CLASS_INCLUDES.
    ENDLOOP.

  ENDLOOP.
  SORT CLASS_INCLUDES BY PROG.
  DELETE ADJACENT DUPLICATES FROM CLASS_INCLUDES.

* remove user excluded programs
  IF NOT S_PRGEXC[] IS INITIAL.
    DELETE R_NAME WHERE LOW IN S_PRGEXC[].
  ENDIF.

  CHECK NOT R_NAME[] IS INITIAL.

  SORT G_PROGS_ADDED_BY_SMODILOG.
  SORT R_NAME.

* Check support to source_extendend variable in RPY_PROGRAM_READ
  PERFORM CHECK_SOURCE_EXT_SUPPORT CHANGING LV_IS_WITH_SOUCE_EXT.

* Save program names for filtering vanilla programs
* with customer variants
  G_CUST_PROGS[] = R_NAME[].

* Get the Programs data
  IF NOT R_NAME[] IS INITIAL.
    IF NOT EXTRACT_DEBUG IS INITIAL.

      DATA: MESSAGE_STR TYPE STRING.

      PERFORM EXTRACT_R_NAME TABLES R_NAME.
      LOOP AT R_NAME.
        CONCATENATE 'DEBUG!Prog Range,program name -' "#EC NOTEXT
        R_NAME-LOW
          INTO MESSAGE_STR.
        PERFORM ADD_MESSAGE USING MESSAGE_STR ABAP_TRUE.
      ENDLOOP.
    ENDIF.

    DESCRIBE TABLE R_NAME LINES PROG_NUM.
    PROG_NUM_TEXT = PROG_NUM.
    CLEAR MESSAGE_STR.
    CONCATENATE 'Number of programs to extract: ' "#EC NOTEXT
    PROG_NUM_TEXT
    INTO MESSAGE_STR SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING MESSAGE_STR ABAP_TRUE.

*   Create a child node for the Programs node
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'PROGRAMS'
                            CHANGING PROGRAMS_NODE.

    PERFORM APPEND_STRING_TO_FILE USING '<PROGRAMS>'.

    SELECT * FROM TRDIR
    INTO CORRESPONDING FIELDS OF TABLE LT_PROG
    FOR ALL ENTRIES IN R_NAME
    WHERE NAME = R_NAME-LOW AND
          SUBC <> 'X'.

    FREE R_NAME.

    LOOP AT LT_PROG.

*     Set 'added by smodilog' flag
      READ TABLE G_PROGS_ADDED_BY_SMODILOG BINARY SEARCH
                                  WITH KEY PROG = LT_PROG-NAME.
      IF SY-SUBRC IS INITIAL.
        LT_PROG-ADDED_BY_SMODILOG = 'X'.
        MODIFY LT_PROG.
      ENDIF.
    ENDLOOP.

    PERFORM ADD_MESSAGE USING '*** ALL programs packet' "#EC NOTEXT
    ABAP_TRUE.
    PERFORM ADD_USED_MEMORY_TO_LOG.

*   Add the Programs data to the current node
    PERFORM ADD_ITAB_TO_XML TABLES LT_PROG LT_PROGRAMS_NODES
                            USING G_IREF_PDOCUMENT PROGRAMS_NODE
                                  'PROGRAM'.
    FREE LT_PROG.

    LOOP AT LT_PROGRAMS_NODES INTO LS_PROGRAM_NODE.

      ASSIGN LS_PROGRAM_NODE-WA->* TO <LS_PROG>.
      IF <LS_PROG> IS ASSIGNED.
        IF <LS_PROG>-NAME IS INITIAL OR <LS_PROG>-NAME EQ SPACE.
          CONCATENATE 'PROG: ' <LS_PROG>-NAME ' is nameless' "#EC NOTEXT
                INTO GT_ETL_MESSAGE-MESSAGE.

          PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
          CALL METHOD LS_PROGRAM_NODE-NODE_REF->REMOVE_NODE.
          CLEAR LS_PROGRAM_NODE-NODE_REF.

          CONTINUE.
        ENDIF.
      ENDIF.

      PROG_COUNTER = PROG_COUNTER + 1.

      IF NOT EXTRACT_DEBUG IS INITIAL.
        ASSIGN LS_PROGRAM_NODE-WA->* TO <LS_PROG>.
        CONCATENATE 'PROG: ' <LS_PROG>-NAME INTO GT_ETL_MESSAGE-MESSAGE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ENDIF.

      PROG_BULK_MOD = PROG_COUNTER MOD PAC_SIZE.
      IF ( PROG_BULK_MOD = 1 ).
        PROG_BULK = PROG_BULK + 1.
        PROG_BULK_STR = PROG_BULK.
        CONCATENATE 'Prog bulk ' PROG_BULK_STR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
        PERFORM ADD_USED_MEMORY_TO_LOG.
      ENDIF.

      GET_PROGRAM_DATA = 'X'.

*     Don't get abap query programs if not needed
      IF ADD_ABAP_QUERIES = SPACE.
        ASSIGN LS_PROGRAM_NODE-WA->* TO <LS_PROG>.
        READ TABLE ABAP_QUERY_PROGS WITH KEY OBJ_NAME = <LS_PROG>-NAME
                                  BINARY SEARCH TRANSPORTING NO FIELDS.

*     Add the abap query program header (don't get more program data)
        IF SY-SUBRC IS INITIAL.
          CLEAR GET_PROGRAM_DATA.
        ENDIF.
      ENDIF.

*     Add Program's titles anyway ( even in case of ABAP Query )
      PERFORM GET_PROGRAM_TEXTS USING LS_PROGRAM_NODE.

      IF GET_PROGRAM_DATA = 'X'.
*       Add Program's Screens
        PERFORM GET_PROGRAM_SCREENS    USING  LS_PROGRAM_NODE.
*       Add Program's GUI status
        IF DISABLE_GUI_STATUS_EXTRACT IS INITIAL.
          PERFORM GET_PROGRAM_GUI_STATUS_WRAP USING  LS_PROGRAM_NODE.
        ENDIF.
*       Add Program's Mains
        PERFORM GET_PROGRAM_MAINS      USING  LS_PROGRAM_NODE.
*       Add Program's Source
        PERFORM GET_PROGRAM_SOURCE     TABLES CLASS_INCLUDES
                                        USING  LS_PROGRAM_NODE
                                              LV_IS_WITH_SOUCE_EXT.
*       Add Program's syntax check result
        IF DISABLE_SYNTAX_CHECK IS INITIAL.
          PERFORM GET_PROGRAM_SYNTAX_CHECK USING  LS_PROGRAM_NODE.
        ENDIF.

      ENDIF.

      PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                    LS_PROGRAM_NODE-NODE_REF 'X'.
      DELETE LT_PROGRAMS_NODES.

    ENDLOOP.

    PERFORM APPEND_STRING_TO_FILE USING '</PROGRAMS>'.

  ENDIF.

  PERFORM ADD_TIME_STAT USING 'Extract programs' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                          " extract_programs

*&---------------------------------------------------------------------*
*&      Form  extract_r_name
*&---------------------------------------------------------------------*
FORM EXTRACT_R_NAME TABLES R_NAME.
  PERFORM APPEND_STRING_TO_FILE USING '<R_NAMES>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES R_NAME
                                  USING  G_IREF_PDOCUMENT
                                         'R_NAME'.
  PERFORM APPEND_STRING_TO_FILE USING '</R_NAMES>'.

ENDFORM.                          "extract_r_name

*&---------------------------------------------------------------------*
*&      Form  get_program_screens
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SCREENS USING  PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

  DATA: SCREENS_NODE    TYPE XML_ELEMENT,
        ELEMENTS_NODE   TYPE XML_ELEMENT,
        FLOW_LOGIC_NODE TYPE XML_ELEMENT.

  DATA: BEGIN OF LT_SCREENS OCCURS 0.
          INCLUDE STRUCTURE D020S.
  DATA:   DTXT LIKE D020V-DTXT,
        END OF LT_SCREENS,

        LT_D020T              TYPE TABLE OF D020T   WITH HEADER LINE,
        LT_SCREENS_NODES      TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        SCREEN_HEADER         LIKE D020S.

* For Function: RS_IMPORT_DYNPRO
  DATA: LT_FTAB               TYPE TABLE OF D021S   WITH HEADER LINE,
        LT_PLTAB              TYPE TABLE OF D022S   WITH HEADER LINE.
* For Function: RS_SCRP_GET_FIELD_TYPE_TEXT
  DATA: LV_FIELD_TYPE TYPE SCRFGTYP.
* For Function: RS_SCRP_GET_ALL_DIMENSIONS
  DATA: LV_LINE       TYPE I,
        LV_COLUMN     TYPE I,
        LV_VIS_LENGTH TYPE I.

  DATA: LV_NUMBER     TYPE I.
* For Foreign key active check
  DATA: FLG1DDF TYPE X VALUE '20',
        FLG3FOR TYPE X VALUE '04',
        FLG3FDU TYPE X VALUE '02',
        FLG3FKU TYPE X VALUE '08'.

  DATA: BEGIN OF LT_FTAB_EXT  OCCURS 0.
          INCLUDE STRUCTURE D021S.
  DATA:   LINE_NO        TYPE NUMC2,
          COLN_NO        TYPE NUMC2,
          LENG_NO        TYPE NUMC2,
          FIELD_TYPE     TYPE SCRFGTYP,
          FORKEY_ACTIVE  TYPE CHAR1,
          FUNTYPE        TYPE SCRFPTYPE,
          FUNCODE        TYPE CUA_FUNC,
        END OF LT_FTAB_EXT.

  DATA: LS_FUNKEY  TYPE D021S_RES1.
  DATA: LV_STRING  TYPE STRING,
        CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT.

  FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP,
                 <LS_SCREENS> LIKE LINE OF LT_SCREENS.

*--- Get Program's screens ---------------------------------------------
*   Create a node for the program screens
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'SCREENS'
                          CHANGING SCREENS_NODE.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

*   Get the current program's screens data
  SELECT * FROM  D020S
         INTO CORRESPONDING FIELDS OF TABLE LT_SCREENS
         WHERE  PROG  = <LS_PROG>-NAME.
  CHECK NOT LT_SCREENS[] IS INITIAL.
*   Get Screens text
  IF NOT LT_SCREENS[] IS INITIAL.
    SELECT * FROM  D020T
           INTO TABLE LT_D020T
           FOR ALL ENTRIES IN LT_SCREENS
           WHERE  PROG  = LT_SCREENS-PROG
           AND    LANG  = 'E'.
  ENDIF.
*   Set Screens text
  LOOP AT LT_SCREENS.
    GV_TABIX = SY-TABIX.
    READ TABLE LT_D020T WITH KEY DYNR = LT_SCREENS-DNUM.
    CHECK SY-SUBRC = 0.
    LT_SCREENS-DTXT = LT_D020T-DTXT.
    MODIFY LT_SCREENS INDEX GV_TABIX TRANSPORTING DTXT.
  ENDLOOP.

*   Add the screens data to the current screen tag
  PERFORM ADD_ITAB_TO_XML TABLES LT_SCREENS LT_SCREENS_NODES
                           USING G_IREF_PDOCUMENT SCREENS_NODE
                                 'SCREEN'.

*--- Get Screen's elements
  LOOP AT LT_SCREENS_NODES.

*   Create a node for the screen elements
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LT_SCREENS_NODES-NODE_REF
                                  'ELEMENTS'
                            CHANGING ELEMENTS_NODE.

    ASSIGN LT_SCREENS_NODES-WA->* TO <LS_SCREENS>.

    FREE: LT_FTAB,
          LT_FTAB_EXT,
          LT_PLTAB.

* Get the current screen's elements data
    CALL FUNCTION 'RS_IMPORT_DYNPRO'
         EXPORTING
              DYLANG               = 'E'
              DYNAME               = <LS_SCREENS>-PROG
              DYNUMB               = <LS_SCREENS>-DNUM
*             REQUEST              = ' '
*             SUPPRESS_CHECKS      = ' '
         IMPORTING
              HEADER               = SCREEN_HEADER
         TABLES
              FTAB                 = LT_FTAB
              PLTAB                = LT_PLTAB
         EXCEPTIONS
              BUTTON_ERROR         = 1
              DYLANGUAGE_INVALID   = 2
              DYLANGUAGE_NOT_INST  = 3
              DYNAME_INVALID       = 4
              DYNPROLOAD_NOT_FOUND = 5
              DYNPRO_OLD           = 6
              DYNUMB_INVALID       = 7
              FTAB_INVALID         = 8
              GEN_ERROR            = 9
              GEN_OK               = 10
              HEADER_INVALID       = 11
              INTERNAL_ERROR       = 12
              NO_DYNPRO            = 13
              NO_FTAB_ROW          = 14
              NO_MEMORY            = 15
              NO_PROCESSLOGIC      = 16
              PLTAB_INVALID        = 17
              REQUEST_INVALID      = 18
              OTHERS               = 19.
    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'button_error'. "#EC NOTEXT
        WHEN 2. ERROR = 'dylanguage_invalid'. "#EC NOTEXT
        WHEN 3. ERROR = 'dylanguage_not_inst'. "#EC NOTEXT
        WHEN 4. ERROR = 'dyname_invalid'. "#EC NOTEXT
        WHEN 5. ERROR = 'dynproload_not_found'. "#EC NOTEXT
        WHEN 6. ERROR = 'dynpro_old'. "#EC NOTEXT
        WHEN 7. ERROR = 'dynumb_invalid'. "#EC NOTEXT
        WHEN 8. ERROR = 'ftab_invalid'. "#EC NOTEXT
        WHEN 9. ERROR = 'gen_error'. "#EC NOTEXT
        WHEN 10. ERROR = 'gen_ok'. "#EC NOTEXT
        WHEN 11. ERROR = 'header_invalid'. "#EC NOTEXT
        WHEN 12. ERROR = 'internal_error'. "#EC NOTEXT
        WHEN 13. ERROR = 'no_dynpro'. "#EC NOTEXT
        WHEN 14. ERROR = 'no_ftab_row'. "#EC NOTEXT
        WHEN 15. ERROR = 'no_memory'. "#EC NOTEXT
        WHEN 16. ERROR = 'no_processlogic'. "#EC NOTEXT
        WHEN 17. ERROR = 'pltab_invalid'. "#EC NOTEXT
        WHEN 18. ERROR = 'request_invalid'. "#EC NOTEXT
        WHEN 19. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
      'extract programs: RS_IMPORT_DYNPRO, program:' "#EC NOTEXT
           <LS_SCREENS>-PROG 'Screen:' "#EC NOTEXT
           <LS_SCREENS>-DNUM 'Error:' ERROR "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    CHECK SY-SUBRC = 0.

*   Set LT_FTAB
    LOOP AT LT_FTAB.
      CLEAR LT_FTAB_EXT.
      MOVE-CORRESPONDING LT_FTAB TO LT_FTAB_EXT.

*     This field's data contains invalid chars. when transported to
*     the xml file
      CLEAR LT_FTAB_EXT-FMKY.

*     Get Field type
      CALL FUNCTION 'RS_SCRP_GET_FIELD_TYPE_TEXT'
        EXPORTING
          FIELD                    = LT_FTAB
*         TEXT_KIND                = 'LONG'
        IMPORTING
          FIELD_TYPE               = LT_FTAB_EXT-FIELD_TYPE.

      CLEAR: LV_LINE, LV_COLUMN, LV_VIS_LENGTH.
*     Get Field line, column, vis.langth,
      CALL FUNCTION 'RS_SCRP_GET_ALL_DIMENSIONS'
        EXPORTING
          DYNP_FIELD         = LT_FTAB
        IMPORTING
          LINE               = LV_LINE
          COLUMN             = LV_COLUMN
*         LENGTH             =
          VIS_LENGTH         = LV_VIS_LENGTH.
*         HIGHT              =
*         RELATIVE_POSITIONS =
      MOVE LV_LINE   TO LV_NUMBER.
      MOVE LV_NUMBER TO LT_FTAB_EXT-LINE_NO.

      MOVE LV_COLUMN TO LV_NUMBER.
      MOVE LV_NUMBER TO LT_FTAB_EXT-COLN_NO.

      MOVE LV_VIS_LENGTH TO LV_NUMBER.
      MOVE LV_NUMBER     TO LT_FTAB_EXT-LENG_NO.


*     Set the flag 'Foreign key active'
      IF    LT_FTAB-FLG1 O FLG1DDF
        AND LT_FTAB-FLG3 O FLG3FOR
        AND LT_FTAB-FLG3 Z FLG3FDU
        AND LT_FTAB-FLG3 Z FLG3FKU.
        LT_FTAB_EXT-FORKEY_ACTIVE = 'X'.
      ENDIF.

*     Set the 'Function code'
      LS_FUNKEY = LT_FTAB-RES1.
      IF NOT LS_FUNKEY-FUNCCODE IS INITIAL.
        LT_FTAB_EXT-FUNTYPE = LS_FUNKEY-FUNCTYPE.
        LT_FTAB_EXT-FUNCODE = LS_FUNKEY-FUNCCODE.
      ENDIF.

*     These fields' data may contain invalid chars. when transported to
*     the xml file
*      CLEAR LT_FTAB_EXT-RES1.
*      CLEAR LT_FTAB_EXT-RES2.

      APPEND LT_FTAB_EXT.

    ENDLOOP.

*   Add the screen Elements data to the current screen
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FTAB_EXT
                                   USING G_IREF_PDOCUMENT
                                         ELEMENTS_NODE
                                         'ELEMENT'.

*   Create a node for the screen Flow Logic
*    PERFORM create_xml_node USING g_iref_pdocument
*                                  lt_screens_nodes-node_ref
*                                  'FLOW_LOGIC'
*                            CHANGING flow_logic_node.

*   Export screen flow logic if the current screen is not a selection
*   screen
    IF SCREEN_HEADER-TYPE <> 'S'.

*     Set the Flow Logic lines to a string
      CLEAR LV_STRING.
      LOOP AT LT_PLTAB.
        CONCATENATE LV_STRING LT_PLTAB-LINE INTO LV_STRING
                    SEPARATED BY GV_ENDLINE.
      ENDLOOP.

*     Add the screen Flow Logic data to the current screen
      PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
                                              LT_SCREENS_NODES-NODE_REF
                                              'FLOW_LOGIC'
                                              LV_STRING 'X'
                                          CHANGING CDATA_ELEM.

    ENDIF.

  ENDLOOP.

ENDFORM.                    " get_program_screens

*&---------------------------------------------------------------------*
*&      Form  get_program_gui_status
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_GUI_STATUS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

  DATA: STATUSES_NODE     TYPE XML_ELEMENT,
        FKEYS_NODE        TYPE XML_ELEMENT,
        TREES_NODE        TYPE XML_ELEMENT.

  DATA: LT_STATUS_NODES   TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

* For Function: RS_CUA_STATUS
  DATA: LT_STATUS         TYPE TABLE OF  RLSEU0_DOK.
* For Function: RS_CUA_GET_STATUS
  DATA: LT_FKEYS          TYPE TABLE OF  RSEUL_KEYS  WITH HEADER LINE,
        LT_FUNCTIONKEYS   TYPE TABLE OF  RSMPE_KEYS  WITH HEADER LINE.
* For Function: RS_CUA_GET_TREE
  DATA: LT_TREE           TYPE TABLE OF  RSEUL_TREE  WITH HEADER LINE,
        LT_MENUTREE       TYPE TABLE OF  RSMPE_TREE  WITH HEADER LINE.

* Function Keys
  DATA: BEGIN OF LT_FUNKEYS  OCCURS 0.
          INCLUDE STRUCTURE RSMPE_KEYS.
  DATA:   TCODE   TYPE CUA_FUNC.         " Function code
  DATA: END OF LT_FUNKEYS.

* Trees
  DATA: BEGIN OF LT_TREES  OCCURS 0.
          INCLUDE STRUCTURE RSMPE_TREE.
  DATA:   TEXTNO     TYPE CUA_TEXTNR,    " Reference to assigned text
          SHORT      TYPE CUA_SHORT,     " GUI: Short text
          LONG       TYPE CUA_LONG,      " GUI: Long text
          TRANSLATED TYPE CUA_JA.        " Execute function
  DATA: END OF LT_TREES.

  FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP,
                 <LS_STATUS>  LIKE LINE OF LT_STATUS.

*--- Get Program's GUI statuses ----------------------------------------

*   Create a node for the program GUI statuses
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'GUI_STATUSES'
                          CHANGING STATUSES_NODE.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

  FREE: LT_STATUS.
*   Get the current program's GUI statuses data
  CALL FUNCTION 'RS_CUA_STATUS'
    EXPORTING
      OBJECTNAME           = <LS_PROG>-NAME
      LANGUAGE             = SY-LANGU
    TABLES
      STATUS               = LT_STATUS
    EXCEPTIONS
      OBJECT_NOT_FOUND     = 1
      OBJECT_NOT_SPECIFIED = 2
      PROGRAM_NOT_FOUND    = 3
      OTHERS               = 4.
  CHECK SY-SUBRC = 0.
  CHECK NOT LT_STATUS[] IS INITIAL.

*   Add the GUIs list to the GUI_STATUSES tag
  PERFORM ADD_ITAB_TO_XML TABLES LT_STATUS LT_STATUS_NODES
                           USING G_IREF_PDOCUMENT STATUSES_NODE
                                 'GUI_STATUS'.

*--- Get GUI status's Function Keys ------------------------------------
  LOOP AT LT_STATUS_NODES.

*   Create a node for the GUI Function Keys
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LT_STATUS_NODES-NODE_REF
                                  'FKEYS'
                            CHANGING FKEYS_NODE.

*   Create a node for the GUI trees
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LT_STATUS_NODES-NODE_REF
                                  'TREE'
                            CHANGING TREES_NODE.

    ASSIGN LT_STATUS_NODES-WA->* TO <LS_STATUS>.

    FREE: LT_FKEYS,
          LT_FUNCTIONKEYS,
          LT_TREE,
          LT_MENUTREE.

* Get the Function Keys data to the current GUI status
    CALL FUNCTION 'RS_CUA_GET_STATUS'
      EXPORTING
        LANGUAGE              = SY-LANGU
        PROGRAM               = <LS_PROG>-NAME
        STATUS                = <LS_STATUS>-STATUS
        SUPPRESS_CMOD_ENTRIES = ' '
      TABLES
        FKEYS                 = LT_FKEYS
        TREE                  = LT_TREE
        MENUTREE              = LT_MENUTREE
        FUNCTIONKEYS          = LT_FUNCTIONKEYS
      EXCEPTIONS
        NOT_FOUND_PROGRAM     = 1
        NOT_FOUND_STATUS      = 2
        RECURSIVE_MENUES      = 3
        EMPTY_LIST            = 4
        NOT_FOUND_MENU        = 5
        OTHERS                = 6.
    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'not_found_program'. "#EC NOTEXT
        WHEN 2. ERROR = 'not_found_status'. "#EC NOTEXT
        WHEN 3. ERROR = 'recursive_menues'. "#EC NOTEXT
        WHEN 4. ERROR = 'empty_list'. "#EC NOTEXT
        WHEN 5. ERROR = 'not_found_menu'. "#EC NOTEXT
        WHEN 6. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
      'extract programs: RS_CUA_GET_STATUS, program:' "#EC NOTEXT
      <LS_PROG>-NAME 'Status:' "#EC NOTEXT
      <LS_STATUS>-STATUS 'Error:' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.
    CHECK SY-SUBRC = 0.

*   When the gui status name contains asterisk the 'RS_CUA_GET_STATUS'
*   function module doesn't refer the asterisk as character but as a
*   placeholder - in this case, several statuses (that match the
*   pattern) may be selected into the returned tables. We keep only the
*   current status relevant records
*   Also, remove inactive entries
    DELETE LT_FKEYS WHERE STATUS <> <LS_STATUS>-STATUS
                       OR ACTIVE <> 'X'.
    DELETE LT_TREE WHERE STATUS <> <LS_STATUS>-STATUS
                      OR ACTIVE <> 'X'.
    DELETE LT_MENUTREE WHERE STATUS <> <LS_STATUS>-STATUS
                          OR ACTIVE <> 'X'.
    DELETE LT_FUNCTIONKEYS WHERE STATUS <> <LS_STATUS>-STATUS
                              OR ACTIVE <> 'X'.

*   Remove any duplicate records
    SORT LT_FKEYS BY PFNO CODE PROGRAM STATUS.
    SORT LT_FUNCTIONKEYS BY PROGRAM STATUS PFNO CODE.
    SORT LT_TREE BY POS_1 POS_2 POS_3 POS_4 CODE PROGRAM STATUS.
    SORT LT_MENUTREE BY PROGRAM STATUS POS_1 POS_2 POS_3 POS_4 CODE.
    DELETE ADJACENT DUPLICATES FROM LT_FKEYS COMPARING
                    PFNO CODE PROGRAM STATUS.
    DELETE ADJACENT DUPLICATES FROM LT_FUNCTIONKEYS COMPARING
                    PROGRAM STATUS PFNO CODE.
    DELETE ADJACENT DUPLICATES FROM LT_TREE COMPARING
                    POS_1 POS_2 POS_3 POS_4 CODE PROGRAM STATUS.
    DELETE ADJACENT DUPLICATES FROM LT_MENUTREE COMPARING
                    PROGRAM STATUS POS_1 POS_2 POS_3 POS_4 CODE.

* Merge 2 tables: LT_FKEYS & LT_FUNCTIONKEYS
    FREE: LT_FUNKEYS.
    LOOP AT LT_FUNCTIONKEYS.
      MOVE-CORRESPONDING LT_FUNCTIONKEYS TO LT_FUNKEYS.
      READ TABLE LT_FKEYS WITH KEY PROGRAM = LT_FUNCTIONKEYS-PROGRAM
                                   STATUS  = LT_FUNCTIONKEYS-STATUS
                                   PFNO    = LT_FUNCTIONKEYS-PFNO
                                   CODE    = LT_FUNCTIONKEYS-CODE.
      IF SY-SUBRC = 0.
        LT_FUNKEYS-TCODE = LT_FKEYS-TCODE.
      ENDIF.
      APPEND LT_FUNKEYS.
    ENDLOOP.

*   Add the Function Keys data to the current GUI status
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FUNKEYS
                                   USING G_IREF_PDOCUMENT
                                         FKEYS_NODE
                                         'FKEY'.

* Merge 2 tables: LT_TREE & LT_MENUTREE
    FREE: LT_TREES.
    LOOP AT LT_MENUTREE.
      MOVE-CORRESPONDING LT_MENUTREE TO LT_TREES.
      READ TABLE LT_TREE WITH KEY PROGRAM = LT_MENUTREE-PROGRAM
                                  STATUS  = LT_MENUTREE-STATUS
                                  POS_1   = LT_MENUTREE-POS_1
                                  POS_2   = LT_MENUTREE-POS_2
                                  POS_3   = LT_MENUTREE-POS_3
                                  POS_4   = LT_MENUTREE-POS_4
                                  CODE    = LT_MENUTREE-CODE.
      IF SY-SUBRC = 0.
        LT_TREES-TEXTNO     = LT_TREE-TEXTNO.
        LT_TREES-SHORT      = LT_TREE-SHORT.
        LT_TREES-LONG       = LT_TREE-LONG.
        LT_TREES-TRANSLATED = LT_TREE-TRANSLATED.
      ENDIF.
      APPEND LT_TREES.
    ENDLOOP.

*   Add the Trees data to the current GUI status
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TREES
                                   USING G_IREF_PDOCUMENT
                                         TREES_NODE
                                         'TREE_ELEMENT'.
  ENDLOOP.

ENDFORM.                    " get_program_gui_status

*&---------------------------------------------------------------------*
*&      Form  get_program_texts
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_TEXTS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

  DATA: TEXTS_NODE   TYPE XML_ELEMENT,
        LT_TRDIRT          TYPE TABLE OF TRDIRT.

  FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.

*   Create a node for the Program Text Elements
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'TITLE_TEXT'
                          CHANGING TEXTS_NODE.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

  SELECT *
  FROM   TRDIRT
  INTO   TABLE LT_TRDIRT
  WHERE  NAME = <LS_PROG>-NAME.

  IF NOT LT_TRDIRT[] IS INITIAL.
*     Add the Text Elements data to the current program
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TRDIRT
                                   USING G_IREF_PDOCUMENT
                                         TEXTS_NODE 'TRDIRT'.
  ENDIF.

ENDFORM.                    " get_program_texts

*&---------------------------------------------------------------------*
*&      Form  read_program_data
*&---------------------------------------------------------------------*
FORM READ_PROGRAM_DATA TABLES LT_TEXTELM STRUCTURE TEXTPOOL
                              CLASS_INCLUDES TYPE PROG_TAB_TYPE
                             P_FORMS
                             P_MODU
                       USING P_NAME TYPE PROGNAME
                             P_RFC_DEST TYPE RFCDEST
                             P_READ_SOURCE TYPE C
                             P_READ_TEXTELEMENTS TYPE C
                             P_READ_FORMS TYPE C
                             P_READ_MODU TYPE C
                       CHANGING P_SOURCE TYPE STRING
                                P_READ_SOURCE_RC TYPE I
                                P_SOURCE_LINE_COUNT TYPE I.

  DATA: LT_SOURCE TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
        LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
        LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
        IS_FIRST TYPE C.

  CLEAR: P_READ_SOURCE_RC.
  CLEAR: P_SOURCE_LINE_COUNT.

  IF P_READ_SOURCE = 'X'.

    CALL FUNCTION 'RPY_PROGRAM_READ' DESTINATION P_RFC_DEST
      EXPORTING
        LANGUAGE         = 'E'
        PROGRAM_NAME     = P_NAME
      TABLES
        SOURCE           = LT_SOURCE
        SOURCE_EXTENDED  = LT_SOURCE_EXT
      EXCEPTIONS
        CANCELLED        = 1
        NOT_FOUND        = 2
        PERMISSION_ERROR = 3
        OTHERS           = 4.

    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'canceled'. "#EC NOTEXT
        WHEN 2. ERROR = 'not_found'. "#EC NOTEXT
        WHEN 3. ERROR = 'permission_error'. "#EC NOTEXT
        WHEN 4. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      P_READ_SOURCE_RC = SY-SUBRC.
      CONCATENATE
      'read program source: RPY_PROGRAM_READ, program:' "#EC NOTEXT
      P_NAME 'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
      SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    IF NOT LT_SOURCE[] IS INITIAL.
      LT_UNIFIED_SOURCE[] = LT_SOURCE[].
    ELSE.
      LT_UNIFIED_SOURCE[] = LT_SOURCE_EXT[].
    ENDIF.

    DESCRIBE TABLE LT_UNIFIED_SOURCE LINES P_SOURCE_LINE_COUNT.

    CLEAR P_SOURCE.

* Don't start new line for first line
    LOOP AT LT_UNIFIED_SOURCE.
      REPLACE ALL OCCURRENCES OF ']]>' IN LT_UNIFIED_SOURCE-LINE
        WITH CDATA_END_REPLACE.

      REPLACE  '?XML' WITH '&XML_START_TAG&' INTO
        LT_UNIFIED_SOURCE-LINE.
      REPLACE  '?xml' WITH '&XML_START_TAG&' INTO
        LT_UNIFIED_SOURCE-LINE.

      IF IS_FIRST IS INITIAL.
        P_SOURCE = LT_UNIFIED_SOURCE-LINE.
        IS_FIRST = 'X'.
      ELSE.
        CONCATENATE P_SOURCE LT_UNIFIED_SOURCE-LINE INTO P_SOURCE
                  SEPARATED BY GV_ENDLINE.
      ENDIF.
    ENDLOOP.

    IF NOT P_READ_FORMS IS INITIAL.
      PERFORM GET_SUBROUTINE_FOR_PROGRAM TABLES LT_UNIFIED_SOURCE
                                         P_FORMS
                                    USING 'FORM'.
    ENDIF.
    IF NOT P_READ_MODU IS INITIAL.
      PERFORM GET_SUBROUTINE_FOR_PROGRAM TABLES LT_UNIFIED_SOURCE
                                         P_MODU
                                    USING 'MODULE'.
    ENDIF.

  ENDIF.

  IF EXTRACT_TEXT_ELEMENTS = 'X' AND P_READ_TEXTELEMENTS = 'X'.
    CLEAR LT_TEXTELM.
    REFRESH LT_TEXTELM.
    PERFORM GET_TEXT_ELEMENTS TABLES LT_TEXTELM
                                     CLASS_INCLUDES
                              USING P_NAME P_RFC_DEST.
  ENDIF.

ENDFORM.                    "READ_PROGRAM_DATA

*&---------------------------------------------------------------------*
*&      Form  get_program_source
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SOURCE TABLES CLASS_INCLUDES TYPE PROG_TAB_TYPE
                        USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE
                              LV_SOURCE_WITH_EXT.

  DATA: SOURCE_NODE   TYPE XML_ELEMENT,
        TEXTELM_NODE  TYPE XML_ELEMENT,
        FORM_NODE     TYPE XML_ELEMENT,
        MODULES_NODE  TYPE XML_ELEMENT,
        LT_TEXTELM TYPE TABLE OF TEXTPOOL WITH HEADER LINE,
        CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT,
        LV_STRING TYPE STRING,
        IS_FIRST TYPE C,
        READ_SOURCE_RC TYPE I,
        LV_SOURCE_LINE_COUNT TYPE I,
        FORMS_TAB TYPE SUBROUTINE_TAB_TYPE,
        MODU_TAB  TYPE SUBROUTINE_TAB_TYPE.

  FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.

*   Create a node for the Program Text Elements
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'TEXT_ELEMENTS'
                          CHANGING TEXTELM_NODE.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

  PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
                                   FORMS_TAB
                                   MODU_TAB
                       USING <LS_PROG>-NAME 'NONE' 'X' 'X' 'X' 'X'
                       CHANGING LV_STRING READ_SOURCE_RC
                                LV_SOURCE_LINE_COUNT.

  IF READ_SOURCE_RC = 0.

*   Add the Program Source data to the current program
    PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
                                            PT_PROGRAM_NODE-NODE_REF
                                              'SOURCE' LV_STRING 'X'
                                        CHANGING CDATA_ELEM.

    IF NOT CDATA_ELEM IS INITIAL.
      PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM
                                    'LINE_COUNT' LV_SOURCE_LINE_COUNT.
    ENDIF.

  ENDIF.

  IF NOT LT_TEXTELM[] IS INITIAL.
    SORT LT_TEXTELM.
    DELETE ADJACENT DUPLICATES FROM LT_TEXTELM COMPARING ID KEY.

*     Add the Text Elements data to the current program
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TEXTELM
                                   USING G_IREF_PDOCUMENT
                                         TEXTELM_NODE 'TEXT_ELEMENT'.
  ENDIF.

  IF NOT FORMS_TAB[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'FORMS'
                          CHANGING FORM_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES FORMS_TAB
                                   USING  G_IREF_PDOCUMENT
                                          FORM_NODE 'FORM'.
  ENDIF.
  IF NOT MODU_TAB[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'MODULES'
                          CHANGING MODULES_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES MODU_TAB
                                   USING  G_IREF_PDOCUMENT
                                          MODULES_NODE 'MODULE'.
  ENDIF.

ENDFORM.                    " get_program_source

*&---------------------------------------------------------------------*
*&      Form  get_program_mains
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_MAINS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

  DATA: MAINS_NODE     TYPE XML_ELEMENT,
        LT_MAINS       TYPE PROG_TAB_TYPE,
        LV_MAINS_COUNT TYPE I.

  FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.

* Create a node for the program mains
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                PT_PROGRAM_NODE-NODE_REF
                                'MAINS'
                          CHANGING MAINS_NODE.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

  CLEAR LT_MAINS[].

* Get the active mains of the program
  SELECT MASTER FROM D010INC
  INTO TABLE LT_MAINS
  WHERE INCLUDE = <LS_PROG>-NAME.

* Get the inactive mains of the program
  SELECT MASTER FROM RSEUINC
  APPENDING TABLE LT_MAINS
  WHERE INCLUDE = <LS_PROG>-NAME.

  DESCRIBE TABLE LT_MAINS LINES LV_MAINS_COUNT.

  IF ( NOT LT_MAINS[] IS INITIAL ) AND
     ( LV_MAINS_COUNT < MAX_MAINS ) .

    SORT LT_MAINS.
    DELETE ADJACENT DUPLICATES FROM LT_MAINS.

*   Add the mains of the current program
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_MAINS
                                   USING G_IREF_PDOCUMENT
                                         MAINS_NODE 'MAIN'.
  ENDIF.

ENDFORM.                    " get_program_mains

*&---------------------------------------------------------------------*
*&      Form  CHECK_SOURCE_EXT_SUPPORT
*&---------------------------------------------------------------------*
*       Checks whether the function module RPY_PROGRAM_READ has a
*       parameter of SOURCE_EXTENDED
*----------------------------------------------------------------------*
*      <--P_LV_IS_WITH_SOUCE_EXT  Flag
*----------------------------------------------------------------------*
FORM CHECK_SOURCE_EXT_SUPPORT  CHANGING P_IS_WITH_SOUCE_EXT.
  DATA:
        LV_GLOBAL_FLAG        LIKE RS38L-GLOBAL,
        LV_REMOTE_CALL        LIKE RS38L-REMOTE,
        LV_UPDATE_TASK        LIKE RS38L-UTASK,
        LV_SHORT_TEXT         LIKE TFTIT-STEXT,
        LV_FUNCTION_POOL      LIKE RS38L-AREA,
        LT_IMPORT_PARAMETER   TYPE TABLE OF RSIMP,
        LT_CHANGING_PARAMETER TYPE TABLE OF RSCHA,
        LT_EXPORT_PARAMETER   TYPE TABLE OF RSEXP,
        LT_TABLES_PARAMETER   TYPE TABLE OF RSTBL,
        LT_EXCEPTION_LIST     TYPE TABLE OF RSEXC,
        LT_DOCUMENTATION      TYPE TABLE OF RSFDO,
        LT_SOURCE             TYPE TABLE OF RSSOURCE WITH HEADER LINE,
        RC                    LIKE  SY-SUBRC,
        WA                    LIKE LINE OF LT_TABLES_PARAMETER.

  CLEAR P_IS_WITH_SOUCE_EXT.
  PERFORM READ_FUNCTION_MODULE_INTERFACE
              TABLES
                 LT_IMPORT_PARAMETER
                 LT_CHANGING_PARAMETER
                 LT_EXPORT_PARAMETER
                 LT_TABLES_PARAMETER
                 LT_EXCEPTION_LIST
                 LT_DOCUMENTATION
                 LT_SOURCE
              USING
                 'RPY_PROGRAM_READ'
              CHANGING
                 LV_GLOBAL_FLAG
                 LV_REMOTE_CALL
                 LV_UPDATE_TASK
                 LV_SHORT_TEXT
                 LV_FUNCTION_POOL
                 RC.

  READ TABLE LT_TABLES_PARAMETER WITH KEY PARAMETER = 'SOURCE_EXTENDED'
  INTO WA.
  IF SY-SUBRC IS INITIAL.
    P_IS_WITH_SOUCE_EXT = 'X'.
  ENDIF.

ENDFORM.                    " CHECK_SOURCE_EXT_SUPPORT

*&---------------------------------------------------------------------*
*&      Form  get_program_syntax_check
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SYNTAX_CHECK USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE
.

  CHECK TESTING_DATA_ONLY IS INITIAL.

  DATA: ERRORS_NODE  TYPE XML_ELEMENT.
  DATA: COMPILER TYPE REF TO CL_ABAP_COMPILER.
  DATA: ERRORS TYPE SYNT_ERRORS,
        ERROR  LIKE LINE OF ERRORS.
  DATA: MAIN_PROG TYPE PROGRAM.
  DATA: OREF TYPE REF TO CX_ROOT.
  DATA: ERROR_MESSAGE TYPE STRING,
        RC(2)         TYPE C.
  DATA: BEGIN OF SOURCE_TAB OCCURS 100,
          LINE(80),
        END OF SOURCE_TAB.
  FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.

  ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.
  CHECK <LS_PROG>-SUBC <> 'I' OR <LS_PROG>-NAME(2) = 'ZX'.

  TRY.
      IF <LS_PROG>-NAME(2) = 'ZX'.

        CONCATENATE 'SAPL' <LS_PROG>-NAME+1(4) INTO MAIN_PROG.

        CREATE OBJECT COMPILER
          EXPORTING
            P_NAME             = MAIN_PROG
            P_INCLUDE          = <LS_PROG>-NAME
*           p_includes         =
*           p_only_interface   =
          EXCEPTIONS
            PROGRAM_NAME_EMPTY = 1
            OTHERS             = 2.
      ELSE.
        CREATE OBJECT COMPILER
          EXPORTING
            P_NAME             = <LS_PROG>-NAME
*           p_include          =
*           p_includes         =
*           p_only_interface   =
          EXCEPTIONS
            PROGRAM_NAME_EMPTY = 1
            OTHERS             = 2.

      ENDIF.

      IF RC <> 0.
        CONCATENATE 'SYNTAX CHECK DEBUG: ' <LS_PROG>-NAME
        '1. compiler initialized. rc:' RC "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      ENDIF.

      CALL METHOD COMPILER->GET_ALL
        IMPORTING
*         p_result =
          P_ERRORS = ERRORS.

      IF ERRORS[] IS INITIAL AND <LS_PROG>-SUBC <> 'I'.

        CALL FUNCTION 'RS_SYNTAX_CHECK'
          EXPORTING
            I_GLOBAL_CHECK   = 'X'
            I_GLOBAL_PROGRAM = <LS_PROG>-NAME
            I_PROGRAM        = ''
*           I_WITH_DIALOG    = ' '
          IMPORTING
            O_ERROR_INCLUDE  = ERROR-INCNAME
            O_ERROR_LINE     = ERROR-LINE
            O_ERROR_MESSAGE  = ERROR-MESSAGE
            O_ERROR_OFFSET   = ERROR-COL
*           O_ERROR_SUBRC    =
*           O_NAVIGATE       =
*           CANCEL           =
          TABLES
            I_SOURCE         = SOURCE_TAB.

        IF NOT ERROR-MESSAGE IS INITIAL.
          CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME "#EC NOTEXT
          '2.2. found error with func: ' ERROR-MESSAGE "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.
          PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

          APPEND ERROR TO ERRORS.
          CLEAR ERROR.
        ENDIF.
      ELSE.
        LOOP AT ERRORS INTO ERROR.
          CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
          '2. found error: ' ERROR-MESSAGE "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.
          PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
        ENDLOOP.
      ENDIF.

      CHECK NOT ERRORS[] IS INITIAL.

*     Create a node for the Program Text Elements
      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                    PT_PROGRAM_NODE-NODE_REF
                                    'SYNTAX_ERRORS'
                              CHANGING ERRORS_NODE.

*     Add the Text Elements data to the current program
      PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES ERRORS
                                       USING G_IREF_PDOCUMENT
                                             ERRORS_NODE 'ERROR'.

    CATCH CX_ROOT INTO OREF.

      CALL METHOD OREF->GET_TEXT
        RECEIVING
          RESULT = ERROR_MESSAGE.

      CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
      '4. caught excpetion, message:' ERROR_MESSAGE "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
  ENDTRY.

ENDFORM.                    " get_program_syntax_check

*---------------------------------------------------------------------*
*       FORM GET_SUBROUTINE_FOR_PROGRAM                               *
*---------------------------------------------------------------------*
FORM GET_SUBROUTINE_FOR_PROGRAM TABLES P_SOURCE
                                  P_SUBROUTINES
                           USING  P_OBJECT.
  DATA:
    TK              TYPE TABLE OF STOKES WITH HEADER LINE,
    NAME_TABIX      TYPE SY-TABIX,
    SUBROUTINE_NAME TYPE SUBROUTINE_TYPE,
    TK_PRINT_WA     TYPE STOKES.

  DATA  BEGIN OF STM OCCURS 1000.
          INCLUDE STRUCTURE SSTMNT.
  DATA  END OF STM.

  DATA: KEY_TAB TYPE TABLE OF LINE,
        KEY     TYPE LINE.

* Create the keywords key in order to get only the wanted subroutine
* statement
  KEY = P_OBJECT.
  APPEND KEY TO KEY_TAB.

* Get the tokens and statement of the statements containing the wanted
* subroutine
  SCAN ABAP-SOURCE P_SOURCE
                   TOKENS      INTO TK
                   STATEMENTS  INTO STM
                   KEYWORDS FROM KEY_TAB.
  CLEAR STM.
  CLEAR P_SUBROUTINES.

* Get the name of the subroutine
  LOOP AT TK WHERE STR = P_OBJECT.
*   The name of the subroutine is the word after the keyword
    NAME_TABIX = SY-TABIX + 1.
    READ TABLE TK INDEX NAME_TABIX INTO TK_PRINT_WA.
    IF SY-SUBRC IS INITIAL.
      SUBROUTINE_NAME-SUBROUTINE = TK_PRINT_WA-STR.
      APPEND SUBROUTINE_NAME TO P_SUBROUTINES.
    ELSE.
      CONCATENATE 'GET_SUBROUTINE: ERROR getting ' "#EC NOTEXT
      P_OBJECT ' name' "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
  ENDLOOP.
ENDFORM.                    "GET_SUBROUTINE_FOR_PROGRAM

*&---------------------------------------------------------------------*
*&      Form  read_function_module_interface
*&---------------------------------------------------------------------*
*       Reads function module interface
*----------------------------------------------------------------------*
FORM READ_FUNCTION_MODULE_INTERFACE
                          TABLES
                                   IMPORT_PARAMETER STRUCTURE  RSIMP
                                   CHANGING_PARAMETER STRUCTURE  RSCHA
                                   EXPORT_PARAMETER STRUCTURE  RSEXP
                                   TABLES_PARAMETER STRUCTURE  RSTBL
                                   EXCEPTION_LIST STRUCTURE  RSEXC
                                   DOCUMENTATION STRUCTURE  RSFDO
                                   SOURCE STRUCTURE  RSSOURCE
                          USING
                                   FUNCTIONNAME   TYPE RS38L-NAME
                          CHANGING
                                   GLOBAL_FLAG    LIKE  RS38L-GLOBAL
                                   REMOTE_CALL    LIKE  RS38L-REMOTE
                                   UPDATE_TASK    LIKE  RS38L-UTASK
                                   SHORT_TEXT     LIKE  TFTIT-STEXT
                                   FUNCTION_POOL  LIKE  RS38L-AREA
                                   RC             LIKE  SY-SUBRC.

  CALL FUNCTION 'RPY_FUNCTIONMODULE_READ_NEW'
    EXPORTING
      FUNCTIONNAME       = FUNCTIONNAME
    IMPORTING
      GLOBAL_FLAG        = GLOBAL_FLAG
      REMOTE_CALL        = REMOTE_CALL
      UPDATE_TASK        = UPDATE_TASK
      SHORT_TEXT         = SHORT_TEXT
      FUNCTION_POOL      = FUNCTION_POOL
    TABLES
      IMPORT_PARAMETER   = IMPORT_PARAMETER
      CHANGING_PARAMETER = CHANGING_PARAMETER
      EXPORT_PARAMETER   = EXPORT_PARAMETER
      TABLES_PARAMETER   = TABLES_PARAMETER
      EXCEPTION_LIST     = EXCEPTION_LIST
      DOCUMENTATION      = DOCUMENTATION
      SOURCE             = SOURCE
    EXCEPTIONS
      ERROR_MESSAGE      = 1
      FUNCTION_NOT_FOUND = 2
      INVALID_NAME       = 3
      OTHERS             = 4.
  RC = SY-SUBRC.

ENDFORM.                    "read_function_module_interface

*&---------------------------------------------------------------------*
*&      Form  get_program_gui_status_wrap
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_GUI_STATUS_WRAP
       USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

  CHECK IA_DATA_ONLY IS INITIAL.

  FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.
  TRY.
      PERFORM GET_PROGRAM_GUI_STATUS USING PT_PROGRAM_NODE.
    CATCH CX_ROOT.
      ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.
      CONCATENATE 'extract program gui status: program:' "#EC NOTEXT
            <LS_PROG>-NAME
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDTRY.
ENDFORM.                    "get_program_gui_status_wrap

*---------------------------------------------------------------------*
*       FORM get_text_elements                                        *
*---------------------------------------------------------------------*
FORM GET_TEXT_ELEMENTS TABLES LT_TEXTELM   STRUCTURE TEXTPOOL
                              CLASS_INCLUDES TYPE PROG_TAB_TYPE
                       USING P_NAME TYPE C
                             P_RFC_DEST TYPE RFCDEST.

  READ TABLE CLASS_INCLUDES WITH KEY PROG = P_NAME BINARY SEARCH.
  IF NOT SY-SUBRC IS INITIAL.

*   The text elements are not read in RPY_PROGRAM_READ since the is a
*   problem. The text field of selection texts based on data dictionary
*   are not solved
    CALL FUNCTION 'RS_TEXTPOOL_READ'
      EXPORTING
        OBJECTNAME           = P_NAME
        ACTION               = ''
        LANGUAGE             = 'E'
      TABLES
        TPOOL                = LT_TEXTELM
      EXCEPTIONS
        OBJECT_NOT_FOUND     = 1
        PERMISSION_FAILURE   = 2
        INVALID_PROGRAM_TYPE = 3
        ERROR_OCCURED        = 4
        ACTION_CANCELLED     = 5
        OTHERS               = 6.
    IF SY-SUBRC <> 0 AND SY-SUBRC <> 1 AND SY-SUBRC <> 3.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 2. ERROR = 'PERMISSION_FAILURE'.
        WHEN 4. ERROR = 'ERROR_OCCURED'.
        WHEN 5. ERROR = 'ACTION_CANCELLED'.
        WHEN 6. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
      'extract programs: RS_TEXTPOOL_READ, program:' "#EC NOTEXT
      P_NAME 'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
  ENDIF.

ENDFORM.                    "get_text_elements

*&---------------------------------------------------------------------*
*&      Form  extract_transactions
*&---------------------------------------------------------------------*
FORM EXTRACT_TRANSACTIONS.

  CONSTANTS: REPORT_TRANSACTION_CINFO TYPE X VALUE '80'.

  TABLES: TSTCP.

  DATA: LT_TSTC   TYPE TABLE OF TSTC  WITH HEADER LINE,
        LT_TSTCT  TYPE TABLE OF TSTCT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: BEGIN OF LT_TSTCP  OCCURS 0.
          INCLUDE STRUCTURE TSTCP.
  DATA:   BASE_TCODE  TYPE TSTC-TCODE,
        END OF LT_TSTCP.

  RANGES: R_TCODE FOR TSTC-TCODE.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting transactions'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_TRNS INTO GS_OBJECTLIST.
    CLEAR R_TCODE.
    R_TCODE-SIGN   = 'I'.
    R_TCODE-OPTION = 'EQ'.
    R_TCODE-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_TCODE.
  ENDLOOP.

  FREE GT_OBJ_TRNS.

  CHECK NOT R_TCODE[] IS INITIAL.

* Get Transaction Codes list
  IF NOT R_TCODE[] IS INITIAL.
    SELECT * FROM  TSTC  AS TS
    INTO TABLE LT_TSTC
    FOR ALL ENTRIES IN R_TCODE
    WHERE  TCODE = R_TCODE-LOW.
  ENDIF.

  SORT LT_TSTC.

  CHECK NOT LT_TSTC[] IS INITIAL.

  LOOP AT LT_TSTC.
    IF LT_TSTC-DYPNO IS INITIAL AND
       LT_TSTC-CINFO = REPORT_TRANSACTION_CINFO.
      LT_TSTC-DYPNO = '1000'.
      MODIFY LT_TSTC TRANSPORTING DYPNO.
    ENDIF.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<TRANSACTIONS>'.

  PERFORM APPEND_STRING_TO_FILE USING '<BASE_TRANSACTIONS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTC
                                 USING G_IREF_PDOCUMENT
                                       'TSTC'.
  PERFORM APPEND_STRING_TO_FILE USING '</BASE_TRANSACTIONS>'.
  FREE LT_TSTC.

* Get Transactions Text 'TSTCT'
  IF NOT R_TCODE[] IS INITIAL.
    SELECT * FROM  TSTCT
    INTO TABLE LT_TSTCT
    FOR ALL ENTRIES IN R_TCODE
    WHERE  TCODE = R_TCODE-LOW.
  ENDIF.
  SORT LT_TSTCT.

  PERFORM APPEND_STRING_TO_FILE USING '<TRANSACTIONS_TEXT>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTCT
                                 USING G_IREF_PDOCUMENT
                                       'TSTCT'.
  PERFORM APPEND_STRING_TO_FILE USING '</TRANSACTIONS_TEXT>'.
  FREE LT_TSTCT.

* Get Parameters Transaction Codes list 'TSTCP'
  IF NOT R_TCODE[] IS INITIAL.
    SELECT * FROM  TSTCP
    INTO TABLE LT_TSTCP
    FOR ALL ENTRIES IN R_TCODE
    WHERE  TCODE = R_TCODE-LOW.
  ENDIF.
  SORT LT_TSTCP.

  LOOP AT LT_TSTCP.
    GV_TABIX = SY-TABIX.
* Get Transaction
    CALL FUNCTION 'RS_TRANSACTION_SINGLE_GET'
      EXPORTING
        PARAMETER_TCODE = LT_TSTCP-TCODE
      IMPORTING
        TCODE           = LT_TSTCP-BASE_TCODE.
    MODIFY LT_TSTCP INDEX GV_TABIX TRANSPORTING BASE_TCODE.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<PARAM_TRANSACTIONS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTCP
                                 USING G_IREF_PDOCUMENT
                                       'TSTCP'.
  PERFORM APPEND_STRING_TO_FILE USING '</PARAM_TRANSACTIONS>'.
  FREE LT_TSTCP.

  PERFORM APPEND_STRING_TO_FILE USING '</TRANSACTIONS>'.

  PERFORM ADD_TIME_STAT USING 'Extract transactions' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_transactions

*&---------------------------------------------------------------------*
*&      Form  extract_logical_data_bases
*&---------------------------------------------------------------------*
FORM EXTRACT_LOGICAL_DATABASES.
  CHECK TESTING_DATA_ONLY IS INITIAL.
  DATA: LT_LDBN  TYPE TABLE OF LDBN,
        LT_LDBD  TYPE TABLE OF LDBD WITH HEADER LINE,
        LT_LDBT  TYPE TABLE OF LDBT.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: BEGIN OF LT_LDB_SHLP OCCURS 0,
          LDBNAME TYPE LDBNAM.
          INCLUDE STRUCTURE DDSHLDB1.
  DATA: END OF LT_LDB_SHLP,
        LT_DDSHLDB1 TYPE TABLE OF DDSHLDB1 WITH HEADER LINE.

  RANGES: R_LDBNAME FOR LDBN-LDBNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
                          'Extracting logical databases'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_LGDB INTO GS_OBJECTLIST.
    CLEAR R_LDBNAME.
    R_LDBNAME-SIGN   = 'I'.
    R_LDBNAME-OPTION = 'EQ'.
    R_LDBNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_LDBNAME.
  ENDLOOP.

  FREE GT_OBJ_LGDB.

  CHECK NOT R_LDBNAME[] IS INITIAL.

* Get Logical Data Bases admin info
  IF NOT R_LDBNAME[] IS INITIAL.
    SELECT * FROM  LDBD
    INTO TABLE LT_LDBD
    FOR ALL ENTRIES IN R_LDBNAME
    WHERE  LDBNAME = R_LDBNAME-LOW.
  ENDIF.

  LOOP AT LT_LDBD WHERE NOT SHLPNAME IS INITIAL.

    LT_LDB_SHLP-LDBNAME = LT_LDBD-LDBNAME.

*   Get the search help parameters
    REFRESH LT_DDSHLDB1.
    CALL FUNCTION 'DD_SHLP_GET_OUTPARAMS'
      EXPORTING
        SHLP_NAME  = LT_LDBD-SHLPNAME
      TABLES
        FIELDS_TAB = LT_DDSHLDB1.
    LOOP AT LT_DDSHLDB1.
      MOVE-CORRESPONDING LT_DDSHLDB1 TO LT_LDB_SHLP.
      APPEND LT_LDB_SHLP.
    ENDLOOP.

  ENDLOOP.

  CHECK NOT LT_LDBD[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASES>'.

  PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_ADMIN_INFO>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBD
                                 USING G_IREF_PDOCUMENT
                                       'LDBD'.
  PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_ADMIN_INFO>'.
  FREE LT_LDBD.

* Get Logical Data Bases nodes
  PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_NODES>'.

  IF NOT R_LDBNAME[] IS INITIAL.
    SELECT * FROM  LDBN
    INTO TABLE LT_LDBN PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_LDBNAME
    WHERE  LDBNAME = R_LDBNAME-LOW.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBN
                                     USING G_IREF_PDOCUMENT
                                           'LDBN'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_NODES>'.
  FREE LT_LDBN.

  PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_SEARCH_HELP>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDB_SHLP
                                 USING G_IREF_PDOCUMENT
                                       'LDB_SHLP'.
  PERFORM APPEND_STRING_TO_FILE USING
                                '</LOGICAL_DATA_BASE_SEARCH_HELP>'.
  FREE LT_LDB_SHLP.

* Get Logical Data Bases Text
  PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_TEXT>'.
  IF NOT R_LDBNAME[] IS INITIAL.
    SELECT * FROM  LDBT
    INTO TABLE LT_LDBT PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_LDBNAME
    WHERE  LDBNAME = R_LDBNAME-LOW.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBT
                                     USING G_IREF_PDOCUMENT
                                           'LDBT'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_TEXT>'.
  FREE LT_LDBT.

  PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASES>'.

  PERFORM ADD_TIME_STAT USING 'Extract LDBs' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_logical_data_bases

*&---------------------------------------------------------------------*
*&      Form  extract_messages
*&---------------------------------------------------------------------*
FORM EXTRACT_MESSAGES.
  CHECK IA_DATA_ONLY IS INITIAL.
  DATA: LT_T100   TYPE TABLE OF T100,
        LT_T100A  TYPE TABLE OF T100A WITH HEADER LINE,
        LT_T100A1 TYPE TABLE OF T100A,
        LT_T100T  TYPE TABLE OF T100T.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_ARBGB FOR T100A-ARBGB.

  PERFORM UPDATE_PROGRESS USING 'Extracting messages'. "#EC NOTEXT
  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

* Set Object list
  LOOP AT GT_OBJ_MESG INTO GS_OBJECTLIST.
    CLEAR R_ARBGB.
    R_ARBGB-SIGN   = 'I'.
    R_ARBGB-OPTION = 'EQ'.
    R_ARBGB-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_ARBGB.
  ENDLOOP.

  FREE GT_OBJ_MESG.

  CHECK NOT R_ARBGB[] IS INITIAL.

* Get Messages IDs
  IF NOT R_ARBGB[] IS INITIAL.
    SELECT * FROM  T100A
    INTO TABLE LT_T100A
    FOR ALL ENTRIES IN R_ARBGB
    WHERE  ARBGB = R_ARBGB-LOW.
  ENDIF.

  CHECK NOT LT_T100A[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<MESSAGES>'.

  LOOP AT LT_T100A.

    PERFORM APPEND_STRING_TO_FILE USING '<MESSAGE_GROUP>'.

    FREE: LT_T100A1.
    APPEND LT_T100A TO LT_T100A1.
*   Add Message Header data
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100A1
                                   USING G_IREF_PDOCUMENT
                                         'MESSAGE_HEADER'.
    FREE LT_T100A1.

*   Get Message Text
    SELECT * FROM  T100T
           INTO TABLE LT_T100T
           WHERE  ARBGB  = LT_T100A-ARBGB.
*   Add the Message text
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100T
                                   USING G_IREF_PDOCUMENT
                                         'MESSAGE_TEXT'.
    FREE LT_T100T.

*   Get Messages list
    SELECT * FROM  T100
           INTO TABLE LT_T100
           WHERE  ARBGB  = LT_T100A-ARBGB.
*   Add the Messages list
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100
                                   USING G_IREF_PDOCUMENT
                                         'MESSAGE_NO'.
    FREE LT_T100.

    PERFORM APPEND_STRING_TO_FILE USING '</MESSAGE_GROUP>'.

  ENDLOOP.

  FREE LT_T100A.

  PERFORM APPEND_STRING_TO_FILE USING '</MESSAGES>'.

  PERFORM ADD_TIME_STAT USING 'Extract messages' "#EC NOTEXT
    L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_messages

*---------------------------------------------------------------------*
*       FORM EXTRACT_VANILLA_SOURCE                                   *
*---------------------------------------------------------------------*
FORM EXTRACT_VANILLA_SOURCE.
  CHECK TESTING_DATA_ONLY IS INITIAL.
  DATA: LT_PROGRAMS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LS_PROGRAM_NODE    LIKE LINE OF LT_PROGRAMS_NODES,
        LT_SOURCE TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
        LV_SOURCE_SRC TYPE STRING,
        LV_SOURCE_TAR TYPE STRING,
        LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
        IS_FIRST TYPE C,
        LT_TEXTELM TYPE TABLE OF TEXTPOOL,
        CLASS_INCLUDES TYPE PROG_TAB_TYPE,
        PROG_NAME TYPE PROGNAME,
        VAN_PROGRAMS_NODE TYPE XML_ELEMENT,
        ACC_VAN_PROGRAMS_NODE TYPE XML_ELEMENT,
        READ_SOURCE_RC TYPE I,
        CDATA_ELEM_SRC TYPE REF TO IF_IXML_ELEMENT,
        CDATA_ELEM_TAR TYPE REF TO IF_IXML_ELEMENT,
        ACTUAL_VANILLA_PROGS_COUNT TYPE I,
        ACTUAL_VANILLA_PROGS_COUNT_STR TYPE STRING,
        LV_SOURCE_LINE_COUNT TYPE I,
        FORMS_TAB TYPE SUBROUTINE_TAB_TYPE,
        MODU_TAB TYPE SUBROUTINE_TAB_TYPE.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  FIELD-SYMBOLS: <LS_PROG> TYPE PROG_TYPE.

  CHECK NOT G_VANILLA_PROGRAMS[] IS INITIAL.

  SORT G_VANILLA_PROGRAMS BY PROG.
  CLEAR ACTUAL_VANILLA_PROGS_COUNT.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting vanilla programs'. "#EC NOTEXT

* Create a child node for the Programs node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'VANILLA_PROGRAMS'
                          CHANGING VAN_PROGRAMS_NODE.

  PERFORM APPEND_STRING_TO_FILE USING '<VANILLA_PROGRAMS>'.

* Read the programs source code from the SOURCE system
  LOOP AT G_VANILLA_PROGRAMS.

    PROG_NAME = G_VANILLA_PROGRAMS-PROG.

    IF ( G_VANILLA_PROGRAMS-ORIGIN = ORIGIN_TARGET ).

*     Read program's source code from TARGET system
      PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
                                       FORMS_TAB
                                       MODU_TAB
                         USING PROG_NAME 'NONE' 'X' SPACE SPACE SPACE
                         CHANGING LV_SOURCE_SRC READ_SOURCE_RC
                                  LV_SOURCE_LINE_COUNT.

      IF READ_SOURCE_RC = 0.

*     Add the Program Source data to the current program
        PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
                                                  VAN_PROGRAMS_NODE
                                                  'VANILLA_SOURCE'
                                                  LV_SOURCE_SRC 'X'
                                            CHANGING CDATA_ELEM_SRC.

        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
                                            'PROGRAM' PROG_NAME.
        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
                                            'ORIGIN' 'TARGET'.
        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
                                      'LINE_COUNT' LV_SOURCE_LINE_COUNT.
        PERFORM APPEND_XML_ELEMENT_TO_FILE USING CDATA_ELEM_SRC 'X'.

*       Increase the acctual programs counter
        ADD 1 TO ACTUAL_VANILLA_PROGS_COUNT.
      ENDIF.
    ELSEIF ( G_VANILLA_PROGRAMS-ORIGIN = ORIGIN_SOURCE ).

*     Read program's source code from SOURCE system
      PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
                                       FORMS_TAB
                                       MODU_TAB
                         USING PROG_NAME P_RFCDES 'X' SPACE SPACE SPACE
                         CHANGING LV_SOURCE_TAR READ_SOURCE_RC
                                  LV_SOURCE_LINE_COUNT.

      IF READ_SOURCE_RC = 0.
*     Add the Program Source data to the current program
        PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
                                                  VAN_PROGRAMS_NODE
                                                  'VANILLA_SOURCE'
                                                  LV_SOURCE_TAR 'X'
                                            CHANGING CDATA_ELEM_TAR.

        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
                                            'PROGRAM' PROG_NAME.
        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
                                            'ORIGIN' 'SOURCE'.
        PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
                                      'LINE_COUNT' LV_SOURCE_LINE_COUNT.
        PERFORM APPEND_XML_ELEMENT_TO_FILE USING CDATA_ELEM_TAR 'X'.

*       Increase the acctual programs counter
        ADD 1 TO ACTUAL_VANILLA_PROGS_COUNT.

      ENDIF.
    ENDIF.

  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '</VANILLA_PROGRAMS>'.

* Add vanilla programs actual count tag

* Create a child node for the Actual vanilla programs that were found
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'ACC_VANILLA_PROGS'
                          CHANGING ACC_VAN_PROGRAMS_NODE.

  ACTUAL_VANILLA_PROGS_COUNT_STR = ACTUAL_VANILLA_PROGS_COUNT.

  PERFORM ADD_ATTRIBUTE_TO_NODE USING ACC_VAN_PROGRAMS_NODE
                             'ACTUAL_PROGS' ACTUAL_VANILLA_PROGS_COUNT.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING ACC_VAN_PROGRAMS_NODE 'X'.

  PERFORM ADD_TIME_STAT USING 'Extract vanilla programs' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_VANILLA_SOURCE

*---------------------------------------------------------------------*
*       FORM extract_append_structures                                *
*---------------------------------------------------------------------*
FORM FIND_APPEND_STRUCTURES.

  DATA: APP_STRUC_TAB TYPE TABLE OF DD03L,
        APP_STRUC LIKE LINE OF APP_STRUC_TAB,
        SAP_TABLE_FIELDS TYPE TABLE OF DD03L,
        PROCESS_TYPE TYPE C,
        APPEND_STRUCTURES_NODE TYPE XML_ELEMENT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
      'Searching for SAP types with append structures'. "#EC NOTEXT

  CHECK NOT CUSTOMER_OBJECTS[] IS INITIAL.

* Find all SAP types that contain customer append structure
  SELECT * FROM DD03L
  INTO TABLE APP_STRUC_TAB
  WHERE FIELDNAME = '.INCLU--AP'
  AND   AS4LOCAL  = 'A' AND
        AS4VERS = '0000'   " Take only the active version
  AND   PRECFIELD IN CUSTOMER_OBJECTS.

  SORT APP_STRUC_TAB BY TABNAME.

  LOOP AT APP_STRUC_TAB INTO APP_STRUC.
    AT END OF TABNAME. PROCESS_TYPE = 'X'. ENDAT.

    IF PROCESS_TYPE = 'X'.
      CLEAR PROCESS_TYPE.

      SELECT * FROM DD03L
      INTO TABLE SAP_TABLE_FIELDS
      WHERE TABNAME = APP_STRUC-TABNAME
      AND   AS4LOCAL = 'A' AND
            AS4VERS = '0000'.   " Take only the active version

      CHECK SY-SUBRC IS INITIAL.

      G_APP_STRUC-SIGN   = 'I'.
      G_APP_STRUC-OPTION = 'EQ'.
      G_APP_STRUC-LOW    = APP_STRUC-TABNAME.
      APPEND G_APP_STRUC.

    ENDIF.
  ENDLOOP.

  PERFORM ADD_TIME_STAT USING 'Extract append structures' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "find_append_structures

*---------------------------------------------------------------------*
*       FORM extract_customer_includes                                *
*---------------------------------------------------------------------*
FORM FIND_CUSTOMER_INCLUDES.
  DATA: INC_STRUC_TAB TYPE TABLE OF DD03L,
        INC_STRUC LIKE LINE OF INC_STRUC_TAB,
        SAP_TABLE_FIELDS TYPE TABLE OF DD03L,
        DD02L_TAB TYPE TABLE OF DD02L WITH HEADER LINE,
        PROCESS_TYPE TYPE C,
        CUSTOMER_INCLUDES_NODE TYPE XML_ELEMENT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
      'Searching for SAP types with customer includes'. "#EC NOTEXT

* Find all SAP types that contain active customer includes
  SELECT * FROM DD02L
  INTO TABLE DD02L_TAB
  WHERE TABNAME LIKE 'CI%'
  AND   AS4LOCAL = 'A'.

  LOOP AT DD02L_TAB WHERE TABNAME NP 'CI_*'.
    DELETE DD02L_TAB.
  ENDLOOP.

  CHECK NOT DD02L_TAB[] IS INITIAL.

  IF NOT DD02L_TAB[] IS INITIAL.
    SELECT * FROM DD03L
    INTO TABLE INC_STRUC_TAB
    FOR ALL ENTRIES IN DD02L_TAB
    WHERE AS4LOCAL  = 'A'
    AND AS4VERS = '0000'   " Take only the active version
    AND   PRECFIELD = DD02L_TAB-TABNAME.
  ENDIF.

  SORT INC_STRUC_TAB BY TABNAME.

  LOOP AT INC_STRUC_TAB INTO INC_STRUC.
    AT END OF TABNAME. PROCESS_TYPE = 'X'. ENDAT.

    IF PROCESS_TYPE = 'X'.
      CLEAR PROCESS_TYPE.

      SELECT * FROM DD03L
      INTO TABLE SAP_TABLE_FIELDS
      WHERE TABNAME = INC_STRUC-TABNAME
      AND AS4VERS = '0000'   " Take only the active version
      AND   AS4LOCAL = 'A'.

      CHECK SY-SUBRC IS INITIAL.

      G_INC_STRUC-SIGN   = 'I'.
      G_INC_STRUC-OPTION = 'EQ'.
      G_INC_STRUC-LOW    = INC_STRUC-TABNAME.
      APPEND G_INC_STRUC.

    ENDIF.
  ENDLOOP.

  PERFORM ADD_TIME_STAT USING 'Extract customer includes' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.


ENDFORM.                    "find_customer_includes

*&---------------------------------------------------------------------*
*&      Form  find_view_with_astrix
*&---------------------------------------------------------------------*
FORM FIND_VIEW_WITH_ASTRIX.

  TYPES: BEGIN OF DD27S_INT_TYPE,
           TABNAME LIKE DD27S-TABNAME,
         END OF DD27S_INT_TYPE.
  DATA: CURR_TAB LIKE LINE OF G_APP_STRUC,
        VIEWS_TAB LIKE DD27S OCCURS 0,
        VIEW_DATA LIKE DD27S,
        PROCESS_VIEW TYPE C,
        L_TABLES TYPE TABLE OF DD27S_INT_TYPE WITH HEADER LINE.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

DATA: LV_TEMP TYPE STRING.

CONCATENATE 'Searching for SAP views with customer ' "#EC NOTEXT
    'changes to its tables' "#EC NOTEXT
    INTO LV_TEMP.

  PERFORM UPDATE_PROGRESS USING LV_TEMP.

* Check if there is a view that includes this table with *
* in fields field ( this means that all fields of current
* table should be included into the view )
  IF NOT G_APP_STRUC[] IS INITIAL.
    CLEAR L_TABLES. REFRESH L_TABLES.
    LOOP AT G_APP_STRUC.
      L_TABLES-TABNAME = G_APP_STRUC-LOW.
      APPEND L_TABLES.
    ENDLOOP.

    IF NOT L_TABLES[] IS INITIAL.
      SELECT *
      FROM DD27S
      INTO TABLE VIEWS_TAB
      FOR ALL ENTRIES IN L_TABLES
      WHERE TABNAME = L_TABLES-TABNAME AND
            FIELDNAME = '*' AND
            AS4LOCAL  = 'A'.
    ENDIF.
  ENDIF.
  IF NOT G_INC_STRUC[] IS INITIAL.
    CLEAR L_TABLES. REFRESH L_TABLES.
    LOOP AT G_INC_STRUC.
      L_TABLES-TABNAME = G_INC_STRUC-LOW.
      APPEND L_TABLES.
    ENDLOOP.

    IF NOT L_TABLES[] IS INITIAL.
      SELECT *
      FROM DD27S
      APPENDING TABLE VIEWS_TAB
      FOR ALL ENTRIES IN L_TABLES
      WHERE TABNAME = L_TABLES-TABNAME AND
            FIELDNAME = '*' AND
            AS4LOCAL  = 'A'.
    ENDIF.
  ENDIF.

  SORT VIEWS_TAB BY VIEWNAME.

  LOOP AT VIEWS_TAB INTO VIEW_DATA.
    AT END OF VIEWNAME. PROCESS_VIEW = 'X'. ENDAT.

    IF PROCESS_VIEW = 'X'.
      CLEAR PROCESS_VIEW.

      G_VIEW_WITH_AST-SIGN   = 'I'.
      G_VIEW_WITH_AST-OPTION = 'EQ'.
      G_VIEW_WITH_AST-LOW    = VIEW_DATA-VIEWNAME.
      APPEND G_VIEW_WITH_AST.

    ENDIF.
  ENDLOOP.

  PERFORM ADD_TIME_STAT USING 'Extract views with astrixes' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " find_view_with_astrix

*&---------------------------------------------------------------------*
*&      Form  extract_tables
*&---------------------------------------------------------------------*
FORM EXTRACT_TABLES.

  TYPES: BEGIN OF DD03L_TYPE,
          TABNAME LIKE DD03L-TABNAME,
          FIELDNAME LIKE DD03L-FIELDNAME,
         END OF DD03L_TYPE.

  DATA: LT_DD02L   TYPE TABLE OF DD02L,
        LT_DD02T   TYPE TABLE OF DD02T,
        LT_DD09L   TYPE TABLE OF DD09L,
        LT_DD03L   TYPE TABLE OF DD03L_TYPE,
        LT_DD03T   TYPE TABLE OF DD03T,
        LT_DD12V   TYPE TABLE OF DD12V.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_TABNAME FOR DD02L-TABNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting DB tables'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_TABL INTO GS_OBJECTLIST.
    CLEAR R_TABNAME.
    R_TABNAME-SIGN   = 'I'.
    R_TABNAME-OPTION = 'EQ'.
    R_TABNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_TABNAME.

    READ TABLE MODIFIED_OBJECTS
         WITH KEY OBJ_TYPE = 'TABL'
                  OBJ_NAME = GS_OBJECTLIST-OBJ_NAME
         TRANSPORTING NO FIELDS.
    IF SY-SUBRC <> 0.
      G_TABNAME_INDEX = R_TABNAME.
      APPEND G_TABNAME_INDEX.
    ENDIF.

  ENDLOOP.

* Add also the SAP types with append structure
  IF NOT G_APP_STRUC IS INITIAL.
    APPEND LINES OF G_APP_STRUC TO R_TABNAME.
  ENDIF.
* Add also the SAP types with customer include
  IF NOT G_INC_STRUC IS INITIAL.
    APPEND LINES OF G_INC_STRUC TO R_TABNAME.
  ENDIF.

  CHECK NOT R_TABNAME[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<TABLES>'.

* Get Table Data 'DD02L'
  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_METADATA>'.

  IF NOT R_TABNAME[] IS INITIAL.
    SELECT * FROM  DD02L
    INTO TABLE LT_DD02L PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_TABNAME
    WHERE  TABNAME = R_TABNAME-LOW
    AND    AS4LOCAL = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD02L
                                     USING G_IREF_PDOCUMENT
                                           'DD02L'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_METADATA>'.
  FREE LT_DD02L.

** Get Table Text 'DD02T'
*  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TEXT>'.
*  IF NOT R_TABNAME[] IS INITIAL.
*    SELECT * FROM  DD02T
*    INTO TABLE LT_DD02T PACKAGE SIZE PAC_SIZE
*    FOR ALL ENTRIES IN R_TABNAME
*    WHERE  TABNAME = R_TABNAME-LOW
*    AND    AS4LOCAL = 'A'
*    AND AS4VERS = '0000'.   " Take only the active version
*
*      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD02T
*                                     USING G_IREF_PDOCUMENT
*                                           'DD02T'.
*    ENDSELECT.
*  ENDIF.
*  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TEXT>'.
*  FREE LT_DD02T.
*
** Get Table Technical settings 'DD09L'
*  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TECHNICAL>'.
*  IF NOT R_TABNAME[] IS INITIAL.
*    SELECT * FROM  DD09L
*    INTO TABLE LT_DD09L PACKAGE SIZE PAC_SIZE
*    FOR ALL ENTRIES IN R_TABNAME
*    WHERE  TABNAME = R_TABNAME-LOW
*    AND    AS4LOCAL = 'A'
*    AND AS4VERS = '0000'.   " Take only the active version
*
*      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD09L
*                                     USING G_IREF_PDOCUMENT
*                                           'DD09L'.
*    ENDSELECT.
*  ENDIF.
*  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TECHNICAL>'.
*  FREE LT_DD09L.

* Get Table Fields 'DD03L'
  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_FIELD_METADATA>'.
  IF NOT R_TABNAME[] IS INITIAL.
    SELECT TABNAME FIELDNAME FROM  DD03L
    INTO CORRESPONDING FIELDS OF TABLE LT_DD03L PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_TABNAME
    WHERE  TABNAME = R_TABNAME-LOW
    AND    AS4LOCAL = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD03L
                                     USING G_IREF_PDOCUMENT
                                           'DD03L'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_FIELD_METADATA>'.
  FREE LT_DD03L.

* Get Table Fields Text 'DD03T'
  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_FIELD_TEXT>'.
  IF NOT R_TABNAME[] IS INITIAL.
    SELECT * FROM  DD03T
    INTO TABLE LT_DD03T PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_TABNAME
    WHERE  TABNAME = R_TABNAME-LOW
    AND    AS4LOCAL = 'A'.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD03T
                                     USING G_IREF_PDOCUMENT
                                           'DD03T'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_FIELD_TEXT>'.
  FREE LT_DD03T.

  IF NO_SUET_DATA IS INITIAL.
*   Get Table Indexes 'DD12V'
*   Don't get indexes that were created by SAP or DDIC,
*   This could happen in case of an index created by
*   SAP or DDIC on a generated table.
    PERFORM APPEND_STRING_TO_FILE USING '<TABLE_INDEXES>'.
    IF NOT G_TABNAME_INDEX[] IS INITIAL.
      SELECT SQLTAB INDEXNAME DDLANGUAGE DDTEXT FROM DD12V
      INTO CORRESPONDING FIELDS OF TABLE LT_DD12V PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN G_TABNAME_INDEX
      WHERE SQLTAB = G_TABNAME_INDEX-LOW
      AND NOT AS4USER IN ('SAP','DDIC')
      AND DDLANGUAGE IN ('E',SY-LANGU).

        SORT LT_DD12V BY SQLTAB INDEXNAME DDLANGUAGE.
        DELETE ADJACENT DUPLICATES FROM LT_DD12V
          COMPARING SQLTAB INDEXNAME DDLANGUAGE.

        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD12V
                                        USING  G_IREF_PDOCUMENT
                                        'DD12V'.
      ENDSELECT.
    ENDIF.
    PERFORM APPEND_STRING_TO_FILE USING '</TABLE_INDEXES>'.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</TABLES>'.

  PERFORM ADD_TIME_STAT USING 'Extract tables' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_tables

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_VANILLA_TABL_CUST_INDX
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_VANILLA_TABL_CUST_INDX.

  CHECK NO_SUET_DATA IS INITIAL.
  DATA: LT_DD12V   TYPE TABLE OF DD12V.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
    USING 'Extracting vanilla tables customer indexes'. "#EC NOTEXT

* Get Table Indexes 'DD12V'
  PERFORM APPEND_STRING_TO_FILE
    USING '<VANILLA_TABLE_CUSTOMER_INDEXES>'.

  SELECT SQLTAB INDEXNAME DDLANGUAGE DDTEXT FROM DD12V
  INTO CORRESPONDING FIELDS OF TABLE LT_DD12V PACKAGE SIZE PAC_SIZE
  WHERE NOT AS4USER IN ('SAP','DDIC')
  AND DDLANGUAGE IN ('E',SY-LANGU).

    DELETE LT_DD12V[] WHERE SQLTAB IN G_TABNAME_INDEX.

    SORT LT_DD12V BY SQLTAB INDEXNAME DDLANGUAGE.
    DELETE ADJACENT DUPLICATES FROM LT_DD12V
      COMPARING SQLTAB INDEXNAME DDLANGUAGE.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD12V
                                    USING  G_IREF_PDOCUMENT
                                    'DD12V'.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE
    USING '</VANILLA_TABLE_CUSTOMER_INDEXES>'.

  PERFORM ADD_TIME_STAT
    USING 'Extract vanilla tables customer indexes' "#EC NOTEXT
        L_STARTTIME L_STARTDATE.

  FREE G_TABNAME_INDEX[].


ENDFORM.                    " EXTRACT_VANILLA_TABL_CUST_INDX

*---------------------------------------------------------------------*
*       FORM extract_views                                            *
*---------------------------------------------------------------------*
FORM EXTRACT_VIEWS.

  TYPES: BEGIN OF VIEWS_TYPE,
           TABNAME LIKE DD02L-TABNAME,
         END OF VIEWS_TYPE.

  DATA: LT_VIEWS TYPE TABLE OF VIEWS_TYPE,
        VIEW_WA  LIKE LINE OF LT_VIEWS,
        VIEW_NAME TYPE DDOBJNAME,
        DD26V_TAB TYPE TABLE OF DD26V,
        DD27P_TAB TYPE TABLE OF DD27P,
        DD28J_TAB TYPE TABLE OF DD28J,
        DD28V_TAB TYPE TABLE OF DD28V,
        LT_VIEWS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LS_VIEW_NODE    LIKE LINE OF LT_VIEWS_NODES,
        VIEWS_NODE      TYPE XML_ELEMENT,
        VIEW_BASE_TABLES_NODE TYPE XML_ELEMENT,
        VIEW_FIELDS_NODE      TYPE XML_ELEMENT,
        VIEW_JOIN_NODE        TYPE XML_ELEMENT,
        VIEW_SELECTION_NODE   TYPE XML_ELEMENT,
        DUMMY_TAB_HANDLES TYPE HANDLES_TAB_TYPE.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  FIELD-SYMBOLS: <LS_VIEW> TYPE VIEWS_TYPE.

  RANGES: R_VIEWS FOR DD02L-TABNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting views'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_VIEW INTO GS_OBJECTLIST.
    CLEAR R_VIEWS.
    R_VIEWS-SIGN   = 'I'.
    R_VIEWS-OPTION = 'EQ'.
    R_VIEWS-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_VIEWS.
  ENDLOOP.

* Add also the SAP view types with * notion and
* tables that were changed by customer
  IF NOT G_VIEW_WITH_AST IS INITIAL.
    APPEND LINES OF G_VIEW_WITH_AST TO R_VIEWS.
  ENDIF.

  FREE GT_OBJ_VIEW.

  CHECK NOT R_VIEWS[] IS INITIAL.

* Get the matching views
  IF NOT R_VIEWS[] IS INITIAL.
    SELECT * FROM DD02L
    INTO CORRESPONDING FIELDS OF TABLE LT_VIEWS
    FOR ALL ENTRIES IN R_VIEWS
    WHERE TABNAME = R_VIEWS-LOW
    AND   AS4LOCAL = 'A'
    AND   TABCLASS = 'VIEW'
    AND AS4VERS = '0000'.   " Take only the active version

  ENDIF.

  CHECK NOT LT_VIEWS[] IS INITIAL.

* Create a child node for the Views node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'VIEWS'
                          CHANGING VIEWS_NODE.

* Add the views data to the current node
  PERFORM ADD_ITAB_TO_XML TABLES LT_VIEWS LT_VIEWS_NODES
                          USING G_IREF_PDOCUMENT VIEWS_NODE
                                'VIEW'.

  PERFORM APPEND_STRING_TO_FILE USING '<VIEWS>'.

  LOOP AT LT_VIEWS_NODES INTO LS_VIEW_NODE.

    ASSIGN LS_VIEW_NODE-WA->* TO <LS_VIEW>.

    CLEAR: VIEW_NAME, DD26V_TAB, DD27P_TAB,
            DD28J_TAB, DD28V_TAB.

    VIEW_NAME = <LS_VIEW>-TABNAME.
    CALL FUNCTION 'DDIF_VIEW_GET'
      EXPORTING
        NAME          = VIEW_NAME
        STATE         = 'A'
      TABLES
        DD26V_TAB     = DD26V_TAB
        DD27P_TAB     = DD27P_TAB
        DD28J_TAB     = DD28J_TAB
        DD28V_TAB     = DD28V_TAB
      EXCEPTIONS
        ILLEGAL_INPUT = 1
        OTHERS        = 2.

    CHECK SY-SUBRC IS INITIAL.

*   Get base Tables of a View
*   -------------------------
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LS_VIEW_NODE-NODE_REF
                                  'BASE_TABLES'
                            CHANGING VIEW_BASE_TABLES_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD26V_TAB
                             USING G_IREF_PDOCUMENT
                                   VIEW_BASE_TABLES_NODE
                                   'DD26V'.

*   Fields in an SAP Table View
*   ---------------------------
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LS_VIEW_NODE-NODE_REF
                                  'FIELDS'
                            CHANGING VIEW_FIELDS_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD27P_TAB
                             USING G_IREF_PDOCUMENT
                                   VIEW_FIELDS_NODE
                                   'DD27P'.

*   joins of views
*   --------------
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LS_VIEW_NODE-NODE_REF
                                  'JOINS'
                            CHANGING VIEW_JOIN_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD28J_TAB
                             USING G_IREF_PDOCUMENT
                                   VIEW_JOIN_NODE
                                   'DD28J'.

*   Selection Condition
*   -------------------
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LS_VIEW_NODE-NODE_REF
                                  'SELECTION_CONDITIONS'
                            CHANGING VIEW_SELECTION_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD28V_TAB
                             USING G_IREF_PDOCUMENT
                                   VIEW_SELECTION_NODE
                                   'DD28V'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                       LS_VIEW_NODE-NODE_REF 'X'.
    DELETE LT_VIEWS_NODES.

  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '</VIEWS>'.

  PERFORM ADD_TIME_STAT USING 'Extract views' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "extract_views

*&---------------------------------------------------------------------*
*&      Form  extract_foreign_keys
*&---------------------------------------------------------------------*
FORM EXTRACT_FOREIGN_KEYS.

  CHECK TESTING_DATA_ONLY IS INITIAL.
  DATA: DOMAIN LIKE DD03L-DOMNAME,
        LT_DD08L   TYPE TABLE OF DD08L  WITH HEADER LINE,
        LT_DD05M1  TYPE TABLE OF DD05M,
        LT_DD05M   TYPE TABLE OF DD05M.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_TABNAME FOR DD02L-TABNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting foreign keys'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_TABL INTO GS_OBJECTLIST.
    CLEAR R_TABNAME.
    R_TABNAME-SIGN   = 'I'.
    R_TABNAME-OPTION = 'EQ'.
    R_TABNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_TABNAME.
  ENDLOOP.

  FREE GT_OBJ_TABL.

  CHECK NOT R_TABNAME[] IS INITIAL.

* Get Foreign Keys Data
  IF NOT R_TABNAME[] IS INITIAL.
    SELECT * FROM  DD08L
    INTO TABLE LT_DD08L
    FOR ALL ENTRIES IN R_TABNAME
    WHERE  TABNAME = R_TABNAME-LOW
    AND  AS4LOCAL = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

  ENDIF.

  CHECK NOT LT_DD08L[] IS INITIAL.

  LOOP AT LT_DD08L WHERE CHECKTABLE = '*'.
    SELECT SINGLE DOMNAME
    FROM   DD03L
    INTO   DOMAIN
    WHERE  TABNAME = LT_DD08L-TABNAME
    AND    FIELDNAME = LT_DD08L-FIELDNAME
    AND    AS4LOCAL = LT_DD08L-AS4LOCAL
    AND    AS4VERS = LT_DD08L-AS4VERS.                      "#EC WARNOK

    CHECK SY-SUBRC IS INITIAL.

    SELECT SINGLE ENTITYTAB FROM DD01L
    INTO LT_DD08L-CHECKTABLE
    WHERE DOMNAME = DOMAIN
    AND   AS4LOCAL = 'A'.                                   "#EC WARNOK

    MODIFY LT_DD08L TRANSPORTING CHECKTABLE.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEYS>'.

  PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEY_DATA>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD08L
                                 USING G_IREF_PDOCUMENT
                                       'DD08L'.
  PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEY_DATA>'.

* Get the Foreign Keys Fields
  LOOP AT LT_DD08L.
    CALL FUNCTION 'DD_TBFK_GET'
      EXPORTING
        FIELDNAME     = LT_DD08L-FIELDNAME
        TABL_NAME     = LT_DD08L-TABNAME
      TABLES
        DD05M_TAB_N   = LT_DD05M1
      EXCEPTIONS
        ILLEGAL_VALUE = 1
        OTHERS        = 2.
    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'illegal_value'. "#EC NOTEXT
        WHEN 2. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
      'extract foreign keys: DD_TBFK_GET, table:' "#EC NOTEXT
            LT_DD08L-TABNAME 'Error:' ERROR "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    CHECK SY-SUBRC = 0.
    APPEND LINES OF LT_DD05M1 TO LT_DD05M.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEY_FIELDS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD05M
                                 USING G_IREF_PDOCUMENT
                                       'DD05M'.
  PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEY_FIELDS>'.
  FREE: LT_DD05M, LT_DD08L.

  PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEYS>'.

  PERFORM ADD_TIME_STAT USING 'Extract foreign keys' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_foreign_keys

*&---------------------------------------------------------------------*
*&      Form  extract_data_elements
*&---------------------------------------------------------------------*
FORM EXTRACT_DATA_ELEMENTS.

  TYPES: BEGIN OF DD04L_TYPE,
          ROLLNAME LIKE DD04L-ROLLNAME,
          DOMNAME LIKE DD04L-DOMNAME,
         END OF DD04L_TYPE.

  DATA: LT_DD04L   TYPE TABLE OF DD04L_TYPE,
        LT_DD04T   TYPE TABLE OF DD04T,
        DD04L_WA   LIKE LINE OF LT_DD04L,
        ABTYPE_INT LIKE  DD03L-INTTYPE,
        ABLEN LIKE  DD03L-INTLEN.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: BEGIN OF DATA_ELEMENTS OCCURS 0.
          INCLUDE STRUCTURE DD04L.
  DATA:   INTTYPE LIKE DFIES-INTTYPE,
          INTLEN  LIKE DFIES-INTLEN,
        END OF DATA_ELEMENTS,
        DATA_ELEMENT LIKE LINE OF DATA_ELEMENTS.

  RANGES: R_ROLLNAME FOR DD04L-ROLLNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting data elements'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_DELM INTO GS_OBJECTLIST.
    CLEAR R_ROLLNAME.
    R_ROLLNAME-SIGN   = 'I'.
    R_ROLLNAME-OPTION = 'EQ'.
    R_ROLLNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_ROLLNAME.
  ENDLOOP.

  FREE GT_OBJ_DELM.

  CHECK NOT R_ROLLNAME[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENTS>'.

* Get Data Elements Data 'DD04L'
  PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENT_DATA>'.
  IF NOT R_ROLLNAME[] IS INITIAL.
    SELECT * FROM  DD04L
    INTO CORRESPONDING FIELDS OF TABLE LT_DD04L PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_ROLLNAME
    WHERE  ROLLNAME = R_ROLLNAME-LOW
    AND    AS4LOCAL  = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD04L
                                     USING G_IREF_PDOCUMENT
                                           'DD04L'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENT_DATA>'.
  FREE LT_DD04L.

* Get Data Elements Text 'DD04T'
  PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENT_TEXT>'.
  IF NOT R_ROLLNAME[] IS INITIAL.
    SELECT * FROM  DD04T
    INTO TABLE LT_DD04T PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_ROLLNAME
    WHERE  ROLLNAME = R_ROLLNAME-LOW
    AND    AS4LOCAL  = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD04T
                                     USING G_IREF_PDOCUMENT
                                           'DD04T'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENT_TEXT>'.
  FREE LT_DD04T.

  PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENTS>'.

  PERFORM ADD_TIME_STAT USING 'Extract data elements' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_data_elements

*&---------------------------------------------------------------------*
*&      Form  extract_table_types
*&---------------------------------------------------------------------*
FORM EXTRACT_TABLE_TYPES.

  DATA: LT_DD40L   TYPE TABLE OF DD40L,
        LT_DD40T   TYPE TABLE OF DD40T.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_TYPENAME FOR DD40L-TYPENAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting table types'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_TTYP INTO GS_OBJECTLIST.
    CLEAR R_TYPENAME.
    R_TYPENAME-SIGN   = 'I'.
    R_TYPENAME-OPTION = 'EQ'.
    R_TYPENAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_TYPENAME.
  ENDLOOP.

  FREE GT_OBJ_TTYP.

  CHECK NOT R_TYPENAME[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES>'.

* Get Table Types Data 'DD40L'
  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES_DATA>'.
  IF NOT R_TYPENAME[] IS INITIAL.
*   Get Table Types Data
    SELECT * FROM  DD40L
    INTO TABLE LT_DD40L PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_TYPENAME
    WHERE  TYPENAME = R_TYPENAME-LOW
    AND    AS4LOCAL = 'A'.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD40L
                                     USING G_IREF_PDOCUMENT
                                           'DD40L'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES_DATA>'.
  FREE LT_DD40L.

* Get Table Types Text 'DD40T'
  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES_TEXT>'.
  IF NOT R_TYPENAME[] IS INITIAL.
    SELECT * FROM  DD40T
    INTO TABLE LT_DD40T PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_TYPENAME
    WHERE  TYPENAME = R_TYPENAME-LOW
    AND    AS4LOCAL = 'A'.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD40T
                                     USING G_IREF_PDOCUMENT
                                           'DD40T'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES_TEXT>'.
  FREE LT_DD40T.

  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract table types' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_table_types

*&---------------------------------------------------------------------*
*&      Form  extract_domains
*&---------------------------------------------------------------------*
FORM EXTRACT_DOMAINS.

  DATA: BEGIN OF LT_DD01L  OCCURS 0.
          INCLUDE STRUCTURE DD01L.
  DATA:   ABCODE      TYPE X031L-FIELDTYPE,   " ABAP Coding for nametab
          ABLEN       TYPE DD03L-INTLEN,      " ABAP Length
          ABTYPE      TYPE DD03L-INTTYPE,     " ABAP Category
          ABTYPE_INT  TYPE DD03L-INTTYPE,     " ABAP Nametab type
        END OF LT_DD01L,
        LT_DD01T   TYPE TABLE OF DD01T.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_DOMNAME FOR DD01L-DOMNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting domains'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_DOMN INTO GS_OBJECTLIST.
    CLEAR R_DOMNAME.
    R_DOMNAME-SIGN   = 'I'.
    R_DOMNAME-OPTION = 'EQ'.
    R_DOMNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_DOMNAME.
  ENDLOOP.

  FREE GT_OBJ_DOMN.

  CHECK NOT R_DOMNAME[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS>'.

* Extract the Domains Data 'DD01L'
  PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS_DATA>'.
  IF NOT R_DOMNAME[] IS INITIAL.
*     Get Domains Data
    SELECT * FROM  DD01L
    INTO TABLE LT_DD01L PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_DOMNAME
    WHERE  DOMNAME = R_DOMNAME-LOW
    AND    AS4LOCAL = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      LOOP AT LT_DD01L.
        GV_TABIX = SY-TABIX.
*     Get ABAP Types
        CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
          EXPORTING
            DDLEN         = LT_DD01L-LENG
            DDTYPE        = LT_DD01L-DATATYPE
          IMPORTING
            ABCODE        = LT_DD01L-ABCODE
            ABLEN         = LT_DD01L-ABLEN
            ABTYPE        = LT_DD01L-ABTYPE
            ABTYPE_INT    = LT_DD01L-ABTYPE_INT
          EXCEPTIONS
            ILLEGAL_VALUE = 1
            OTHERS        = 2.
        IF SY-SUBRC <> 0.
          CLEAR ERROR.
          CASE SY-SUBRC.
            WHEN 1. ERROR = 'illegal_value'. "#EC NOTEXT
            WHEN 2. ERROR = 'Others'. "#EC NOTEXT
          ENDCASE.

          CONCATENATE
          'extract domains: DD_DDTYPE_TO_ABAPTYPE, type:' "#EC NOTEXT
                LT_DD01L-DATATYPE 'Error:' ERROR "#EC NOTEXT
                INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
          PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
        ENDIF.
        CHECK SY-SUBRC = 0.
        MODIFY LT_DD01L INDEX GV_TABIX TRANSPORTING ABCODE ABLEN ABTYPE
                                                    ABTYPE_INT.
      ENDLOOP.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD01L
                                     USING G_IREF_PDOCUMENT
                                           'DD01L'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS_DATA>'.
  FREE LT_DD01L.

* Extract the Domains Data 'DD01T'
  PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS_TEXT>'.
  IF NOT R_DOMNAME[] IS INITIAL.
    SELECT * FROM  DD01T
    INTO TABLE LT_DD01T PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_DOMNAME
    WHERE  DOMNAME = R_DOMNAME-LOW
    AND    AS4LOCAL = 'A'
    AND AS4VERS = '0000'.   " Take only the active version

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD01T
                                     USING G_IREF_PDOCUMENT
                                           'DD01T'.
    ENDSELECT.
  ENDIF.
  PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS_TEXT>'.
  FREE LT_DD01T.

  PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract domains' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_domains

*&---------------------------------------------------------------------*
*&      Form  extract_data_types
*&---------------------------------------------------------------------*
FORM EXTRACT_DATA_TYPES.

  DATA: DATA_TYPES_NODE  TYPE XML_ELEMENT,
        TYPES_INDEX_NODE TYPE XML_ELEMENT,
        DATA_ELEMENTS_NODE TYPE XML_ELEMENT,
        TABLES_NODE TYPE XML_ELEMENT,
        CLUSTERS_NODE TYPE XML_ELEMENT,
        VIEWS_NODE TYPE XML_ELEMENT,
        TABLE_TYPES_NODE TYPE XML_ELEMENT,
        DATA_TYPES TYPE TABLE OF DDTYPES_TYPE,
        NEW_TYPEKIND TYPE C,
        END_TYPEKIND TYPE C,
        TAG_NAME     TYPE STRING,
        START_TAG    TYPE STRING,
        END_TAG      TYPE STRING,
        DATA_ELEMENT TYPE DATA_ELEMENT_TAB_TYPE,
        STRUCTURE_FIELDS TYPE STRUCTURE_FIELDS_TAB_TYPE,
        TABLE_TYPE TYPE TABLE_TYPE_TAB_TYPE,
        LT_DDTYPES   TYPE TABLE OF DDTYPES_TYPE,
        LS_DDTYPE    LIKE LINE OF LT_DDTYPES.

  DATA: L_STARTTIME TYPE SY-UZEIT,
      L_STARTDATE TYPE SY-DATUM.

  RANGES: R_TYPENAME FOR DDTYPES-TYPENAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting data types'. "#EC NOTEXT

* Set Object list
  LOOP AT GT_OBJ_TYPE INTO GS_OBJECTLIST.
    CLEAR R_TYPENAME.
    R_TYPENAME-SIGN   = 'I'.
    R_TYPENAME-OPTION = 'EQ'.
    R_TYPENAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_TYPENAME.
  ENDLOOP.

  FREE GT_OBJ_TYPE.

* Add also the SAP types with append structure
  IF NOT G_APP_STRUC IS INITIAL.
    APPEND LINES OF G_APP_STRUC TO R_TYPENAME.
  ENDIF.
* Add also the SAP types with customer include
  IF NOT G_INC_STRUC IS INITIAL.
    APPEND LINES OF G_INC_STRUC TO R_TYPENAME.
  ENDIF.
* Add also the SAP view types with * notion and
* tables that were changed by customer
  IF NOT G_VIEW_WITH_AST IS INITIAL.
    APPEND LINES OF G_VIEW_WITH_AST TO R_TYPENAME.
  ENDIF.

  CHECK NOT R_TYPENAME[] IS INITIAL.

  IF NOT R_TYPENAME[] IS INITIAL.
*   Get Master Tables Data
    SELECT * FROM  DDTYPES
    INTO CORRESPONDING FIELDS OF TABLE LT_DDTYPES
    FOR ALL ENTRIES IN R_TYPENAME
    WHERE  TYPENAME = R_TYPENAME-LOW
    AND    STATE = 'A'.

    FREE R_TYPENAME.
  ENDIF.

  CHECK NOT LT_DDTYPES[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<DATA_TYPES>'.

* Add the Master Tables Data
  PERFORM APPEND_STRING_TO_FILE USING '<DDTYPES_INDEX>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DDTYPES
                                 USING G_IREF_PDOCUMENT
                                       'DDTYPE'.
  PERFORM APPEND_STRING_TO_FILE USING '</DDTYPES_INDEX>'.

  SORT LT_DDTYPES BY TYPEKIND TYPENAME.

* Process types
  LOOP AT LT_DDTYPES INTO LS_DDTYPE.

    CLEAR: NEW_TYPEKIND, END_TYPEKIND, TAG_NAME.

*   Check that the current data type is supported
    CHECK LS_DDTYPE-TYPEKIND = 'DTEL' OR LS_DDTYPE-TYPEKIND = 'TABL' OR
          LS_DDTYPE-TYPEKIND = 'SQLT' OR LS_DDTYPE-TYPEKIND = 'VIEW' OR
          LS_DDTYPE-TYPEKIND = 'TTYP' OR ( LS_DDTYPE-TYPEKIND = 'INTF'
AND VANILLA = 'X' ).

    AT NEW TYPEKIND. NEW_TYPEKIND = 'X'. ENDAT.
    AT END OF TYPEKIND. END_TYPEKIND = 'X'. ENDAT.

    IF NEW_TYPEKIND = 'X' OR END_TYPEKIND = 'X'.
      CASE LS_DDTYPE-TYPEKIND.
        WHEN 'DTEL'.
          TAG_NAME = 'DATA_ELEMENTS'.
        WHEN 'TABL'.
          TAG_NAME = 'TABLES'.
        WHEN 'SQLT'.
          TAG_NAME = 'CLUSTER_TABLES'.
        WHEN 'VIEW'.
          TAG_NAME = 'VIEWS'.
        WHEN 'TTYP'.
          TAG_NAME = 'TABLE_TYPES'.
        WHEN 'INTF'.
          TAG_NAME = 'INTERFACES'.

      ENDCASE.
    ENDIF.

    IF NEW_TYPEKIND = 'X'.
      CONCATENATE '<' TAG_NAME '>' INTO START_TAG.
      PERFORM APPEND_STRING_TO_FILE USING START_TAG.
    ENDIF.

*   Process the type
    CLEAR: DATA_ELEMENT, STRUCTURE_FIELDS, TABLE_TYPE.

    PERFORM GET_TYPE_FIELDS TABLES DATA_ELEMENT
                                   STRUCTURE_FIELDS
                                   TABLE_TYPE
                            USING  LS_DDTYPE.

    CASE LS_DDTYPE-TYPEKIND.

      WHEN 'DTEL'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES DATA_ELEMENT
                                       USING G_IREF_PDOCUMENT
                                             'DATA_ELEMENT'.
      WHEN 'TABL'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
                                       USING G_IREF_PDOCUMENT
                                             'TABLE_FIELD'.
      WHEN 'SQLT'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
                                       USING G_IREF_PDOCUMENT
                                             'CLUSTER_TABLE_FIELD'.
      WHEN 'VIEW'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
                                       USING G_IREF_PDOCUMENT
                                             'VIEW_FIELD'.
      WHEN 'TTYP'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TABLE_TYPE
                                       USING G_IREF_PDOCUMENT
                                             'TABLE_TYPE'.
      WHEN 'INTF'.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
                                       USING G_IREF_PDOCUMENT
                                             'INTERFACE'.

    ENDCASE.

    IF END_TYPEKIND = 'X'.
      CONCATENATE '</' TAG_NAME '>' INTO END_TAG.
      PERFORM APPEND_STRING_TO_FILE USING END_TAG.
    ENDIF.

  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '</DATA_TYPES>'.

  PERFORM ADD_TIME_STAT USING 'Extract data types' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_data_types

*---------------------------------------------------------------------*
*       FORM get_type_fields                                          *
*---------------------------------------------------------------------*
FORM GET_TYPE_FIELDS TABLES
                       DATA_ELEMENT TYPE DATA_ELEMENT_TAB_TYPE
                       STRUCTURE_FIELDS TYPE STRUCTURE_FIELDS_TAB_TYPE
                       TABLE_TYPE TYPE TABLE_TYPE_TAB_TYPE
                     USING DATA_TYPE TYPE DDTYPES_TYPE.

  DATA:   ROLLNAME TYPE ROLLNAME,
          TABNAME TYPE DDOBJNAME,
          TYPENAME TYPE DD40L-TYPENAME,
          DD04L_ITAB TYPE TABLE OF DD04L,
          DD04L_WA TYPE DD04L,
          ABTYPE_INT LIKE  DD03L-INTTYPE,
          ABLEN LIKE  DD03L-INTLEN,
          DDTYPE LIKE  DD01V-DATATYPE,
          DD02L_WA LIKE DD02L,
          NEXT_FIELD_OFFSET LIKE DFIES-OFFSET.

  ROLLNAME = DATA_TYPE-TYPENAME.
  TABNAME = DATA_TYPE-TYPENAME.
  TYPENAME = DATA_TYPE-TYPENAME.

* Decide according to kind from where to read its definition
  CASE DATA_TYPE-TYPEKIND.
    WHEN 'DTEL'. " Data Element

*     OBJECT is a Data Element
      SELECT * FROM DD04L
      INTO TABLE DD04L_ITAB
      WHERE ROLLNAME = ROLLNAME
      AND   AS4LOCAL = 'A'.

      CHECK SY-SUBRC IS INITIAL.

      LOOP AT DD04L_ITAB INTO DD04L_WA.
        DATA_ELEMENT-ROLLNAME = DD04L_WA-ROLLNAME.
        DATA_ELEMENT-DECIMALS = DD04L_WA-DECIMALS.

        IF DD04L_WA-REFKIND = 'R'. "Reference type
          DATA_ELEMENT-INTTYPE = 'l'.
          DATA_ELEMENT-INTLEN = 8.
        ELSE.
          DDTYPE = DD04L_WA-DATATYPE.
          CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
            EXPORTING
              DDLEN         = DD04L_WA-LENG
              DDTYPE        = DDTYPE
            IMPORTING
              ABLEN         = ABLEN
              ABTYPE_INT    = ABTYPE_INT
            EXCEPTIONS
              ILLEGAL_VALUE = 1
              OTHERS        = 2.
          IF SY-SUBRC IS INITIAL.
            PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
            DATA_ELEMENT-INTTYPE = ABTYPE_INT.
            DATA_ELEMENT-INTLEN = ABLEN.
          ENDIF.
        ENDIF.
        APPEND DATA_ELEMENT.
      ENDLOOP.

    WHEN 'TABL' OR 'SQLT' OR 'VIEW'. " Table or cluster table

*     OBJECT is a DB/cluster table OR a Structure
      CALL FUNCTION 'DDIF_NAMETAB_GET'
           EXPORTING
                TABNAME     = TABNAME
                ALL_TYPES   = 'X'
*                group_names = 'X'
           TABLES
                DFIES_TAB   = STRUCTURE_FIELDS
           EXCEPTIONS
               NOT_FOUND         = 1
               OTHERS            = 2
          .

      CHECK SY-SUBRC IS INITIAL.
      DELETE STRUCTURE_FIELDS WHERE LFIELDNAME CA '-'.

      LOOP AT STRUCTURE_FIELDS.

*        Get position and depth from table definition
*        (overriding actual position in runtime type)
        SELECT SINGLE POSITION ADMINFIELD REFFIELD PRECFIELD
        FROM   DD03L
        INTO   (STRUCTURE_FIELDS-POSITION, STRUCTURE_FIELDS-ADMINFIELD,
                STRUCTURE_FIELDS-REFFIELD, STRUCTURE_FIELDS-PRECFIELD)
        WHERE  TABNAME = STRUCTURE_FIELDS-TABNAME
        AND    FIELDNAME = STRUCTURE_FIELDS-FIELDNAME
        AND    AS4LOCAL = 'A'
        AND    DEPTH = ' '.                                 "#EC WARNOK

        IF SY-SUBRC > 0.
          STRUCTURE_FIELDS-ADMINFIELD = '0'.
          CLEAR: STRUCTURE_FIELDS-REFFIELD,
                 STRUCTURE_FIELDS-PRECFIELD.
        ENDIF.

        DDTYPE = STRUCTURE_FIELDS-DATATYPE.
        IF STRUCTURE_FIELDS-COMPTYPE = 'E' OR
            STRUCTURE_FIELDS-COMPTYPE = SPACE.
          CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
            EXPORTING
              DDLEN         = STRUCTURE_FIELDS-LENG
              DDTYPE        = DDTYPE
            IMPORTING
              ABLEN         = ABLEN
              ABTYPE_INT    = ABTYPE_INT
            EXCEPTIONS
              ILLEGAL_VALUE = 1
              OTHERS        = 2.
          IF SY-SUBRC IS INITIAL.
            PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
            STRUCTURE_FIELDS-INTTYPE = ABTYPE_INT.
            STRUCTURE_FIELDS-INTLEN = ABLEN.
          ENDIF.
        ENDIF.

        IF STRUCTURE_FIELDS-CHECKTABLE = '*'.
          SELECT SINGLE ENTITYTAB
          FROM DD01L
          INTO STRUCTURE_FIELDS-CHECKTABLE
          WHERE DOMNAME = STRUCTURE_FIELDS-DOMNAME
          AND   AS4LOCAL = 'A'.                             "#EC WARNOK
        ENDIF.
        MODIFY STRUCTURE_FIELDS INDEX SY-TABIX.
      ENDLOOP.

*     Add include structure fields to the type
      SELECT *
      FROM   DD03L
      APPENDING CORRESPONDING FIELDS OF TABLE STRUCTURE_FIELDS
      WHERE  TABNAME = STRUCTURE_FIELDS-TABNAME
      AND    AS4LOCAL = 'A'
      AND    PRECFIELD NE SPACE.

*     Add offsets to fields that are missing it
      SORT STRUCTURE_FIELDS BY POSITION DESCENDING.
      LOOP AT STRUCTURE_FIELDS.

*       Do not touch the first field since it should stay 0
        AT LAST.
          EXIT.
        ENDAT.
        IF SY-TABIX >= 2 AND NOT STRUCTURE_FIELDS-PRECFIELD IS INITIAL.
          STRUCTURE_FIELDS-OFFSET = NEXT_FIELD_OFFSET.
          MODIFY STRUCTURE_FIELDS INDEX SY-TABIX TRANSPORTING OFFSET.
        ENDIF.
        NEXT_FIELD_OFFSET = STRUCTURE_FIELDS-OFFSET.
      ENDLOOP.

*     Sort the returned table by the field position
      SORT STRUCTURE_FIELDS BY POSITION ASCENDING.

    WHEN 'TTYP'. " Table type

*     Check if the OBJECT is a Table type
      SELECT * FROM DD40L
      INTO TABLE TABLE_TYPE
      WHERE TYPENAME = TYPENAME
      AND   AS4LOCAL = 'A'.

      CHECK SY-SUBRC IS INITIAL.

      LOOP AT TABLE_TYPE.
        IF NOT TABLE_TYPE-DATATYPE IS INITIAL.
          DDTYPE = TABLE_TYPE-DATATYPE.
          CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
            EXPORTING
              DDLEN         = TABLE_TYPE-LENG
              DDTYPE        = DDTYPE
            IMPORTING
              ABLEN         = ABLEN
              ABTYPE_INT    = ABTYPE_INT
            EXCEPTIONS
              ILLEGAL_VALUE = 1
              OTHERS        = 2.
          IF SY-SUBRC IS INITIAL.
            PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
            TABLE_TYPE-INTTYPE = ABTYPE_INT.
            TABLE_TYPE-INTLEN = ABLEN.
          ENDIF.
          MODIFY TABLE_TYPE
               INDEX SY-TABIX TRANSPORTING INTTYPE INTLEN.
        ENDIF.
      ENDLOOP.

    WHEN 'INTF'.  " Interface

      STRUCTURE_FIELDS-TABNAME = TABNAME.
      APPEND STRUCTURE_FIELDS.

  ENDCASE.

ENDFORM.                    "get_type_fields

*&---------------------------------------------------------------------*
*&      Form  INTLEN_TO_UCLEN
*&---------------------------------------------------------------------*
FORM UCLEN_TO_INTLEN USING DATATYPE
                           INTLEN   LIKE DD03P-INTLEN
                           UC_LEN   LIKE X030L-UNICODELG.

  DATA CHAR_TYPES(60) VALUE
       'ACCP CHAR CLNT CUKY DATS LANG LCHR NUMC TIMS TMST VARC UNIT'.
  DATA: MASK00(1) TYPE X VALUE 00,
        MASK01(1) TYPE X VALUE 01.

  IF UC_LEN <> MASK00 AND UC_LEN <> MASK01 AND CHAR_TYPES CS DATATYPE.
    INTLEN = INTLEN / UC_LEN.
  ENDIF.

ENDFORM.                    " INTLEN_TO_UCLENGTH

*&---------------------------------------------------------------------*
*&      Form  extract_user_exits
*&---------------------------------------------------------------------*
FORM EXTRACT_USER_EXITS.

  DATA: USER_EXIT_ENHANCEMENTS_TEXTS TYPE XML_ELEMENT,
        USER_EXIT_COMPONENTS_TEXTS TYPE XML_ELEMENT,
        LT_MODATTR  TYPE TABLE OF MODATTR,
        LT_MODTEXT  TYPE TABLE OF MODTEXT,
        LT_MODSAPT  TYPE TABLE OF MODSAPT,
        LT_TFTIT    TYPE TABLE OF TFTIT,
        LV_FUNCNAME TYPE RS38L-NAME,
        LV_INCLUDE  TYPE RS38L-INCLUDE,
        LT_SOURCE   TYPE TABLE OF  ABAPSOURCE  WITH HEADER LINE,
        LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
        LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
        MODSAP_WA   TYPE MODSAP,
        RC LIKE SY-SUBRC.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  DATA: BEGIN OF LT_EXITS  OCCURS 0,
          PROJECT      TYPE MODACT-NAME,
ENHANCEMENT  TYPE MODACT-MEMBER,
          COMPONENT    TYPE MODSAP-MEMBER,
          INCLUDE      TYPE RS38L-INCLUDE,
          IMPLEMENTED  TYPE CHAR3,
        END OF LT_EXITS.

  RANGES: R_NAME FOR MODACT-NAME,
          R_MODSAPT FOR MODSAPT-NAME,
          R_FUNCTIONS FOR TFTIT-FUNCNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting user exits'. "#EC NOTEXT

* Set Object list - projects (CMOD)
  LOOP AT GT_OBJ_UEXT INTO GS_OBJECTLIST.
    CLEAR R_NAME.
    R_NAME-SIGN   = 'I'.
    R_NAME-OPTION = 'EQ'.
    R_NAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_NAME.
  ENDLOOP.

  FREE GT_OBJ_UEXT.

* Get all SAP enhancements
  SELECT * FROM MODSAP
  INTO MODSAP_WA
  WHERE TYP = 'E'.
    LT_EXITS-ENHANCEMENT = MODSAP_WA-NAME.
    LT_EXITS-COMPONENT = MODSAP_WA-MEMBER.
    APPEND LT_EXITS.
  ENDSELECT.

* Get projects attributes
  SELECT * FROM  MODATTR
  INTO TABLE LT_MODATTR
  WHERE  NAME  IN R_NAME.

* Get projects descriptions
  SELECT * FROM  MODTEXT "#EC CI_NOFIRST
  INTO TABLE LT_MODTEXT
  WHERE  NAME  IN R_NAME.

  CHECK NOT LT_EXITS[] IS INITIAL.

  SORT LT_EXITS.
  LOOP AT LT_EXITS.
    GV_TABIX = SY-TABIX.
    LV_FUNCNAME = LT_EXITS-COMPONENT.
    CLEAR LV_INCLUDE.

*   Get the function exit's program
    CALL FUNCTION 'FUNCTION_EXISTS'
      EXPORTING
        FUNCNAME           = LV_FUNCNAME
      IMPORTING
        INCLUDE            = LV_INCLUDE
      EXCEPTIONS
        FUNCTION_NOT_EXIST = 1
        OTHERS             = 2.

    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'function_not_exist'. "#EC NOTEXT
        WHEN 2. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
      'extract user exits: FUNCTION_EXISTS, function:' "#EC NOTEXT
            LV_FUNCNAME 'Error:' ERROR "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      DELETE LT_EXITS.
      CONTINUE.
    ENDIF.

    REFRESH: LT_SOURCE, LT_SOURCE_EXT.
*   Get the function exit's source
    CALL FUNCTION 'RPY_PROGRAM_READ'
      EXPORTING
        PROGRAM_NAME     = LV_INCLUDE
      TABLES
        SOURCE           = LT_SOURCE
        SOURCE_EXTENDED  = LT_SOURCE_EXT
      EXCEPTIONS
        CANCELLED        = 1
        NOT_FOUND        = 2
        PERMISSION_ERROR = 3
        OTHERS           = 4.
    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'cancelled'. "#EC NOTEXT
        WHEN 2. ERROR = 'not_found'. "#EC NOTEXT
        WHEN 3. ERROR = 'permission_error'. "#EC NOTEXT
        WHEN 4. ERROR = 'Others'. "#EC NOTEXT
      ENDCASE.

      CONCATENATE
      'extract user exits: RPY_PROGRAM_READ, program:' "#EC NOTEXT
            LV_INCLUDE 'Error:' ERROR "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      DELETE LT_EXITS.
      CONTINUE.
    ENDIF.

    IF NOT LT_SOURCE[] IS INITIAL.
      LT_UNIFIED_SOURCE[] = LT_SOURCE[].
    ELSE.
      LT_UNIFIED_SOURCE[] = LT_SOURCE_EXT[].
    ENDIF.

*   Go over the function exit's source code and find the 'Z' include
*   name. Then, check if the include exists which means that it is
*   implemented by the cutomer
    LOOP AT LT_UNIFIED_SOURCE.
      CHECK LT_UNIFIED_SOURCE-LINE(1) <> '*'.
      TRANSLATE LT_UNIFIED_SOURCE-LINE TO UPPER CASE.
      SEARCH LT_UNIFIED_SOURCE-LINE FOR 'INCLUDE'.
      IF SY-SUBRC = 0.
        ADD 8 TO SY-FDPOS.
        LT_EXITS-INCLUDE = LT_UNIFIED_SOURCE-LINE+SY-FDPOS.
        REPLACE '.' WITH SPACE INTO LT_EXITS-INCLUDE.

*       Check if the include is implemented
        SELECT SINGLE * FROM  TRDIR
        WHERE  NAME  = LT_EXITS-INCLUDE.

        IF SY-SUBRC = 0.
          LT_EXITS-IMPLEMENTED = 'YES'.

*         Create a list of the implemented enhancements
          R_MODSAPT-SIGN = 'I'.
          R_MODSAPT-OPTION = 'EQ'.
          R_MODSAPT-LOW = LT_EXITS-ENHANCEMENT.
          APPEND R_MODSAPT.

*         Create a list of all function exits
          R_FUNCTIONS-SIGN = 'I'.
          R_FUNCTIONS-OPTION = 'EQ'.
          R_FUNCTIONS-LOW = LT_EXITS-COMPONENT.
          APPEND R_FUNCTIONS.

          SELECT SINGLE NAME FROM MODACT
          INTO LT_EXITS-PROJECT
          WHERE MEMBER = LT_EXITS-ENHANCEMENT.              "#EC WARNOK

          MODIFY LT_EXITS INDEX GV_TABIX TRANSPORTING
                                PROJECT INCLUDE IMPLEMENTED.
        ELSE.
          DELETE LT_EXITS.
        ENDIF.

        EXIT.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXITS>'.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_ATTRIBUTES>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODATTR
                                 USING G_IREF_PDOCUMENT
                                       'MODATTR'.
  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_ATTRIBUTES>'.
  FREE LT_MODATTR.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_COMPONENTS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_EXITS
                                 USING G_IREF_PDOCUMENT
                                       'MODACT'.
  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_COMPONENTS>'.
  FREE LT_EXITS.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_TEXT>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODTEXT
                                 USING G_IREF_PDOCUMENT
                                       'MODTEXT'.
  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_TEXT>'.
  FREE LT_MODTEXT.

* Read enhancements descriptions 'MODSAPT'
  IF NOT R_MODSAPT[] IS INITIAL.
    SELECT * FROM MODSAPT
    INTO TABLE LT_MODSAPT
    FOR ALL ENTRIES IN R_MODSAPT
    WHERE NAME = R_MODSAPT-LOW.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_ENHANCEMENTS_TEXTS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODSAPT
                                 USING G_IREF_PDOCUMENT
                                       'MODSAPT'.
  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_ENHANCEMENTS_TEXTS>'.
  FREE LT_MODSAPT.

* Read function exits descriptions 'TFTIT'
  IF NOT R_FUNCTIONS[] IS INITIAL.
    SELECT * FROM TFTIT
    INTO TABLE LT_TFTIT
    FOR ALL ENTRIES IN R_FUNCTIONS
    WHERE FUNCNAME = R_FUNCTIONS-LOW.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_COMPONENTS_TEXTS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TFTIT
                                 USING G_IREF_PDOCUMENT
                                       'TFTIT'.
  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_COMPONENTS_TEXTS>'.
  FREE LT_TFTIT.

  PERFORM APPEND_STRING_TO_FILE USING '</USER_EXITS>'.

  PERFORM ADD_TIME_STAT USING 'Extract user exits' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_user_exits

*---------------------------------------------------------------------*
*       FORM extract_modifications                                    *
*---------------------------------------------------------------------*
FORM EXTRACT_MODIFICATIONS.

  DATA: BEGIN OF CWBNTHEAD_ITAB OCCURS 0,
          NUMM(10) TYPE N,
          VERSNO(4) TYPE N,
          THEMK(24),
          INSTA(10),
          MNUMM(10),
          MYEAR(4) TYPE N,
          INCOMPLETE,
        END OF CWBNTHEAD_ITAB.

  DATA: BEGIN OF CWBNTCUST_ITAB OCCURS 0,
          NUMM(10) TYPE N,
          NTSTATUS,
          PRSTATUS,
          CWBUSER(12),
        END OF CWBNTCUST_ITAB.

  DATA: MOD_ITAB TYPE TABLE OF SMODILOG,
        E07T_ITAB TYPE TABLE OF E07T,
        E070_ITAB TYPE TABLE OF E070,
        E071_ITAB TYPE TABLE OF E071,
        TEMP_DD02L TYPE DD02L.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: LV_MONTHS_BACK TYPE I,
        LV_EXTRACT_DATE TYPE DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

* Calculate the date according to months back parameter
  LV_MONTHS_BACK = 0 - CRS_EXTRACTION_MONTHS.

  CALL FUNCTION 'CALCULATE_DATE'
    EXPORTING
*     DAYS              = '0'
      MONTHS            = LV_MONTHS_BACK
      START_DATE        = SY-DATUM
    IMPORTING
      RESULT_DATE       = LV_EXTRACT_DATE.

  PERFORM UPDATE_PROGRESS USING 'Extracting modifications'. "#EC NOTEXT

* extract smodilog
  PERFORM APPEND_STRING_TO_FILE USING '<MODIFICATIONS>'.

  SELECT * FROM SMODILOG                                "#EC CI_NOWHERE
  INTO TABLE MOD_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES MOD_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'SMODILOG'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</MODIFICATIONS>'.

  FREE MOD_ITAB.

* extract Change Request texts ( E070 )
  PERFORM APPEND_STRING_TO_FILE USING '<CRS>'.

  SELECT * FROM E070
  INTO TABLE E070_ITAB PACKAGE SIZE PAC_SIZE
  WHERE NOT TRKORR LIKE 'SAPK%'
  AND   AS4USER <> 'SAP'
  AND   AS4USER <> 'SAPUSER'
  AND   AS4DATE >= LV_EXTRACT_DATE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E070_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'E070'.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</CRS>'.

  FREE E070_ITAB.

* extract Change Request texts ( E071 )
  PERFORM APPEND_STRING_TO_FILE USING '<CRS_OBJECTS>'.

  SELECT * FROM E070
  INTO TABLE E070_ITAB PACKAGE SIZE PAC_SIZE
  WHERE NOT TRKORR LIKE 'SAPK%'
  AND   AS4USER <> 'SAP'
  AND   AS4USER <> 'SAPUSER'
  AND   AS4DATE >= LV_EXTRACT_DATE.

    IF NOT E070_ITAB[] IS INITIAL.
      SELECT * FROM E071
      INTO TABLE E071_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN E070_ITAB
      WHERE TRKORR = E070_ITAB-TRKORR.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E071_ITAB
                                       USING G_IREF_PDOCUMENT
                                             'E071'.
      ENDSELECT.
    ENDIF.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</CRS_OBJECTS>'.

  FREE E070_ITAB.
  FREE E071_ITAB.

* extract Change Request texts ( E07T )
  PERFORM APPEND_STRING_TO_FILE USING '<CR_TEXTS>'.

  SELECT * FROM E070
  INTO TABLE E070_ITAB PACKAGE SIZE PAC_SIZE
  WHERE NOT TRKORR LIKE 'SAPK%'
  AND   AS4USER <> 'SAP'
  AND   AS4USER <> 'SAPUSER'
  AND   AS4DATE >= LV_EXTRACT_DATE.

    IF NOT E070_ITAB[] IS INITIAL.
      SELECT * FROM E07T
      INTO TABLE E07T_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN E070_ITAB
      WHERE TRKORR = E070_ITAB-TRKORR.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E07T_ITAB
                                         USING G_IREF_PDOCUMENT
                                               'E07T'.
      ENDSELECT.
    ENDIF.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</CR_TEXTS>'.

  FREE E070_ITAB.
  FREE E07T_ITAB.

  PERFORM GET_CR_FROM_PROD.

* extract Notest header data ( CWBNTHEAD )

* First check that table CWBNTHEAD and CWBNTCUST exist
  SELECT SINGLE *
  FROM DD02L
  INTO TEMP_DD02L
  WHERE TABNAME = 'CWBNTHEAD'.

  IF SY-SUBRC IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<NOTES_HEADER>'.

    SELECT * FROM ('CWBNTHEAD')
    INTO CORRESPONDING FIELDS OF TABLE CWBNTHEAD_ITAB
                                PACKAGE SIZE PAC_SIZE.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES CWBNTHEAD_ITAB
                                     USING G_IREF_PDOCUMENT
                                           'CWBNTHEAD'.
    ENDSELECT.
    PERFORM APPEND_STRING_TO_FILE USING '</NOTES_HEADER>'.

    FREE CWBNTHEAD_ITAB.

  ENDIF.

* extract Notest status data ( CWBNTCUST )

* First check that table CWBNTHEAD and CWBNTCUST exist
  SELECT SINGLE *
  FROM DD02L
  INTO TEMP_DD02L
  WHERE TABNAME = 'CWBNTCUST'.

  IF SY-SUBRC IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<NOTES_STATUS>'.

    SELECT * FROM ('CWBNTCUST')
    INTO CORRESPONDING FIELDS OF TABLE CWBNTCUST_ITAB
                                PACKAGE SIZE PAC_SIZE.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES CWBNTCUST_ITAB
                                     USING G_IREF_PDOCUMENT
                                           'CWBNTCUST'.
    ENDSELECT.
    PERFORM APPEND_STRING_TO_FILE USING '</NOTES_STATUS>'.

    FREE CWBNTCUST_ITAB.

  ENDIF.

  PERFORM ADD_TIME_STAT USING 'Extract modifications'       "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "extract_modification

*&---------------------------------------------------------------------*
*&      Form  get_cr_from_prod
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_CR_FROM_PROD.

  DATA: DATE TYPE D,
        E070_ITAB TYPE TABLE OF E070,
        TAB_DATA TYPE TABLE OF TAB512,
        SEL TYPE TABLE OF RFC_DB_OPT,
        SEL_LINE LIKE LINE OF SEL,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.

  DATA: LV_ROUNDS TYPE I,
        LV_MOD TYPE I.

  LV_ROUNDS = PROD_CRS_EXTRACTION_MONTHS DIV 6.
  LV_MOD = PROD_CRS_EXTRACTION_MONTHS MOD 6.

  IF LV_MOD > 0.
    ADD 1 TO LV_ROUNDS.
  ENDIF.

* extract Change Request ( E070 )
  PERFORM APPEND_STRING_TO_FILE USING '<PROD_CRS>'.

  DATE = SY-DATUM.

  DO LV_ROUNDS TIMES.

    CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].

    CONCATENATE 'AS4DATE <= ''' DATE ''' AND' INTO SEL_LINE.
    APPEND SEL_LINE TO SEL.

    CALL FUNCTION 'CALCULATE_DATE'
     EXPORTING
*       DAYS              = '0'
       MONTHS            = '-6'
       START_DATE        = DATE
     IMPORTING
       RESULT_DATE       = DATE
              .

    CONCATENATE 'AS4DATE > ''' DATE '''' INTO SEL_LINE.
    APPEND SEL_LINE TO SEL.

    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE          = 'E070'
        DELIMITER            = SPACE
        NO_DATA              = SPACE
        ROWSKIPS             = 0
        ROWCOUNT             = 0
      TABLES
        OPTIONS              = SEL
        FIELDS               = FIELDS_TAB
        DATA                 = TAB_DATA
      EXCEPTIONS
        TABLE_NOT_AVAILABLE  = 1
        TABLE_WITHOUT_DATA   = 2
        OPTION_NOT_VALID     = 3
        FIELD_NOT_VALID      = 4
        NOT_AUTHORIZED       = 5
        DATA_BUFFER_EXCEEDED = 6
        OTHERS               = 7.

    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE 'extract prod CR: RFC_READ_TABLE of E070.' "#EC NOTEXT
            'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE      "#EC NOTEXT
            SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    E070_ITAB[] = TAB_DATA[].

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E070_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'PROD_E070'.

  ENDDO.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_CRS>'.


ENDFORM.                    " get_cr_from_prod

*---------------------------------------------------------------------*
*       FORM extract_authorizations                                   *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTHORIZATIONS.

  DATA: BEGIN OF AGR_DEFINE_REC.
          INCLUDE STRUCTURE AGR_DEFINE.
  DATA:   SOURCE_SYSTEM_ID TYPE SYSYSID,
       END OF AGR_DEFINE_REC.

  DATA: BEGIN OF AGR_NAME_REC,
          AGR_NAME TYPE AGR_NAME,
        END OF AGR_NAME_REC.

  DATA: USOBX_C_ITAB TYPE TABLE OF USOBX_C,
        USR12_ITAB TYPE TABLE OF USR12,
        AGR1016_ITAB TYPE TABLE OF AGR_1016,
        AGR_AGRS_ITAB TYPE TABLE OF AGR_AGRS,
        AGR_TEXTS_ITABS TYPE TABLE OF AGR_TEXTS,
        AGR_DEFINE_ITAB LIKE TABLE OF AGR_DEFINE_REC,
        AGR_NAME_ITAB LIKE TABLE OF AGR_NAME_REC,
        OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
        AGR_DEFINE_FROM_PROD_ITAB LIKE TABLE OF AGR_DEFINE_REC,
        AGR1251_ITAB TYPE TABLE OF AGR_1251,
        AGR1252_ITAB TYPE TABLE OF AGR_1252,
        TAB_DATA TYPE TABLE OF TAB512,
        TAB_REC LIKE LINE OF TAB_DATA.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting authorizations'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<AUTHORIZATIONS>'.

  DATA: LV_EXTRACT_DATE TYPE DATUM.
  PERFORM GET_DATE_BEFORE_MONTHS
    USING ROLES_EXTRACTION_PERIOD
    CHANGING LV_EXTRACT_DATE.

  PERFORM EXTRACT_AUTH_CHANGE_LOGS_CDHDR USING LV_EXTRACT_DATE.

  PERFORM EXTRACT_AUTH_CHANGE_LOGS_CDPOS USING LV_EXTRACT_DATE.

  PERFORM EXTRACT_AUTH_USOBOX_C.

* export 'USR12' data
  PERFORM APPEND_STRING_TO_FILE USING '<PROFILE_AUTHORIZATIONS>'.

  SELECT * FROM USR12
   INTO TABLE USR12_ITAB PACKAGE SIZE PAC_SIZE
   WHERE MODBE <> 'SAP'
   AND   MODBE <> 'DDIC'.

    PERFORM ADD_MESSAGE
    USING '*** profile auth. (USR12) packet' "#EC NOTEXT
      ABAP_TRUE.

    PERFORM ADD_USED_MEMORY_TO_LOG.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES USR12_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'USR12'.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</PROFILE_AUTHORIZATIONS>'.
  FREE USR12_ITAB.

* export AGR_DEFINE data
  PERFORM APPEND_STRING_TO_FILE USING '<ROLES>'.

  SELECT * FROM AGR_DEFINE
  INTO CORRESPONDING FIELDS OF TABLE AGR_DEFINE_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    PERFORM ADD_MESSAGE
    USING '*** role def. (AGR_DEFINE) packet' "#EC NOTEXT
      ABAP_TRUE.
    PERFORM ADD_USED_MEMORY_TO_LOG.

* Fill system id and AGR_DEFINE
    LOOP AT AGR_DEFINE_ITAB INTO AGR_DEFINE_REC.
      AGR_DEFINE_REC-SOURCE_SYSTEM_ID = SY-SYSID.
      MODIFY AGR_DEFINE_ITAB FROM AGR_DEFINE_REC.
    ENDLOOP.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_DEFINE_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'AGR_DEFINE'.
  ENDSELECT.

  REFRESH AGR_DEFINE_ITAB[].

* Get roles definitions from RFC destination ( only if it is
* different than current system )
  IF ( RFC_SYSID <> SY-SYSID ).
    CLEAR ERROR.

    APPEND
      'CREATE_USR <> ''SAP'' AND CREATE_USR <> ''DDIC'''
      TO OPTIONS.

    PERFORM RFC_READ_TABLE
      USING 'AGR_DEFINE' P_RFCDES OPTIONS FIELDS
      CHANGING AGR_DEFINE_ITAB.

    LOOP AT AGR_DEFINE_ITAB INTO AGR_DEFINE_REC.
      AGR_DEFINE_REC-SOURCE_SYSTEM_ID = RFC_SYSID.
      APPEND AGR_DEFINE_REC TO AGR_DEFINE_FROM_PROD_ITAB.
    ENDLOOP.
  ENDIF.
  FREE AGR_DEFINE_ITAB.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_DEFINE_FROM_PROD_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'AGR_DEFINE'.
  FREE AGR_DEFINE_FROM_PROD_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</ROLES>'.

* export AGR_TEXTS data
  PERFORM APPEND_STRING_TO_FILE USING '<ROLE_TEXTS>'.

  SELECT AGR_NAME FROM AGR_DEFINE
  INTO TABLE AGR_NAME_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

      SELECT * FROM AGR_TEXTS
      INTO TABLE AGR_TEXTS_ITABS PACKAGE SIZE PAC_SIZE
        FOR ALL ENTRIES IN AGR_NAME_ITAB
        WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME
        AND LINE = '0000'.

        PERFORM ADD_MESSAGE
        USING '*** role text packet' ABAP_TRUE. "#EC NOTEXT
        PERFORM ADD_USED_MEMORY_TO_LOG.

        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_TEXTS_ITABS
                                       USING G_IREF_PDOCUMENT
                                             'AGR_TEXTS'.
      ENDSELECT.

    ENDIF.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</ROLE_TEXTS>'.
  FREE AGR_TEXTS_ITABS.

* export AGR_1016 data
  PERFORM APPEND_STRING_TO_FILE USING '<ROLE_PROFILE>'.

  SELECT AGR_NAME FROM AGR_DEFINE
  INTO TABLE AGR_NAME_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

      SELECT * FROM AGR_1016
      INTO TABLE AGR1016_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN AGR_NAME_ITAB
      WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR1016_ITAB
                                       USING G_IREF_PDOCUMENT
                                             'AGR_1016'.
      ENDSELECT.
    ENDIF.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</ROLE_PROFILE>'.
  FREE AGR1016_ITAB.

* export AGR_1251 data
  PERFORM APPEND_STRING_TO_FILE USING '<ROLE_AGR_1251>'.

  SELECT AGR_NAME FROM AGR_DEFINE
  INTO TABLE AGR_NAME_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

      SELECT * FROM AGR_1251
      INTO TABLE AGR1251_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN AGR_NAME_ITAB
      WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR1251_ITAB
                                        USING G_IREF_PDOCUMENT
                                              'AGR_1251'.
      ENDSELECT.
    ENDIF.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</ROLE_AGR_1251>'.
  FREE AGR1251_ITAB.

* export AGR_1252 data
  PERFORM APPEND_STRING_TO_FILE USING '<ROLE_ORG_UNIT_FIELDS>'.

  SELECT AGR_NAME FROM AGR_DEFINE
  INTO TABLE AGR_NAME_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

      SELECT * FROM AGR_1252
      INTO TABLE AGR1252_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN AGR_NAME_ITAB
      WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR1252_ITAB
                                        USING G_IREF_PDOCUMENT
                                              'AGR_1252'.
      ENDSELECT.
    ENDIF.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</ROLE_ORG_UNIT_FIELDS>'.
  FREE AGR1252_ITAB.

* export composite roles AGR_AGRS data
  PERFORM APPEND_STRING_TO_FILE USING '<COMPOSITE_ROLES>'.

  SELECT AGR_NAME FROM AGR_DEFINE
  INTO TABLE AGR_NAME_ITAB
  PACKAGE SIZE PAC_SIZE
  WHERE CREATE_USR <> 'SAP'
  AND CREATE_USR <> 'DDIC'.

    IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

      SELECT * FROM AGR_AGRS
      INTO TABLE AGR_AGRS_ITAB PACKAGE SIZE PAC_SIZE
      FOR ALL ENTRIES IN AGR_NAME_ITAB
      WHERE CHILD_AGR = AGR_NAME_ITAB-AGR_NAME.
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_AGRS_ITAB
                                        USING G_IREF_PDOCUMENT
                                              'AGR_AGRS'.
      ENDSELECT.

    ENDIF.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</COMPOSITE_ROLES>'.

  FREE AGR_NAME_ITAB.

* Export AGR_USERS data ( from production )
  PERFORM EXTRACT_AUTHORIZATIONS_USAGE.

  PERFORM APPEND_STRING_TO_FILE USING '</AUTHORIZATIONS>'.

  PERFORM ADD_TIME_STAT USING 'Extract authorization' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_AUTHORIZATIONS

*---------------------------------------------------------------------*
* FORM EXTRACT_AUTH_CHANGE_LOGS_CDHDR                                 *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTH_CHANGE_LOGS_CDHDR USING UV_EXTRACT_DATE TYPE DATUM.

  DATA: LT_CDHDR TYPE TABLE OF CDHDR.

  PERFORM APPEND_STRING_TO_FILE USING '<AUTH_CHANGE_LOGS_CDHDR>'.

  SELECT *
    FROM CDHDR
    INTO TABLE LT_CDHDR
    PACKAGE SIZE PAC_SIZE
    WHERE OBJECTCLAS = 'PFCG'
    AND UDATE > UV_EXTRACT_DATE.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE
      TABLES LT_CDHDR
      USING G_IREF_PDOCUMENT 'CDHDR'.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</AUTH_CHANGE_LOGS_CDHDR>'.
  FREE LT_CDHDR.

ENDFORM.                    "EXTRACT_AUTH_CHANGE_LOGS_CDHDR

*---------------------------------------------------------------------*
* FORM EXTRACT_AUTH_CHANGE_LOGS_CDPOS                                 *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTH_CHANGE_LOGS_CDPOS USING UV_EXTRACT_DATE TYPE DATUM.

  DATA:
    LT_CDHDR TYPE TABLE OF CDHDR,
    LS_CDHDR TYPE CDHDR,
    LR_OBJECTID TYPE RANGE OF CDPOS-OBJECTID,
    LR_OBJECTID_WA LIKE LINE OF LR_OBJECTID,
    LR_CHANGENR TYPE RANGE OF CDPOS-CHANGENR,
    LR_CHANGENR_WA LIKE LINE OF LR_CHANGENR,
    LT_CDPOS TYPE TABLE OF CDPOS.

  PERFORM APPEND_STRING_TO_FILE USING '<AUTH_CHANGE_LOGS_CDPOS>'.

  SELECT *
    FROM CDHDR
    INTO TABLE LT_CDHDR
    PACKAGE SIZE 500
    WHERE OBJECTCLAS = 'PFCG'
    AND UDATE > UV_EXTRACT_DATE.

    IF LT_CDHDR[] IS NOT INITIAL.

      CLEAR: LT_CDPOS[], LR_OBJECTID[], LR_CHANGENR[].
      LR_OBJECTID_WA-SIGN   = 'I'.
      LR_OBJECTID_WA-OPTION = 'EQ'.
      LR_CHANGENR_WA-SIGN   = 'I'.
      LR_CHANGENR_WA-OPTION = 'EQ'.
      LOOP AT LT_CDHDR INTO LS_CDHDR.
        LR_OBJECTID_WA-LOW = LS_CDHDR-OBJECTID.
        APPEND LR_OBJECTID_WA TO LR_OBJECTID.
        LR_CHANGENR_WA-LOW = LS_CDHDR-CHANGENR.
        APPEND LR_CHANGENR_WA TO LR_CHANGENR.
      ENDLOOP.

      SELECT *
        FROM CDPOS
        INTO TABLE LT_CDPOS
        WHERE OBJECTCLAS = 'PFCG'
        AND OBJECTID IN LR_OBJECTID
        AND CHANGENR IN LR_CHANGENR
        AND TABNAME = 'CD1251'.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES LT_CDPOS
        USING G_IREF_PDOCUMENT 'CDPOS'.

    ENDIF.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</AUTH_CHANGE_LOGS_CDPOS>'.
  FREE LT_CDPOS.

ENDFORM.                    "EXTRACT_AUTH_CHANGE_LOGS_CDPOS

*---------------------------------------------------------------------*
* FORM EXTRACT_AUTH_USOBOX_C                                          *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTH_USOBOX_C.

  DATA: LT_USOBX_C TYPE TABLE OF USOBX_C.

  PERFORM APPEND_STRING_TO_FILE USING '<USOBX_C_DATA>'.

  SELECT *
    FROM USOBX_C
    INTO TABLE LT_USOBX_C
    PACKAGE SIZE PAC_SIZE.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE
      TABLES LT_USOBX_C
      USING G_IREF_PDOCUMENT 'USOBX_C'.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</USOBX_C_DATA>'.
  FREE LT_USOBX_C.

ENDFORM.                    "EXTRACT_AUTH_USOBOX_C

*---------------------------------------------------------------------*
*       FORM extract_authorizations_usage                             *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTHORIZATIONS_USAGE.

  DATA: AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
        AGR_USERS_ITAB_BACKUP TYPE TABLE OF AGR_USERS,
        OPTIONS TYPE TABLE OF RFC_DB_OPT,
        OPTIONS_WA LIKE LINE OF OPTIONS,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        FIRST_AGR_NAME LIKE AGR_USERS-AGR_NAME,
        LAST_AGR_NAME LIKE AGR_USERS-AGR_NAME,
        LAST_AGR_USERS_ITAB LIKE AGR_USERS_ITAB,
        WA_AGR_USERS_ITAB LIKE LINE OF AGR_USERS_ITAB,
        CALL_RC LIKE SY-SUBRC,
        CALL_NUM_ROWS TYPE I,
        IS_FIRST TYPE C,
        IS_LAST TYPE C,
        AGR_USERS_ITAB_TEST TYPE TABLE OF AGR_USERS,
        TEST,
        LS_OPTIONS LIKE LINE OF OPTIONS,
        AGR_USERS_SIZE TYPE SY-TFILL,
        STR_AGR_SIZE TYPE STRING,
        MESS_STR TYPE STRING,
        STR_SUBRC TYPE STRING,
        DATA_TAB TYPE TABLE OF TAB512,
        DATA_WA TYPE TAB512,
        EXTRACTED_USERS_NUM TYPE I VALUE 0,
        EX_USERS_NUM_STR    TYPE STRING,
        USERS_COUNT_NODE_STR TYPE STRING,
        AGR_USERS_WHERE TYPE STRING,
        RFC_ERROR TYPE RFCLOG_D,
        LV_NOTIFICATION_PARAM TYPE STRING.


  CHECK NOT GET_AGR_USERS_LOCAL IS INITIAL OR
        NOT GET_AGR_USERS_RFC IS INITIAL.

* export AGR_USERS data ( from production )
  PERFORM APPEND_STRING_TO_FILE USING '<PROFILE_USERS>'.

* If the prod system is the current, there is
* no need to go through the RFC
  IF ( RFC_SYSID = SY-SYSID ).

    CHECK NOT GET_AGR_USERS_LOCAL IS INITIAL.

    SELECT * FROM AGR_USERS
    INTO TABLE AGR_USERS_ITAB PACKAGE SIZE PAC_SIZE
    WHERE COL_FLAG <> 'X'.

      PERFORM ADD_MESSAGE
      USING '*** role usage (agr_users) packet' "#EC NOTEXT
              ABAP_TRUE.
      PERFORM ADD_USED_MEMORY_TO_LOG.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB
                                     USING G_IREF_PDOCUMENT
                                           'AGR_USERS'.
    ENDSELECT.

  ELSEIF NOT GET_AGR_USERS_RFC IS INITIAL.

    CLEAR ERROR.
    CLEAR OPTIONS.
    CLEAR FIELDS.

*   Get the size of the agr users table in the rfc destination
*   before starting the iterations, and add it to the log.
    IF ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

*     No inherited users from composite roles needed
      AGR_USERS_WHERE = 'COL_FLAG <> ''X'''.
      CALL FUNCTION 'SELECT_COUNT' DESTINATION P_RFCDES
        EXPORTING
          TABNAME               = 'AGR_USERS'
          WHERE                 = AGR_USERS_WHERE
*          BYPASSINGBUFFER       = ' '
        IMPORTING
          HITS                  = AGR_USERS_SIZE
        EXCEPTIONS
          SYSTEM_FAILURE          = 1  MESSAGE RFC_ERROR
          COMMUNICATION_FAILURE   = 2  MESSAGE RFC_ERROR
          OTHERS                  = 3.

      STR_SUBRC = SY-SUBRC.
      IF STR_SUBRC <> 0.
        CONCATENATE 'WARNING!! SY-SUBRC =' STR_SUBRC
        'when calling SELECT_COUNT for AGR_USERS - ' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        IF SY-SUBRC = 1 OR SY-SUBRC = 2.
          CONCATENATE GT_ETL_MESSAGE-MESSAGE RFC_ERROR
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        ENDIF.
      ELSE.
        STR_AGR_SIZE = AGR_USERS_SIZE.
        CONCATENATE
        'AGR_USERS size in system' P_RFCDES 'is' "#EC NOTEXT
          STR_AGR_SIZE INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ENDIF.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      CLEAR GT_ETL_MESSAGE.

    ENDIF. "if ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

    PERFORM ADD_USED_MEMORY_TO_LOG.

*   No inherited users from composite roles needed
    LS_OPTIONS-TEXT = AGR_USERS_WHERE.
    APPEND LS_OPTIONS TO OPTIONS .

    DO.

      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE          = 'AGR_USERS'
          DELIMITER            = SPACE
          NO_DATA              = SPACE
          ROWSKIPS             = 0
          ROWCOUNT             = AGR_USERS_ROW_COUNT
        TABLES
          OPTIONS              = OPTIONS
          FIELDS               = FIELDS
          DATA                 = AGR_USERS_ITAB
        EXCEPTIONS
          TABLE_NOT_AVAILABLE  = 1
          TABLE_WITHOUT_DATA   = 2
          OPTION_NOT_VALID     = 3
          FIELD_NOT_VALID      = 4
          NOT_AUTHORIZED       = 5
          DATA_BUFFER_EXCEEDED = 6
          OTHERS               = 7.

      CALL_RC = SY-SUBRC.


      IF CALL_RC IS INITIAL.
        DESCRIBE TABLE AGR_USERS_ITAB LINES CALL_NUM_ROWS.
        EXTRACTED_USERS_NUM = EXTRACTED_USERS_NUM + CALL_NUM_ROWS.

        IF CALL_NUM_ROWS > 0.
          FREE AGR_USERS_ITAB_BACKUP.

          SORT AGR_USERS_ITAB.

*       Remove the last role's data (will be fetched in the next round)
          LOOP AT AGR_USERS_ITAB INTO WA_AGR_USERS_ITAB.
            AT FIRST.
              IS_FIRST = 'X'.
            ENDAT.
            IF IS_FIRST = 'X'.
              CLEAR IS_FIRST.
              FIRST_AGR_NAME = WA_AGR_USERS_ITAB-AGR_NAME.
            ENDIF.

            AT LAST.
              IS_LAST = 'X'.
            ENDAT.
            IF IS_LAST = 'X'.
              CLEAR IS_LAST.
              LAST_AGR_NAME = WA_AGR_USERS_ITAB-AGR_NAME.
              CLEAR: OPTIONS, OPTIONS_WA.

*           All records are the same role. Next fetch will be from the
*           following role
              IF FIRST_AGR_NAME = LAST_AGR_NAME.
                CONCATENATE 'AGR_NAME > ''' LAST_AGR_NAME ''''
                    INTO OPTIONS_WA-TEXT.
              ELSE.
                CONCATENATE 'AGR_NAME >= ''' LAST_AGR_NAME ''''
                    INTO OPTIONS_WA-TEXT.

*           Remove the last role's data
                LOOP AT AGR_USERS_ITAB INTO WA_AGR_USERS_ITAB
                    WHERE AGR_NAME = LAST_AGR_NAME.
                  DELETE AGR_USERS_ITAB INDEX SY-TABIX.
                  APPEND WA_AGR_USERS_ITAB TO AGR_USERS_ITAB_BACKUP.
                ENDLOOP.

              ENDIF.
              APPEND OPTIONS_WA TO OPTIONS.
            ENDIF.
          ENDLOOP.

          PERFORM ADD_MESSAGE
          USING '*** roles usage packet' ABAP_TRUE. "#EC NOTEXT
          PERFORM ADD_USED_MEMORY_TO_LOG.

          PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB
                                         USING G_IREF_PDOCUMENT
                                               'AGR_USERS'.
          FREE AGR_USERS_ITAB.
        ENDIF.
      ELSE.
        CASE CALL_RC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN 7. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'Extraction of AGR_USERS from ' P_RFCDES "#EC NOTEXT
              ' failed. Error: ' ERROR "#EC NOTEXT
              INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ENDIF.

*   Failed to fetch records OR read all table content
      IF CALL_RC <> 0 OR CALL_NUM_ROWS < AGR_USERS_ROW_COUNT.
        PERFORM ADD_MESSAGE
        USING '*** roles usage packet' ABAP_TRUE. "#EC NOTEXT
        PERFORM ADD_USED_MEMORY_TO_LOG.

        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB_BACKUP
                                           USING G_IREF_PDOCUMENT
                                                 'AGR_USERS'.
        EXIT.
      ENDIF.

    ENDDO.

*   The AGR_USERS_COUNT will be written only when the RFC is in ECC6
    IF NOT STR_AGR_SIZE IS INITIAL.
      EX_USERS_NUM_STR = EXTRACTED_USERS_NUM.
      CONCATENATE '<AGR_USERS_COUNT EXISTING="' STR_AGR_SIZE
        '" EXTRACTED="' EX_USERS_NUM_STR '"/>'
                  INTO USERS_COUNT_NODE_STR.
      PERFORM APPEND_STRING_TO_FILE USING USERS_COUNT_NODE_STR.

      IF EXTRACTED_USERS_NUM <> AGR_USERS_SIZE.

        CONCATENATE
'AGR_USERS table count difference - existing count:' "#EC NOTEXT
          STR_AGR_SIZE
          ', is not equal to the extracted count:' "#EC NOTEXT
          EX_USERS_NUM_STR
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*       Add notification for AGR_COUNT_DIFF.
        CONCATENATE STR_AGR_SIZE
          NOTIFICATION_PARAMS_DELIMITER
          EX_USERS_NUM_STR
          INTO LV_NOTIFICATION_PARAM.

        PERFORM ADD_NOTIFICATION USING AGR_USERS_COUNT_DIFF
                                       LV_NOTIFICATION_PARAM
                                       GT_ETL_MESSAGE-MESSAGE.
      ENDIF.
    ENDIF.

  ENDIF. " IF ( RFC_SYSID <> SY-SYSID ).

  PERFORM APPEND_STRING_TO_FILE USING '</PROFILE_USERS>'.

ENDFORM.                    "EXTRACT_AUTHORIZATIONS_USAGE


*---------------------------------------------------------------------*
*       FORM extract_software_components                              *
*---------------------------------------------------------------------*
FORM EXTRACT_SOFTWARE_COMPONENTS.

  DATA: SC_ITAB TYPE TABLE OF CVERS,
        UP_ITAB TYPE TABLE OF UVERS,
        UVERS_HIST_ITAB TYPE TABLE OF UVERS_HIST_REC_TYPE,
        AVERS_ITAB TYPE TABLE OF AVERS,
        TAB_DATA TYPE TABLE OF TAB512,
*        ls_data LIKE LINE OF TAB_DATA,
        SEL TYPE TABLE OF RFC_DB_OPT,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.


  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting software components'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<SOFTWARE_COMPONENTS>'.
  SELECT * FROM CVERS
  INTO TABLE SC_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SC_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'SOFTWARE_COMPONENT'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</SOFTWARE_COMPONENTS>'.

  FREE SC_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '<PROD_SOFTWARE_COMPONENTS>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'CVERS'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: RFC_READ_TABLE of CVERS.' "#EC NOTEXT
          'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  SC_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SC_ITAB
                                   USING G_IREF_PDOCUMENT
                                        'PROD_SOFTWARE_COMPONENT'.
  FREE SC_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_SOFTWARE_COMPONENTS>'.

  PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'UVERS'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'extract prod BF: RFC_READ_TABLE of UVERS.' "#EC NOTEXT
          'Error:' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  UP_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES UP_ITAB
                                   USING G_IREF_PDOCUMENT
                                        'PROD_UVERS'.
  FREE UP_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES>'.

  PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES_HISTORY>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'UVERS_HIST'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'extract prod BF: RFC_READ_TABLE of UVERS_HIST.' "#EC NOTEXT
          'Error:' ERROR  "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  UVERS_HIST_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES UVERS_HIST_ITAB
                                   USING G_IREF_PDOCUMENT
                                        'PROD_UVERS_HIST'.
  FREE UVERS_HIST_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES_HISTORY>'.

  PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES_ADDONS>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'AVERS'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: RFC_READ_TABLE of AVERS.' "#EC NOTEXT
          'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  AVERS_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AVERS_ITAB
                                   USING G_IREF_PDOCUMENT
                                        'PROD_AVERS'.
  FREE AVERS_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES_ADDONS>'.

  PERFORM ADD_TIME_STAT USING 'Extract software components' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.


ENDFORM.                    "EXTRACT_SOFTWARE_COMPONENTS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PRODUCT_VERSIONS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_PRODUCT_VERSIONS .

  DATA: LT_PRDVERS TYPE TABLE OF TY_PRD_VERS,
        LT_STACKCOMPS TYPE TABLE OF TY_STACKCOMPS,
        LT_STACKHEADR TYPE TABLE OF TY_STACKHEADR,
        TAB_DATA TYPE TABLE OF TAB512,
        SEL TYPE TABLE OF RFC_DB_OPT,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: LS_TADIR TYPE TADIR.

  DATA: LX_EXCEPTION TYPE REF TO CX_ROOT.

  FIELD-SYMBOLS: <DYN_TABLE> TYPE STANDARD TABLE.

  DATA: DY_TABLE TYPE REF TO DATA,
        DY_LINE TYPE REF TO DATA,
        IFC      TYPE LVC_T_FCAT.

  CONSTANTS: LC_PRDVERS TYPE STRING VALUE 'PRDVERS',
             LC_STACKCOMPS TYPE STRING VALUE 'STACKCOMPS',
             LC_STACKHEADR TYPE STRING VALUE 'STACKHEADR'.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting product versions'. "#EC NOTEXT

  SELECT SINGLE *
    FROM TADIR
    INTO LS_TADIR
    WHERE PGMID EQ 'R3TR' AND
          OBJECT EQ 'TABL' AND
          OBJ_NAME EQ 'PRDVERS'.

  IF SY-SUBRC <> 0.
    CONCATENATE 'Cound not extract product versions.' "#EC NOTEXT
          'Please update SAINT and Spam Vesions' "#EC NOTEXT
       INTO GT_ETL_MESSAGE-MESSAGE
       SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    RETURN.
  ENDIF.

  TRY.

      PERFORM APPEND_STRING_TO_FILE USING '<PRODUCT_VERSIONS>'.

      PERFORM GET_STRUCTURE USING LC_PRDVERS CHANGING IFC.
      PERFORM CREATE_DYNAMIC_ITAB USING IFC CHANGING DY_TABLE.

      ASSIGN DY_TABLE->* TO <DYN_TABLE>.

      PERFORM SELECT_DYN_TAB_BY_TAB_NAME USING LC_PRDVERS
                                         CHANGING <DYN_TABLE>.

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_PRDVERS.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_PRDVERS
                                     USING G_IREF_PDOCUMENT
                                           'PRODUCT_VERSION'.

      FREE LT_PRDVERS.
      CLEAR <DYN_TABLE>[].

      PERFORM APPEND_STRING_TO_FILE USING '</PRODUCT_VERSIONS>'.
      PERFORM APPEND_STRING_TO_FILE USING '<PROD_PRODUCT_VERSIONS>'.

      CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE          = 'PRDVERS'
          DELIMITER            = SPACE
          NO_DATA              = SPACE
          ROWSKIPS             = 0
          ROWCOUNT             = 0
        TABLES
          OPTIONS              = SEL
          FIELDS               = FIELDS_TAB
          DATA                 = TAB_DATA
        EXCEPTIONS
          TABLE_NOT_AVAILABLE  = 1
          TABLE_WITHOUT_DATA   = 2
          OPTION_NOT_VALID     = 3
          FIELD_NOT_VALID      = 4
          NOT_AUTHORIZED       = 5
          DATA_BUFFER_EXCEEDED = 6
          OTHERS               = 7.

      IF SY-SUBRC <> 0.
        CLEAR ERROR.
        CASE SY-SUBRC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN 7. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'extract prod BF: RFC_READ_TABLE of PRDVERS.' "#EC NOTEXT
              'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
          SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ENDIF.

      <DYN_TABLE>[] = TAB_DATA[].

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_PRDVERS.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_PRDVERS
                                       USING G_IREF_PDOCUMENT
                                            'PROD_PRODUCT_VERSION'.
      FREE LT_PRDVERS.

      PERFORM APPEND_STRING_TO_FILE USING '</PROD_PRODUCT_VERSIONS>'.
      PERFORM APPEND_STRING_TO_FILE USING '<SWC_M2M_STACKS>'.

      PERFORM GET_STRUCTURE USING LC_STACKCOMPS CHANGING IFC.
      PERFORM CREATE_DYNAMIC_ITAB USING IFC CHANGING DY_TABLE.

      ASSIGN DY_TABLE->* TO <DYN_TABLE>.

      PERFORM SELECT_DYN_TAB_BY_TAB_NAME USING LC_STACKCOMPS
                       CHANGING <DYN_TABLE>.

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_STACKCOMPS.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STACKCOMPS
                                      USING G_IREF_PDOCUMENT
                                           'SWC_M2M_STACK'.

      FREE LT_STACKCOMPS.
      CLEAR <DYN_TABLE>[].

      PERFORM APPEND_STRING_TO_FILE USING '</SWC_M2M_STACKS>'.
      PERFORM APPEND_STRING_TO_FILE USING '<PROD_SWC_M2M_STACKS>'.

      CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE          = 'STACKCOMPS'
          DELIMITER            = SPACE
          NO_DATA              = SPACE
          ROWSKIPS             = 0
          ROWCOUNT             = 0
        TABLES
          OPTIONS              = SEL
          FIELDS               = FIELDS_TAB
          DATA                 = TAB_DATA
        EXCEPTIONS
          TABLE_NOT_AVAILABLE  = 1
          TABLE_WITHOUT_DATA   = 2
          OPTION_NOT_VALID     = 3
          FIELD_NOT_VALID      = 4
          NOT_AUTHORIZED       = 5
          DATA_BUFFER_EXCEEDED = 6
          OTHERS               = 7.

      IF SY-SUBRC <> 0.
        CLEAR ERROR.
        CASE SY-SUBRC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN 7. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'extract prod BF: RFC_READ_TABLE of STACKCOMPS.' "#EC NOTEXT
              'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
           SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ENDIF.

      <DYN_TABLE>[] = TAB_DATA[].

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_STACKCOMPS.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STACKCOMPS
                                       USING G_IREF_PDOCUMENT
                                            'PROD_SWC_M2M_STACK'.
      FREE LT_STACKCOMPS.

      PERFORM APPEND_STRING_TO_FILE USING '</PROD_SWC_M2M_STACKS>'.

      PERFORM APPEND_STRING_TO_FILE USING '<STACK_HEADERS>'.

      PERFORM GET_STRUCTURE USING LC_STACKHEADR CHANGING IFC.
      PERFORM CREATE_DYNAMIC_ITAB USING IFC CHANGING DY_TABLE.

      ASSIGN DY_TABLE->* TO <DYN_TABLE>.

      PERFORM SELECT_DYN_TAB_BY_TAB_NAME USING LC_STACKHEADR
                       CHANGING <DYN_TABLE>.

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_STACKHEADR.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STACKHEADR
                                      USING G_IREF_PDOCUMENT
                                           'STACK_HEADER'.

      FREE LT_STACKCOMPS.
      CLEAR <DYN_TABLE>[].
      PERFORM APPEND_STRING_TO_FILE USING '</STACK_HEADERS>'.
      PERFORM APPEND_STRING_TO_FILE USING '<PROD_STACK_HEADERS>'.

      CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE          = 'STACKHEADR'
          DELIMITER            = SPACE
          NO_DATA              = SPACE
          ROWSKIPS             = 0
          ROWCOUNT             = 0
        TABLES
          OPTIONS              = SEL
          FIELDS               = FIELDS_TAB
          DATA                 = TAB_DATA
        EXCEPTIONS
          TABLE_NOT_AVAILABLE  = 1
          TABLE_WITHOUT_DATA   = 2
          OPTION_NOT_VALID     = 3
          FIELD_NOT_VALID      = 4
          NOT_AUTHORIZED       = 5
          DATA_BUFFER_EXCEEDED = 6
          OTHERS               = 7.

      IF SY-SUBRC <> 0.
        CLEAR ERROR.
        CASE SY-SUBRC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN 7. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'extract prod BF: RFC_READ_TABLE of STACKHEADR.' "#EC NOTEXT
              'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
            SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ENDIF.

      <DYN_TABLE>[] = TAB_DATA[].

      PERFORM COPY_TABLE_BY_NAME USING <DYN_TABLE>
                                 CHANGING LT_STACKHEADR.

      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STACKHEADR
                                       USING G_IREF_PDOCUMENT
                                            'PROD_STACK_HEADER'.
      FREE LT_STACKHEADR.

      PERFORM APPEND_STRING_TO_FILE USING '</PROD_STACK_HEADERS>'.

    CATCH CX_ROOT INTO LX_EXCEPTION.

      DATA LV_ERROR TYPE STRING.

      LV_ERROR = LX_EXCEPTION->GET_LONGTEXT( ).
      CONCATENATE 'Extraction of Product Version.' "#EC NOTEXT
            'Error:' LV_ERROR INTO GT_ETL_MESSAGE-MESSAGE "#EC NOTEXT
          SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDTRY.

  FREE IFC.
  PERFORM ADD_TIME_STAT USING 'Extract product versions' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_PRODUCT_VERSIONS

*&---------------------------------------------------------------------*
*&      Form  copy_table_by_name
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TABLE    text
*      -->P_SOURCE   text
*      -->P_TARGET   text
*----------------------------------------------------------------------*
FORM COPY_TABLE_BY_NAME USING P_SOURCE TYPE ANY TABLE
              CHANGING P_TARGET TYPE ANY TABLE.

  DATA: REF_TABLE_DES TYPE REF TO CL_ABAP_TABLEDESCR.
  DATA: REF_STRUCT_DES TYPE REF TO CL_ABAP_STRUCTDESCR.
  DATA: REF_TABLE_TYPE TYPE REF TO CL_ABAP_TYPEDESCR.
  DATA: IDETAILS TYPE ABAP_COMPDESCR_TAB,
         XDETAILS TYPE ABAP_COMPDESCR.

  DATA: TARGET_LINE TYPE REF TO DATA.

  FIELD-SYMBOLS: <DYN_FIELD_SOURCE>.
  FIELD-SYMBOLS: <DYN_FIELD_TARGET>.

  FIELD-SYMBOLS: <SOURCE_LINE>,
                 <TARGET_LINE>.

  REF_TABLE_DES ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( P_TARGET ).
  REF_STRUCT_DES ?= REF_TABLE_DES->GET_TABLE_LINE_TYPE( ).
  IDETAILS[] = REF_STRUCT_DES->COMPONENTS[].
  LOOP AT P_SOURCE ASSIGNING <SOURCE_LINE>.
    CREATE DATA TARGET_LINE LIKE LINE OF P_TARGET.

    ASSIGN TARGET_LINE->* TO <TARGET_LINE>.
    INSERT <TARGET_LINE> INTO TABLE P_TARGET ASSIGNING <TARGET_LINE>.

    LOOP AT IDETAILS INTO XDETAILS.
      ASSIGN COMPONENT XDETAILS-NAME OF STRUCTURE <SOURCE_LINE>
            TO <DYN_FIELD_SOURCE>.
      ASSIGN COMPONENT XDETAILS-NAME OF STRUCTURE <TARGET_LINE>
            TO <DYN_FIELD_TARGET>.

      CHECK <DYN_FIELD_SOURCE> IS ASSIGNED.
      CHECK <DYN_FIELD_TARGET> IS ASSIGNED.

      <DYN_FIELD_TARGET> = <DYN_FIELD_SOURCE>.
    ENDLOOP.
  ENDLOOP.

ENDFORM.                    "copy_table_by_name

*&---------------------------------------------------------------------*
*&      Form  create_dynamic_itab
*&---------------------------------------------------------------------*
FORM CREATE_DYNAMIC_ITAB USING IFC TYPE LVC_T_FCAT
                         CHANGING DY_TABLE TYPE REF TO DATA.

  FIELD-SYMBOLS: <DYN_TABLE> TYPE STANDARD TABLE,
              <DYN_WA>,
              <DYN_FIELD>.

* Create dynamic internal table and assign to FS
  CALL METHOD CL_ALV_TABLE_CREATE=>CREATE_DYNAMIC_TABLE
    EXPORTING
      IT_FIELDCATALOG  = IFC
      I_LENGTH_IN_BYTE = 'X'
    IMPORTING
      EP_TABLE         = DY_TABLE.
  ASSIGN DY_TABLE->* TO <DYN_TABLE>.
* Create dynamic work area and assign to FS
ENDFORM.                    "create_dynamic_itab

*&---------------------------------------------------------------------*
*&      Form  get_structure
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TABLE    text
*      -->IFC        text
*----------------------------------------------------------------------*
FORM GET_STRUCTURE USING P_TABLE TYPE STRING
                         CHANGING IFC TYPE LVC_T_FCAT.
  DATA : IDETAILS TYPE ABAP_COMPDESCR_TAB,
         XDETAILS TYPE ABAP_COMPDESCR,
         XFC      TYPE LVC_S_FCAT.
  DATA : REF_TABLE_DES TYPE REF TO CL_ABAP_STRUCTDESCR.

  CLEAR IFC.

* Get the structure of the table.
  REF_TABLE_DES ?=
      CL_ABAP_TYPEDESCR=>DESCRIBE_BY_NAME( P_TABLE ).
  IDETAILS[] = REF_TABLE_DES->COMPONENTS[].
  LOOP AT IDETAILS INTO XDETAILS.
    CLEAR XFC.
    XFC-FIELDNAME = XDETAILS-NAME .
    CASE XDETAILS-TYPE_KIND.
      WHEN 'C'.
        XFC-DATATYPE = 'CHAR'.
      WHEN 'N'.
        XFC-DATATYPE = 'NUMC'.
      WHEN 'D'.
        XFC-DATATYPE = 'DATE'.
      WHEN 'P'.
        XFC-DATATYPE = 'PACK'.
      WHEN OTHERS.
        XFC-DATATYPE = XDETAILS-TYPE_KIND.
    ENDCASE.
    XFC-INTTYPE = XDETAILS-TYPE_KIND.
    XFC-INTLEN = XDETAILS-LENGTH.
    XFC-DECIMALS = XDETAILS-DECIMALS.
    APPEND XFC TO IFC.
  ENDLOOP.
ENDFORM.                    "get_structure

*&---------------------------------------------------------------------*
*&      Form  SELECT_DYN_TAB_BY_TAB_NAME
*&---------------------------------------------------------------------*
FORM SELECT_DYN_TAB_BY_TAB_NAME USING P_TABLE TYPE STRING
              CHANGING P_TARGET TYPE ANY TABLE.

* Select Data from table.
  SELECT * INTO TABLE P_TARGET
             FROM (P_TABLE).

ENDFORM.                    "SELECT_DYN_TAB_BY_TAB_NAME

*---------------------------------------------------------------------*
*       FORM extract_support_packages                                 *
*---------------------------------------------------------------------*
FORM EXTRACT_SUPPORT_PACKAGES.

  TYPES: BEGIN OF TY_PAT03,
                PATCH TYPE PATCH,
                SHORT_TEXT TYPE PATCHTXT,
                STATUS TYPE PATCHSTAT,
                DELIV_DATE TYPE PATDELDATE,
                DELIV_TIME TYPE PATDELTIME,
                RESPONSIBL TYPE PATCH_USER,
                IMPLE_DATE TYPE PATIMPDATE,
                IMPLE_TIME TYPE PATIMPTIME,
                L_IMPL_REL TYPE SYSAPRL,
                CONFLICTS TYPE PAT_CONFL,
                CONFIRMED TYPE CONFIRMED,
                BACKUP TYPE TRKORR,
                FROM_REL TYPE SYSAPRL,
                TO_REL TYPE SYSAPRL,
                OS TYPE SYOPSYS,
                DB TYPE SYDBSYS,
                PATCH_TYPE TYPE PATCH_TYPE,
                ANCESTOR TYPE PAT_ANCEST,
                STRICT_SEQ TYPE PAT_STRICT,
                NO_GEN TYPE PAT_NOGEN,
                SPAMFIX TYPE PAT_SPAMFX,
                ADDON_ID TYPE ADDONID,
                ADDON_REL TYPE ADDONRL,
                IGN_CONFLI TYPE IGN_CONFLI,
                AP_ANCEST TYPE AP_ANCEST,
                EPSFILSIZ TYPE CHAR10,                      "int4
                HI_ANCEST TYPE PAT_HIAN,
                COMP_REL TYPE PAT_COREL,
                COMPONENT TYPE PAT_COMP,
         END OF TY_PAT03.

  DATA: SP_ITAB TYPE TABLE OF PAT03,
        TAB_DATA TYPE TABLE OF TAB512,
        SEL TYPE TABLE OF RFC_DB_OPT,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
        LT_RFC_PAT03 TYPE STANDARD TABLE OF TY_PAT03.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting support packages'.                      "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<SUPPORT_PACKAGES>'.

  SELECT * FROM PAT03                                   "#EC CI_NOWHERE
  INTO TABLE SP_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SP_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'SUPPORT_PACKAGE'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</SUPPORT_PACKAGES>'.

  FREE SP_ITAB.

**Extract Prod SPs
  PERFORM APPEND_STRING_TO_FILE USING '<PROD_SUPPORT_PACKAGES>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'PAT03'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: RFC_READ_TABLE of PAT03.' "#EC NOTEXT
          'Error:' ERROR                                    "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  LT_RFC_PAT03[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RFC_PAT03
                                  USING G_IREF_PDOCUMENT
                                        'PROD_SUPPORT_PACKAGE'.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_SUPPORT_PACKAGES>'.

  FREE LT_RFC_PAT03.

  PERFORM ADD_TIME_STAT USING 'Extract support packages'    "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_SUPPORT_PACKAGES

*---------------------------------------------------------------------*
*       FORM EXTRACT_DEV_CLASSES                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_DEV_CLASSES.

  DATA: TDEVC_ITAB TYPE TABLE OF TDEVC,
        TDEVCT_ITAB TYPE TABLE OF TDEVCT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting full dev. classes'. "#EC NOTEXT

  SELECT * FROM TDEVC
  INTO TABLE TDEVC_ITAB.

  SELECT * FROM TDEVCT
  INTO TABLE TDEVCT_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TDEVC_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'TDEVC_FULL'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TDEVCT_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'TDEVCT_FULL'.
  PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES>'.

  FREE TDEVC_ITAB.
  FREE TDEVCT_ITAB.

  PERFORM ADD_TIME_STAT
  USING 'Extract full dev. classes' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_DEV_CLASSES

*&---------------------------------------------------------------------*
*&      Form  extract_development_classes
*&---------------------------------------------------------------------*
FORM EXTRACT_DEVELOPMENT_CLASSES.

  RANGES: R_DEVCLASS FOR TDEVC-DEVCLASS.
  DATA: MESS_TEXT(512) TYPE C.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
                          'Extracting development classes'. "#EC NOTEXT

* Get Development Classes Data
  PERFORM GET_DEV_CLASS_DATA.

* Get Development Classes Text
  IF NOT LT_TDEVC[] IS INITIAL.
    SELECT * FROM  TDEVCT
    INTO TABLE LT_TDEVCT
    FOR ALL ENTRIES IN LT_TDEVC
    WHERE  DEVCLASS = LT_TDEVC-DEVCLASS.
  ENDIF.

  CHECK NOT LT_TDEVC[] IS INITIAL.

* Add non 'Z' or 'Y' namespace dev. classes to log
*  IF SY-BATCH = 'X'.
  LOOP AT LT_TDEVC INTO LS_TDEVC.
    IF ( LS_TDEVC-DEVCLASS(1) <> 'Z'
          AND LS_TDEVC-DEVCLASS(1) <> 'Y' ).
      CLEAR MESS_TEXT.
      CONCATENATE '*** Found namespace dev. class: ' "#EC NOTEXT
      LS_TDEVC-DEVCLASS
               INTO MESS_TEXT SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING MESS_TEXT ABAP_TRUE.
    ENDIF.
  ENDLOOP.
  CLEAR LS_TDEVC.
*  ENDIF.

* Extract Development classes
  PERFORM APPEND_STRING_TO_FILE USING '<DEVELOPMENT_CLASSES>'.

  PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES_DATA>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVC
                                 USING G_IREF_PDOCUMENT
                                       'TDEVC'.
  PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES_DATA>'.

  PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES_TEXT>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVCT
                                 USING G_IREF_PDOCUMENT
                                       'TDEVCT'.
  PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES_TEXT>'.

  PERFORM APPEND_STRING_TO_FILE USING '</DEVELOPMENT_CLASSES>'.

* Get Development Class Objects list
  IF NOT LT_TDEVC[] IS INITIAL.
    SELECT * FROM TADIR
    APPENDING TABLE GT_TADIR
    FOR ALL ENTRIES IN LT_TDEVC
    WHERE DEVCLASS = LT_TDEVC-DEVCLASS
    AND  PGMID     EQ 'R3TR'.
  ENDIF.

* Select from tadir where the objects are in customer name range
  SELECT *
  FROM   TADIR AS TDR
  APPENDING  TABLE GT_TADIR
  WHERE  TDR~PGMID EQ 'R3TR'
  AND    TDR~OBJ_NAME IN CUST_NAMESPACE_RNG
  AND   AUTHOR <> 'SAP'
  AND   DEVCLASS <> '$TMP'
  AND   DEVCLASS <> '$SAMPLE'.

* -- Check if generated obejects should also be removed ----------------
* Add generated objects
  IF ADD_GEN_PROGRAMS = 'X'.
*   Add also generated programs
    SELECT * FROM TADIR
    APPENDING TABLE GT_TADIR
    WHERE PGMID = 'R3TR'
    AND   SRCSYSTEM = 'SAP'
    AND   AUTHOR <> 'SAP'
    AND   DEVCLASS <> '$TMP'
    AND   DEVCLASS <> '$SAMPLE'
    AND   GENFLAG = 'X'.
  ELSE.
*   Add all generated objects (except programs)
    SELECT * FROM TADIR
    APPENDING TABLE GT_TADIR
    WHERE PGMID = 'R3TR'
    AND   OBJECT <> 'PROG'
    AND   SRCSYSTEM = 'SAP'
    AND   AUTHOR <> 'SAP'
    AND   DEVCLASS <> '$TMP'
    AND   DEVCLASS <> '$SAMPLE'
    AND   GENFLAG = 'X'.
  ENDIF.

* Add Query programs
  PERFORM ADD_ABAP_QUERY_OBJECTS.

  SORT GT_TADIR BY PGMID OBJECT OBJ_NAME.
  DELETE ADJACENT DUPLICATES FROM GT_TADIR.

  IF VANILLA = ''.
* Add customer ABAP Dictionary modifications
    SELECT * FROM SMODILOG
    INTO TABLE GT_MODIF
    WHERE ( OBJ_TYPE = 'TABL' AND SUB_TYPE <> 'DOCU' )
    OR    ( OBJ_TYPE IN ('VIEW', 'DTEL', 'TABL', 'SQLT',
                       'TTYP', 'DOMA' ) )
    AND   INACTIVE <> '1'.

    IF NOT GT_MODIF[] IS INITIAL.
      LOOP AT GT_MODIF.
        READ TABLE GT_TADIR INTO GS_TADIR WITH KEY
                                          PGMID = 'R3TR'
                                          OBJECT = GT_MODIF-OBJ_TYPE
                                          OBJ_NAME = GT_MODIF-OBJ_NAME
                                          BINARY SEARCH.
        CHECK SY-SUBRC <> 0.

        MODIFIED_OBJECTS-OBJ_TYPE = GT_MODIF-OBJ_TYPE.
        MODIFIED_OBJECTS-OBJ_NAME = GT_MODIF-OBJ_NAME.
        APPEND MODIFIED_OBJECTS.
      ENDLOOP.

      IF NOT MODIFIED_OBJECTS[] IS INITIAL.
        SELECT * FROM TADIR
        APPENDING TABLE GT_TADIR
        FOR ALL ENTRIES IN MODIFIED_OBJECTS
        WHERE PGMID = 'R3TR'
        AND   OBJECT = MODIFIED_OBJECTS-OBJ_TYPE
        AND   OBJ_NAME = MODIFIED_OBJECTS-OBJ_NAME.
      ENDIF.
    ENDIF.
  ENDIF.

  SORT GT_TADIR BY PGMID OBJECT OBJ_NAME.

  DELETE ADJACENT DUPLICATES FROM GT_TADIR.

  LOOP AT GT_TADIR INTO GS_TADIR.

    GS_OBJECTLIST-OBJ_TYPE = GS_TADIR-OBJECT.
    GS_OBJECTLIST-OBJ_NAME = GS_TADIR-OBJ_NAME.

    CASE GS_TADIR-OBJECT.
      WHEN 'FUGR'.
        APPEND GS_OBJECTLIST TO GT_OBJ_FUNC.
      WHEN 'PROG'.
*       Check if the program is active. Only then
*       add it to the file
        SELECT SINGLE *
        FROM PROGDIR
        WHERE NAME = GS_OBJECTLIST-OBJ_NAME AND
              STATE = 'I'.
        IF SY-SUBRC IS NOT INITIAL.
          APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
        ENDIF.
      WHEN 'TRAN'.
        APPEND GS_OBJECTLIST TO GT_OBJ_TRNS.
      WHEN 'LDBA'.
        APPEND GS_OBJECTLIST TO GT_OBJ_LGDB.

*       Add ldb program to object list
        PERFORM ADD_LDB_TO_OBJ_LIST USING GS_TADIR-OBJ_NAME
                                          GS_OBJECTLIST.
      WHEN 'TYPE'.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPEPOOL.
      WHEN 'MSAG'.
        APPEND GS_OBJECTLIST TO GT_OBJ_MESG.
      WHEN 'TABL'.
        APPEND GS_OBJECTLIST TO GT_OBJ_TABL.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
      WHEN 'VIEW'.
        APPEND GS_OBJECTLIST TO GT_OBJ_VIEW.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
      WHEN 'DTEL'.
        APPEND GS_OBJECTLIST TO GT_OBJ_DELM.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
      WHEN 'SQLT'.
        APPEND GS_OBJECTLIST TO GT_OBJ_CTAB.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
      WHEN 'TTYP'.
        APPEND GS_OBJECTLIST TO GT_OBJ_TTYP.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
      WHEN 'DOMA'.
        APPEND GS_OBJECTLIST TO GT_OBJ_DOMN.
      WHEN 'CLAS'.
        APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
        APPEND GS_OBJECTLIST TO GT_OBJ_CLAS.
      WHEN 'BMFR'.
        APPEND GS_OBJECTLIST TO GT_OBJ_APPL.
      WHEN 'CMOD'.
        APPEND GS_OBJECTLIST TO GT_OBJ_UEXT.
      WHEN 'SSFO'.
        APPEND GS_OBJECTLIST TO GT_OBJ_SSFO.
      WHEN 'FORM'.
        APPEND GS_OBJECTLIST TO GT_OBJ_FORM.
      WHEN 'OSOA' OR 'OSOD'.
        APPEND GS_OBJECTLIST TO GT_OBJ_OSOA_D.
      WHEN 'SHI3'.
        APPEND GS_OBJECTLIST TO GT_OBJ_SHI3.
      WHEN 'SXCI'. " Classic BADI Implementation
        APPEND GS_OBJECTLIST TO GT_OBJ_SXCI.
      WHEN 'WEBI'. " Web Services
        APPEND GS_OBJECTLIST TO GT_OBJ_WEBI.
      WHEN 'ENHO'. " Enhancement Spot Implementation
        APPEND GS_OBJECTLIST TO GT_OBJ_ENHO.
    ENDCASE.
  ENDLOOP.

  SORT: GT_OBJ_FUNC, GT_OBJ_PROG, GT_OBJ_TRNS, GT_OBJ_LGDB,
        GT_OBJ_MESG, GT_OBJ_TABL, GT_OBJ_VIEW, GT_OBJ_DELM,
        GT_OBJ_CTAB, GT_OBJ_TTYP, GT_OBJ_DOMN, GT_OBJ_TYPE,
        GT_OBJ_APPL, GT_OBJ_UEXT, GT_OBJ_SSFO, GT_OBJ_FORM,
        GT_OBJ_OSOA_D, GT_OBJ_SHI3, GT_OBJ_SXCI, GT_OBJ_WEBI,
        GT_OBJ_TYPEPOOL, ABAP_QUERY_PROGS.

  PERFORM ADD_TIME_STAT
  USING 'Extract developement classes' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_development_classes

*&---------------------------------------------------------------------*
*&      Form  GET_DEV_CLASS_DATA
*&---------------------------------------------------------------------*
FORM GET_DEV_CLASS_DATA.

  IF DEVCLASS[] IS INITIAL.
    SELECT * FROM TDEVC
    INTO TABLE LT_TDEVC
    WHERE ( DEVCLASS LIKE 'Z%' OR DEVCLASS LIKE 'Y%' ) OR
          ( DEVCLASS LIKE '/%'
            AND AS4USER <> 'SAP'
            AND PDEVCLASS <> 'SAP'
            AND DLVUNIT <> 'LOCAL'
            AND NOT NAMESPACE IN EXCL_NAMESPACES ) OR
          ( NAMESPACE IN THIRD_PARTY_NS ).

*   delete from LT_TDEVC all the DEVC the user excluded
    IF NOT S_DVCEXC[] IS INITIAL.
      DELETE LT_TDEVC WHERE DEVCLASS IN S_DVCEXC.
    ENDIF.

*   delete from LT_TDEVC all the NAMESPACE the user excluded
    IF NOT S_NSPEXC[] IS INITIAL.
      DELETE LT_TDEVC WHERE NAMESPACE IN S_NSPEXC.
    ENDIF.

  ELSE.
    SELECT * FROM TDEVC
   INTO TABLE LT_TDEVC
   WHERE DEVCLASS IN DEVCLASS.
  ENDIF.

ENDFORM.                    " GET_DEV_CLASS_DATA
*&---------------------------------------------------------------------*
*&      Form  add_abap_query_objects
*&
*& The following objects are collected:
*& 1. Function group of AQ (/1BCDWB/SAPLIQ*) - added once as FUGR and
*&    once as PROG. We add it as FUGR so that the fugr's function
*&    modules interface will be extracted
*& 2. Function group includes (/1BCDWB/LIQ*) - TOP include, UXX include,
*&                             func. modules includes are added as PROG
*& 3. AQ includes (/1BCDWB/IQ*) - added as PROG
*&---------------------------------------------------------------------*
FORM ADD_ABAP_QUERY_OBJECTS.

  DATA: LT_AQLQCAT TYPE TABLE OF AQLQCAT WITH HEADER LINE,
        OBJ_NAME   LIKE RSEUI_SET-OBJ_NAME,
        RSTAT      LIKE TRDIR-RSTAT,
        FUGR_NAME  LIKE RSEUI_SET-OBJ_NAME.

  SELECT * FROM  AQLQCAT
         INTO TABLE LT_AQLQCAT.
  LOOP AT LT_AQLQCAT.
    CLEAR GS_TADIR.
    GS_TADIR-PGMID  = 'R3TR'.
    GS_TADIR-OBJECT = 'PROG'.
* Get Query's program name
    CALL FUNCTION 'RSAQ_REPORT_NAME'
      EXPORTING
        WORKSPACE  = ' '
        USERGROUP  = LT_AQLQCAT-NUM
        QUERY      = LT_AQLQCAT-QNUM
      IMPORTING
        REPORTNAME = GS_TADIR-OBJ_NAME.
    CHECK NOT GS_TADIR-OBJ_NAME IS INITIAL.
    APPEND GS_TADIR TO GT_TADIR.

    ABAP_QUERY_PROGS-OBJ_NAME = GS_TADIR-OBJ_NAME.
    APPEND ABAP_QUERY_PROGS.
  ENDLOOP.

  IF ADD_ABAP_QUERIES = 'X'.

*   Add includes
    SELECT NAME FROM TRDIR
    INTO OBJ_NAME
    WHERE NAME LIKE '/1BCDWB/IQ%'.
      GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
      GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
      APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
    ENDSELECT.

*   Add function group includes (TOP/UXX/function module includes)
    SELECT NAME RSTAT FROM TRDIR
    INTO (OBJ_NAME, RSTAT)
    WHERE NAME LIKE '/1BCDWB/LIQ%'.

*     Do not collect system includes
      IF NOT ( RSTAT = 'S' AND OBJ_NAME CS '$' ).
        GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
        GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
        APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
      ENDIF.
    ENDSELECT.

*   Add function groups (as a function group and a program)
    SELECT NAME FROM TRDIR
    INTO OBJ_NAME
    WHERE NAME LIKE '/1BCDWB/SAPLIQ%'.
      GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
      GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
      APPEND GS_OBJECTLIST TO GT_OBJ_PROG.

      GS_OBJECTLIST-OBJ_TYPE = 'FUGR'.

      PERFORM GET_FUGR_FROM_FUGR_PROG USING OBJ_NAME
                                      CHANGING FUGR_NAME.

      GS_OBJECTLIST-OBJ_NAME = FUGR_NAME.
      APPEND GS_OBJECTLIST TO GT_OBJ_FUNC.
    ENDSELECT.

*   Add structures
    SELECT TABNAME FROM DD02L
    INTO OBJ_NAME
    WHERE TABNAME LIKE '/1BCDWB/IQ%'.
      GS_OBJECTLIST-OBJ_TYPE = 'TABL'.
      GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
      APPEND GS_OBJECTLIST TO GT_OBJ_TABL.
      APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
    ENDSELECT.

  ENDIF.

ENDFORM.                    "add_abap_query_objects

*&---------------------------------------------------------------------*
*&      Form  add_ldb_to_obj_list
*&---------------------------------------------------------------------*
*       Add LDB to object list
*----------------------------------------------------------------------*
*      -->LDB_NAME  LDB name
*      -->OBJ_REC   Object record
*----------------------------------------------------------------------*
FORM ADD_LDB_TO_OBJ_LIST  USING    LDB_NAME TYPE SOBJ_NAME
                                   OBJ_REC TYPE RSEUI_SET.

  DATA: CURR_NAMESPACE   LIKE LINE OF CUSTOMER_OBJECTS,
        NAMESPACE        LIKE DD03L-PRECFIELD,
        LLDB_NAME     TYPE SOBJ_NAME,
        ASTERIX(1)       TYPE C,
        NAMESPACE_LENGTH TYPE I.


* Find if there is customer namespace in the LDB name.
*  (no need to check in case of vanilla extraction)
  CLEAR NAMESPACE.
  LLDB_NAME = LDB_NAME.
  IF VANILLA = ''.
    LOOP AT CUSTOMER_OBJECTS INTO CURR_NAMESPACE.
      IF CURR_NAMESPACE-LOW = 'Z*' OR
         CURR_NAMESPACE-LOW = 'Y*'.
        CONTINUE.
      ENDIF.

      IF LLDB_NAME CP CURR_NAMESPACE-LOW.

*       Get the namespace value
        SPLIT CURR_NAMESPACE-LOW AT '*' INTO NAMESPACE ASTERIX.

*       Get the value of DB without the namespace
        NAMESPACE_LENGTH = STRLEN( NAMESPACE ).

        SHIFT LLDB_NAME BY NAMESPACE_LENGTH PLACES.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

* Add the program name to objects list
  CONCATENATE NAMESPACE 'SAPDB' LLDB_NAME INTO OBJ_REC-OBJ_NAME.
  OBJ_REC-OBJ_TYPE = 'PROG'.
  APPEND OBJ_REC TO GT_OBJ_PROG.

* Add LDB includes
  PERFORM ADD_LDB_INCLUDES USING LLDB_NAME
                                 NAMESPACE
                                 OBJ_REC-OBJ_NAME.

ENDFORM.                    " add_ldb_to_obj_list

*&---------------------------------------------------------------------*
*&      Form  add_ldb_includes
*&---------------------------------------------------------------------*
FORM ADD_LDB_INCLUDES USING LDB_NAME
                            NAMESPACE
                            LDP_PROG_NAME.

  DATA: BEGIN OF INCLUDES OCCURS 50.
          INCLUDE STRUCTURE RSEUINC.
  DATA: END OF INCLUDES.
  DATA: CURR_INCLUDE LIKE LINE OF INCLUDES.
  DATA: SEL_INCLUDE LIKE TRDIR-NAME,
        OBJ_NAME    LIKE RSEUI_SET-OBJ_NAME,
        FLAG.

  REFRESH INCLUDES.

  SELECT * FROM D010INC
  APPENDING CORRESPONDING FIELDS OF TABLE INCLUDES
  WHERE MASTER = LDP_PROG_NAME.

  IF SY-SUBRC <> 0.
    SELECT * FROM RSEUINC
    APPENDING CORRESPONDING FIELDS OF TABLE INCLUDES
    WHERE MASTER = LDP_PROG_NAME.
  ENDIF.

* Add selection screen include
  CONCATENATE NAMESPACE 'DB' LDB_NAME 'SEL' INTO SEL_INCLUDE.
  SELECT SINGLE NAME FROM TRDIR
  INTO OBJ_NAME
  WHERE NAME = SEL_INCLUDE.

  IF SY-SUBRC IS INITIAL.
    CURR_INCLUDE-MASTER  = LDP_PROG_NAME.
    CURR_INCLUDE-INCLUDE = OBJ_NAME.
    APPEND CURR_INCLUDE TO INCLUDES.
  ENDIF.

  SORT INCLUDES.
  DELETE ADJACENT DUPLICATES FROM INCLUDES.

  GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
  LOOP AT INCLUDES.

*   Check if this is customer include. Only if yes - add it
    PERFORM IS_CUSTOMER_DEV_INCLUDE USING INCLUDES-INCLUDE
                                      CHANGING FLAG.

    IF ( FLAG NE VANILLA ).
      GS_OBJECTLIST-OBJ_NAME = INCLUDES-INCLUDE.
      APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "ADD_LDB_INCLUDES
*&---------------------------------------------------------------------*
*&      Form  is_customer_dev_include
*&---------------------------------------------------------------------*
* Check if the given include is a customer development
*(Z*, Y*, customer namespace *, function include 'LZ*';'LY*';'/NS/L*' ,
* LDB include 'DBZ*;'DBY*';'/NS/DB*' )
*----------------------------------------------------------------------*
FORM IS_CUSTOMER_DEV_INCLUDE USING VALUE(INCLUDE_NAME)
                             CHANGING FLAG TYPE BOOLEAN.

  CLEAR FLAG.

  DATA: NAME LIKE RS38L-INCLUDE,
        NAMESPACE LIKE RS38L-NAMESPACE,
        INC_NAME LIKE  RS38L-INCLUDE,
        FIRST_CHAR TYPE C,
        SECOND_CHAR TYPE C.

  FIRST_CHAR = INCLUDE_NAME(1).
  SECOND_CHAR = INCLUDE_NAME+1(1).

  IF FIRST_CHAR = 'L'.
    INCLUDE_NAME = INCLUDE_NAME+1.
  ENDIF.

  IF FIRST_CHAR = 'D' AND SECOND_CHAR = 'B'.
    INCLUDE_NAME = INCLUDE_NAME+2.
  ENDIF.

  IF INCLUDE_NAME IN CUSTOMER_OBJECTS.
    FLAG = 'X'.
  ENDIF.

ENDFORM.                    "is_customer_dev_include

*---------------------------------------------------------------------*
*       FORM EXTRACT_NAMESPACES                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_NAMESPACES.

  DATA: TRNSPACE_ITAB TYPE TABLE OF TRNSPACE,
        TRNSPACET_ITAB TYPE TABLE OF TRNSPACET,
        TRNSPACETT_ITAB TYPE TABLE OF TRNSPACETT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting namespaces'.    "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACES>'.

* export 'TRNSPACE' data
  PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_RUNTIME>'.

  SELECT * FROM TRNSPACE
  INTO TABLE TRNSPACE_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACE_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TRNSPACE'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_RUNTIME>'.
  FREE TRNSPACE_ITAB.

* export 'TRNSPACET' data
  PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_TRANSPORTABLE>'.

  SELECT * FROM TRNSPACET
  INTO TABLE TRNSPACET_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACET_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TRNSPACET'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_TRANSPORTABLE>'.
  FREE TRNSPACET_ITAB.

* export 'TRNSPACETT' data
  PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_TEXTS>'.

  SELECT * FROM TRNSPACETT                              "#EC CI_NOWHERE
  INTO TABLE TRNSPACETT_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACETT_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TRNSPACETT'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_TEXTS>'.
  FREE TRNSPACETT_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACES>'.

  PERFORM ADD_TIME_STAT USING 'Extract namespaces'          "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_NAMESPACES

*---------------------------------------------------------------------*
*       FORM EXTRACT_OMG_MASTER_DATA_TEXTS                            *
*---------------------------------------------------------------------*
*  Get text table values of omega master data                         *
*---------------------------------------------------------------------*
FORM EXTRACT_OMG_MASTER_DATA_TEXTS.
  DATA:
    LT_BUSINESS_PARAM_TEXT TYPE TT_BUSINESS_PARAM_TEXT,
    LS_BUSINESS_PARAM_TEXT_FIELDS TYPE TS_BUSINESS_PARAM_TEXT_FIELDS,
    LT_BUSINESS_PARAM_TEXT_FIELDS TYPE TT_BUSINESS_PARAM_TEXT_FIELDS.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK EXTRACT_OMEGA_MASTER_DATA = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting omega master data texts'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<OMEGA_BUSINESS_PARAM_TEXTS>'.

  PERFORM FILL_TEXT_TABLE_FIELDS TABLES LT_BUSINESS_PARAM_TEXT_FIELDS.

  LOOP AT LT_BUSINESS_PARAM_TEXT_FIELDS
      INTO LS_BUSINESS_PARAM_TEXT_FIELDS.

    CONCATENATE 'Extracting TEXTS of ' "#EC NOTEXT
        LS_BUSINESS_PARAM_TEXT_FIELDS-VALUE
        '('
        LS_BUSINESS_PARAM_TEXT_FIELDS-TABLE_NAME
        ') '
        'from ' P_RFCDES
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM GET_TEXT_TABLE_VALUES
        USING LS_BUSINESS_PARAM_TEXT_FIELDS
        CHANGING LT_BUSINESS_PARAM_TEXT.

  ENDLOOP.

* Work center has a two fields unique key
* (plant and worrk center)
  CONCATENATE 'Extracting TEXTS of WERKS}ARBPL' "#EC NOTEXT
      '(CRHD_V1) '
      'from ' P_RFCDES "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  PERFORM GET_WORK_CENTER_TEXTS
      CHANGING LT_BUSINESS_PARAM_TEXT.

  IF NOT LT_BUSINESS_PARAM_TEXT[] IS INITIAL.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE
            TABLES
              LT_BUSINESS_PARAM_TEXT
            USING
              G_IREF_PDOCUMENT
              'OMEGA_BUSINESS_PARAM_TEXT'.

  ENDIF. " IF NOT LT_BUSINESS_PARAM_TEXT[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '</OMEGA_BUSINESS_PARAM_TEXTS>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract omega master data texts' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.


ENDFORM.                    "EXTRACT_OMG_MASTER_DATA_TEXTS

*---------------------------------------------------------------------*
*       FORM GET_TEXT_TABLE_VALUES                                    *
*---------------------------------------------------------------------*
*  Get text table values                                              *
*---------------------------------------------------------------------*
FORM GET_TEXT_TABLE_VALUES
  USING
    US_FIELDS_NAMES TYPE TS_BUSINESS_PARAM_TEXT_FIELDS
  CHANGING
    CT_BUSINESS_PARAM_TEXT TYPE TT_BUSINESS_PARAM_TEXT.

  DATA:
    LT_REF_TEXT_TABLE      TYPE REF TO DATA,
    OPTIONS                TYPE TABLE OF RFC_DB_OPT,
    FIELDS                 TYPE TABLE OF RFC_DB_FLD,
    ERROR                  TYPE STRING,
    LS_BUSINESS_PARAM_TEXT TYPE TS_BUSINESS_PARAM_TEXT.

  FIELD-SYMBOLS: <FS_TEXT_TABLE> TYPE STANDARD TABLE,
                 <FS_TEXT_TABLE_ROW> TYPE ANY,
                 <FS_VALUE> TYPE ANY.

* APPEND 'SPRAS = ''EN''' TO OPTIONS.

  TRY.
      CREATE DATA LT_REF_TEXT_TABLE TYPE STANDARD TABLE
                                    OF (US_FIELDS_NAMES-TABLE_NAME).
      ASSIGN LT_REF_TEXT_TABLE->* TO <FS_TEXT_TABLE>.

      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE           = US_FIELDS_NAMES-TABLE_NAME
          DELIMITER             = SPACE
          NO_DATA               = SPACE
          ROWSKIPS              = 0
          ROWCOUNT              = 0
        TABLES
          OPTIONS               = OPTIONS
          FIELDS                = FIELDS
          DATA                  = <FS_TEXT_TABLE>
        EXCEPTIONS
          TABLE_NOT_AVAILABLE   = 1
          TABLE_WITHOUT_DATA    = 2
          OPTION_NOT_VALID      = 3
          FIELD_NOT_VALID       = 4
          NOT_AUTHORIZED        = 5
          DATA_BUFFER_EXCEEDED  = 6
          SYSTEM_FAILURE        = 7
          COMMUNICATION_FAILURE = 8
          OTHERS                = 9.

      IF NOT ( SY-SUBRC IS INITIAL AND
         NOT <FS_TEXT_TABLE>[] IS INITIAL ).

        CASE SY-SUBRC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN OTHERS. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE 'Extraction of TEXTS of ' "#EC NOTEXT
              US_FIELDS_NAMES-VALUE
              '('
              US_FIELDS_NAMES-TABLE_NAME
              ') '
              'from ' P_RFCDES "#EC NOTEXT
              'failed. Error: ' ERROR "#EC NOTEXT
              INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      ELSE.

*     Parameter name
        LS_BUSINESS_PARAM_TEXT-BUSINESS_PARAM = US_FIELDS_NAMES-VALUE.

        LOOP AT <FS_TEXT_TABLE> ASSIGNING <FS_TEXT_TABLE_ROW>.

*       LANG
          ASSIGN COMPONENT US_FIELDS_NAMES-LANG
            OF STRUCTURE <FS_TEXT_TABLE_ROW> TO <FS_VALUE>.

          IF SY-SUBRC IS INITIAL AND <FS_VALUE> IS ASSIGNED.
            LS_BUSINESS_PARAM_TEXT-LANG = <FS_VALUE>.
            UNASSIGN <FS_VALUE>.
          ELSE.
            CLEAR LS_BUSINESS_PARAM_TEXT-LANG.
          ENDIF.

*       Parameter value
          ASSIGN COMPONENT US_FIELDS_NAMES-VALUE
            OF STRUCTURE <FS_TEXT_TABLE_ROW> TO <FS_VALUE>.

          IF SY-SUBRC IS INITIAL AND <FS_VALUE> IS ASSIGNED.
            LS_BUSINESS_PARAM_TEXT-VALUE = <FS_VALUE>.
            UNASSIGN <FS_VALUE>.
          ELSE.
            CLEAR LS_BUSINESS_PARAM_TEXT-VALUE.
          ENDIF.

*       Parameter text
          ASSIGN COMPONENT US_FIELDS_NAMES-TEXT
            OF STRUCTURE <FS_TEXT_TABLE_ROW> TO <FS_VALUE>.

          IF SY-SUBRC IS INITIAL AND <FS_VALUE> IS ASSIGNED.
            LS_BUSINESS_PARAM_TEXT-TEXT = <FS_VALUE>.
            UNASSIGN <FS_VALUE>.
          ELSE.
            CLEAR LS_BUSINESS_PARAM_TEXT-TEXT.
          ENDIF.

          APPEND LS_BUSINESS_PARAM_TEXT TO CT_BUSINESS_PARAM_TEXT.
        ENDLOOP.

      ENDIF.

      FREE: LT_REF_TEXT_TABLE, OPTIONS, FIELDS.

    CATCH CX_SY_CREATE_DATA_ERROR.
      CONCATENATE 'Extraction of TEXTS of ' "#EC NOTEXT
            US_FIELDS_NAMES-VALUE
            '('
            US_FIELDS_NAMES-TABLE_NAME
            ') '
            'from ' P_RFCDES "#EC NOTEXT
            'failed. Error: cx_sy_create_data_error' "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDTRY.
ENDFORM.                    "GET_TEXT_TABLE_VALUES

*---------------------------------------------------------------------*
*       FORM FILL_TEXT_TABLE_FIELDS                                   *
*---------------------------------------------------------------------*
*  Fill text table fields                                             *
*---------------------------------------------------------------------*
FORM FILL_TEXT_TABLE_FIELDS
  TABLES ET_FIELDS_NAMES TYPE TT_BUSINESS_PARAM_TEXT_FIELDS.

  DATA:
      LS_FIELDS_NAMES TYPE TS_BUSINESS_PARAM_TEXT_FIELDS.

* The lang field is the same for all the current tables.
  LS_FIELDS_NAMES-LANG = 'SPRAS'.

* Sales Document Type
  LS_FIELDS_NAMES-TABLE_NAME = 'TVAKT'.
  LS_FIELDS_NAMES-VALUE = 'AUART'.
  LS_FIELDS_NAMES-TEXT = 'BEZEI'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Sales Organization
  LS_FIELDS_NAMES-TABLE_NAME = 'TVKOT'.
  LS_FIELDS_NAMES-VALUE = 'VKORG'.
  LS_FIELDS_NAMES-TEXT = 'VTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Distribution Channel
  LS_FIELDS_NAMES-TABLE_NAME = 'TVTWT'.
  LS_FIELDS_NAMES-VALUE = 'VTWEG'.
  LS_FIELDS_NAMES-TEXT = 'VTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Division
  LS_FIELDS_NAMES-TABLE_NAME = 'TSPAT'.
  LS_FIELDS_NAMES-VALUE = 'SPART'.
  LS_FIELDS_NAMES-TEXT = 'VTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Sales Group
  LS_FIELDS_NAMES-TABLE_NAME = 'TVGRT'.
  LS_FIELDS_NAMES-VALUE = 'VKGRP'.
  LS_FIELDS_NAMES-TEXT = 'BEZEI'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Sales Office
  LS_FIELDS_NAMES-TABLE_NAME = 'TVKBT'.
  LS_FIELDS_NAMES-VALUE = 'VKBUR'.
  LS_FIELDS_NAMES-TEXT = 'BEZEI'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Sales District
  LS_FIELDS_NAMES-TABLE_NAME = 'T171T'.
  LS_FIELDS_NAMES-VALUE = 'BZIRK'.
  LS_FIELDS_NAMES-TEXT = 'BZTXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Customer Account group (Partner Functions)
  LS_FIELDS_NAMES-TABLE_NAME = 'TPART'.
  LS_FIELDS_NAMES-VALUE = 'PARVW'.
  LS_FIELDS_NAMES-TEXT = 'VTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Customer group
  LS_FIELDS_NAMES-TABLE_NAME = 'T151T'.
  LS_FIELDS_NAMES-VALUE = 'KDGRP'.
  LS_FIELDS_NAMES-TEXT = 'KTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Company code
  LS_FIELDS_NAMES-TABLE_NAME = 'T001'.
  LS_FIELDS_NAMES-VALUE = 'BUKRS'.
  LS_FIELDS_NAMES-TEXT = 'BUTXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Purchasing Organization
  LS_FIELDS_NAMES-TABLE_NAME = 'T024E'.
  LS_FIELDS_NAMES-VALUE = 'EKORG'.
  LS_FIELDS_NAMES-TEXT = 'EKOTX'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Purchasing Group
  LS_FIELDS_NAMES-TABLE_NAME = 'T024'.
  LS_FIELDS_NAMES-VALUE = 'EKGRP'.
  LS_FIELDS_NAMES-TEXT = 'EKNAM'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Vendor Account group
  LS_FIELDS_NAMES-TABLE_NAME = 'T077Y'.
  LS_FIELDS_NAMES-VALUE = 'KTOKK'.
  LS_FIELDS_NAMES-TEXT = 'TXT30'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Plant
  LS_FIELDS_NAMES-TABLE_NAME = 'T001W'.
  LS_FIELDS_NAMES-VALUE = 'WERKS'.
  LS_FIELDS_NAMES-TEXT = 'NAME1'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Material Type
  LS_FIELDS_NAMES-TABLE_NAME = 'T134T'.
  LS_FIELDS_NAMES-VALUE = 'MTART'.
  LS_FIELDS_NAMES-TEXT = 'MTBEZ'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Currency
  LS_FIELDS_NAMES-TABLE_NAME = 'TCURT'.
  LS_FIELDS_NAMES-VALUE = 'WAERS'.
  LS_FIELDS_NAMES-TEXT = 'LTEXT'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

ENDFORM.                    "FILL_TEXT_TABLE_FIELDS

*---------------------------------------------------------------------*
*       FORM GET_WORK_CENTER_TEXTS                                    *
*---------------------------------------------------------------------*
*  Get text table values of work centers                              *
*---------------------------------------------------------------------*
FORM GET_WORK_CENTER_TEXTS
  CHANGING
    CT_BUSINESS_PARAM_TEXT TYPE TT_BUSINESS_PARAM_TEXT.

  DATA:
    LT_TEXT_TABLE          TYPE TABLE OF CRHD_V1,
    LS_TEXT_TABLE          TYPE CRHD_V1,
    LV_TABNAME             LIKE DD02L-TABNAME,
    LV_BUSINESS_PARAM      TYPE TYPENAME,
    OPTIONS                TYPE TABLE OF RFC_DB_OPT,
    FIELDS                 TYPE TABLE OF RFC_DB_FLD,
    ERROR                  TYPE STRING,
    LS_BUSINESS_PARAM_TEXT TYPE TS_BUSINESS_PARAM_TEXT.


* APPEND 'SPRAS = ''EN''' TO OPTIONS.
  LV_TABNAME = 'CRHD_V1'.
  LV_BUSINESS_PARAM = 'ARBPL'.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE           = LV_TABNAME
      DELIMITER             = SPACE
      NO_DATA               = SPACE
      ROWSKIPS              = 0
      ROWCOUNT              = 0
    TABLES
      OPTIONS               = OPTIONS
      FIELDS                = FIELDS
      DATA                  = LT_TEXT_TABLE
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7
      COMMUNICATION_FAILURE = 8
      OTHERS                = 9.

  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_TEXT_TABLE IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN OTHERS. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of work center texts (ARBPL)' "#EC NOTEXT
          'from ' P_RFCDES "#EC NOTEXT
          'failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ELSE.

    LS_BUSINESS_PARAM_TEXT-BUSINESS_PARAM = LV_BUSINESS_PARAM.
    LOOP AT LT_TEXT_TABLE INTO LS_TEXT_TABLE.
      LS_BUSINESS_PARAM_TEXT-LANG = LS_TEXT_TABLE-SPRAS.
*     The work center key is unique only with its plant number.
      CONCATENATE LS_TEXT_TABLE-ARBPL
                  '}'
                  LS_TEXT_TABLE-WERKS
             INTO LS_BUSINESS_PARAM_TEXT-VALUE.
      LS_BUSINESS_PARAM_TEXT-TEXT = LS_TEXT_TABLE-KTEXT.

      APPEND LS_BUSINESS_PARAM_TEXT TO CT_BUSINESS_PARAM_TEXT.
    ENDLOOP.

  ENDIF.

  FREE: LT_TEXT_TABLE, OPTIONS, FIELDS.

ENDFORM.                    "GET_WORK_CENTER_TEXTS

*---------------------------------------------------------------------*
*       FORM EXTRACT_OMG_MASTER_DATA_RELS                             *
*---------------------------------------------------------------------*
*  Get Business params relations of omega master data                 *
*---------------------------------------------------------------------*
FORM EXTRACT_OMG_MASTER_DATA_RELS.
  DATA:
    LT_BUSINESS_PARAM_REL TYPE TT_BUSINESS_PARAM_REL,
    LS_BUSINESS_PARAM_REL_FIELDS TYPE TS_BUSINESS_PARAM_REL_FIELDS,
    LT_BUSINESS_PARAM_REL_FIELDS TYPE TT_BUSINESS_PARAM_REL_FIELDS.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK EXTRACT_OMEGA_MASTER_DATA = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting omega master data relations' "#EC NOTEXT
  .

  PERFORM APPEND_STRING_TO_FILE USING '<OMEGA_BUSINESS_PARAM_RELS>'.

  PERFORM FILL_PARAM_REL_TABLE_FIELDS TABLES
  LT_BUSINESS_PARAM_REL_FIELDS.

  LOOP AT LT_BUSINESS_PARAM_REL_FIELDS
      INTO LS_BUSINESS_PARAM_REL_FIELDS.

    CONCATENATE 'Extracting RELS of ' "#EC NOTEXT
         LS_BUSINESS_PARAM_REL_FIELDS-VALUE
         'to ' "#EC NOTEXT
         LS_BUSINESS_PARAM_REL_FIELDS-VALUE_REL
         '('
         LS_BUSINESS_PARAM_REL_FIELDS-TABLE_NAME
         ') '
         'from ' P_RFCDES
         INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM GET_PARAM_REL_TABLE_VALUES
        USING LS_BUSINESS_PARAM_REL_FIELDS
        CHANGING LT_BUSINESS_PARAM_REL.

  ENDLOOP.

  IF NOT LT_BUSINESS_PARAM_REL[] IS INITIAL.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE
            TABLES
              LT_BUSINESS_PARAM_REL
            USING
              G_IREF_PDOCUMENT
              'OMEGA_BUSINESS_PARAM_REL'.

  ENDIF. " IF NOT LT_BUSINESS_PARAM_TEXT[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '</OMEGA_BUSINESS_PARAM_RELS>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract omega master data relations' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.


ENDFORM.                    "EXTRACT_OMG_MASTER_DATA_RELS



*---------------------------------------------------------------------*
*       FORM GET_PARAM_REL_TABLE_VALUES                               *
*---------------------------------------------------------------------*
*  Get Business Param Relations table values                          *
*---------------------------------------------------------------------*
FORM GET_PARAM_REL_TABLE_VALUES
  USING
    US_FIELDS_NAMES TYPE TS_BUSINESS_PARAM_REL_FIELDS
  CHANGING
    CT_BUSINESS_PARAM_REL TYPE TT_BUSINESS_PARAM_REL.

  DATA:
    LT_REF_REL_TABLE      TYPE REF TO DATA,
    OPTIONS               TYPE TABLE OF RFC_DB_OPT,
    FIELDS                TYPE TABLE OF RFC_DB_FLD,
    ERROR                 TYPE STRING,
    LS_BUSINESS_PARAM_REL TYPE TS_BUSINESS_PARAM_REL.

  FIELD-SYMBOLS: <FS_REL_TABLE> TYPE STANDARD TABLE,
                 <FS_REL_TABLE_ROW> TYPE ANY,
                 <FS_VALUE> TYPE ANY.

* APPEND 'SPRAS = ''EN''' TO OPTIONS.

  TRY.
      CREATE DATA LT_REF_REL_TABLE TYPE STANDARD TABLE
                                    OF (US_FIELDS_NAMES-TABLE_NAME).
      ASSIGN LT_REF_REL_TABLE->* TO <FS_REL_TABLE>.

      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE           = US_FIELDS_NAMES-TABLE_NAME
          DELIMITER             = SPACE
          NO_DATA               = SPACE
          ROWSKIPS              = 0
          ROWCOUNT              = 0
        TABLES
          OPTIONS               = OPTIONS
          FIELDS                = FIELDS
          DATA                  = <FS_REL_TABLE>
        EXCEPTIONS
          TABLE_NOT_AVAILABLE   = 1
          TABLE_WITHOUT_DATA    = 2
          OPTION_NOT_VALID      = 3
          FIELD_NOT_VALID       = 4
          NOT_AUTHORIZED        = 5
          DATA_BUFFER_EXCEEDED  = 6
          SYSTEM_FAILURE        = 7
          COMMUNICATION_FAILURE = 8
          OTHERS                = 9.

      IF NOT ( SY-SUBRC IS INITIAL AND
         NOT <FS_REL_TABLE>[] IS INITIAL ).

        CASE SY-SUBRC.
          WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
          WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
          WHEN 3. ERROR = 'OPTION_NOT_VALID'.
          WHEN 4. ERROR = 'FIELD_NOT_VALID'.
          WHEN 5. ERROR = 'NOT_AUTHORIZED'.
          WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
          WHEN OTHERS. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE 'Extraction of RELS of ' "#EC NOTEXT
              US_FIELDS_NAMES-VALUE
              'to ' "#EC NOTEXT
              US_FIELDS_NAMES-VALUE_REL
              '('
              US_FIELDS_NAMES-TABLE_NAME
              ') '
              'from ' P_RFCDES "#EC NOTEXT
              'failed. Error: ' ERROR "#EC NOTEXT
              INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      ELSE.

*     Parameter name
        LS_BUSINESS_PARAM_REL-BUSINESS_PARAM = US_FIELDS_NAMES-VALUE.
*     Relation Parameter name
        LS_BUSINESS_PARAM_REL-BUSINESS_PARAM_REL =
            US_FIELDS_NAMES-VALUE_REL.

        LOOP AT <FS_REL_TABLE> ASSIGNING <FS_REL_TABLE_ROW>.

*       Parameter value
          ASSIGN COMPONENT US_FIELDS_NAMES-VALUE
            OF STRUCTURE <FS_REL_TABLE_ROW> TO <FS_VALUE>.

          IF SY-SUBRC IS INITIAL AND <FS_VALUE> IS ASSIGNED.
            LS_BUSINESS_PARAM_REL-VALUE = <FS_VALUE>.
            UNASSIGN <FS_VALUE>.
          ELSE.
            CLEAR LS_BUSINESS_PARAM_REL-VALUE.
          ENDIF.

*       Relation Parameter value
          ASSIGN COMPONENT US_FIELDS_NAMES-VALUE_REL
            OF STRUCTURE <FS_REL_TABLE_ROW> TO <FS_VALUE>.

          IF SY-SUBRC IS INITIAL AND <FS_VALUE> IS ASSIGNED.
            LS_BUSINESS_PARAM_REL-VALUE_REL = <FS_VALUE>.
            UNASSIGN <FS_VALUE>.
          ELSE.
            CLEAR LS_BUSINESS_PARAM_REL-VALUE_REL.
          ENDIF.

          APPEND LS_BUSINESS_PARAM_REL TO CT_BUSINESS_PARAM_REL.
        ENDLOOP.

      ENDIF.

      FREE: LT_REF_REL_TABLE, OPTIONS, FIELDS.

    CATCH CX_SY_CREATE_DATA_ERROR.
      CONCATENATE 'Extraction of RELS of ' "#EC NOTEXT
            US_FIELDS_NAMES-VALUE
            'to ' "#EC NOTEXT
            US_FIELDS_NAMES-VALUE_REL
            '('
            US_FIELDS_NAMES-TABLE_NAME
            ') '
            'from ' P_RFCDES "#EC NOTEXT
            'failed. Error: cx_sy_create_data_error' "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDTRY.

ENDFORM.                    "GET_PARAM_REL_TABLE_VALUES

*---------------------------------------------------------------------*
*       FORM FILL_PARAM_REL_TABLE_FIELDS                           *
*---------------------------------------------------------------------*
*  Get text table values                                              *
*---------------------------------------------------------------------*
FORM FILL_PARAM_REL_TABLE_FIELDS
  TABLES ET_FIELDS_NAMES TYPE TT_BUSINESS_PARAM_REL_FIELDS.

  DATA:
      LS_FIELDS_NAMES TYPE TS_BUSINESS_PARAM_REL_FIELDS.

* Sales Organization to Company Code
  LS_FIELDS_NAMES-TABLE_NAME = 'TVKO'.
  LS_FIELDS_NAMES-VALUE = 'VKORG'.
  LS_FIELDS_NAMES-VALUE_REL = 'BUKRS'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

* Purchasing Organization to Company Code
  LS_FIELDS_NAMES-TABLE_NAME = 'T024E'.
  LS_FIELDS_NAMES-VALUE = 'EKORG'.
  LS_FIELDS_NAMES-VALUE_REL = 'BUKRS'.
  APPEND LS_FIELDS_NAMES TO ET_FIELDS_NAMES.

ENDFORM.                    "FILL_PARAM_REL_TABLE_FIELDS

*&---------------------------------------------------------------------*
*&      Form  extract_extract_infotype_texts
*&---------------------------------------------------------------------*
FORM EXTRACT_INFOTYPE_TEXTS.

  TYPES: BEGIN OF T582S_TYPE,
           MANDT(3) TYPE C,
           SPRSL(1) TYPE C,
           INFTY(4) TYPE C,
           ITBLD(2) TYPE C,
           ITEXT(35) TYPE C,
         END OF T582S_TYPE.

  DATA: LT_T582S   TYPE TABLE OF T582S_TYPE,

        T582S_TAB(15) TYPE C VALUE 'T582S',
        TADIR_WA TYPE TADIR.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting infotype texts'. "#EC NOTEXT

* Get Infotype Texts Data ( only user defined infotypes )
  PERFORM APPEND_STRING_TO_FILE USING '<INFOTYPE_TEXTS>'.

* Check if table 'T582S' exists
  SELECT SINGLE * FROM TADIR INTO TADIR_WA
    WHERE PGMID = 'R3TR' AND OBJECT = 'TABL' AND OBJ_NAME = T582S_TAB.

  IF SY-SUBRC IS INITIAL.
    SELECT * FROM  (T582S_TAB)
    INTO TABLE LT_T582S PACKAGE SIZE PAC_SIZE
    WHERE INFTY > '9000'.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T582S
                                     USING G_IREF_PDOCUMENT
                                           'T582S'.
    ENDSELECT.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</INFOTYPE_TEXTS>'.
  FREE LT_T582S.

  PERFORM ADD_TIME_STAT USING 'Extract infotype texts' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_infotype_texts

*---------------------------------------------------------------------*
*       FORM extract_idocs                                            *
*---------------------------------------------------------------------*
FORM EXTRACT_IDOCS.

  TYPES: BEGIN OF MLINK_WITH_USAGE.
          INCLUDE TYPE BDI_MLINK.
  TYPES:
    USED TYPE XFELD,
  END OF MLINK_WITH_USAGE.

  DATA:
    TAB_DATA TYPE TABLE OF TAB512,
    SEL TYPE TABLE OF RFC_DB_OPT,
    SEL_WA LIKE LINE OF SEL,
    FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
    FIELDS_WA LIKE LINE OF FIELDS_TAB,
    ITAB_VIEW TYPE TABLE OF  BDI_VIEW,
    ITAB_LSYS TYPE TABLE OF  BDI_LSYS,
    ITAB_BLINK TYPE TABLE OF  BDI_BLINK,
    ITAB_MLINK TYPE TABLE OF  BDI_MLINK,
    WA_MLINK LIKE LINE OF ITAB_MLINK,
    ITAB_MLINK_USAGE TYPE TABLE OF MLINK_WITH_USAGE,
    WA_MLINK_USAGE LIKE LINE OF ITAB_MLINK_USAGE,
    ITAB_MTYP TYPE TABLE OF  BDI_MTYP,
    EDIMSGT_ITAB TYPE TABLE OF EDIMSGT,
    TBD52_ITAB TYPE TABLE OF TBD52,
    TBDBA_ITAB TYPE TABLE OF TBDBA,
    TBDBE_ITAB TYPE TABLE OF TBDBE,
    TBDME_ITAB TYPE TABLE OF TBDME.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting IDocs'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<IDOCS>'.

  PERFORM APPEND_STRING_TO_FILE USING '<DISTRIBUTION_MODEL>'.

* Get the idoc distribution model
  CALL FUNCTION 'MODEL_GET'
    EXPORTING
      LANGUAGE = SY-LANGU
    TABLES
      T_VIEW   = ITAB_VIEW
      T_LSYS   = ITAB_LSYS
      T_BLINK  = ITAB_BLINK
      T_MLINK  = ITAB_MLINK
      T_MTYP   = ITAB_MTYP.
*     T_BFLT         =
*     T_MFLT         =
*     T_BPRM         =
*     T_FOBJT        =
*     T_FOBJV        =

  FIELDS_WA-FIELDNAME = 'IDOCTP'.
  APPEND FIELDS_WA TO FIELDS_TAB.
  FIELDS_WA-FIELDNAME = 'MESTYP'.
  APPEND FIELDS_WA TO FIELDS_TAB.

  LOOP AT ITAB_MLINK INTO WA_MLINK.
    WA_MLINK_USAGE = WA_MLINK.
    REFRESH TAB_DATA.
    REFRESH SEL.
    CONCATENATE 'MESTYP =''' WA_MLINK-MESTYP '''' INTO SEL_WA-TEXT.
*      separated by space .
    APPEND SEL_WA TO SEL.
    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE          = 'EDIDC'
        DELIMITER            = SPACE
        NO_DATA              = SPACE
        ROWSKIPS             = 0
        ROWCOUNT             = 5
      TABLES
        OPTIONS              = SEL
        FIELDS               = FIELDS_TAB
        DATA                 = TAB_DATA
      EXCEPTIONS
        TABLE_NOT_AVAILABLE  = 1
        TABLE_WITHOUT_DATA   = 2
        OPTION_NOT_VALID     = 3
        FIELD_NOT_VALID      = 4
        NOT_AUTHORIZED       = 5
        DATA_BUFFER_EXCEEDED = 6
        OTHERS               = 7.
    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE 'extract idocs: RFC_READ_TABLE, message:' "#EC NOTEXT
            WA_MLINK-MESTYP 'Error:' ERROR "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    IF TAB_DATA IS INITIAL.
      CLEAR WA_MLINK_USAGE-USED.
    ELSE.
      WA_MLINK_USAGE-USED = 'X'.
    ENDIF.
    APPEND WA_MLINK_USAGE TO ITAB_MLINK_USAGE.

  ENDLOOP.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_VIEW
                                 USING G_IREF_PDOCUMENT
                                       'MODEL_VIEW'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_LSYS
                                 USING G_IREF_PDOCUMENT
                                       'LOGICAL_SYSTEM'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_BLINK
                                 USING G_IREF_PDOCUMENT
                                       'BAPI_LINK'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_MLINK_USAGE
                                 USING G_IREF_PDOCUMENT
                                       'MESSAGE_LINK'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_MTYP
                                 USING G_IREF_PDOCUMENT
                                       'MESSAGE_TYPE'.

  PERFORM APPEND_STRING_TO_FILE USING '</DISTRIBUTION_MODEL>'.
  FREE: ITAB_VIEW, ITAB_LSYS, ITAB_BLINK, ITAB_MLINK, ITAB_MTYP.

* export EDIMSGT data
  PERFORM APPEND_STRING_TO_FILE USING '<IDOC_MESSAGE_DESC>'.

* Extract all the message type description (not only of the model)
  SELECT * FROM EDIMSGT
  INTO TABLE EDIMSGT_ITAB PACKAGE SIZE PAC_SIZE
  WHERE LANGUA = 'E'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES EDIMSGT_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'EDIMSGT'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</IDOC_MESSAGE_DESC>'.

* export TBD52 data
  PERFORM APPEND_STRING_TO_FILE USING '<EVENT_FUNCTION>'.

  SELECT * FROM TBD52
  INTO TABLE TBD52_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBD52_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TBD52'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</EVENT_FUNCTION>'.

* export TBDBA data
  PERFORM APPEND_STRING_TO_FILE USING '<BAPI_MESSAGE>'.

  SELECT * FROM TBDBA
  INTO TABLE TBDBA_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDBA_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TBDBA'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</BAPI_MESSAGE>'.

* export TBDBE data
  PERFORM APPEND_STRING_TO_FILE USING '<BAPI_INBOUND>'.

  SELECT * FROM TBDBE
  INTO TABLE TBDBE_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDBE_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TBDBE'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</BAPI_INBOUND>'.

* export TBDME data
  PERFORM APPEND_STRING_TO_FILE USING '<MESS_SUPP_DATA>'.

  SELECT * FROM TBDME
  INTO TABLE TBDME_ITAB PACKAGE SIZE PAC_SIZE.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDME_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'TBDME'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</MESS_SUPP_DATA>'.

  PERFORM EXTRACT_PARTNERS_WITH_USAGE.

  PERFORM APPEND_STRING_TO_FILE USING '</IDOCS>'.

  PERFORM ADD_TIME_STAT USING 'Extract IDOCs' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_IDOCS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PARTNERS_WITH_USAGE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_PARTNERS_WITH_USAGE .


  TYPES: BEGIN OF TY_IDOC_USAGE_KEY,
            DIRECTION TYPE EDI_DIRECT,
            MESSAGE_TYPE TYPE EDIPMESTYP,
            PARTNER TYPE EDIPRCVPRN,
            PARTNER_TYPE TYPE EDIPRCVPRT,
         END OF TY_IDOC_USAGE_KEY,
         BEGIN OF TY_IDOC_USAGE.
          INCLUDE TYPE TY_IDOC_USAGE_KEY.
  TYPES: COUNT TYPE NUMC10,
  LAST_USED TYPE DATUM,
*           In an Inbound message we don't have idoc type in the
*           partner profile metadata
  IDOC_TYPE TYPE EDIPIDOCTP,
END OF TY_IDOC_USAGE.
  DATA:
    TAB_DATA TYPE TABLE OF TAB512,
    SEL TYPE TABLE OF RFC_DB_OPT,
    FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
    PP_OUT_ITAB TYPE TABLE OF EDP13,
    PP_OUT_WA LIKE LINE OF PP_OUT_ITAB,
    PP_IN_ITAB TYPE TABLE OF EDP21,
    PP_IN_WA LIKE LINE OF PP_IN_ITAB,
    L_STARTTIME LIKE SY-UZEIT,
    LT_USAGE_PARTNER_IDOC TYPE TT_USAGE_CALLER,
    LS_USAGE_PARTNER_IDOC TYPE TY_USAGE_CALLER,
    LT_IDOC_USAGE_KEY TYPE STANDARD TABLE OF TY_IDOC_USAGE_KEY,
    LS_IDOC_USAGE_KEY TYPE TY_IDOC_USAGE_KEY,
    LT_IDOC_USAGE TYPE STANDARD TABLE OF TY_IDOC_USAGE,
    LS_IDOC_USAGE TYPE TY_IDOC_USAGE,
    LV_LINES TYPE I,
    LV_STR TYPE STRING,
    LV_MAX_IDOC_USAGE_PAIRS_STR TYPE STRING,
    LV_MAX_IDOC_USAGE_TIME_STR(8) TYPE C,
    IS_USAGE_AGGREGATED TYPE C,
    LV_USAGE_END_DATE TYPE SY-DATUM,
    LV_USAGE_END_TIME TYPE SY-UZEIT,
    LV_NOTIFICATION_PARAM TYPE STRING,
    LV_IDOCS_USAGE_LINES TYPE STRING.

  DATA: LV_TIME_LIMIT TYPE SY-UZEIT.

  CLEAR: SEL, FIELDS_TAB, TAB_DATA.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'EDP13'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract idocs: RFC_READ_TABLE of EDP13.' "#EC NOTEXT
          'Error:' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '<PARTNER_PROFILE_OUTBOUND>'.

  PP_OUT_ITAB[] = TAB_DATA[].
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES PP_OUT_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'EDP13'.

* Get the idoc partner usage of the last three months
  IF NOT EXTRACT_IDOCS_USAGE IS INITIAL.
    CLEAR LV_LINES.
    DESCRIBE TABLE PP_OUT_ITAB LINES LV_LINES.
    LV_STR = LV_LINES.

    CONCATENATE 'Outbound Idoc partner messages: ' LV_STR "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   We collect the usage according to partner and Message type
*   (A few EDP13 records can be accomulated to one usage)
    SORT PP_OUT_ITAB BY RCVPRN RCVPRT MESTYP.
    DELETE ADJACENT DUPLICATES FROM PP_OUT_ITAB COMPARING RCVPRN
                                                   RCVPRT MESTYP.

    LOOP AT PP_OUT_ITAB INTO PP_OUT_WA.
      LS_IDOC_USAGE_KEY-DIRECTION = '1'. " Direction = outbound
      LS_IDOC_USAGE_KEY-MESSAGE_TYPE = PP_OUT_WA-MESTYP.
      LS_IDOC_USAGE_KEY-PARTNER = PP_OUT_WA-RCVPRN.
      LS_IDOC_USAGE_KEY-PARTNER_TYPE = PP_OUT_WA-RCVPRT.

      APPEND LS_IDOC_USAGE_KEY TO LT_IDOC_USAGE_KEY.
    ENDLOOP.
  ENDIF.

  FREE PP_OUT_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_PROFILE_OUTBOUND>'.

  CLEAR: SEL, FIELDS_TAB, TAB_DATA.
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'EDP21'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract idocs: RFC_READ_TABLE of EDP21.' "#EC NOTEXT
          'Error:' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '<PARTNER_PROFILE_INBOUND>'.

  PP_IN_ITAB[] = TAB_DATA[].
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES PP_IN_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'EDP21'.

* Get the idoc partner usage of the last three months
  IF NOT EXTRACT_IDOCS_USAGE IS INITIAL.

    CLEAR LV_LINES.
    DESCRIBE TABLE PP_IN_ITAB LINES LV_LINES.
    LV_STR = LV_LINES.

    CONCATENATE 'Inbound Idoc partner messages: ' "#EC NOTEXT
    LV_STR
        INTO GT_ETL_MESSAGE-MESSAGE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   We collect the usage according to partner and Message type
*   (A few EDP21 records can be accomulated to one usage)
    SORT PP_IN_ITAB BY SNDPRN SNDPRT MESTYP.
    DELETE ADJACENT DUPLICATES FROM PP_IN_ITAB COMPARING SNDPRN SNDPRT
                                                         MESTYP.

    LOOP AT PP_IN_ITAB INTO PP_IN_WA.
      LS_IDOC_USAGE_KEY-DIRECTION = '2'. " Direction = inbound
      LS_IDOC_USAGE_KEY-MESSAGE_TYPE = PP_IN_WA-MESTYP.
      LS_IDOC_USAGE_KEY-PARTNER = PP_IN_WA-SNDPRN.
      LS_IDOC_USAGE_KEY-PARTNER_TYPE = PP_IN_WA-SNDPRT.

      APPEND LS_IDOC_USAGE_KEY TO LT_IDOC_USAGE_KEY.
    ENDLOOP.
  ENDIF.

  FREE PP_IN_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_PROFILE_INBOUND>'.

** Extract IDoc Usage

* If there are too many Partner-IDoc pairs for fetching the usage
* for each pair, we fetch it for each IDoc message.
  CLEAR LV_LINES.
  DESCRIBE TABLE LT_IDOC_USAGE_KEY LINES LV_LINES.
  LV_IDOCS_USAGE_LINES = LV_LINES.

  LV_MAX_IDOC_USAGE_PAIRS_STR = MAX_IDOC_USAGE_PAIRS.

  IF LV_LINES > MAX_IDOC_USAGE_PAIRS AND RFC_SYSID <> SY-SYSID.

    CONCATENATE 'IDoc pairs: ' "#EC NOTEXT
    LV_IDOCS_USAGE_LINES '(more than ' "#EC NOTEXT
        LV_MAX_IDOC_USAGE_PAIRS_STR '). '
        'Aggregated Usage data will be fetched.' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   Add notification that IDocs usage extraction will be aggregated
    CONCATENATE LV_IDOCS_USAGE_LINES
                NOTIFICATION_PARAMS_DELIMITER
                LV_MAX_IDOC_USAGE_PAIRS_STR
           INTO LV_NOTIFICATION_PARAM.

    PERFORM ADD_NOTIFICATION USING IDOCS_USAGE_AGGREGATED
                                   LV_NOTIFICATION_PARAM
                                   GT_ETL_MESSAGE-MESSAGE.

*   Make the IDoc key table distinct according to
*   direction and message type
    SORT LT_IDOC_USAGE_KEY BY DIRECTION MESSAGE_TYPE.
    DELETE ADJACENT DUPLICATES FROM LT_IDOC_USAGE_KEY
                          COMPARING DIRECTION MESSAGE_TYPE.
    IS_USAGE_AGGREGATED = 'X'.

    DESCRIBE TABLE LT_IDOC_USAGE_KEY LINES LV_LINES.
    LV_IDOCS_USAGE_LINES = LV_LINES.

    CONCATENATE 'Extract Idoc Usage of: ' LV_STR "#EC NOTEXT
        ' IDoc messages.' INTO GT_ETL_MESSAGE-MESSAGE. "#EC NOTEXT
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ELSE.
    LV_IDOCS_USAGE_LINES = LV_LINES.

    CONCATENATE 'Extract Idoc Usage of: ' "#EC NOTEXT
    LV_IDOCS_USAGE_LINES
        ' partner messages.' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  CONCATENATE '<PARTNER_IDOCS_USAGE IS_USAGE_AGGREGATED="'
    IS_USAGE_AGGREGATED '"> ' INTO LV_STR.
  PERFORM APPEND_STRING_TO_FILE USING LV_STR.

  IF RFC_SYSID <> SY-SYSID.
    LV_TIME_LIMIT = MAX_IDOC_USAGE_TIME.
  ELSE.
    LV_TIME_LIMIT = LOCAL_IDOC_USAGE_TIME.
  ENDIF.

* Calc the max time the IDoc Usage should take.
  PERFORM ADD_TIME USING LV_TIME_LIMIT
                CHANGING LV_USAGE_END_TIME
                         LV_USAGE_END_DATE.

  LOOP AT LT_IDOC_USAGE_KEY INTO LS_IDOC_USAGE_KEY.

*   Make sure the IDoc usage doesn't take too much time
*   (more than 45 min)
    IF ( SY-DATUM > LV_USAGE_END_DATE OR
         SY-UZEIT > LV_USAGE_END_TIME ).

      WRITE LV_TIME_LIMIT TO LV_MAX_IDOC_USAGE_TIME_STR.
      LV_STR = SY-TABIX.
      CONCATENATE 'Extract Idoc Usage takes more than ' "#EC NOTEXT
          LV_MAX_IDOC_USAGE_TIME_STR
          '. Stopping extraction at row: ' LV_STR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*     Add notification for reaching time limit of IDocs usage
*     extraction.
      CONCATENATE LV_MAX_IDOC_USAGE_TIME_STR
                  NOTIFICATION_PARAMS_DELIMITER
                  LV_STR
                  NOTIFICATION_PARAMS_DELIMITER
                  LV_IDOCS_USAGE_LINES
             INTO LV_NOTIFICATION_PARAM.

      PERFORM ADD_NOTIFICATION USING IDOCS_USAGE_TIME_LIMIT
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.

      EXIT.
    ENDIF.

*   Fetch usage only according to direction and message type
*   when there are too many pairs
    IF ( IS_USAGE_AGGREGATED = 'X' ).
      CLEAR LS_IDOC_USAGE_KEY-PARTNER.
      CLEAR LS_IDOC_USAGE_KEY-PARTNER_TYPE.
    ENDIF.

    CLEAR LT_USAGE_PARTNER_IDOC[].

    PERFORM GET_USAGE_BY_MONTHS_BACK
            USING LS_IDOC_USAGE_KEY-DIRECTION
                  LS_IDOC_USAGE_KEY-MESSAGE_TYPE
                  LS_IDOC_USAGE_KEY-PARTNER
                  LS_IDOC_USAGE_KEY-PARTNER_TYPE
                  'IDOCS'
         CHANGING LT_USAGE_PARTNER_IDOC.

    IF ( NOT LT_USAGE_PARTNER_IDOC[] IS INITIAL ).
      LOOP AT LT_USAGE_PARTNER_IDOC INTO LS_USAGE_PARTNER_IDOC.
        MOVE-CORRESPONDING LS_IDOC_USAGE_KEY TO LS_IDOC_USAGE.
        MOVE-CORRESPONDING LS_USAGE_PARTNER_IDOC TO LS_IDOC_USAGE.
*        In the case of an Inbound message we don't have the idoc type
*        in the profile metadata, only in the usage
        LS_IDOC_USAGE-IDOC_TYPE = LS_USAGE_PARTNER_IDOC-CALLER.
        APPEND LS_IDOC_USAGE TO LT_IDOC_USAGE.
      ENDLOOP.
    ENDIF.

  ENDLOOP.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_IDOC_USAGE
                                USING G_IREF_PDOCUMENT
                                      'IDOC_USAGE'.

  PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_IDOCS_USAGE>'.

  FREE : LT_IDOC_USAGE, LT_IDOC_USAGE_KEY.

ENDFORM.                    " EXTRACT_PARTNERS_WITH_USAGE

*---------------------------------------------------------------------*
*       FORM EXTRACT_FUGR_INCLUDES_STATUS                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_FUGR_INCLUDES_STATUS.

  DATA: D010SINF_ITAB TYPE TABLE OF D010SINF.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting fugr inc. status (DEBUG)'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<FUGR_INCLUDES_DEBUG>'.
  SELECT * FROM D010SINF
  INTO TABLE D010SINF_ITAB PACKAGE SIZE PAC_SIZE
  WHERE PROG LIKE 'LZ%'
  OR    PROG LIKE 'LY%'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES D010SINF_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'D010SINF'.
  ENDSELECT.
  PERFORM APPEND_STRING_TO_FILE USING '</FUGR_INCLUDES_DEBUG>'.

  FREE D010SINF_ITAB.

  PERFORM ADD_TIME_STAT USING 'Extract fugr inc. status' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_FUGR_INCLUDES_STATUS

*---------------------------------------------------------------------*
*       FORM EXTRACT_FORMS                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_FORMS.

  DATA: LT_STXFADM  TYPE TABLE OF STXFADM,
        LT_STXFADMT  TYPE TABLE OF STXFADMT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  RANGES: R_FORMNAME FOR STXFADM-FORMNAME.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting forms'.         "#EC NOTEXT

  LOOP AT GT_OBJ_SSFO INTO GS_OBJECTLIST.
    CLEAR R_FORMNAME.
    R_FORMNAME-SIGN   = 'I'.
    R_FORMNAME-OPTION = 'EQ'.
    R_FORMNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
    APPEND R_FORMNAME.
  ENDLOOP.
  FREE GT_OBJ_SSFO.

  PERFORM APPEND_STRING_TO_FILE USING '<FORMS>'.

* Get header data of smart forms
  IF NOT R_FORMNAME[] IS INITIAL.

    PERFORM APPEND_STRING_TO_FILE USING '<SMART_FORMS>'.

*   Select and add smart forms headers
    SELECT * FROM STXFADM
    INTO TABLE LT_STXFADM PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_FORMNAME
    WHERE  FORMNAME = R_FORMNAME-LOW.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STXFADM
                                     USING G_IREF_PDOCUMENT
                                           'SMART_FORM'.
    ENDSELECT.

    PERFORM APPEND_STRING_TO_FILE USING '</SMART_FORMS>'.
    PERFORM APPEND_STRING_TO_FILE USING '<SMART_FORM_TEXTS>'.

*   Select and add smart forms texts
    SELECT * FROM STXFADMT                              "#EC CI_NOFIRST
    INTO TABLE LT_STXFADMT PACKAGE SIZE PAC_SIZE
    FOR ALL ENTRIES IN R_FORMNAME
    WHERE  FORMNAME = R_FORMNAME-LOW.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STXFADMT
                                     USING G_IREF_PDOCUMENT
                                           'SMART_FORM_TEXT'.
    ENDSELECT.

    PERFORM APPEND_STRING_TO_FILE USING '</SMART_FORM_TEXTS>'.
  ENDIF.
  FREE LT_STXFADM.

  PERFORM APPEND_STRING_TO_FILE USING '</FORMS>'.

  PERFORM ADD_TIME_STAT USING 'Extract forms'               "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_FORMS

*&---------------------------------------------------------------------*
*&      Form  extract_layouts
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_LAYOUTS .

  DATA : LV_LAYOUTS_NODE TYPE XML_ELEMENT,
         LV_TNAPR_NODE TYPE XML_ELEMENT,
         LV_T042E_NODE TYPE XML_ELEMENT,
         LV_T042Z_NODE TYPE XML_ELEMENT,
         LV_T390_NODE  TYPE XML_ELEMENT,
         LV_TTXFP_NODE TYPE XML_ELEMENT,
         LV_T001_NODE TYPE XML_ELEMENT,
         LV_T001F_NODE TYPE XML_ELEMENT.

  DATA : LT_TNAPR TYPE STANDARD TABLE OF TNAPR,
         LT_T042E TYPE STANDARD TABLE OF T042E,
         LT_T042Z TYPE STANDARD TABLE OF T042Z,
         LT_T390  TYPE STANDARD TABLE OF T390,
         LT_TTXFP TYPE STANDARD TABLE OF TTXFP,
         LT_T001  TYPE STANDARD TABLE OF T001,
         LT_T001F TYPE STANDARD TABLE OF T001F,
         LT_T681B TYPE STANDARD TABLE OF T681B,
         LT_T685T TYPE STANDARD TABLE OF T685T,
         LT_NACHA_TEXTS TYPE TABLE OF RPY_DVAL.

  PERFORM UPDATE_PROGRESS USING 'Extracting layouts'.       "#EC NOTEXT

* Create the layouts xml node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                G_IREF_ROOT_ELEM
                                'LAYOUTS'
                          CHANGING LV_LAYOUTS_NODE.

  PERFORM APPEND_STRING_TO_FILE USING '<LAYOUTS>'.

* Forms settings - tnapr table
  SELECT *
  FROM TNAPR
  INTO CORRESPONDING FIELDS OF TABLE LT_TNAPR.

  IF NOT LT_TNAPR[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'TNAPR_TABLE'
                            CHANGING LV_TNAPR_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TNAPR
                                   USING G_IREF_PDOCUMENT
                                         LV_TNAPR_NODE
                                         'TNAPR'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_TNAPR_NODE 'X'.
  ENDIF.

* Forms settings - t042e , t042z tables
  SELECT *
  FROM T042E
  INTO CORRESPONDING FIELDS OF TABLE LT_T042E.

  IF NOT LT_T042E[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'T042E_TABLE'
                          CHANGING LV_T042E_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE
       TABLES LT_T042E                       "#EC CI_FLDEXT_OK[2610650]
       USING G_IREF_PDOCUMENT
             LV_T042E_NODE
             'T042E'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T042E_NODE 'X'.
  ENDIF.

  SELECT *
  FROM T042Z
  INTO CORRESPONDING FIELDS OF TABLE LT_T042Z.

  IF NOT LT_T042Z[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'T042Z_TABLE'
                          CHANGING LV_T042Z_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T042Z
                                   USING G_IREF_PDOCUMENT
                                         LV_T042Z_NODE
                                         'T042Z'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T042Z_NODE 'X'.
  ENDIF.

* Forms settings - t390 , ttxfp , t001f tables
  SELECT *
  FROM T390
  INTO CORRESPONDING FIELDS OF TABLE LT_T390
  ORDER BY PRIMARY KEY.

  IF NOT LT_T390[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'T390_TABLE'
                          CHANGING LV_T390_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T390
                                   USING G_IREF_PDOCUMENT
                                         LV_T390_NODE
                                         'T390'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T390_NODE 'X'.
  ENDIF.

  SELECT *
  FROM TTXFP
  INTO CORRESPONDING FIELDS OF TABLE LT_TTXFP.

  IF NOT LT_TTXFP[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'TTXFP_TABLE'
                          CHANGING LV_TTXFP_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TTXFP
                                   USING G_IREF_PDOCUMENT
                                         LV_TTXFP_NODE
                                         'TTXFP'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_TTXFP_NODE 'X'.
  ENDIF.

* Get only company , company text , country
  SELECT BUKRS BUTXT LAND1
  FROM T001
  INTO CORRESPONDING FIELDS OF TABLE LT_T001.

  IF NOT LT_T001[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'T001_TABLE'
                          CHANGING LV_T001_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T001
                                   USING G_IREF_PDOCUMENT
                                         LV_T001_NODE
                                         'T001'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T001_NODE 'X'.
  ENDIF.

  SELECT *                                              "#EC CI_NOWHERE
  FROM T001F
  INTO CORRESPONDING FIELDS OF TABLE LT_T001F
  ORDER BY PRIMARY KEY.

  IF NOT LT_T001F[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  LV_LAYOUTS_NODE
                                  'T001F_TABLE'
                          CHANGING LV_T001F_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T001F
                                   USING G_IREF_PDOCUMENT
                                         LV_T001F_NODE
                                         'T001F'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T001F_NODE 'X'.
  ENDIF.

  SELECT *
    FROM T681B
    INTO CORRESPONDING FIELDS OF TABLE LT_T681B.

  IF NOT LT_T681B[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<LAYOUT_APP_TEXTS>'.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T681B
                                     USING G_IREF_PDOCUMENT
                                           'T681B'.

    PERFORM APPEND_STRING_TO_FILE USING '</LAYOUT_APP_TEXTS>'.
  ENDIF.

  SELECT *
    FROM T685T
    INTO CORRESPONDING FIELDS OF TABLE LT_T685T.

  IF NOT LT_T685T[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<LAYOUT_OUTPUT_TEXTS>'.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T685T
                                     USING G_IREF_PDOCUMENT
                                           'T685T'.

    PERFORM APPEND_STRING_TO_FILE USING '</LAYOUT_OUTPUT_TEXTS>'.
  ENDIF.

* Get domain texts
  CALL FUNCTION 'RPY_DOMAIN_READ'
    EXPORTING
      DOMA_NAME        = 'NA_NACHA'
    TABLES
      DOMA_VALUES      = LT_NACHA_TEXTS
    EXCEPTIONS
      CANCELLED        = 1
      NOT_FOUND        = 2
      PERMISSION_ERROR = 3
      ILLEGAL_TYPE     = 4
      OTHERS           = 5.

  IF SY-SUBRC <> 0.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'CANCELLED'.
      WHEN 2. ERROR = 'NOT_FOUND'.
      WHEN 3. ERROR = 'PERMISSION_ERROR'.
      WHEN 4. ERROR = 'ILLEGAL_TYPE'.
      WHEN 5. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extract Layouts: '                         "#EC NOTEXT
    'RPY_DOMAIN_READ of NA_NACHA.'                          "#EC NOTEXT
              'ERROR:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED
              BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ELSE.
    PERFORM APPEND_STRING_TO_FILE USING '<LAYOUT_MEDIUM_TEXTS>'.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_NACHA_TEXTS
                                     USING G_IREF_PDOCUMENT
                                           'NACHA_TEXT'.

    PERFORM APPEND_STRING_TO_FILE USING '</LAYOUT_MEDIUM_TEXTS>'.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</LAYOUTS>'.

ENDFORM.                    " extract_layouts

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_SERVICES
*&---------------------------------------------------------------------*
FORM EXTRACT_WEB_SERVICES.

  TYPES: BEGIN OF TY_VEPTEXT,
           VEPNAME TYPE VEPNAME,
           LANGU   TYPE SPRAS,
           TEXT    TYPE VEPTEXT,
         END OF TY_VEPTEXT.

* We don't want to extract fields CLUSTR, CLUSTD
* of VEPENDPOINT table
  TYPES: BEGIN OF TY_VEPENDPOINT,
           RELID          TYPE RELID,
           VEPNAME        TYPE VEPNAME,
           VERSION        TYPE R3STATE,
           SORTFIELD      TYPE SRTF2,
           ENDPOINTTYPE   TYPE VEPREFTYPE,
           DATA_VERSION   TYPE VIFENDPOINTDATAVERS,
           DEF_START_PT   TYPE DEF_START_PT,
           AUTO_GENERATED TYPE AUTO_GENERATED,
         END OF TY_VEPENDPOINT.

  DATA: L_STARTTIME LIKE SY-UZEIT,
        L_STARTDATE LIKE SY-DATUM.

  DATA: WSHEADER_ITAB    TYPE TABLE OF WSHEADER,
        VEPENDPOINT_ITAB TYPE TABLE OF TY_VEPENDPOINT,
        VEPFUNCTION_ITAB TYPE TABLE OF VEPFUNCTION,
        VEPTEXT_ITAB     TYPE STANDARD TABLE OF TY_VEPTEXT,
        VEPCROSSREF_ITAB TYPE STANDARD TABLE OF VEPCROSSREF.

  RANGES: R_OBJ_WEBI FOR WSHEADER-WSNAME.

  DATA: LS_OBJ_WEBI LIKE LINE OF R_OBJ_WEBI,
        LS_VEPTEXT  LIKE LINE OF VEPTEXT_ITAB.

  FIELD-SYMBOLS: <OBJ_WEBI> LIKE LINE OF GT_OBJ_WEBI.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Web Services'. "#EC NOTEXT

  CHECK NOT GT_OBJ_WEBI[] IS INITIAL.

  LOOP AT GT_OBJ_WEBI ASSIGNING <OBJ_WEBI>.
    CLEAR R_OBJ_WEBI.
    R_OBJ_WEBI-SIGN = 'I'.
    R_OBJ_WEBI-OPTION = 'EQ'.
    R_OBJ_WEBI-LOW = <OBJ_WEBI>-OBJ_NAME.
    APPEND R_OBJ_WEBI.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICES>'.

* Extract web services header data
  SELECT *
    FROM WSHEADER
    INTO CORRESPONDING FIELDS OF TABLE WSHEADER_ITAB
     FOR ALL ENTRIES IN R_OBJ_WEBI
   WHERE VINAME = R_OBJ_WEBI-LOW.

  IF SY-SUBRC = 0.
    PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_HEADERS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES WSHEADER_ITAB
                                    USING  G_IREF_PDOCUMENT
                                           'WSHEADER'.
    PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_HEADERS>'.
  ENDIF.

* Extract web services end point data
  SELECT *
    FROM VEPENDPOINT
    INTO CORRESPONDING FIELDS OF TABLE VEPENDPOINT_ITAB
     FOR ALL ENTRIES IN R_OBJ_WEBI
   WHERE VEPNAME = R_OBJ_WEBI-LOW.

  IF SY-SUBRC = 0.
    PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_END_POINTS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPENDPOINT_ITAB
                                    USING  G_IREF_PDOCUMENT
                                          'VEPENDPOINT'.
    PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_END_POINTS>'.
  ENDIF.

* Extract web services end point functions data
  SELECT *
    FROM VEPFUNCTION
    INTO CORRESPONDING FIELDS OF TABLE VEPFUNCTION_ITAB
     FOR ALL ENTRIES IN R_OBJ_WEBI
   WHERE VEPNAME = R_OBJ_WEBI-LOW.

  IF SY-SUBRC = 0.
    PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_FUNCTIONS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPFUNCTION_ITAB
                                    USING  G_IREF_PDOCUMENT
                                          'VEPFUNCTION'.
    PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_FUNCTIONS>'.
  ENDIF.

* Extract web services connection to XI Proxies
  SELECT *
    FROM VEPCROSSREF
    INTO CORRESPONDING FIELDS OF TABLE VEPCROSSREF_ITAB
     FOR ALL ENTRIES IN R_OBJ_WEBI
   WHERE VEPNAME = R_OBJ_WEBI-LOW
     AND ( SUB_TYPE = 'INTF'  OR
           SUB_TYPE = 'CLAS' ).

  IF SY-SUBRC = 0.
    PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_XI_PROXY>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPCROSSREF_ITAB
                                    USING  G_IREF_PDOCUMENT
                                          'VEPCROSSREF'.
    PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_XI_PROXY>'.
  ENDIF.

* Extract web services texts
  LOOP AT R_OBJ_WEBI INTO LS_OBJ_WEBI.
*   Get English Text
    CLEAR LS_VEPTEXT.
    LS_VEPTEXT-VEPNAME = LS_OBJ_WEBI-LOW.
    LS_VEPTEXT-LANGU   = 'E'.
    CALL FUNCTION 'GET_WEBI_SHORTTEXT'
      EXPORTING
        VINAME         = LS_VEPTEXT-VEPNAME
        LANGUAGE       = LS_VEPTEXT-LANGU
      IMPORTING
        TEXT           = LS_VEPTEXT-TEXT
      EXCEPTIONS
        NOT_FOUND      = 1
        LOCKED         = 2
        INTERNAL_ERROR = 3
        NO_PERMISSION  = 4
        OTHERS         = 5.
    IF SY-SUBRC = 0.
      APPEND LS_VEPTEXT TO VEPTEXT_ITAB.
    ENDIF.

*   Get login language text (if not english)
    IF SY-LANGU NE 'E'.
      CLEAR LS_VEPTEXT.
      LS_VEPTEXT-VEPNAME = LS_OBJ_WEBI-LOW.
      LS_VEPTEXT-LANGU   = SY-LANGU.
      CALL FUNCTION 'GET_WEBI_SHORTTEXT'
        EXPORTING
          VINAME         = LS_VEPTEXT-VEPNAME
          LANGUAGE       = LS_VEPTEXT-LANGU
        IMPORTING
          TEXT           = LS_VEPTEXT-TEXT
        EXCEPTIONS
          NOT_FOUND      = 1
          LOCKED         = 2
          INTERNAL_ERROR = 3
          NO_PERMISSION  = 4
          OTHERS         = 5.
      IF SY-SUBRC = 0.
        APPEND LS_VEPTEXT TO VEPTEXT_ITAB.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF NOT VEPTEXT_ITAB[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_TEXTS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPTEXT_ITAB
                                    USING  G_IREF_PDOCUMENT
                                          'VEPTEXT'.
    PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_TEXTS>'.
  ENDIF.

* Append closing XML tag for web services data
  PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICES>'.

  PERFORM ADD_TIME_STAT USING 'Extract Web Services' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_WEB_SERVICES

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_INDUSTRY_SOLUTION
*&---------------------------------------------------------------------*
FORM EXTRACT_INDUSTRY_SOLUTION.

  DATA: BF_ACTIVE_TAB         TYPE TABLE OF SFW_ACTIVE_B2,
        SFW_SWITCH_STATE_ITAB TYPE TABLE OF SFW_SWITCH_STATE,
        SFW_ACTIVE_BSET_ITAB  TYPE TABLE OF SFW_ACTIVE_BSET.

  PERFORM UPDATE_PROGRESS USING
        'Extracting industry solution BFs'. "#EC NOTEXT

* Extract activate business functions (BF_ACTIVE_TAB)
  PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_BUSINESS_FUNCTIONS>'.

  SELECT * FROM SFW_ACTIVE_B2 "#EC CI_NOWHERE
  INTO TABLE BF_ACTIVE_TAB.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES BF_ACTIVE_TAB
                                  USING G_IREF_PDOCUMENT
                                        'SFW_ACTIVE_B2'.
  PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_BUSINESS_FUNCTIONS>'.

  FREE BF_ACTIVE_TAB.

* extract Swith States ( SFW_SWITCH_STATE )
  PERFORM APPEND_STRING_TO_FILE USING '<SWITCH_STATES>'.

  SELECT * FROM SFW_SWITCH_STATE "#EC CI_NOWHERE
  INTO TABLE SFW_SWITCH_STATE_ITAB.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_SWITCH_STATE_ITAB
                                  USING G_IREF_PDOCUMENT
                                        'SFW_SWITCH_STATE'.
  PERFORM APPEND_STRING_TO_FILE USING '</SWITCH_STATES>'.

  FREE SFW_SWITCH_STATE_ITAB.

* extract Active Business Functions set ( SFW_ACTIVE_BSET )
  PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_BSET>'.

  SELECT * FROM SFW_ACTIVE_BSET "#EC CI_NOWHERE
  INTO TABLE SFW_ACTIVE_BSET_ITAB.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BSET_ITAB
                                  USING G_IREF_PDOCUMENT
                                        'SFW_ACTIVE_BSET'.

  PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_BSET>'.

  FREE SFW_ACTIVE_BSET_ITAB.

* extract the BF data from prod as well
  PERFORM EXTRACT_PROD_INDUSTRY_SOLUTION.

ENDFORM.                    " EXTRACT_INDUSTRY_SOLUTION

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROD_INDUSTRY_SOLUTION
*&---------------------------------------------------------------------*
FORM EXTRACT_PROD_INDUSTRY_SOLUTION.

  DATA: BF_ACTIVE_TAB         TYPE TABLE OF SFW_ACTIVE_B2,
        BF_ACTIVE_WA          LIKE LINE OF BF_ACTIVE_TAB,
        SFW_SWITCH_STATE_ITAB TYPE TABLE OF SFW_SWITCH_STATE,
        SFW_ACTIVE_BSET_ITAB  TYPE TABLE OF SFW_ACTIVE_BSET,
        TAB_DATA              TYPE TABLE OF TAB512,
        LS_DATA               LIKE LINE OF TAB_DATA,
        SEL                   TYPE TABLE OF RFC_DB_OPT,
        FIELDS_TAB            TYPE TABLE OF RFC_DB_FLD.


  PERFORM UPDATE_PROGRESS USING
        'Extracting prod industry solution BFs'. "#EC NOTEXT

* Extract activate business functions (BF_ACTIVE_TAB)
  PERFORM APPEND_STRING_TO_FILE USING
                                  '<PROD_ACTIVE_BUSINESS_FUNCTIONS>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'SFW_ACTIVE_B2'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.
  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: RFC_READ_TABLE ' "#EC NOTEXT
    'of SFW_ACTIVE_B2.' "#EC NOTEXT
          'Error:' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY
          SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

*   The data cannot be parsed automatically because of the decimals.
  LOOP AT TAB_DATA INTO LS_DATA.
    BF_ACTIVE_WA-VERSION = LS_DATA-WA(1).
    BF_ACTIVE_WA-BFUNCTION = LS_DATA-WA+1(30).
    BF_ACTIVE_WA-SWITCH_ON_TIME = LS_DATA-WA+31(15).
    APPEND BF_ACTIVE_WA TO BF_ACTIVE_TAB.
  ENDLOOP.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES BF_ACTIVE_TAB
                                  USING G_IREF_PDOCUMENT
                                        'PROD_SFW_ACTIVE_B2'.
  PERFORM APPEND_STRING_TO_FILE USING
                                  '</PROD_ACTIVE_BUSINESS_FUNCTIONS>'.
  FREE BF_ACTIVE_TAB.

* extract Swith States ( SFW_SWITCH_STATE )
  PERFORM APPEND_STRING_TO_FILE USING '<PROD_SWITCH_STATES>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'SFW_SWITCH_STATE'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: RFC_READ_TABLE ' "#EC NOTEXT
    'of SFW_SWITCH_STATE.' "#EC NOTEXT
          'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE
          .
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  SFW_SWITCH_STATE_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_SWITCH_STATE_ITAB
                                  USING G_IREF_PDOCUMENT
                                        'PROD_SFW_SWITCH_STATE'.
  PERFORM APPEND_STRING_TO_FILE USING '</PROD_SWITCH_STATES>'.

  FREE SFW_SWITCH_STATE_ITAB.

* extract Active Business Functions set ( SFW_ACTIVE_BSET )
  PERFORM APPEND_STRING_TO_FILE USING '<PROD_ACTIVE_BSET>'.

  CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'SFW_ACTIVE_BSET'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = TAB_DATA
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'extract prod BF: ' "#EC NOTEXT
    'RFC_READ_TABLE of SFW_ACTIVE_BSET.' "#EC NOTEXT
          'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY
          SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  SFW_ACTIVE_BSET_ITAB[] = TAB_DATA[].

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BSET_ITAB
                                  USING G_IREF_PDOCUMENT
                                        'PROD_SFW_ACTIVE_BSET'.

  PERFORM APPEND_STRING_TO_FILE USING '</PROD_ACTIVE_BSET>'.

  FREE SFW_ACTIVE_BSET_ITAB.

ENDFORM.                    " EXTRACT_PROD_INDUSTRY_SOLUTION

*---------------------------------------------------------------------*
*       FORM EXTRACT_USERS_DATA                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_USERS_DATA.

  DATA:
    LT_USERS_DATA_TO_FILE    TYPE TT_USER_MSTR_REC,
    LT_USER_MSTR_REC         TYPE TT_USER_MSTR_REC,
    LT_USERS_WITH_HR_DETAILS TYPE TT_USERS_DETAILS,
    LT_HASH_T500P            TYPE TT_HASH_T500P,
    LT_HASH_T005T            TYPE TT_HASH_T005T,
    LV_NUMBER_OF_ENTRIES     TYPE I,
    LV_STRING                TYPE STRING,
    LV_CURRENT_INDEX         TYPE SY-TABIX,
    LV_BULK                  TYPE I.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  FIELD-SYMBOLS:
    <LS_USER_DATA> LIKE LINE OF LT_USER_MSTR_REC.

  CHECK EXTRACT_USER_DATA = 'X' AND VANILLA =''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting users'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<USERS_DATA>'.

* Get users data from tables USER_ADDR and USR01
  PERFORM GET_USERS_DATA
              TABLES
                 LT_USER_MSTR_REC.

* If data was found,
  IF NOT LT_USER_MSTR_REC[] IS INITIAL.

*   If we should extract HR data
    IF EXTRACT_USER_HR_DATA = ABAP_TRUE.

      " Get all personal area.
      PERFORM GET_ALL_PERSONNEL_AREAS
        CHANGING
          LT_HASH_T500P.

      " Get all countries texts.
      PERFORM GET_ALL_COUNTRIES_TEXT
        CHANGING
          LT_HASH_T005T.

      DESCRIBE TABLE LT_USER_MSTR_REC LINES LV_NUMBER_OF_ENTRIES.
      LV_STRING = LV_NUMBER_OF_ENTRIES.

      CONCATENATE 'Number of users from USER_ADDR from ' "#EC NOTEXT
      P_RFCDES
      ' is : ' LV_STRING "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      " Tried to get user from HR module with bulk size
      " USERS_HR_DATA_BULK_SIZE.
      LOOP AT LT_USER_MSTR_REC ASSIGNING <LS_USER_DATA>.

        LV_CURRENT_INDEX = SY-TABIX.

        APPEND <LS_USER_DATA> TO LT_USERS_DATA_TO_FILE.

        LV_BULK = LV_CURRENT_INDEX MOD USERS_HR_DATA_BULK_SIZE.

        IF LV_CURRENT_INDEX = LV_NUMBER_OF_ENTRIES OR
           LV_BULK = 0.

          LV_STRING = LV_CURRENT_INDEX DIV USERS_HR_DATA_BULK_SIZE.
          CONCATENATE 'User HR data bulk' LV_STRING "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

          PERFORM FILL_USERS_DETAILS_FROM_HR
            USING
              LT_USERS_DATA_TO_FILE
              LT_HASH_T500P
              LT_HASH_T005T
            CHANGING
              LT_USERS_WITH_HR_DETAILS.

          PERFORM ADD_ITAB_TO_FILE_SIMPLE
              TABLES
                LT_USERS_WITH_HR_DETAILS
              USING
                G_IREF_PDOCUMENT
                'USER_DETAILS'.

          FREE: LT_USERS_DATA_TO_FILE, LT_USERS_WITH_HR_DETAILS.

        ENDIF.

      ENDLOOP.

    ELSE.

*     If HR data is not required, add the extracted user data
*     to the XML
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_USER_MSTR_REC
        USING
          G_IREF_PDOCUMENT
          'USER_DETAILS'.

    ENDIF. " IF EXTRACT_USER_HR_DATA = ABAP_TRUE.

  ENDIF. " IF NOT LT_USER_MSTR_REC[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '</USERS_DATA>'.

  PERFORM ADD_TIME_STAT USING 'Extract users' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_USERS_DATA

*---------------------------------------------------------------------*
*       FORM GET_USERS_DATA                                           *
*---------------------------------------------------------------------*
*       Get users data from tables USER_ADDR and USR01                *
*---------------------------------------------------------------------*
FORM GET_USERS_DATA TABLES ET_USER_MSTR_REC TYPE TT_USER_MSTR_REC.

  TYPES: BEGIN OF TS_USR21,
           MANDT      TYPE USR21-MANDT,
           BNAME      TYPE USR21-BNAME,
           PERSNUMBER TYPE USR21-PERSNUMBER,
           ADDRNUMBER TYPE USR21-ADDRNUMBER,
         END OF TS_USR21,

         BEGIN OF TS_ADRP,
           CLIENT     TYPE ADRP-CLIENT,
           PERSNUMBER TYPE ADRP-PERSNUMBER,
           NAME_FIRST TYPE ADRP-NAME_FIRST,
           NAME_LAST  TYPE ADRP-NAME_LAST,
           NAME_TEXT  TYPE ADRP-NAME_TEXT,
         END OF TS_ADRP,

         BEGIN OF TS_ADCP,
           CLIENT     TYPE ADCP-CLIENT,
           ADDRNUMBER TYPE ADCP-ADDRNUMBER,
           PERSNUMBER TYPE ADCP-PERSNUMBER,
           DEPARTMENT TYPE ADCP-DEPARTMENT,
           FUNCTION   TYPE ADCP-FUNCTION,
           BUILDING   TYPE ADCP-BUILDING,
           FLOOR      TYPE ADCP-FLOOR,
           ROOMNUMBER TYPE ADCP-ROOMNUMBER,
         END OF TS_ADCP,

         BEGIN OF TS_ADRC,
           CLIENT     TYPE ADRC-CLIENT,
           ADDRNUMBER TYPE ADRC-ADDRNUMBER,
           CITY1      TYPE ADRC-CITY1,
           NAME1      TYPE ADDR1_DATA-NAME1,
           COUNTRY    TYPE ADDR1_DATA-COUNTRY,
           REGION     TYPE ADDR1_DATA-REGION,
         END OF TS_ADRC.

  DATA:
    P_TABNAME           LIKE DD02L-TABNAME,
    LT_FIELDS           TYPE TABLE OF RFC_DB_FLD,
    LS_FIELDS           LIKE LINE  OF LT_FIELDS,
    LT_OPTIONS          TYPE TABLE OF RFC_DB_OPT,
    LS_OPTIONS          LIKE LINE OF LT_OPTIONS,
    OPTIONS             TYPE TABLE OF RFC_DB_OPT,
    LT_USERS_DATA       TYPE TT_USER_ADDR,
    ERROR               TYPE STRING,
    LT_USER_DEFS        TYPE TT_USR01,
    LS_USER_DEFS        LIKE LINE OF LT_USER_DEFS,
    LS_USER_MSTR_REC    LIKE LINE OF ET_USER_MSTR_REC,
    SUBRC               TYPE NUMC2,
    LT_USR21            TYPE TABLE OF TS_USR21,
    LS_USR21            TYPE TS_USR21,
    LT_ADRP             TYPE TABLE OF TS_ADRP,
    LS_ADRP             TYPE TS_ADRP,
    LT_ADCP             TYPE TABLE OF TS_ADCP,
    LS_ADCP             TYPE TS_ADCP,
    LT_ADRC             TYPE TABLE OF TS_ADRC,
    LS_ADRC             TYPE TS_ADRC,
    LS_USERS_DATA       TYPE TS_USER_ADDR,
    LT_HASH_T005T       TYPE TT_HASH_T005T,
    LS_T005T            LIKE LINE OF LT_HASH_T005T,
    LT_HASH_T005U       TYPE TT_HASH_T005U,
    LS_T005U            LIKE LINE OF LT_HASH_T005U.

  FIELD-SYMBOLS:
    <LS_USER_DATA> LIKE LINE OF LT_USERS_DATA.

* Get the needed users data from table USR21
  CLEAR LT_FIELDS[].
  CLEAR LT_OPTIONS[].
  LS_FIELDS-FIELDNAME = 'MANDT'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'BNAME'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'PERSNUMBER'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'ADDRNUMBER'.
  APPEND LS_FIELDS TO  LT_FIELDS.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE           = 'USR21'
      DELIMITER             = SPACE
      NO_DATA               = SPACE
      ROWSKIPS              = 0
      ROWCOUNT              = 0
    TABLES
      OPTIONS               = LT_OPTIONS
      FIELDS                = LT_FIELDS
      DATA                  = LT_USR21
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7
      COMMUNICATION_FAILURE = 8
      OTHERS                = 9.

* If no exception occurred and data was found
  IF SY-SUBRC IS INITIAL AND NOT LT_USR21 IS INITIAL.

*   Get the needed users data from table ADRP
    CLEAR LT_FIELDS[].
    CLEAR LT_OPTIONS[].
    LS_FIELDS-FIELDNAME = 'CLIENT'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'PERSNUMBER'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'NAME_FIRST'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'NAME_LAST'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'NAME_TEXT'.
    APPEND LS_FIELDS TO  LT_FIELDS.

    LS_OPTIONS-TEXT = 'PERS_GROUP	=	''BC01'''.
    APPEND LS_OPTIONS TO  LT_OPTIONS.

    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE           = 'ADRP'
        DELIMITER             = SPACE
        NO_DATA               = SPACE
        ROWSKIPS              = 0
        ROWCOUNT              = 0
      TABLES
        OPTIONS               = LT_OPTIONS
        FIELDS                = LT_FIELDS
        DATA                  = LT_ADRP
      EXCEPTIONS
        TABLE_NOT_AVAILABLE   = 1
        TABLE_WITHOUT_DATA    = 2
        OPTION_NOT_VALID      = 3
        FIELD_NOT_VALID       = 4
        NOT_AUTHORIZED        = 5
        DATA_BUFFER_EXCEEDED  = 6
        SYSTEM_FAILURE        = 7
        COMMUNICATION_FAILURE = 8
        OTHERS                = 9.

*   Get the needed users data from table ADCP
    CLEAR LT_FIELDS[].
    CLEAR LT_OPTIONS[].
    LS_FIELDS-FIELDNAME = 'CLIENT'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'ADDRNUMBER'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'PERSNUMBER'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'DEPARTMENT'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'FUNCTION'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'BUILDING'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'FLOOR'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'ROOMNUMBER'.
    APPEND LS_FIELDS TO  LT_FIELDS.

    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE           = 'ADCP'
        DELIMITER             = SPACE
        NO_DATA               = SPACE
        ROWSKIPS              = 0
        ROWCOUNT              = 0
      TABLES
        OPTIONS               = LT_OPTIONS
        FIELDS                = LT_FIELDS
        DATA                  = LT_ADCP
      EXCEPTIONS
        TABLE_NOT_AVAILABLE   = 1
        TABLE_WITHOUT_DATA    = 2
        OPTION_NOT_VALID      = 3
        FIELD_NOT_VALID       = 4
        NOT_AUTHORIZED        = 5
        DATA_BUFFER_EXCEEDED  = 6
        SYSTEM_FAILURE        = 7
        COMMUNICATION_FAILURE = 8
        OTHERS                = 9.

*   Get the needed users data from table ADRC
    CLEAR LT_FIELDS[].
    CLEAR LT_OPTIONS[].
    LS_FIELDS-FIELDNAME = 'CLIENT'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'ADDRNUMBER'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'CITY1'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'NAME1'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'COUNTRY'.
    APPEND LS_FIELDS TO  LT_FIELDS.
    LS_FIELDS-FIELDNAME = 'REGION'.
    APPEND LS_FIELDS TO  LT_FIELDS.

    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE           = 'ADRC'
        DELIMITER             = SPACE
        NO_DATA               = SPACE
        ROWSKIPS              = 0
        ROWCOUNT              = 0
      TABLES
        OPTIONS               = LT_OPTIONS
        FIELDS                = LT_FIELDS
        DATA                  = LT_ADRC
      EXCEPTIONS
        TABLE_NOT_AVAILABLE   = 1
        TABLE_WITHOUT_DATA    = 2
        OPTION_NOT_VALID      = 3
        FIELD_NOT_VALID       = 4
        NOT_AUTHORIZED        = 5
        DATA_BUFFER_EXCEEDED  = 6
        SYSTEM_FAILURE        = 7
        COMMUNICATION_FAILURE = 8
        OTHERS                = 9.

*   get countrys names
    PERFORM GET_ALL_COUNTRIES_TEXT
      CHANGING
        LT_HASH_T005T.

*   get regions names
    PERFORM GET_ALL_REGIONS_TEXT
      CHANGING
        LT_HASH_T005U.

    SORT LT_USR21 BY MANDT BNAME PERSNUMBER ADDRNUMBER.
    SORT LT_ADCP BY CLIENT PERSNUMBER ADDRNUMBER.
    SORT LT_ADRP BY CLIENT PERSNUMBER.
    SORT LT_ADRC BY CLIENT ADDRNUMBER.

*   put all the values into LT_USERS_DATA itab.
    LOOP AT LT_USR21 INTO LS_USR21.
      CLEAR LS_USERS_DATA.

*     add USR21 fields into the wa
      MOVE-CORRESPONDING LS_USR21 TO LS_USERS_DATA.

*     add ADCP fields into the wa
      READ TABLE LT_ADCP INTO LS_ADCP WITH KEY CLIENT = LS_USR21-MANDT
                                PERSNUMBER = LS_USR21-PERSNUMBER
                                ADDRNUMBER = LS_USR21-ADDRNUMBER
                                BINARY SEARCH.

      IF SY-SUBRC = 0.
        LS_USERS_DATA-DEPARTMENT = LS_ADCP-DEPARTMENT.
        LS_USERS_DATA-FUNCTION = LS_ADCP-FUNCTION.
        LS_USERS_DATA-BUILDING = LS_ADCP-BUILDING.
        LS_USERS_DATA-FLOOR = LS_ADCP-FLOOR.
        LS_USERS_DATA-ROOM_NUM = LS_ADCP-ROOMNUMBER.
      ENDIF.

*     add ADRP fields into the wa
      READ TABLE LT_ADRP INTO LS_ADRP WITH KEY CLIENT = LS_USR21-MANDT
                                PERSNUMBER = LS_USR21-PERSNUMBER
                                BINARY SEARCH.

      IF SY-SUBRC = 0.
        LS_USERS_DATA-NAME_FIRST = LS_ADRP-NAME_FIRST.
        LS_USERS_DATA-NAME_LAST = LS_ADRP-NAME_LAST.
        LS_USERS_DATA-NAME_TEXT = LS_ADRP-NAME_TEXT.
      ENDIF.

*     add ADRC fields into the wa
      READ TABLE LT_ADRC INTO LS_ADRC WITH KEY CLIENT = LS_USR21-MANDT
                                ADDRNUMBER = LS_USR21-ADDRNUMBER
                                BINARY SEARCH.

      IF SY-SUBRC = 0.
        LS_USERS_DATA-CITY1 = LS_ADRC-CITY1.
        LS_USERS_DATA-COMPANY_NAME = LS_ADRC-NAME1.
        LS_USERS_DATA-COMPANY_COUNTRY = LS_ADRC-COUNTRY.
        LS_USERS_DATA-COMPANY_REGION = LS_ADRC-REGION.
      ENDIF.

*     add country name into the wa
      READ TABLE LT_HASH_T005T INTO LS_T005T
      WITH TABLE KEY LAND1 = LS_USERS_DATA-COMPANY_COUNTRY.

      IF SY-SUBRC = 0.
        LS_USERS_DATA-COMPANY_COUNTRY_TEXT = LS_T005T-LANDX.
      ENDIF.

*     add region name into the wa
      READ TABLE LT_HASH_T005U INTO LS_T005U
      WITH TABLE KEY LAND1 = LS_USERS_DATA-COMPANY_COUNTRY
                     BLAND = LS_USERS_DATA-COMPANY_REGION.

      IF SY-SUBRC = 0.
        LS_USERS_DATA-COMPANY_REGION_TEXT = LS_T005U-BEZEI.
      ENDIF.

      APPEND LS_USERS_DATA TO LT_USERS_DATA.
    ENDLOOP.

** Get the needed users data from table USER_ADDR
*  LS_FIELDS-FIELDNAME = 'MANDT'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'BNAME'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'NAME_FIRST'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'NAME_LAST'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'NAME_TEXTC'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'DEPARTMENT'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*  LS_FIELDS-FIELDNAME = 'CITY1'.
*  APPEND LS_FIELDS TO  LT_FIELDS.
*
*  P_TABNAME = 'USER_ADDR'.
*  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
*    EXPORTING
*      QUERY_TABLE           = P_TABNAME
*      DELIMITER             = SPACE
*      NO_DATA               = SPACE
*      ROWSKIPS              = 0
*      ROWCOUNT              = 0
*    TABLES
*      OPTIONS               = OPTIONS
*      FIELDS                = LT_FIELDS
*      DATA                  = LT_USERS_DATA
*    EXCEPTIONS
*      TABLE_NOT_AVAILABLE   = 1
*      TABLE_WITHOUT_DATA    = 2
*      OPTION_NOT_VALID      = 3
*      FIELD_NOT_VALID       = 4
*      NOT_AUTHORIZED        = 5
*      DATA_BUFFER_EXCEEDED  = 6
*      SYSTEM_FAILURE        = 7
*      COMMUNICATION_FAILURE = 8
*      OTHERS                = 9.
*
** If no exception occurred and data was found
*  IF SY-SUBRC IS INITIAL AND
*    NOT LT_USERS_DATA IS INITIAL.

*   If user formats should be extracted
    IF NOT EXTRACT_USER_FORMATS IS INITIAL.

      CLEAR LT_FIELDS[].

*     Get the needed formats data from table USR01
      LS_FIELDS-FIELDNAME = 'MANDT'.
      APPEND LS_FIELDS TO  LT_FIELDS.
      LS_FIELDS-FIELDNAME = 'BNAME'.
      APPEND LS_FIELDS TO  LT_FIELDS.
      LS_FIELDS-FIELDNAME = 'DATFM'.
      APPEND LS_FIELDS TO  LT_FIELDS.
      LS_FIELDS-FIELDNAME = 'DCPFM'.
      APPEND LS_FIELDS TO  LT_FIELDS.

      CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
        EXPORTING
          QUERY_TABLE           = 'USR01'
          DELIMITER             = SPACE
          NO_DATA               = SPACE
          ROWSKIPS              = 0
          ROWCOUNT              = 0
        TABLES
          OPTIONS               = OPTIONS
          FIELDS                = LT_FIELDS
          DATA                  = LT_USER_DEFS
        EXCEPTIONS
          TABLE_NOT_AVAILABLE   = 1
          TABLE_WITHOUT_DATA    = 2
          OPTION_NOT_VALID      = 3
          FIELD_NOT_VALID       = 4
          NOT_AUTHORIZED        = 5
          DATA_BUFFER_EXCEEDED  = 6
          SYSTEM_FAILURE        = 7
          COMMUNICATION_FAILURE = 8
          OTHERS                = 9.

      SUBRC = SY-SUBRC.

*     If there's an error, add it to the log and continue
      IF SUBRC <> 0.

        CONCATENATE 'Extraction of USR01 from ' P_RFCDES "#EC NOTEXT
              ' failed. Error code: ' SUBRC "#EC NOTEXT
              INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      ENDIF.

      SORT LT_USER_DEFS BY BNAME ASCENDING.

*     Add the data to the exported table
      LOOP AT LT_USERS_DATA ASSIGNING <LS_USER_DATA>.

*       Set the USER_ADDR data
        CLEAR LS_USER_MSTR_REC.
        LS_USER_MSTR_REC = <LS_USER_DATA>.

*       Read and set the USR01 data
        READ TABLE LT_USER_DEFS
          INTO LS_USER_DEFS
          WITH KEY BNAME = <LS_USER_DATA>-BNAME
          BINARY SEARCH.

        IF SY-SUBRC IS INITIAL.

          LS_USER_MSTR_REC-DATFM = LS_USER_DEFS-DATFM.

*         The default value for this field is empty.
*         If we require this field and it's empty, extract it as 'Z'.
          IF LS_USER_DEFS-DCPFM IS INITIAL.

            LS_USER_MSTR_REC-DCPFM = 'Z'.
          ELSE.

*           If it's not empty, just save the value.
            LS_USER_MSTR_REC-DCPFM = LS_USER_DEFS-DCPFM.
          ENDIF.

        ENDIF.

        APPEND LS_USER_MSTR_REC TO ET_USER_MSTR_REC.

      ENDLOOP.

    ELSE.

*     If there's no need for the user formats, just
*     fill the returned table with the data from USER_ADDR
      LOOP AT LT_USERS_DATA ASSIGNING <LS_USER_DATA>.

        CLEAR LS_USER_MSTR_REC.
        LS_USER_MSTR_REC = <LS_USER_DATA>.
        APPEND LS_USER_MSTR_REC TO ET_USER_MSTR_REC.

      ENDLOOP.

    ENDIF.

  ELSE.
*   If no data was found or an excption occurred,
*   set an error and return nothing
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'SYSTEM_FAILURE'.
      WHEN 8. ERROR = 'COMMUNICATION_FAILURE'.
      WHEN OTHERS. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of USER_ADDR from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

ENDFORM.                    "GET_USERS_DATA
*---------------------------------------------------------------------*
*       FORM get_all_personnel_areas                                  *
*---------------------------------------------------------------------*
*  Get all HR personnel areas                                         *
*---------------------------------------------------------------------*
FORM GET_ALL_PERSONNEL_AREAS
  CHANGING
    CT_HASH_T500P TYPE TT_HASH_T500P.

  DATA:
    LT_T500P   TYPE TABLE OF T500P,
    LV_TABNAME LIKE DD02L-TABNAME,
    OPTIONS    TYPE TABLE OF RFC_DB_OPT,
    FIELDS     TYPE TABLE OF RFC_DB_FLD,
    ERROR      TYPE STRING.

  FREE CT_HASH_T500P.

  " Get all personnel areas
  LV_TABNAME = 'T500P'.

  PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING LT_T500P.


  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_T500P IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of T500P from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  " Convert to hash map.
  INSERT LINES OF LT_T500P INTO TABLE CT_HASH_T500P.
  FREE: LT_T500P, OPTIONS, FIELDS.


ENDFORM.                    "GET_ALL_PERSONNEL_AREAS

*---------------------------------------------------------------------*
*       FORM get_all_countries_text                                   *
*---------------------------------------------------------------------*
*  Get all HR countries text                                          *
*---------------------------------------------------------------------*
FORM GET_ALL_COUNTRIES_TEXT
  CHANGING
    CT_HASH_T005T TYPE TT_HASH_T005T.

  DATA:
    LT_T005T   TYPE TABLE OF T005T,
    LV_TABNAME LIKE DD02L-TABNAME,
    OPTIONS    TYPE TABLE OF RFC_DB_OPT,
    FIELDS     TYPE TABLE OF RFC_DB_FLD,
    ERROR      TYPE STRING.

  FREE CT_HASH_T005T.

  " Get all countries text in English
  APPEND 'SPRAS = ''E''' TO OPTIONS.
  LV_TABNAME = 'T005T'.

  PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING LT_T005T.


  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_T005T IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of T005T from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  " Convert to hash map.
  INSERT LINES OF LT_T005T INTO TABLE CT_HASH_T005T.

  FREE: LT_T005T, OPTIONS, FIELDS.

ENDFORM.                    "GET_ALL_COUNTRIES_TEXT

*---------------------------------------------------------------------*
*       FORM get_all_regions_text                                     *
*---------------------------------------------------------------------*
*  Get all regions text                                               *
*---------------------------------------------------------------------*
FORM GET_ALL_REGIONS_TEXT
  CHANGING
    LT_HASH_T005U TYPE TT_HASH_T005U.

  DATA:
    LT_T005U   TYPE TABLE OF T005U,
    LV_TABNAME LIKE DD02L-TABNAME,
    OPTIONS    TYPE TABLE OF RFC_DB_OPT,
    FIELDS     TYPE TABLE OF RFC_DB_FLD,
    ERROR      TYPE STRING.

  FREE LT_HASH_T005U.

  " Get all countries text in English
  APPEND 'SPRAS = ''E''' TO OPTIONS.
  LV_TABNAME = 'T005U'.

  PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                         CHANGING LT_T005U.

  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_T005U IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of T005U from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  " Convert to hash map.
  INSERT LINES OF LT_T005U INTO TABLE LT_HASH_T005U.

  FREE: LT_T005U, OPTIONS, FIELDS.

ENDFORM.                    "GET_ALL_REGIONS_TEXT

*---------------------------------------------------------------------*
*       FORM FILL_USERS_DETAILS_FROM_HR                               *
*---------------------------------------------------------------------*
*  Get user details from HR                                           *
*---------------------------------------------------------------------*
FORM FILL_USERS_DETAILS_FROM_HR
    USING
      IT_USERS_DETAILS TYPE TT_USER_MSTR_REC
      IT_HASH_T500P    TYPE TT_HASH_T500P
      IT_HASH_T005T    TYPE TT_HASH_T005T
    CHANGING
      CT_USERS_DETAILS TYPE TT_USERS_DETAILS.

  TYPES:
    BEGIN OF TS_HR_USER_DATA,
      SAP_USER     TYPE BNAME,
      PERS_AREA_ID TYPE PERSA,
      ORG_UNIT_ID  TYPE ORGEH,
      BUKRS        TYPE BUKRS,
      SUB_AREA     TYPE BTRTL,
      BUS_AREA     TYPE GSBER,
      POSITION     TYPE PLANS,
    END OF TS_HR_USER_DATA.

  DATA:
    LS_USERS_DETAILS    LIKE LINE OF CT_USERS_DETAILS,
    LV_TABNAME          LIKE DD02L-TABNAME,
    OTYPE               TYPE OTYPE,
    LT_PA0105           TYPE TABLE OF PA0105,
    LT_HASH_PA0001      TYPE HASHED TABLE OF PA0001
                             WITH UNIQUE KEY PERNR,
    LT_UNIQUE_ORG_UNIT  TYPE STANDARD TABLE OF ORGEH,
    LT_UNIQUE_COMPANY   TYPE HASHED TABLE OF BUKRS
                             WITH UNIQUE KEY TABLE_LINE,
    LT_UNIQUE_BUS_AREA  TYPE HASHED TABLE OF GSBER
                             WITH UNIQUE KEY TABLE_LINE,
    LT_UNIQUE_POSITION  TYPE STANDARD TABLE OF PLANS,
    LT_HASH_T001        TYPE HASHED TABLE OF T001
                             WITH UNIQUE KEY BUKRS,
    LT_HASH_T001P       TYPE HASHED TABLE OF T001P
                             WITH UNIQUE KEY WERKS BTRTL,
    LT_HASH_TGSBT       TYPE HASHED TABLE OF TGSBT
                             WITH UNIQUE KEY SPRAS GSBER,
    LT_HRP1000_ORG      TYPE TABLE OF HRP1000,
    LT_HRP1000_POS      TYPE TABLE OF HRP1000,
    LT_USERS_HR_DETAILS TYPE HASHED TABLE OF TS_HR_USER_DATA
                             WITH UNIQUE KEY SAP_USER,
    LS_USERS_HR_DETAILS LIKE LINE OF LT_USERS_HR_DETAILS.

  FIELD-SYMBOLS:
    <LS_USERS_DETAILS>    LIKE LINE OF IT_USERS_DETAILS,
    <LS_PA0105>           LIKE LINE OF LT_PA0105,
    <LS_PA0001>           LIKE LINE OF LT_HASH_PA0001,
    <LS_HRP1000>          LIKE LINE OF LT_HRP1000_ORG,
    <LS_T500P>            LIKE LINE OF IT_HASH_T500P,
    <LS_T005T>            LIKE LINE OF IT_HASH_T005T,
    <LS_T001>             LIKE LINE OF LT_HASH_T001,
    <LS_T001P>            LIKE LINE OF LT_HASH_T001P,
    <LS_TGSBT>            LIKE LINE OF LT_HASH_TGSBT,
    <LS_UNIQUE_ORG_UNIT>  LIKE LINE OF LT_UNIQUE_ORG_UNIT,
    <LS_USERS_HR_DETAILS> LIKE LINE OF LT_USERS_HR_DETAILS.

  FREE CT_USERS_DETAILS.

  " Get all the sap users
  PERFORM GET_EMP_BY_SAP_USERS
    USING
      IT_USERS_DETAILS
    CHANGING
      LT_PA0105.

  " Get all the employees assignment by sap users
  PERFORM GET_EMP_ASSIGNMENT_BY_SAP_USR
    USING
      LT_PA0105
    CHANGING
      LT_HASH_PA0001.

  " Add all the employees that have sap users
  LOOP AT LT_PA0105 ASSIGNING <LS_PA0105>.

    READ TABLE LT_HASH_PA0001
    WITH TABLE KEY PERNR = <LS_PA0105>-PERNR
    ASSIGNING <LS_PA0001>.

    IF SY-SUBRC EQ 0.
      LS_USERS_HR_DETAILS-SAP_USER     = <LS_PA0105>-USRID.
      LS_USERS_HR_DETAILS-ORG_UNIT_ID  = <LS_PA0001>-ORGEH.
      LS_USERS_HR_DETAILS-PERS_AREA_ID = <LS_PA0001>-WERKS.
      LS_USERS_HR_DETAILS-BUKRS        = <LS_PA0001>-BUKRS.
      LS_USERS_HR_DETAILS-SUB_AREA     = <LS_PA0001>-BTRTL.
      LS_USERS_HR_DETAILS-BUS_AREA     = <LS_PA0001>-GSBER.
      LS_USERS_HR_DETAILS-POSITION     = <LS_PA0001>-PLANS.
      INSERT LS_USERS_HR_DETAILS INTO TABLE LT_USERS_HR_DETAILS.

      " If org unit doesn't exists , add it to map.
      READ TABLE LT_UNIQUE_ORG_UNIT
      WITH TABLE KEY TABLE_LINE = <LS_PA0001>-ORGEH
      TRANSPORTING NO FIELDS.

      IF SY-SUBRC <> 0.
        INSERT <LS_PA0001>-ORGEH INTO TABLE LT_UNIQUE_ORG_UNIT.
      ENDIF.

      " If company doesn't exists , add it to map.
      READ TABLE LT_UNIQUE_COMPANY
      WITH TABLE KEY TABLE_LINE = <LS_PA0001>-BUKRS
      TRANSPORTING NO FIELDS.

      IF SY-SUBRC <> 0.
        INSERT <LS_PA0001>-BUKRS INTO TABLE LT_UNIQUE_COMPANY.
      ENDIF.

      " If business area doesn't exists , add it to map.
      READ TABLE LT_UNIQUE_BUS_AREA
      WITH TABLE KEY TABLE_LINE = <LS_PA0001>-GSBER
      TRANSPORTING NO FIELDS.

      IF SY-SUBRC <> 0.
        INSERT <LS_PA0001>-GSBER INTO TABLE LT_UNIQUE_BUS_AREA.
      ENDIF.

      " If position doesn't exists , add it to map.
      READ TABLE LT_UNIQUE_POSITION
      WITH TABLE KEY TABLE_LINE = <LS_PA0001>-PLANS
      TRANSPORTING NO FIELDS.

      IF SY-SUBRC <> 0.
        INSERT <LS_PA0001>-PLANS INTO TABLE LT_UNIQUE_POSITION.
      ENDIF.

    ENDIF.

  ENDLOOP.

  FREE: LT_HASH_PA0001, LT_PA0105.

  " Get all organization units text by ids
  OTYPE = 'O'.
  PERFORM GET_OBJECT_TEXT_BY_IDS
    TABLES
      LT_UNIQUE_ORG_UNIT
    USING
      OTYPE
    CHANGING
      LT_HRP1000_ORG.

  " Get all companies names
  PERFORM GET_ALL_COMPANIES_NAMES
    USING
      LT_UNIQUE_COMPANY
    CHANGING
      LT_HASH_T001.

  " Get all business areas names
  PERFORM GET_ALL_BUS_AREA_NAMES
    USING
      LT_UNIQUE_BUS_AREA
    CHANGING
      LT_HASH_TGSBT.

  " Get all positions texts
  OTYPE = 'S'.
  PERFORM GET_OBJECT_TEXT_BY_IDS
    TABLES
      LT_UNIQUE_POSITION
    USING
      OTYPE
    CHANGING
      LT_HRP1000_POS.

  " Get all sub areas texts
  PERFORM GET_ALL_SUB_AREAS_TEXTS
    CHANGING
      LT_HASH_T001P.

  " For each user get his HR DATA.
  LOOP AT IT_USERS_DETAILS ASSIGNING <LS_USERS_DETAILS>.

    CLEAR LS_USERS_DETAILS.

    MOVE-CORRESPONDING <LS_USERS_DETAILS> TO LS_USERS_DETAILS.

    READ TABLE LT_USERS_HR_DETAILS
    WITH TABLE KEY SAP_USER = <LS_USERS_DETAILS>-BNAME
    ASSIGNING <LS_USERS_HR_DETAILS>.

    IF SY-SUBRC EQ 0 .

      LS_USERS_DETAILS-HR_COMPANY_CODE = <LS_USERS_HR_DETAILS>-BUKRS.
      LS_USERS_DETAILS-HR_PERSONAL_AREA =
                <LS_USERS_HR_DETAILS>-PERS_AREA_ID.
      LS_USERS_DETAILS-HR_SUB_AREA = <LS_USERS_HR_DETAILS>-SUB_AREA.
      LS_USERS_DETAILS-HR_BUS_AREA = <LS_USERS_HR_DETAILS>-BUS_AREA.

      " Tried to get the English org unit text from hash table
      READ TABLE LT_HRP1000_ORG BINARY SEARCH
      WITH KEY OBJID = <LS_USERS_HR_DETAILS>-ORG_UNIT_ID
               LANGU = 'EN'
               ASSIGNING <LS_HRP1000>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_ORG_UNIT = <LS_HRP1000>-STEXT.

      ELSE.

        " Tried to get the current language org unit text
        " from hash table
        READ TABLE LT_HRP1000_ORG BINARY SEARCH
        WITH KEY OBJID = <LS_USERS_HR_DETAILS>-ORG_UNIT_ID
                 LANGU = SY-LANGU
                 ASSIGNING <LS_HRP1000>.

        IF SY-SUBRC EQ 0.
          LS_USERS_DETAILS-HR_ORG_UNIT = <LS_HRP1000>-STEXT.
        ELSE.

          " Tried to get the first org unit text
          READ TABLE LT_HRP1000_ORG BINARY SEARCH
          WITH KEY OBJID = <LS_USERS_HR_DETAILS>-ORG_UNIT_ID
                   ASSIGNING <LS_HRP1000> .

          IF SY-SUBRC EQ 0.
            LS_USERS_DETAILS-HR_ORG_UNIT = <LS_HRP1000>-STEXT.
          ENDIF.

        ENDIF.
      ENDIF.

      " Tried to get the English business area text from hash table
      READ TABLE LT_HASH_TGSBT
      WITH TABLE KEY SPRAS = 'EN'
                     GSBER = <LS_USERS_HR_DETAILS>-BUS_AREA
      ASSIGNING <LS_TGSBT>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_BUS_AREA_NAME = <LS_TGSBT>-GTEXT.

      ELSE.

        " Tried to get the current language business area text
        " from hash table
        READ TABLE LT_HASH_TGSBT
        WITH TABLE KEY SPRAS = SY-LANGU
                       GSBER = <LS_USERS_HR_DETAILS>-BUS_AREA
        ASSIGNING <LS_TGSBT>.

        IF SY-SUBRC EQ 0.
          LS_USERS_DETAILS-HR_BUS_AREA_NAME = <LS_TGSBT>-GTEXT.
        ELSE.

          " Tried to get the first business area text exists
          READ TABLE LT_HASH_TGSBT
          WITH KEY GSBER = <LS_USERS_HR_DETAILS>-BUS_AREA
          ASSIGNING <LS_TGSBT>.

          IF SY-SUBRC EQ 0.
            LS_USERS_DETAILS-HR_BUS_AREA_NAME = <LS_TGSBT>-GTEXT.
          ENDIF.

        ENDIF.
      ENDIF.

      " Tried to get the English position text
      READ TABLE LT_HRP1000_POS BINARY SEARCH
      WITH KEY LANGU = 'EN'
               OBJID = <LS_USERS_HR_DETAILS>-POSITION
      ASSIGNING <LS_HRP1000>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_POSITION = <LS_HRP1000>-STEXT.

      ELSE.

        " Tried to get the current language position text
        READ TABLE LT_HRP1000_POS BINARY SEARCH
        WITH KEY LANGU = SY-LANGU
                 OBJID = <LS_USERS_HR_DETAILS>-POSITION
        ASSIGNING <LS_HRP1000>.

        IF SY-SUBRC EQ 0.
          LS_USERS_DETAILS-HR_POSITION = <LS_HRP1000>-STEXT.
        ELSE.

          " Tried to get the first position text
          READ TABLE LT_HRP1000_POS BINARY SEARCH
          WITH KEY OBJID = <LS_USERS_HR_DETAILS>-POSITION
          ASSIGNING <LS_HRP1000>.

          IF SY-SUBRC EQ 0.
            LS_USERS_DETAILS-HR_POSITION = <LS_HRP1000>-STEXT.
          ENDIF.

        ENDIF.
      ENDIF.

      " Get personal area text
      READ TABLE IT_HASH_T500P
      WITH TABLE KEY PERSA = <LS_USERS_HR_DETAILS>-PERS_AREA_ID
      ASSIGNING <LS_T500P>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_PERSONAL_AREA_TEXT = <LS_T500P>-NAME1.

        " Get the country name
        READ TABLE IT_HASH_T005T
        WITH TABLE KEY LAND1 = <LS_T500P>-LAND1
        ASSIGNING <LS_T005T>.

        IF SY-SUBRC EQ 0.
          LS_USERS_DETAILS-HR_COUNTRY = <LS_T005T>-LANDX.
        ENDIF.

      ENDIF.

      " Get company name
      READ TABLE LT_HASH_T001
      WITH TABLE KEY BUKRS = <LS_USERS_HR_DETAILS>-BUKRS
      ASSIGNING <LS_T001>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_COMPANY_NAME = <LS_T001>-BUTXT.
      ENDIF.

      " Get sub area text
      READ TABLE LT_HASH_T001P
      WITH TABLE KEY WERKS = <LS_USERS_HR_DETAILS>-PERS_AREA_ID
                     BTRTL = <LS_USERS_HR_DETAILS>-SUB_AREA
      ASSIGNING <LS_T001P>.

      IF SY-SUBRC EQ 0.
        LS_USERS_DETAILS-HR_SUB_AREA_NAME = <LS_T001P>-BTEXT.
      ENDIF.

    ENDIF.

    APPEND LS_USERS_DETAILS TO CT_USERS_DETAILS.

  ENDLOOP.

  FREE:  LT_HRP1000_ORG, LT_HRP1000_POS, LT_USERS_HR_DETAILS.

ENDFORM.                    "FILL_USERS_DETAILS_FROM_HR

*---------------------------------------------------------------------*
*       FORM get_emp_by_sap_users                                     *
*---------------------------------------------------------------------*
*  Get HR employees that connected to sap users                       *
*---------------------------------------------------------------------*
FORM GET_EMP_BY_SAP_USERS
    USING
    IT_USERS TYPE TT_USER_MSTR_REC
  CHANGING
    CT_PA0105 TYPE TT_PA0105.

  DATA:
    LV_TABNAME           LIKE DD02L-TABNAME,
    OPTIONS              TYPE TABLE OF RFC_DB_OPT,
    FIELDS               TYPE TABLE OF RFC_DB_FLD,
    ERROR                TYPE STRING,
    LV_STR_CONDITION     TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE SY-TABIX,
    LV_STR               TYPE STRING.

  FIELD-SYMBOLS:
    <LS_USERS> LIKE LINE OF IT_USERS.

  FREE CT_PA0105.

  DESCRIBE TABLE IT_USERS LINES LV_NUMBER_OF_ENTRIES.

  IF LV_NUMBER_OF_ENTRIES > 0.

    APPEND '( '  TO OPTIONS.

    LOOP AT IT_USERS ASSIGNING <LS_USERS>.

*     For case user name have "'" character.
*     replace it with double '
      LV_STR = <LS_USERS>-BNAME.

      PERFORM REPLACE_ALL_OCCURRENCES
        USING
          LV_STR
          ''''
          ''''''
        CHANGING
          LV_STR.

      IF LV_NUMBER_OF_ENTRIES > SY-TABIX.

        CONCATENATE
          'USRID = ''' LV_STR ''' OR '
          INTO LV_STR_CONDITION.

      ELSE.

        CONCATENATE
          'USRID = ''' LV_STR ''' '
          INTO LV_STR_CONDITION.

      ENDIF.

      APPEND LV_STR_CONDITION  TO OPTIONS.
    ENDLOOP.

    APPEND ') AND '  TO OPTIONS.

*   Get only sub type of SAP users.
    APPEND 'SUBTY = ''0001''' TO OPTIONS.

    " Get all the employees that connected to sap users
    LV_TABNAME = 'PA0105'.

    PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING CT_PA0105.

    IF NOT ( SY-SUBRC IS INITIAL AND
             NOT CT_PA0105 IS INITIAL ).

      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
     'Error occured when tried to get PA0105 from ' "#EC NOTEXT
      P_RFCDES
      ' failed. Error: ' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.

  ENDIF.

  " Keep only the up to date connection sap user to person.
  SORT CT_PA0105 BY USRID ENDDA DESCENDING.
  DELETE ADJACENT DUPLICATES FROM CT_PA0105
  COMPARING USRID.
  DELETE CT_PA0105 WHERE USRID = SPACE.

  FREE:  OPTIONS, FIELDS.

ENDFORM.                    "GET_EMP_BY_SAP_USERS
*---------------------------------------------------------------------*
*       FORM get_emp_assignment_by_sap_usr                            *
*---------------------------------------------------------------------*
*  Get HR employees assignment by sap users                           *
*---------------------------------------------------------------------*
FORM GET_EMP_ASSIGNMENT_BY_SAP_USR
  USING
    IT_PA0105 TYPE TT_PA0105
  CHANGING
    CT_HASH_PA0001 TYPE TT_HASH_PA0001.

  DATA:
    LT_PA0001            TYPE TABLE OF PA0001,
    LV_TABNAME           LIKE DD02L-TABNAME,
    OPTIONS              TYPE TABLE OF RFC_DB_OPT,
    FIELDS               TYPE TABLE OF RFC_DB_FLD,
    ERROR                TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE SY-TABIX,
    LV_STR_CONDITION     TYPE STRING.

  FIELD-SYMBOLS:
    <LS_PA0105>           LIKE LINE OF IT_PA0105.

  FREE CT_HASH_PA0001.

  DESCRIBE TABLE IT_PA0105 LINES LV_NUMBER_OF_ENTRIES.


  IF LV_NUMBER_OF_ENTRIES > 0.

    " Prepare where condition of personal number that have sap user.
    APPEND '( ' TO OPTIONS.
    LOOP AT IT_PA0105 ASSIGNING <LS_PA0105>.

      IF LV_NUMBER_OF_ENTRIES > SY-TABIX.

        CONCATENATE
          'PERNR = ''' <LS_PA0105>-PERNR ''' OR '
          INTO LV_STR_CONDITION.

      ELSE.

        CONCATENATE
          'PERNR = ''' <LS_PA0105>-PERNR ''' '
          INTO LV_STR_CONDITION.

      ENDIF.

      APPEND LV_STR_CONDITION  TO OPTIONS.
    ENDLOOP.

    APPEND ') AND ' TO OPTIONS.

    APPEND 'SUBTY = SPACE AND '    TO OPTIONS. " only sub type empty
    APPEND 'ENDDA = ''99991231'' ' TO OPTIONS. " only up to date data
    LV_TABNAME = 'PA0001'.

    PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING LT_PA0001.

    IF NOT ( SY-SUBRC IS INITIAL AND
       NOT LT_PA0001 IS INITIAL ).

      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
      'Cann''t get employees data that connected to sap' "#EC NOTEXT
      'user PA0001 from ' P_RFCDES "#EC NOTEXT
      ' failed. Error: ' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.

  ENDIF.

*   Get the last record assignment for each employee
  SORT LT_PA0001 BY PERNR ENDDA DESCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_PA0001
  COMPARING PERNR.

  " Convert to hash map.
  INSERT LINES OF LT_PA0001 INTO TABLE CT_HASH_PA0001.
  FREE LT_PA0001.


ENDFORM.                    "GET_EMP_ASSIGNMENT_BY_SAP_USR

*---------------------------------------------------------------------*
*       FORM get_object_text_by_ids                                   *
*---------------------------------------------------------------------*
*  Get HR objectss by ids                                             *
*---------------------------------------------------------------------*
FORM GET_OBJECT_TEXT_BY_IDS
    TABLES
      IT_UNIQUE_OBJECT
    USING
      OTYPE TYPE OTYPE
    CHANGING
      CT_HRP1000 TYPE TT_HRP1000.

  DATA:
    LT_OBJECT            TYPE TABLE OF OBJID,
    LV_PLAN_VERSION      TYPE PLVAR,
    LV_TABNAME           LIKE DD02L-TABNAME,
    OPTIONS              TYPE TABLE OF RFC_DB_OPT,
    FIELDS               TYPE TABLE OF RFC_DB_FLD,
    ERROR                TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE SY-TABIX,
    LV_STR_CONDITION     TYPE STRING.

  FIELD-SYMBOLS:
    <LS_UNIQUE_OBJECT>  LIKE LINE OF LT_OBJECT.


  FREE CT_HRP1000.

  LT_OBJECT[] = IT_UNIQUE_OBJECT[].

  DESCRIBE TABLE LT_OBJECT LINES LV_NUMBER_OF_ENTRIES.

  IF LV_NUMBER_OF_ENTRIES > 0.

    APPEND '( '  TO OPTIONS.

    LOOP AT LT_OBJECT ASSIGNING <LS_UNIQUE_OBJECT>.

      IF LV_NUMBER_OF_ENTRIES > SY-TABIX.

        CONCATENATE
          'OBJID = ''' <LS_UNIQUE_OBJECT> ''' OR '
          INTO LV_STR_CONDITION.

      ELSE.

        CONCATENATE
          'OBJID = ''' <LS_UNIQUE_OBJECT> ''' '
          INTO LV_STR_CONDITION.

      ENDIF.

      APPEND LV_STR_CONDITION  TO OPTIONS.
    ENDLOOP.

    APPEND ') AND '  TO OPTIONS.

    CONCATENATE
      'OTYPE = ''' OTYPE ''' AND '
      INTO LV_STR_CONDITION.
    APPEND LV_STR_CONDITION TO OPTIONS.

    APPEND 'ENDDA = ''99991231'' AND ' TO OPTIONS. " up to date.

    " Get active plan version
    PERFORM GET_HR_ACTIVE_PLAN_VERSION
      CHANGING
        LV_PLAN_VERSION.

    CONCATENATE 'PLVAR = ''' LV_PLAN_VERSION ''' '
    INTO LV_STR_CONDITION.
    APPEND LV_STR_CONDITION TO OPTIONS. " active HR plan version

    LV_TABNAME = 'HRP1000'.
    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE           = LV_TABNAME
        DELIMITER             = SPACE
        NO_DATA               = SPACE
        ROWSKIPS              = 0
        ROWCOUNT              = 0
      TABLES
        OPTIONS               = OPTIONS
        FIELDS                = FIELDS
        DATA                  = CT_HRP1000
      EXCEPTIONS
        TABLE_NOT_AVAILABLE   = 1
        TABLE_WITHOUT_DATA    = 2
        OPTION_NOT_VALID      = 3
        FIELD_NOT_VALID       = 4
        NOT_AUTHORIZED        = 5
        DATA_BUFFER_EXCEEDED  = 6
        SYSTEM_FAILURE        = 7
        COMMUNICATION_FAILURE = 8
        OTHERS                = 9.


    IF NOT ( SY-SUBRC IS INITIAL AND
       NOT CT_HRP1000 IS INITIAL ).

      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
      'Cann''t get object text' OTYPE 'from HRP1000' "#EC NOTEXT
      'from' P_RFCDES "#EC NOTEXT
      ' failed. Error: ' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.

  ENDIF.

  " Sort & Get only the up to date organization unit.
  SORT CT_HRP1000 BY OBJID LANGU ENDDA DESCENDING.
  DELETE ADJACENT DUPLICATES FROM CT_HRP1000
  COMPARING OBJID LANGU.

  FREE:  OPTIONS, FIELDS.

ENDFORM.                    "GET_OBJECT_TEXT_BY_IDS



*---------------------------------------------------------------------*
*       FORM get_all_companies_names                                  *
*---------------------------------------------------------------------*
*  Get all companies names                                            *
*---------------------------------------------------------------------*
FORM GET_ALL_COMPANIES_NAMES
  USING
      IT_UNIQUE_COMPANY TYPE TT_BUKRS
    CHANGING
      CT_HASH_T001 TYPE TT_HASH_T001.

  DATA:
    LT_T001              TYPE TABLE OF T001,
    LS_T001              TYPE T001,
    LT_COMPANY           TYPE TABLE OF BUKRS,
    LV_TABNAME           LIKE DD02L-TABNAME,
    OPTIONS              TYPE TABLE OF RFC_DB_OPT,
    FIELDS               TYPE TABLE OF RFC_DB_FLD,
    ERROR                TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE SY-TABIX,
    LV_STR_CONDITION     TYPE STRING.

  FIELD-SYMBOLS:
    <LS_UNIQUE_COMPANY>  LIKE LINE OF LT_COMPANY.

  FREE CT_HASH_T001.

  LT_COMPANY[] = IT_UNIQUE_COMPANY[].

  DESCRIBE TABLE LT_COMPANY LINES LV_NUMBER_OF_ENTRIES.

  IF LV_NUMBER_OF_ENTRIES > 0.

    LV_TABNAME = 'T001'.

    PERFORM RFC_READ_TABLE USING LV_TABNAME
                                 P_RFCDES
                                 OPTIONS
                                 FIELDS
                        CHANGING LT_T001.

    IF NOT ( SY-SUBRC IS INITIAL AND
       NOT LT_T001 IS INITIAL ).

      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN OTHERS. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
      'Cann''t get company code text from T001' "#EC NOTEXT
      'from' P_RFCDES "#EC NOTEXT
      ' failed. Error: ' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.

  ENDIF.

* take only the companies that are in IT_UNIQUE_COMPANY itab
* and move them into a hash table
  LOOP AT LT_COMPANY ASSIGNING <LS_UNIQUE_COMPANY>.
    READ TABLE LT_T001 WITH KEY BUKRS = <LS_UNIQUE_COMPANY> INTO LS_T001
 .
    IF SY-SUBRC = 0.
      INSERT LS_T001 INTO TABLE CT_HASH_T001.
    ENDIF.
  ENDLOOP.

  FREE: OPTIONS, FIELDS, LT_T001, LT_COMPANY.

ENDFORM.                    "GET_ALL_COMPANIES_NAMES

*---------------------------------------------------------------------*
*       FORM get_all_bus_area_names                                   *
*---------------------------------------------------------------------*
*  Get all business area names                                        *
*---------------------------------------------------------------------*
FORM GET_ALL_BUS_AREA_NAMES
  USING
      IT_UNIQUE_BUS_AREA TYPE TT_GSBER
    CHANGING
      CT_HASH_TGSBT TYPE TT_HASH_TGSBT.

  DATA:
    LT_TGSBT             TYPE TABLE OF TGSBT,
    LS_TGSBT             TYPE TGSBT,
    LT_BUS_AREA          TYPE TABLE OF GSBER,
    LV_TABNAME           LIKE DD02L-TABNAME,
    OPTIONS              TYPE TABLE OF RFC_DB_OPT,
    FIELDS               TYPE TABLE OF RFC_DB_FLD,
    ERROR                TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE SY-TABIX,
    LV_STR_CONDITION     TYPE STRING.

  FREE CT_HASH_TGSBT.

  LT_BUS_AREA[] = IT_UNIQUE_BUS_AREA[].

  DESCRIBE TABLE LT_BUS_AREA LINES LV_NUMBER_OF_ENTRIES.

  IF LV_NUMBER_OF_ENTRIES > 0.

    LV_TABNAME = 'TGSBT'.

    PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING LT_TGSBT.

    IF NOT ( SY-SUBRC IS INITIAL AND
       NOT LT_TGSBT IS INITIAL ).

      CASE SY-SUBRC.
        WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
        WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
        WHEN 3. ERROR = 'OPTION_NOT_VALID'.
        WHEN 4. ERROR = 'FIELD_NOT_VALID'.
        WHEN 5. ERROR = 'NOT_AUTHORIZED'.
        WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
        WHEN 7. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
      'Cann''t get organization unit text from LT_TGSBT' "#EC NOTEXT
      'from' P_RFCDES "#EC NOTEXT
      ' failed. Error: ' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    ENDIF.

  ENDIF.

* take only the business area that are in IT_UNIQUE_BUS_AREA itab
* and move them into a hash table
  LOOP AT LT_TGSBT INTO LS_TGSBT.
    READ TABLE IT_UNIQUE_BUS_AREA
      WITH TABLE KEY TABLE_LINE = LS_TGSBT-GSBER
      TRANSPORTING NO FIELDS.

    IF SY-SUBRC = 0.
      INSERT LS_TGSBT INTO TABLE CT_HASH_TGSBT.
    ENDIF.
  ENDLOOP.

  FREE: OPTIONS, FIELDS, LT_TGSBT, LT_BUS_AREA.

ENDFORM.                    "GET_ALL_BUS_AREA_NAMES

*---------------------------------------------------------------------*
*       FORM get_all_sub_areas_texts                                  *
*---------------------------------------------------------------------*
*  Get all sub areas texts                                            *
*---------------------------------------------------------------------*
FORM GET_ALL_SUB_AREAS_TEXTS
  CHANGING
    CT_HASH_T001P TYPE TT_HASH_T001P.

  DATA:
    LT_T001P   TYPE TABLE OF T001P,
    LV_TABNAME LIKE DD02L-TABNAME,
    OPTIONS    TYPE TABLE OF RFC_DB_OPT,
    FIELDS     TYPE TABLE OF RFC_DB_FLD,
    ERROR      TYPE STRING.

  FREE CT_HASH_T001P.

  LV_TABNAME = 'T001P'.

  PERFORM RFC_READ_TABLE USING LV_TABNAME
                               P_RFCDES
                               OPTIONS
                               FIELDS
                        CHANGING LT_T001P.

  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_T001P IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of T001P from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  " Convert to hash map.
  INSERT LINES OF LT_T001P INTO TABLE CT_HASH_T001P.
  FREE: LT_T001P, OPTIONS, FIELDS.

ENDFORM.                    "GET_ALL_SUB_AREAS_TEXTS

*---------------------------------------------------------------------*
*       FORM get_hr_active_plan_version                               *
*---------------------------------------------------------------------*
*  Get HR active plan version                                         *
*---------------------------------------------------------------------*
FORM GET_HR_ACTIVE_PLAN_VERSION
    CHANGING
      CV_PLAN_VERSION TYPE PLVAR.

  DATA:
    LV_TABNAME LIKE DD02L-TABNAME,
    LT_T77S0   TYPE TABLE OF T77S0,
    OPTIONS    TYPE TABLE OF RFC_DB_OPT,
    FIELDS     TYPE TABLE OF RFC_DB_FLD,
    ERROR      TYPE STRING.

  FIELD-SYMBOLS:
    <LS_T77S0>            LIKE LINE OF LT_T77S0.

  CLEAR CV_PLAN_VERSION.

  APPEND 'GRPID = ''PLOGI'' AND ' TO OPTIONS. " only type of org unit.
  APPEND 'SEMID = ''PLOGI'' '     TO OPTIONS. " only up to date data.

  LV_TABNAME = 'T77S0'.
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE           = LV_TABNAME
      DELIMITER             = SPACE
      NO_DATA               = SPACE
      ROWSKIPS              = 0
      ROWCOUNT              = 0
    TABLES
      OPTIONS               = OPTIONS
      FIELDS                = FIELDS
      DATA                  = LT_T77S0
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7
      COMMUNICATION_FAILURE = 8
      OTHERS                = 9.


  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_T77S0 IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'Failed to get Active plan version from T77S0 ' P_RFCDES "#EC NOTEXT
          'Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    EXIT.

  ENDIF.

  READ TABLE LT_T77S0 INDEX 1 ASSIGNING <LS_T77S0>.

  IF SY-SUBRC EQ 0.
    CV_PLAN_VERSION = <LS_T77S0>-GSVAL.
    UNASSIGN <LS_T77S0>.
  ENDIF.

  FREE: LT_T77S0, OPTIONS, FIELDS.

ENDFORM.                    "GET_HR_ACTIVE_PLAN_VERSION

*&---------------------------------------------------------------------*
*&      Form  extract_bw_extractors
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BW_EXTRACTORS.

  TYPES: BEGIN OF T_TEXT,
    OLTPSOURCE TYPE CHAR30,
    OBJVERS TYPE CHAR1,
    LANGU TYPE CHAR1,
    TXTSH TYPE CHAR20,
    TXTMD TYPE CHAR40,
    TXTLG TYPE CHAR_60,
  END OF T_TEXT.

  DATA: LS_FCAT TYPE LVC_S_FCAT,
        LT_FCAT TYPE LVC_T_FCAT,
        FIELD_CATALOG TYPE SLIS_T_FIELDCAT_ALV,
        ROOSOURCE_ITAB TYPE REF TO DATA,
        TEMP_DD02L TYPE DD02L.

  DATA: LT_TEXT TYPE TABLE OF T_TEXT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  FIELD-SYMBOLS: <ROOSOURCE_ITAB> TYPE STANDARD TABLE,
                 <FIELD_CATALOG> TYPE SLIS_FIELDCAT_ALV,
                 <OBJ_OSOA_D> LIKE LINE OF GT_OBJ_OSOA_D,
                 <ROOSOURCE_LINE> TYPE ANY,
                 <OLTPSOURCE_VALUE> TYPE ANY.

  CHECK VANILLA = ''.

  SELECT SINGLE *
    FROM DD02L
    INTO TEMP_DD02L
   WHERE TABNAME = 'ROOSOURCE'.

  CHECK SY-SUBRC IS INITIAL.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting BW Extractors'. "#EC NOTEXT

  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      I_STRUCTURE_NAME       = 'ROOSOURCE'
    CHANGING
      CT_FIELDCAT            = FIELD_CATALOG
    EXCEPTIONS
      INCONSISTENT_INTERFACE = 1
      PROGRAM_ERROR          = 2
      OTHERS                 = 3.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'INCONSISTENT_INTERFACE'.
      WHEN 2. ERROR = 'PROGRAM_ERROR'.
      WHEN 3. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
      'extract BW extractors: REUSE_ALV_FIELDCATALOG_MERGE' "#EC NOTEXT
      'of structure ROOSOURCE.' 'Error:' ERROR "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ELSE.
    LOOP AT FIELD_CATALOG ASSIGNING <FIELD_CATALOG>.
      CLEAR LS_FCAT.
      MOVE-CORRESPONDING <FIELD_CATALOG> TO LS_FCAT.
      APPEND LS_FCAT TO LT_FCAT.
    ENDLOOP.

    CALL METHOD CL_ALV_TABLE_CREATE=>CREATE_DYNAMIC_TABLE
      EXPORTING
        IT_FIELDCATALOG = LT_FCAT
      IMPORTING
        EP_TABLE        = ROOSOURCE_ITAB.

    IF SY-SUBRC <> 0.
      CLEAR ERROR.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'GENERATE_SUBPOOL_DIR_FULL'.
        WHEN 2. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE
        'extract BW extractors: create_dynamic_table' "#EC NOTEXT
        'Error:' ERROR "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSE.
      ASSIGN ROOSOURCE_ITAB->* TO <ROOSOURCE_ITAB>.

      " Extract only active resources
      SELECT * FROM ('ROOSOURCE')
      INTO CORRESPONDING FIELDS OF TABLE <ROOSOURCE_ITAB>
      WHERE OBJVERS = 'A'.

      SELECT OLTPSOURCE OBJVERS LANGU TXTSH TXTMD TXTLG
      FROM ('ROOSOURCET')
      INTO CORRESPONDING FIELDS OF TABLE LT_TEXT
      WHERE OBJVERS = 'A'.

      PERFORM APPEND_STRING_TO_FILE USING '<BW_EXTRACTORS>'.

      PERFORM APPEND_STRING_TO_FILE USING '<BW_DATA>'.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES <ROOSOURCE_ITAB>
                                      USING G_IREF_PDOCUMENT
                                            'ROOSOURCE'.
      PERFORM APPEND_STRING_TO_FILE USING '</BW_DATA>'.

      PERFORM APPEND_STRING_TO_FILE USING '<BW_TEXT>'.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TEXT
                                      USING G_IREF_PDOCUMENT
                                            'ROOSOURCET'.
      PERFORM APPEND_STRING_TO_FILE USING '</BW_TEXT>'.

      PERFORM APPEND_STRING_TO_FILE USING '</BW_EXTRACTORS>'.

    ENDIF.
  ENDIF.

  PERFORM ADD_TIME_STAT USING 'Extract BW Extractors' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_bw_extractors

*&---------------------------------------------------------------------*
*&      Form  extract_users
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM EXTRACT_USERS.

  TYPES: BEGIN OF USER_DATA,
           BNAME LIKE USR02-BNAME,
           GLTGV LIKE USR02-GLTGV,
           GLTGB LIKE USR02-GLTGB,
           USTYP LIKE USR02-USTYP,
           TRDAT LIKE USR02-TRDAT,
           LTIME LIKE USR02-LTIME,
         END OF USER_DATA.

  DATA: OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELD TYPE RFC_DB_FLD,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        USR02_ITAB TYPE TABLE OF USER_DATA.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK VANILLA = ''.
  CHECK EXTRACT_USER_DATA = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Active Users'. "#EC NOTEXT

* Choose fields for selection
  FIELD-FIELDNAME = 'BNAME'.
  APPEND FIELD TO FIELDS.
  FIELD-FIELDNAME = 'GLTGV'.
  APPEND FIELD TO FIELDS.
  FIELD-FIELDNAME = 'GLTGB'.
  APPEND FIELD TO FIELDS.
  FIELD-FIELDNAME = 'USTYP'.
  APPEND FIELD TO FIELDS.
  FIELD-FIELDNAME = 'TRDAT'.
  APPEND FIELD TO FIELDS.
  FIELD-FIELDNAME = 'LTIME'.
  APPEND FIELD TO FIELDS.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'USR02'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = OPTIONS
      FIELDS               = FIELDS
      DATA                 = USR02_ITAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_USERS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES USR02_ITAB
                                   USING G_IREF_PDOCUMENT
                                         'USR02'.
    PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_USERS>'.
  ELSE.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of USR02 from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  FREE USR02_ITAB.

  PERFORM ADD_TIME_STAT USING 'Extract Active Users' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_users

*&---------------------------------------------------------------------*
*&      Form  extract_bw_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_BW_DATA.

  CHECK NOT P_BW_RFC IS INITIAL.

  PERFORM UPDATE_PROGRESS USING 'Extracting BW objects'. "#EC NOTEXT

* Extract Data
  PERFORM APPEND_STRING_TO_FILE USING '<BW_OBJECTS>'.

  PERFORM EXTRACT_DATA_SOURCES USING GV_LOGSYS.

  PERFORM EXTRACT_INFO_PROVIDERS.

  PERFORM EXTRACT_BW_OBJECTS USING GV_LOGSYS.

  PERFORM EXTRACT_CONNECTION_TO_HIER.

  PERFORM APPEND_STRING_TO_FILE  USING '</BW_OBJECTS>'.

ENDFORM.                    " extract_bw_data

*&---------------------------------------------------------------------*
*&      Form  extract_data_sources
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_PRODSYS  text
*----------------------------------------------------------------------*
FORM EXTRACT_DATA_SOURCES USING IV_PRODSYS TYPE LOGSYS.

  DATA: LT_RSOLTPSOURCE TYPE TABLE OF TY_RSOLTPSOURCE,
        LT_RSDS         TYPE TABLE OF TY_RSDS,
        LT_RSISOSMAP    TYPE TABLE OF TY_RSISOSMAP,
        LT_OPTIONS      TYPE TABLE OF RFC_DB_OPT,
        LT_FIELDS       TYPE TABLE OF RFC_DB_FLD.

  DATA: LS_OPTIONS      TYPE RFC_DB_OPT,
        LS_FIELDS       TYPE RFC_DB_FLD.
  DATA: LV_C_PRODSYS    TYPE CHAR12.

* Set prodsys in char for rfc options
  CONCATENATE '''' IV_PRODSYS '''' INTO LV_C_PRODSYS.

*** Extract All Replicated DataSources in BW
***************************
*** Get 3X Data Sources ***
***************************
  PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_3X>'.

* Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
  INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING 'RSOLTPSOURCE'
                               P_BW_RFC
                               LT_OPTIONS
                               LT_FIELDS
                        CHANGING LT_RSOLTPSOURCE.

  SORT LT_RSOLTPSOURCE BY OLTPSOURCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSOLTPSOURCE
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSOLTPSOURCE
                                  USING  G_IREF_PDOCUMENT
                                         'RSOLTPSOURCE'.
  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE:  LT_RSOLTPSOURCE.

  PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_3X>'.

***************************
*** Get 7X Data Sources ***
***************************
  PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_7X>'.

* Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'DATASOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
  INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDS'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDS.

  SORT LT_RSDS BY DATASOURCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDS
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDS
                                  USING G_IREF_PDOCUMENT
                                        'RSDS'.
  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDS.

  PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_7X>'.

************************************************
*** Get DataSources Connected To InfoSources ***
************************************************
  PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_TO_INFO_SOURCES>'.

* Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'ISOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSISOSMAP'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSISOSMAP.

  SORT LT_RSISOSMAP BY ISOURCE OLTPSOURCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSISOSMAP
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSISOSMAP
                                  USING  G_IREF_PDOCUMENT
                                        'RSISOSMAP'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSISOSMAP.

  PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_TO_INFO_SOURCES>'.
ENDFORM.                    " extract_data_sources

*&---------------------------------------------------------------------*
*&      Form  extract_bw_objects
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_PRODSYS  text
*----------------------------------------------------------------------*
FORM EXTRACT_BW_OBJECTS USING IV_PRODSYS TYPE LOGSYS.

  DATA: LT_RSPCPROCESSLOG      TYPE STANDARD TABLE OF TY_PROCESSLOG,
        LT_RSPCPROCESSLOG_DATA TYPE TABLE OF TY_PROCESSLOG,
        LT_RSLDPIO             TYPE TABLE OF TY_RSLDPIO,
        LT_RSPCCHAINATTR       TYPE TABLE OF TY_RSPCCHAINATTR,
        LT_RSPCCHAINATTR_TXT   TYPE TABLE OF TY_RSPCCHAINT,
        LT_RSPCCHAIN           TYPE TABLE OF TY_RSPCCHAIN,
        LS_RSPCCHAIN           LIKE LINE OF  LT_RSPCCHAIN,
        LT_RSPCCHAIN_OUT       TYPE STANDARD TABLE OF TY_RSPCCHAIN_OUT,
        LT_RSBKDTP             TYPE TABLE OF TY_RSBKDTP,
        LT_RSBKDTP_TXT         TYPE TABLE OF TY_RSBKDTP_TXT,
        LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
        LT_FIELDS              TYPE TABLE OF RFC_DB_FLD.

  DATA: LV_COMP_COUNT TYPE I,
        LV_FIRST_DATE TYPE BTCRELDT,
        LV_LAST_DATE TYPE BTCRELDT,
        LV_FIRST_TIME TYPE BTCRELTM,
        LV_LAST_TIME TYPE BTCRELTM.

  DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
        LS_FIELDS              TYPE RFC_DB_FLD.

  DATA: LV_CURR_MONTH          TYPE CHAR2,
        LV_FROM_DATE           TYPE BTCRELDT,
        LV_TO_DATE             TYPE BTCRELDT,
        LV_C_FROM_DATE         TYPE CHAR10,
        LV_C_TO_DATE           TYPE CHAR10.
  DATA: LV_C_PRODSYS           TYPE CHAR12.
  FIELD-SYMBOLS : <LS_RSPCPROCESSLOG_DATA>
                  LIKE LINE OF LT_RSPCPROCESSLOG_DATA,
                  <LS_RSPCCHAIN_OUT>
                  LIKE LINE OF LT_RSPCCHAIN_OUT.

* Set prodsys in char for rfc options
  CONCATENATE '''' IV_PRODSYS '''' INTO LV_C_PRODSYS.

*** Getting Usage Of BW Objects
***************************
*** Proccess Chain Data ***
***************************
  PERFORM APPEND_STRING_TO_FILE USING '<PROCESS_CHAIN_ATTR>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'CHAIN_ID'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'APPLNM'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSPCCHAINATTR'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSPCCHAINATTR.

  SORT LT_RSPCCHAINATTR BY CHAIN_ID APPLNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAINATTR
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAINATTR
                                  USING  G_IREF_PDOCUMENT
                                        'RSPCCHAINATTR'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSPCCHAINATTR.

  PERFORM APPEND_STRING_TO_FILE USING '</PROCESS_CHAIN_ATTR>'.

*** Get Chain Data Text
  PERFORM APPEND_STRING_TO_FILE USING '<CHAIN_DATA_TEXT>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'CHAIN_ID'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSPCCHAINT'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSPCCHAINATTR_TXT.

  SORT LT_RSPCCHAINATTR_TXT BY CHAIN_ID LANGU TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAINATTR_TXT COMPARING ALL
  FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAINATTR_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSPCCHAINT'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSPCCHAINATTR_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</CHAIN_DATA_TEXT>'.


********************************
*** Process Chain Components ***
********************************
  PERFORM APPEND_STRING_TO_FILE USING '<PROCESS_CHAIN_COMP>'.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSPCCHAIN'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSPCCHAIN.

  SORT LT_RSPCCHAIN BY CHAIN_ID TYPE VARIANTE LNR EVENT_START
  EVENTP_START EVENTNO_START BACKLINK_START  EVENT_GREEN EVENTP_GREEN
  BACKLINK_GREEN EVENT_RED EVENTP_RED BACKLINK_RED GREEN_EQ_RED WAIT
  MAIL_AT_RED MAIL_AT_GREEN ASCENDING.

  DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAIN
  COMPARING ALL FIELDS.

  LT_RSPCCHAIN_OUT[] = LT_RSPCCHAIN[].

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.

*******************************
*** Get Process Chains Logs ***
*******************************

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'TYPE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'EVENT_START'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'EVENTP_START'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'VARIANTE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'BATCHDATE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'BATCHTIME'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INSTANCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Add Current Month
  LV_CURR_MONTH = SY-DATUM+4(2).

*** Get Data For Previous Year(12 month)
  DO 12 TIMES.

    IF SY-INDEX = 1.

      LV_FROM_DATE      = SY-DATUM.
      LV_FROM_DATE+6(2) = '01'.
      LV_TO_DATE        = SY-DATUM.

    ELSE.

*     Get Previous Month
      SUBTRACT 1 FROM LV_CURR_MONTH.
      IF LV_CURR_MONTH = 0.
*       Starting New Year
        LV_CURR_MONTH  = 12.
      ENDIF.

      LV_FROM_DATE+4(2) = LV_CURR_MONTH.
      LV_TO_DATE+4(2)   = LV_CURR_MONTH.
*     Get Days In Month
      PERFORM GET_LAST_MONTH_DATE CHANGING LV_TO_DATE.
    ENDIF.

*** Create WHERE String For SELECT
    CONCATENATE '''' LV_FROM_DATE '''' INTO LV_C_FROM_DATE.
    CONCATENATE '''' LV_TO_DATE ''''   INTO LV_C_TO_DATE.

    CONCATENATE 'BATCHDATE BETWEEN'
                LV_C_FROM_DATE 'AND' LV_C_TO_DATE
          INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.

    APPEND LS_OPTIONS TO LT_OPTIONS .

    LS_OPTIONS-TEXT = 'AND ( TYPE = ''LOADING'''.
    APPEND LS_OPTIONS TO LT_OPTIONS.
    LS_OPTIONS-TEXT = 'OR TYPE = ''DTP_LOAD'' ) '.
    APPEND LS_OPTIONS TO LT_OPTIONS.


    PERFORM RFC_READ_TABLE USING   'RSPCPROCESSLOG'
                                   P_BW_RFC
                                   LT_OPTIONS
                                   LT_FIELDS
                          CHANGING LT_RSPCPROCESSLOG.

    APPEND LINES OF LT_RSPCPROCESSLOG TO LT_RSPCPROCESSLOG_DATA.

    CLEAR: LT_OPTIONS[], LT_RSPCPROCESSLOG[],  LS_OPTIONS.
  ENDDO.

  SORT LT_RSPCPROCESSLOG_DATA BY TYPE EVENT_START EVENTP_START
  VARIANTE BATCHDATE BATCHTIME INSTANCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSPCPROCESSLOG_DATA
  COMPARING ALL FIELDS.

* Count each component usage - number of log entries
  LOOP AT LT_RSPCPROCESSLOG_DATA ASSIGNING <LS_RSPCPROCESSLOG_DATA>.
    AT NEW VARIANTE.
      LV_COMP_COUNT = 1.
      LV_FIRST_DATE = <LS_RSPCPROCESSLOG_DATA>-BATCHDATE.
      LV_FIRST_TIME = <LS_RSPCPROCESSLOG_DATA>-BATCHTIME.
    ENDAT.

    AT END OF VARIANTE.
      LV_LAST_DATE = <LS_RSPCPROCESSLOG_DATA>-BATCHDATE.
      LV_LAST_TIME = <LS_RSPCPROCESSLOG_DATA>-BATCHTIME.

      READ TABLE LT_RSPCCHAIN_OUT
      WITH KEY TYPE = <LS_RSPCPROCESSLOG_DATA>-TYPE
               EVENT_START = <LS_RSPCPROCESSLOG_DATA>-EVENT_START
               EVENTP_START = <LS_RSPCPROCESSLOG_DATA>-EVENTP_START
               VARIANTE = <LS_RSPCPROCESSLOG_DATA>-VARIANTE
      ASSIGNING <LS_RSPCCHAIN_OUT>.

      IF SY-SUBRC IS INITIAL.
        <LS_RSPCCHAIN_OUT>-FIRST_USED_DATE = LV_FIRST_DATE.
        <LS_RSPCCHAIN_OUT>-FIRST_USED_TIME = LV_FIRST_TIME.
        <LS_RSPCCHAIN_OUT>-LAST_USED_DATE = LV_LAST_DATE.
        <LS_RSPCCHAIN_OUT>-LAST_USED_TIME = LV_LAST_TIME.
        <LS_RSPCCHAIN_OUT>-COUNT = LV_COMP_COUNT.
      ENDIF.
    ENDAT.
    LV_COMP_COUNT = LV_COMP_COUNT + 1.
  ENDLOOP.

  CLEAR: LT_FIELDS[], LS_FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAIN_OUT
                                  USING G_IREF_PDOCUMENT
                                        'RSPCCHAIN'.
  FREE : LT_RSPCCHAIN_OUT,
         LT_RSPCCHAIN,
         LT_RSPCPROCESSLOG_DATA.

  PERFORM APPEND_STRING_TO_FILE USING '</PROCESS_CHAIN_COMP>'.

*****************************************
*** Get DataSources From InfoPackages ***
*****************************************
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_PACKAGES>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LOGDPID'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'LOGSYS'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
  INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.

  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSLDPIO'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSLDPIO.

  SORT LT_RSLDPIO BY LOGDPID LOGSYS OLTPSOURCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSLDPIO
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSLDPIO
                                  USING G_IREF_PDOCUMENT
                                        'RSLDPIO'.
  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSLDPIO.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_PACKAGES>'.

********************************
*** Get DataSources From DTP ***
********************************
  PERFORM APPEND_STRING_TO_FILE USING '<DATASOURCE_FROM_DTP>'.

*** Fill Required Table Fields
*  ls_fields-fieldname = 'SRCTLOGO'.
*  APPEND ls_fields TO lt_fields.
  LS_FIELDS-FIELDNAME = 'DTP'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'SRC'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'SRCTP'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'SRCTLOGO'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TGT'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TGTTP'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TGTTLOGO'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  LS_OPTIONS-TEXT =  'AND SRCTLOGO = ''RSDS'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSBKDTP'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSBKDTP.

  SORT LT_RSBKDTP BY SRCTLOGO SRC SRCTP TGT TGTTP TGTTLOGO ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSBKDTP
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSBKDTP
                                  USING G_IREF_PDOCUMENT
                                        'RSBKDTP'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSBKDTP.
  PERFORM APPEND_STRING_TO_FILE USING '</DATASOURCE_FROM_DTP>'.

*** Get Data Objects Text
  PERFORM APPEND_STRING_TO_FILE USING '<DTP_TEXT>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'DTP'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSBKDTPT'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSBKDTP_TXT.

  SORT LT_RSBKDTP_TXT BY DTP LANGU TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSBKDTP_TXT COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSBKDTP_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSBKDTPT'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSBKDTP_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</DTP_TEXT>'.

ENDFORM.                    " extract_bw_objects
*&---------------------------------------------------------------------*
*&      Form  extract_connection_to_hier
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_CONNECTION_TO_HIER.


  DATA: LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
        LT_FIELDS              TYPE TABLE OF RFC_DB_FLD,
        LT_TADIR               TYPE STANDARD TABLE OF TADIR,
        LT_RSDAREA             TYPE TABLE OF TY_AREA,
        LT_RSDAREA_TXT         TYPE TABLE OF TY_AREA_TXT,
        LT_TDEVC               TYPE TABLE OF TY_TDEVC.

  DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
        LS_FIELDS              TYPE RFC_DB_FLD.

********************************
*** InfoProvider To DevClass ***
********************************
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES_TO_DEV_CLASS>'.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = ' OBJECT = ''CUBE'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  LS_OPTIONS-TEXT = ' OR  OBJECT = ''ODSO'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  LS_OPTIONS-TEXT = ' OR  OBJECT = ''IOBJ'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'TADIR'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_TADIR.

  SORT LT_TADIR BY PGMID OBJECT OBJ_NAME KORRNUM SRCSYSTEM AUTHOR SRCDEP
          DEVCLASS GENFLAG EDTFLAG CPROJECT MASTERLANG VERSID PAKNOCHECK
                                OBJSTABLTY COMPONENT CRELEASE  ASCENDING
                                .

  DELETE ADJACENT DUPLICATES FROM LT_TADIR
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TADIR
                                  USING  G_IREF_PDOCUMENT
                                        'TADIR'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_TADIR.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES_TO_DEV_CLASS>'.

*******************************
*** Extract All Dev Classes ***
*******************************
  PERFORM APPEND_STRING_TO_FILE USING '<BW_DEV_CLASSES>'.

  PERFORM RFC_READ_TABLE USING   'TDEVC'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_TDEVC.

  SORT LT_TDEVC BY DEVCLASS
                   INTSYS
                   CONSYS
                   CTEXT
                   KORRFLAG
                   AS4USER
                   PDEVCLASS
                ASCENDING.

  DELETE ADJACENT DUPLICATES FROM LT_TDEVC
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVC
                                  USING  G_IREF_PDOCUMENT
                                        'TDEVC'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_TDEVC.

  PERFORM APPEND_STRING_TO_FILE USING '</BW_DEV_CLASSES>'.

**********************
*** InfoAreas List ***
**********************
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_AREA_LIST>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'INFOAREA'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'OWNER'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA_P'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA_C'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA_N'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TSTPNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TIMESTMP'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDAREA'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDAREA.

  SORT LT_RSDAREA BY INFOAREA OWNER INFOAREA_P INFOAREA_C INFOAREA_N
  TSTPNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDAREA
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDAREA
                                  USING  G_IREF_PDOCUMENT
                                        'RSDAREA'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDAREA.
  PERFORM APPEND_STRING_TO_FILE USING '</INFO_AREA_LIST>'.

*** Get Info Area Text
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_AREA_LIST_TEXT>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDAREAT'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDAREA_TXT.

  SORT LT_RSDAREA_TXT BY INFOAREA LANGU TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDAREA_TXT COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDAREA_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSDAREAT'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDAREA_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_AREA_LIST_TEXT>'.

ENDFORM.                    " extract_connection_to_hier
*&---------------------------------------------------------------------*
*&      Form  extract_info_providers
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_INFO_PROVIDERS.
  DATA:  LT_RSTRAN              TYPE TABLE OF TY_RSTRAN,
         LT_RSUPDINFO           TYPE TABLE OF TY_RSUPDINFO,
         LT_RSDCUBE             TYPE TABLE OF TY_RSDCUBE,
         LT_RSDCUBE_TXT         TYPE TABLE OF TY_RSDCUBE_TXT,
         LT_RSDIOBJ             TYPE TABLE OF TY_RSDIOBJ,
         LT_RSDIOBJ_TXT         TYPE TABLE OF TY_RSDIOBJ_TXT,
         LT_RSDODSO             TYPE TABLE OF TY_RSDODSO,
         LT_RSDODSO_TXT         TYPE TABLE OF TY_RSDODSO_TXT,
         LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
         LT_FIELDS              TYPE TABLE OF RFC_DB_FLD,
         LT_RSDCHABAS           TYPE TABLE OF TY_RSDCHABAS.

  DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
        LS_FIELDS              TYPE RFC_DB_FLD.

  PERFORM APPEND_STRING_TO_FILE USING '<CONNECTED_BY_TRANSFORMATIONS>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'TRANID'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'SOURCETYPE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'SOURCENAME'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TARGETTYPE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TARGETNAME'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSTRAN'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSTRAN.

  SORT LT_RSTRAN BY TARGETTYPE TARGETNAME SOURCENAME ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSTRAN
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSTRAN
                                  USING  G_IREF_PDOCUMENT
                                        'RSTRAN'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSTRAN.

  PERFORM APPEND_STRING_TO_FILE USING '</CONNECTED_BY_TRANSFORMATIONS>'.

****************************************************
*** Get Info Providers Connected By Update Rules ***
****************************************************
  PERFORM APPEND_STRING_TO_FILE USING '<CONNECTED_BY_UPDATE_RULES>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'UPDID'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOCUBE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'ISOURCE'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSUPDINFO'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSUPDINFO.

  SORT LT_RSUPDINFO BY INFOCUBE ISOURCE ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSUPDINFO
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSUPDINFO
                                  USING  G_IREF_PDOCUMENT
                                        'RSUPDINFO'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSUPDINFO.

  PERFORM APPEND_STRING_TO_FILE USING '</CONNECTED_BY_UPDATE_RULES>'.


*****************************
*** Get InfoProvider Data ***
*****************************
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'INFOAREA'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOCUBE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TSTPNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TIMESTMP'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDCUBE'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDCUBE.

  SORT  LT_RSDCUBE BY INFOAREA INFOCUBE TSTPNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDCUBE
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCUBE
                                  USING  G_IREF_PDOCUMENT
                                        'RSDCUBE'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDCUBE.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES>'.

*** Get Info Providers Text
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES_TEXTS>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOCUBE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDCUBET'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDCUBE_TXT.

  SORT LT_RSDCUBE_TXT BY INFOCUBE TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDCUBE COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCUBE_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSDCUBET'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDCUBE_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES_TEXTS>'.

************************
*** Get Info Objects ***
************************
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS>'.

*** Fill Required Table Fields
*  ls_fields-fieldname = 'IOBJTP'.
*  APPEND ls_fields TO lt_fields.
  LS_FIELDS-FIELDNAME = 'IOBJNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TSTPNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TIMESTMP'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  LS_OPTIONS-TEXT = 'AND IOBJTP = ''CHA'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDIOBJ'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDIOBJ.

  SORT LT_RSDIOBJ BY IOBJNM TSTPNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDIOBJ
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDIOBJ
                                  USING  G_IREF_PDOCUMENT
                                        'RSDIOBJ'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDIOBJ.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS>'.

*** Get Info Objects Text
  PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS_TEXTS>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'IOBJNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .
  LS_OPTIONS-TEXT = 'AND LANGU = ''E'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDIOBJT'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDIOBJ_TXT.

  SORT LT_RSDIOBJ_TXT BY IOBJNM LANGU TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDIOBJ_TXT COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDIOBJ_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSDIOBJT'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDIOBJ_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS_TEXTS>'.

*********************************
*** Get Info Objects Add Data ***
*********************************

  PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS_ADD_DATA>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'CHABASNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'APPLNM'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDCHABAS'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDCHABAS.

  SORT LT_RSDCHABAS BY CHABASNM INFOAREA APPLNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDCHABAS
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCHABAS
                                  USING  G_IREF_PDOCUMENT
                                        'RSDCHABAS'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDCHABAS.

  PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS_ADD_DATA>'.
************************
*** Extract DSO Data ***
************************
  PERFORM APPEND_STRING_TO_FILE USING '<DSO_DATA>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'ODSOBJECT'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'ODSOTYPE'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'INFOAREA'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TSTPNM'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TIMESTMP'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDODSO'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDODSO.

  SORT LT_RSDODSO BY ODSOBJECT ODSOTYPE INFOAREA TSTPNM ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDODSO
  COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDODSO
                                  USING  G_IREF_PDOCUMENT
                                        'RSDODSO'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDODSO.

  PERFORM APPEND_STRING_TO_FILE USING '</DSO_DATA>'.

*** Get Info Objects Text
  PERFORM APPEND_STRING_TO_FILE USING '<DSO_DATA_TEXTS>'.

*** Fill Required Table Fields
  LS_FIELDS-FIELDNAME = 'ODSOBJECT'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'LANGU'.
  APPEND LS_FIELDS TO LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'TXTLG'.
  APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
  LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
  APPEND LS_OPTIONS TO LT_OPTIONS .

  PERFORM RFC_READ_TABLE USING   'RSDODSOT'
                                 P_BW_RFC
                                 LT_OPTIONS
                                 LT_FIELDS
                        CHANGING LT_RSDODSO_TXT.

  SORT LT_RSDODSO_TXT BY LANGU TXTLG ASCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_RSDODSO_TXT COMPARING ALL FIELDS.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDODSO_TXT
                                  USING  G_IREF_PDOCUMENT
                                        'RSDODSOT'.

  CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
  FREE: LT_RSDODSO_TXT.

  PERFORM APPEND_STRING_TO_FILE USING '</DSO_DATA_TEXTS>'.

ENDFORM.                    " extract_info_providers

**********************************************************************
* Form add_enhancements_data
**********************************************************************
* Select the enhancements data and add it to the XML
**********************************************************************
FORM ADD_ENHANCEMENTS_DATA.

  PERFORM UPDATE_PROGRESS
    USING
     'Extracting enhancements data'. "#EC NOTEXT


  PERFORM GET_CLASSIC_BADI_DATA.
  PERFORM GET_ENH_SPOT_DATA.

ENDFORM.                    "add_enhancements_data

**********************************************************************
* get_classic_badi_data
**********************************************************************
* Select and add all data related to classic badis
**********************************************************************
FORM GET_CLASSIC_BADI_DATA.

  DATA:
    LT_SXC_CLASS TYPE STANDARD TABLE OF SXC_CLASS,
    LT_SXC_ATTR  TYPE STANDARD TABLE OF SXC_ATTR,
    LT_SXC_ATTRT TYPE STANDARD TABLE OF SXC_ATTRT,
    LS_OBJ_SXCI  LIKE LINE OF GT_OBJ_SXCI,
    LV_IMPL_NAME TYPE EXIT_IMP,
    LT_IMPL_TAB  TYPE IMP_TABLE_TYPE.

* If no implementations exist, quit
  CHECK GT_OBJ_SXCI[] IS NOT INITIAL.

  LOOP AT GT_OBJ_SXCI INTO LS_OBJ_SXCI.

    LV_IMPL_NAME = LS_OBJ_SXCI-OBJ_NAME.
    APPEND LV_IMPL_NAME TO LT_IMPL_TAB.

  ENDLOOP.

* Add all the classic badi data to the node
  PERFORM ADD_CLASSIC_BADI_TABLE
              TABLES
                 LT_SXC_CLASS
                 LT_IMPL_TAB
              USING
                 'SXC_CLASS'.

  PERFORM GET_SXC_EXIT_DATA TABLES LT_IMPL_TAB.

  PERFORM ADD_CLASSIC_BADI_TABLE
              TABLES
                 LT_SXC_ATTR
                 LT_IMPL_TAB
              USING
                 'SXC_ATTR'.

  PERFORM ADD_CLASSIC_BADI_TABLE
              TABLES
                 LT_SXC_ATTRT
                 LT_IMPL_TAB
              USING
                 'SXC_ATTRT'.

ENDFORM.                    "get_classic_badi_data

**********************************************************************
* add_classic_badi_table
**********************************************************************
* Select data from a table related to classic badis and add it
* to the XML.
**********************************************************************
FORM ADD_CLASSIC_BADI_TABLE TABLES
                              DATA_TAB
                              IMPL_NAME_TAB TYPE IMP_TABLE_TYPE
                            USING IM_TAB_NAME.

  DATA:
    TAB_NODE TYPE REF TO IF_IXML_ELEMENT,
    NODE_NAME TYPE STRING.

  CONCATENATE IM_TAB_NAME '_TAB' INTO NODE_NAME.

* Create an XML node for this table
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                NODE_NAME
                          CHANGING TAB_NODE.

* Get all the customer data from the needed classic badis table
  SELECT  *
    FROM  (IM_TAB_NAME)
    INTO  TABLE DATA_TAB
    FOR   ALL ENTRIES IN IMPL_NAME_TAB
    WHERE IMP_NAME = IMPL_NAME_TAB-TABLE_LINE.

* Add the entire table to the XML
  PERFORM ADD_ITAB_TO_XML_SIMPLE
    TABLES
       DATA_TAB
    USING
       G_IREF_PDOCUMENT
       TAB_NODE
       IM_TAB_NAME.

* Add the node to the generated XML
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                 TAB_NODE 'X'.

ENDFORM.                    "add_classic_badi_table

**********************************************************************
* get_enh_spot_data
**********************************************************************
* Select data about enhancement point and add
* it to the XML
**********************************************************************
FORM GET_ENH_SPOT_DATA.

  DATA:
    LT_ENHHEADER TYPE STANDARD TABLE OF ENHHEADER,
    LS_ENHHEADER LIKE LINE OF LT_ENHHEADER,
    ENH_TOOL_REF TYPE REF TO IF_ENH_TOOL,
    LT_ENHOBJ    TYPE STANDARD TABLE OF ENHOBJ,
    LS_ENHOBJ    TYPE ENHOBJ,
    LT_ENH_NAME  TYPE STANDARD TABLE OF ENHNAME,
    LV_ENH_NAME  TYPE ENHNAME,
    LS_OBJ_ENHO  LIKE LINE OF GT_OBJ_ENHO.

* Create the ENHANCEMENT_SPOTS XML node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'ENHANCEMENT_SPOTS'
                          CHANGING ENH_SPOTS_NODE.

* If no enhancement implementations were found, quit
  CHECK GT_OBJ_ENHO[] IS NOT INITIAL.

  LOOP AT GT_OBJ_ENHO INTO LS_OBJ_ENHO.

    LV_ENH_NAME = LS_OBJ_ENHO-OBJ_NAME.
    APPEND LV_ENH_NAME TO LT_ENH_NAME.

  ENDLOOP.

* Get the customer enhancement spots data,
* for badis and enhancement points only
  SELECT  *
    FROM  ENHHEADER
    INTO  TABLE LT_ENHHEADER
    FOR   ALL ENTRIES IN LT_ENH_NAME
    WHERE ENHNAME = LT_ENH_NAME-TABLE_LINE AND
          ENHTOOLTYPE IN ('BADI_IMPL','HOOK_IMPL').

* If enhancement implementations were found
  IF LT_ENHHEADER[] IS NOT INITIAL.

*   Get the implementation's standard enhancement spot
    SELECT  *
      FROM  ENHOBJ
      INTO  TABLE LT_ENHOBJ
      FOR   ALL ENTRIES IN LT_ENHHEADER
      WHERE ENHNAME = LT_ENHHEADER-ENHNAME AND
            VERSION = LT_ENHHEADER-VERSION AND
            OBJ_TYPE = 'ENHS'.

    SORT LT_ENHOBJ BY ENHNAME ASCENDING.

  ENDIF.

* Go over the implementations
  LOOP AT LT_ENHHEADER
    INTO LS_ENHHEADER.

    CLEAR LS_ENHOBJ.

    TRY.
*     Get the enhancement implementation data
        ENH_TOOL_REF = CL_ENH_FACTORY=>GET_ENHANCEMENT(
            ENHANCEMENT_ID = LS_ENHHEADER-ENHNAME ).

*     Read the implementation's enh. spot
        READ TABLE LT_ENHOBJ
          INTO LS_ENHOBJ
          WITH KEY ENHNAME = LS_ENHHEADER-ENHNAME
          BINARY SEARCH.

*     Add the enhancement as a node to the XML
        PERFORM ADD_ENH_SPOT_HEADER_XML USING
              LS_ENHHEADER ENH_TOOL_REF LS_ENHOBJ.

*     Check the enhancement type, and add it to the XML accordingly
        CASE LS_ENHHEADER-ENHTOOLTYPE.
          WHEN 'BADI_IMPL'.
            PERFORM HANDLE_ENH_SPOT_BADI
              USING LS_ENHHEADER ENH_TOOL_REF.
          WHEN 'HOOK_IMPL'.
            PERFORM HANDLE_ENHANCEMENT_POINT
              USING LS_ENHHEADER ENH_TOOL_REF.
          WHEN OTHERS.
        ENDCASE.

      CATCH CX_ENH_ROOT.
        CONCATENATE
        'Extraction of enhancement implementation data' "#EC NOTEXT
          LS_ENHHEADER-ENHNAME
          'failed.' "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDTRY.
  ENDLOOP.

* Add the enhancement spots to the generated XML
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                 ENH_SPOTS_NODE 'X'.

  FREE GT_OBJ_ENHO.

ENDFORM.                    "get_enh_spot_data

**********************************************************************
* get_sxc_exit_data
**********************************************************************
* Get sxc_exit table data and add it to the XML.
* It wasn't done with the add_classic_badi_table form because
* additional logic and data is required
**********************************************************************
FORM GET_SXC_EXIT_DATA TABLES IMPL_NAME_TAB TYPE IMP_TABLE_TYPE.

  DATA:
    TAB_NODE TYPE REF TO IF_IXML_ELEMENT,
    EXIT_NAME_RANGE TYPE RANGE OF SOBJ_NAME,
    EXIT_NAME_WA LIKE LINE OF EXIT_NAME_RANGE,
    LT_TADIR TYPE TABLE OF TADIR,
    LS_TADIR LIKE LINE OF LT_TADIR.

  DATA BEGIN OF SXC_DEVCLASS.
          INCLUDE TYPE SXC_EXIT.
  DATA DEVCLASS TYPE DEVCLASS.
  DATA END OF SXC_DEVCLASS.

  DATA LT_SXC_DEVCLASS LIKE TABLE OF SXC_DEVCLASS.

  FIELD-SYMBOLS <LS_SXC_EXIT> LIKE SXC_DEVCLASS.

* Create an XML node for this table
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'SXC_EXIT_TAB'
                          CHANGING TAB_NODE.

* Get all the customer implemented badis
  SELECT  *
    FROM  SXC_EXIT
    INTO  TABLE LT_SXC_DEVCLASS
    FOR   ALL ENTRIES IN IMPL_NAME_TAB
    WHERE IMP_NAME = IMPL_NAME_TAB-TABLE_LINE.

* Make a range of the selected badis
  LOOP AT LT_SXC_DEVCLASS ASSIGNING <LS_SXC_EXIT>.

    EXIT_NAME_WA-SIGN = 'I'.
    EXIT_NAME_WA-OPTION = 'EQ'.
    EXIT_NAME_WA-LOW = <LS_SXC_EXIT>-EXIT_NAME.

    APPEND EXIT_NAME_WA TO EXIT_NAME_RANGE.

  ENDLOOP.

* If badis were found, get their development class
  IF EXIT_NAME_RANGE[] IS NOT INITIAL.

    SELECT  PGMID
            OBJECT
            OBJ_NAME
            DEVCLASS
      FROM  TADIR
      INTO  CORRESPONDING FIELDS OF TABLE LT_TADIR
      WHERE PGMID  = 'R3TR' AND
            OBJECT = 'SXSD' AND
            OBJ_NAME IN EXIT_NAME_RANGE.

    SORT LT_TADIR BY OBJ_NAME ASCENDING.

  ENDIF.

* Go over the selected badis and save their dev.class
* in the same table
  LOOP AT LT_SXC_DEVCLASS ASSIGNING <LS_SXC_EXIT>.

    READ TABLE LT_TADIR
      INTO LS_TADIR
      WITH KEY OBJ_NAME = <LS_SXC_EXIT>-EXIT_NAME
      BINARY SEARCH.

    IF SY-SUBRC IS INITIAL.
      <LS_SXC_EXIT>-DEVCLASS = LS_TADIR-DEVCLASS.
    ENDIF.
  ENDLOOP.

* Add the entire table to the XML
* The line prefix was set to SXC_EXIT_DATA and not SXC_EXIT
* because it was already used in form EXTRACT_BADI_IMP
  PERFORM ADD_ITAB_TO_XML_SIMPLE
    TABLES
       LT_SXC_DEVCLASS
    USING
       G_IREF_PDOCUMENT
       TAB_NODE
       'SXC_EXIT_DATA'.

* Add the node to the generated XML
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                 TAB_NODE 'X'.

ENDFORM.                    "get_sxc_exit_data

**********************************************************************
* add_enh_spot_header_xml
**********************************************************************
* Add an enhancement spot's implementation header to the XML
**********************************************************************
FORM ADD_ENH_SPOT_HEADER_XML
    USING HEADER_DATA TYPE ENHHEADER
          ENH_TOOL_REF TYPE REF TO IF_ENH_TOOL
          ENH_OBJ TYPE ENHOBJ.

  DATA: SHORTTEXT TYPE STRING,
        DOCU_OBJ TYPE REF TO IF_ENH_OBJECT_DOCU,
        SPOT_REF TYPE REF TO IF_ENH_SPOT_TOOL,
        SPOT_NAME TYPE ENHSPOTNAME,
        ENH_REF   TYPE REF TO IF_ENH_OBJECT,
        DEVCLASS  TYPE DEVCLASS.

* Create the enhancement spot's XML node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT ENH_SPOTS_NODE
                              'ENHANCEMENT_SPOT'
                        CHANGING ENH_SPOT_NODE.

  DOCU_OBJ ?= ENH_TOOL_REF.
  SHORTTEXT = DOCU_OBJ->GET_SHORTTEXT( ).

* Add the required attributes
  PERFORM ADD_ATTRIBUTE_TO_NODE
    USING: ENH_SPOT_NODE 'ENHNAME' HEADER_DATA-ENHNAME,
           ENH_SPOT_NODE 'VERSION' HEADER_DATA-VERSION,
           ENH_SPOT_NODE 'TYPE' HEADER_DATA-TYPE,
           ENH_SPOT_NODE 'ENHTOOLTYPE' HEADER_DATA-ENHTOOLTYPE,
           ENH_SPOT_NODE 'SHORTTEXT' SHORTTEXT.

  SPOT_NAME = ENH_OBJ-OBJ_NAME.

* If there's an enh. spot definition for this implementation
  IF SPOT_NAME IS NOT INITIAL.

*   Add the spot's name
    PERFORM ADD_ATTRIBUTE_TO_NODE
      USING ENH_SPOT_NODE 'SPOTNAME' SPOT_NAME.

    TRY.

*     Get the spot's instance
        SPOT_REF = CL_ENH_FACTORY=>GET_ENHANCEMENT_SPOT(
          SPOT_NAME ).

        ENH_REF ?= SPOT_REF.

*     Get the spot's development class
        DEVCLASS = ENH_REF->GET_DEVCLASS( ).

*     Add the development class to the xml
        PERFORM ADD_ATTRIBUTE_TO_NODE
          USING ENH_SPOT_NODE 'DEVCLASS' DEVCLASS.

      CATCH CX_ROOT.
    ENDTRY.

  ENDIF.

ENDFORM.                    "add_enh_spot_header_xml

**********************************************************************
* handle_enh_spot_badi
**********************************************************************
* Add badis data to the XML
**********************************************************************
FORM HANDLE_ENH_SPOT_BADI USING
      HEADER_DATA TYPE ENHHEADER
      ENH_REF TYPE REF TO IF_ENH_TOOL.

  DATA:
    BADI_REF TYPE REF TO CL_ENH_TOOL_BADI_IMPL,
    LT_BADI TYPE ENH_BADI_IMPL_DATA_IT,
    LS_BADI LIKE LINE OF LT_BADI,
    BADI_NODE TYPE REF TO IF_IXML_ELEMENT.

  BADI_REF ?= ENH_REF.

* Get the spot's implemented badis
  LT_BADI = BADI_REF->GET_IMPLEMENTATIONS( HEADER_DATA-VERSION ).

* Go over the badis
  LOOP AT LT_BADI INTO LS_BADI.

*   Create an XML node for each badi
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT ENH_SPOT_NODE
                              'BADI'
                        CHANGING BADI_NODE.

*   Add the required properties to the node
    PERFORM ADD_ATTRIBUTE_TO_NODE
      USING: BADI_NODE 'SPOT_NAME' LS_BADI-SPOT_NAME,
             BADI_NODE 'BADI_NAME' LS_BADI-BADI_NAME,
             BADI_NODE 'IMPL_NAME' LS_BADI-IMPL_NAME,
             BADI_NODE 'IMPL_CLASS' LS_BADI-IMPL_CLASS,
             BADI_NODE 'ACTIVE' LS_BADI-ACTIVE,
             BADI_NODE 'IMPL_SHORTTEXT' LS_BADI-IMPL_SHORTTEXT.

  ENDLOOP.

ENDFORM.                    "handle_enh_spot_badi

**********************************************************************
* handle_enhancement_point
**********************************************************************
* Add enhancement point's data to the XML
**********************************************************************
FORM HANDLE_ENHANCEMENT_POINT USING
      HEADER_DATA TYPE ENHHEADER
      ENH_REF TYPE REF TO IF_ENH_TOOL.

  DATA:
    ENH_POINT_REF TYPE REF TO CL_ENH_TOOL_HOOK_IMPL,
    LT_HOOKS TYPE ENH_HOOK_IMPL_IT,
    LS_HOOKS LIKE LINE OF LT_HOOKS,
    SPOT_NODE TYPE REF TO IF_IXML_ELEMENT,
    CDATA_NODE TYPE REF TO IF_IXML_ELEMENT,
    SOURCE_STR TYPE STRING,
    LS_SOURCE TYPE STRING,
    IS_FIRST TYPE FLAG,
    INCLUDE_NAME TYPE PROGRAM.

  ENH_POINT_REF ?= ENH_REF.

* Get the spot's implemented enhancement points
  LT_HOOKS = ENH_POINT_REF->GET_HOOK_IMPLS( HEADER_DATA-VERSION ).

* Go over the enh. points
  LOOP AT LT_HOOKS
    INTO LS_HOOKS.

*   Create an XML node for each point
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT ENH_SPOT_NODE
                              'ENHANCEMENT_POINT'
                        CHANGING SPOT_NODE.

*   Get the name of the include file that contains the enh. spot
    CALL FUNCTION 'GET_SOURCE_NAME_FROM_FULL_NAME'
      EXPORTING
        FULL_NAME   = LS_HOOKS-FULL_NAME
        PROGRAM     = LS_HOOKS-PROGRAMNAME
      IMPORTING
        SOURCE_NAME = INCLUDE_NAME.

*   Add the needed properties
    PERFORM ADD_ATTRIBUTE_TO_NODE
      USING: SPOT_NODE 'SPOTNAME' LS_HOOKS-SPOTNAME,
             SPOT_NODE 'PROGRAMNAME' LS_HOOKS-PROGRAMNAME,
             SPOT_NODE 'FULL_NAME' LS_HOOKS-FULL_NAME,
             SPOT_NODE 'INCLUDE_NAME' INCLUDE_NAME.

*   Go over the point's code and add it to a single string
    LOOP AT LS_HOOKS-SOURCE INTO LS_SOURCE.

      REPLACE ALL OCCURRENCES OF ']]>' IN LS_SOURCE
        WITH CDATA_END_REPLACE.
      REPLACE '?XML' IN LS_SOURCE WITH '&XML_START_TAG&'.
      REPLACE '?xml' IN LS_SOURCE WITH '&XML_START_TAG&'.

      IF IS_FIRST IS INITIAL.
        IS_FIRST = 'X'.
        SOURCE_STR = LS_SOURCE.
      ELSE.
        CONCATENATE SOURCE_STR LS_SOURCE INTO SOURCE_STR
          SEPARATED BY GV_ENDLINE.
      ENDIF.

    ENDLOOP.

*   Add the code to the point's node
    PERFORM CREATE_XML_NODE_VALUE_CDATA
                USING
                    G_IREF_PDOCUMENT
                    SPOT_NODE
                    'CODE'
                    SOURCE_STR
                    ABAP_TRUE
                CHANGING
                    CDATA_NODE.

  ENDLOOP.

ENDFORM.                    "handle_enhancement_point

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_AREA_MENUS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_AREA_MENUS.

  DATA: TTREE_ITAB TYPE TABLE OF TTREE,
        TTREE_LINE LIKE LINE OF TTREE_ITAB.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  RANGES: R_OBJ_SHI3 FOR TTREE-ID.

  FIELD-SYMBOLS: <OBJ_SHI3> LIKE LINE OF GT_OBJ_SHI3.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Area Menus'. "#EC NOTEXT

  CHECK NOT GT_OBJ_SHI3[] IS INITIAL.

  LOOP AT GT_OBJ_SHI3 ASSIGNING <OBJ_SHI3>.
    CLEAR R_OBJ_SHI3.
    R_OBJ_SHI3-SIGN = 'I'.
    R_OBJ_SHI3-OPTION = 'EQ'.
    R_OBJ_SHI3-LOW = <OBJ_SHI3>-OBJ_NAME.
    APPEND R_OBJ_SHI3.
  ENDLOOP.

  SELECT ID
  FROM TTREE
  INTO CORRESPONDING FIELDS OF TABLE TTREE_ITAB
  FOR ALL ENTRIES IN R_OBJ_SHI3
  WHERE ID = R_OBJ_SHI3-LOW
  AND   TYPE = 'BMENU'.

  PERFORM APPEND_STRING_TO_FILE USING '<AREA_MENUS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TTREE_ITAB
                                 USING G_IREF_PDOCUMENT
                                       'TTREE'.
  PERFORM APPEND_STRING_TO_FILE USING '</AREA_MENUS>'.

  FREE: GT_OBJ_SHI3.

  PERFORM ADD_TIME_STAT USING
      'Extract Area Menus' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_AREA_MENUS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_VOFM_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_VOFM_USER_EXITS.

  TYPES: BEGIN OF T_VOFM,
            GRPZE  TYPE CHAR4,
            DDTEXT TYPE DDTEXT,
            GRPNO  TYPE NUMC3,
            KAPPL  TYPE CHAR2,
            BEZEI  TYPE CHAR20,
         END OF T_VOFM.

  DATA: LT_VOFM  TYPE TABLE OF T_VOFM,
        LT_TFRM  TYPE TABLE OF TFRM,
        LS_TFRM  TYPE TFRM,
        LT_DOM_V TYPE TABLE OF RPY_DVAL,
        LS_DOM_V TYPE RPY_DVAL.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  FIELD-SYMBOLS: <VOFM> TYPE T_VOFM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting VOFM User Exits'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<VOFM_USER_EXITS>'.

* Get VOFM User Exits
  SELECT * FROM TFRM
  INTO TABLE LT_TFRM
  WHERE AKTIV = 'X'   " Only Active
    AND GRPNO >= 600
  ORDER BY PRIMARY KEY.

  SELECT * FROM TFRM
  APPENDING TABLE LT_TFRM
  WHERE GRPZE = 'PSTK'
    AND GRPNO >= 50
    AND AKTIV = 'X'   " Only Active
  ORDER BY PRIMARY KEY.

  DELETE LT_TFRM
    WHERE GRPZE = 'MCQ1'
    AND ( GRPNO = 601 OR
          GRPNO = 602 OR
          GRPNO = 603 OR
          GRPNO = 604 OR
          GRPNO = 605 OR
          GRPNO = 606 OR
          GRPNO = 607 OR
          GRPNO = 700 OR
          GRPNO = 701 OR
          GRPNO = 702 OR
          GRPNO = 703 OR
          GRPNO = 704 OR
          GRPNO = 705 OR
          GRPNO = 710 ).

  IF LT_TFRM[] IS NOT INITIAL.

*   Get texts
    SELECT GRPZE GRPNO BEZEI FROM TFRMT
    INTO CORRESPONDING FIELDS OF TABLE LT_VOFM
    FOR ALL ENTRIES IN LT_TFRM
    WHERE GRPZE = LT_TFRM-GRPZE
      AND GRPNO = LT_TFRM-GRPNO
      AND SPRAS = SY-LANGU.

    SORT LT_VOFM BY GRPZE ASCENDING GRPNO ASCENDING.

    IF SY-SUBRC = 0.

*     Get domain texts
      CALL FUNCTION 'RPY_DOMAIN_READ'
        EXPORTING
          DOMA_NAME        = 'GRPZE'
        TABLES
          DOMA_VALUES      = LT_DOM_V
        EXCEPTIONS
          CANCELLED        = 1
          NOT_FOUND        = 2
          PERMISSION_ERROR = 3
          ILLEGAL_TYPE     = 4
          OTHERS           = 5.

      IF SY-SUBRC <> 0.
        CASE SY-SUBRC.
          WHEN 1. ERROR = 'CANCELLED'.
          WHEN 2. ERROR = 'NOT_FOUND'.
          WHEN 3. ERROR = 'PERMISSION_ERROR'.
          WHEN 4. ERROR = 'ILLEGAL_TYPE'.
          WHEN 5. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'Extract VOFM: RPY_DOMAIN_READ of GRPZE.' "#EC NOTEXT
                  'ERROR:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED
                  BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      ELSE.

        LOOP AT LT_VOFM ASSIGNING <VOFM>.
          READ TABLE LT_TFRM INTO LS_TFRM WITH KEY GRPZE = <VOFM>-GRPZE
                                                   GRPNO = <VOFM>-GRPNO.
          IF SY-SUBRC = 0.
            <VOFM>-KAPPL = LS_TFRM-KAPPL.
          ENDIF.

          READ TABLE LT_DOM_V INTO LS_DOM_V
                              WITH KEY DOMVALUE_L = <VOFM>-GRPZE.
          IF SY-SUBRC = 0.
            <VOFM>-DDTEXT = LS_DOM_V-DDTEXT.
          ENDIF.
        ENDLOOP.

        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_VOFM
                                        USING  G_IREF_PDOCUMENT
                                               'VOFM'.
      ENDIF.
    ENDIF.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</VOFM_USER_EXITS>'.

  PERFORM ADD_TIME_STAT
    USING 'Extract VOFM User Exits' "#EC NOTEXT
        L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_VOFM_USER_EXITS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BTE_USER_EXITS.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting BTE User Exits'. "#EC NOTEXT

* Add the customer & standard workflow tables with usage
  PERFORM APPEND_STRING_TO_FILE USING '<BTE_USER_EXITS>'.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES GT_BTE_UE
                                  USING G_IREF_PDOCUMENT
                                        'BTE'.

  PERFORM APPEND_STRING_TO_FILE USING '</BTE_USER_EXITS>'.
  FREE GT_BTE_UE.
  PERFORM ADD_TIME_STAT
  USING 'Extract BTE User Exits' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_BTE_USER_EXITS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_SALES_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_SALES_USER_EXITS.

  DATA: LT_SMODILOG TYPE TABLE OF SMODILOG,
        LT_TEMP TYPE TABLE OF TADIR.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting Sales User Exits'. "#EC NOTEXT

  SELECT OBJ_NAME FROM TADIR
  INTO CORRESPONDING FIELDS OF TABLE LT_TEMP
  WHERE PGMID = 'R3TR'
  AND OBJECT = 'PROG'
  AND DEVCLASS = 'VMOD'.

  CHECK NOT LT_TEMP[] IS INITIAL.

  PERFORM APPEND_STRING_TO_FILE USING '<SALES_USER_EXITS>'.

* Get Sales User Exits
  SELECT OBJ_NAME INT_NAME FROM SMODILOG PACKAGE SIZE PAC_SIZE
  INTO CORRESPONDING FIELDS OF TABLE LT_SMODILOG
  FOR ALL ENTRIES IN LT_TEMP
  WHERE OBJ_NAME = LT_TEMP-OBJ_NAME
  AND OBJ_TYPE = 'PROG'
  AND SUB_TYPE = 'REPS'
  AND INT_TYPE = 'PU'.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SMODILOG
                                    USING  G_IREF_PDOCUMENT
                                    'SALES_UE'.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</SALES_USER_EXITS>'.

  PERFORM ADD_TIME_STAT USING 'Extract Sales User Exits' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_SALES_USER_EXITS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_BADI_IMP
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BADI_IMP.

  DATA: LT_SXC_EXIT TYPE TABLE OF SXC_EXIT.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  RANGES: R_SXCI FOR SXC_EXIT-IMP_NAME.

  FIELD-SYMBOLS: <OBJ_SXCI> LIKE LINE OF GT_OBJ_SXCI.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting BADI implementations'. "#EC NOTEXT

  CHECK NOT GT_OBJ_SXCI[] IS INITIAL.

  LOOP AT GT_OBJ_SXCI ASSIGNING <OBJ_SXCI>.
    CLEAR R_SXCI.
    R_SXCI-SIGN = 'I'.
    R_SXCI-OPTION = 'EQ'.
    R_SXCI-LOW = <OBJ_SXCI>-OBJ_NAME.
    APPEND R_SXCI.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<BADI_IMPLEMENTATIONS>'.

* Get BADI implementations
  SELECT IMP_NAME EXIT_NAME FROM SXC_EXIT PACKAGE SIZE PAC_SIZE
  INTO CORRESPONDING FIELDS OF TABLE LT_SXC_EXIT
  FOR ALL ENTRIES IN R_SXCI
  WHERE IMP_NAME = R_SXCI-LOW.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXC_EXIT
                                    USING  G_IREF_PDOCUMENT
                                    'SXC_EXIT'.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</BADI_IMPLEMENTATIONS>'.

  PERFORM ADD_TIME_STAT
    USING 'Extract BADI implementations' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_BADI_IMP

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WORKFLOW
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_WORKFLOWS.

  TYPES: BEGIN OF T_WORKFLOW,
          OTYPE TYPE HR_SOTYPE,
          OBJID TYPE HR_SOBJID,
          STEXT TYPE STEXT,
          USAGE TYPE CHAR10,
         END OF T_WORKFLOW.

  DATA: LT_WORKFLOWS  TYPE TABLE OF HRS1000,
        LT_TEMP       TYPE TABLE OF HRS1000,
        LV_USAGE_KEY  TYPE SWW_TASK,
        R_TIME        TYPE SWR_TIMINT,
        LS_FILTER     TYPE SWR_WITYPE,
        LT_FILTER     TYPE TABLE OF SWR_WITYPE,
        LT_WFLW_USAGE TYPE TABLE OF SWR_FREQ,
        LS_WFLW_USAGE TYPE SWR_FREQ.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.



  DATA: LT_STD_WFLW TYPE TABLE OF T_WORKFLOW,
        LT_CST_WFLW TYPE TABLE OF T_WORKFLOW,
        LS_WORKFLOW TYPE T_WORKFLOW.

  FIELD-SYMBOLS: <WORKFLOW> TYPE HRS1000.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Workflows'. "#EC NOTEXT

  CALL FUNCTION 'RH_CHECK_HRS_MACO'
    EXPORTING
      ACT_OTYPE     = 'WS'
    TABLES
      ACT_HRS_DATA  = LT_WORKFLOWS
    EXCEPTIONS
      NO_DATA_FOUND = 1
      OTHERS        = 2.

  CALL FUNCTION 'RH_CHECK_HRS_MACO'
    EXPORTING
      ACT_OTYPE     = 'TS'
    TABLES
      ACT_HRS_DATA  = LT_TEMP
    EXCEPTIONS
      NO_DATA_FOUND = 1
      OTHERS        = 2.

  APPEND LINES OF LT_TEMP TO LT_WORKFLOWS.
  FREE LT_TEMP.

  R_TIME-SIGN = 'I'.
  R_TIME-OPTION = 'BT'.
  R_TIME-LOW = SY-DATUM - 365.
  R_TIME-HIGH = SY-DATUM.

  LS_FILTER-WI_TYPE = 'W'.
  APPEND LS_FILTER TO LT_FILTER.
  LS_FILTER-WI_TYPE = 'B'.
  APPEND LS_FILTER TO LT_FILTER.
  LS_FILTER-WI_TYPE = 'F'.
  APPEND LS_FILTER TO LT_FILTER.

  CALL FUNCTION 'SAP_WAPI_WORKITEMS_BY_FREQUENC'
    EXPORTING
      TIME                     = R_TIME
      SELECTION_STATUS_VARIANT = 0000
    TABLES
      WORKITEM_TYPE_FILTER     = LT_FILTER
      WORKLIST_COMPACT         = LT_WFLW_USAGE.

  SORT LT_WFLW_USAGE BY WI_RH_TASK.

  LOOP AT LT_WORKFLOWS ASSIGNING <WORKFLOW>.
    CLEAR LS_WORKFLOW.
    LS_WORKFLOW-OTYPE = <WORKFLOW>-OTYPE.
    LS_WORKFLOW-OBJID = <WORKFLOW>-OBJID.
    LS_WORKFLOW-STEXT = <WORKFLOW>-STEXT.

    CONCATENATE <WORKFLOW>-OTYPE <WORKFLOW>-OBJID INTO LV_USAGE_KEY.
    READ TABLE LT_WFLW_USAGE INTO LS_WFLW_USAGE
         WITH KEY WI_RH_TASK = LV_USAGE_KEY.
    IF SY-SUBRC = 0.
      LS_WORKFLOW-USAGE = LS_WFLW_USAGE-WI_COUNT.
      SHIFT LS_WORKFLOW-USAGE LEFT DELETING LEADING SPACE.
    ELSE.
      LS_WORKFLOW-USAGE = '0'.
    ENDIF.

*   Customer Workflow
    IF <WORKFLOW>-OBJID > 89999999.
      APPEND LS_WORKFLOW TO LT_CST_WFLW.
*   Standard Workflow with usage
    ELSE.
      IF NOT LS_WORKFLOW-USAGE = '0'.
        APPEND LS_WORKFLOW TO LT_STD_WFLW.
      ENDIF.
    ENDIF.
  ENDLOOP.

* Add the customer & standard workflow tables with usage
  PERFORM APPEND_STRING_TO_FILE USING '<WORKFLOWS>'.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_CST_WFLW
                                  USING G_IREF_PDOCUMENT
                                        'WORKFLOW_CUST'.

  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STD_WFLW
                                  USING G_IREF_PDOCUMENT
                                        'WORKFLOW_STD'.

  PERFORM APPEND_STRING_TO_FILE USING '</WORKFLOWS>'.

  PERFORM ADD_TIME_STAT USING 'Extract Workflows' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_WORKFLOW

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LSMW
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LSMW.

  TYPES: BEGIN OF T_LSMW_OBJ,
          PROJECT         TYPE CHAR15,
          SUBPROJ         TYPE CHAR15,
          OBJECT          TYPE CHAR15,
          OBJECTTYPE      TYPE CHAR2,
          DXOBJ           TYPE CHAR4,
          SUBDX           TYPE CHAR4,
          BUSOBJ          TYPE CHAR10,
          METHOD          TYPE CHAR32,
          MESSTYPE        TYPE CHAR30,
          IDOCTYPE        TYPE CHAR30,
          CIMTYPE         TYPE CHAR30,
          PROGRAMNUMBER   TYPE CHAR8,
          OWNER           TYPE CHAR12,
          X_ONETIME       TYPE CHAR1,
          X_PERIODIC      TYPE CHAR1,
          UNAME           TYPE CHAR12,
          DATUM           TYPE DATUM,
          SYSTEMDEPENDENT TYPE CHAR1,
          EDIDC40         TYPE CHAR1,
         END OF T_LSMW_OBJ.

  DATA:
        TEMP_DD02L TYPE DD02L,
        LT_LSMW_OBJS TYPE TABLE OF T_LSMW_OBJ.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  SELECT SINGLE * FROM DD02L
  INTO TEMP_DD02L
  WHERE TABNAME = '/SAPDMC/LSOATT'.

  CHECK SY-SUBRC IS INITIAL.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting LSMW objects'. "#EC NOTEXT

  SELECT * FROM ('/SAPDMC/LSOATT')
    INTO TABLE LT_LSMW_OBJS.

  PERFORM APPEND_STRING_TO_FILE USING '<LSMW_OBJECTS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LSMW_OBJS
                                  USING G_IREF_PDOCUMENT
                                        'LSMW'.
  PERFORM APPEND_STRING_TO_FILE USING '</LSMW_OBJECTS>'.

  PERFORM ADD_TIME_STAT USING 'Extract LSMW objects' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_LSMW

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_SAP_SCRIPT_FORMS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_SAP_SCRIPT_FORMS.

  DATA: LT_FORM TYPE TABLE OF STXH.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  RANGES: R_FORM FOR STXH-TDNAME.

  FIELD-SYMBOLS: <OBJ_FORM> LIKE LINE OF GT_OBJ_FORM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting SAP Script Forms'. "#EC NOTEXT

  CHECK NOT GT_OBJ_FORM[] IS INITIAL.

  LOOP AT GT_OBJ_FORM ASSIGNING <OBJ_FORM>.
    CLEAR R_FORM.
    R_FORM-SIGN = 'I'.
    R_FORM-OPTION = 'EQ'.
    R_FORM-LOW = <OBJ_FORM>-OBJ_NAME.
    APPEND R_FORM.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<SAP_SCRIPT_FORMS>'.

* Get SAP Screipt Form Definitions
  SELECT TDNAME FROM STXH PACKAGE SIZE PAC_SIZE
  INTO CORRESPONDING FIELDS OF TABLE LT_FORM
  FOR ALL ENTRIES IN R_FORM
  WHERE TDNAME = R_FORM-LOW
  AND TDOBJECT = 'FORM'
  AND TDID = 'DEF'
  AND TDSPRAS = SY-LANGU.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_FORM
                                    USING  G_IREF_PDOCUMENT
                                    'SAP_SCRIPT'.

  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</SAP_SCRIPT_FORMS>'.

  PERFORM ADD_TIME_STAT
    USING 'Extract SAP Script Forms' "#EC NOTEXT
        L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_SAP_SCRIPT_FORMS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LANGUAGES_INSTALLED
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LANGUAGES_INSTALLED.

  TYPES: BEGIN OF T_LANG.
  INCLUDE   TYPE T002.
  TYPES:  SPTXT     TYPE SPTXT,
          CODEPAGE  TYPE CPCODEPAGE,
         END OF T_LANG.

  DATA:
       LT_LANG TYPE TABLE OF T_LANG.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  FIELD-SYMBOLS: <LANG> LIKE LINE OF LT_LANG.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting Languages Installed'. "#EC NOTEXT

  SELECT T~SPRAS T~LASPEZ T~LAHQ T~LAISO FROM T002 AS T
  INNER JOIN TLANIMP AS L ON T~SPRAS = L~SPRAS
  INTO CORRESPONDING FIELDS OF TABLE LT_LANG.

  SORT LT_LANG BY SPRAS.
  DELETE ADJACENT DUPLICATES FROM LT_LANG COMPARING SPRAS.

  LOOP AT LT_LANG ASSIGNING <LANG>.
    SELECT SINGLE SPTXT FROM T002T
    INTO <LANG>-SPTXT
    WHERE SPRAS = SY-LANGU
    AND   SPRSL = <LANG>-SPRAS.

    CALL FUNCTION 'SCP_CODEPAGE_FOR_LANGUAGE'
      EXPORTING
        LANGUAGE    = <LANG>-SPRAS
      IMPORTING
        CODEPAGE    = <LANG>-CODEPAGE
      EXCEPTIONS
        NO_CODEPAGE = 1
        OTHERS      = 2.

    IF SY-SUBRC <> 0.
      CASE SY-SUBRC.
        WHEN 1. ERROR = 'NO_CODEPAGE'.
        WHEN 2. ERROR = 'OTHERS'.
      ENDCASE.

      CONCATENATE 'Extract Languages Installed:' "#EC NOTEXT
                  'SCP_CODEPAGE_FOR_LANGUAGE -' "#EC NOTEXT
                   <LANG>-SPRAS
                  'Error:' ERROR "#EC NOTEXT
                  INTO GT_ETL_MESSAGE-MESSAGE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<LANGUAGES_INSTALLED>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LANG
                                  USING G_IREF_PDOCUMENT
                                        'LANGUAGE'.
  PERFORM APPEND_STRING_TO_FILE USING '</LANGUAGES_INSTALLED>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract Languages Installed' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_LANGUAGES_INSTALLED

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LANDSCAPE_DETAILS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LANDSCAPE_DETAILS.

  DATA:
        LT_LANDSCAPE TYPE TABLE OF TMSCSYS.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting Landscape Details'. "#EC NOTEXT

  SELECT * FROM TMSCSYS "#EC CI_NOFIELD
  INTO TABLE LT_LANDSCAPE
  WHERE INSTNR <> SPACE.

  PERFORM APPEND_STRING_TO_FILE USING '<LANDSCAPE_DETAILS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LANDSCAPE
                                  USING G_IREF_PDOCUMENT
                                        'LANDSCAPE'.
  PERFORM APPEND_STRING_TO_FILE USING '</LANDSCAPE_DETAILS>'.

  PERFORM ADD_TIME_STAT USING
        'Extract Landscape Details' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_LANDSCAPE_DETAILS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_HARDWARE_PLATFORM
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_HARDWARE_PLATFORM.

  TYPES: BEGIN OF T_PARAM,
          PARAMETER_NAME  TYPE SMSYHWINFO-DESCRIPTOR,
          PARAMETER_VALUE TYPE SMSYHWINFO-VALUE_1,
         END OF T_PARAM.

  DATA: LT_TEMP     TYPE TABLE OF SMSYHWINFO,
        LT_HARDWARE TYPE TABLE OF T_PARAM,
        LS_HARDWARE LIKE LINE OF LT_HARDWARE.

  DATA: LV_PROCESS LIKE SY-TVAR0,
        LV_MEMORY  LIKE SY-TVAR0,
        LV_DISK    LIKE SY-TVAR0.

  DATA: LT_DB6INFO TYPE TABLE OF DB6PMDB02,
        LS_DB6INFO TYPE DB6PMDB02,
        LS_ORAINFO TYPE TD110_STRU.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting Hardware Platform'. "#EC NOTEXT

* Get Hardware information
  CALL FUNCTION 'SCSI_GET_HARDWARE_INFO'
    TABLES
      INFO = LT_TEMP.

  LT_HARDWARE[] = LT_TEMP[].

* Add Process, Memory & Disk parameters to Hardware information
  CALL FUNCTION 'SCUI_GET_HARDWARE_DATA'
    IMPORTING
      EV_PROC_NR  = LV_PROCESS
      EV_MEM_ALL  = LV_MEMORY
      EV_DISKSIZE = LV_DISK.

  LS_HARDWARE-PARAMETER_NAME  = 'No. Of processor'. "#EC NOTEXT
  LS_HARDWARE-PARAMETER_VALUE = LV_PROCESS.
  CONDENSE LS_HARDWARE-PARAMETER_VALUE.
  APPEND LS_HARDWARE TO LT_HARDWARE.

  LS_HARDWARE-PARAMETER_NAME  = 'Total memory'. "#EC NOTEXT
  LS_HARDWARE-PARAMETER_VALUE = LV_MEMORY.
  CONDENSE LS_HARDWARE-PARAMETER_VALUE.
  APPEND LS_HARDWARE TO LT_HARDWARE.

  LS_HARDWARE-PARAMETER_NAME  = 'Disk Space'. "#EC NOTEXT
  LS_HARDWARE-PARAMETER_VALUE = LV_DISK.
  CONDENSE LS_HARDWARE-PARAMETER_VALUE.
  APPEND LS_HARDWARE TO LT_HARDWARE.

  CASE SY-DBSYS.
    WHEN 'DB6'.
      CALL FUNCTION 'DB6_HIS_OVERVIEW'
        TABLES
          IT_DB6PMDB02          = LT_DB6INFO
        EXCEPTIONS
          NO_HISTORY_FOUND      = 1
          INVALID_PARAMETER_SET = 2
          ADBC_ERROR            = 3
          SYSTEM_ERROR          = 4
          OTHERS                = 5.
      IF SY-SUBRC <> 0.
        CASE SY-SUBRC.
          WHEN 1. ERROR = 'NO_HISTORY_FOUND'.
          WHEN 2. ERROR = 'INVALID_PARAMETER_SET'.
          WHEN 3. ERROR = 'ADBC_ERROR'.
          WHEN 4. ERROR = 'SYSTEM_ERROR'.
          WHEN 5. ERROR = 'OTHERS'.
        ENDCASE.

        CONCATENATE
        'Extract Hardware Platform - DB6_HIS_OVERVIEW' "#EC NOTEXT
                    'Error:' ERROR "#EC NOTEXT
                    INTO GT_ETL_MESSAGE-MESSAGE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      ELSE.
        READ TABLE LT_DB6INFO INTO LS_DB6INFO INDEX 1.
        IF SY-SUBRC = 0.
          CLEAR LS_HARDWARE.
          LS_HARDWARE-PARAMETER_NAME  =
          'DB Allocated Space'. "#EC NOTEXT
          LS_HARDWARE-PARAMETER_VALUE = LS_DB6INFO-TOTALKB.
          APPEND LS_HARDWARE TO LT_HARDWARE.

          CLEAR LS_HARDWARE.
          LS_HARDWARE-PARAMETER_NAME =
          'DB Free Space'. "#EC NOTEXT
          LS_HARDWARE-PARAMETER_VALUE = LS_DB6INFO-FREEKB.
          APPEND LS_HARDWARE TO LT_HARDWARE.
        ENDIF.
      ENDIF.

  ENDCASE.

  PERFORM APPEND_STRING_TO_FILE USING '<HARDWARE_PLATFORM>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_HARDWARE
                                  USING G_IREF_PDOCUMENT
                                        'HARDWARE_PARAM'.
  PERFORM APPEND_STRING_TO_FILE USING '</HARDWARE_PLATFORM>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract Hardware Platform' "#EC NOTEXT
    L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_HARDWARE_PLATFORM

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_GATEWAY_CONNECTIONS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_GATEWAY_CONNECTIONS.

  DATA:
        LT_GATEWAY  TYPE TABLE OF GWY_CONN,

        LV_HOST   TYPE GWY_LHOST,
        LV_SERV   TYPE GWY_SERV,
        LV_SYSTEM TYPE CHAR2.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting Gateway Connections'. "#EC NOTEXT

* Get Host&Server Parameters
  CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'SAPLOCALHOST'
                     ID 'VALUE' FIELD LV_HOST.

  IF SY-SUBRC <> 0.
    ERROR = SY-SUBRC.
    CONCATENATE
    'Extract Gateway connections - Getting Host Param.' "#EC NOTEXT
                'SY-SUBRC:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
                SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDIF.

  CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'SAPSYSTEM'
                     ID 'VALUE' FIELD LV_SYSTEM.

  IF SY-SUBRC <> 0.
    ERROR = SY-SUBRC.
    CONCATENATE
    'Extract Gateway connections - Getting System Param.' "#EC NOTEXT
                'SY-SUBRC:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
                SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ELSE.
    LV_SERV   = 'sapgw'. "#EC NOTEXT
    LV_SERV+5 = LV_SYSTEM.
  ENDIF.

  CALL FUNCTION 'GWY_READ_CONNECTIONS'
    EXPORTING
      GWHOST                    = LV_HOST
      GWSERV                    = LV_SERV
    TABLES
      CONNECTIONS               = LT_GATEWAY
    EXCEPTIONS
      GWY_UNKNOWN_OPCODE        = 1
      GWY_COMMUNICATION_FAILURE = 2
      GWY_GET_TAB_FAILED        = 3
      GWY_NEWLINE_FAILED        = 4
      GWY_TABLEN_TOO_SHORT      = 5
      GWY_GET_OPCODE_FAILED     = 6
      GWY_GET_GWHOST_FAILED     = 7
      GWY_GET_GWSERV_FAILED     = 8
      GWY_MONITOR_DISABLED      = 9
      OTHERS                    = 10.

  IF SY-SUBRC <> 0.
    CASE SY-SUBRC.
      WHEN 1.  ERROR = 'GWY_UNKNOWN_OPCODE'.
      WHEN 2.  ERROR = 'GWY_COMMUNICATION_FAILURE'.
      WHEN 3.  ERROR = 'GWY_GET_TAB_FAILED'.
      WHEN 4.  ERROR = 'GWY_NEWLINE_FAILED'.
      WHEN 5.  ERROR = 'GWY_TABLEN_TOO_SHORT'.
      WHEN 6.  ERROR = 'GWY_GET_OPCODE_FAILED'.
      WHEN 7.  ERROR = 'GWY_GET_GWHOST_FAILED'.
      WHEN 8.  ERROR = 'GWY_GET_GWSERV_FAILED'.
      WHEN 9.  ERROR = 'GWY_MONITOR_DISABLED'.
      WHEN 10. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'Extract Gateway connections - GWY_READ_CONNECTIONS:' "#EC NOTEXT
                'Host:' LV_HOST 'Serv:' "#EC NOTEXT
                LV_SERV 'Error:' ERROR "#EC NOTEXT
                INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ELSE.

    PERFORM APPEND_STRING_TO_FILE USING '<GATEWAY_CONNECTIONS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_GATEWAY
                                    USING G_IREF_PDOCUMENT
                                          'GWY_CONN'.
    PERFORM APPEND_STRING_TO_FILE USING '</GATEWAY_CONNECTIONS>'.

  ENDIF.

  PERFORM ADD_TIME_STAT USING 'Extract Gateway Connections' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_GATEWAY_CONNECTIONS

*&---------------------------------------------------------------------*
*&      Form  get_rfc_list
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_RFC_LIST.

  DATA : LT_RFCDES     TYPE STANDARD TABLE OF RFCDES,
         LS_RFCDES     TYPE RFCDES,
         LS_RFCDISPLAY TYPE RFCDISPLAY.

  CLEAR : GT_RFCS[].

  SELECT *
  FROM RFCDES BYPASSING BUFFER
  INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
  WHERE RFCTYPE = '3'.

  IF SY-SUBRC = 0.

    LOOP AT LT_RFCDES INTO LS_RFCDES.

      CLEAR LS_RFCDISPLAY.
      CALL FUNCTION 'RFCDES2RFCDISPLAY'
        EXPORTING
          IMPORT_RFCDES           = LS_RFCDES
*         AUTHORITY_CHECK         = ' '
        IMPORTING
          EXPORT_RFCDISPLAY       = LS_RFCDISPLAY
        EXCEPTIONS
          FORMAT_ERROR            = 1
          AUTHORITY_NOT_AVAILABLE = 2
          OTHERS                  = 3.

      IF SY-SUBRC <> 0.
      ELSE.
        APPEND LS_RFCDISPLAY TO GT_RFCS.
      ENDIF.

    ENDLOOP.
  ENDIF.

ENDFORM.                    " get_rfc_list

*&---------------------------------------------------------------------*
*&      Form  add_rfcs_list
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM ADD_RFCS_LIST.

  DATA: LT_RFC_LIST_NODE TYPE XML_ELEMENT.

  IF NOT GT_RFCS[] IS INITIAL.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'RFC_LIST'
                            CHANGING LT_RFC_LIST_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_RFCS
                                   USING G_IREF_PDOCUMENT
                                         LT_RFC_LIST_NODE
                                         'RFC'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LT_RFC_LIST_NODE 'X'.
    FREE GT_RFCS.
  ENDIF.

ENDFORM.                    " add_rfcs_list

*&---------------------------------------------------------------------*
*&      Form  extract_system_parameters
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_SYSTEM_PARAMETERS .
  TYPES: BEGIN OF TY_SYSTEM_PARAMETER,
          PARAMETER_NAME TYPE TPFET-PARNAME,
          PARAMETER_VALUE TYPE TPFET-PVALUE,
         END OF TY_SYSTEM_PARAMETER.

  DATA : LT_SYS_PARAMS      TYPE STANDARD TABLE OF TY_SYSTEM_PARAMETER,
         LS_SYS_PARAMS      LIKE LINE OF LT_SYS_PARAMS,
         LT_SYS_PARAMS_OUT  TYPE STANDARD TABLE OF TY_SYSTEM_PARAMETER.
  DATA : LV_SYS_PARAMS_NODE TYPE XML_ELEMENT.

* Set RZ11 / RZ10 system parameters names to be extracted
  LS_SYS_PARAMS-PARAMETER_NAME = 'auth/tcodes_not_checked'. "#EC NOTEXT
  APPEND LS_SYS_PARAMS TO LT_SYS_PARAMS.

* Get parameters values
  LOOP AT LT_SYS_PARAMS INTO LS_SYS_PARAMS.
*   Get system parameter value
    CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LS_SYS_PARAMS-PARAMETER_NAME
                       ID 'VALUE' FIELD LS_SYS_PARAMS-PARAMETER_VALUE.

    IF SY-SUBRC = 0.
      APPEND LS_SYS_PARAMS TO LT_SYS_PARAMS_OUT.
    ENDIF.
  ENDLOOP.

* Set parameters data to ETL file
  IF NOT LT_SYS_PARAMS_OUT[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'SYSTEM_PARAMETERS'
                            CHANGING LV_SYS_PARAMS_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_SYS_PARAMS_OUT
                                   USING G_IREF_PDOCUMENT
                                         LV_SYS_PARAMS_NODE
                                         'SYSTEM_PARAMETER'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_SYS_PARAMS_NODE 'X'.
  ENDIF.
ENDFORM.                    " extract_system_parameters

*&---------------------------------------------------------------------*
*&      Form  get_sm_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_SM_DATA .

  DATA : LT_TAB512 TYPE STANDARD TABLE OF TAB512,
         LV_FAILED TYPE FLAG,
         LV_STRING TYPE STRING.
  DATA : LV_SM_DATA_NODE TYPE XML_ELEMENT,
         LV_SM_SYSTEM_NODE TYPE XML_ELEMENT.
* Solution manager data
  DATA : LT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T,
         LT_SMSY_SYSTEM_SAP TYPE SMSY_SYSTEM_SAP_T,
         LT_SMSY_SYST_CLIENT TYPE SMSY_SYST_CLIENT_T,
         LT_SMSY_SYS_RELINST_FINAL TYPE SMSY_SYS_RELINST_T,
         LT_SMSY_MAIN_INST_FINAL TYPE SMSY_MAIN_INST_SYST_T,
         LT_SMSYPROCOM_FINAL TYPE SMSYPROCOM_T,
         LT_PAT03_FINAL TYPE TY_SYST_PAT03_OUT_T,
         LT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T,
         LT_SMSY_PROD_VERS TYPE SMSY_PROD_VERS_T,
         LT_SMSY_PRODUCT TYPE SMSY_PRODUCT_T,
         LT_SM_SYSTEM_PRODUCTS TYPE SM_SYSTEM_PRODUCTS_T,
         LV_SKIP TYPE FLAG VALUE ABAP_FALSE.

* The SM rfc was entered and validated in selection screen
  IF NOT P_SM_RFC IS INITIAL.

    PERFORM READ_SOLMAN_FUNCTIONS TABLES LT_TAB512
                                  USING  P_SM_RFC
                                         ABAP_TRUE
                                  CHANGING LV_FAILED.
    IF NOT LV_FAILED IS INITIAL.
      EXIT.
    ENDIF.

*   Get all systems , sap_systems , system_clients
    READ TABLE LT_TAB512 WITH KEY WA =
    'SMSY_GET_ALL_SYSTEMS_INFO'
    TRANSPORTING NO FIELDS.

    IF SY-SUBRC IS INITIAL.

      PERFORM READ_SMSY_SYSTEMS
      USING  P_SM_RFC
      CHANGING LV_FAILED
               LT_SMSY_SYSTEM
               LT_SMSY_SYSTEM_SAP
               LT_SMSY_SYST_CLIENT.

      IF LT_SMSY_SYSTEM[] IS INITIAL.
*       Message no systems extracted from Solution manager
        CONCATENATE 'SM No systems are defined in' "#EC NOTEXT
        P_SM_RFC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
        LV_FAILED = ABAP_TRUE.
      ENDIF.
    ELSE.
      "Message - function doesnt exist in SM
      CONCATENATE
'SM Function SMSY_GET_ALL_SYSTEMS_INFO does not exist in' "#EC NOTEXT
      P_SM_RFC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
*      LV_FAILED = ABAP_TRUE.
      LV_SKIP = ABAP_TRUE.
    ENDIF.

    IF LV_FAILED IS INITIAL AND LV_SKIP = ABAP_FALSE.
*     SMSY functions exist in SM - extract SMSY data
*     Create a child node for the sm_data node
      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                    'SM_DATA'
                              CHANGING LV_SM_DATA_NODE.
      PERFORM APPEND_STRING_TO_FILE USING '<SM_DATA>'.

*     Open current SM system xml tag
      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT LV_SM_DATA_NODE
                              'SM_SYSTEM'
                              CHANGING LV_SM_SYSTEM_NODE.
      CONCATENATE '<SM_SYSTEM RFC_DEST="' P_SM_RFC '">'
      INTO LV_STRING.
      PERFORM APPEND_STRING_TO_FILE USING LV_STRING.
      CLEAR : LV_STRING.
    ELSEIF LV_SKIP = ABAP_TRUE.
*     Do not continue unable to read SM Systems data
      EXIT.
    ENDIF.

*   SM systems extracted - Get system leading product
    READ TABLE LT_TAB512 WITH KEY WA =
    'SMSY_GET_RELINST_TO_SYSTEM_RFC' TRANSPORTING NO FIELDS.
    IF SY-SUBRC IS INITIAL AND
       NOT LT_SMSY_SYSTEM[] IS INITIAL.

      PERFORM GET_SYSTEM_LEADING_PRODUCTS
      USING  P_SM_RFC
             LT_SMSY_SYSTEM
      CHANGING LT_SMSY_SYS_RELINST_FINAL.
    ELSE.
*     Message - function doesnt exist in SM
      CONCATENATE
      'SM Function SMSY_GET_RELINST_TO_SYSTEM_RFC' "#EC NOTEXT
      'does not exist in' "#EC NOTEXT
      P_SM_RFC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

*   Get all system installed product instances
    READ TABLE LT_TAB512 WITH KEY WA =
    'SMSY_GET_INST_OF_PRODUCT_RFC' TRANSPORTING NO FIELDS.
    IF SY-SUBRC IS INITIAL AND
       NOT LT_SMSY_SYS_RELINST_FINAL[] IS INITIAL.

      PERFORM READ_SYSTEM_PRODUCTS_INSTANCES
      USING  P_SM_RFC
             LT_SMSY_SYS_RELINST_FINAL
      CHANGING LT_SMSY_MAIN_INST_FINAL.
    ELSE.
*     Message - function doesnt exist in SM
      CONCATENATE
      'SM Function SMSY_GET_INST_OF_PRODUCT_RFC' "#EC NOTEXT
      'does not exist in' "#EC NOTEXT
      P_SM_RFC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

*   Get all systems components / release / patchlevel
    READ TABLE LT_TAB512 WITH KEY WA = 'SMSY_GET_CVERS_INFO_RFC'
    TRANSPORTING NO FIELDS.
    IF SY-SUBRC IS INITIAL AND
       NOT LT_SMSY_SYSTEM[] IS INITIAL.

      PERFORM READ_SYSTEM_COMPONENTS
      USING P_SM_RFC
            LT_SMSY_SYSTEM
      CHANGING LT_SMSYPROCOM_FINAL.
    ELSE.
*     Message - function doesnt exist in SM
      CONCATENATE
      'SM Function SMSY_GET_CVERS_INFO_RFC' "#EC NOTEXT
      'does not exist in' "#EC NOTEXT
      P_SM_RFC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.


*   RFC_READ_TABLE data access
*   Get SMSY OSS system data - table AISYSNR_BUFFER
    PERFORM READ_SYSTEM_OSS_DATA
    USING  P_SM_RFC
    CHANGING LT_AISYSNR_BUFFER.

*   Get SMSY product and product version system data
*   tables : SMSY_PRODUCT , SMSY_PROD_VERS
*   the data of system product version is
*   fetched in the systems call
*   if not use table SMSY_SYST_PRODVR
    PERFORM READ_PRODUCTS
    USING P_SM_RFC
          LT_SMSY_SYSTEM
          LT_AISYSNR_BUFFER
    CHANGING LT_SMSY_PROD_VERS
             LT_SMSY_PRODUCT
             LT_SM_SYSTEM_PRODUCTS.

*   Append SM system data to output file
    PERFORM ADD_SM_DATA_TO_XML
    USING LV_SM_SYSTEM_NODE
          LT_SMSY_SYSTEM
          LT_SMSY_SYSTEM_SAP
          LT_SMSY_SYST_CLIENT
          LT_SM_SYSTEM_PRODUCTS
          LT_SMSY_MAIN_INST_FINAL
          LT_SMSYPROCOM_FINAL
          LT_PAT03_FINAL
          LT_AISYSNR_BUFFER.

*   Close current SM system data segment
    PERFORM APPEND_STRING_TO_FILE USING '</SM_SYSTEM>'.
    CLEAR : LS_RFCDES.

*   Append closing XML tag for SM data segment
    PERFORM APPEND_STRING_TO_FILE USING '</SM_DATA>'.

*   Release SM data global tables - memory consumption
    FREE : LT_SMSY_SYSTEM,
           LT_SMSY_SYSTEM_SAP,
           LT_SMSY_SYST_CLIENT,
           LT_SM_SYSTEM_PRODUCTS,
           LT_SMSY_MAIN_INST_FINAL,
           LT_SMSYPROCOM_FINAL,
           LT_PAT03_FINAL,
           LT_AISYSNR_BUFFER.
  ENDIF.

ENDFORM.                    " get_sm_data

*&---------------------------------------------------------------------*
*&      Form  read_solman_functions
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*      <--P_LT_TAB512  text
*----------------------------------------------------------------------*
FORM READ_SOLMAN_FUNCTIONS
TABLES   CT_TAB512 STRUCTURE TAB512
USING    IV_RFCDEST TYPE RFCDEST
         IV_VALIDATE TYPE FLAG
CHANGING EV_FAILED  TYPE FLAG.

  DATA : LT_RFC_DB_OPT TYPE STANDARD TABLE OF RFC_DB_OPT,
         LS_RFC_DB_OPT LIKE LINE OF LT_RFC_DB_OPT,
         LT_RFC_DB_FLD TYPE STANDARD TABLE OF RFC_DB_FLD,
         LS_RFC_DB_FLD LIKE LINE OF LT_RFC_DB_FLD,
         LV_FUNC       TYPE STRING,
         LV_SUBRC      TYPE C,
         RFC_ERROR     TYPE RFCLOG_D,
         LV_ERR_MSG    TYPE STRING.

* Check solman functions in the rfc system
  CLEAR : LT_RFC_DB_OPT[] , LT_RFC_DB_FLD[] , CT_TAB512[].

* Set functions names to be checked
  CLEAR : LS_RFC_DB_OPT .
  LV_FUNC = 'SMSY_GET_ALL_SYSTEMS_INFO'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  '  OR ' INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

  CLEAR : LS_RFC_DB_OPT.
  LV_FUNC = 'SMSY_GET_RELINST_TO_SYSTEM_RFC'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  '  OR ' INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

  CLEAR : LS_RFC_DB_OPT.
  LV_FUNC = 'SMSY_GET_INST_OF_PRODUCT_RFC'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  '  OR ' INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

  CLEAR : LS_RFC_DB_OPT.
  LV_FUNC = 'SMSY_GET_CVERS_INFO_RFC'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  '  OR ' INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

  CLEAR : LS_RFC_DB_OPT.
  LV_FUNC = 'RSDRI_INFOPROV_READ_RFC'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  '  OR ' INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

  CLEAR : LS_RFC_DB_OPT.
  LV_FUNC = 'SASAP_HIERARCHY_READ'.
  CONCATENATE
  '( FUNCNAME =''' LV_FUNC ''''
  '  AND '
  '  FMODE = ''R'' )'
  INTO LS_RFC_DB_OPT-TEXT.
  APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

*  clear : ls_rfc_db_opt.
*  lv_func = 'SMSY_GET_SYSTEM_PAT03'.
*  concatenate 'FUNCNAME =''' lv_func ''''
*  into ls_rfc_db_opt-text.
*  append ls_rfc_db_opt-text to lt_rfc_db_opt.

* Set field name for validity check
  CONCATENATE 'FUNCNAME' '' INTO LS_RFC_DB_FLD-FIELDNAME.
  APPEND LS_RFC_DB_FLD TO LT_RFC_DB_FLD.

* Check that the fucntions exist in RFC system in TFDIR
  CALL FUNCTION 'RFC_READ_TABLE'
  DESTINATION IV_RFCDEST
    EXPORTING
      QUERY_TABLE                = 'TFDIR'
*     DELIMITER                  = ' '
*     NO_DATA                    = ' '
*     ROWSKIPS                   = 0
*     ROWCOUNT                   = 0
    TABLES
      OPTIONS                    = LT_RFC_DB_OPT
      FIELDS                     = LT_RFC_DB_FLD
      DATA                       = CT_TAB512
   EXCEPTIONS
     TABLE_NOT_AVAILABLE        = 1
     TABLE_WITHOUT_DATA         = 2
     OPTION_NOT_VALID           = 3
     FIELD_NOT_VALID            = 4
     NOT_AUTHORIZED             = 5
     DATA_BUFFER_EXCEEDED       = 6
     SYSTEM_FAILURE             = 7 MESSAGE RFC_ERROR
     COMMUNICATION_FAILURE      = 8 MESSAGE RFC_ERROR
     OTHERS                     = 9.

  IF NOT SY-SUBRC IS INITIAL.
    IF NOT IV_VALIDATE IS INITIAL.
      IF SY-SUBRC = 5.
        "Message - SM rfc user has no auth to read tfdir
        CONCATENATE
'SM SM rfc user has no auth to read TFDIR table dat from' "#EC NOTEXT
        IV_RFCDEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ELSE.
        LV_SUBRC = SY-SUBRC.
        "Message - function doesnt exist in SM
        CONCATENATE 'SM Error reading SM functions from' "#EC NOTEXT
        IV_RFCDEST
        'RC:'
        LV_SUBRC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ENDIF.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      EV_FAILED = ABAP_TRUE.
    ELSE.
      IF SY-SUBRC = 7 OR SY-SUBRC = 8.
        CONCATENATE
        'RFC error for' "#EC NOTEXT
        IV_RFCDEST
        ':'
        RFC_ERROR
        INTO LV_ERR_MSG
        SEPARATED BY SPACE.
      ELSE.
        CONCATENATE
        'Error reading Solution Manager functions from' "#EC NOTEXT
        IV_RFCDEST
        'RC:'
        LV_SUBRC
        INTO LV_ERR_MSG
        SEPARATED BY SPACE.
      ENDIF.
      PERFORM RAISE_ERROR USING LV_ERR_MSG.
      LEAVE TO SCREEN SY-DYNNR.
    ENDIF.
  ENDIF.
ENDFORM.                    " read_solman_functions

*&---------------------------------------------------------------------*
*&      Form  check_sm_rfc_dest
*&---------------------------------------------------------------------*
FORM CHECK_SM_RFC_DEST
USING IV_RFC_DEST TYPE RFCDEST
      IV_VALIDATE TYPE FLAG
CHANGING EV_VALID TYPE FLAG.

  DATA : LV_ERR_MSG     TYPE STRING,
         LT_TAB512      TYPE STANDARD TABLE OF TAB512,
         LT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T,
         IV_AUTH_PROBLEM,
         MESSAGE        TYPE RFCLOG_D.

  CLEAR G_EXTRACT_UPL.

* SM RFC entered
  CHECK NOT IV_RFC_DEST IS INITIAL.

  PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
                                        IV_VALIDATE
                                  CHANGING EV_VALID
                                           SM_SYSID
                                           SM_SAPRL.

* Continue to the solman checks only if the RFC is valid
  CHECK NOT EV_VALID IS INITIAL.

* Check sm functions are available
  PERFORM READ_SOLMAN_FUNCTIONS TABLES LT_TAB512
                                USING  IV_RFC_DEST
                                       IV_VALIDATE
                                CHANGING EV_VALID.

  READ TABLE LT_TAB512
  WITH KEY WA = 'SMSY_GET_ALL_SYSTEMS_INFO'
  TRANSPORTING NO FIELDS.

  IF SY-SUBRC = 0 .

*   Check able to get SMSY systems from SM
    CALL FUNCTION 'SMSY_GET_ALL_SYSTEMS_INFO'
    DESTINATION IV_RFC_DEST
*     EXPORTING
*       NO_KONZS            = ' '
*       IV_SYSTEMTYPE       =
      IMPORTING
        SYSTEMS             = LT_SMSY_SYSTEM
      EXCEPTIONS
        SYSTEM_FAILURE        = 1
        COMMUNICATION_FAILURE = 2.

    IF NOT SY-SUBRC IS INITIAL.
      IF IV_VALIDATE IS INITIAL.
        "Message - function doesnt exist in SM
        CONCATENATE
        'Failed to execute SMSY_GET_ALL_SYSTEMS_INFO in' "#EC NOTEXT
        IV_RFC_DEST
        INTO LV_ERR_MSG SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_ERR_MSG.
        LEAVE TO SCREEN SY-DYNNR.
      ELSE.
        EV_VALID = ABAP_FALSE.
      ENDIF.
    ENDIF.

    IF LT_SMSY_SYSTEM[] IS INITIAL.
      IF IV_VALIDATE IS INITIAL.
        "Message - function doesnt exist in SM
        CONCATENATE
        'No SMSY systems defined in' "#EC NOTEXT
        IV_RFC_DEST
        INTO LV_ERR_MSG SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_ERR_MSG.
        LEAVE TO SCREEN SY-DYNNR.
      ELSE.
        EV_VALID = ABAP_FALSE.
      ENDIF.
    ENDIF.
  ENDIF.
* If there is a valid solman system, then check if there is upl data
* Check that UPL function exists
  IF NOT EXTRACT_UPL_DATA IS INITIAL.
    READ TABLE LT_TAB512 WITH KEY WA =
    'RSDRI_INFOPROV_READ_RFC'
    TRANSPORTING NO FIELDS.

    IF NOT SY-SUBRC IS INITIAL.
      IF IV_VALIDATE IS INITIAL.
        "Message - UPL function doesnt exist in SM
        CONCATENATE
        'Could not read UPL Solution Manager functions in' "#EC NOTEXT
        IV_RFC_DEST
        INTO LV_ERR_MSG SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_ERR_MSG.
        LEAVE TO SCREEN SY-DYNNR.
      ELSE.
        EV_VALID = ABAP_FALSE.
      ENDIF.
    ENDIF.
  ENDIF.


* Check authorization to UPL Data
  PERFORM CHECK_UPL_EXISTENCE USING IV_RFC_DEST
                              CHANGING IV_AUTH_PROBLEM.
  IF IV_AUTH_PROBLEM = 'X'.
    IF IV_VALIDATE IS INITIAL.
      "Message - No authorization to execute UPL function
      CONCATENATE
      'No authorization to execute UPL function in ' "#EC NOTEXT
      IV_RFC_DEST
      INTO LV_ERR_MSG SEPARATED BY SPACE.
      PERFORM RAISE_ERROR USING LV_ERR_MSG.
      LEAVE TO SCREEN SY-DYNNR.
    ELSE.
      EV_VALID = ABAP_FALSE.
    ENDIF.

*   If there is no valid solman system then there is no upl data
    IF EV_VALID = ABAP_FALSE.
      CLEAR G_EXTRACT_UPL.
    ENDIF.
  ENDIF.


  IF EXTRACT_SOLAR_DATA = 'X'.
*   Check if the hierarchy function exists in the destination
    READ TABLE LT_TAB512 WITH KEY WA =
    'SASAP_HIERARCHY_READ'
    TRANSPORTING NO FIELDS.

    IF NOT SY-SUBRC IS INITIAL.
      IF IV_VALIDATE IS INITIAL.
        "Message - UPL function doesnt exist in SM
        CONCATENATE
        'Could not read hierarchy functions ' "#EC NOTEXT
        'for business process in' "#EC NOTEXT
        IV_RFC_DEST
        INTO LV_ERR_MSG SEPARATED BY SPACE.
        PERFORM RAISE_ERROR USING LV_ERR_MSG.
        LEAVE TO SCREEN SY-DYNNR.
      ELSE.
        EV_VALID = ABAP_FALSE.
      ENDIF.
    ELSE.
      PERFORM CHECK_BUSINESS_PROCESS_AUTH USING IV_RFC_DEST
                                          CHANGING IV_AUTH_PROBLEM
                                                   MESSAGE.
      IF IV_AUTH_PROBLEM = 'X'.
        IF IV_VALIDATE IS INITIAL.
          "Message - No authorization to execute UPL function
*        CONCATENATE
*        'No authorization to execute hierarchy function in '
*        IV_RFC_DEST
*        INTO LV_ERR_MSG SEPARATED BY SPACE.
          LV_ERR_MSG = MESSAGE.
          PERFORM RAISE_ERROR USING LV_ERR_MSG.
          LEAVE TO SCREEN SY-DYNNR.
        ELSE.
          EV_VALID = ABAP_FALSE.
        ENDIF.

*     If there is no valid solman system then there is no upl data
        IF EV_VALID = ABAP_FALSE.
          CLEAR G_EXTRACT_UPL.
        ENDIF.
      ENDIF..
    ENDIF.
*   Check the accessibility for all of the tables of solman

    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TOBJECTP' IV_RFC_DEST.
    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'BMTNODE01R' IV_RFC_DEST.
    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'BMTNODE01' IV_RFC_DEST.
    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'DFURLS' IV_RFC_DEST.
    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGS_TBOM_HEAD'
    IV_RFC_DEST.
    PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGS_TBOM_BASE'
    IV_RFC_DEST.
  ENDIF.
ENDFORM.                    " check_sm_rfc_dest

*&---------------------------------------------------------------------*
*&      Form  check_rfc_dest_existance
*&---------------------------------------------------------------------*
FORM CHECK_RFC_DEST_EXISTANCE .

  DATA: RFC_ERROR TYPE RFCLOG_D,
        ERR_MSG TYPE STRING,
        AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
        OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        TABLE_SIZE LIKE  SY-TFILL,
        MSG1 TYPE RFCLOG_D,
        MSG2 TYPE RFCLOG_D,
        MSG3 TYPE RFCLOG_D,
        MSG4 TYPE STRING,
        SELECTED,
        T000_ITAB TYPE TABLE OF T000,
        T000_REC LIKE T000,
        IS_PROD,
        SUBRC_STR TYPE STRING.

  CALL FUNCTION 'RFC_READ_R3_DESTINATION'
    EXPORTING
      DESTINATION             = P_RFCDES
    IMPORTING
      CLIENT                  = RFC_MANDT
      USER                    = RFC_USER
    EXCEPTIONS
      AUTHORITY_NOT_AVAILABLE = 1
      DESTINATION_NOT_EXIST   = 2
      INFORMATION_FAILURE     = 3
      INTERNAL_FAILURE        = 4
      OTHERS                  = 5.

  IF SY-SUBRC <> 0.
    SUBRC_STR = SY-SUBRC.
    CONCATENATE 'RFC destination' P_RFCDES "#EC NOTEXT
      'does not exist or is not R/3 connection. Subrc: ' "#EC NOTEXT
      SUBRC_STR
      INTO ERR_MSG
      SEPARATED BY SPACE.
    PERFORM RAISE_ERROR USING ERR_MSG.
  ENDIF.

* Check that the client in the RFC system is not '000'
  IF RFC_MANDT = '000'.
    CONCATENATE 'The client of the RFC destination' P_RFCDES "#EC NOTEXT
    INTO MSG1 SEPARATED BY SPACE.
    MSG2 = ' is 000. Please choose an RFC destination'. "#EC NOTEXT
    MSG3 = ' with a different client number.'. "#EC NOTEXT
    MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
  ENDIF.

  CALL FUNCTION 'RFC_SYSTEM_INFO' DESTINATION P_RFCDES
    EXCEPTIONS
      SYSTEM_FAILURE        = 1  MESSAGE RFC_ERROR
      COMMUNICATION_FAILURE = 2  MESSAGE RFC_ERROR.

  IF SY-SUBRC <> 0.
    CONCATENATE 'Could not connect to RFC destination' "#EC NOTEXT
    P_RFCDES
                RFC_ERROR
                INTO ERR_MSG
                SEPARATED BY SPACE.
*    PERFORM display_message USING err_msg rfc_error '' show_error.
    PERFORM RAISE_ERROR USING ERR_MSG.
    LEAVE TO SCREEN SY-DYNNR.
  ENDIF.

* -------------------------------------------------------------------
  CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET' DESTINATION P_RFCDES
    IMPORTING
      P_LOGSYS                       = GV_LOGSYS
    EXCEPTIONS
      OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
      SYSTEM_FAILURE                 = 2  MESSAGE RFC_ERROR
      COMMUNICATION_FAILURE          = 3  MESSAGE RFC_ERROR
      OTHERS                         = 4.

  IF SY-SUBRC = 2 OR SY-SUBRC = 3.
    MSG4 = RFC_ERROR.
    PERFORM RAISE_ERROR USING MSG4.
  ENDIF.

  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGR_USERS' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDIDC' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDP13' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDP21' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'SAPWLSERV' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'T582A' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'T000' P_RFCDES.
  PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'V_USR_NAME' P_RFCDES.

  PERFORM TEST_AUTH_READ_SOURCE
  USING 'SAPLS38E' P_RFCDES ''.

  CALL FUNCTION 'SAPWL_WORKLOAD_GET_STATISTIC' DESTINATION P_RFCDES
    EXCEPTIONS
      NO_DATA_FOUND         = 2
      SYSTEM_FAILURE        = 3  MESSAGE RFC_ERROR
      COMMUNICATION_FAILURE = 4  MESSAGE RFC_ERROR
      OTHERS                = 5.

  IF SY-SUBRC = 3 OR SY-SUBRC = 4.
    MSG4 = RFC_ERROR.
    PERFORM RAISE_ERROR USING MSG4.
  ENDIF.

  CALL FUNCTION 'SRTT_GET_TABLE_SIZE_RFC' DESTINATION P_RFCDES
    EXPORTING
      TABLE_NAME            = 'T001'
    IMPORTING
      TABLE_SIZE            = TABLE_SIZE
    EXCEPTIONS
      CLIENT_NOT_FOUND      = 1
      TABLE_NOT_FOUND       = 2
      TABLE_INKONSISTENT    = 3
      PROTECTED             = 4
      WRONG_TYPE            = 5
      SYSTEM_FAILURE        = 6  MESSAGE RFC_ERROR
      COMMUNICATION_FAILURE = 7  MESSAGE RFC_ERROR
      OTHERS                = 8.

  IF SY-SUBRC = 6 OR SY-SUBRC = 7.
    MSG4 = RFC_ERROR.
    PERFORM RAISE_ERROR USING MSG4.
  ENDIF.

* Get the RFC system
  CALL FUNCTION 'RFC_SYSTEM_INFO' DESTINATION P_RFCDES
    IMPORTING
      RFCSI_EXPORT = RFC_DATA.
  RFC_SYSID = RFC_DATA-RFCSYSID.
  RFC_SAPRL = RFC_DATA-RFCSAPRL.

* Check the authority for select_count function (Exist only in ECC6)
  IF RFC_SAPRL > '700' OR RFC_SAPRL = '700'.
    CALL FUNCTION 'SELECT_COUNT' DESTINATION P_RFCDES
      EXPORTING
        TABNAME               = 'T000'
*        WHERE                 =
*        BYPASSINGBUFFER       = ' '
      IMPORTING
        HITS                  = TABLE_SIZE
      EXCEPTIONS
        SYSTEM_FAILURE          = 1  MESSAGE RFC_ERROR
        COMMUNICATION_FAILURE   = 2  MESSAGE RFC_ERROR
        OTHERS                  = 3.

    IF SY-SUBRC = 1 OR SY-SUBRC = 2.
      MSG4 = RFC_ERROR.
      PERFORM RAISE_ERROR USING MSG4.
    ENDIF.
  ENDIF.

  PERFORM CHECK_AUTH_WORKLOAD_STATISTIC.

* Check that in table T000 of the system that the RFC points on
* there is a Prodution client except client 00
  CLEAR IS_PROD.
  IF DONT_SHOW_ERROR_ON_RFC IS INITIAL.
    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE          = 'T000'
        DELIMITER            = SPACE
        NO_DATA              = SPACE
        ROWSKIPS             = 0
        ROWCOUNT             = 0
      TABLES
        OPTIONS              = OPTIONS
        FIELDS               = FIELDS
        DATA                 = T000_ITAB
      EXCEPTIONS
        TABLE_NOT_AVAILABLE  = 1
        TABLE_WITHOUT_DATA   = 2
        OPTION_NOT_VALID     = 3
        FIELD_NOT_VALID      = 4
        NOT_AUTHORIZED       = 5
        DATA_BUFFER_EXCEEDED = 6
        OTHERS               = 7.

    IF SY-SUBRC IS INITIAL AND
       NOT T000_ITAB IS INITIAL.

*       Find a Client that is not 000 and its role is Production.
      LOOP AT T000_ITAB INTO T000_REC WHERE
        MANDT <> '000' AND CCCATEGORY = 'P'.
        IS_PROD = 'X'.
      ENDLOOP.

*       If no such Client was found - this is not Production system!
      IF IS_PROD IS INITIAL.
        CONCATENATE 'RFC destination' P_RFCDES "#EC NOTEXT
        'does not point to ' INTO MSG1 SEPARATED BY SPACE. "#EC NOTEXT
        MSG2 =
        ' Production system. Please choose another '. "#EC NOTEXT
        MSG3 =
        ' RFC destination that points to Production.'. "#EC NOTEXT
        MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
      ENDIF.
    ELSE.
      DATA: ERR(2) TYPE N.
      ERR = SY-SUBRC.
      MSG1 =
      'Error when retreiving information on clients '. "#EC NOTEXT
      CONCATENATE ' of RFC destination ' "#EC NOTEXT
      P_RFCDES '. RC: ' ERR
      INTO MSG2 SEPARATED BY SPACE.
      MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
    ENDIF.

*  Perform the following check only if Production client was not found.
    IF IS_PROD IS INITIAL.

*   Check if the system id of the rfc is the same as current system id.
*     If yes - raise a warning
      IF (  RFC_SYSID = SY-SYSID ).
        CONCATENATE 'The system id of the RFC destination' "#EC NOTEXT
        RFC_SYSID
          'is the ' INTO MSG1 SEPARATED BY SPACE. "#EC NOTEXT

CONCATENATE ' same as the current system. ' "#EC NOTEXT
'Please make sure your RFC' "#EC NOTEXT
INTO MSG2.
MSG3 = 'destination points to the Production system.'. "#EC NOTEXT
*        MESSAGE I000(CONV) WITH MSG1 MSG2 MSG3.
        CONCATENATE MSG1 MSG2 MSG3 INTO MSG4 SEPARATED BY SPACE.

        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            TEXT_QUESTION         = MSG4
            TEXT_BUTTON_1         = 'Continue' "#EC NOTEXT
            TEXT_BUTTON_2         = 'Abort' "#EC NOTEXT
            DEFAULT_BUTTON        = '2'
            DISPLAY_CANCEL_BUTTON = ' '
          IMPORTING
            ANSWER                = SELECTED.
        CASE SELECTED.
          WHEN '1'.                  "Continue selected
          WHEN '2'.                  "Abort selected
MSG4 = 'Program aborted. Please check you RFC destination.'. "#EC NOTEXT
            PERFORM RAISE_ERROR USING MSG4.
        ENDCASE.
      ENDIF.
    ENDIF.
  ENDIF.

* -------------------------------------------------------------------

* To get a logon screen at the next 'normal' RFC call, it is required
* to close the connection opend by RFC_SYSTEM_INFO.
  CALL FUNCTION 'RFC_CONNECTION_CLOSE'
    EXPORTING
      DESTINATION = P_RFCDES
    EXCEPTIONS
      OTHERS      = 1.

ENDFORM.                    " check_rfc_dest_existance

*&---------------------------------------------------------------------*
*&      Form  read_smsy_systems
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYSTEM_SAP  text
*      -->P_LT_SMSY_SYST_CLIENT  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*      <--P_LV_FAILED  text
*----------------------------------------------------------------------*
FORM READ_SMSY_SYSTEMS  USING    IV_RFCDEST
                        CHANGING EV_FAILED
                                 CT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
                                 CT_SMSY_SYSTEM_SAP TYPE
                                 SMSY_SYSTEM_SAP_T
                                 CT_SMSY_SYST_CLIENT TYPE
                                 SMSY_SYST_CLIENT_T.
  DATA : LV_SUBRC TYPE C.

* Remove each SM system data
  CLEAR : CT_SMSY_SYSTEM[],
          CT_SMSY_SYSTEM_SAP[],
          CT_SMSY_SYST_CLIENT[].

  CALL FUNCTION 'SMSY_GET_ALL_SYSTEMS_INFO'
  DESTINATION IV_RFCDEST
*   EXPORTING
*     NO_KONZS            = ' '
*     IV_SYSTEMTYPE       =
    IMPORTING
      SYSTEMS             = CT_SMSY_SYSTEM
      SYSTEMS_SAP         = CT_SMSY_SYSTEM_SAP
      CLIENTS             = CT_SMSY_SYST_CLIENT
    EXCEPTIONS
      SYSTEM_FAILURE        = 1
      COMMUNICATION_FAILURE = 2.

  IF NOT SY-SUBRC IS INITIAL.
    LV_SUBRC = SY-SUBRC.
    "Message - function doesnt exist in SM
CONCATENATE
'SM Error executing SMSY_GET_ALL_SYSTEMS_INFO in' "#EC NOTEXT
    IV_RFCDEST
    'RC:'
    LV_SUBRC
    INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    EV_FAILED = ABAP_TRUE.
  ENDIF.
ENDFORM.                    " read_smsy_systems
*&---------------------------------------------------------------------*
*&      Form  GET_SYSTEM_LEADING_PRODUCTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYS_RELINST  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM GET_SYSTEM_LEADING_PRODUCTS USING  IV_RFCDEST TYPE RFCDEST
                                        IT_SMSY_SYSTEM TYPE
                                        SMSY_SYSTEM_T
                                 CHANGING CT_SMSY_SYS_RELINST_FINAL
                                 TYPE
                                 SMSY_SYS_RELINST_T.

  DATA : LS_SMSY_SYSTEM      LIKE LINE OF IT_SMSY_SYSTEM,
         LT_SMSY_SYS_RELINST TYPE SMSY_SYS_RELINST_T,
         LS_SMSY_SYS_RELINST LIKE LINE OF LT_SMSY_SYS_RELINST,
         LV_NO_RIGHTS        TYPE FLAG,
         LV_SUBRC            TYPE C.

  LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
    CLEAR : LT_SMSY_SYS_RELINST[] , LV_NO_RIGHTS.

    CALL FUNCTION 'SMSY_GET_RELINST_TO_SYSTEM_RFC'
    DESTINATION IV_RFCDEST
    EXPORTING
      SYSTEMNAME                  = LS_SMSY_SYSTEM-SYSTEMNAME
*     VERSION                     = 'ACTIVE'
*     IV_SYSTEMTYPE               =
    IMPORTING
      SYS_RELINST                 = LT_SMSY_SYS_RELINST
      EV_NO_RIGHTS                = LV_NO_RIGHTS
    EXCEPTIONS
      SYSTEM_DOES_NOT_EXIST       = 1
      ERROR                       = 2
      SYSTEM_FAILURE              = 3
      COMMUNICATION_FAILURE       = 4
      OTHERS                      = 5.

    IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
      LV_SUBRC = SY-SUBRC.
*    Message auth. error running SMSY_GET_RELINST_TO_SYSTEM_RFC
      CONCATENATE
'SM Error executing SMSY_GET_RELINST_TO_SYSTEM_RFC in' "#EC NOTEXT
      IV_RFCDEST
      'RC:'
      LV_SUBRC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSEIF NOT LT_SMSY_SYS_RELINST[] IS INITIAL.
*     Set only system relevant product for products fetch
      LOOP AT LT_SMSY_SYS_RELINST INTO LS_SMSY_SYS_RELINST WHERE
      FLG_RELEVANT = ABAP_TRUE.
        APPEND LS_SMSY_SYS_RELINST TO CT_SMSY_SYS_RELINST_FINAL.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_SYSTEM_LEADING_PRODUCTS

*&---------------------------------------------------------------------*
*&      Form  read_system_product_instances
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYS_RELINST_FINAL  text
*      -->P_LT_SMSY_MAIN_INST_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_PRODUCTS_INSTANCES USING IV_RFCDEST TYPE RFCDEST
                                          IT_SMSY_SYS_RELINST_FINAL
                                          TYPE
                                          SMSY_SYS_RELINST_T
                                    CHANGING CT_SMSY_MAIN_INST_FINAL
                                    TYPE SMSY_MAIN_INST_SYST_T.


  DATA : LV_SUBRC                TYPE C,
         LS_SMSY_SYS_RELINST     LIKE LINE OF
         IT_SMSY_SYS_RELINST_FINAL,
         LT_SMSY_MAIN_INST       TYPE SMSY_MAIN_INST_T,
         LS_SMSY_MAIN_INST       LIKE LINE OF LT_SMSY_MAIN_INST,
         LV_NO_RIGHTS            TYPE FLAG,
         LS_SMSY_MAIN_INST_FINAL LIKE LINE OF CT_SMSY_MAIN_INST_FINAL.

  LOOP AT IT_SMSY_SYS_RELINST_FINAL INTO LS_SMSY_SYS_RELINST.

    CLEAR: LT_SMSY_MAIN_INST[] , LV_NO_RIGHTS.
    CALL FUNCTION 'SMSY_GET_INST_OF_PRODUCT_RFC'
      DESTINATION IV_RFCDEST
      EXPORTING
        PRODUCT                = LS_SMSY_SYS_RELINST-PRODUCT
        READ_FROM_DB           = ABAP_TRUE
      IMPORTING
        MAIN_INSTANCES         = LT_SMSY_MAIN_INST
        EV_NO_RIGHTS           = LV_NO_RIGHTS
      EXCEPTIONS
        PRODUCT_DOES_NOT_EXIST = 1
        ERROR                  = 2
        NO_INSTANCES           = 3
        SYSTEM_FAILURE         = 4
        COMMUNICATION_FAILURE  = 5
        OTHERS                 = 6.

    IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
      LV_SUBRC = SY-SUBRC.
*     Message auth error running SMSY_GET_INST_OF_PRODUCT_RFC
      CONCATENATE 'SM Error executing ' "#EC NOTEXT
      'SMSY_GET_INST_OF_PRODUCT_RFC in' "#EC NOTEXT
      IV_RFCDEST
      'RC:'
      LV_SUBRC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSEIF NOT LT_SMSY_MAIN_INST[] IS INITIAL.
      LOOP AT LT_SMSY_MAIN_INST INTO LS_SMSY_MAIN_INST.
        MOVE-CORRESPONDING LS_SMSY_MAIN_INST TO
        LS_SMSY_MAIN_INST_FINAL.
        LS_SMSY_MAIN_INST_FINAL-SYSTEMNAME =
        LS_SMSY_SYS_RELINST-SYSTEMNAME.
        APPEND LS_SMSY_MAIN_INST_FINAL TO CT_SMSY_MAIN_INST_FINAL.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " read_system_product_instances

*---------------------------------------------------------------------*
*       FORM CHECK_UPL_EXISTENCE                                      *
*---------------------------------------------------------------------*
FORM CHECK_UPL_EXISTENCE USING IV_RFC_DEST TYPE RFCDEST
                         CHANGING IV_AUTH_PROBLEM.

  DATA:
    I_T_SFK     TYPE RSDRI_T_SFK,
    L_T_SFC     TYPE TABLE OF RSDRI_S_SFC,
    E_T_RFCDATA TYPE RSDRI_T_RFCDATA,
    SUBRC       TYPE STRING.

  IF EXTRACT_UPL_DATA IS INITIAL.
    CLEAR G_EXTRACT_UPL.
  ELSE.
    CALL FUNCTION 'RSDRI_INFOPROV_READ_RFC' DESTINATION IV_RFC_DEST
      EXPORTING
        I_INFOPROV             = '0SM_UPL'
        I_MAXROWS              = 1
      TABLES
        I_T_SFC                = L_T_SFC
        I_T_SFK                = I_T_SFK
        E_T_RFCDATA            = E_T_RFCDATA
      EXCEPTIONS
        ILLEGAL_INPUT          = 1
        ILLEGAL_INPUT_SFC      = 2
        ILLEGAL_INPUT_SFK      = 3
        ILLEGAL_INPUT_RANGE    = 4
        ILLEGAL_INPUT_TABLESEL = 5
        NO_AUTHORIZATION       = 6
        GENERATION_ERROR       = 7
        ILLEGAL_DOWNLOAD       = 8
        ILLEGAL_TABLENAME      = 9
        ILLEGAL_RESULTTYPE     = 10
        X_MESSAGE              = 11
        DATA_OVERFLOW          = 12
        OTHERS                 = 13.
    IF SY-SUBRC <> 0.
      SUBRC = SY-SUBRC.
      IF  ( SY-MSGID = 'RSDODSO' AND
        SY-MSGNO = 201 ).
        CLEAR G_EXTRACT_UPL.

        CONCATENATE 'UPL: UPL data not available in ' "#EC NOTEXT
        IV_RFC_DEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.


      ELSEIF SY-SUBRC = 6.
        IV_AUTH_PROBLEM = 'X'.
        CONCATENATE 'UPL: NO AUTHORIZATION for UPL in ' "#EC NOTEXT
        IV_RFC_DEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      ELSE.
        CONCATENATE
        'UPL: Problem when checking UPL existance subrc' "#EC NOTEXT
      SUBRC 'for system' IV_RFC_DEST 'message info' "#EC NOTEXT
      SY-MSGID SY-MSGNO
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      ENDIF.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      CLEAR G_EXTRACT_UPL.
    ELSE.
      G_EXTRACT_UPL = 'X'.
    ENDIF.
  ENDIF.
ENDFORM.                    "CHECK_UPL_EXISTENCE

*&---------------------------------------------------------------------*
*&      Form  CHECK_BUSINESS_PROCESS_AUTH
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*

FORM CHECK_BUSINESS_PROCESS_AUTH USING IV_RFC_DEST
                                 CHANGING IV_AUTH_PROBLEM
                                   MESSAGE TYPE RFCLOG_D.

  DATA:
    NODES     TYPE TABLE OF HIER_IFACE.

  CALL FUNCTION 'SASAP_HIERARCHY_READ' DESTINATION IV_RFC_DEST
    TABLES
      LIST_OF_NODES         = NODES
    EXCEPTIONS
      SYSTEM_FAILURE        = 1  MESSAGE MESSAGE
      COMMUNICATION_FAILURE = 2  MESSAGE MESSAGE.

  IF NOT SY-SUBRC IS INITIAL.
    IV_AUTH_PROBLEM = 'X'.
  ENDIF.

ENDFORM.                    "CHECK_BUSINESS_PROCESS_AUTH

*&---------------------------------------------------------------------*
*&      Form  CHECK_AUTH_WORKLOAD_STATISTIC
*&---------------------------------------------------------------------*
FORM CHECK_AUTH_WORKLOAD_STATISTIC.

  DATA: RFC_ERROR TYPE RFCLOG_D,
        MSG1      TYPE STRING,
        MSG2      TYPE STRING.

* Check that web usage extraction is needed
* and that RFC target is 700 or higher
* to verify that the function exists in destination
  IF NO_WEB_USAGE IS INITIAL
    AND ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

    CALL FUNCTION 'SWNC_GET_WORKLOAD_STATISTIC' DESTINATION P_RFCDES
      EXCEPTIONS
        UNKNOWN_PERIODTYPE    = 1
        NO_DATA_FOUND         = 2
        UNKNOWN_ERROR         = 3
        SYSTEM_FAILURE        = 4  MESSAGE RFC_ERROR
        COMMUNICATION_FAILURE = 5  MESSAGE RFC_ERROR
        OTHERS                = 6.

    IF SY-SUBRC = 4 OR SY-SUBRC = 5.
      MSG1 = RFC_ERROR.
      PERFORM RAISE_ERROR USING MSG1.
      LEAVE TO SCREEN SY-DYNNR.
    ENDIF.
  ENDIF.

  IF ( NOT EXTRACT_PROXY_DATA IS INITIAL )
    AND ( RFC_SAPRL >= '700' OR RFC_SAPRL = '640' ).

    CALL FUNCTION 'SXMB_GET_MESSAGE_LIST' DESTINATION P_RFCDES
      EXCEPTIONS
        NOT_AUTHORIZED        = 1
        INTERNAL_ERROR        = 2
        TOO_MANY_MESSAGES     = 3
        NO_MESSAGE            = 4
        SYSTEM_FAILURE        = 5  MESSAGE RFC_ERROR
        COMMUNICATION_FAILURE = 6  MESSAGE RFC_ERROR
        OTHERS                = 7.
    IF SY-SUBRC = 1 .
MSG1 = 'The user has no authorizations reading proxies'. "#EC NOTEXT
      IF P_RFCDES = 'NONE'.
        MSG2 = ' usage in your current system.'. "#EC NOTEXT
      ELSE.
        CONCATENATE ' usage in system ' P_RFCDES '.' "#EC NOTEXT
                    INTO MSG2 SEPARATED BY SPACE.
      ENDIF.
      MESSAGE E000(CONV) WITH MSG1 MSG2.
    ELSEIF SY-SUBRC = 5 OR SY-SUBRC = 6.
      MSG1 = RFC_ERROR.
      PERFORM RAISE_ERROR USING MSG1.
      LEAVE TO SCREEN SY-DYNNR.
    ENDIF.
  ENDIF.

ENDFORM.                    " CHECK_AUTH_WORKLOAD_STATISTIC

*&---------------------------------------------------------------------*
*&      Form  read_system_components
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSYPROCOM_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_COMPONENTS USING    IV_RFCDEST TYPE RFCDEST
                                     IT_SMSY_SYSTEM      TYPE
                                     SMSY_SYSTEM_T
                            CHANGING CT_SMSYPROCOM_FINAL TYPE
                            SMSYPROCOM_T.

  DATA : LS_SMSY_SYSTEM LIKE LINE OF IT_SMSY_SYSTEM,
         LT_SMSYPROCOM  TYPE SMSYPROCOM_T,
         LS_MSG         TYPE SYMSG,
         LV_SUBRC       TYPE C,
         LV_NO_RIGHTS   TYPE FLAG.

  LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
    CLEAR : LT_SMSYPROCOM[], LV_NO_RIGHTS, LS_MSG.
    CALL FUNCTION 'SMSY_GET_CVERS_INFO_RFC'
      DESTINATION IV_RFCDEST
      EXPORTING
        SYSTEMNAME            = LS_SMSY_SYSTEM-SYSTEMNAME
*       iv_systemtype         =
      IMPORTING
        ET_PROCOM             = LT_SMSYPROCOM
        EV_NO_RIGHTS          = LV_NO_RIGHTS
        ES_MSG                = LS_MSG
      EXCEPTIONS
        SYSTEM_DOES_NOT_EXIST = 1
        ERROR                 = 2
        SYSTEM_FAILURE        = 3
        COMMUNICATION_FAILURE = 4
        OTHERS                = 5.

    IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
      LV_SUBRC = SY-SUBRC.
*     Message auth error running SMSY_GET_CVERS_INFO_RFC
      CONCATENATE
      'SM Error executing SMSY_GET_CVERS_INFO_RFC in' "#EC NOTEXT
      IV_RFCDEST
      'from system' "#EC NOTEXT
      LS_SMSY_SYSTEM-SYSTEMNAME
      'RC:'
      LV_SUBRC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSEIF NOT LS_MSG IS INITIAL.
*     Message error occured running SMSY_GET_CVERS_INFO_RFC
      CONCATENATE
      'SM Error executing SMSY_GET_CVERS_INFO_RFC in' "#EC NOTEXT
      IV_RFCDEST
      'for system' "#EC NOTEXT
      LS_SMSY_SYSTEM-SYSTEMNAME
      'error message:' "#EC NOTEXT
      LS_MSG
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSEIF NOT LT_SMSYPROCOM[] IS INITIAL.
      APPEND LINES OF LT_SMSYPROCOM TO CT_SMSYPROCOM_FINAL.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " read_system_components
*&---------------------------------------------------------------------*
*&      Form  read_system_patches
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_PAT03_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_PATCHES USING  IV_RFCDEST TYPE RFCDEST
                                IT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
                         CHANGING CT_PAT03_FINAL TYPE
                         TY_SYST_PAT03_OUT_T.

  DATA : LS_SMSY_SYSTEM LIKE LINE OF IT_SMSY_SYSTEM,
         LT_PAT03       TYPE TY_SYST_PAT03_T,
         LS_PAT03       LIKE LINE OF LT_PAT03,
         LS_PAT03_FINAL LIKE LINE OF CT_PAT03_FINAL.

  DATA : LV_HANDLE         TYPE BALLOGHNDL VALUE ''.

  LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
    CLEAR : LT_PAT03[].
    CALL FUNCTION 'SMSY_GET_SYSTEM_PAT03'
      DESTINATION IV_RFCDEST
      EXPORTING
        SYSTEM                = LS_SMSY_SYSTEM-SYSTEMNAME
        IV_LOG_HANDLE         = LV_HANDLE
      TABLES
        ET_PAT03              = LT_PAT03
      EXCEPTIONS
        DESTINATION_ERROR     = 1
        SYSTEM_FAILURE        = 2
        COMMUNICATION_FAILURE = 3
        OTHERS                = 4.

    IF SY-SUBRC <> 0.
*     Message auth error running SMSY_GET_SYSTEM_PAT03
      CONCATENATE
      'SM Error executing SMSY_GET_SYSTEM_PAT03 in' "#EC NOTEXT
      IV_RFCDEST
      'for system' "#EC NOTEXT
      LS_SMSY_SYSTEM-SYSTEMNAME
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSEIF NOT LT_PAT03[] IS INITIAL.
      LOOP AT LT_PAT03 INTO LS_PAT03.
        MOVE-CORRESPONDING LS_PAT03 TO LS_PAT03_FINAL.
        LS_PAT03_FINAL-SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME.
        APPEND LS_PAT03_FINAL TO CT_PAT03_FINAL.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " read_system_patches
*&---------------------------------------------------------------------*
*&      Form  read_system_oss_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_OSS_DATA USING  IV_RFCDEST TYPE RFCDEST
                          CHANGING CT_AISYSNR_BUFFER TYPE
                          AISYSNR_BUFFER_T.

  DATA : LV_SUBRC      TYPE C,
         LT_RFC_DB_OPT TYPE STANDARD TABLE OF RFC_DB_OPT,
         LT_RFC_DB_FLD TYPE STANDARD TABLE OF RFC_DB_FLD,
         LT_TAB512     TYPE STANDARD TABLE OF TAB512.

  CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].

  CALL FUNCTION 'RFC_READ_TABLE'
  DESTINATION IV_RFCDEST
    EXPORTING
      QUERY_TABLE                = 'AISYSNR_BUFFER'
*     DELIMITER                  = ' '
*     NO_DATA                    = ' '
*     ROWSKIPS                   = 0
*     ROWCOUNT                   = 0
    TABLES
      OPTIONS                    = LT_RFC_DB_OPT
      FIELDS                     = LT_RFC_DB_FLD
      DATA                       = LT_TAB512
    EXCEPTIONS
      TABLE_NOT_AVAILABLE        = 1
      TABLE_WITHOUT_DATA         = 2
      OPTION_NOT_VALID           = 3
      FIELD_NOT_VALID            = 4
      NOT_AUTHORIZED             = 5
      DATA_BUFFER_EXCEEDED       = 6
      SYSTEM_FAILURE             = 7
      COMMUNICATION_FAILURE      = 8
      OTHERS                     = 9.

  IF SY-SUBRC <> 0.
    IF SY-SUBRC = 5.
*     Message - SM rfc user has no auth to read AISYSNR_BUFFER
      CONCATENATE
      'SM SM rfc user has no auth to read AISYSNR_BUFFER' "#EC NOTEXT
      'table data from' "#EC NOTEXT
      IV_RFCDEST
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    ELSE.
      LV_SUBRC = SY-SUBRC.
*     Message - function doesnt exist in SM
      CONCATENATE 'SM Error reading SMSY OSS data from' "#EC NOTEXT
      IV_RFCDEST
      'RC:'
      LV_SUBRC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    ENDIF.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ELSE.
    CT_AISYSNR_BUFFER[] = LT_TAB512[].
  ENDIF.

ENDFORM.                    " read_system_oss_data
*&---------------------------------------------------------------------*
*&      Form  read_products
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LT_SMSY_SYST_PRODVR  text
*      -->P_LT_SMSY_PROD_VERS  text
*      -->P_LT_SMSY_PRODUCT  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_PRODUCTS USING  IV_RFCDEST        TYPE RFCDEST
                          IT_SMSY_SYSTEM    TYPE SMSY_SYSTEM_T
                          IT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T
                   CHANGING CT_SMSY_PROD_VERS     TYPE
                   SMSY_PROD_VERS_T
                            CT_SMSY_PRODUCT       TYPE SMSY_PRODUCT_T
                            CT_SM_SYSTEM_PRODUCTS TYPE
                            SM_SYSTEM_PRODUCTS_T.

  DATA: LV_SUBRC            TYPE C,
        LT_RFC_DB_OPT       TYPE STANDARD TABLE OF RFC_DB_OPT,
        LT_RFC_DB_FLD       TYPE STANDARD TABLE OF RFC_DB_FLD,
        LT_TAB512           TYPE STANDARD TABLE OF TAB512,
        LT_SMSY_SYST_PRODVR TYPE SMSY_SYST_PRODVR_T,
        LS_SMSY_SYSTEM      LIKE LINE OF IT_SMSY_SYSTEM,
        LS_SMSY_SYST_PRODVR LIKE LINE OF LT_SMSY_SYST_PRODVR,
        LS_SMSY_PROD_VERS   LIKE LINE OF CT_SMSY_PROD_VERS,
        LS_SMSY_PRODUCT     LIKE LINE OF CT_SMSY_PRODUCT,
        LS_SM_SYSTEM_PRODUCTS LIKE LINE OF CT_SM_SYSTEM_PRODUCTS,
        LS_AISYSNR_BUFFER   LIKE LINE OF IT_AISYSNR_BUFFER.

  IF NOT IT_SMSY_SYSTEM[] IS INITIAL.
    CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].

*   Fetch all data from SM
*   SMSY_SYST_PRODVR - product version for each system
    CALL FUNCTION 'RFC_READ_TABLE'
    DESTINATION IV_RFCDEST
      EXPORTING
        QUERY_TABLE                = 'SMSY_SYST_PRODVR'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
      TABLES
        OPTIONS                    = LT_RFC_DB_OPT
        FIELDS                     = LT_RFC_DB_FLD
        DATA                       = LT_TAB512
      EXCEPTIONS
        TABLE_NOT_AVAILABLE        = 1
        TABLE_WITHOUT_DATA         = 2
        OPTION_NOT_VALID           = 3
        FIELD_NOT_VALID            = 4
        NOT_AUTHORIZED             = 5
        DATA_BUFFER_EXCEEDED       = 6
        SYSTEM_FAILURE             = 7
        COMMUNICATION_FAILURE      = 8
        OTHERS                     = 9.

    IF SY-SUBRC <> 0.
      IF SY-SUBRC = 5.
        "Message - SM rfc user has no auth to read SMSY_SYST_PRODVR
        CONCATENATE
'SM SM rfc user has no auth to read SMSY_SYST_PRODVR' "#EC NOTEXT
        'table data from ' "#EC NOTEXT
        IV_RFCDEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ELSE.
        LV_SUBRC = SY-SUBRC.
        CONCATENATE
        'SM Error reading SMSY systems ' "#EC NOTEXT
        'to product versions data from' "#EC NOTEXT
        IV_RFCDEST
        'RC:'
        LV_SUBRC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ENDIF.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSE.
      LT_SMSY_SYST_PRODVR[] = LT_TAB512[].
    ENDIF.

    CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].
*   SMSY_PROD_VERS - product version , product , text
    CALL FUNCTION 'RFC_READ_TABLE'
    DESTINATION IV_RFCDEST
      EXPORTING
        QUERY_TABLE                = 'SMSY_PROD_VERS'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
      TABLES
        OPTIONS                    = LT_RFC_DB_OPT
        FIELDS                     = LT_RFC_DB_FLD
        DATA                       = LT_TAB512
      EXCEPTIONS
        TABLE_NOT_AVAILABLE        = 1
        TABLE_WITHOUT_DATA         = 2
        OPTION_NOT_VALID           = 3
        FIELD_NOT_VALID            = 4
        NOT_AUTHORIZED             = 5
        DATA_BUFFER_EXCEEDED       = 6
        SYSTEM_FAILURE             = 7
        COMMUNICATION_FAILURE      = 8
        OTHERS                     = 9.

    IF SY-SUBRC <> 0.
      IF SY-SUBRC = 5.
*       Message - SM rfc user has no auth to read SMSY_PROD_VERS
        CONCATENATE
        'SM SM rfc user has no auth to read SMSY_PROD_VERS' "#EC NOTEXT
        'table data from ' "#EC NOTEXT
        IV_RFCDEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ELSE.
        LV_SUBRC = SY-SUBRC.
*       Message - function doesnt exist in SM
        CONCATENATE
        'SM Error reading SMSY products versions data from' "#EC NOTEXT
        IV_RFCDEST
        'RC:'
        LV_SUBRC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ENDIF.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSE.
      CT_SMSY_PROD_VERS[] = LT_TAB512[].
    ENDIF.

    CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].
*   SMSY_PRODUCT - product , text
    CALL FUNCTION 'RFC_READ_TABLE'
    DESTINATION IV_RFCDEST
      EXPORTING
        QUERY_TABLE                = 'SMSY_PRODUCT'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
      TABLES
        OPTIONS                    = LT_RFC_DB_OPT
        FIELDS                     = LT_RFC_DB_FLD
        DATA                       = LT_TAB512
      EXCEPTIONS
        TABLE_NOT_AVAILABLE        = 1
        TABLE_WITHOUT_DATA         = 2
        OPTION_NOT_VALID           = 3
        FIELD_NOT_VALID            = 4
        NOT_AUTHORIZED             = 5
        DATA_BUFFER_EXCEEDED       = 6
        SYSTEM_FAILURE             = 7
        COMMUNICATION_FAILURE      = 8
        OTHERS                     = 9.

    IF SY-SUBRC <> 0.
      IF SY-SUBRC = 5.
        "Message - SM rfc user has no auth to read SMSY_PRODUCT
        CONCATENATE
        'SM SM rfc user has no auth to read SMSY_PRODUCT' "#EC NOTEXT
        'table data from' "#EC NOTEXT
        IV_RFCDEST
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ELSE.
        LV_SUBRC = SY-SUBRC.
        "Message - function doesnt exist in SM
        CONCATENATE
        'SM Error reading SMSY products data from' "#EC NOTEXT
        IV_RFCDEST
        'RC:'
        LV_SUBRC
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      ENDIF.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ELSE.
      CT_SMSY_PRODUCT[] = LT_TAB512[].
    ENDIF.

*   For each system get system product version and product
    LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
      CLEAR : LS_SM_SYSTEM_PRODUCTS,
              LS_SMSY_SYST_PRODVR,
              LS_SMSY_PROD_VERS,
              LS_SMSY_PRODUCT.

*     No product data fetched in systems data get from OSS or
*     SMSY_SYST_PRODVR
      IF LS_SMSY_SYSTEM-PRODVERS IS INITIAL.
*       OSS data read
        READ TABLE IT_AISYSNR_BUFFER
        WITH KEY SYSNR = LS_SMSY_SYSTEM-SYSTEMNAME
        INTO LS_AISYSNR_BUFFER.

        IF SY-SUBRC IS INITIAL AND
           NOT LS_AISYSNR_BUFFER-PRODVERS IS INITIAL.
          LS_SMSY_SYSTEM-PRODVERS = LS_AISYSNR_BUFFER-PRODVERS.
        ELSE.
*         SMSY settings - not always set
          READ TABLE LT_SMSY_SYST_PRODVR
          WITH KEY SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME
                   VERSION = 'ACTIVE'
          INTO LS_SMSY_SYST_PRODVR.
          IF SY-SUBRC IS INITIAL AND
             NOT LS_SMSY_SYST_PRODVR-PRODVERS IS INITIAL.
            LS_SMSY_SYSTEM-PRODVERS = LS_SMSY_SYST_PRODVR-PRODVERS.
          ENDIF.
        ENDIF.
      ENDIF.

*     Found the system product version
      IF NOT LS_SMSY_SYSTEM-PRODVERS IS INITIAL.
*       Fetch product version text and product
        LS_SM_SYSTEM_PRODUCTS-SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME.
        LS_SM_SYSTEM_PRODUCTS-PRODVERS = LS_SMSY_SYSTEM-PRODVERS.

        READ TABLE CT_SMSY_PROD_VERS
        WITH KEY PRODUCTVERSION = LS_SM_SYSTEM_PRODUCTS-PRODVERS
        INTO LS_SMSY_PROD_VERS.
        IF SY-SUBRC IS INITIAL.
          LS_SM_SYSTEM_PRODUCTS-PRODVERSTXT =
          LS_SMSY_PROD_VERS-PRODVERSTXT.
          LS_SM_SYSTEM_PRODUCTS-PRODUCT = LS_SMSY_PROD_VERS-PRODUCT.

*         Get product text
          READ TABLE CT_SMSY_PRODUCT
          WITH KEY PRODUCT = LS_SM_SYSTEM_PRODUCTS-PRODUCT
          INTO LS_SMSY_PRODUCT.
          IF SY-SUBRC IS INITIAL.
            LS_SM_SYSTEM_PRODUCTS-PRODUCTTXT =
            LS_SMSY_PRODUCT-PRODUCTTXT.
          ENDIF.
        ENDIF.
        APPEND LS_SM_SYSTEM_PRODUCTS TO CT_SM_SYSTEM_PRODUCTS.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " read_products

*&---------------------------------------------------------------------*
*&      Form  add_sm_data_to_xml
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYSTEM_SAP  text
*      -->P_LT_SMSY_SYST_CLIENT  text
*      -->P_LT_SM_SYSTEM_PRODUCTS  text
*      -->P_LT_SMSY_MAIN_INST_FINAL  text
*      -->P_LT_SMSYPROCOM_FINAL  text
*      -->P_LT_PAT03_FINAL  text
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LT_SMSY_PRODUCT  text
*      -->P_LT_SMSY_PROD_VERS  text
*----------------------------------------------------------------------*
FORM ADD_SM_DATA_TO_XML USING IV_SM_SYSTEM_NODE TYPE XML_ELEMENT
                              IT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
                              IT_SMSY_SYSTEM_SAP TYPE
                              SMSY_SYSTEM_SAP_T
                              IT_SMSY_SYST_CLIENT TYPE
                              SMSY_SYST_CLIENT_T
                              IT_SM_SYSTEM_PRODUCTS TYPE
                              SM_SYSTEM_PRODUCTS_T
                              IT_SMSY_MAIN_INST_FINAL TYPE
                              SMSY_MAIN_INST_SYST_T
                              IT_SMSYPROCOM_FINAL TYPE SMSYPROCOM_T
                              IT_PAT03_FINAL TYPE TY_SYST_PAT03_OUT_T
                              IT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T.

  DATA : LV_SMSY_SYSTEM_NODE TYPE XML_ELEMENT,
         LV_SMSY_SYSTEM_SAP_NODE TYPE XML_ELEMENT,
         LV_SMSY_SYST_CLIENT_NODE TYPE XML_ELEMENT,
         LV_SMSY_MAIN_INST_FINAL_NODE TYPE XML_ELEMENT,
         LV_SMSY_PRODUCTS_NODE TYPE XML_ELEMENT,
         LV_SMSYPROCOM_FINAL_NODE TYPE XML_ELEMENT,
         LV_PAT03_FINAL_NODE TYPE XML_ELEMENT,
         LV_AISYSNR_BUFFER_NODE TYPE XML_ELEMENT.

  IF NOT IT_SMSY_SYSTEM[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                                  'SM_DEFINED_SYSTEMS'
                            CHANGING LV_SMSY_SYSTEM_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYSTEM
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSY_SYSTEM_NODE
                                         'SM_DEFINED_SYSTEM'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_SMSY_SYSTEM_NODE 'X'.
  ENDIF.
* !!!Add the products after systems the sm_defined systems
* !!!persisted in ETLloader on the system products proccessing
* !!!and the systems data is required for all the other SM proccessing
  IF NOT IT_SM_SYSTEM_PRODUCTS[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_SYSTEMS_PRODUCTS'
                        CHANGING LV_SMSY_PRODUCTS_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SM_SYSTEM_PRODUCTS
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSY_PRODUCTS_NODE
                                         'SM_SYSTEMS_PRODUCT'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_SMSY_PRODUCTS_NODE 'X'.
  ENDIF.

  IF NOT IT_SMSY_SYSTEM_SAP[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_SAP_SYSTEMS'
                        CHANGING LV_SMSY_SYSTEM_SAP_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYSTEM_SAP
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSY_SYSTEM_SAP_NODE
                                         'SM_SAP_SYSTEM'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_SMSY_SYSTEM_SAP_NODE 'X'.
  ENDIF.
  IF NOT IT_SMSY_SYST_CLIENT[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_CLIENTS'
                        CHANGING LV_SMSY_SYST_CLIENT_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYST_CLIENT
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSY_SYST_CLIENT_NODE
                                         'SM_CLIENT'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
          LV_SMSY_SYST_CLIENT_NODE 'X'.
  ENDIF.

  IF NOT IT_SMSY_MAIN_INST_FINAL[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_PRODUCTS_INSTANCES'
                        CHANGING LV_SMSY_MAIN_INST_FINAL_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_MAIN_INST_FINAL
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSY_MAIN_INST_FINAL_NODE
                                         'SM_PRODUCTS_INSTANCE'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_SMSY_MAIN_INST_FINAL_NODE 'X'.
  ENDIF.

  IF NOT IT_SMSYPROCOM_FINAL[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_SYSTEMS_COMPONENTS'
                        CHANGING LV_SMSYPROCOM_FINAL_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSYPROCOM_FINAL
                                   USING G_IREF_PDOCUMENT
                                         LV_SMSYPROCOM_FINAL_NODE
                                         'SM_SYSTEM_COMPONENT'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_SMSYPROCOM_FINAL_NODE 'X'.
  ENDIF.

  IF NOT IT_PAT03_FINAL[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_SYSTEMS_PATCHES'
                        CHANGING LV_PAT03_FINAL_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_PAT03_FINAL
                                   USING G_IREF_PDOCUMENT
                                         LV_PAT03_FINAL_NODE
                                         'SM_SYSTEM_PATCH'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_PAT03_FINAL_NODE 'X'.
  ENDIF.

  IF NOT IT_AISYSNR_BUFFER[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
                              'SM_OSS_SETTINGS'
                        CHANGING LV_AISYSNR_BUFFER_NODE.
    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_AISYSNR_BUFFER
                                   USING G_IREF_PDOCUMENT
                                         LV_AISYSNR_BUFFER_NODE
                                         'SM_SYSTEM_OSS'.
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
            LV_AISYSNR_BUFFER_NODE 'X'.
  ENDIF.

ENDFORM.                    " add_sm_data_to_xml

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_HANA_CODE_INSPECTOR
*&---------------------------------------------------------------------*
" Extract Hana Check Code Inspector by variants :
" FUNCTIONAL_DB and FUNCTIONAL_DB_ADDITION, PERFORMANCE_DB.
" According to SAP Note 1912445 -
" ABAP custom code migration for SAP HANA -
" recommendations and Code Inspector variants for
" SAP HANA migration
*----------------------------------------------------------------------*
FORM EXTRACT_HANA_CODE_INSPECTOR.

  DATA:
    LV_STARTTIME               TYPE SY-UZEIT,
    LV_STARTDATE               TYPE SY-DATUM,

    LT_ALL_RESULT_TABLE        TYPE TT_HANAA_SCI_CHECK,
    LT_RESULT_TABLE            TYPE TT_HANAA_SCI_CHECK,
    LT_CHUNK_TABLE             TYPE TT_HANAA_SCI_CHECK,
    LO_HANA_SCI_CHCEK_NODE     TYPE XML_ELEMENT,
    LO_HANA_SCI_PER_CHCEK_NODE TYPE XML_ELEMENT,
    LV_IS_SUCCESS              TYPE FLAG,
    LV_INDEX                   TYPE I,
    LV_CHUNK                   TYPE I,
    LT_RESULT_TABLE_DETAILS    TYPE TT_HANA_SCI_CHECK_DETAILS,
    LT_CHUNK_TABLE_DETAILS     TYPE TT_HANA_SCI_CHECK_DETAILS,
    LV_DETAIL_REF              TYPE I.

  FIELD-SYMBOLS:
    <LS_ALL_RESULT_TABLE>     LIKE LINE OF LT_ALL_RESULT_TABLE,
    <LS_RESULT_TABLE_DETAILS> LIKE LINE OF LT_RESULT_TABLE_DETAILS.

  " Check if need to extract sci hana checks.
  IF ( EXTRACT_SCI_HANA_CHECK EQ ABAP_FALSE AND
       EXTRACT_SCI_HANA_PERFORMANCE EQ ABAP_FALSE ) OR
     ( G_IS_CAPABLE_EXTRACT_SCI_HANA EQ ABAP_FALSE AND
       R_SCIXLS IS INITIAL ).
      RETURN.
    ENDIF.

  GET TIME.
  LV_STARTTIME = SY-UZEIT.
  LV_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
    USING
     'Extracting HANA Code Inspector'. "#EC NOTEXT

  " Get Hana code Inspector table data.
  DATA: lt_messages TYPE TY_ETL_NOTIFICATION_T.
  PERFORM GET_HANA_CODE_INSPECTOR_DATA
    CHANGING
      LT_ALL_RESULT_TABLE
      LT_MESSAGES.

  " Add notifiction, if error occur.
  FIELD-SYMBOLS <fs_message> LIKE LINE OF lt_messages.
  LOOP AT lt_messages ASSIGNING <fs_message>.
    PERFORM ADD_NOTIFICATION USING <fs_message>-code
                    <fs_message>-parameters
                    <fs_message>-message.

    PERFORM ADD_MESSAGE USING <fs_message>-message ABAP_TRUE.
  ENDLOOP.

  LT_RESULT_TABLE[] = LT_ALL_RESULT_TABLE[].
  DELETE LT_RESULT_TABLE WHERE ZZVARIANT = 'PERFORMANCE_DB'.

  " Get issue details
  PERFORM GET_SCI_ISSUE_DETAILS
    USING
      ABAP_TRUE " Clear detail field
    CHANGING
      LT_RESULT_TABLE
      LT_RESULT_TABLE_DETAILS.

  " Create SCI Hana functional check element to xml.
  PERFORM CREATE_XML_NODE
    USING
      G_IREF_PDOCUMENT
      G_IREF_ROOT_ELEM
      'SCI_HANA_ISSUES'
    CHANGING
      LO_HANA_SCI_CHCEK_NODE.

  " Add result sci hana functional check table to xml.
  PERFORM ADD_ITAB_TO_XML_SIMPLE
    TABLES
      LT_RESULT_TABLE
    USING
      G_IREF_PDOCUMENT
      LO_HANA_SCI_CHCEK_NODE
      'SCI_HANA_ISSUE'.

  " Add SCI Hana functional check element to file
  PERFORM APPEND_XML_ELEMENT_TO_FILE
    USING
      LO_HANA_SCI_CHCEK_NODE
      'X'.

  PERFORM EXTRACT_SCI_HANA_ISSUE_DETAILS
    USING
       'SCI_HANA_ISSUES_DETAILS'
       'SCI_HANA_ISSUE_DETAILS'
    CHANGING
       LT_RESULT_TABLE_DETAILS.

  " Create SCI Hana performance check element to xml.
  PERFORM APPEND_STRING_TO_FILE
    USING
      '<SCI_HANA_PERFORMANCE_ISSUES>'.

  LT_RESULT_TABLE[] = LT_ALL_RESULT_TABLE[].
  DELETE LT_RESULT_TABLE WHERE ZZVARIANT = C_FUNCTIONAL_DB.
  DELETE LT_RESULT_TABLE WHERE ZZVARIANT = C_FUNCTIONAL_DB_ADDITION.

  CLEAR LT_RESULT_TABLE_DETAILS.
  CLEAR LV_DETAIL_REF.

  " Get perdormance issue details
  " Get issue details
  PERFORM GET_SCI_ISSUE_DETAILS
    USING
      ABAP_TRUE " Clear detail field
    CHANGING
      LT_RESULT_TABLE
      LT_RESULT_TABLE_DETAILS.

  " Delete duplicate rows
  " OBJTYPE, OBJNAME, DEVCLASS, AUTHOR, KIND, TEXT
  " DESCRIPTION, TEST, CODE SOBJTYPE, SOBJNAME, LINE,
  " COL, PARAM1, PARAM2, ZZVARIANT.
  SORT LT_RESULT_TABLE BY OBJTYPE OBJNAME DEVCLASS AUTHOR KIND TEXT
                          DESCRIPTION TEST CODE SOBJTYPE SOBJNAME LINE
                          COL PARAM1 PARAM2 ZZVARIANT.

  DELETE ADJACENT DUPLICATES FROM LT_RESULT_TABLE
  COMPARING OBJTYPE OBJNAME DEVCLASS AUTHOR KIND TEXT DESCRIPTION TEST
            CODE SOBJTYPE SOBJNAME LINE COL PARAM1 PARAM2 ZZVARIANT.

  FREE LT_CHUNK_TABLE.
  LV_INDEX = 0.

  LOOP AT LT_RESULT_TABLE
  ASSIGNING <LS_ALL_RESULT_TABLE>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <LS_ALL_RESULT_TABLE> TO LT_CHUNK_TABLE.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_RESULT_TABLE ).

      " Add result sci hana performance check table to xml.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_CHUNK_TABLE
        USING
          G_IREF_PDOCUMENT
          'SCI_HANA_PERFORMANCE_ISSUE'.

      FREE LT_CHUNK_TABLE.
    ENDIF.

  ENDLOOP.

  " Add SCI Hana check element to file
  PERFORM APPEND_STRING_TO_FILE
    USING
      '</SCI_HANA_PERFORMANCE_ISSUES>'.

  "Append SCI Hana check details to xml
  PERFORM EXTRACT_SCI_HANA_ISSUE_DETAILS
    USING
       'SCI_HANA_PERFORMANCE_ISSUES_DETAILS'
       'SCI_HANA_PERFORMANCE_ISSUE_DETAILS'
    CHANGING
       LT_RESULT_TABLE_DETAILS.

  PERFORM ADD_TIME_STAT
    USING
      'Extracting HANA Code Inspector' "#EC NOTEXT
      LV_STARTTIME
      LV_STARTDATE.

  FREE LT_RESULT_TABLE.
  FREE LT_ALL_RESULT_TABLE.

ENDFORM.                    "EXTRACT_HANA_CODE_INSPECTOR

*&---------------------------------------------------------------------*
*&      Form  GET_HANA_CODE_INSPECTOR_DATA
*&---------------------------------------------------------------------*
* Get SCI Hana checks results for hana check variants:
* FUNCTIONAL_DB & FUNCTIONAL_DB_ADDITION.
* There are two options:
* 1) from existing exectued inspections list.
* 2) or execute sci run for both checks variants.
*----------------------------------------------------------------------*
FORM GET_HANA_CODE_INSPECTOR_DATA
  CHANGING
    CT_ALL_RESULT_TABLE     TYPE TT_HANAA_SCI_CHECK
    CT_MESSAGES             TYPE TY_ETL_NOTIFICATION_T.

  DATA:
    LT_RESULT_TABLE TYPE TT_HANAA_SCI_CHECK,
    LV_COUNT        TYPE STRING,
  ls_message      like LINE OF ct_messages,
  lv_lines        type string,
    LV_IS_SUCCESS   TYPE FLAG.


  CLEAR CT_ALL_RESULT_TABLE[].

  " Check if user choose from existing executed inspections list.
  IF R_SCIHAS = ABAP_TRUE.

    IF EXTRACT_ATC_S4_CHECK = ABAP_FALSE.
      " Get result SCI Hana check for Check variant FUNCTIONAL_DB
    CLEAR lv_is_success.
      PERFORM GET_EXISTS_SCI_HANA_CHECK
         USING
           SCI_FD
           SCI_FDV
         CHANGING
           LT_RESULT_TABLE
           lv_is_success.

      IF lv_is_success EQ abap_false.
        ls_message-code       = sci_hana_error_execute.
        lv_lines = lines( lt_result_table ).
        CONCATENATE
          'Error GET_EXISTS_SCI_HANA_CHECK (SCI_FD, SCI_FDV) , Lines: '
          lv_lines into ls_message-message.
        ls_message-parameters = ''.
        APPEND ls_message to ct_messages.
      ENDIF.

      APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.
    ENDIF.

    IF EXTRACT_ATC_S4_CHECK = ABAP_TRUE AND
       EXTRACT_SCI_HANA_CHECK = ABAP_TRUE.
    " Get result SCI Hana check for Check variant FUNCTIONAL_DB_ADDITION
    CLEAR lv_is_success.
      PERFORM GET_EXISTS_SCI_HANA_CHECK
         USING
           SCI_FDA
           SCI_FDAV
         CHANGING
           LT_RESULT_TABLE
           LV_IS_SUCCESS.

      IF lv_is_success EQ abap_false.
        ls_message-code       = sci_hana_error_execute.
        lv_lines = lines( lt_result_table ).
        CONCATENATE
          'Error GET_EXISTS_SCI_HANA_CHECK (SCI_FDA, SCI_FDAV) , Lines: '
          lv_lines into ls_message-message.
        ls_message-parameters = ''.
        APPEND ls_message to ct_messages.
      ENDIF.

      APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.
    ENDIF.

    " Get result SCI Hana check for Check variant PERFORMANCE_DB
    IF  G_IS_CAN_SCI_HANA_PERFORMANCE = ABAP_TRUE.
      CLEAR lv_is_success.
      PERFORM GET_EXISTS_SCI_HANA_CHECK
         USING
           SCI_PER
           SCI_PERV
         CHANGING
           LT_RESULT_TABLE
           LV_IS_SUCCESS.

      IF lv_is_success EQ abap_false.
        ls_message-code       = sci_hana_error_execute.
        lv_lines = lines( lt_result_table ).
        CONCATENATE
          'Error GET_EXISTS_SCI_HANA_CHECK (SCI_PER, SCI_PERV), Lines: '
          lv_lines into ls_message-message.
        ls_message-parameters = ''.
        APPEND ls_message to ct_messages.
      ENDIF.

      APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.

    ENDIF.

  ELSEIF R_SCIXLS = ABAP_TRUE.

    " Get SCI Hana check from excel files.
  CLEAR lv_is_success.
    PERFORM GET_SCI_HANA_CHECK_FROM_FILES
      CHANGING
        CT_ALL_RESULT_TABLE
        lv_is_success.

    IF lv_is_success EQ abap_false.
      ls_message-code       = sci_hana_error_execute.
      lv_lines = lines( lt_result_table ).
      CONCATENATE
        'Error GET_SCI_HANA_CHECK_FROM_FILES, Lines: '
        lv_lines into ls_message-message.
      ls_message-parameters = ''.
      APPEND ls_message to ct_messages.
    ENDIF.

  ENDIF.

  LV_COUNT = LINES( CT_ALL_RESULT_TABLE ).
  CONCATENATE
    'Extracting HANA Code Inspector - ' "#EC NOTEXT
    'Toatal number of entries :' "#EC NOTEXT
    LV_COUNT
    INTO GT_ETL_MESSAGE-MESSAGE
    SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

ENDFORM.                    "get_hana_code_inspector_data

*&---------------------------------------------------------------------*
*&      Form  get_sci_issue_details
*&---------------------------------------------------------------------*
FORM GET_SCI_ISSUE_DETAILS
        USING UV_CLEAR_DETAIL         TYPE FLAG
     CHANGING CT_RESULT_TABLE         TYPE TT_HANAA_SCI_CHECK
              CT_RESULT_TABLE_DETAILS TYPE TT_HANA_SCI_CHECK_DETAILS.

  DATA: LT_SCI_RESULT_DETAIL    TYPE ZSCIT_SOURCE_LINK,
        LS_RESULT_TABLE_DETAILS LIKE LINE OF CT_RESULT_TABLE_DETAILS,
        LV_DETAIL_REF           TYPE I.

  FIELD-SYMBOLS:
    <LS_SCI_RESULT_DETAIL> LIKE LINE OF LT_SCI_RESULT_DETAIL,
    <LS_RESULT_TABLE>      LIKE LINE OF CT_RESULT_TABLE.

  CLEAR CT_RESULT_TABLE_DETAILS.

  " Get perdormance issue details
  LOOP AT CT_RESULT_TABLE ASSIGNING <LS_RESULT_TABLE>.

    CLEAR: LS_RESULT_TABLE_DETAILS, LT_SCI_RESULT_DETAIL.
    ADD 1 TO LV_DETAIL_REF.

    PERFORM GET_SCI_RESULT_DETAIL USING <LS_RESULT_TABLE>-DETAIL
                               CHANGING LT_SCI_RESULT_DETAIL.

    " Get the test details
    LOOP AT LT_SCI_RESULT_DETAIL ASSIGNING <LS_SCI_RESULT_DETAIL>.
      CLEAR LS_RESULT_TABLE_DETAILS.
      MOVE-CORRESPONDING <LS_SCI_RESULT_DETAIL>
        TO LS_RESULT_TABLE_DETAILS.
      LS_RESULT_TABLE_DETAILS-DETAILS_REF = LV_DETAIL_REF.
      APPEND LS_RESULT_TABLE_DETAILS TO CT_RESULT_TABLE_DETAILS.
    ENDLOOP.

    <LS_RESULT_TABLE>-DETAILS_REF = LV_DETAIL_REF.

    IF UV_CLEAR_DETAIL EQ ABAP_TRUE.

      " Clear detail to hide it from the xml
      CLEAR <LS_RESULT_TABLE>-DETAIL.

    ENDIF.

  ENDLOOP.

ENDFORM.        "get_sci_issue_details

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_SCI_HANA_ISSUE_DETAILS
*&---------------------------------------------------------------------*
* Append the reults details to xml
*----------------------------------------------------------------------*
FORM EXTRACT_SCI_HANA_ISSUE_DETAILS
    USING UV_TAG_NAME TYPE STRING
          UV_SINGLE_TAG_NAME TYPE STRING
 CHANGING CT_RESULT_TABLE_DETAILS TYPE TT_HANA_SCI_CHECK_DETAILS.

  DATA: REC_TAG                TYPE STRING,
        LT_CHUNK_TABLE_DETAILS TYPE TT_HANA_SCI_CHECK_DETAILS,
        LV_INDEX               TYPE I VALUE 0,
        LV_CHUNK               TYPE I.

  FIELD-SYMBOLS: <LS_RESULT_TABLE_DETAILS>
                                   LIKE LINE OF CT_RESULT_TABLE_DETAILS.

  SORT CT_RESULT_TABLE_DETAILS BY TEXT INCLUDE LINE PROGRAM DETAILS_REF.
  DELETE ADJACENT DUPLICATES FROM CT_RESULT_TABLE_DETAILS
    COMPARING TEXT INCLUDE LINE PROGRAM DETAILS_REF.

  CONCATENATE '<' UV_TAG_NAME '>' INTO REC_TAG.

  " Create SCI Hana performance check element details to xml.
  PERFORM APPEND_STRING_TO_FILE
    USING REC_TAG.

  LOOP AT CT_RESULT_TABLE_DETAILS
  ASSIGNING <LS_RESULT_TABLE_DETAILS>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <LS_RESULT_TABLE_DETAILS> TO LT_CHUNK_TABLE_DETAILS.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( CT_RESULT_TABLE_DETAILS ).

      " Add result sci hana performance check table to xml.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_CHUNK_TABLE_DETAILS
        USING
          G_IREF_PDOCUMENT
          UV_SINGLE_TAG_NAME.

      FREE LT_CHUNK_TABLE_DETAILS.
    ENDIF.

  ENDLOOP.

  CONCATENATE '</' UV_TAG_NAME '>' INTO REC_TAG.

  PERFORM APPEND_STRING_TO_FILE
  USING REC_TAG.

ENDFORM.                    "EXTRACT_SCI_HANA_ISSUE_DETAILS

*&---------------------------------------------------------------------*
*&      Form  get_exists_sci_hana_check
*&---------------------------------------------------------------------*
* Get SCI Hana check results from existing inspection executed list
* by inspection name and version.
*----------------------------------------------------------------------*
FORM GET_EXISTS_SCI_HANA_CHECK
  USING
    IV_INPECTION_NAME
    IV_INSPECTION_VERSION
  CHANGING
    CT_RESULT_TABLE         TYPE TT_HANAA_SCI_CHECK
    CV_IS_SUCCESS           TYPE FLAG.

  DATA:
    LO_CI_INSPECTION        TYPE REF TO CL_CI_INSPECTION,
    LO_CI_CHECK_RESULT      TYPE REF TO CL_CI_CHECK_RESULT,
    LT_RESULT_TABLE         TYPE SCIT_ALVLIST,
    LS_RESULT_TABLE         LIKE LINE OF CT_RESULT_TABLE,
    LV_COUNT                TYPE STRING.

  FIELD-SYMBOLS:
    <LT_RESULT_TABLE>      LIKE LINE OF LT_RESULT_TABLE.

  CLEAR CT_RESULT_TABLE[].

  CV_IS_SUCCESS = ABAP_TRUE.

  IF IV_INPECTION_NAME IS INITIAL.
    RETURN.
  ENDIF.

  " Get exists inspection by inspection name & version
  CL_CI_INSPECTION=>GET_REF(
    EXPORTING
      P_USER          =  SCI_USR                 " Code Inspector: User
      P_NAME          =  IV_INPECTION_NAME
      " Code Inspector: Element Name of an Inspection
      P_VERS          =  IV_INSPECTION_VERSION
      " Code Inspector: Version Number of Element (ObjM, Inspec)
    RECEIVING
      P_REF           =  LO_CI_INSPECTION
      " Reference to Relevant Inspection
    EXCEPTIONS
      INSP_NOT_EXISTS = 1
      OTHERS          = 2
  ).

  IF SY-SUBRC <> 0.
    CV_IS_SUCCESS = ABAP_FALSE.

    CONCATENATE
      'Extracting HANA Code Inspector - The inpection' "#EC NOTEXT
      IV_INPECTION_NAME
      'doesn''t exists' "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    RETURN.
  ENDIF.

  " Load inspection data.
  LO_CI_INSPECTION->GET_INFO(
    EXCEPTIONS
      INSP_NOT_EXISTS           = 1
      CHKV_NOT_EXISTS           = 2
      MISSING_CHKV_PARAMETER    = 3
      OBJS_NOT_EXISTS           = 4
      MISSING_OBJS_PARAMETER    = 5
      OBJECT_MAY_NOT_BE_CHECKED = 6
      OBJECT_NOT_EXISTS         = 7
      INVALID_REQUEST           = 8
      OTHERS                    = 9
  ).
  IF SY-SUBRC <> 0.
    CV_IS_SUCCESS = ABAP_FALSE.

    CONCATENATE
      'Extracting HANA Code Inspector' "#EC NOTEXT
      '- Error occur when tried to load inspection' "#EC NOTEXT
      IV_INPECTION_NAME
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    RETURN.
  ENDIF.

* Get results.
  PERFORM GET_SCI_PLAIN_LIST_DYN
    USING LO_CI_INSPECTION
    CHANGING LT_RESULT_TABLE CV_IS_SUCCESS.

  IF CV_IS_SUCCESS = ABAP_FALSE.
    CONCATENATE 'Extracting HANA Code Inspector' "#EC NOTEXT
                '- Error occur when dynamic call to' "#EC NOTEXT
                'cl_ci_inspection->plain_list.' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    RETURN.
  ENDIF.

  LV_COUNT = LINES( LT_RESULT_TABLE ).

  CONCATENATE
    'Extracting HANA Code Inspector' "#EC NOTEXT
    '- Number of entries for check variant' "#EC NOTEXT
    LO_CI_INSPECTION->CHKV->CHKVINF-CHECKVNAME
    ':'
    LV_COUNT
    INTO GT_ETL_MESSAGE-MESSAGE
    SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  LOOP AT LT_RESULT_TABLE ASSIGNING <LT_RESULT_TABLE>.
    CLEAR LS_RESULT_TABLE.
    MOVE-CORRESPONDING <LT_RESULT_TABLE> TO LS_RESULT_TABLE.
    LS_RESULT_TABLE-ZZVARIANT =
                        LO_CI_INSPECTION->CHKV->CHKVINF-CHECKVNAME.
    APPEND LS_RESULT_TABLE TO CT_RESULT_TABLE.

  ENDLOOP.

ENDFORM.                    "get_exists_sci_hana_check

*&---------------------------------------------------------------------*
*&      Form  get_sci_hana_check_from_files
*&---------------------------------------------------------------------*
* Get SCI Hana check results from excel files
*----------------------------------------------------------------------*
FORM GET_SCI_HANA_CHECK_FROM_FILES
  CHANGING
    CT_ALL_RESULT_TABLE TYPE TT_HANAA_SCI_CHECK
    CV_IS_SUCCESS       TYPE FLAG.

  DATA:
    LT_RESULT_TABLE TYPE TT_HANAA_SCI_CHECK,
    LV_COUNT        TYPE STRING,
    LV_IS_SUCCESS   TYPE FLAG.

  FREE CT_ALL_RESULT_TABLE.

  CV_IS_SUCCESS = ABAP_TRUE.

  " Get result SCI Hana check for Check variant ADDITIONAL_DB
  IF PXLS_FD IS NOT INITIAL.

    PERFORM GET_SCI_HANA_CHECK_FROM_FILE
       USING
         C_FUNCTIONAL_DB
         G_FULLNAME_FUNC_DB
       CHANGING
         LT_RESULT_TABLE
         LV_IS_SUCCESS.

    IF LV_IS_SUCCESS EQ ABAP_FALSE.
      CV_IS_SUCCESS = LV_IS_SUCCESS.
    ENDIF.

    APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.
  ENDIF.

  IF PXLS_FDA IS NOT INITIAL.

    " Get result SCI Hana check for Check variant ADDITIONAL_DB_ADDITION
    PERFORM GET_SCI_HANA_CHECK_FROM_FILE
       USING
         C_FUNCTIONAL_DB_ADDITION
         G_FULLNAME_FUNC_DB_ADD
       CHANGING
         LT_RESULT_TABLE
         LV_IS_SUCCESS.

    IF LV_IS_SUCCESS EQ ABAP_FALSE.
      CV_IS_SUCCESS = LV_IS_SUCCESS.
    ENDIF.

    APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.

  ENDIF.

  " Get result SCI Hana check for Check variant PERFORMANCE_DB
  IF  EXTRACT_SCI_HANA_PERFORMANCE = ABAP_TRUE AND
      PXLS_PER IS NOT INITIAL.

    PERFORM GET_SCI_HANA_CHECK_FROM_FILE
       USING
         C_PERFORMANCE_DB
         G_FULLNAME_PER_DB
       CHANGING
         LT_RESULT_TABLE
         LV_IS_SUCCESS.

    IF LV_IS_SUCCESS EQ ABAP_FALSE.
      CV_IS_SUCCESS = LV_IS_SUCCESS.
    ENDIF.

    APPEND LINES OF LT_RESULT_TABLE TO CT_ALL_RESULT_TABLE.

  ENDIF.

ENDFORM.                    "get_sci_hana_check_from_files

*&---------------------------------------------------------------------*
*&      Form  get_sci_result_detail
*&---------------------------------------------------------------------*
FORM GET_SCI_RESULT_DETAIL
  USING UV_DETAILS_XSTRING TYPE TS_HANAA_SCI_CHECK-DETAIL
  CHANGING LT_LINKS TYPE ZSCIT_SOURCE_LINK.

  IF UV_DETAILS_XSTRING IS NOT INITIAL.
    IMPORT LINKS = LT_LINKS FROM DATA BUFFER UV_DETAILS_XSTRING.
  ENDIF.
ENDFORM.                    "get_sci_result_detail

*---------------------------------------------------------------------*
*       FORM GET_SCI_PLAIN_LIST_DYN                                   *
*---------------------------------------------------------------------*
*   dynamically call to method cl_ci_inspection->plain_list           *
*   to send parameter P_MAX_LINES which is not found in older         *
*   versions and therefore wont compile.                              *
*---------------------------------------------------------------------*
FORM GET_SCI_PLAIN_LIST_DYN
  USING
    UO_CI_INSPECTION  TYPE REF TO CL_CI_INSPECTION
  CHANGING
    CT_RESULT_TABLE   TYPE SCIT_ALVLIST
    CV_IS_SUCCESS     TYPE FLAG.

  DATA: LV_METH   TYPE STRING VALUE 'PLAIN_LIST',
        PTAB      TYPE ABAP_PARMBIND_TAB,
        PTAB_LINE TYPE ABAP_PARMBIND,
        ETAB      TYPE ABAP_EXCPBIND_TAB,
        ETAB_LINE TYPE ABAP_EXCPBIND,
        EXC_REF   TYPE REF TO CX_ROOT.

  PTAB_LINE-NAME = 'P_MAX_LINES'.
  PTAB_LINE-KIND = CL_ABAP_OBJECTDESCR=>EXPORTING.
  GET REFERENCE OF SCI_MAX_LINES INTO PTAB_LINE-VALUE.
  INSERT PTAB_LINE INTO TABLE PTAB.

  PTAB_LINE-NAME = 'P_LIST'.
  PTAB_LINE-KIND = CL_ABAP_OBJECTDESCR=>IMPORTING.
  GET REFERENCE OF CT_RESULT_TABLE INTO PTAB_LINE-VALUE.
  INSERT PTAB_LINE INTO TABLE PTAB.

  TRY.
      CALL METHOD UO_CI_INSPECTION->(LV_METH)
        PARAMETER-TABLE
          PTAB
        EXCEPTION-TABLE
          ETAB.

    CATCH CX_ROOT INTO EXC_REF.
      CV_IS_SUCCESS = ABAP_FALSE.

      GT_ETL_MESSAGE-MESSAGE = EXC_REF->GET_TEXT( ).
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ENDTRY.

ENDFORM.                    "GET_SCI_PLAIN_LIST_DYN

*&---------------------------------------------------------------------*
*&      Form  get_sci_hana_check_from_file
*&---------------------------------------------------------------------*
* Get SCI Hana check results from excel file
*----------------------------------------------------------------------*
FORM GET_SCI_HANA_CHECK_FROM_FILE
  USING
    IV_VARIANT_NAME
    IV_FILE_FULL_NAME  TYPE STRING
  CHANGING
    CT_HANAA_SCI_CHECK TYPE TT_HANAA_SCI_CHECK
    CV_IS_SUCCESS      TYPE FLAG.


  DATA:
     LV_TEXT_FILE       TYPE          STRING,
     LV_STRING          TYPE          STRING,
     LT_STRING          TYPE TABLE OF STRING,
     LT_EXCEL_SCI_HANA  TYPE TABLE OF TS_EXCEL_SCI_HANA,
     LS_EXCEL_SCI_HANA  LIKE LINE  OF LT_EXCEL_SCI_HANA,
     LT_HANAA_SCI_CHECK TYPE TABLE OF TS_HANAA_SCI_CHECK,
     LS_HANAA_SCI_CHECK LIKE LINE  OF LT_HANAA_SCI_CHECK,
     LV_COUNT           TYPE          STRING.

  FIELD-SYMBOLS:
    <COMP> TYPE STRING.

  CLEAR CV_IS_SUCCESS.
  FREE CT_HANAA_SCI_CHECK.

  OPEN DATASET IV_FILE_FULL_NAME FOR INPUT IN TEXT MODE ENCODING UTF-8.

  IF SY-SUBRC <> 0.

    CONCATENATE
    'Extracting HANA Code Inspector' "#EC NOTEXT
    '- Could get data from file' "#EC NOTEXT
    LV_TEXT_FILE
    'for check variant' "#EC NOTEXT
    IV_VARIANT_NAME
    INTO GT_ETL_MESSAGE-MESSAGE
    SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    EXIT.
  ENDIF.

  DO.
    READ DATASET IV_FILE_FULL_NAME INTO LV_STRING.

    IF SY-SUBRC = 0.
      SPLIT LV_STRING AT CL_ABAP_CHAR_UTILITIES=>HORIZONTAL_TAB INTO
TABLE LT_STRING.
      CLEAR LS_EXCEL_SCI_HANA.

      LOOP AT LT_STRING INTO LV_STRING.

        ASSIGN COMPONENT SY-TABIX
           OF STRUCTURE LS_EXCEL_SCI_HANA TO <COMP>.
        IF SY-SUBRC EQ 0.
          <COMP> = LV_STRING.
        ENDIF.

      ENDLOOP.

      APPEND LS_EXCEL_SCI_HANA TO LT_EXCEL_SCI_HANA.

    ELSE.
      EXIT.
    ENDIF.
  ENDDO.

  CLOSE DATASET IV_FILE_FULL_NAME.

  DELETE  DATASET IV_FILE_FULL_NAME.

  LOOP AT LT_EXCEL_SCI_HANA
  INTO LS_EXCEL_SCI_HANA.
    CLEAR LS_HANAA_SCI_CHECK.
    LS_HANAA_SCI_CHECK-OBJTYPE      = LS_EXCEL_SCI_HANA-OBJECT_TYPE.
    LS_HANAA_SCI_CHECK-OBJNAME      = LS_EXCEL_SCI_HANA-OBJECT_NAME.
    LS_HANAA_SCI_CHECK-DEVCLASS     = LS_EXCEL_SCI_HANA-PACKAGE.
    LS_HANAA_SCI_CHECK-AUTHOR       =
LS_EXCEL_SCI_HANA-PERSON_RESPONSIBLE.

    CASE LS_EXCEL_SCI_HANA-MESSAGE_TYPE.
      WHEN '1_E'.
        LS_HANAA_SCI_CHECK-KIND = 'E'.
      WHEN '2_W'.
        LS_HANAA_SCI_CHECK-KIND = 'W'.
      WHEN '3_N'.
        LS_HANAA_SCI_CHECK-KIND = 'N'.
      WHEN OTHERS.
        LS_HANAA_SCI_CHECK-KIND = LS_EXCEL_SCI_HANA-MESSAGE_TYPE.
    ENDCASE.

    LS_HANAA_SCI_CHECK-TEXT         =
    LS_EXCEL_SCI_HANA-MESSAGE_TEXT.
    LS_HANAA_SCI_CHECK-DESCRIPTION  =
    LS_EXCEL_SCI_HANA-CHECK_DESCRIPTION.
    LS_HANAA_SCI_CHECK-TEST         =
    LS_EXCEL_SCI_HANA-CHECK_CLASS.
    LS_HANAA_SCI_CHECK-CODE         =
    LS_EXCEL_SCI_HANA-MESSAGE_CODE.
    LS_HANAA_SCI_CHECK-SOBJTYPE     =
    LS_EXCEL_SCI_HANA-SUB_OBJECT_TYPE.
    LS_HANAA_SCI_CHECK-SOBJNAME     =
    LS_EXCEL_SCI_HANA-SUB_OBJECT_NAME.
    LS_HANAA_SCI_CHECK-LINE         =
    LS_EXCEL_SCI_HANA-LINE_NUMBER.
    LS_HANAA_SCI_CHECK-COL          =
    LS_EXCEL_SCI_HANA-COLUMN_NUMBER.
    LS_HANAA_SCI_CHECK-PARAM1       = LS_EXCEL_SCI_HANA-PARAM1.
    LS_HANAA_SCI_CHECK-PARAM2       = LS_EXCEL_SCI_HANA-PARAM2.
    LS_HANAA_SCI_CHECK-PARAM3       = LS_EXCEL_SCI_HANA-PARAM3.
    LS_HANAA_SCI_CHECK-PARAM4       = LS_EXCEL_SCI_HANA-PARAM4.
    LS_HANAA_SCI_CHECK-ZZVARIANT = IV_VARIANT_NAME.
    APPEND LS_HANAA_SCI_CHECK TO CT_HANAA_SCI_CHECK.
  ENDLOOP.

  LV_COUNT = LINES( CT_HANAA_SCI_CHECK ).

  CONCATENATE
    'Extracting HANA Code Inspector' "#EC NOTEXT
    '- Number of entries for check variant' "#EC NOTEXT
    IV_VARIANT_NAME
    ':'
    LV_COUNT
    INTO GT_ETL_MESSAGE-MESSAGE
    SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  CV_IS_SUCCESS = ABAP_TRUE.

ENDFORM.                    "get_sci_hana_check_from_file

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_S4HANA_SI_REPORT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_S4HANA_SI_REPORT .

  DATA: LT_REL_CHK_RESULT    TYPE TY_RC_RELE_CHK_RESULT_TAB,
        LS_REL_CHK_RESULT    TYPE TY_RC_RELE_CHK_RESULT_STR,
        LT_CHECK             TYPE TY_SMDB_CHECK_TAB,
        LT_SITEM             TYPE TY_SMDB_ITEM_TAB,
        LS_SITEM             TYPE TY_SMDB_ITEM_STR,
        LV_CONV_TARGET_STACK TYPE  CHAR20.

  DATA: LT_CLAS_CHK_RESULT TYPE TY_PRE_CONS_CHK_RESULT_TAB.

  DATA: LV_TARGET_STACK TYPE CHAR20.

  DATA: LT_RESULT_OUT_SIG TYPE TY_CONSIS_CHK_RESULT_OUT_TAB,
        LT_HEADER_OUT_SIG TYPE TY_CONSIS_CHK_HEADER_OUT_TAB,
        LT_DETAIL_OUT_SIG TYPE TY_CONSIS_CHK_DETAILS_OUT_TAB.

  DATA: LV_STARTTIME TYPE TIMS,
        LV_STARTDATE TYPE DATS.

  DATA: LV_SITEM_SKIPPED TYPE I.
  DATA: LV_SITEM_MANUAL TYPE I.
  DATA: LV_SITEM_CHECKED TYPE I.

  DATA: LV_ERROR TYPE FLAG.
  DATA: LV_ERROR_MSG TYPE STRING.

  DATA: LV_RFC TYPE RFCDEST.

  " Check if need to extract sci hana checks.
  IF EXTRACT_SI_S4_CHECK EQ ABAP_FALSE.
    RETURN.
  ENDIF.

  GET TIME.
  LV_STARTTIME = SY-UZEIT.
  LV_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
    USING
     'Extracting S/4 HANA Simplification Item Checks'.      "#EC NOTEXT

  LV_TARGET_STACK = C_TARGET_S4HANA_VERSION.

  CHECK CREUSESI = ABAP_FALSE.

  IF P_SI_RFC IS INITIAL.
    LV_RFC = 'NONE'.
  ELSE.
    LV_RFC = P_SI_RFC.
  ENDIF.

  PERFORM ADD_MESSAGE
  USING 'About to get SI Relevancy check result'            "#EC NOTEXT
          ABAP_TRUE.

*s4_si_relevancy_check
  PERFORM S4_SI_RELEVANCY_CHECK USING  LV_TARGET_STACK
                                       LV_RFC
                                CHANGING LT_REL_CHK_RESULT
                                         LV_ERROR_MSG.

  IF LT_REL_CHK_RESULT IS INITIAL.

    CONCATENATE 'Error occurred while trying'               "#EC NOTEXT
    'to extract SI Relevancy check'                         "#EC NOTEXT
    INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_NOTIFICATION USING SCI_HANA_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                     GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.


    PERFORM ADD_NOTIFICATION USING SCI_HANA_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                     LV_ERROR_MSG.

    PERFORM ADD_MESSAGE USING LV_ERROR_MSG ABAP_TRUE.

    MESSAGE A000(CONV) WITH LV_ERROR_MSG.
    RETURN.

  ENDIF.

  PERFORM ADD_MESSAGE USING
      'About to get Consistency Check result'               "#EC NOTEXT
      ABAP_TRUE.

*s4_si_consistency_check
  PERFORM S4_SI_CONSISTENCY_CHECK TABLES   LT_REL_CHK_RESULT
                                  USING    LV_TARGET_STACK
                                           LV_RFC
                                  CHANGING LV_SITEM_SKIPPED
                                           LV_SITEM_MANUAL
                                           LV_SITEM_CHECKED
                                           LT_RESULT_OUT_SIG
                                           LT_HEADER_OUT_SIG
                                           LT_DETAIL_OUT_SIG
                                           LV_ERROR.

  IF LV_ERROR = ABAP_TRUE.

    CONCATENATE 'Error occurred while trying'               "#EC NOTEXT
    'to extract SI Consistency check'                       "#EC NOTEXT
    INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_NOTIFICATION USING SCI_HANA_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                     GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    MESSAGE A000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
    RETURN.
  ENDIF.

  PERFORM EXPORT_SI_REPORT_TO_XML TABLES LT_RESULT_OUT_SIG
                                        LT_HEADER_OUT_SIG
                                        LT_DETAIL_OUT_SIG
                                  USING LV_SITEM_SKIPPED
                                        LV_SITEM_MANUAL
                                        LV_SITEM_CHECKED.

  FREE LT_RESULT_OUT_SIG.
  FREE LT_HEADER_OUT_SIG.
  FREE LT_DETAIL_OUT_SIG.

  PERFORM ADD_TIME_STAT
    USING
      'Extracting SI Consistency Checks'                    "#EC NOTEXT
      SY-UZEIT
      SY-DATUM.

ENDFORM.                    " EXTRACT_S4HANA_SI_REPORT

*&---------------------------------------------------------------------*
*&      Form  S4_SI_RELEVANCY_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_REL_CHK_RESULT  text
*----------------------------------------------------------------------*
FORM S4_SI_RELEVANCY_CHECK  USING  LV_TARGET_STACK TYPE CHAR20
                                   LV_RFC          TYPE RFCDEST
                            CHANGING LT_REL_CHK_RESULT TYPE
                            TY_RC_RELE_CHK_RESULT_TAB
                            LV_ERROR_MSG TYPE STRING.

  DATA: LV_FUNCNAME_REL  TYPE RS38L_FNAM  VALUE
  '/SDF/GEN_FUNCS_S4_RELEVAN_CHK',
        LV_METHOD         TYPE STRING      VALUE 'GET_SMDB_CONTENT'.

  DATA: LV_RESULT_XSTR       TYPE XSTRING,
        LV_CONV_TARGET_STACK TYPE CHAR20,
        LS_HDR_INFO          TYPE TY_RELEV_CHK_HEADER_STR.

  CALL FUNCTION LV_FUNCNAME_REL DESTINATION LV_RFC
    EXPORTING
      IV_CONV_TARGET_STACK = LV_TARGET_STACK
    IMPORTING
      EV_ERR_MESG          = LV_ERROR_MSG
      EV_RESULT_XSTR       = LV_RESULT_XSTR.

  CHECK LV_RESULT_XSTR IS NOT INITIAL.

  CALL TRANSFORMATION ID
    SOURCE XML LV_RESULT_XSTR
    RESULT SITEM_RELE_CHECK_RESULT = LT_REL_CHK_RESULT
           CONVERSION_TARGET_STACK = LV_CONV_TARGET_STACK
           SITEM_RELE_CHK_HDR_INFO = LS_HDR_INFO.

ENDFORM.                    "s4_si_relevancy_check

*&---------------------------------------------------------------------*
*&      Form  S4_SI_CONSISTENCY_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_REL_CHK_RESULT  text
*----------------------------------------------------------------------*
FORM S4_SI_CONSISTENCY_CHECK  TABLES    LT_REL_CHK_RESULT TYPE
TY_RC_RELE_CHK_RESULT_TAB
                              USING     LV_TARGET_STACK TYPE CHAR20
                                        LV_RFC            TYPE RFCDEST
                              CHANGING  LV_SITEM_SKIPPED  TYPE I
                                        LV_SITEM_MANUAL   TYPE I
                                        LV_SITEM_CHECKED  TYPE I
                                        LT_RESULT_OUT_SIG TYPE
                                        TY_CONSIS_CHK_RESULT_OUT_TAB
                                        LT_HEADER_OUT_SIG TYPE
                                        TY_CONSIS_CHK_HEADER_OUT_TAB
                                        LT_DETAIL_OUT_SIG TYPE
                                        TY_CONSIS_CHK_DETAILS_OUT_TAB
                                        LV_ERROR          TYPE FLAG.

  DATA: LV_FUNCNAME_SIG  TYPE RS38L_FNAM
                         VALUE '/SDF/GEN_FUNCS_S4_CONS_CHK_SIG',
        LS_CLASS_UTILITY TYPE SEOCLSKEY
                         VALUE '/SDF/CL_RC_CHK_UTILITY'.

  DATA:
    LS_REL_CHK_RESULT       TYPE TY_RC_RELE_CHK_RESULT_STR,
    LT_CHECK                TYPE TY_SMDB_CHECK_TAB,
    LS_CHECK                TYPE TY_SMDB_CHECK_STR,
    LT_SITEM                TYPE TY_SMDB_ITEM_TAB,
    LS_SITEM                TYPE TY_SMDB_ITEM_STR,
    LV_CHK_CLASS            TYPE STRING,
    LS_CONS_CHECK_ITEM      TYPE TY_SMDB_CHECK_STR,
    LV_RESULT_XSTR          TYPE XSTRING,
    LT_PARAMETER            TYPE TIHTTPNVP,
    LV_STRING               TYPE STRING,
    LS_RESULT_SIG           TYPE TY_CONSIS_CHK_RESULT_STR,
    LT_RESULT_SIG_DETAILS   TYPE TY_PRE_CONS_CHK_RESULT_TAB,
    LS_RESULT_OUT_SIG       TYPE TY_CONSIS_CHK_RESULT_OUT_STR,
    LS_HEADER_OUT_SIG       TYPE TY_CONSIS_CHK_HEADER_OUT_STR,
    LS_DETAIL_OUT_SIG       TYPE TY_CONSIS_CHK_DETAILS_OUT_STR,
    LV_FAIL_SI_COUNTER      TYPE I,
    LV_FAIL_SI_COUNTER_STR  TYPE STRING.

  FIELD-SYMBOLS:
    <FS_CHECK_SITEM>        TYPE TY_RC_RELE_CHK_RESULT_STR,
    <FS_RESULT_SIG>         TYPE TY_CONSIS_CHK_RESULT_STR,
    <FS_RESULT_SIG_DETAILS> TYPE TY_PRE_CONS_CHK_RESULT_STR,
    <FS_HEADER_INFO_TABLE>  TYPE IHTTPNVP,
    <FS_DETAIL>             TYPE STRING.

  PERFORM GET_SITEM_AND_CHECK CHANGING LT_SITEM LT_CHECK.

  IF SY-SUBRC = 0.

    LOOP AT LT_REL_CHK_RESULT ASSIGNING <FS_CHECK_SITEM>.

      CLEAR: LS_RESULT_OUT_SIG, LS_SITEM.

      READ TABLE LT_SITEM INTO LS_SITEM WITH KEY GUID =
        <FS_CHECK_SITEM>-SITEM_GUID.

      "Exclude only 100% sure irrelevant items
      "To be on the safe side; keep all possibly relevant items
      "including chk_cls_issue & rule_issue
      IF <FS_CHECK_SITEM>-RELEVANT_STAT_INT = 'NOT_RELEVT'.
        ADD 1 TO LV_SITEM_SKIPPED.

        CLEAR LS_REL_CHK_RESULT.
        MOVE-CORRESPONDING <FS_CHECK_SITEM> TO LS_RESULT_OUT_SIG.

        LS_RESULT_OUT_SIG-SITEM_ID = LS_SITEM-SITEM_ID.
        LS_RESULT_OUT_SIG-SITEM_TYPE = 'Skipped'.           "#EC NOTEXT
        APPEND LS_RESULT_OUT_SIG TO LT_RESULT_OUT_SIG.

        IF EXTRACT_DEBUG = ABAP_TRUE.

          READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
            WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID.

          PERFORM LOG_SI_ITEM USING <FS_CHECK_SITEM>-SITEM_GUID
                            LS_SITEM-SITEM_ID
                            <FS_CHECK_SITEM>-RELEVANT_STAT_INT
                            LS_CONS_CHECK_ITEM-CHECK_TYPE
                            LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE
                            LS_RESULT_OUT_SIG-SITEM_TYPE.

        ENDIF.

        CONTINUE.
      ENDIF.

      "Exclude items need manual check
      IF <FS_CHECK_SITEM>-RELEVANT_STAT_INT = 'MANUAL_CHK'.

        ADD 1 TO LV_SITEM_MANUAL.

        CLEAR LS_REL_CHK_RESULT.
        MOVE-CORRESPONDING <FS_CHECK_SITEM> TO LS_RESULT_OUT_SIG.

        LS_RESULT_OUT_SIG-SITEM_ID = LS_SITEM-SITEM_ID.
        LS_RESULT_OUT_SIG-SITEM_TYPE = 'Manual'.            "#EC NOTEXT
        APPEND LS_RESULT_OUT_SIG TO LT_RESULT_OUT_SIG.

        IF EXTRACT_DEBUG = ABAP_TRUE.

          READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
            WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID.

          PERFORM LOG_SI_ITEM USING <FS_CHECK_SITEM>-SITEM_GUID
                            LS_SITEM-SITEM_ID
                            <FS_CHECK_SITEM>-RELEVANT_STAT_INT
                            LS_CONS_CHECK_ITEM-CHECK_TYPE
                            LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE
                            LS_RESULT_OUT_SIG-SITEM_TYPE.

        ENDIF.

        CONTINUE.
      ENDIF.

      "Check if pre-check is defined ->
      "otherwise take it as manual check as well
      READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
        WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID
                 CHECK_TYPE = 'NPC'.
      IF SY-SUBRC <> 0.

        ADD 1 TO LV_SITEM_MANUAL.

        CLEAR LS_REL_CHK_RESULT.
        MOVE-CORRESPONDING <FS_CHECK_SITEM> TO LS_RESULT_OUT_SIG.

        LS_RESULT_OUT_SIG-SITEM_ID = LS_SITEM-SITEM_ID.
        LS_RESULT_OUT_SIG-SITEM_TYPE = 'Manual'.            "#EC NOTEXT
        APPEND LS_RESULT_OUT_SIG TO LT_RESULT_OUT_SIG.

        IF EXTRACT_DEBUG = ABAP_TRUE.

          READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
            WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID.

          PERFORM LOG_SI_ITEM USING <FS_CHECK_SITEM>-SITEM_GUID
                            LS_SITEM-SITEM_ID
                            <FS_CHECK_SITEM>-RELEVANT_STAT_INT
                            LS_CONS_CHECK_ITEM-CHECK_TYPE
                            LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE
                            LS_RESULT_OUT_SIG-SITEM_TYPE.

        ENDIF.

        CONTINUE.
      ENDIF.

      IF LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE = 'CONSISTNCY'
        OR LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE = 'REL_CONSIS'.

        ADD 1 TO LV_SITEM_CHECKED.

        DATA: LV_LOG_MESSAGE TYPE STRING.

        LV_STRING = LS_SITEM-SITEM_ID.
        LV_CHK_CLASS = LS_CONS_CHECK_ITEM-CHECK_IDENTIFIER.

        CONCATENATE 'Begin of' LV_CHK_CLASS 'check'         "#EC NOTEXT
          INTO LV_LOG_MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.

        PERFORM ADD_TIME_STAT
          USING
            LV_LOG_MESSAGE
            SY-UZEIT
            SY-DATUM.

        CALL METHOD
          (LS_CLASS_UTILITY-CLSNAME)=>PREPARE_CHECK_CLASS_PARAMETER
          EXPORTING
            IV_SITEM_GUID   = <FS_CHECK_SITEM>-SITEM_GUID
            IV_TARGET_STACK = LV_TARGET_STACK
            IV_DETAILED_CHK = ABAP_TRUE
          RECEIVING
            RT_PARAMETER    = LT_PARAMETER.

        DATA LV_RFC_ERROR TYPE RFCLOG_D.

        CALL FUNCTION LV_FUNCNAME_SIG DESTINATION LV_RFC
          EXPORTING
            IV_TARGET_STACK       = LV_TARGET_STACK
            IV_SITEM_GUID         = LS_CONS_CHECK_ITEM-SITEM_GUID
            IV_SITEM_ID           = LV_STRING
            IV_CHECK_CLASS        = LV_CHK_CLASS
            IV_SAP_NOTE           = LS_CONS_CHECK_ITEM-SAP_NOTE
            IT_PARAMETER          = LT_PARAMETER
            IV_SUM_MODE           = ABAP_FALSE
          IMPORTING
            EV_RESULT_XSTR        = LV_RESULT_XSTR
          EXCEPTIONS
            SYSTEM_FAILURE        = 1  MESSAGE LV_RFC_ERROR
            COMMUNICATION_FAILURE = 2  MESSAGE LV_RFC_ERROR
            OTHERS                = 3.

        IF SY-SUBRC <> 0.
          DATA: LV_SUBRC TYPE NUMC1.
          LV_SUBRC = SY-SUBRC.
          LV_FAIL_SI_COUNTER = LV_FAIL_SI_COUNTER + 1.
          LV_FAIL_SI_COUNTER_STR = LV_FAIL_SI_COUNTER.

          PERFORM HANDLE_FAIL_SI_RUN
            TABLES
              LT_RESULT_OUT_SIG LT_HEADER_OUT_SIG LT_DETAIL_OUT_SIG
            USING
              LV_STRING <FS_CHECK_SITEM> LV_FUNCNAME_SIG
              LV_RFC LV_SUBRC LV_RFC_ERROR LV_FAIL_SI_COUNTER.

          IF LV_FAIL_SI_COUNTER > 5.
            LV_LOG_MESSAGE =
                'Too many SI checks failed - aborting ETL process.'.
            PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.
            LV_ERROR = ABAP_TRUE.
            RETURN.
          ELSE.
            CONTINUE.
          ENDIF.
        ENDIF.

        PERFORM S4_SI_CONSISTENCY_RUN_PARSE
            TABLES LT_RESULT_OUT_SIG
                  LT_HEADER_OUT_SIG
                  LT_DETAIL_OUT_SIG
                  LT_REL_CHK_RESULT
            USING LV_RESULT_XSTR
                  LS_CONS_CHECK_ITEM-SITEM_GUID
            CHANGING <FS_CHECK_SITEM>.

        CONCATENATE 'End of' LV_CHK_CLASS 'check'           "#EC NOTEXT
          INTO LV_LOG_MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_TIME_STAT
          USING LV_LOG_MESSAGE SY-UZEIT SY-DATUM.

        IF EXTRACT_DEBUG = ABAP_TRUE.

          READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
            WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID.

          PERFORM LOG_SI_ITEM USING <FS_CHECK_SITEM>-SITEM_GUID
                            LS_SITEM-SITEM_ID
                            <FS_CHECK_SITEM>-RELEVANT_STAT_INT
                            LS_CONS_CHECK_ITEM-CHECK_TYPE
                            LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE
                            'Performed Consistency Check'.

        ENDIF.

        CONTINUE.

      ENDIF.

      CLEAR LS_REL_CHK_RESULT.
      MOVE-CORRESPONDING <FS_CHECK_SITEM> TO LS_RESULT_OUT_SIG.

      LS_RESULT_OUT_SIG-SITEM_TYPE = 'Not Handled'.         "#EC NOTEXT
      APPEND LS_RESULT_OUT_SIG TO LT_RESULT_OUT_SIG.

      READ TABLE LT_CHECK INTO LS_CONS_CHECK_ITEM
        WITH KEY SITEM_GUID = <FS_CHECK_SITEM>-SITEM_GUID.

      PERFORM LOG_SI_ITEM USING <FS_CHECK_SITEM>-SITEM_GUID
                            LS_SITEM-SITEM_ID
                            <FS_CHECK_SITEM>-RELEVANT_STAT_INT
                            LS_CONS_CHECK_ITEM-CHECK_TYPE
                            LS_CONS_CHECK_ITEM-CHECK_CLASS_USAGE
                            LS_RESULT_OUT_SIG-SITEM_TYPE.

    ENDLOOP.
  ELSE.
    LV_ERROR = ABAP_TRUE.
    RETURN.
  ENDIF.


ENDFORM.                    "s4_si_consistency_check

*&---------------------------------------------------------------------*
*&      Form  LOG_SI_ITEM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->SITEM_GUID         text
*      -->SITEM_ID           text
*      -->RELEVANT_STAT_INT  text
*      -->CHECK_TYPE         text
*      -->CHECK_CLASS_USAGE  text
*----------------------------------------------------------------------*
FORM LOG_SI_ITEM USING SITEM_GUID
                       SITEM_ID
                       RELEVANT_STAT_INT
                       CHECK_TYPE
                       CHECK_CLASS_USAGE
                       HANDLE_TYPE.

  DATA: LV_LOG_MESSAGE TYPE STRING.

  CONCATENATE
      'Simplification Item:'                                "#EC NOTEXT
      SITEM_ID
      'Int. Status:'                                        "#EC NOTEXT
      RELEVANT_STAT_INT
      INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.

  CONCATENATE
  'Check Type:'                                             "#EC NOTEXT
  CHECK_TYPE
  'Check Class Ussage:'                                     "#EC NOTEXT
  CHECK_CLASS_USAGE
  HANDLE_TYPE
  INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.

ENDFORM.                    "LOG_SI_ITEM

*&---------------------------------------------------------------------*
*&      Form  EXPORT_SI_REPORT_TO_XML
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_SITEM_SKIPPED  text
*      -->P_LV_SITEM_MANUAL  text
*      -->P_LV_SITEM_CHECKED  text
*      -->P_LT_RESULT_OUT_SIG  text
*      -->P_LT_HEADER_OUT_SIG  text
*      -->P_LT_DETAIL_OUT_SIG  text
*----------------------------------------------------------------------*
FORM EXPORT_SI_REPORT_TO_XML  TABLES LT_RESULT_OUT_SIG TYPE
                                     TY_CONSIS_CHK_RESULT_OUT_TAB
                                     LT_HEADER_OUT_SIG TYPE
                                     TY_CONSIS_CHK_HEADER_OUT_TAB
                                     LT_DETAIL_OUT_SIG TYPE
                                     TY_CONSIS_CHK_DETAILS_OUT_TAB
                              USING LV_SITEM_SKIPPED TYPE I
                                    LV_SITEM_MANUAL TYPE I
                                    LV_SITEM_CHECKED TYPE I.

  DATA: LO_SI_ROOT_NODE      TYPE XML_ELEMENT.

  DATA: LV_STRING TYPE STRING.
  DATA: LV_STRING_S TYPE STRING.
  DATA: LV_STRING_M TYPE STRING.
  DATA: LV_STRING_C TYPE STRING.

  DATA: LT_RESULT_CHUNK TYPE
        TY_CONSIS_CHK_RESULT_OUT_TAB,
        LT_HEADER_CHUNK TYPE
        TY_CONSIS_CHK_HEADER_OUT_TAB,
        LT_DETAIL_CHUNK TYPE
        TY_CONSIS_CHK_DETAILS_OUT_TAB.

  DATA: LV_INDEX TYPE I,
        LV_CHUNK TYPE I.

  FIELD-SYMBOLS: <FT_RESULT_OUT_SIG> TYPE TY_CONSIS_CHK_RESULT_OUT_STR,
                 <FT_HEADER_OUT_SIG> TYPE TY_CONSIS_CHK_HEADER_OUT_STR,
                 <FT_DETAIL_OUT_SIG> TYPE TY_CONSIS_CHK_DETAILS_OUT_STR.

  LV_STRING_S = LV_SITEM_SKIPPED.
  LV_STRING_M = LV_SITEM_MANUAL.
  LV_STRING_C = LV_SITEM_CHECKED.

  " Create SCI Hana performance check element to xml.
  CONCATENATE '<SI_CHECKS '
  'SITEMS_SKIPPED="' LV_STRING_S
  '" SITEMS_MANUAL="' LV_STRING_M
  '" SITEMS_CHECKED="' LV_STRING_C '">'
   INTO LV_STRING RESPECTING BLANKS.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

**********************************************************************
  LV_STRING = '<SI_CHECK>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LOOP AT LT_RESULT_OUT_SIG
    ASSIGNING <FT_RESULT_OUT_SIG>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <FT_RESULT_OUT_SIG> TO LT_RESULT_CHUNK.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_RESULT_OUT_SIG ).

      " Add result SI relevancy to XML.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_RESULT_CHUNK
        USING
          G_IREF_PDOCUMENT
          'SI_ITEM'.

      FREE LT_RESULT_CHUNK.
    ENDIF.

  ENDLOOP.
  CLEAR: LV_INDEX, LV_CHUNK.

  LV_STRING = '</SI_CHECK>'.
  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

**********************************************************************

  LV_STRING = '<SI_CONSISTENCY_CHECK_HEADERS>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LOOP AT LT_HEADER_OUT_SIG
    ASSIGNING <FT_HEADER_OUT_SIG>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <FT_HEADER_OUT_SIG> TO LT_HEADER_CHUNK.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_HEADER_OUT_SIG ).

      " Add result SI CONSISTENCY HEADER to ETL.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_HEADER_CHUNK
        USING
          G_IREF_PDOCUMENT
          'SI_CONSISTENCY_CHECK_HEADER'.

      FREE LT_HEADER_CHUNK.
    ENDIF.

  ENDLOOP.

  LV_STRING = '</SI_CONSISTENCY_CHECK_HEADERS>'.
  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.
  CLEAR: LV_INDEX, LV_CHUNK.


**********************************************************************

  LV_STRING = '<SI_CONSISTENCY_CHECK_DETAILS>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LOOP AT LT_DETAIL_OUT_SIG
    ASSIGNING <FT_DETAIL_OUT_SIG>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <FT_DETAIL_OUT_SIG> TO LT_DETAIL_CHUNK.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_DETAIL_OUT_SIG ).

      " Add result SI CONSISTENCY DETAIL to ETL.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_DETAIL_CHUNK
        USING
          G_IREF_PDOCUMENT
          'SI_CONSISTENCY_CHECK_DETAIL'.

      FREE LT_DETAIL_CHUNK.
    ENDIF.

  ENDLOOP.

  LV_STRING = '</SI_CONSISTENCY_CHECK_DETAILS>'.
  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.
  CLEAR: LV_INDEX, LV_CHUNK.

**********************************************************************

  LV_STRING = '</SI_CHECKS>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

ENDFORM.                    " EXPORT_SI_REPORT_TO_XML

*&---------------------------------------------------------------------*
*&      Form  GET_SITEM_AND_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LT_SITEM  text
*      <--P_LT_CHECK  text
*----------------------------------------------------------------------*
FORM GET_SITEM_AND_CHECK  CHANGING LT_SITEM TYPE TY_SMDB_ITEM_TAB
                                   LT_CHECK TYPE TY_SMDB_CHECK_TAB.

  DATA: LS_CLASS_UTILITY TYPE SEOCLSKEY VALUE '/SDF/CL_RC_CHK_UTILITY',
        LV_METHOD         TYPE STRING VALUE 'GET_SMDB_CONTENT',
        LV_SITEM_TAB     TYPE STRING VALUE
'/SDF/CL_RC_CHK_UTILITY=>TY_SMDB_ITEM_TAB',
        LV_SITEM_STR     TYPE STRING VALUE
'/SDF/CL_RC_CHK_UTILITY=>TY_SMDB_ITEM_STR',
        LV_CHECK_TAB     TYPE STRING VALUE
'/SDF/CL_RC_CHK_UTILITY=>TY_SMDB_CHECK_TAB',
        LV_CHECK_STR     TYPE STRING VALUE
'/SDF/CL_RC_CHK_UTILITY=>TY_SMDB_CHECK_STR'.

  DATA: LX_EXCEPTION TYPE REF TO CX_ROOT.

  DATA: LR_SITEM TYPE REF TO DATA.
  DATA: LR_CHECK TYPE REF TO DATA.

  FIELD-SYMBOLS: <FS_SITEM> TYPE ANY TABLE.
  FIELD-SYMBOLS: <FS_CHECK> TYPE ANY TABLE.

  FIELD-SYMBOLS: <FS_SITEM_L> TYPE ANY.
  FIELD-SYMBOLS: <FS_CHECK_L> TYPE ANY.

  CREATE DATA LR_SITEM TYPE (LV_SITEM_TAB).
  ASSIGN LR_SITEM->* TO <FS_SITEM>.

  CREATE DATA LR_CHECK TYPE (LV_CHECK_TAB).
  ASSIGN LR_CHECK->* TO <FS_CHECK>.

  FIELD-SYMBOLS: <FS_TARGET_SRUCT> TYPE ANY.

  FIELD-SYMBOLS: <FS_SOURCE> TYPE ANY.
  FIELD-SYMBOLS: <FS_TARGET> TYPE ANY.

  TRY.

      DATA: LV_LOG_MESSAGE TYPE STRING.
      CONCATENATE 'About to run:'                           "#EC NOTEXT
      LS_CLASS_UTILITY-CLSNAME
      '=>'
      LV_METHOD
      INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

      CALL METHOD (LS_CLASS_UTILITY-CLSNAME)=>(LV_METHOD)
        IMPORTING
          ET_SITEM               = <FS_SITEM>
          ET_CHECK               = <FS_CHECK>
        EXCEPTIONS
          SMDB_CONTNET_NOT_FOUND = 1
          ERROR                  = 2
          OTHERS                 = 3.

      IF SY-SUBRC <> 0.
        MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
        WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
        INTO GT_ETL_MESSAGE-MESSAGE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM RAISE_ERROR USING GT_ETL_MESSAGE-MESSAGE.
      ENDIF.

      LOOP AT <FS_SITEM> ASSIGNING <FS_SITEM_L>.

        APPEND INITIAL LINE TO LT_SITEM ASSIGNING <FS_TARGET_SRUCT>.
        MOVE-CORRESPONDING <FS_SITEM_L> TO <FS_TARGET_SRUCT>.

      ENDLOOP.

      LOOP AT <FS_CHECK> ASSIGNING <FS_CHECK_L>.

        APPEND INITIAL LINE TO LT_CHECK ASSIGNING <FS_TARGET_SRUCT>.
        MOVE-CORRESPONDING <FS_CHECK_L> TO <FS_TARGET_SRUCT>.

      ENDLOOP.

    CATCH CX_ROOT INTO LX_EXCEPTION.

      DATA LV_MESSAGE TYPE STRING.
      LV_MESSAGE = LX_EXCEPTION->GET_LONGTEXT( ).
      PERFORM RAISE_ERROR USING LV_MESSAGE.

  ENDTRY.

ENDFORM.                    "get_sitem_and_check

FORM HANDLE_FAIL_SI_RUN
  TABLES
    RESULT_OUT_SIG TYPE TY_CONSIS_CHK_RESULT_OUT_TAB
    HEADER_OUT_SIG TYPE TY_CONSIS_CHK_HEADER_OUT_TAB
    DETAIL_OUT_SIG TYPE TY_CONSIS_CHK_DETAILS_OUT_TAB
  USING
    SITEM_ID TYPE STRING
    CHECK_SITEM TYPE TY_RC_RELE_CHK_RESULT_STR
    FUNCNAME TYPE RS38L_FNAM
    RFC TYPE RFCDEST
    SUBRC TYPE NUMC1
    RFC_ERROR TYPE RFCLOG_D
    FAIL_SI_COUNTER TYPE I.

  DATA:
    LV_LOG_MESSAGE TYPE STRING,
    LS_RESULT_OUT_SIG LIKE LINE OF RESULT_OUT_SIG,
    LS_HEADER_OUT_SIG LIKE LINE OF HEADER_OUT_SIG,
    LS_DETAIL_OUT_SIG LIKE LINE OF DETAIL_OUT_SIG,
    LV_FAIL_SI_COUNTER_STR TYPE STRING.

  MOVE-CORRESPONDING CHECK_SITEM TO LS_RESULT_OUT_SIG.
  LS_RESULT_OUT_SIG-SITEM_ID = SITEM_ID.
  LS_RESULT_OUT_SIG-SITEM_TYPE = 'Consistency'.             "#EC NOTEXT
  LS_RESULT_OUT_SIG-RETURN_CODE = SUBRC.
  APPEND LS_RESULT_OUT_SIG TO RESULT_OUT_SIG.

  LS_HEADER_OUT_SIG-SITEM_GUID = CHECK_SITEM-SITEM_GUID.
  LS_HEADER_OUT_SIG-NUMERATOR = 0.
  LS_HEADER_OUT_SIG-NAME = 'A'.
  LS_HEADER_OUT_SIG-VALUE = 'Consistency check failed'.     "#EC NOTEXT
  APPEND LS_HEADER_OUT_SIG TO HEADER_OUT_SIG.

  LS_DETAIL_OUT_SIG-SITEM_GUID = CHECK_SITEM-SITEM_GUID.
  LS_DETAIL_OUT_SIG-RETURN_CODE = SUBRC.
  LS_DETAIL_OUT_SIG-CHECK_SUB_ID = 0.
  LS_DETAIL_OUT_SIG-INDEX = 0.
  CONCATENATE 'RFC return code:' SUBRC '-' RFC_ERROR        "#EC NOTEXT
    INTO LS_DETAIL_OUT_SIG-DESCRIPTION SEPARATED BY SPACE.
  APPEND LS_DETAIL_OUT_SIG TO DETAIL_OUT_SIG.

  LV_FAIL_SI_COUNTER_STR = FAIL_SI_COUNTER.
  CONCATENATE
    'Error occured in RFC Function:' FUNCNAME               "#EC NOTEXT
    'RFC:' RFC 'Count:' LV_FAIL_SI_COUNTER_STR
    INTO LV_LOG_MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.

  LV_LOG_MESSAGE = LS_DETAIL_OUT_SIG-DESCRIPTION.
  PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_TRUE.

ENDFORM.                    "HANDLE_FAIL_SI_RUN

*&---------------------------------------------------------------------*
*&      Form  S4_SI_CONSISTENCY_RUN_PARSE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM S4_SI_CONSISTENCY_RUN_PARSE TABLES LT_RESULT_OUT_SIG TYPE
                                        TY_CONSIS_CHK_RESULT_OUT_TAB
                                        LT_HEADER_OUT_SIG TYPE
                                        TY_CONSIS_CHK_HEADER_OUT_TAB
                                        LT_DETAIL_OUT_SIG TYPE
                                        TY_CONSIS_CHK_DETAILS_OUT_TAB
                                        LT_REL_CHK_RESULT TYPE
                                        TY_RC_RELE_CHK_RESULT_TAB
                                  USING LV_RESULT_XSTR TYPE XSTRING
                                        LV_ITEM_GUID TYPE GUID_32
                                  CHANGING LS_CHECK_SITEM TYPE
                                           TY_RC_RELE_CHK_RESULT_STR.

  DATA: LT_PARAMETER TYPE TIHTTPNVP,
        LV_STRING    TYPE STRING.

  DATA LS_REL_CHK_RESULT TYPE TY_RC_RELE_CHK_RESULT_STR.

  DATA LS_RESULT_SIG             TYPE TY_CONSIS_CHK_RESULT_STR.
  DATA LT_RESULT_SIG_DETAILS     TYPE TY_PRE_CONS_CHK_RESULT_TAB.

  DATA: LS_RESULT_OUT_SIG TYPE TY_CONSIS_CHK_RESULT_OUT_STR,
        LS_HEADER_OUT_SIG TYPE TY_CONSIS_CHK_HEADER_OUT_STR,
        LS_DETAIL_OUT_SIG TYPE TY_CONSIS_CHK_DETAILS_OUT_STR.

  DATA: LV_NUMERATOR TYPE I.

  FIELD-SYMBOLS: <FS_RESULT_SIG> TYPE TY_CONSIS_CHK_RESULT_STR.
  FIELD-SYMBOLS: <FS_RESULT_SIG_DETAILS> TYPE TY_PRE_CONS_CHK_RESULT_STR
                .
  FIELD-SYMBOLS: <FS_HEADER_INFO_TABLE> TYPE IHTTPNVP.
  FIELD-SYMBOLS: <FS_DETAIL> TYPE STRING.

  CALL TRANSFORMATION ID
              SOURCE XML LV_RESULT_XSTR
              RESULT CHECK_RESULT = LS_RESULT_SIG.

  MOVE-CORRESPONDING LS_RESULT_SIG TO LS_RESULT_OUT_SIG.
  LS_RESULT_OUT_SIG-SITEM_TYPE = 'Consistency'.             "#EC NOTEXT

* Append to Header Out
  CLEAR: LV_NUMERATOR, LS_HEADER_OUT_SIG.
  LOOP AT LS_RESULT_SIG-HEADER_INFO_TABLE ASSIGNING
  <FS_HEADER_INFO_TABLE>.

    LS_HEADER_OUT_SIG-SITEM_GUID = LS_CHECK_SITEM-SITEM_GUID.
    LS_HEADER_OUT_SIG-NUMERATOR = LV_NUMERATOR.
    LS_HEADER_OUT_SIG-NAME = <FS_HEADER_INFO_TABLE>-NAME.
    LS_HEADER_OUT_SIG-VALUE = <FS_HEADER_INFO_TABLE>-VALUE.
    APPEND LS_HEADER_OUT_SIG TO LT_HEADER_OUT_SIG.

    ADD 1 TO LV_NUMERATOR.
  ENDLOOP.

  CLEAR LV_NUMERATOR.

* Append to Details Tab
  CLEAR: LV_NUMERATOR, LS_DETAIL_OUT_SIG.
  IF NOT LS_RESULT_SIG-CHK_CLAS_RESULT_XSTR IS INITIAL.
    CALL TRANSFORMATION ID
      SOURCE XML LS_RESULT_SIG-CHK_CLAS_RESULT_XSTR
      RESULT CLAS_CHK_RESULT = LT_RESULT_SIG_DETAILS.

    LOOP AT LT_RESULT_SIG_DETAILS ASSIGNING
    <FS_RESULT_SIG_DETAILS>.

      LV_NUMERATOR = LV_NUMERATOR + 1.

      LS_DETAIL_OUT_SIG-SITEM_GUID = LS_CHECK_SITEM-SITEM_GUID.
      LS_DETAIL_OUT_SIG-RETURN_CODE =
      <FS_RESULT_SIG_DETAILS>-RETURN_CODE.
      LS_DETAIL_OUT_SIG-CHECK_SUB_ID =
      <FS_RESULT_SIG_DETAILS>-CHECK_SUB_ID.
      LS_DETAIL_OUT_SIG-INDEX = LV_NUMERATOR.

      LOOP AT <FS_RESULT_SIG_DETAILS>-DESCRIPTIONS ASSIGNING
      <FS_DETAIL>.
        IF SY-TABIX <> 1.

          CONCATENATE LS_DETAIL_OUT_SIG-DESCRIPTION <FS_DETAIL>
          INTO LS_DETAIL_OUT_SIG-DESCRIPTION SEPARATED BY '{CRLF}'.

        ELSEIF SY-TABIX = 1.

          LS_DETAIL_OUT_SIG-DESCRIPTION = <FS_DETAIL>.

        ENDIF.

      ENDLOOP.

      APPEND LS_DETAIL_OUT_SIG TO LT_DETAIL_OUT_SIG.

    ENDLOOP.
  ENDIF.

  CLEAR LS_REL_CHK_RESULT.
  READ TABLE LT_REL_CHK_RESULT INTO LS_REL_CHK_RESULT WITH KEY
  SITEM_GUID = LV_ITEM_GUID.

  MOVE-CORRESPONDING LS_REL_CHK_RESULT TO LS_RESULT_OUT_SIG.
  APPEND LS_RESULT_OUT_SIG TO LT_RESULT_OUT_SIG.

ENDFORM.                    " S4_SI_CONSISTENCY_RUN_PARSE

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_S4HANA_ATC_CHECKS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_S4HANA_ATC_CHECKS .

  DATA:
    LV_STARTTIME TYPE SY-UZEIT,
    LV_STARTDATE TYPE SY-DATUM.

  DATA: LT_RESULT_TABLE_S4    TYPE TT_S4HANA_ATC_CHECK.
  DATA: LT_RESULT_TABLE_HANA  TYPE TT_HANAA_SCI_CHECK.
  DATA: LV_ATC_DATE TYPE DATS.

  DATA: LV_IS_SUCCESS          TYPE FLAG.

  " Check if need to extract sci hana checks.
  IF EXTRACT_ATC_S4_CHECK EQ ABAP_FALSE.
    RETURN.
  ENDIF.

  GET TIME.
  LV_STARTTIME = SY-UZEIT.
  LV_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
    USING
     'Extracting S/4 HANA Convertion ATC Checks'. "#EC NOTEXT

  IF C_ATCRES EQ ABAP_TRUE.
    " Get Hana code Inspector table data.
    PERFORM GET_S4HANA_ATC_DATA
      CHANGING
        LT_RESULT_TABLE_S4
        LT_RESULT_TABLE_HANA
        LV_IS_SUCCESS.


    PERFORM EXPORT_S4_ATC_CHECKS_TO_XML TABLES LT_RESULT_TABLE_S4
                                               LT_RESULT_TABLE_HANA.

    FREE LT_RESULT_TABLE_S4.
    FREE LT_RESULT_TABLE_HANA.

  ENDIF.


  " Add notification, if error occur.
  IF LV_IS_SUCCESS EQ ABAP_FALSE.
    GT_ETL_MESSAGE-MESSAGE =
    'Error occurred while extracting S/4 HANA ATC Checks'. "#EC NOTEXT

    PERFORM ADD_NOTIFICATION USING SCI_HANA_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                    GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  PERFORM ADD_TIME_STAT
  USING
    'Extracting S/4 HANA Convertion ATC Checks' "#EC NOTEXT
    LV_STARTTIME
    LV_STARTDATE.

ENDFORM.                    "extract_s4hana_atc_checks

*&---------------------------------------------------------------------*
*&      Form  GET_S4HANA_ATC_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LT_ALL_RESULT_TABLE  text
*      <--P_LV_IS_SUCCESS  text
*----------------------------------------------------------------------*
FORM GET_S4HANA_ATC_DATA   CHANGING
     CT_RESULT_TABLE_S4    TYPE TT_S4HANA_ATC_CHECK
     CT_RESULT_TABLE_FUNC  TYPE TT_HANAA_SCI_CHECK
     CV_IS_SUCCESS         TYPE FLAG.

  DATA:
    LV_COUNT      TYPE STRING,
    LV_IS_SUCCESS TYPE FLAG.

  CLEAR CT_RESULT_TABLE_S4[].
  CLEAR CT_RESULT_TABLE_FUNC[].

  DATA LT_METADATA TYPE TT_CHECK_METADATA.
  DATA LT_METADATA_KEY TYPE TT_CHECK_METADATA_KEY.
  DATA LS_METADATA TYPE ST_CHECK_METADATA.
  DATA LS_MESSAGE  TYPE ST_MSG_METADATA.

  DATA LT_RESULTS           TYPE TT_SCIR_REST.
  DATA LS_RESULT            TYPE ST_SCIR_REST.
  DATA LT_RESULTS_EXTENSION TYPE TT_FINDING_EXTENSION.
  DATA LS_RESULTS_EXTENSION TYPE ST_FINDING_EXTENSION.
  DATA LV_READ_ERRORS       TYPE I.
  DATA LV_TOTAL_FINDINGS    TYPE I.
  DATA LV_HAS_MORE          TYPE SAP_BOOL.

  DATA: LS_RESULT_TABLE_S4    TYPE TS_S4HANA_ATC_CHECK.
  DATA: LS_RESULT_TABLE_FUNC  TYPE TS_HANAA_SCI_CHECK.

  DATA: LT_FINAL TYPE TT_S4HANA_ATC_CHECK,
        LS_FINAL TYPE TS_S4HANA_ATC_CHECK.

  DATA: LV_STRING TYPE STRING.

  DATA: LV_GUID TYPE SYSUUID_X.

  CALL FUNCTION 'SATC_CI_GET_CHECK_METADATA' DESTINATION P_AT_RFC
    IMPORTING
      E_METADATA            = LT_METADATA
    EXCEPTIONS
      NOT_AUTHORIZED        = 1
      SYSTEM_FAILURE        = 98  "MESSAGE msg
      COMMUNICATION_FAILURE = 99  "MESSAGE msg
      OTHERS                = 2.

  IF SY-SUBRC <> 0.
    GT_ETL_MESSAGE-MESSAGE =
    'Error occurred while trying to extract ATC checks'. "#EC NOTEXT

    PERFORM ADD_NOTIFICATION USING ATC_S4_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                    GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    MESSAGE A000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
    RETURN.
  ENDIF.

  LOOP AT LT_METADATA INTO LS_METADATA.
    INSERT LS_METADATA INTO TABLE LT_METADATA_KEY.
  ENDLOOP.
  FREE LT_METADATA.

  LV_GUID = P_AT_GID.

  CALL FUNCTION 'SATC_CI_GET_RESULT' DESTINATION P_AT_RFC
    EXPORTING
      I_RESULT_ID           = LV_GUID
    IMPORTING
      E_RESULTS             = LT_RESULTS
      E_RESULTS_EXTENSION   = LT_RESULTS_EXTENSION
      E_READ_ERRORS         = LV_READ_ERRORS
      E_TOTAL_FINDINGS      = LV_TOTAL_FINDINGS
      E_HAS_MORE            = LV_HAS_MORE
    EXCEPTIONS
      NOT_AUTHORIZED        = 1
      INVALID_RESULT_ID     = 2
      SYSTEM_FAILURE        = 98  "MESSAGE msg
      COMMUNICATION_FAILURE = 99  "MESSAGE msg
      OTHERS                = 3.

  IF SY-SUBRC <> 0.
    GT_ETL_MESSAGE-MESSAGE =
    'Error occurred while trying to extract ATC checks'. "#EC NOTEXT

    PERFORM ADD_NOTIFICATION USING ATC_S4_ERROR_EXECUTE
                    LV_NOTIFICATION_PARAM
                    GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    MESSAGE A000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
    RETURN.

  ENDIF.

  LOOP AT LT_RESULTS INTO LS_RESULT.

    CLEAR: LV_STRING, LS_FINAL.

    READ TABLE LT_RESULTS_EXTENSION INTO LS_RESULTS_EXTENSION INDEX
      SY-TABIX.

    MOVE-CORRESPONDING LS_RESULT TO LS_FINAL.

    LS_FINAL-DEVCLASS = LS_RESULTS_EXTENSION-PACKAGE_NAME.
    LS_FINAL-AUTHOR = LS_RESULTS_EXTENSION-CONTACT_PERSON.

    LOOP AT LS_RESULTS_EXTENSION-DESCRIPTION_LINES INTO LV_STRING.
      CONCATENATE LS_FINAL-DESCRIPTION_LINES LV_STRING INTO
      LS_FINAL-DESCRIPTION_LINES SEPARATED BY SPACE.
    ENDLOOP.

    READ TABLE LT_METADATA_KEY INTO LS_METADATA
      WITH TABLE KEY CLASS = LS_RESULT-TEST.

    LS_FINAL-DESCRIPTION = LS_METADATA-TITLE.
    READ TABLE LS_METADATA-MESSAGES INTO LS_MESSAGE WITH KEY CODE =
    LS_RESULT-CODE.
    LS_FINAL-TEXT = LS_MESSAGE-TITLE.

    IF LS_FINAL-DESCRIPTION CP 'S/4HANA:*'.

      MOVE-CORRESPONDING LS_FINAL TO LS_RESULT_TABLE_S4.
      LS_RESULT_TABLE_S4-ZZVARIANT = C_S4HANA_READINESS.

      APPEND LS_RESULT_TABLE_S4 TO CT_RESULT_TABLE_S4.
    ELSE.

      MOVE-CORRESPONDING LS_FINAL TO LS_RESULT_TABLE_FUNC.
      LS_RESULT_TABLE_FUNC-ZZVARIANT = C_FUNCTIONAL_DB.

      APPEND LS_RESULT_TABLE_FUNC TO CT_RESULT_TABLE_FUNC.

    ENDIF.

  ENDLOOP.

  LV_COUNT = LINES( CT_RESULT_TABLE_S4 ) + LINES( CT_RESULT_TABLE_FUNC )
  .
  CONCATENATE
'Extracting S/4 HANA Convertion ' "#EC NOTEXT
'Checks - Total number of entries:' "#EC NOTEXT
    LV_COUNT
    INTO GT_ETL_MESSAGE-MESSAGE
    SEPARATED BY SPACE.

  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  CV_IS_SUCCESS = ABAP_TRUE.

ENDFORM.                    "get_s4hana_atc_data

*&---------------------------------------------------------------------*
*&      Form  EXPORT_S4_ATC_CHECKS_TO_XML
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_RESULT_TABLE_S4  text
*      -->P_LT_RESULT_TABLE_HANA  text
*----------------------------------------------------------------------*
FORM EXPORT_S4_ATC_CHECKS_TO_XML TABLES LT_RESULT_TABLE_S4 TYPE
                                  TT_S4HANA_ATC_CHECK
                                  LT_RESULT_TABLE_HANA TYPE
                                  TT_HANAA_SCI_CHECK.

  DATA: LV_STRING TYPE STRING.

  DATA: LV_INDEX TYPE I,
        LV_CHUNK TYPE I.

  DATA: LT_CHUNK_TABLE_S4 TYPE TT_S4HANA_ATC_CHECK,
        LT_CHUNK_TABLE_HANA TYPE TT_HANAA_SCI_CHECK.

  FIELD-SYMBOLS: <FT_CHUNK_TABLE_S4> TYPE TS_S4HANA_ATC_CHECK,
                 <FT_CHUNK_TABLE_HANA> TYPE TS_HANAA_SCI_CHECK.

  LV_STRING = '<ATC_S4HANA_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LV_STRING = '<ATC_S4HANA_READINESS_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LOOP AT LT_RESULT_TABLE_S4
    ASSIGNING <FT_CHUNK_TABLE_S4>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <FT_CHUNK_TABLE_S4> TO LT_CHUNK_TABLE_S4.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_RESULT_TABLE_S4 ).

      " Add result SI relevancy to XML.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_CHUNK_TABLE_S4
        USING
          G_IREF_PDOCUMENT
          'ATC_S4HANA_READINESS_ISSUE'.

      FREE LT_CHUNK_TABLE_S4.
    ENDIF.

  ENDLOOP.
  CLEAR: LV_INDEX, LV_CHUNK.


  LV_STRING = '</ATC_S4HANA_READINESS_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LV_STRING = '<ATC_S4HANA_FUNCTIONAL_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.


  LOOP AT LT_RESULT_TABLE_HANA
  ASSIGNING <FT_CHUNK_TABLE_HANA>.

    LV_INDEX = LV_INDEX + 1.
    LV_CHUNK = LV_INDEX MOD WARN_TABLE_SIZE.

    APPEND <FT_CHUNK_TABLE_HANA> TO LT_CHUNK_TABLE_HANA.

    IF LV_CHUNK = 0 OR
       LV_INDEX = LINES( LT_RESULT_TABLE_HANA ).

      " Add result SI relevancy to XML.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_CHUNK_TABLE_HANA
        USING
          G_IREF_PDOCUMENT
          'ATC_S4HANA_FUNCTIONAL_ISSUE'.

      FREE LT_CHUNK_TABLE_HANA.
    ENDIF.

  ENDLOOP.
  CLEAR: LV_INDEX, LV_CHUNK.


  LV_STRING = '</ATC_S4HANA_FUNCTIONAL_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

  LV_STRING = '</ATC_S4HANA_ISSUES>'.

  PERFORM APPEND_STRING_TO_FILE
    USING
      LV_STRING.

ENDFORM.                    " EXPORT_S4_ATC_CHECKS_TO_XML


*&---------------------------------------------------------------------*
*& Form extract_hana_sizing_result
*&---------------------------------------------------------------------*
FORM EXTRACT_HANA_SIZING_RESULT.

  DATA:
    LV_STARTTIME  TYPE SY-UZEIT,
    LV_STARTDATE  TYPE SY-DATUM,
    LT_RESULTS    TYPE STRINGTAB.

  IF EXTRACT_HN_SIZING_CHECK = ABAP_FALSE OR PSRV_HN IS INITIAL.
    RETURN.
  ENDIF.

  GET TIME.
  LV_STARTTIME = SY-UZEIT.
  LV_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting HANA sizing report results'. "#EC NOTEXT

  PERFORM GET_HANA_SIZING_DATA_FROM_SRVR
    USING PSRV_HN
    CHANGING LT_RESULTS.

  PERFORM EXPORT_HANA_SIZING_DATA_TO_XML
    TABLES LT_RESULTS.

  PERFORM ADD_TIME_STAT
    USING
      'Extracting S/4 HANA sizing report results' "#EC NOTEXT
      LV_STARTTIME
      LV_STARTDATE.

ENDFORM.                    "extract_hana_sizing_result

*&---------------------------------------------------------------------*
*& Form get_hana_sizing_data_from_srvr
*&---------------------------------------------------------------------*
FORM GET_HANA_SIZING_DATA_FROM_SRVR
  USING IV_SERVER_FILE_NAME
  CHANGING CT_RESULT TYPE STRINGTAB.

  DATA:
    LV_WA TYPE STRING.

  OPEN DATASET IV_SERVER_FILE_NAME FOR INPUT IN TEXT MODE
    ENCODING UTF-8.

  IF SY-SUBRC <> 0.
    CONCATENATE
      'Extracting HANA sizing report result failed.' "#EC NOTEXT
      'Could not open file:' "#EC NOTEXT
      IV_SERVER_FILE_NAME
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    EXIT.
  ENDIF.

  DO.
    READ DATASET IV_SERVER_FILE_NAME INTO LV_WA.
    IF SY-SUBRC = 0.
      APPEND LV_WA TO CT_RESULT.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.

  CLOSE DATASET IV_SERVER_FILE_NAME.
  DELETE DATASET IV_SERVER_FILE_NAME.

ENDFORM.                    "get_hana_sizing_data_from_srvr

*&---------------------------------------------------------------------*
*& Form export_hana_sizing_data_to_xml
*&---------------------------------------------------------------------*
FORM EXPORT_HANA_SIZING_DATA_TO_XML
  TABLES IT_HANA_SIZING_DATA TYPE STRINGTAB.

  DATA: SIZING_REPORT_NODE    TYPE XML_ELEMENT,
        SIZING_REPORT_HANDLER TYPE HANDLES_TYPE,
        CDATA_ELEM            TYPE REF TO IF_IXML_ELEMENT,
        IS_FIRST              TYPE BOOLEAN,
        LV_RESULT_LIST_WA     LIKE LINE OF IT_HANA_SIZING_DATA,
        LV_RESULT_LIST_STRING TYPE STRING.

  PERFORM CREATE_XML_NODE
    USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
          'HANA_SIZING_REPORT'
    CHANGING SIZING_REPORT_NODE.

  LOOP AT IT_HANA_SIZING_DATA INTO LV_RESULT_LIST_WA.
    REPLACE ALL OCCURRENCES OF ']]>' IN LV_RESULT_lIST_WA
      WITH CDATA_END_REPLACE.
    REPLACE '?XML' WITH '&XML_START_TAG&' INTO LV_RESULT_LIST_WA.
    REPLACE '?xml' WITH '&XML_START_TAG&' INTO LV_RESULT_LIST_WA.

    IF IS_FIRST IS INITIAL.
      LV_RESULT_LIST_STRING = LV_RESULT_LIST_WA.
      IS_FIRST = 'X'.
    ELSE.
      CONCATENATE LV_RESULT_LIST_STRING LV_RESULT_LIST_WA
        INTO LV_RESULT_LIST_STRING
        SEPARATED BY GV_ENDLINE.
    ENDIF.
  ENDLOOP.

  PERFORM CREATE_XML_NODE_VALUE_CDATA
    USING G_IREF_PDOCUMENT
          SIZING_REPORT_NODE
          'RESULTS'
          LV_RESULT_LIST_STRING
          'X'
    CHANGING CDATA_ELEM.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING SIZING_REPORT_NODE 'X'.

ENDFORM.                    " export_hana_sizing_data_to_xml

*&---------------------------------------------------------------------*
*&      Form  ADD_WD_DATA
*&---------------------------------------------------------------------*
*      add web dynpro data
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_WD_DATA .

  DATA:
    OBJNAME                  TYPE TADIR-OBJ_NAME,
    COMPO_INTER_INDEX_START  TYPE SY-TABIX,
    COMPO_INTER_INDEX_END    TYPE SY-TABIX,
    APP_CONFIG_START_INDEX   TYPE SY-TABIX,
    APP_CONFIG_END_INDEX     TYPE SY-TABIX,
    COMPO_SYNTAX_INDEX_END   TYPE SY-TABIX,
    COMPO_SYNTAX_INDEX_START TYPE SY-TABIX,
    WD_CHECK_RESULTS_WA      LIKE LINE OF WD_CHECK_RESULTS_TAB,
    WD_CUST_APP_NODE         TYPE REF TO IF_IXML_ELEMENT,
    APP_START_INDEX          TYPE SY-TABIX,
    APP_END_INDEX            TYPE SY-TABIX,
    APP_PROP_START_INDEX     TYPE SY-TABIX,
    APP_PROP_END_INDEX       TYPE SY-TABIX,
    DESC_START_INDEX         TYPE I,
    DESC_END_INDEX           TYPE I,
    LV_STARTTIME             TYPE SY-UZEIT,
    LV_STARTDATE             TYPE SY-DATUM.

  GET TIME.
  LV_STARTTIME = SY-UZEIT.
  LV_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
    USING
     'Extracting Web Dyndpro Data'. "#EC NOTEXT

*  Select web dynpro data
  PERFORM SELECT_WD_DATA.

* Create a child node for the Header node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'WDA_OBJECTS'
                          CHANGING WD_HEADER_NODE.

* Add cust app for std comps
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_HEADER_NODE
                                'WDA_CUST_APPS_FOR_STD_OBJ'
                          CHANGING WD_CUST_APP_FOR_STD_CMP_NODE.

* Add devclass for custapps of std comps
  LOOP AT WDY_CUST_FOR_SAP_APPS_TAB INTO WDY_CUST_FOR_SAP_APPS_WA.

    PERFORM CREATE_XML_NODE
    USING G_IREF_PDOCUMENT
          WD_CUST_APP_FOR_STD_CMP_NODE
                                  'WDY_CUST_APP_FOR_STD_COMP'
                            CHANGING WD_CUST_APP_NODE.

    PERFORM ADD_ALL_ATTRIBUTES_TO_NODE USING
      WD_CUST_APP_NODE WDY_CUST_FOR_SAP_APPS_WA.

    READ TABLE GT_TADIR
    WITH KEY OBJ_NAME =
    WDY_CUST_FOR_SAP_APPS_WA-APPLICATION_NAME
                               OBJECT   = 'WDYA'
                               INTO GS_TADIR.

    IF SY-SUBRC EQ 0.

      PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                     WD_CUST_APP_NODE
                      'DEVCLASS'
                      GS_TADIR-DEVCLASS
                      .
    ENDIF.

  ENDLOOP.

* Add app property for standard components
  PERFORM ADD_ITAB_TO_XML_SIMPLE
  TABLES
     WDY_CU_APP_PROPERTY_TAB
  USING
     G_IREF_PDOCUMENT
     WD_CUST_APP_FOR_STD_CMP_NODE
     'WDY_CUST_APP_PROPERTY_FOR_STD_COMP'.

* Add cust app configs for standard apps
  PERFORM ADD_ITAB_TO_XML_SIMPLE
  TABLES
     WDY_CONFIG_CU_APPL_FS_TAB
  USING
     G_IREF_PDOCUMENT
     WD_CUST_APP_FOR_STD_CMP_NODE
     'WDY_CUST_APP_CONFIG_FOR_STD_COMP'.

* Add descriptions
  PERFORM ADD_ITAB_TO_XML_SIMPLE
  TABLES
     WDY_APPLICATIION_CU_DESC_TAB
  USING
     G_IREF_PDOCUMENT
     WD_CUST_APP_FOR_STD_CMP_NODE
     'WDY_CUST_APP_DESC_FOR_STD_COMP'.

  LOOP AT WDY_COMPONENT_TAB INTO WDY_COMPONENT_WA.

*   Create a child node for the Header node
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_HEADER_NODE
                                'WDA_COMPONENT'
                          CHANGING WD_COMPS_NODE.


*   Find devclass
    OBJNAME = WDY_COMPONENT_WA-COMPONENT_NAME.
    READ TABLE GT_TADIR WITH KEY OBJ_NAME = OBJNAME
                                 OBJECT   = 'WDYN'
                                 INTO GS_TADIR.
*    Check if it is intf
    IF SY-SUBRC <> 0.

      READ TABLE GT_TADIR WITH KEY OBJ_NAME = OBJNAME
                                   OBJECT   = 'INTF'
                                   INTO GS_TADIR.

*     Still no success, attempt to find IWCI_ old objects
*     this used to be a sap naming convention
      IF SY-SUBRC <> 0.

        CONCATENATE 'IWCI_' OBJNAME INTO OBJNAME.

        READ TABLE GT_TADIR WITH KEY OBJ_NAME = OBJNAME
                                   OBJECT   = 'INTF'
                                   INTO GS_TADIR.

      ENDIF.

    ENDIF.

*   Add devclass data if it exists
    IF GS_TADIR IS NOT INITIAL.

      PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                     WD_COMPS_NODE
                      'DEVCLASS'
                      GS_TADIR-DEVCLASS
                      .
    ENDIF.

*   add all attributes to node
    PERFORM ADD_ALL_ATTRIBUTES_TO_NODE
    USING WD_COMPS_NODE WDY_COMPONENT_WA.

*   Add comp descriptions
    PERFORM ADD_COMP_DESCRIPTIONS_TO_XML
      USING WDY_COMPONENT_WA.


*   Read the check results
    READ TABLE WD_CHECK_RESULTS_TAB TRANSPORTING NO FIELDS WITH KEY
      OBJNAME = WDY_COMPONENT_WA-COMPONENT_NAME BINARY SEARCH.

    IF SY-SUBRC EQ 0.

      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_COMPS_NODE
                                  'SYNTAX_ERRORS'
                            CHANGING WD_COMP_SYNTAX_ERRORS_NODE.

*      store sy-tabix
      COMPO_SYNTAX_INDEX_START = SY-TABIX.

      LOOP AT WD_CHECK_RESULTS_TAB INTO WD_CHECK_RESULTS_WA FROM
      COMPO_SYNTAX_INDEX_START.

        AT END OF OBJNAME.
          COMPO_SYNTAX_INDEX_END = SY-TABIX.
          APPEND LINES OF WD_CHECK_RESULTS_TAB
          FROM COMPO_SYNTAX_INDEX_START TO COMPO_SYNTAX_INDEX_END TO
          WD_CHECK_RESULTS_TAB_LOCAL.

          PERFORM ADD_ITAB_TO_XML_SIMPLE
            TABLES
               WD_CHECK_RESULTS_TAB_LOCAL
            USING
               G_IREF_PDOCUMENT
               WD_COMP_SYNTAX_ERRORS_NODE
               'WD_SYNTAX_ERROR'.

          FREE WD_CHECK_RESULTS_TAB_LOCAL.
          EXIT.

        ENDAT.
      ENDLOOP.

    ENDIF.

*   Add component usages
    PERFORM ADD_COMP_USAGE_DATA_TO_XML USING WDY_COMPONENT_WA.

*   add interface implementations
    PERFORM ADD_INTERFACE_IMPL_DATA_TO_XML
      USING WDY_COMPONENT_WA.

*   Add controller data
    PERFORM ADD_WD_CONTROLLER_DATA_TO_XML USING WDY_COMPONENT_WA.

*   Add all data related to application
    PERFORM ADD_APPLICATION_DATA_TO_XML USING WDY_COMPONENT_WA.

    FREE WD_COMPS_NODE.
    FREE WD_CUSTOM_CTRL_HEADER_NODE.

  ENDLOOP. " LOOP AT wdy_component_tab INTO wdy_component_wa.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                 WD_HEADER_NODE 'X'.

  FREE: WDY_CONTROLLER_TAB , WDY_CONTROLLER_DESC_TAB ,
  WDY_COMPO_USAGE_TAB , WDY_COMPO_USAGE_TAB_LOCAL ,
  WDY_INTF_IMPLEM_TAB ,
  WDY_INTF_IMPLEM_TAB_LOCAL , WDY_CTLR_COMPO_TAB ,
  WDY_CONFIG_APPL_TAB ,
  WDY_APP_PROPERTY_TAB , WDY_COMPONENT_TAB , WDY_APP_PROPERTY_TAB ,
  WDY_COMPONENT_TAB , WDY_COMPONENT_DESC_TAB , WDY_CTLR_PARAM_TAB ,
  WDY_CTLR_COMPO_DESC_TAB , SINGLE_METHOD_PARAM_TAB .

  PERFORM ADD_TIME_STAT
    USING
      'Extracting Web Dyndpro Data'  "#EC NOTEXT
      LV_STARTTIME
      LV_STARTDATE.

ENDFORM.                    " ADD_WD_DATA
*&---------------------------------------------------------------------*
*&      Form  SELECT_WD_DATA
*&---------------------------------------------------------------------*
*       select wd relevant data and do SCI check
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM SELECT_WD_DATA .

* Get devclass data
  PERFORM GET_DEV_CLASS_DATA.

  REFRESH GT_TADIR[].

* Read only WD ABAP componenets
  IF NOT LT_TDEVC[] IS INITIAL.
    SELECT * FROM TADIR
    APPENDING TABLE GT_TADIR
    FOR ALL ENTRIES IN LT_TDEVC
    WHERE DEVCLASS = LT_TDEVC-DEVCLASS
    AND  PGMID     EQ 'R3TR' AND OBJECT IN ('WDYN', 'WDYA', 'INTF',
    'WDCA').
    " ('WDYC', 'WDYD', 'WDYV', 'WDCA', 'WDCC', 'WDYA', 'WDYN' ).
  ENDIF.

* DO WEB DYNPRO SCI
  PERFORM RUN_WD_SCI CHANGING WD_CHECK_RESULTS_TAB .

  REFRESH LT_TDEVC[].
  REFRESH COMP_NAME_TAB_RA[].

  COMP_NAME_TAB_RA_WA-SIGN = 'I'.
  APP_NAME_TAB_RA_WA-SIGN = 'I'.
  APP_NAME_TAB_RA_WA-OPTION = 'EQ'.
  COMP_NAME_TAB_RA_WA-OPTION = 'EQ'.

* Build TADIR objects
  LOOP AT GT_TADIR INTO GS_TADIR.
    COMP_NAME_WA = GS_TADIR-OBJ_NAME.

*   Build object name range
    IF GS_TADIR-OBJECT = 'INTF'.

*   sometimes webdyn objects are actually interfaces with iwci prefix
      REPLACE ALL OCCURRENCES
      OF SUBSTRING 'IWCI_' IN COMP_NAME_WA
      WITH ''.
      IF SY-SUBRC EQ 0.
        APPEND COMP_NAME_WA TO COMP_NAME_TAB.
        COMP_NAME_TAB_RA_WA-LOW = COMP_NAME_WA.
        APPEND COMP_NAME_TAB_RA_WA TO COMP_NAME_TAB_RA.
      ENDIF.
    ELSEIF GS_TADIR-OBJECT = 'WDYN'.
      APPEND COMP_NAME_WA TO COMP_NAME_TAB.
      COMP_NAME_TAB_RA_WA-LOW = COMP_NAME_WA.
      APPEND COMP_NAME_TAB_RA_WA TO COMP_NAME_TAB_RA.
    ELSEIF GS_TADIR-OBJECT = 'WDYA'.
      COMP_WDY_CUST_WA = GS_TADIR-OBJ_NAME.
      APP_NAME_TAB_RA_WA-LOW = COMP_WDY_CUST_WA.

*     Also build a range of custom applications
      APPEND APP_NAME_TAB_RA_WA TO APP_NAME_TAB_RA.
      APPEND COMP_WDY_CUST_WA TO COMP_WDY_CUST_TAB.
    ELSEIF GS_TADIR-OBJECT = 'WDCA'.
      CUST_APP_CONFIGS_WA = GS_TADIR-OBJ_NAME.
      APPEND CUST_APP_CONFIGS_WA TO CUST_APP_CONFIGS_TAB.
    ENDIF.

  ENDLOOP.

  CHECK COMP_NAME_TAB[] IS NOT INITIAL.

* Select all data from tables:
  SELECT * FROM WDY_CTLR_COMPOT INTO TABLE WDY_CTLR_COMPO_DESC_TAB FOR
  ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE .

  SORT WDY_CTLR_COMPO_DESC_TAB BY
  COMPONENT_NAME CONTROLLER_NAME CMPNAME.

* Select components
  SELECT * FROM WDY_COMPONENT INTO TABLE WDY_COMPONENT_TAB FOR ALL
  ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE AND VERSION = 'A'.

* Controller parameters
  SELECT * FROM   WDY_CTLR_PARAM INTO TABLE   WDY_CTLR_PARAM_TAB FOR ALL
  ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE
    AND VERSION = 'A'.

* Component Usages
  SELECT * FROM WDY_COMPO_USAGE INTO TABLE WDY_COMPO_USAGE_TAB FOR ALL
  ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE
    AND VERSION = 'A'.

  SORT WDY_COMPO_USAGE_TAB BY COMPONENT_NAME COMPO_USAGE_NAME VERSION.

* interface implementations
  SELECT * FROM WDY_INTF_IMPLEM INTO TABLE WDY_INTF_IMPLEM_TAB FOR ALL
  ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE
    AND VERSION = 'A'.

  SORT WDY_INTF_IMPLEM_TAB BY COMPONENT_NAME.

* controllers
  SELECT * FROM  WDY_CTLR_COMPO INTO TABLE  WDY_CTLR_COMPO_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE AND CMPTYPE =
    'CL_WDY_MD_CONTROLLER_METHOD' AND VERSION = 'A'.

  SORT WDY_CTLR_COMPO_TAB BY COMPONENT_NAME CONTROLLER_NAME CMPNAME.

  SELECT * FROM WDY_CONTROLLERT INTO TABLE WDY_CONTROLLER_DESC_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE .

* contrllers data
  SELECT * FROM WDY_CONTROLLER INTO TABLE WDY_CONTROLLER_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE AND VERSION = 'A'.

  SORT WDY_CONTROLLER_TAB BY COMPONENT_NAME.

* component descriptions
  SELECT * FROM WDY_COMPONENTT INTO TABLE WDY_COMPONENT_DESC_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE.

  SORT WDY_COMPONENT_DESC_TAB BY COMPONENT_NAME.

* views
  SELECT * FROM WDY_VIEW INTO TABLE WDY_VIEW_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT_NAME = COMP_NAME_TAB-TABLE_LINE AND VERSION = 'A'.

  SORT WDY_VIEW_TAB BY COMPONENT_NAME.

* applications
  SELECT * FROM WDY_APPLICATION INTO TABLE WDY_APPLICATION_TAB
    FOR ALL ENTRIES IN COMP_NAME_TAB
    WHERE COMPONENT = COMP_NAME_TAB-TABLE_LINE .

* store cust apps for standard comps
  LOOP AT WDY_APPLICATION_TAB INTO WDY_APPLICATION_WA.
    APPS_FOR_CUST_COMPS_WA-SIGN = 'I'.
    APPS_FOR_CUST_COMPS_WA-OPTION = 'EQ'.
    APPS_FOR_CUST_COMPS_WA-LOW = WDY_APPLICATION_WA-APPLICATION_NAME.
    APPEND APPS_FOR_CUST_COMPS_WA TO APPS_FOR_CUST_COMPS_RA.
  ENDLOOP.

  SORT WDY_APPLICATION_TAB BY COMPONENT.

  IF WDY_APPLICATION_TAB[] IS NOT INITIAL.

*   Config application
    SELECT * FROM WDY_CONFIG_APPL INTO TABLE WDY_CONFIG_APPL_TAB
      FOR ALL ENTRIES IN WDY_APPLICATION_TAB
      WHERE APPLICATION = WDY_APPLICATION_TAB-APPLICATION_NAME.

    SORT WDY_CONFIG_APPL_TAB BY APPLICATION ASCENDING.

    SELECT * FROM WDY_APP_PROPERTY INTO TABLE WDY_APP_PROPERTY_TAB
      FOR ALL ENTRIES IN WDY_APPLICATION_TAB
      WHERE APPLICATION_NAME = WDY_APPLICATION_TAB-APPLICATION_NAME.

    SORT WDY_APP_PROPERTY_TAB BY APPLICATION_NAME ASCENDING.

    SELECT * FROM WDY_APPLICATIONT INTO TABLE WDY_APPLICATION_DESC_TAB
      FOR ALL ENTRIES IN WDY_APPLICATION_TAB
      WHERE APPLICATION_NAME = WDY_APPLICATION_TAB-APPLICATION_NAME
      AND LANGU = SY-LANGU.

    SORT WDY_APPLICATION_DESC_TAB BY APPLICATION_NAME ASCENDING.

  ENDIF.

* Get cust apps for std components
  IF CUST_APP_CONFIGS_TAB[] IS NOT INITIAL.

    IF APPS_FOR_CUST_COMPS_RA[] IS NOT INITIAL.
      DELETE APP_NAME_TAB_RA WHERE LOW NOT IN APPS_FOR_CUST_COMPS_RA.
    ENDIF.

    SELECT * FROM WDY_CONFIG_APPL INTO
      TABLE WDY_CONFIG_CU_APPL_FS_TAB
      FOR ALL ENTRIES IN CUST_APP_CONFIGS_TAB
      WHERE CONFIG_ID = CUST_APP_CONFIGS_TAB-TABLE_LINE
            AND APPLICATION NOT IN APP_NAME_TAB_RA.
    .

    SORT WDY_CONFIG_CU_APPL_FS_TAB BY APPLICATION ASCENDING.

  ENDIF.

* Select custom apps for standard components
  IF COMP_WDY_CUST_TAB[] IS NOT INITIAL.

    SELECT * FROM WDY_APPLICATION INTO TABLE WDY_CUST_FOR_SAP_APPS_TAB
      FOR ALL ENTRIES IN COMP_WDY_CUST_TAB
      WHERE APPLICATION_NAME = COMP_WDY_CUST_TAB-TABLE_LINE
            AND COMPONENT NOT IN COMP_NAME_TAB_RA .


  ENDIF.

*---
  IF WDY_CUST_FOR_SAP_APPS_TAB[] IS NOT INITIAL.

    SELECT * FROM WDY_APP_PROPERTY INTO TABLE WDY_CU_APP_PROPERTY_TAB
      FOR ALL ENTRIES IN WDY_CUST_FOR_SAP_APPS_TAB
      WHERE APPLICATION_NAME =
      WDY_CUST_FOR_SAP_APPS_TAB-APPLICATION_NAME.

    SORT WDY_APP_PROPERTY_TAB BY APPLICATION_NAME.

    SELECT * FROM WDY_APPLICATIONT INTO TABLE
      WDY_APPLICATIION_CU_DESC_TAB
      FOR ALL ENTRIES IN WDY_CUST_FOR_SAP_APPS_TAB
      WHERE APPLICATION_NAME =
      WDY_CUST_FOR_SAP_APPS_TAB-APPLICATION_NAME.

  ENDIF.

  SORT WDY_APPLICATION_DESC_TAB BY APPLICATION_NAME.

ENDFORM.                    "select_wd_data

*&---------------------------------------------------------------------*
*&      Form  ADD_ALL_ATTRIBUTES_TO_NODE
*&---------------------------------------------------------------------*
*       add all attributes of structure to given node
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
*---Add all attributes of line to node
FORM ADD_ALL_ATTRIBUTES_TO_NODE
  USING P_NODE
      TYPE REF TO IF_IXML_ELEMENT
  P_COMP_LINE.


  DATA: R_DESCR    TYPE REF TO CL_ABAP_STRUCTDESCR,
        FIELD_NAME TYPE STRING,
        WA_COMP    TYPE ABAP_COMPDESCR.

  FIELD-SYMBOLS:
  <FSX> TYPE ANY.

  R_DESCR ?=
  CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( P_COMP_LINE ).
  LOOP AT R_DESCR->COMPONENTS INTO WA_COMP.

    ASSIGN COMPONENT WA_COMP-NAME OF STRUCTURE
    P_COMP_LINE TO <FSX>.

    IF SY-SUBRC EQ 0.

      FIELD_NAME = WA_COMP-NAME.
      PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                      P_NODE
                      FIELD_NAME
                      <FSX>.
    ENDIF.

  ENDLOOP.


ENDFORM.                    "add_all_attributes_to_node
*------------------ADD_APPLICATION_DATA_TO_XML---------------------
*-----Add the application data (conf, desc, etc')
*---------------------------------------------------------------------
FORM ADD_APPLICATION_DATA_TO_XML USING P_COMP_WA TYPE
      WDY_COMPONENT.

  DATA:
    APP_START_INDEX        TYPE SY-TABIX,
    APP_CONFIG_START_INDEX TYPE SY-TABIX,
    APP_CONFIG_END_INDEX   TYPE SY-TABIX,
    APP_PROP_END_INDEX     TYPE SY-TABIX,
    OBJNAME                TYPE TADIR-OBJ_NAME,
    APP_PROP_START_INDEX   TYPE SY-TABIX,
    DESC_START_INDEX       TYPE SY-TABIX,
    DESC_END_INDEX         TYPE SY-TABIX,
    APP_END_INDEX          TYPE SY-TABIX.

*   add component application
  READ TABLE WDY_APPLICATION_TAB INTO WDY_APPLICATION_WA WITH KEY

  COMPONENT = P_COMP_WA-COMPONENT_NAME.

  IF SY-SUBRC EQ 0.
    CLEAR: APP_START_INDEX, APP_END_INDEX.

    APP_START_INDEX = SY-TABIX.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_COMPS_NODE
                                   'COMPONENT_APPLICATIONS'
                            CHANGING WDY_APPLICATIONS_HEADER_NODE.

    APP_END_INDEX = APP_START_INDEX.

    WHILE SY-SUBRC EQ  0.

      APP_END_INDEX = APP_END_INDEX + 1.

      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
      WDY_APPLICATIONS_HEADER_NODE
                                     'WDY_APPLICATION'
                              CHANGING WDY_APPLICATION_NODE.

      CLEAR GS_TADIR.

*       find devclass
      OBJNAME = WDY_APPLICATION_WA-APPLICATION_NAME.
      READ TABLE GT_TADIR WITH KEY OBJ_NAME = OBJNAME
                                   OBJECT   = 'WDYA'
                                   INTO GS_TADIR.

      IF SY-SUBRC EQ 0.

        PERFORM ADD_ATTRIBUTE_TO_NODE
                    USING
                       WDY_APPLICATION_NODE
                        'DEVCLASS'
                        GS_TADIR-DEVCLASS
                        .

      ENDIF.

      PERFORM ADD_ALL_ATTRIBUTES_TO_NODE USING
            WDY_APPLICATION_NODE WDY_APPLICATION_WA.


      PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                      WDY_APPLICATION_NODE
                      'NAME'
                      WDY_APPLICATION_WA-APPLICATION_NAME.

      PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                      WDY_APPLICATION_NODE
                      'MASTER_COMPONENT'
                      WDY_APPLICATION_WA-COMPONENT.

*-------desc
      CLEAR: DESC_START_INDEX, DESC_END_INDEX.

*       read application description if it exists
      READ TABLE WDY_APPLICATION_DESC_TAB WITH KEY APPLICATION_NAME =
      WDY_APPLICATION_WA-APPLICATION_NAME INTO WDY_APPLICATION_DESC_WA
      BINARY SEARCH..
      IF SY-SUBRC EQ 0.

        PERFORM ADD_ATTRIBUTE_TO_NODE
                  USING
                      WDY_APPLICATION_NODE
                      'DESCRIPTION'
                      WDY_APPLICATION_DESC_WA-DESCRIPTION.

        DESC_START_INDEX = SY-TABIX.

        LOOP AT WDY_APPLICATION_DESC_TAB INTO WDY_APPLICATION_DESC_WA
        FROM DESC_START_INDEX.

          AT END OF APPLICATION_NAME.

            DESC_END_INDEX = SY-TABIX.
            APPEND LINES OF WDY_APPLICATION_DESC_TAB
            FROM DESC_START_INDEX TO DESC_END_INDEX TO
            WDY_APP_DESC_LOCAL_TAB.

            PERFORM ADD_ITAB_TO_XML_SIMPLE
              TABLES
                  WDY_APP_DESC_LOCAL_TAB
              USING
                 G_IREF_PDOCUMENT
                 WDY_APPLICATION_NODE
                 'APPLICATION_DESCRIPTIONS'.

            REFRESH WDY_APP_DESC_LOCAL_TAB[].
            EXIT.

          ENDAT.

        ENDLOOP.

      ENDIF.

*       read application parameters
      READ TABLE WDY_APP_PROPERTY_TAB WITH KEY APPLICATION_NAME =
      WDY_APPLICATION_WA-APPLICATION_NAME TRANSPORTING NO FIELDS
      BINARY SEARCH.

      IF SY-SUBRC EQ 0..
        CLEAR : APP_PROP_END_INDEX, APP_PROP_START_INDEX.

        APP_PROP_START_INDEX = SY-TABIX.

        LOOP AT WDY_APP_PROPERTY_TAB INTO WDY_APP_PROPERTY_WA FROM
        APP_PROP_START_INDEX.

          AT END OF APPLICATION_NAME.

            APP_PROP_END_INDEX = SY-TABIX.

            APPEND LINES OF WDY_APP_PROPERTY_TAB FROM
            APP_PROP_START_INDEX TO APP_PROP_END_INDEX TO
            WDY_APP_PROPERTY_TAB_LOCAL.

            PERFORM ADD_ITAB_TO_XML_SIMPLE
              TABLES
                 WDY_APP_PROPERTY_TAB_LOCAL
              USING
                 G_IREF_PDOCUMENT
                 WDY_APPLICATION_NODE
                 'APPLICATION_PARAMETER'.

            REFRESH WDY_APP_PROPERTY_TAB_LOCAL[].
            EXIT.

          ENDAT.

        ENDLOOP.
        " loop at wdy_app_property_tab into wdy_app_property_wa

      ENDIF.

      READ TABLE WDY_CONFIG_APPL_TAB WITH KEY APPLICATION =
      WDY_APPLICATION_WA-APPLICATION_NAME INTO WDY_CONFIG_APPL_WA
      BINARY SEARCH.
      IF SY-SUBRC EQ 0.

        PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
        WDY_APPLICATION_NODE
                                       'APPLICATION_CONFIGURATIONS'
                                CHANGING WD_APP_CONFIGURATIONS_NODE.

        CLEAR : APP_CONFIG_START_INDEX, APP_CONFIG_END_INDEX.

        APP_CONFIG_START_INDEX = SY-TABIX.
        APP_CONFIG_END_INDEX  = APP_CONFIG_START_INDEX.

        WHILE SY-SUBRC EQ 0.

          APP_CONFIG_END_INDEX = APP_CONFIG_END_INDEX + 1.

*           read the app configurations
          READ TABLE WDY_CONFIG_APPL_TAB
          INDEX APP_CONFIG_END_INDEX INTO WDY_CONFIG_APPL_WA.

          IF WDY_CONFIG_APPL_WA-APPLICATION <>
            WDY_APPLICATION_WA-APPLICATION_NAME OR SY-SUBRC <> '0'.

            APP_CONFIG_END_INDEX = APP_CONFIG_END_INDEX - 1.
            APPEND LINES OF WDY_CONFIG_APPL_TAB FROM
            APP_CONFIG_START_INDEX TO APP_CONFIG_END_INDEX TO
            WDY_APP_CONFIG_TAB_LOCAL.

            PERFORM ADD_ITAB_TO_XML_SIMPLE
            TABLES
                WDY_APP_CONFIG_TAB_LOCAL
            USING
               G_IREF_PDOCUMENT
               WD_APP_CONFIGURATIONS_NODE
               'APPLICATION_CONFIGURATION'.

            REFRESH WDY_APP_CONFIG_TAB_LOCAL[].

            EXIT.

          ENDIF.

        ENDWHILE.

      ENDIF.

      FREE WDY_APPLICATION_NODE.

*         check next application
      READ TABLE WDY_APPLICATION_TAB
      INDEX APP_END_INDEX INTO WDY_APPLICATION_WA.

      IF WDY_APPLICATION_WA-COMPONENT <>
        WDY_COMPONENT_WA-COMPONENT_NAME OR SY-SUBRC <> 0.

        FREE WDY_APPLICATIONS_HEADER_NODE.
        EXIT.

      ENDIF.

    ENDWHILE.

  ENDIF.

ENDFORM.                    "add_application_data_to_xml
*------------------ADD_WD_CONTROLLER_DATA_TO_XML---------------------
*-------Add the controller data
*---------------------------------------------------------------------
FORM ADD_WD_CONTROLLER_DATA_TO_XML USING P_COMP_WA
      TYPE WDY_COMPONENT.

  DATA:
                STORED_CONTROLLER_TABIX TYPE SY-TABIX.

*---Go through the various controllers of the component
*(can be view, custom controller, default controller, window, interface
*view , etc
  READ TABLE WDY_CONTROLLER_TAB TRANSPORTING NO FIELDS WITH KEY
    COMPONENT_NAME = P_COMP_WA-COMPONENT_NAME BINARY SEARCH.

  IF SY-SUBRC EQ 0.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_COMPS_NODE
                                'COMPONENT_CONTROLLERS'
                          CHANGING WD_COMP_CONTROLLERS_NODE.

    STORED_CONTROLLER_TABIX =  SY-TABIX.

    LOOP AT WDY_CONTROLLER_TAB INTO WDY_CONTROLLER_WA FROM
    STORED_CONTROLLER_TABIX.

*       various components have their desriptions in different tables
      CASE WDY_CONTROLLER_WA-CONTROLLER_TYPE.

*         custom controller
        WHEN '00'.

          IF WD_CUSTOM_CTRL_HEADER_NODE IS INITIAL.

*             Create a child node header of custom components
            PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
            WD_COMP_CONTROLLERS_NODE
                                        'WDA_CUSTOM_CONTROLLERS'
                                  CHANGING WD_CUSTOM_CTRL_HEADER_NODE.
          ENDIF.

*           Create a child node for the Header node
          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
          WD_CUSTOM_CTRL_HEADER_NODE
                                      'WDA_CUSTOM_CONTROLLER'
                                CHANGING WD_CUSTOM_CONTROLLER_NODE.

          PERFORM ADD_CONTROLLER_NODE_BY_TYPE
          USING WD_CUSTOM_CONTROLLER_NODE P_COMP_WA
          WDY_CONTROLLER_WA.

**         view
        WHEN '01'.

          IF WDY_VIEWS_HEADER_NODE IS INITIAL.

            PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
            WD_COMP_CONTROLLERS_NODE
                                          'WDA_VIEWS'
                                    CHANGING WDY_VIEWS_HEADER_NODE.
          ENDIF.

          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
          WDY_VIEWS_HEADER_NODE
                                         'WDA_VIEW'
                                  CHANGING WDY_VIEW_NODE.

          PERFORM ADD_CONTROLLER_NODE_BY_TYPE
          USING WDY_VIEW_NODE P_COMP_WA  WDY_CONTROLLER_WA.

**        component controller
        WHEN '02'.

*           if wdy_controller_node is initial.
          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
          WD_COMP_CONTROLLERS_NODE
                                         'WDA_CONTROLLER'
                                  CHANGING WDY_CONTROLLER_NODE.

          PERFORM ADD_CONTROLLER_NODE_BY_TYPE
          USING WDY_CONTROLLER_NODE P_COMP_WA  WDY_CONTROLLER_WA
          .
*
*          window
        WHEN '06' OR '03'.

          IF WDY_WINDOW_HEADER_NODE IS INITIAL.


            PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
            WD_COMP_CONTROLLERS_NODE
                                          'WDA_WINDOWS'
                                    CHANGING WDY_WINDOW_HEADER_NODE.
          ENDIF.

          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
          WDY_WINDOW_HEADER_NODE
                                         'WDA_WINDOW'
                                  CHANGING WDY_WINDOW_NODE.

          PERFORM ADD_CONTROLLER_NODE_BY_TYPE
          USING WDY_WINDOW_NODE P_COMP_WA  WDY_CONTROLLER_WA.

        WHEN OTHERS.

      ENDCASE.

      AT END OF COMPONENT_NAME.
        FREE: WD_CUSTOM_CTRL_HEADER_NODE,
        WDY_WINDOW_HEADER_NODE, WDY_CONTROLLER_NODE,
        WDY_VIEWS_HEADER_NODE.
        EXIT.
      ENDAT.

    ENDLOOP.
    " LOOP AT wdy_controller_tab INTO wdy_controller_wa
    " FROM stored_controller_tabix

  ENDIF.


ENDFORM.                    "add_wd_controller_data_to_xml

*&---------------------------------------------------------------------*
*&      Form  ADD_COMP_USAGE_DATA_TO_XML
*&      add component usage data
*&---------------------------------------------------------------------*
FORM ADD_COMP_USAGE_DATA_TO_XML USING
      P_COMP_WA TYPE
      WDY_COMPONENT
  .

  DATA:
    COMPO_USAGE_INDEX_START TYPE SY-TABIX,
    COMPO_USAGE_INDEX_END   TYPE SY-TABIX.

*   Create a child node for component_usages
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT WD_COMPS_NODE
                              'USED_OBJECTS'
                        CHANGING WD_USED_OBJECTS_NODE.

*   Read component usage
  READ TABLE WDY_COMPO_USAGE_TAB TRANSPORTING NO FIELDS WITH KEY
    COMPONENT_NAME = P_COMP_WA-COMPONENT_NAME BINARY SEARCH.

  IF SY-SUBRC EQ 0.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
    WD_USED_OBJECTS_NODE
                                'COMPONENT_USAGES'
                          CHANGING WD_COMP_USAGE_NODE.

*      store sy-tabix
    COMPO_USAGE_INDEX_START = SY-TABIX.

    LOOP AT WDY_COMPO_USAGE_TAB INTO WDY_COMPO_USAGE_WA FROM
    COMPO_USAGE_INDEX_START.

      AT END OF COMPONENT_NAME.
        COMPO_USAGE_INDEX_END = SY-TABIX.
        APPEND LINES OF WDY_COMPO_USAGE_TAB
        FROM COMPO_USAGE_INDEX_START TO COMPO_USAGE_INDEX_END TO
        WDY_COMPO_USAGE_TAB_LOCAL.

        PERFORM ADD_ITAB_TO_XML_SIMPLE
          TABLES
             WDY_COMPO_USAGE_TAB_LOCAL
          USING
             G_IREF_PDOCUMENT
             WD_COMP_USAGE_NODE
             'COMPONENT_USAGE'.

        REFRESH WDY_COMPO_USAGE_TAB_LOCAL[].
        EXIT.

      ENDAT.
    ENDLOOP.
    "wdy_compo_usage_tab into wdy_compo_usage_wa
    "from compo_usage_index_start

  ENDIF.

ENDFORM.                    "add_comp_usage_data_to_xml
*&---------------------------------------------------------------------*
*&      Form  RUN_WD_SCI
*&---------------------------------------------------------------------*
*       DO Web dynpro syntax check
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM RUN_WD_SCI CHANGING CT_ALL_RESULT_TABLE TYPE TT_HANAA_SCI_CHECK.

  DATA:

    VARIANT_TAB         TYPE SCI_TSTVAR,
    VARIANT_WA          LIKE LINE OF VARIANT_TAB,
    LO_CI_OBJECTSET     TYPE REF TO CL_CI_OBJECTSET,

    GT_TADIR            TYPE TABLE OF TADIR,
    GS_TADIR            LIKE LINE OF GT_TADIR,
    LO_CI_CHECKVARIANT  TYPE REF TO CL_CI_CHECKVARIANT,
    LS_SEL_FLAGS        TYPE SCI_FLGL,
    CV_IS_SUCCESS       TYPE FLAG,
    LO_CI_INSPECTION    TYPE REF TO CL_CI_INSPECTION,
    LV_INSPECTION_NAME  TYPE SCI_INSP,
    LT_VARIANTS         TYPE TABLE OF SCI_CHKV,
    LS_SO_TADIR         TYPE SCISTADIR,
    LS_SO_DEVC          LIKE LINE OF LS_SO_TADIR-SODEVC,
    VARIANT_CREATION_FAILED TYPE FLAG,
    LO_CI_CHECK_RESULT  TYPE REF TO CL_CI_CHECK_RESULT,
    LT_RESULT_TABLE     TYPE SCIT_ALVLIST,
    LS_ALL_RESULT_TABLE LIKE LINE OF CT_ALL_RESULT_TABLE,
    LV_COUNT            TYPE STRING,
    LO_EXEPTION         TYPE REF TO CX_ROOT.

  FIELD-SYMBOLS:
    <LT_RESULT_TABLE> LIKE LINE OF LT_RESULT_TABLE,
    <LS_VARIANT>      LIKE LINE OF LT_VARIANTS,
    <LS_TADIR>        LIKE LINE OF GT_TADIR,
    <LV_FLAG>         TYPE ANY.

  DATA:
        ZCLCI TYPE REF TO CL_CI_CHECKVARIANT.

  CREATE OBJECT ZCLCI.

  CLEAR CT_ALL_RESULT_TABLE[].

  " Check if need to get WD Syntax Check.
  CHECK EXTRACT_WD_SYNTAX_CHECK IS NOT INITIAL.

  " Get all customers dev classes
  CHECK NOT LT_TDEVC[] IS INITIAL.

  LS_SO_DEVC-SIGN = 'I'.
  LS_SO_DEVC-OPTION = 'EQ'.
  LOOP AT LT_TDEVC INTO LS_TDEVC.
    LS_SO_DEVC-LOW = LS_TDEVC-DEVCLASS.
    APPEND LS_SO_DEVC TO LS_SO_TADIR-SODEVC[].
  ENDLOOP.

  LS_SEL_FLAGS-WDYNS = 'X'.

  " Create object selector (the wda object names to be checked)
  CL_CI_OBJECTSET=>CREATE(
    EXPORTING
      P_USER              =  SY-UNAME   " User
      P_NAME              =  'ZPANAYA_WDYN_OBJECTS'
      " Name of an object set
*          p_new_version       = ''    " New version should be created
    RECEIVING
      P_REF               =  LO_CI_OBJECTSET
    EXCEPTIONS
      OBJS_ALREADY_EXISTS = 1
      OBJS_NOT_EXISTS     = 2
      LOCKED              = 3
      ERROR_IN_ENQUEUE    = 4
      NOT_AUTHORIZED      = 5
      OTHERS              = 6 ).

  IF SY-SUBRC <> 0.

    CONCATENATE
      'Extracting WD Code Inspector'  "#EC NOTEXT
'- Invalid objects selection for Check variant' "#EC NOTEXT
      'WD'
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

  ENDIF.

  " Set objects selections by devc.
  LO_CI_OBJECTSET->SAVE_OBJECTSET(
    EXPORTING
      P_TADIR        = LS_SO_TADIR
      P_SEL_FLAGS    = LS_SEL_FLAGS
    EXCEPTIONS
      NO_VALID_SELECTION    = 1
      MISSING_PROGRAM_PARAM = 2
      OTHERS                = 3 ).

  FREE LS_SO_TADIR.

* Try to check if currently variant exists (for the type of checking
* of wda objects)
  CALL METHOD CL_CI_CHECKVARIANT=>GET_REF
    EXPORTING
      P_USER            = SY-UNAME
      P_NAME            = 'ZPANAYA_CHECK_VARIANT'
*     p_id              =
*     p_dont_look_for_new_chkv = ''
    RECEIVING
      P_REF             = ZCLCI
    EXCEPTIONS
      CHKV_NOT_EXISTS   = 1
      MISSING_PARAMETER = 2
      OTHERS            = 3.
  IF SY-SUBRC <> 0.

*   if the check variant does not exist, create it
    IF SY-SUBRC EQ 1.

      CALL METHOD CL_CI_CHECKVARIANT=>CREATE
        EXPORTING
          P_USER              = SY-UNAME
          P_NAME              = 'ZPANAYA_CHECK_VARIANT'
*         p_called_internal   =
        RECEIVING
          P_REF               = ZCLCI
        EXCEPTIONS
          CHKV_ALREADY_EXISTS = 1
          LOCKED              = 2
          ERROR_IN_ENQUEUE    = 3
          NOT_AUTHORIZED      = 4
          OTHERS              = 5.
      IF SY-SUBRC <> 0.
        CONCATENATE
'Extracting WD Code Inspector' "#EC NOTEXT
'- Failed to create check variant' "#EC NOTEXT
'WD'
          INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

        EXIT.

      ENDIF.

*     Relevant web dynpro checks
      VARIANT_WA-TESTNAME = 'CL_CI_TEST_ABAP_GENERATE'.
      INSERT VARIANT_WA INTO TABLE VARIANT_TAB.
      VARIANT_WA-TESTNAME = 'CL_CI_TEST_EXTENDED_CHECK'.
      INSERT VARIANT_WA INTO TABLE VARIANT_TAB.
      VARIANT_WA-TESTNAME = 'CL_CI_TEST_SYNTAX_CHECK'.
      INSERT VARIANT_WA INTO TABLE VARIANT_TAB.
      VARIANT_WA-TESTNAME = 'CL_WDY_CI_TEST_COMPONENT_DEF'.
      INSERT VARIANT_WA INTO TABLE VARIANT_TAB.

*     Save the variant with the created objects type filters
      CALL METHOD ZCLCI->SAVE
        EXPORTING
          P_VARIANT       = VARIANT_TAB
          P_TEXT          = 'ZPANAYA_WD_TEST'
        EXCEPTIONS
          EMPTY_VARIANT   = 1
          TRANSPORT_ERROR = 2
          NOT_AUTHORIZED  = 3
          OTHERS          = 4.
      IF SY-SUBRC <> 0.

        CONCATENATE
          'Saving the variant failed' "#EC NOTEXT
          'WD' "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

        EXIT.
      ENDIF.

    ENDIF.

  ELSE.

*    If variant already exist, just set the changes (apparently
*    you must do this
    CALL METHOD ZCLCI->ENTER_CHANGE
*        EXPORTING
*          p_called_internal =
      EXCEPTIONS
        LOCKED           = 1
        ERROR_IN_ENQUEUE = 2
        NOT_AUTHORIZED   = 3
        OTHERS           = 4.
    IF SY-SUBRC <> 0.
      CONCATENATE
        'Extracting WD Code Inspector'  "#EC NOTEXT
        '- Invalid objects selection for Check variant'  "#EC NOTEXT
        'WD'
        INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      EXIT.
    ENDIF.

*   Set the variant
    CALL METHOD ZCLCI->SET_VARIANT
      EXPORTING
        P_VARIANT    = VARIANT_TAB
        P_TEXT       = 'ZPANAYA_WD_TEST'
*       p_transport  =
*       p_variant_merge =
      EXCEPTIONS
        NOT_ENQUEUED = 1
        OTHERS       = 2.
    IF SY-SUBRC <> 0.
      CONCATENATE
        'Extracting WD Code Inspector'  "#EC NOTEXT
        '- failed setting variant'  "#EC NOTEXT
        'WD'
        INTO GT_ETL_MESSAGE-MESSAGE
        SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
      EXIT.
    ENDIF.

  ENDIF.

* Set inspection name
  LV_INSPECTION_NAME = 'ZPANAYA_WD_TEST'.

  " Create inspection
  CL_CI_INSPECTION=>CREATE(
    EXPORTING
      P_NAME              = LV_INSPECTION_NAME
      P_USER              = SY-UNAME
    RECEIVING
      P_REF               = LO_CI_INSPECTION
    EXCEPTIONS
      INSP_ALREADY_EXISTS = 1
      INSP_NOT_EXISTS     = 2
      LOCKED              = 3
      ERROR_IN_ENQUEUE    = 4
      OTHERS              = 5 ).

      IF SY-SUBRC <> 0.
        CONCATENATE
          'Extracting WD Code Inspector'
          '- failed Creating variant'
          'WD'
          INTO GT_ETL_MESSAGE-MESSAGE
          SEPARATED BY SPACE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
         EXIT.
      ENDIF.

  " Set the object selector and check variant
  LO_CI_INSPECTION->SET(
    EXPORTING
      P_CHKV       = ZCLCI
      P_OBJS       = LO_CI_OBJECTSET
    EXCEPTIONS
      NOT_ENQUEUED = 1
      OTHERS       = 2 ).

  IF SY-SUBRC <> 0.

    CV_IS_SUCCESS = ABAP_FALSE.

    CONCATENATE
'Extracting WD Code Inspector'  "#EC NOTEXT
'- Error occur when run code inspector for check variant'  "#EC NOTEXT
      'WD'
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
    EXIT.
  ENDIF.

  " Execute the WD code inspector.
  LO_CI_INSPECTION->RUN(
    EXPORTING
      P_HOWTORUN  = 'D' "DIRECT RUN
    EXCEPTIONS
      OTHERS      = 1 ).

  IF SY-SUBRC <> 0.

    CV_IS_SUCCESS = ABAP_FALSE.

    CONCATENATE
'Extracting WD Code Inspector'  "#EC NOTEXT
'- Error occur when run code inspector for check variant'  "#EC NOTEXT
'WD'
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
*        CONTINUE.


  ELSE.

    " Get results.
    LO_CI_INSPECTION->PLAIN_LIST( IMPORTING P_LIST = LT_RESULT_TABLE ).

*   Get number of lines selected
    LV_COUNT = LINES( LT_RESULT_TABLE ).

    CONCATENATE
      'Extracting WD Code Inspector'  "#EC NOTEXT
      '- Number of entries for check variant' "#EC NOTEXT
      'WD'
      ':'
      LV_COUNT
      INTO GT_ETL_MESSAGE-MESSAGE
      SEPARATED BY SPACE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    LOOP AT LT_RESULT_TABLE ASSIGNING <LT_RESULT_TABLE>.
      MOVE-CORRESPONDING <LT_RESULT_TABLE> TO LS_ALL_RESULT_TABLE.
      LS_ALL_RESULT_TABLE-ZZVARIANT = 'WD'.
      APPEND LS_ALL_RESULT_TABLE TO CT_ALL_RESULT_TABLE.
    ENDLOOP.

    DELETE CT_ALL_RESULT_TABLE WHERE KIND <> 'E'.
    SORT CT_ALL_RESULT_TABLE BY OBJTYPE OBJNAME.

  ENDIF.

  FREE LO_CI_INSPECTION.
  FREE LO_CI_OBJECTSET.
  FREE ZCLCI.

ENDFORM.                    "run_wd_sci

*---------------------------------------------------------------------*
*       FORM extract_auth_usage_only                                  *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTH_USAGE_ONLY.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS
  USING 'Extracting authorizations usage'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<AUTHORIZATIONS>'.

* Export AGR_USERS data ( from production )
  PERFORM EXTRACT_AUTHORIZATIONS_USAGE.

  PERFORM APPEND_STRING_TO_FILE USING '</AUTHORIZATIONS>'.

  PERFORM ADD_TIME_STAT
  USING 'Extract authorizations usage' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_AUTH_USAGE_ONLY

*---------------------------------------------------------------------*
*       FORM EXTRACT_IDOCS_USAGE_ONLY                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_IDOCS_USAGE_ONLY.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting IDocs'. "#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<IDOCS>'.
  PERFORM EXTRACT_PARTNERS_WITH_USAGE.
  PERFORM APPEND_STRING_TO_FILE USING '</IDOCS>'.

  PERFORM ADD_TIME_STAT USING 'Extract IDOCs' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_IDOCS_USAGE_ONLY

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES.

  DATA: L_STARTTIME LIKE SY-UZEIT,
        L_STARTDATE LIKE SY-DATUM.

  DATA: SPROXDAT_ITAB TYPE TABLE OF SPROXDAT.

  DATA: LT_TADIR_PROXY TYPE STANDARD TABLE OF TADIR,
        LS_TADIR_PROXY TYPE TADIR,
        LT_PROXIES     TYPE TABLE OF SPROXHDR,
        LS_PROXIES     TYPE SPROXHDR.

  FIELD-SYMBOLS: <SPROXHDR> LIKE LINE OF G_PROXY_HEADERS,
                 <SPROXDAT> LIKE LINE OF SPROXDAT_ITAB.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Proxies'. "#EC NOTEXT

* Get all customers dev classes
  PERFORM GET_DEV_CLASS_DATA.
  CHECK NOT LT_TDEVC[] IS INITIAL.

* Get all customers 'CLAS' & 'INTF' objects for proxy selection
  SELECT OBJECT OBJ_NAME
    FROM TADIR
    INTO CORRESPONDING FIELDS OF TABLE LT_TADIR_PROXY
     FOR ALL ENTRIES IN LT_TDEVC
   WHERE DEVCLASS = LT_TDEVC-DEVCLASS
     AND PGMID = 'R3TR'
     AND OBJECT IN ('CLAS','INTF').

  FREE: LT_TDEVC.
  CHECK NOT LT_TADIR_PROXY[] IS INITIAL.

  LOOP AT LT_TADIR_PROXY INTO LS_TADIR_PROXY.
    CLEAR LS_PROXIES.
    LS_PROXIES-OBJECT = LS_TADIR_PROXY-OBJECT.
    LS_PROXIES-OBJ_NAME = LS_TADIR_PROXY-OBJ_NAME.
    APPEND LS_PROXIES TO LT_PROXIES.
  ENDLOOP.
  FREE: LT_TADIR_PROXY.

  PERFORM APPEND_STRING_TO_FILE USING '<PROXIES>'.

* Extract proxies header data
  SELECT *
    FROM SPROXHDR
    INTO CORRESPONDING FIELDS OF TABLE G_PROXY_HEADERS
     FOR ALL ENTRIES IN LT_PROXIES
   WHERE OBJECT   = LT_PROXIES-OBJECT
     AND OBJ_NAME = LT_PROXIES-OBJ_NAME.

  IF SY-SUBRC = 0.
*   Clear unwaqnted data that might cuase XML errors
    LOOP AT G_PROXY_HEADERS ASSIGNING <SPROXHDR>.
      CLEAR: <SPROXHDR>-HASH_ID, <SPROXHDR>-ID,
             <SPROXHDR>-FURTHER_DATA, <SPROXHDR>-BO_DATA.
    ENDLOOP.
    PERFORM APPEND_STRING_TO_FILE USING '<PROXY_HEADERS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES G_PROXY_HEADERS
                                    USING  G_IREF_PDOCUMENT
                                           'SPROXHDR'.
    PERFORM APPEND_STRING_TO_FILE USING '</PROXY_HEADERS>'.
  ENDIF.

* Extract proxies data
  PERFORM APPEND_STRING_TO_FILE USING '<PROXY_DATA>'.
  SELECT *
    FROM SPROXDAT PACKAGE SIZE PAC_SIZE
    INTO CORRESPONDING FIELDS OF TABLE SPROXDAT_ITAB
     FOR ALL ENTRIES IN LT_PROXIES
   WHERE OBJECT   = LT_PROXIES-OBJECT
     AND OBJ_NAME = LT_PROXIES-OBJ_NAME.

*   Clear unwaqnted data that might cuase XML errors
    LOOP AT SPROXDAT_ITAB ASSIGNING <SPROXDAT>.
      CLEAR: <SPROXDAT>-ID.
    ENDLOOP.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SPROXDAT_ITAB
                                    USING  G_IREF_PDOCUMENT
                                           'SPROXDAT'.
  ENDSELECT.

  FREE: SPROXDAT_ITAB.

  PERFORM APPEND_STRING_TO_FILE USING '</PROXY_DATA>'.

* Extract SXMB_ADM parameters
  PERFORM EXTRACT_PROXIES_PARAMS.

* Append closing XML tag for proxies data
  PERFORM APPEND_STRING_TO_FILE USING '</PROXIES>'.

  PERFORM ADD_TIME_STAT USING 'Extract Proxies' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " EXTRACT_PROXIES

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES_USAGE
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES_USAGE.

  TYPES: BEGIN OF TY_PROXY_USAGE,
           LAST_USED      TYPE DATUM,
           OBJECT(4)      TYPE C,
           OBJ_NAME(30)   TYPE C,
           INTERFACE(120) TYPE C,
           NAMESPACE(255) TYPE C,
           CALLER(100)    TYPE C,
           COUNT          TYPE NUM10,
         END OF TY_PROXY_USAGE,

         BEGIN OF TY_PROXY_USAGE_OUT,
           PERIOD(6)  TYPE C,
           TCODE(400) TYPE C,
           TYPE(1)    TYPE C,
           USAGE      TYPE NUM10,
         END OF TY_PROXY_USAGE_OUT,

         BEGIN OF TY_PROXY_CALLER,
           CALLER_NAME(255) TYPE C,
           CALLER_USAGE     TYPE NUM10,
         END OF TY_PROXY_CALLER.

  DATA: L_STARTTIME  LIKE SY-UZEIT,
        L_STARTDATE  LIKE SY-DATUM,
        LV_TABIX     TYPE NUMC10,
        LV_TABIX_STR TYPE STRING.

  DATA: LV_USAGE_END_DATE TYPE SY-DATUM,
        LV_USAGE_END_TIME TYPE SY-UZEIT.

  DATA: LV_MAX_PROXY_USAGE_TIME_STR(8) TYPE C,
        LV_MAX_PROXY_USAGE_VIA_RFC     TYPE STRING,
        LV_PROXIES_COUNT               TYPE I,
        LV_PROXIES_COUNT_STR           TYPE STRING.

  DATA: LV_NOTIFICATION_PARAM TYPE STRING.

  DATA: LS_PROXY_HEADER LIKE LINE OF G_PROXY_HEADERS.

  DATA: LT_PROXY_USAGE  TYPE STANDARD TABLE OF TY_PROXY_USAGE,
        LS_PROXY_USAGE  TYPE TY_PROXY_USAGE,
        LT_USAGE_CALLER TYPE TT_USAGE_CALLER,
        LS_USAGE_CALLER TYPE TY_USAGE_CALLER.

  DATA: LT_USAGE_OUT TYPE STANDARD TABLE OF TY_PROXY_USAGE_OUT,
        LS_USAGE_OUT TYPE TY_PROXY_USAGE_OUT.

  DATA: USAGE_CALLERS TYPE STANDARD TABLE OF TY_PROXY_CALLER,
        USAGE_CALLER  TYPE TY_PROXY_CALLER.

  DATA: TOTAL_USAGE      TYPE NUM10,
        USAGE_PER_CALLER TYPE NUM10.

  DATA: USAGE_NODE           TYPE XML_ELEMENT,
        CALLERS_NODE         TYPE XML_ELEMENT,
        LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

  DATA: LV_TIME_LIMIT TYPE SY-UZEIT.

  CHECK VANILLA = ''.

* Extract proxy usage only if rfc system is ecc5 or higher
  CHECK RFC_SAPRL GE '640'.

  CHECK NOT G_PROXY_HEADERS[] IS INITIAL.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Proxies Usage'. "#EC NOTEXT

  DESCRIBE TABLE G_PROXY_HEADERS LINES LV_PROXIES_COUNT.
  LV_PROXIES_COUNT_STR = LV_PROXIES_COUNT.

  IF RFC_SYSID <> SY-SYSID.
    LV_TIME_LIMIT = MAX_PROXY_USAGE_TIME.
  ELSE.
    LV_TIME_LIMIT = LOCAL_PROXY_USAGE_TIME.
  ENDIF.

* Calc the max time the Proxies Usage should take.
  PERFORM ADD_TIME USING LV_TIME_LIMIT
                CHANGING LV_USAGE_END_TIME
                         LV_USAGE_END_DATE.

  SORT G_PROXY_HEADERS.

* Extract usage per proxy (interface)
  LOOP AT G_PROXY_HEADERS INTO LS_PROXY_HEADER.

    LV_TABIX = SY-TABIX.
    LV_TABIX_STR = SY-TABIX.

*   Make sure the Proxy usage doesn't take too much time
*   (more than 45 min)
    IF ( SY-DATUM > LV_USAGE_END_DATE OR
         SY-UZEIT > LV_USAGE_END_TIME ).

      WRITE LV_TIME_LIMIT TO LV_MAX_PROXY_USAGE_TIME_STR.

      CONCATENATE 'Extract Proxy Usage takes more than ' "#EC NOTEXT
          LV_MAX_PROXY_USAGE_TIME_STR
          '. Extracted ' LV_TABIX_STR ' out of ' "#EC NOTEXT
          LV_PROXIES_COUNT_STR ' proxies.' "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*     Add notification for reaching time limit of proxies usage
*     extraction.
      CONCATENATE LV_MAX_PROXY_USAGE_TIME_STR
              NOTIFICATION_PARAMS_DELIMITER
              LV_TABIX_STR
              NOTIFICATION_PARAMS_DELIMITER
              LV_PROXIES_COUNT_STR
              INTO LV_NOTIFICATION_PARAM.

      PERFORM ADD_NOTIFICATION USING PROXIES_USAGE_TIME_LIMIT
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.

      EXIT.
    ENDIF.

*   When extraction isn't from production or we don't want to
*   extract callers, we'll get only partial data for the
*   first 100 proxies only
    IF ( LV_TABIX GT MAX_PROXIES_VIA_RFC ) AND
       ( ( RFC_SYSID NE SY-SYSID ) OR
         ( EXTRACT_PROXY_CALLERS IS INITIAL ) ).

      LV_MAX_PROXY_USAGE_VIA_RFC = MAX_PROXIES_VIA_RFC.

      CONCATENATE
      'Proxies usage is extracted via RFC, reached the' "#EC NOTEXT
        'max limit of:' LV_MAX_PROXY_USAGE_VIA_RFC 'out of' "#EC NOTEXT
        LV_PROXIES_COUNT_STR 'proxies.' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*     Add notification for reaching amount limit of proxies usage
*     extraction via RFC.
      CONCATENATE LV_MAX_PROXY_USAGE_VIA_RFC
        NOTIFICATION_PARAMS_DELIMITER
        LV_PROXIES_COUNT_STR
        INTO LV_NOTIFICATION_PARAM.

      PERFORM ADD_NOTIFICATION USING PROXIES_USAGE_RFC_LIMIT
                                     LV_NOTIFICATION_PARAM
                                     GT_ETL_MESSAGE-MESSAGE.

      EXIT.
    ENDIF.

    CLEAR LS_PROXY_USAGE.
    LS_PROXY_USAGE-OBJECT = LS_PROXY_HEADER-OBJECT.
    LS_PROXY_USAGE-OBJ_NAME = LS_PROXY_HEADER-OBJ_NAME.
    LS_PROXY_USAGE-INTERFACE = LS_PROXY_HEADER-IFR_NAME.
    LS_PROXY_USAGE-NAMESPACE = LS_PROXY_HEADER-IFR_NSPCE.

    CLEAR LT_USAGE_CALLER[].

*   Get the interface's usage (by caller)
    PERFORM GET_USAGE_BY_MONTHS_BACK
            USING LS_PROXY_HEADER-IFR_NSPCE
                  LS_PROXY_HEADER-IFR_NAME
                  ''
                  ''
                  'PROXIES'
         CHANGING LT_USAGE_CALLER.

    LOOP AT LT_USAGE_CALLER INTO LS_USAGE_CALLER.
      MOVE-CORRESPONDING LS_USAGE_CALLER TO LS_PROXY_USAGE.
      APPEND LS_PROXY_USAGE TO LT_PROXY_USAGE.
    ENDLOOP.

  ENDLOOP.

  IF NOT LT_PROXY_USAGE[] IS INITIAL.
    SORT LT_PROXY_USAGE
      BY LAST_USED OBJECT OBJ_NAME INTERFACE NAMESPACE CALLER.

*   Extract the proxies usage like existing usage
*   With callers per interface
    LOOP AT LT_PROXY_USAGE INTO LS_PROXY_USAGE.
      ADD LS_PROXY_USAGE-COUNT TO TOTAL_USAGE.
      ADD LS_PROXY_USAGE-COUNT TO USAGE_PER_CALLER.

      AT END OF CALLER.
        CLEAR USAGE_CALLER.
        USAGE_CALLER-CALLER_NAME = LS_PROXY_USAGE-CALLER.
        USAGE_CALLER-CALLER_USAGE = USAGE_PER_CALLER.
        APPEND USAGE_CALLER TO USAGE_CALLERS.
        CLEAR USAGE_PER_CALLER.
      ENDAT.

      AT END OF NAMESPACE.
        CLEAR LS_USAGE_OUT.

        LS_USAGE_OUT-PERIOD = LS_PROXY_USAGE-LAST_USED(6).
        CONCATENATE LS_PROXY_USAGE-NAMESPACE '/'
          LS_PROXY_USAGE-INTERFACE INTO LS_USAGE_OUT-TCODE.
        LS_USAGE_OUT-TYPE = 'X'.
        LS_USAGE_OUT-USAGE = TOTAL_USAGE.
        APPEND LS_USAGE_OUT TO LT_USAGE_OUT.

        PERFORM ADD_ITAB_TO_XML TABLES LT_USAGE_OUT
                                       LT_USAGE_TCODE_NODES
                                USING G_IREF_PDOCUMENT USAGE_NODE
                                      'USAGE_TCODE'.

        IF NOT LS_PROXY_USAGE-CALLER IS INITIAL.
          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                        LT_USAGE_TCODE_NODES-NODE_REF
                                        'CALLERS'
                                  CHANGING CALLERS_NODE.

          PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES USAGE_CALLERS
                                  USING G_IREF_PDOCUMENT CALLERS_NODE
                                          'CALLER'.
        ENDIF.

        PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                               LT_USAGE_TCODE_NODES-NODE_REF 'X'.

        CLEAR TOTAL_USAGE.
        FREE: LT_USAGE_OUT[], USAGE_CALLERS[],
              LT_USAGE_TCODE_NODES.
      ENDAT.

    ENDLOOP.

  ENDIF.

  FREE: G_PROXY_HEADERS[].

  PERFORM ADD_TIME_STAT
    USING
      'Extract Proxies Usage' "#EC NOTEXT
      L_STARTTIME
      L_STARTDATE.

ENDFORM.                    " EXTRACT_PROXIES_USAGE


*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES_PARAMS
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES_PARAMS.

  DATA: LT_SXMSCONFDF TYPE TABLE OF SXMSCONFDF,
        LT_SXMSCONFVL TYPE TABLE OF SXMSCONFVL,
        LT_SXMSARCITF TYPE TABLE OF SXMSARCITF2.

* Extract from direct SELECT or via RFC, depends extraction is from
* the same system like RFC (Prod to Prod)
  IF ( RFC_SYSID = SY-SYSID ).
    SELECT *
      FROM SXMSCONFDF
      INTO CORRESPONDING FIELDS OF TABLE LT_SXMSCONFDF.

    SELECT *
      FROM SXMSCONFVL
      INTO CORRESPONDING FIELDS OF TABLE LT_SXMSCONFVL.

    SELECT *
      FROM SXMSARCITF2
      INTO CORRESPONDING FIELDS OF TABLE LT_SXMSARCITF.
  ELSE.
    PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSCONFDF
                                    USING 'SXMSCONFDF'.

    PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSCONFVL
                                    USING 'SXMSCONFVL'.

    PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSARCITF
                                    USING 'SXMSARCITF2'.
  ENDIF.

* Default SXMB_ADM parameters
  IF NOT LT_SXMSCONFDF[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<PROXY_PARAMS_DEFAULT>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSCONFDF
                                    USING  G_IREF_PDOCUMENT
                                           'SXMSCONFDF'.
    PERFORM APPEND_STRING_TO_FILE USING '</PROXY_PARAMS_DEFAULT>'.
  ENDIF.

* User non-default SXMB_ADM parameters
  IF NOT LT_SXMSCONFVL[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<PROXY_PARAMS_VALUES>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSCONFVL
                                    USING  G_IREF_PDOCUMENT
                                           'SXMSCONFVL'.
    PERFORM APPEND_STRING_TO_FILE USING '</PROXY_PARAMS_VALUES>'.
  ENDIF.

* Interfaces for archive (not default delete)
  IF NOT LT_SXMSARCITF[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<PROXY_ARC_INTERFACES>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSARCITF
                                    USING  G_IREF_PDOCUMENT
                                           'SXMSARCITF'.
    PERFORM APPEND_STRING_TO_FILE USING '</PROXY_ARC_INTERFACES>'.
  ENDIF.

  FREE: LT_SXMSCONFDF, LT_SXMSCONFVL, LT_SXMSARCITF.

ENDFORM.                    " EXTRACT_PROXIES_PARAMS

*&---------------------------------------------------------------------*
*&      Form  GET_TABLE_DATA_VIA_RFC
*&---------------------------------------------------------------------*
FORM GET_TABLE_DATA_VIA_RFC TABLES RESULT
                             USING TAB_NAME TYPE TABNAME.

  DATA: OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        TAB_DATA TYPE TABLE OF TAB512.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = TAB_NAME
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = OPTIONS
      FIELDS               = FIELDS
      DATA                 = RESULT
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF NOT SY-SUBRC IS INITIAL.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'Extraction of ' TAB_NAME ' from ' P_RFCDES "#EC NOTEXT
          ' failed. Error: ' ERROR "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

ENDFORM.                    "GET_TABLE_DATA_VIA_RFC

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LAYOUTS_USAGE
*&---------------------------------------------------------------------*
FORM EXTRACT_LAYOUTS_USAGE.

  DATA: LV_USAGE_START_DATE LIKE SY-DATUM.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.


  DATA: LV_MESSAGE TYPE STRING,
        LV_LINES TYPE I,
        LV_LINES_STR TYPE STRING.

  DATA: LT_LAYOUTS_USAGE        TYPE STANDARD TABLE OF TY_LAYOUT_USAGE,
        LT_SORTED_LAYOUTS_USAGE TYPE TY_SORTED_LAYOUT_USAGE.

  DATA:
    LT_TNAPR_KEY             TYPE TABLE OF TS_TNAPR_KEY,
    LV_FROM_SLICE_DATE       TYPE D,
    LV_TO_SLICE_DATE         TYPE D,
    LT_HASH_LAYOUTS_USAGE    TYPE TT_HASH_LAYOUT_USAGE,
    LS_STR_CONDITION         TYPE STRING,
    LV_RFC_ERROR             TYPE RFCLOG_D,
    LV_STR_SY_SUBRC          TYPE STRING,
    LV_NUMBER_OF_ENTRIES     TYPE I.

  FIELD-SYMBOLS:
    <LS_TNAPR_KEYS>        LIKE LINE OF LT_TNAPR_KEY,
    <LS_LAYOUT_USAGE>      LIKE LINE OF LT_LAYOUTS_USAGE,
    <LS_HASH_LAYOUT_USAGE> LIKE LINE OF LT_HASH_LAYOUTS_USAGE.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Layouts Usage'. "#EC NOTEXT

* Calculate date for the number of days needed (default is 1 year)
  PERFORM GET_USAGE_START_DATE
    USING EXTRACT_LAYOUT_USAGE_DAYS
    CHANGING LV_USAGE_START_DATE.

  PERFORM APPEND_STRING_TO_FILE USING '<LAYOUTS_USAGE>'.

* Tried to get layouts usage when extraction is from the
* same system the RFC connection is pointing to.
  IF RFC_SYSID = SY-SYSID.

***************************
    LV_MESSAGE = 'Before Layouts Usage Count'.              "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************

    SELECT COUNT( * )                                   "#EC CI_NOFIRST
      FROM NAST
      INTO LV_LINES
     WHERE ERDAT GE LV_USAGE_START_DATE.

    LV_LINES_STR = LV_LINES.

    CONCATENATE
    'Total records in NAST (1 year back):' LV_LINES_STR     "#EC NOTEXT
      INTO LV_MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.

***************************
    LV_MESSAGE = 'Before Layouts Usage Data'.               "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************
    LV_FROM_SLICE_DATE = LV_USAGE_START_DATE.
    LV_TO_SLICE_DATE = LV_FROM_SLICE_DATE + LAYOUTS_USAGE_DAYS_SLICE.

    WHILE L_STARTDATE >= LV_FROM_SLICE_DATE.

*     Select Layouts usage grouped by KSCHL, NACHA, KAPPL & OBJTYPE
      SELECT T~KSCHL        AS KSCHL
             T~NACHA        AS NACHA
             T~KAPPL        AS KAPPL
             N~OBJTYPE      AS OBJTYPE
             MAX( N~ERDAT ) AS LAST_USED_DATE
             COUNT( * )     AS COUNT
      FROM TNAPR AS T
      INNER JOIN NAST AS N
             ON T~KSCHL = N~KSCHL AND
                T~NACHA = N~NACHA AND
                T~KAPPL = N~KAPPL
      INTO  CORRESPONDING FIELDS OF TABLE LT_LAYOUTS_USAGE
      WHERE N~ERDAT >= LV_FROM_SLICE_DATE AND
            N~ERDAT <  LV_TO_SLICE_DATE
      GROUP BY T~KSCHL T~NACHA T~KAPPL N~OBJTYPE
      ORDER BY T~KSCHL T~NACHA T~KAPPL N~OBJTYPE.

      LOOP AT LT_LAYOUTS_USAGE ASSIGNING <LS_LAYOUT_USAGE>.

        READ TABLE LT_HASH_LAYOUTS_USAGE
        WITH TABLE KEY
            KSCHL   = <LS_LAYOUT_USAGE>-KSCHL
            NACHA   = <LS_LAYOUT_USAGE>-NACHA
            KAPPL   = <LS_LAYOUT_USAGE>-KAPPL
            OBJTYPE = <LS_LAYOUT_USAGE>-OBJTYPE
            ASSIGNING <LS_HASH_LAYOUT_USAGE>.

        IF SY-SUBRC EQ 0.

          ADD <LS_LAYOUT_USAGE>-COUNT TO <LS_HASH_LAYOUT_USAGE>-COUNT.
          IF <LS_LAYOUT_USAGE>-LAST_USED_DATE GT
<LS_HASH_LAYOUT_USAGE>-LAST_USED_DATE.
            <LS_HASH_LAYOUT_USAGE>-LAST_USED_DATE =
<LS_LAYOUT_USAGE>-LAST_USED_DATE.
          ENDIF.

        ELSE.

          INSERT <LS_LAYOUT_USAGE> INTO TABLE LT_HASH_LAYOUTS_USAGE.

        ENDIF.

      ENDLOOP.

      LV_FROM_SLICE_DATE = LV_TO_SLICE_DATE.

      LV_TO_SLICE_DATE =
          LV_FROM_SLICE_DATE + LAYOUTS_USAGE_DAYS_SLICE.


    ENDWHILE.

    FREE LT_LAYOUTS_USAGE.
    APPEND LINES OF LT_HASH_LAYOUTS_USAGE TO LT_LAYOUTS_USAGE.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE
      TABLES
        LT_LAYOUTS_USAGE
      USING
         G_IREF_PDOCUMENT
        'NAST'.

***************************
    LV_MESSAGE = 'After Layouts Usage Data'.                "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************

    " Else, get layout usage from RFC system
  ELSEIF EXTRACT_LAYOUTS_USAGE_VIA_RFC = ABAP_TRUE.

***************************
    LV_MESSAGE = 'Before Layouts Usage Count via RFC'.      "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************

    IF ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

      " Count the number of entries in NAST in the last year
      CONCATENATE 'ERDAT GE ''' LV_USAGE_START_DATE ''''
      INTO LS_STR_CONDITION.
      .
      CALL FUNCTION 'SELECT_COUNT' DESTINATION P_RFCDES
        EXPORTING
          TABNAME               = 'NAST'
          WHERE                 = LS_STR_CONDITION
*         BYPASSINGBUFFER       = ' '
        IMPORTING
          HITS                  = LV_LINES
        EXCEPTIONS
          SYSTEM_FAILURE        = 1 MESSAGE LV_RFC_ERROR
          COMMUNICATION_FAILURE = 2 MESSAGE LV_RFC_ERROR
          OTHERS                = 3.

      IF SY-SUBRC <> 0.

        LV_STR_SY_SUBRC = SY-SUBRC.
        CONCATENATE 'WARNING!! SY-SUBRC =' LV_STR_SY_SUBRC
        'when calling SELECT_COUNT for NAST - '             "#EC NOTEXT
        INTO LV_MESSAGE SEPARATED BY SPACE.

        IF SY-SUBRC = 1 OR
           SY-SUBRC = 2.

          CONCATENATE LV_MESSAGE LV_RFC_ERROR
          INTO LV_MESSAGE SEPARATED BY SPACE.

        ENDIF.

      ELSE.

        LV_LINES_STR = LV_LINES.
        CONCATENATE 'Total records in NAST (1 year back):'  "#EC NOTEXT
        LV_LINES_STR
        INTO LV_MESSAGE SEPARATED BY SPACE.

      ENDIF.

      PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.

    ENDIF. "if ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

***************************
    LV_MESSAGE = 'Before Layouts Usage Data via RFC'.       "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************

    " Get layout program keys
    PERFORM GET_LAYOUT_PROGRAMS_KEY
      CHANGING
        LT_TNAPR_KEY.

    DESCRIBE TABLE LT_TNAPR_KEY LINES LV_NUMBER_OF_ENTRIES.

    IF LV_NUMBER_OF_ENTRIES > 0.

      " Get layout usage by slice dates
      LV_FROM_SLICE_DATE = LV_USAGE_START_DATE.
      LV_TO_SLICE_DATE = LV_FROM_SLICE_DATE +
                         LAYOUTS_USAGE_DAYS_SLICE_RFC.

      " For each slice from the last year until today,
      " get the layout usage
      WHILE L_STARTDATE >= LV_FROM_SLICE_DATE.

        " Get usage of layout program by the current slice dates,
        " and save it in hash table
        PERFORM GET_LAYOUT_USAGE_BY_DATES
          USING
            LV_FROM_SLICE_DATE
            LV_TO_SLICE_DATE
          CHANGING
            LT_HASH_LAYOUTS_USAGE.

        LV_FROM_SLICE_DATE = LV_TO_SLICE_DATE.
        LV_TO_SLICE_DATE =
            LV_FROM_SLICE_DATE + LAYOUTS_USAGE_DAYS_SLICE_RFC.

      ENDWHILE.

    ENDIF.

    " Check if there are layout usage
    DESCRIBE TABLE LT_HASH_LAYOUTS_USAGE LINES LV_NUMBER_OF_ENTRIES.

    IF LV_NUMBER_OF_ENTRIES > 0.

      " Insert layout usage to sorted table.
      INSERT LINES OF LT_HASH_LAYOUTS_USAGE
      INTO TABLE LT_SORTED_LAYOUTS_USAGE.

      DELETE LT_SORTED_LAYOUTS_USAGE WHERE COUNT = 0.

      SORT LT_TNAPR_KEY BY KSCHL NACHA KAPPL.

      " For each record in 'tnapr' check if it have usage,
      " then add it to xml.
      LOOP AT LT_TNAPR_KEY ASSIGNING <LS_TNAPR_KEYS>.

        LOOP AT LT_SORTED_LAYOUTS_USAGE
        ASSIGNING <LS_LAYOUT_USAGE>
        WHERE KSCHL = <LS_TNAPR_KEYS>-KSCHL AND
              NACHA = <LS_TNAPR_KEYS>-NACHA AND
              KAPPL = <LS_TNAPR_KEYS>-KAPPL.

          APPEND <LS_LAYOUT_USAGE> TO LT_LAYOUTS_USAGE.

        ENDLOOP.

      ENDLOOP.

      " Add layout usage to xml.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE
        TABLES
          LT_LAYOUTS_USAGE
        USING
           G_IREF_PDOCUMENT
          'NAST'.

      FREE: LT_LAYOUTS_USAGE, LT_HASH_LAYOUTS_USAGE.

    ENDIF.

*    ENDLOOP.

***************************
    LV_MESSAGE = 'After Layouts Usage Data'.                "#EC NOTEXT
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_TRUE.
***************************

  ENDIF.


  PERFORM APPEND_STRING_TO_FILE USING '</LAYOUTS_USAGE>'.

  PERFORM ADD_TIME_STAT USING 'Extract Layouts Usage'       "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    "EXTRACT_LAYOUTS_USAGE

*&---------------------------------------------------------------------*
*&      Form  extract_usage
*&---------------------------------------------------------------------*
FORM EXTRACT_USAGE .

  TYPES: BEGIN OF T_USAGE_ENTRIES,
          TOTAL_ENTRIES TYPE I,
         END OF T_USAGE_ENTRIES.

  DATA: LS_USAGE_ENTRIES TYPE T_USAGE_ENTRIES,
        LT_USAGE_ENTRIES TYPE TABLE OF T_USAGE_ENTRIES.

  DATA: TCODESTAT  TYPE TABLE OF SAPWLUSTCX,
        RFC_STAT   TYPE TABLE OF SAPWLRFCS,
        RFC_STAT_REC LIKE LINE OF RFC_STAT,
        TCODE_LINE LIKE LINE OF TCODESTAT.

  DATA: BEGIN OF ENTRY_ID_TYPE,
          TCODE_OR_REPORT LIKE SAPWLPFNRM-REPORT,
          JOBNAME         LIKE SAPWLPFBTC-JOBNAME,
          TYPE,           "T)code or R)eport F)unction?
        END OF ENTRY_ID_TYPE.

  DATA: USAGE_START_DATE TYPE BEGDA.

  DATA: USAGE_NODE TYPE XML_ELEMENT,
        LV_LAYOUTS_USAGE_NODE TYPE XML_ELEMENT,
        USERS_NODE TYPE XML_ELEMENT,
        CALLERS_NODE TYPE XML_ELEMENT,
        LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LT_USAGE_USERS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

  DATA: SAPWLSERV_TAB TYPE TABLE OF SAPWLSERV,
        SAPWLSERV_REC LIKE LINE OF SAPWLSERV_TAB,
        OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        INSTANCE_NAME LIKE SAPWLSERV-NAME,
        IS_DATA.

  DATA: FULL_TCODESTAT TYPE TABLE OF SAPWLUSTCX.

  DATA: LT_MONTH   TYPE TABLE OF SY-DATUM,
        LT_WEEK    TYPE TABLE OF SY-DATUM,
        LT_DAY     TYPE TABLE OF SY-DATUM.

  DATA: DATATAB TYPE TABLE OF OUTREC.

  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: LV_USAGE_START_MONTH TYPE DATUM.
  DATA: LV_USAGE_START_WEEK TYPE DATUM.
  DATA: LV_DAY_IN_CURRENT_WEEK TYPE I.

  CHECK VANILLA = ''.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Usage'.         "#EC NOTEXT

* Get the servers for instances
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE = 'SAPWLSERV'
      DELIMITER   = SPACE
      NO_DATA     = SPACE
      ROWSKIPS    = 0
      ROWCOUNT    = 0
    TABLES
      OPTIONS     = OPTIONS
      FIELDS      = FIELDS
      DATA        = SAPWLSERV_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE        = 1
      TABLE_WITHOUT_DATA         = 2
      OPTION_NOT_VALID           = 3
      FIELD_NOT_VALID            = 4
      NOT_AUTHORIZED             = 5
      DATA_BUFFER_EXCEEDED       = 6
      OTHERS                     = 7.

  IF sy-subrc <> 0.
    DATA lv_message TYPE string.

    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
         INTO lv_message.

    PERFORM ADD_MESSAGE USING lv_message ABAP_TRUE.

    MESSAGE A000(CONV) WITH lv_message.
        RETURN.
  ENDIF.

  IF NOT EXTRACT_TOTAL_INSTANCE IS INITIAL.
    SAPWLSERV_REC-NAME = 'TOTAL'.
    APPEND SAPWLSERV_REC TO SAPWLSERV_TAB.
    CLEAR SAPWLSERV_REC.
  ENDIF.

* Create a child node for the Usage node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'USAGE'
                          CHANGING USAGE_NODE.

  PERFORM APPEND_STRING_TO_FILE USING '<USAGE>'.

  PERFORM EXTRACT_WEB_USAGE_CONFIG USING USAGE_NODE.

  PERFORM GET_USAGE_START_DATE
    USING USAGE_EXTRACTION_DAYS
    CHANGING USAGE_START_DATE.

* // Convert Date Range To Table Of Months
* // e.g: 20071201 - 20080201 => 20071201
* //                             20080101
* //                             20080201
  "Set date to first day of month
  LV_USAGE_START_WEEK = LV_USAGE_START_MONTH = USAGE_START_DATE.
  LV_USAGE_START_MONTH+6(2) = '01'.

  "Set date to first day of week
  LV_DAY_IN_CURRENT_WEEK = ( ( SY-DATUM + 1 - SY-FDAYW ) - LV_USAGE_START_WEEK ) MOD 7.
  IF LV_DAY_IN_CURRENT_WEEK <> 0.
    LV_USAGE_START_WEEK = LV_DAY_IN_CURRENT_WEEK + LV_USAGE_START_WEEK - 7.
  ENDIF.

  PERFORM PERIOD_TO_MONTES USING LV_USAGE_START_MONTH
                                 SY-DATUM
                        CHANGING LT_MONTH.

* // Retrieve From All Application Servers in The SAP Landscape The
* // Tcode & Report
* // Usage Statistics Per Each Month In The Table
  PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_MONTH
                                    SAPWLSERV_TAB
                                    FULL_TCODESTAT
                             USING 'M'
                             CHANGING IS_DATA.


* If no monthly data was found - get weekly data
  IF IS_DATA IS INITIAL.

*   Get weeks two years back
    PERFORM PERIOD_TO_WEEKS USING LV_USAGE_START_WEEK
                                   SY-DATUM
                          CHANGING LT_WEEK.

    PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_WEEK
                                      SAPWLSERV_TAB
                                      FULL_TCODESTAT
                               USING 'W'
                               CHANGING IS_DATA.
  ENDIF.

* If no monthly and weekly data was found - get daily data
  IF IS_DATA IS INITIAL.

*   Get days two years back
    PERFORM PERIOD_TO_DAYS USING USAGE_START_DATE
                                 SY-DATUM
                        CHANGING LT_DAY.

    PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_DAY
                                      SAPWLSERV_TAB
                                      FULL_TCODESTAT
                               USING 'D'
                               CHANGING IS_DATA.
  ENDIF.

* If no usage was found at all, throw error message
  DATA: MSG1 TYPE STRING,
        MSG2 TYPE STRING.

  IF IS_DATA IS INITIAL.
    NO_USAGE = 'X'.
  ENDIF.

* Read infotype statistics
  PERFORM READ_INFOTYPE_STATISCTICS CHANGING DATATAB.

  IF NOT DATATAB[] IS INITIAL.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES DATATAB
                                    USING G_IREF_PDOCUMENT
                                          'USAGE_TCODE'.
  ENDIF.

* Create a child node for the layouts usage node
*  perform create_xml_node using g_iref_pdocument g_iref_root_elem
*                                'LAYOUTS_USAGE'
*                          changing lv_layouts_usage_node.
*  perform append_string_to_file using '<LAYOUTS_USAGE>'.
*
** Read layouts usage
*  perform add_layouts_usage using two_years_back
*                                  lv_layouts_usage_node.
*  perform append_string_to_file using '</LAYOUTS_USAGE>'.

* Extract full usage data
  IF NOT EXTRACT_FULL_USAGE IS INITIAL AND
    NO_SUET_DATA IS INITIAL.
*   Full usage entries count
    DESCRIBE TABLE FULL_TCODESTAT LINES LS_USAGE_ENTRIES-TOTAL_ENTRIES.
    APPEND LS_USAGE_ENTRIES TO LT_USAGE_ENTRIES.

    PERFORM APPEND_STRING_TO_FILE USING '<ST03N_ENTRIES>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_USAGE_ENTRIES
                                    USING G_IREF_PDOCUMENT
                                          'ST03N_ENTRIES'.
    PERFORM APPEND_STRING_TO_FILE USING '</ST03N_ENTRIES>'.

*   Full usage data
    PERFORM APPEND_STRING_TO_FILE USING '<FULL_ST03N>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES FULL_TCODESTAT
                                    USING G_IREF_PDOCUMENT
                                          'ST03N'.
    PERFORM APPEND_STRING_TO_FILE USING '</FULL_ST03N>'.
  ENDIF.

  FREE: DATATAB, FULL_TCODESTAT[].

  IF NOT EXTRACT_PROXY_DATA IS INITIAL.
    PERFORM EXTRACT_PROXIES_USAGE.
  ENDIF.

  IF NOT EXTRACT_LAYOUTS_USAGE IS INITIAL.
    PERFORM EXTRACT_LAYOUTS_USAGE.
  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</USAGE>'.

  PERFORM ADD_TIME_STAT USING 'Extract usage'               "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_usage

*---------------------------------------------------------------------*
*       FORM GET_USAGE_START_DATE                                     *
*---------------------------------------------------------------------*
*                                                                     *
*---------------------------------------------------------------------*
FORM GET_USAGE_START_DATE
  USING DEFAULT_DAYS_BACK TYPE I
  CHANGING START_DATE     TYPE DATUM.

  DATA LS_SYSTEM_DATE TYPE TY_EXTRACT_USAGE_DATE.

* first, put the default value
  START_DATE = SY-DATUM - DEFAULT_DAYS_BACK.

* check the user wants to get only the delta in usage data,
* and not all the usage data
  CHECK NOT GET_USAGE_DELTA IS INITIAL.

* get last extraction date from WS
  READ TABLE GT_USAGE_EXTRACT_DATES_WS WITH TABLE KEY
    SYSTEM_NAME = RFC_SYSID INTO LS_SYSTEM_DATE.

  IF NOT LS_SYSTEM_DATE IS INITIAL.
    START_DATE = LS_SYSTEM_DATE-LAST_EXTRACTION_DATE.
  ELSE.
*   if no results from WS, get data added when the extractor created
    READ TABLE GT_USAGE_EXTRACT_DATES WITH TABLE KEY
      SYSTEM_NAME = RFC_SYSID INTO LS_SYSTEM_DATE.

    IF NOT LS_SYSTEM_DATE IS INITIAL.
      START_DATE = LS_SYSTEM_DATE-LAST_EXTRACTION_DATE.
    ENDIF.
  ENDIF.

ENDFORM.                    " GET_USAGE_START_DATE

*&---------------------------------------------------------------------*
*&      Form  get_layout_programs_key
*&---------------------------------------------------------------------*
FORM GET_LAYOUT_PROGRAMS_KEY
    CHANGING
      CT_TNAPR_KEY TYPE ANY TABLE.

  DATA:
    LV_TABNAME           LIKE DD02L-TABNAME,
    LT_TNAPR_KEY         TYPE TABLE OF TAB512,
    LT_OPTIONS           TYPE TABLE OF RFC_DB_OPT,
    LT_FIELDS            TYPE TABLE OF RFC_DB_FLD,
    LS_FIELDS            LIKE LINE  OF LT_FIELDS,
    ERROR                TYPE STRING.

  " select the fields
  LS_FIELDS-FIELDNAME = 'KSCHL'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'NACHA'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'KAPPL'.
  APPEND LS_FIELDS TO  LT_FIELDS.

  " from table
  LV_TABNAME = 'TNAPR'.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE           = LV_TABNAME
      DELIMITER             = SPACE
      NO_DATA               = SPACE
      ROWSKIPS              = 0
      ROWCOUNT              = 0
    TABLES
      OPTIONS               = LT_OPTIONS
      FIELDS                = LT_FIELDS
      DATA                  = LT_TNAPR_KEY
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7
      COMMUNICATION_FAILURE = 8
      OTHERS                = 9.


  IF NOT ( SY-SUBRC IS INITIAL AND
     NOT LT_TNAPR_KEY IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'Cann''t get processing programs '                      "#EC NOTEXT
    'for output data TNAPR from '                           "#EC NOTEXT
    P_RFCDES
    ' failed. Error: ' ERROR                                "#EC NOTEXT
    INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  ENDIF.

  CT_TNAPR_KEY[] = LT_TNAPR_KEY[].

  FREE: LT_FIELDS, LT_OPTIONS, LT_TNAPR_KEY.

ENDFORM.                    "GET_LAYOUT_PROGRAMS_KEY
*---------------------------------------------------------------------*
*       FORM get_layout_usage_by_dates                                *
*---------------------------------------------------------------------*
*       Count and set that last usage date                            *
*       of combination kschl, nacha, kappl, objtype                   *
*       for each date slice                                           *
*---------------------------------------------------------------------*
**  -->  is_tnapr_keys                                                *
*  -->  iv_date_from                                                  *
*  -->  iv_date_to                                                    *
*  <--  ct_hash_layouts_usage                                         *
*---------------------------------------------------------------------*
FORM GET_LAYOUT_USAGE_BY_DATES
    USING
*      is_tnapr_keys TYPE ts_tnapr_key
      IV_DATE_FROM  TYPE D
      IV_DATE_TO    TYPE D
    CHANGING
      CT_HASH_LAYOUTS_USAGE TYPE TT_HASH_LAYOUT_USAGE.

  TYPES:
    BEGIN OF TS_LAYOUT_USAGE,
      KSCHL   TYPE NAST-KSCHL,
      NACHA   TYPE NAST-NACHA,
      KAPPL   TYPE NAST-KAPPL,
      OBJTYPE TYPE NAST-OBJTYPE,
      ERDAT   TYPE NAST-ERDAT,
    END OF TS_LAYOUT_USAGE.

  DATA:
    LV_TABNAME       LIKE DD02L-TABNAME,
    LT_NAST_USAGE    TYPE TABLE OF TS_LAYOUT_USAGE,
    LT_OPTIONS       TYPE TABLE OF RFC_DB_OPT,
    LT_FIELDS        TYPE TABLE OF RFC_DB_FLD,
    LS_FIELDS        LIKE LINE OF LT_FIELDS,
    ERROR            TYPE STRING,
    LV_STR_CONDITION TYPE STRING,
    LV_NUMBER_OF_ENTRIES TYPE STRING,
    LS_LAYOUTS_USAGE LIKE LINE OF CT_HASH_LAYOUTS_USAGE.

  FIELD-SYMBOLS:
    <LS_HASH_LAYOUTS_USAGE> LIKE LINE OF CT_HASH_LAYOUTS_USAGE,
    <LT_NAST_USAGE>         LIKE LINE OF LT_NAST_USAGE.

  " select the fields
  LS_FIELDS-FIELDNAME = 'KSCHL'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'NACHA'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'KAPPL'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'OBJTYPE'.
  APPEND LS_FIELDS TO  LT_FIELDS.
  LS_FIELDS-FIELDNAME = 'ERDAT'.
  APPEND LS_FIELDS TO  LT_FIELDS.

  " From table
  LV_TABNAME = 'NAST'.

  " Where created date between the slice dates and layout
  " key( layout program processing ).
  CONCATENATE 'ERDAT >= ''' IV_DATE_FROM ''' AND '
  INTO LV_STR_CONDITION.
  APPEND LV_STR_CONDITION TO LT_OPTIONS.

  CONCATENATE 'ERDAT < ''' IV_DATE_TO ''''
  INTO LV_STR_CONDITION.
  APPEND LV_STR_CONDITION TO LT_OPTIONS.

  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE           = LV_TABNAME
      DELIMITER             = SPACE
      NO_DATA               = SPACE
      ROWSKIPS              = 0
      ROWCOUNT              = 0
    TABLES
      OPTIONS               = LT_OPTIONS
      FIELDS                = LT_FIELDS
      DATA                  = LT_NAST_USAGE
    EXCEPTIONS
      TABLE_NOT_AVAILABLE   = 1
      TABLE_WITHOUT_DATA    = 2
      OPTION_NOT_VALID      = 3
      FIELD_NOT_VALID       = 4
      NOT_AUTHORIZED        = 5
      DATA_BUFFER_EXCEEDED  = 6
      SYSTEM_FAILURE        = 7
      COMMUNICATION_FAILURE = 8
      OTHERS                = 9.


  IF NOT ( SY-SUBRC IS INITIAL ).

    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE
    'Cann''t get usage of layout data NAST from ' P_RFCDES  "#EC NOTEXT
          ' failed for between : '                          "#EC NOTEXT
          IV_DATE_FROM  ' and ' IV_DATE_TO                  "#EC NOTEXT
          ' Error: ' ERROR                                  "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
  ELSE.

    DESCRIBE TABLE LT_NAST_USAGE LINES LV_NUMBER_OF_ENTRIES.

    CONCATENATE
    'Number of layouts usage NAST that found from ' P_RFCDES "#EC NOTEXT
          ' between ' IV_DATE_FROM ' and '                  "#EC NOTEXT
          IV_DATE_TO ' is: '                                "#EC NOTEXT
          LV_NUMBER_OF_ENTRIES
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM ADD_USED_MEMORY_TO_LOG.

  ENDIF.

  LOOP AT LT_NAST_USAGE ASSIGNING <LT_NAST_USAGE>.

    READ TABLE CT_HASH_LAYOUTS_USAGE
    WITH TABLE KEY
        KSCHL   = <LT_NAST_USAGE>-KSCHL
        NACHA   = <LT_NAST_USAGE>-NACHA
        KAPPL   = <LT_NAST_USAGE>-KAPPL
        OBJTYPE = <LT_NAST_USAGE>-OBJTYPE
        ASSIGNING <LS_HASH_LAYOUTS_USAGE>.

    IF SY-SUBRC EQ 0.

      ADD 1 TO <LS_HASH_LAYOUTS_USAGE>-COUNT.
      IF <LT_NAST_USAGE>-ERDAT GT <LS_HASH_LAYOUTS_USAGE>-LAST_USED_DATE
 .
        <LS_HASH_LAYOUTS_USAGE>-LAST_USED_DATE = <LT_NAST_USAGE>-ERDAT.
      ENDIF.

    ELSE.

      CLEAR LS_LAYOUTS_USAGE.
      LS_LAYOUTS_USAGE-KSCHL   = <LT_NAST_USAGE>-KSCHL.
      LS_LAYOUTS_USAGE-NACHA   = <LT_NAST_USAGE>-NACHA.
      LS_LAYOUTS_USAGE-KAPPL   = <LT_NAST_USAGE>-KAPPL.
      LS_LAYOUTS_USAGE-OBJTYPE = <LT_NAST_USAGE>-OBJTYPE.
      LS_LAYOUTS_USAGE-LAST_USED_DATE = <LT_NAST_USAGE>-ERDAT.
      ADD 1 TO LS_LAYOUTS_USAGE-COUNT.
      INSERT  LS_LAYOUTS_USAGE INTO TABLE CT_HASH_LAYOUTS_USAGE.

    ENDIF.

  ENDLOOP.

  FREE: LT_FIELDS, LT_OPTIONS, LT_NAST_USAGE.


ENDFORM.                    "GET_LAYOUT_USAGE_BY_DATES
*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_USAGE_CONFIG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_NODE_REF text
*----------------------------------------------------------------------*
FORM EXTRACT_WEB_USAGE_CONFIG USING P_NODE_REF TYPE XML_ELEMENT.

  DATA:PARAMETER_TABLE TYPE SAPWLCOLPARAMS,
       PARAMETER_WA    TYPE SAPWLCOLPA,
       WA_LIST         TYPE SAPWLPARNS,
       T_LIST          TYPE SAPWLPARAMNAMES,
       WEB_CONFIG_NODE TYPE XML_ELEMENT.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                        P_NODE_REF
                                        'WEB_STAT_CONFIG'
                                  CHANGING WEB_CONFIG_NODE.

* This code is taken from program SWNC_CONFIG_URL.
* Check the system's configuration
  WA_LIST-PARAMNAME  = 'HTTP_STATREC_PATH_SPLIT_RULE'.
  APPEND WA_LIST TO T_LIST.
  WA_LIST-PARAMNAME  = 'HTTP_STATREC_PATH_SPLIT_RULE_WEB'.
  APPEND WA_LIST TO T_LIST.

  CALL FUNCTION 'SAPWL_PARAMETERS_READ'
    EXPORTING
      PARAMETER_LIST      = T_LIST
    IMPORTING
      PARAMETER_TABLE     = PARAMETER_TABLE
    EXCEPTIONS
      PARAMETER_NOT_FOUND = 1
      OTHERS              = 2.

  READ TABLE PARAMETER_TABLE INTO PARAMETER_WA WITH KEY PARAMNAME =
  'HTTP_STATREC_PATH_SPLIT_RULE'.
  IF SY-SUBRC = 0.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING WEB_CONFIG_NODE
    'TRANS_PROFILE' PARAMETER_WA-PAR_INTVAL.
  ENDIF.
  READ TABLE PARAMETER_TABLE INTO PARAMETER_WA WITH KEY PARAMNAME =
  'HTTP_STATREC_PATH_SPLIT_RULE_WEB'.
  IF SY-SUBRC = 0.
    PERFORM ADD_ATTRIBUTE_TO_NODE USING WEB_CONFIG_NODE 'WEB_CONFIG'
    PARAMETER_WA-PAR_INTVAL.
  ENDIF.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING WEB_CONFIG_NODE 'X'.

ENDFORM.                    "EXTRACT_WEB_USAGE_CONFIG
*&---------------------------------------------------------------------*
*&      Form  period_to_montes
*&---------------------------------------------------------------------*
FORM PERIOD_TO_MONTES USING BEGDA
                            ENDDA
                   CHANGING PTMONTH TYPE TABLE.

  DATA: DATE TYPE DATUM,
        LAST_MONTH(2) TYPE N,
        CURR_MONTH(2) TYPE N.

  DATE = BEGDA.

  WHILE DATE < ENDDA.
    APPEND DATE TO PTMONTH.
    CALL FUNCTION 'RE_ADD_MONTH_TO_DATE'
      EXPORTING
        MONTHS  = '1'
        OLDDATE = DATE
      IMPORTING
        NEWDATE = DATE.
  ENDWHILE.

* Add handle last date: only if the monthes equal, add it.
* There are cases when the last month will be higher than current month,
* in these cases we wouldn't like to add the last month.
  LAST_MONTH = DATE+4(2).
  CURR_MONTH = ENDDA+4(2).
  IF ( LAST_MONTH = CURR_MONTH ).
    APPEND DATE TO PTMONTH.
  ENDIF.

ENDFORM.                    " period_to_montes

*---------------------------------------------------------------------*
*       FORM PERIOD_TO_WEEKS                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  BEGDA                                                         *
*  -->  ENDDA                                                         *
*  -->  PTWEEK                                                        *
*---------------------------------------------------------------------*
FORM PERIOD_TO_WEEKS USING  BEGDA
                            ENDDA
                   CHANGING PTWEEK TYPE TABLE.

  DATA: DATE TYPE DATUM.

  DATE = BEGDA.

  WHILE DATE < ENDDA.
    DATE = DATE + 7.
    APPEND DATE TO PTWEEK.
  ENDWHILE.

ENDFORM.                    "PERIOD_TO_WEEKS

*---------------------------------------------------------------------*
*       FORM PERIOD_TO_DAYS                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  BEGDA                                                         *
*  -->  ENDDA                                                         *
*  -->  PTDAY                                                         *
*---------------------------------------------------------------------*
FORM PERIOD_TO_DAYS USING  BEGDA
                           ENDDA
                  CHANGING PTDAY TYPE TABLE.

  DATA: DATE TYPE DATUM.

  DATE = BEGDA.

  WHILE DATE < ENDDA.
    DATE = DATE + 1.
    APPEND DATE TO PTDAY.
  ENDWHILE.

ENDFORM.                    "PERIOD_TO_DAYS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM EXTRACT_USAGE_FOR_PERIOD TABLES   T_PERIOD
                                       T_SAPWLSERV_TAB
                                       T_FULL_USAGE
                              USING    P_PERIOD TYPE SAPWLACCPT
                              CHANGING P_IS_DATA.

  TYPES: BEGIN OF USER_DATA_TYPE,
           USERNAME  TYPE SAPWLUTACC,
           USERUSAGE TYPE NUM10,
         END OF USER_DATA_TYPE,
         BEGIN OF CALLERS_DATA_TYPE,
           CALLER_NAME LIKE SAPWLRFCS-REMOT_DEST,
         END OF CALLERS_DATA_TYPE.

  DATA:
    DATE          TYPE SY-DATUM,
    SAPWLSERV_REC TYPE SAPWLSERV,
    INSTANCE_NAME LIKE SAPWLSERV-NAME.

  DATA: RECORD TYPE TY_RECORD.

  DATA: TTAB       LIKE TABLE OF RECORD.
  DATA: CURR_RECORD LIKE RECORD,
        PREV_RECORD LIKE RECORD.

  DATA: TEMP_TTAB TYPE TT_RECORD.

  DATA: TOTAL_USAGE    TYPE P,
        USAGE_PER_USER TYPE P.

  DATA: USERS   TYPE TABLE OF USER_DATA_TYPE WITH HEADER LINE,
        CALLERS TYPE TABLE OF CALLERS_DATA_TYPE WITH HEADER LINE,
        CALLERS_HASHED TYPE HASHED TABLE OF CALLERS_DATA_TYPE WITH
        UNIQUE KEY CALLER_NAME,
        CALLERS_WA TYPE CALLERS_DATA_TYPE.

  DATA: LT_MONTH TYPE TABLE OF SY-DATUM,
        LT_WEEK  TYPE TABLE OF SY-DATUM,
        LT_DAY   TYPE TABLE OF SY-DATUM,
        OUTREC   TYPE OUTREC.

  DATA: DATATAB TYPE TABLE OF OUTREC.

  DATA: USAGE_NODE           TYPE XML_ELEMENT,
        USERS_NODE           TYPE XML_ELEMENT,
        CALLERS_NODE         TYPE XML_ELEMENT,
        LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        LT_USAGE_USERS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        TCODE_VALID          TYPE FLAG.

  CHECK VANILLA = ''.

  PERFORM EXTRACT_WEBI_USAGE.
* Create range for ws
  PERFORM CREATE_WS_FILTER_RANGE CHANGING LT_WS_FILTER.

* Check if extract wd data is on
  IF EXTRACT_WD_DATA EQ 'X'.
    PERFORM EXTRACT_WD_ABAP_USAGE_OBJECTS.
    PERFORM CREATE_WD_ABAP_FILTER_RANGE CHANGING LT_WD_ABAP_FILTER.
  ENDIF.

  FREE GT_OBJ_WEBI[].
  FREE GT_OBJ_WD[].

  LOOP AT T_PERIOD INTO DATE.

    LOOP AT T_SAPWLSERV_TAB INTO SAPWLSERV_REC.

      INSTANCE_NAME = SAPWLSERV_REC-NAME.
      CLEAR: TEMP_TTAB[].

      CONCATENATE 'Extract Usage (tcode+rfc)- Period: '     "#EC NOTEXT
          P_PERIOD DATE
          ' Instance: ' INSTANCE_NAME                       "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*     Extract tcode & rfc usage
      PERFORM GET_TCODE_RFC_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
                                              USING DATE
                                                    INSTANCE_NAME
                                                    P_PERIOD
                                           CHANGING TEMP_TTAB
                                                    P_IS_DATA.

*     Extract Web Statistics
*     Check that RFC target is 700 or higher
*     to verify that the function exists in destination
*     and only if we have web services / web dynpro white list
      IF NO_WEB_USAGE IS INITIAL AND
       ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ) AND
       ( LT_WS_FILTER[] IS NOT INITIAL OR
          LT_WD_ABAP_FILTER[] IS NOT INITIAL ).

        CONCATENATE 'Extract Usage (web)- Period: '         "#EC NOTEXT
            P_PERIOD DATE
            ' Instance: ' INSTANCE_NAME                     "#EC NOTEXT
            INTO GT_ETL_MESSAGE-MESSAGE.

        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM GET_WEB_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
                                          USING DATE
                                                INSTANCE_NAME
                                                P_PERIOD
                                                LT_WS_FILTER
                                                LT_WD_ABAP_FILTER
                                       CHANGING TEMP_TTAB.
      ENDIF.

      PERFORM ADD_USED_MEMORY_TO_LOG.

*     Append the temp records to main ttab
      IF NOT TEMP_TTAB[] IS INITIAL.
        APPEND LINES OF TEMP_TTAB TO TTAB.
      ENDIF.

      CONCATENATE 'Extract Usage (fetched data)- Period: '  "#EC NOTEXT
          P_PERIOD DATE
          ' Instance: ' INSTANCE_NAME                       "#EC NOTEXT
          INTO GT_ETL_MESSAGE-MESSAGE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

    ENDLOOP.

*   Anna - aggregate the records by program and
*   user name ( don't duplicate jobs )
    SORT TTAB BY PERIOD TCODE TYPE USER REMOT_DEST JOBNAME.
    LOOP AT TTAB INTO RECORD.

      CLEAR TCODE_VALID.

      PERFORM IS_TCODE_VALID
                  USING
                     RECORD-TCODE
                  CHANGING
                     TCODE_VALID.

      CHECK TCODE_VALID = 'X'.

      CURR_RECORD = RECORD.
      TOTAL_USAGE = TOTAL_USAGE + CURR_RECORD-USAGE.
      USAGE_PER_USER = USAGE_PER_USER + CURR_RECORD-USAGE.

*     When reaching to a new username ( the program stays
*     stays unchanged ) - put it into results table
      AT END OF USER.
        USERS-USERNAME = CURR_RECORD-USER.
        USERS-USERUSAGE = USAGE_PER_USER.
        APPEND USERS.
        CLEAR USAGE_PER_USER.
      ENDAT.

      AT END OF REMOT_DEST.
*       check if caller already exists for this tcode.
        CALLERS_WA-CALLER_NAME = CURR_RECORD-REMOT_DEST.
        READ TABLE CALLERS_HASHED
          WITH TABLE KEY CALLER_NAME = CALLERS_WA-CALLER_NAME
          TRANSPORTING NO FIELDS.

*       if not, add to hash table and to output
        IF SY-SUBRC <> 0.
          INSERT CALLERS_WA INTO TABLE CALLERS_HASHED.
          CALLERS-CALLER_NAME = CALLERS_WA-CALLER_NAME.
          APPEND CALLERS.
        ENDIF.
      ENDAT.

*     When reaching to a new transaction print it
      AT END OF TCODE.
        MOVE-CORRESPONDING CURR_RECORD TO OUTREC.
        OUTREC-USAGE = TOTAL_USAGE.
        APPEND OUTREC TO DATATAB.

        PERFORM ADD_ITAB_TO_XML TABLES DATATAB LT_USAGE_TCODE_NODES
                                USING G_IREF_PDOCUMENT USAGE_NODE
                                      'USAGE_TCODE'.


        PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                      LT_USAGE_TCODE_NODES-NODE_REF
                                      'USERS'
                                CHANGING USERS_NODE.

        PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES USERS
                                USING G_IREF_PDOCUMENT USERS_NODE
                                        'USER'.

        IF CURR_RECORD-TYPE = 'F'.
          PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                        LT_USAGE_TCODE_NODES-NODE_REF
                                        'CALLERS'
                                  CHANGING CALLERS_NODE.

          PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES CALLERS
                                  USING G_IREF_PDOCUMENT CALLERS_NODE
                                          'CALLER'.
        ENDIF.
        PERFORM EXTRACT_WEB_DATA USING RECORD-TCODE
                                       RECORD-TYPE
                                       LT_USAGE_TCODE_NODES-NODE_REF.
        PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                               LT_USAGE_TCODE_NODES-NODE_REF 'X'.

        CLEAR: TOTAL_USAGE, CALLERS_WA.
        FREE DATATAB.
        FREE: USERS, CALLERS, CALLERS_HASHED.
        FREE LT_USAGE_TCODE_NODES.

      ENDAT.

    ENDLOOP.

*   Clear TTAB.
    REFRESH TTAB.
*   Clear g_web_data for next period
    CLEAR G_WEB_DATA[].

    CONCATENATE 'Extract Usage (process done)- Period: '    "#EC NOTEXT
        P_PERIOD DATE
        INTO GT_ETL_MESSAGE-MESSAGE.

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

  ENDLOOP.
  FREE G_WEB_DATA.

ENDFORM.                    " EXTRACT_USAGE_FOR_PERIOD
*---------------------------------------------------------------------*
*       FORM READ_INFOTYPE_STATISCTICS                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_DATATAB                                                     *
*---------------------------------------------------------------------*
FORM READ_INFOTYPE_STATISCTICS  CHANGING P_DATATAB TYPE TABLE.

  TYPES: BEGIN OF T582A_TYPE,
           INFTY(4) TYPE C,
         END OF T582A_TYPE.

  DATA: T582A_TAB TYPE TABLE OF T582A_TYPE,
        T582A_REC LIKE LINE OF T582A_TAB,
        DBTABLE LIKE DD02L-TABNAME,
        NO_OF_ENTERIES TYPE I,
        DUMMY_TABLE TYPE TABLE OF TAB512,
        OPTIONS TYPE TABLE OF RFC_DB_OPT,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        FIELD_WA LIKE LINE OF FIELDS.

  DATA: BEGIN OF RECORD,
         PERIOD  TYPE CHAR6,
         TCODE   TYPE SAPWLPFNRM-REPORT,
         JOBNAME TYPE SY-CPROG,
         TYPE    TYPE CHAR1,
         USAGE   TYPE P,
         USERS   TYPE P,
       END OF RECORD.

  DATA: OUTREC   TYPE OUTREC.

  FIELD_WA-FIELDNAME = 'INFTY'.
  APPEND FIELD_WA TO FIELDS.

* Select all Infotypes
  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = 'T582A'
      DELIMITER            = SPACE
      NO_DATA              = SPACE
      ROWSKIPS             = 0
      ROWCOUNT             = 0
    TABLES
      OPTIONS              = OPTIONS
      FIELDS               = FIELDS
      DATA                 = T582A_TAB
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.

  IF SY-SUBRC <> 0.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
      WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
      WHEN 3. ERROR = 'OPTION_NOT_VALID'.
      WHEN 4. ERROR = 'FIELD_NOT_VALID'.
      WHEN 5. ERROR = 'NOT_AUTHORIZED'.
      WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
      WHEN 7. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'reading table T582A Error:' ERROR          "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    EXIT.
  ENDIF.

  LOOP AT T582A_TAB INTO T582A_REC.

*   Derive the table name
    CONCATENATE 'PA' T582A_REC-INFTY INTO DBTABLE.

*   Get the number of enteries for this table
    PERFORM GET_ROW_COUNT USING DBTABLE CHANGING NO_OF_ENTERIES.

*   if number of enteries greater than 0
    IF NO_OF_ENTERIES > 0.
      RECORD-PERIOD = SY-DATUM(6).
      CLEAR RECORD-JOBNAME.
      RECORD-TCODE = T582A_REC-INFTY.
      RECORD-TYPE = 'I'. " I)nfotype
      RECORD-USAGE = 1.
      RECORD-USERS = 1.
      MOVE-CORRESPONDING RECORD TO OUTREC.
      APPEND OUTREC TO P_DATATAB.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " read_infotype_statisctics
*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEBI_USAGE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_WEBI_USAGE.

  DATA: L_STARTTIME LIKE SY-UZEIT,
        L_STARTDATE LIKE SY-DATUM.

  DATA: SPROXDAT_ITAB TYPE TABLE OF SPROXDAT.

  DATA: LT_TADIR_WEBI TYPE STANDARD TABLE OF TADIR,
        LS_TADIR_WEBI TYPE TADIR.

  DATA:
      LS_OBJ_WEBI LIKE LINE OF GT_OBJ_WEBI.

  CHECK VANILLA = ''.

  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

* Get all customers dev classes
  PERFORM GET_DEV_CLASS_DATA.
  CHECK NOT LT_TDEVC[] IS INITIAL.

* Get all customers 'WEBI' objects that are web-services
  SELECT OBJECT OBJ_NAME
    FROM TADIR
    INTO CORRESPONDING FIELDS OF TABLE LT_TADIR_WEBI
     FOR ALL ENTRIES IN LT_TDEVC
   WHERE DEVCLASS = LT_TDEVC-DEVCLASS
     AND PGMID = 'R3TR'
     AND OBJECT IN ('WEBI').

  FREE: LT_TDEVC.
  CHECK NOT LT_TADIR_WEBI[] IS INITIAL.

  LOOP AT LT_TADIR_WEBI INTO LS_TADIR_WEBI.
    CLEAR LS_OBJ_WEBI.
    LS_OBJ_WEBI-OBJ_TYPE = LS_TADIR_WEBI-OBJECT.
    LS_OBJ_WEBI-OBJ_NAME = LS_TADIR_WEBI-OBJ_NAME.
    APPEND LS_OBJ_WEBI TO GT_OBJ_WEBI.

  ENDLOOP.

ENDFORM.                    " EXTRACT_WEBI_USAGE

*&---------------------------------------------------------------------*
*&      Form  CREATE_WS_FILTER_RANGE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_WS_ILTER  text
*----------------------------------------------------------------------*
FORM CREATE_WS_FILTER_RANGE  CHANGING P_LT_WS_FILTER TYPE RA_WS_FILTER.

  DATA: LT_WSHEADER TYPE TABLE OF WSHEADER.
  DATA: LS_WS_FILTER LIKE LINE OF P_LT_WS_FILTER.
  RANGES: LR_OBJ_WEBI FOR WSHEADER-WSNAME.
  FIELD-SYMBOLS: <LS_OBJ_WEBI> LIKE LINE OF GT_OBJ_WEBI,
                 <LS_WSHEADER> LIKE LINE OF LT_WSHEADER.


  CHECK NOT GT_OBJ_WEBI[] IS INITIAL.

  LOOP AT GT_OBJ_WEBI ASSIGNING <LS_OBJ_WEBI>.
    CLEAR LR_OBJ_WEBI.
    LR_OBJ_WEBI-SIGN = 'I'.
    LR_OBJ_WEBI-OPTION = 'EQ'.
    LR_OBJ_WEBI-LOW = <LS_OBJ_WEBI>-OBJ_NAME.
    APPEND LR_OBJ_WEBI.
  ENDLOOP.

*   Extract web services header data
  SELECT *
  FROM WSHEADER
  INTO CORRESPONDING FIELDS OF TABLE LT_WSHEADER
  FOR ALL ENTRIES IN LR_OBJ_WEBI
  WHERE VINAME = LR_OBJ_WEBI-LOW.

  LOOP AT LT_WSHEADER ASSIGNING <LS_WSHEADER>.
    CLEAR LS_WS_FILTER.
    LS_WS_FILTER-SIGN = 'I'.
    LS_WS_FILTER-OPTION = 'CP'.
    DATA TEMP_STR TYPE STRING.
    TEMP_STR = <LS_WSHEADER>-PREFIX.
    TRANSLATE TEMP_STR TO UPPER CASE.
    <LS_WSHEADER>-PREFIX = TEMP_STR.
    TEMP_STR = <LS_WSHEADER>-VINAME.
    TRANSLATE TEMP_STR TO UPPER CASE.
    <LS_WSHEADER>-VINAME = TEMP_STR.
    CONCATENATE
    <LS_WSHEADER>-PREFIX
    <LS_WSHEADER>-VINAME INTO
    LS_WS_FILTER-LOW SEPARATED BY '/'.
    CONCATENATE LS_WS_FILTER-LOW '*' INTO LS_WS_FILTER-LOW.
    APPEND LS_WS_FILTER TO P_LT_WS_FILTER.
  ENDLOOP.

  CLEAR : LT_WSHEADER[].

ENDFORM.                    " CREATE_WS_FILTER_RANGE
*&---------------------------------------------------------------------*
*&      Form  extract_wd_abap_usage_objects
*&---------------------------------------------------------------------*
*      Get the WD ABAP Objects
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_WD_ABAP_USAGE_OBJECTS. "WDABAP

  DATA: L_STARTTIME LIKE SY-UZEIT,
        L_STARTDATE LIKE SY-DATUM.

  DATA: SPROXDAT_ITAB TYPE TABLE OF SPROXDAT.

  DATA: LT_TADIR_WD TYPE STANDARD TABLE OF TADIR,
        LS_TADIR_WD TYPE TADIR.

  DATA:
      LS_OBJ_WD TYPE STRING.


  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

* Get all SAP/CUSTOMER applications
  SELECT OBJECT OBJ_NAME
    FROM TADIR
    INTO CORRESPONDING FIELDS OF TABLE LT_TADIR_WD
   WHERE
     PGMID = 'R3TR'
     AND OBJECT IN ('WDYA').

  FREE: LT_TDEVC.
  CHECK NOT LT_TADIR_WD[] IS INITIAL.

  LOOP AT LT_TADIR_WD INTO LS_TADIR_WD.
    CLEAR LS_OBJ_WD.
    IF LS_TADIR_WD-OBJ_NAME CS '/'.
      CONCATENATE '/SAP/BC/WEBDYNPRO' LS_TADIR_WD-OBJ_NAME INTO
      LS_OBJ_WD.
      TRANSLATE LS_OBJ_WD TO UPPER CASE.
    ELSE.
      CONCATENATE '/SAP/BC/WEBDYNPRO/SAP/' LS_TADIR_WD-OBJ_NAME INTO
      LS_OBJ_WD.
      TRANSLATE LS_OBJ_WD TO UPPER CASE.
    ENDIF.

    APPEND LS_OBJ_WD TO GT_OBJ_WD.

  ENDLOOP.

ENDFORM.                    " EXTRACT_WD_ABAP_USAGE_OBJECTS
*&---------------------------------------------------------------------*
*&      Form  CREATE_WD_ABAP_FILTER_RANGE
*&---------------------------------------------------------------------*
*       Create range of WD ABAP objects
*----------------------------------------------------------------------*
*      --
*----------------------------------------------------------------------*

FORM CREATE_WD_ABAP_FILTER_RANGE CHANGING P_LT_WD_ABAP_FILTER TYPE
RA_WD_ABAP_FILTER.

  DATA: LS_ABAP_FILTER LIKE LINE OF P_LT_WD_ABAP_FILTER.
  DATA: LS_WD_FILTER LIKE LINE OF P_LT_WD_ABAP_FILTER.
  DATA: STRING_LEN TYPE I.
  FIELD-SYMBOLS: <LS_OBJ_WD> LIKE LINE OF GT_OBJ_WD.


  CHECK NOT GT_OBJ_WD[] IS INITIAL.

* Sometimes usage appears with '/' suffix, we add them both to filter
  LOOP AT GT_OBJ_WD ASSIGNING <LS_OBJ_WD>.
    CLEAR LS_WD_FILTER.
    LS_WD_FILTER-SIGN = 'I'.
    LS_WD_FILTER-OPTION = 'EQ'.
    LS_WD_FILTER-LOW = <LS_OBJ_WD>.
    APPEND LS_WD_FILTER TO P_LT_WD_ABAP_FILTER.
    CONCATENATE LS_WD_FILTER-LOW '/' INTO LS_WD_FILTER-LOW.
    APPEND LS_WD_FILTER TO P_LT_WD_ABAP_FILTER.
  ENDLOOP.

*  CLEAR : lt_wsheader[].

ENDFORM.                    "create_wd_abap_filter_range
*&---------------------------------------------------------------------*
*&      Form  GET_TCODE_RFC_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM GET_TCODE_RFC_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
                                     USING P_START_DATE
                                           P_INSTANCE
                                           P_PERIOD
                                  CHANGING T_TTAB TYPE TT_RECORD
                                           P_IS_DATA.

  DATA: INSTANCE_NAME LIKE SAPWLSERV-NAME,
        PERIOD_TYPE   TYPE SAPWLACCPT,
        PERIOD_DATE   TYPE DATUM.

  DATA: BEGIN OF ENTRY_ID_TYPE,
          TCODE_OR_REPORT TYPE SAPWLPFNRM-REPORT,
          JOBNAME         LIKE SAPWLPFBTC-JOBNAME,
          TYPE,           "T)code or R)eport F)unction?
        END OF ENTRY_ID_TYPE.

  DATA: TCODESTAT    TYPE TABLE OF SAPWLUSTCX,
        RFC_STAT     TYPE TABLE OF SAPWLRFCS,
        RFC_STAT_REC LIKE LINE OF RFC_STAT,
        TCODE_LINE   LIKE LINE OF TCODESTAT.

  DATA: RECORD TYPE TY_RECORD.

  INSTANCE_NAME = P_INSTANCE.
  PERIOD_TYPE   = P_PERIOD.
  PERIOD_DATE   = P_START_DATE.

  REFRESH TCODESTAT.
  REFRESH RFC_STAT.

  CALL FUNCTION 'SAPWL_WORKLOAD_GET_STATISTIC' DESTINATION P_RFCDES
    EXPORTING
      PERIODTYPE            = PERIOD_TYPE
      STARTDATE             = PERIOD_DATE
      INSTANCE              = INSTANCE_NAME
    TABLES
      APPLICATION_STATISTIC = TCODESTAT
      RFC_SERVER_STATISTIC  = RFC_STAT
    EXCEPTIONS
      NO_DATA_FOUND         = 2
      OTHERS                = 4.

  IF SY-SUBRC = 4.
    MESSAGE ID SY-MSGID TYPE 'E' NUMBER SY-MSGNO WITH SY-MSGV1
      SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  SORT TCODESTAT BY ENTRY_ID.

* Get lines for full usage only if wanted
  IF NOT EXTRACT_FULL_USAGE IS INITIAL.
    APPEND LINES OF TCODESTAT TO T_FULL_USAGE.
  ENDIF.

  IF P_IS_DATA IS INITIAL AND NOT TCODESTAT[] IS INITIAL.
    P_IS_DATA = 'X'.
  ENDIF.

  LOOP AT TCODESTAT INTO TCODE_LINE.
    CLEAR: RECORD.
    ENTRY_ID_TYPE = TCODE_LINE-ENTRY_ID.
    RECORD-TCODE = ENTRY_ID_TYPE-TCODE_OR_REPORT.
    RECORD-JOBNAME = ENTRY_ID_TYPE-JOBNAME.
    RECORD-TYPE = ENTRY_ID_TYPE-TYPE.
    RECORD-PERIOD = PERIOD_DATE(6).
    RECORD-USAGE = TCODE_LINE-COUNT.
    RECORD-USER = TCODE_LINE-ACCOUNT.
    COLLECT RECORD INTO T_TTAB.
  ENDLOOP.

  LOOP AT RFC_STAT INTO RFC_STAT_REC.
    CLEAR: RECORD.
    RECORD-TCODE = RFC_STAT_REC-FUNC_NAME.
    RECORD-PERIOD = PERIOD_DATE(6).
    RECORD-TYPE = 'F'.
    RECORD-USAGE = 1.
    RECORD-USER = RFC_STAT_REC-ACCOUNT.
    RECORD-REMOT_DEST = RFC_STAT_REC-REMOT_DEST.
    COLLECT RECORD INTO T_TTAB.
  ENDLOOP.

ENDFORM.                    "GET_TCODE_RFC_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
*&      Form  GET_WEB_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM GET_WEB_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
                              USING  P_START_DATE
                                     P_INSTANCE
                                     P_PERIOD
                                     T_WS_RANGE TYPE RA_WS_FILTER
                                     T_WD_ABAP_RANGE TYPE
                                     RA_WD_ABAP_FILTER
                        CHANGING T_TTAB TYPE TT_RECORD.

  DATA: INSTANCE_NAME LIKE SAPWLSERV-NAME,
        PERIOD_TYPE   TYPE SAPWLACCPT,
        PERIOD_DATE   TYPE DATUM.

  DATA: RECORD TYPE TY_RECORD.

  DATA: LS_FULL_USAGE TYPE SAPWLUSTCX.

  DATA: LT_WEBS      TYPE SWNCGL_T_AGGWEBCLNT,
        LS_WEBS      LIKE LINE OF LT_WEBS,
        STRING_LEN   TYPE I.

  DATA: LT_TEMP_WEBSD TYPE TABLE OF SWNCAGGWEBDEST.
  DATA: LV_CURR_PATH TYPE CHAR250_D.
  DATA: MSG_TEXT(80) TYPE C.
  DATA: LV_SUBRC(4)  TYPE C.

  INSTANCE_NAME = P_INSTANCE.
  PERIOD_TYPE   = P_PERIOD.
  PERIOD_DATE   = P_START_DATE.

  CLEAR: LT_WEBS[], LT_TEMP_WEBSD[], MSG_TEXT.

  CALL FUNCTION 'SWNC_GET_WORKLOAD_STATISTIC' DESTINATION P_RFCDES
    EXPORTING
      SYSTEMID              = RFC_SYSID
      INSTANCE              = INSTANCE_NAME
      PERIODTYPE            = PERIOD_TYPE
      PERIODSTRT            = PERIOD_DATE
    IMPORTING
      WEBS                  = LT_WEBS
      WEBSD                 = LT_TEMP_WEBSD
    EXCEPTIONS
      UNKNOWN_PERIODTYPE    = 1
      NO_DATA_FOUND         = 2
      UNKNOWN_ERROR         = 3
      COMMUNICATION_FAILURE = 98  MESSAGE MSG_TEXT
      SYSTEM_FAILURE        = 99  MESSAGE MSG_TEXT
      OTHERS                = 4.

  IF SY-SUBRC <> 0.
    IF MSG_TEXT IS INITIAL.
      MESSAGE ID SY-MSGID TYPE 'E' NUMBER SY-MSGNO WITH SY-MSGV1
      SY-MSGV2 SY-MSGV3 SY-MSGV4 INTO MSG_TEXT.
    ENDIF.

    LV_SUBRC = SY-SUBRC.

    CONCATENATE 'Error during web usage. Period - '         "#EC NOTEXT
    PERIOD_DATE
      ', Instance - ' INSTANCE_NAME ', SUBRC - ' LV_SUBRC   "#EC NOTEXT
      ', Message - ' MSG_TEXT INTO GT_ETL_MESSAGE-MESSAGE.  "#EC NOTEXT

    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
  ENDIF.

  APPEND LINES OF LT_TEMP_WEBSD TO G_WEB_DATA.

* We correlate names with the filter (either WS / WDA)
* in order to filter out garbage data

  LOOP AT LT_WEBS INTO LS_WEBS.
    CLEAR: RECORD, LV_CURR_PATH.
    LV_CURR_PATH = LS_WEBS-PATH.
    DATA: TEMP_STR TYPE STRING.
    TEMP_STR = LV_CURR_PATH.
    TRANSLATE TEMP_STR TO UPPER CASE.
    LV_CURR_PATH = TEMP_STR.

    IF NOT LV_CURR_PATH IN G_WEB_BLACKLIST
      AND ( LV_CURR_PATH IN T_WS_RANGE OR LV_CURR_PATH IN
      T_WD_ABAP_RANGE ).

      RECORD-PERIOD = PERIOD_DATE(6).
      RECORD-TCODE  = LS_WEBS-PATH.


      IF LV_CURR_PATH IN T_WD_ABAP_RANGE.
        RECORD-TYPE   = 'D'.

        STRING_LEN = STRLEN( RECORD-TCODE ) - 1.

        IF STRING_LEN > 0.

* this part cuts the '/' and unifies it with the entry is without
          IF RECORD-TCODE+STRING_LEN  = '/'. " make name identical
            RECORD-TCODE = RECORD-TCODE(STRING_LEN).
          ENDIF.

        ENDIF.

        TEMP_STR = RECORD-TCODE.
        TRANSLATE TEMP_STR TO UPPER CASE.
        RECORD-TCODE = TEMP_STR.

*       remove the sap prefix.
        REPLACE ALL OCCURRENCES OF '/SAP/BC/WEBDYNPRO/SAP/' IN
        RECORD-TCODE WITH ''.

*       remove alternative prefix
        IF SY-SUBRC <> 0.
          REPLACE ALL OCCURRENCES OF '/SAP/BC/WEBDYNPRO' IN
          RECORD-TCODE WITH ''.
        ENDIF.


      ELSEIF LV_CURR_PATH IN  T_WS_RANGE. " if it is a ws app
        RECORD-TYPE   = 'W'.
      ENDIF.
      RECORD-USAGE  = LS_WEBS-COUNTER.
      RECORD-USER   = LS_WEBS-ACCOUNT.
      COLLECT RECORD INTO T_TTAB.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "GET_WEB_USAGE_FOR_PERIOD

*&---------------------------------------------------------------------*
*&      Form  IS_TCODE_VALID
*&---------------------------------------------------------------------*
FORM IS_TCODE_VALID USING P_TCODE TYPE CHAR255
                    CHANGING P_IS_VALID TYPE FLAG.

  P_IS_VALID = ABAP_TRUE.

    IF ( ( P_TCODE(1) CA '1234567890' AND
     P_TCODE CS '/DATA/' ) OR
     P_TCODE CP '*.PCL' OR
     P_TCODE CP '*.PS' OR
     P_TCODE CP '*.X' OR
     P_TCODE CP '*.GIF' OR
     P_TCODE CP '*.ICO' OR
     P_TCODE CP '*.JPG' OR
     P_TCODE CP '*.JPEG' OR
     P_TCODE CP '*.PNG' OR
     P_TCODE CP '*.BMP' OR
     P_TCODE CP '*.PDF' OR
     P_TCODE CP '*.WAV' OR
     P_TCODE CP '*.JS' OR
     P_TCODE CP '*.CSS' OR
     P_TCODE CP '*.HTM' OR
     P_TCODE CP '*.HTML' OR
     P_TCODE CP '*.DTD' OR
     P_TCODE CP '*.XML' OR
     P_TCODE CP '*.DLG' OR
     P_TCODE CP '*.WAR' OR
     P_TCODE CP '*.JAR' OR
     P_TCODE CP '*.DLL' OR
     P_TCODE CP '*.MF' OR
     P_TCODE CP '*.MSI' OR
     P_TCODE CP 'NW7/*' OR
     P_TCODE EQ 'SAPMSSYC' OR
     P_TCODE CP 'NW5/*' OR
     P_TCODE EQ '/IWFND/CL_MGW_REQUEST_MANAGER=CP' OR
     P_TCODE EQ 'RFC' OR
     P_TCODE EQ 'SYSTEM_RESET_RFC_SERVER' OR
     P_TCODE EQ 'RFCPING' OR
     P_TCODE EQ '<AD_DISPLACE>' OR
     P_TCODE EQ 'MAINMENU' OR
     P_TCODE EQ 'SAPMSYST' OR
     P_TCODE EQ 'SAPLARFC' OR
     P_TCODE EQ 'SAPMHTTP' OR
     P_TCODE EQ 'DDIF_FIELDINFO_GET' OR
     P_TCODE EQ 'RFC_GET_FUNCTION_INTERFACE' OR
     P_TCODE EQ 'DD_LANGU_TO_ISOLA' OR
     P_TCODE EQ 'DD_GET_UCLEN' OR
     P_TCODE EQ 'RFC_GET_SAP_SYSTEM_PARAMETERS' OR
     P_TCODE EQ 'SAPLLRFC' OR
     P_TCODE EQ 'SAPLERFC' OR
     P_TCODE EQ 'BATCH/JSON' OR
     P_TCODE EQ '<HANDLE RFC>' OR
     P_TCODE EQ 'ABORTED' OR
     P_TCODE EQ 'SAPJCO731' OR
     P_TCODE CP '~flNUQVRFPT*' ).

      CLEAR P_IS_VALID.

    ENDIF.

ENDFORM.                    "IS_TCODE_VALID
*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TCODE    text
*      -->P_TYPE     text
*      -->P_NODE_REF text
*----------------------------------------------------------------------*
FORM EXTRACT_WEB_DATA USING P_TCODE TYPE CHAR255
                            P_TYPE TYPE CHAR1
                            P_NODE_REF TYPE XML_ELEMENT.

  DATA: WEBDYN_NODE  TYPE XML_ELEMENT,
        WEB_ENTRY_ID TYPE SWNCENTRYID,
        WEB_DATA_WA  TYPE SWNCAGGWEBDEST.

  IF NOT G_WEB_DATA[] IS INITIAL.
*Check if there is an entry for this transaction in the web data
*         if so, mark it as web
*          CONCATENATE RECORD-TCODE RECORD-TYPE INTO WEB_ENTRY_ID.
    WEB_ENTRY_ID = P_TCODE.
    WEB_ENTRY_ID+72(1) = P_TYPE.
    READ TABLE G_WEB_DATA WITH KEY ENTRY_ID = WEB_ENTRY_ID INTO
    WEB_DATA_WA.
    IF SY-SUBRC IS INITIAL.
      PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  P_NODE_REF
                                  'WEBDYN'
                            CHANGING WEBDYN_NODE.
    ENDIF.
  ENDIF.
ENDFORM.                    "EXTRACT_WEB_DATA
*&---------------------------------------------------------------------*
*&      Form  GET_ROW_COUNT
*&---------------------------------------------------------------------*
* Get the number of enteries of a table
*----------------------------------------------------------------------*
FORM GET_ROW_COUNT
  USING
    P_TABNAME   TYPE TABNAME
  CHANGING
    C_ROW_COUNT TYPE SYTFILL.

  DATA:
    LT_ROW_COUNT  TYPE TABLE OF DDCDIM,
    LS_ROW_COUNT  TYPE DDCDIM.

  CLEAR C_ROW_COUNT.

* Get the number of enteries for this table
  CALL FUNCTION 'SRTT_GET_TABLE_SIZE_RFC'
    DESTINATION P_RFCDES
    EXPORTING
      TABLE_NAME         = P_TABNAME
    IMPORTING
      TABLE_SIZE         = C_ROW_COUNT
    EXCEPTIONS
      CLIENT_NOT_FOUND   = 1
      TABLE_NOT_FOUND    = 2
      TABLE_INKONSISTENT = 3
      PROTECTED          = 4
      WRONG_TYPE         = 5
      OTHERS             = 6.

* if got exception - add message to log and try to use fallback
* function EM_GET_NUMBER_OF_ENTRIES to get the number of entries
  IF NOT SY-SUBRC IS INITIAL.
    CLEAR ERROR.
    CASE SY-SUBRC.
      WHEN 1. ERROR = 'CLIENT_NOT_FOUND'.
      WHEN 2. ERROR = 'TABLE_NOT_FOUND'.
      WHEN 3. ERROR = 'TABLE_INKONSISTENT'.
      WHEN 4. ERROR = 'PROTECTED'.
      WHEN 5. ERROR = 'WRONG_TYPE'.
      WHEN 6. ERROR = 'OTHERS'.
    ENDCASE.

    CONCATENATE 'get num of entries in table:' P_TABNAME    "#EC NOTEXT
      'Error:' ERROR                                        "#EC NOTEXT
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   call fallback function
    LS_ROW_COUNT-TABNAME = P_TABNAME.
    APPEND LS_ROW_COUNT TO LT_ROW_COUNT.

    CALL FUNCTION 'EM_GET_NUMBER_OF_ENTRIES' DESTINATION P_RFCDES
      TABLES
        IT_TABLES             = LT_ROW_COUNT
      EXCEPTIONS
        SYSTEM_FAILURE        = 1
        COMMUNICATION_FAILURE = 2
        OTHERS                = 4.

    IF NOT LT_ROW_COUNT[] IS INITIAL.
      READ TABLE LT_ROW_COUNT INTO LS_ROW_COUNT INDEX 1.
      C_ROW_COUNT = LS_ROW_COUNT-TABROWS.
    ENDIF.
  ENDIF.
ENDFORM.                    "GET_ROW_COUNT

*&---------------------------------------------------------------------*
*&      Form  add_layouts_usage
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TWO_YEARS_BACK  text
*----------------------------------------------------------------------*
FORM ADD_LAYOUTS_USAGE
USING IV_TWO_YEARS_BACK TYPE DATUM
      IV_USAGE_NODE     TYPE XML_ELEMENT.

  TYPES : BEGIN OF TY_NAST ,
            KAPPL TYPE KAPPL,
            KSCHL TYPE KSCHL,
            NACHA TYPE NA_NACHA,
            COUNT TYPE I,
          END OF TY_NAST.
  TYPES : BEGIN OF TY_PAYR ,
            ZBUKR TYPE DZBUKR,
            RZAWE TYPE DZLSCH,
            COUNT TYPE I,
          END OF TY_PAYR.
  TYPES : BEGIN OF TY_REGUH,
            ZBUKR TYPE DZBUKR,
            RZAWE TYPE RZAWE,
            COUNT TYPE I,
          END OF TY_REGUH.

  DATA : LT_T042E TYPE STANDARD TABLE OF T042E,
         LS_T042E LIKE LINE OF LT_T042E,
         LT_PAYR  TYPE STANDARD TABLE OF TY_PAYR,
         LS_PAYR  LIKE LINE OF LT_PAYR,
         LV_PAYR_NODE TYPE XML_ELEMENT.
  DATA : LT_REGUH TYPE STANDARD TABLE OF TY_REGUH,
         LS_REGUH LIKE LINE OF LT_REGUH,
         LV_REGUH_NODE TYPE XML_ELEMENT.
  DATA : LT_TNAPR TYPE STANDARD TABLE OF TNAPR,
         LS_TNAPR LIKE LINE OF LT_TNAPR,
         LV_WHERE1 TYPE SYCHAR72,
         LV_WHERE2 TYPE SYCHAR72,
         LV_WHERE3 TYPE SYCHAR72,
         LV_WHERE4 TYPE SYCHAR72,
         LV_VALUE  TYPE STRING,
         LV_COUNT  TYPE SYDBCNT,
         LT_NAST   TYPE STANDARD TABLE OF TY_NAST,
         LS_NAST   LIKE LINE OF LT_NAST,
         LV_NAST_NODE TYPE XML_ELEMENT,
         LV_SIZE   TYPE I,
         LV_TEXT   TYPE STRING.

* Layouts usage - nast table
  SELECT *
  FROM TNAPR
  INTO CORRESPONDING FIELDS OF TABLE LT_TNAPR.
*  IF NOT SY-BATCH IS INITIAL.
  DESCRIBE TABLE LT_TNAPR LINES LV_SIZE.
  LV_TEXT = LV_SIZE.
  CONCATENATE 'Layouts usage Number of layouts in TNAPR:'   "#EC NOTEXT
              LV_TEXT
  INTO LV_TEXT SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
*  ENDIF.

* Itterate per nast keys get usage two years back
  LOOP AT LT_TNAPR INTO LS_TNAPR.
    CLEAR : LV_WHERE1,
            LV_WHERE2,
            LV_WHERE3,
            LV_WHERE4,
            LV_VALUE.
*    IF NOT SY-BATCH IS INITIAL.
    CONCATENATE 'Layouts usage Extracting TNAPR usage for:' "#EC NOTEXT
                LS_TNAPR-KAPPL
                LS_TNAPR-KSCHL
                LS_TNAPR-NACHA
    INTO LV_TEXT SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
*    ENDIF.

*   Two years back
    CONCATENATE 'ERDAT >'
                IV_TWO_YEARS_BACK
                'AND'
    INTO LV_WHERE1 SEPARATED BY SPACE.

*   Get usage per tnapr key from nast
*   record key = kappl , kschl , nacha
    CONCATENATE '''' LS_TNAPR-KAPPL  '''' INTO LV_VALUE.
    CONCATENATE 'KAPPL ='
                LV_VALUE
                'AND'
    INTO LV_WHERE2 SEPARATED BY SPACE.

    CLEAR : LV_VALUE.
    CONCATENATE '''' LS_TNAPR-KSCHL  '''' INTO LV_VALUE.
    CONCATENATE 'KSCHL ='
                LV_VALUE
                'AND'
    INTO LV_WHERE3 SEPARATED BY SPACE.

    CLEAR : LV_VALUE.
    CONCATENATE '''' LS_TNAPR-NACHA  '''' INTO LV_VALUE.
    CONCATENATE 'NACHA ='
                LV_VALUE
    INTO LV_WHERE4 SEPARATED BY SPACE.

*   Get usage from prod two years back per record
    CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
    DESTINATION P_RFCDES
      EXPORTING
        TABLE         = 'NAST'
        WHERE1        = LV_WHERE1
        WHERE2        = LV_WHERE2
        WHERE3        = LV_WHERE3
        WHERE4        = LV_WHERE4
*       WHERE5        =
     IMPORTING
        ANZAHL        = LV_COUNT.

    IF LV_COUNT > 0.
      MOVE-CORRESPONDING LS_TNAPR TO LS_NAST.
      LS_NAST-COUNT = LV_COUNT.
      APPEND LS_NAST TO LT_NAST.
    ENDIF.
  ENDLOOP.

* Add nast to xml
  IF NOT LT_NAST[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  IV_USAGE_NODE
                                  'NAST_USAGE'
                          CHANGING LV_NAST_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_NAST
                                   USING G_IREF_PDOCUMENT
                                         LV_NAST_NODE
                                         'NAST'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_NAST_NODE 'X'.
  ENDIF.

* Get t042e - zbukr and zlsch = payr,reguh  - zbukr and rzawe
  SELECT *
  FROM T042E
  INTO CORRESPONDING FIELDS OF TABLE LT_T042E.

*  IF NOT SY-BATCH IS INITIAL.
  DESCRIBE TABLE LT_T042E LINES LV_SIZE.
  LV_TEXT = LV_SIZE.
  CONCATENATE 'Layouts usage Number of layouts in T042E:'   "#EC NOTEXT
              LV_TEXT
  INTO LV_TEXT SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
*  ENDIF.

* Itterate over each layout key get it's usage
  LOOP AT LT_T042E INTO LS_T042E.

    CLEAR : LV_WHERE1,
            LV_WHERE2,
            LV_WHERE3,
            LV_VALUE.

*    IF NOT SY-BATCH IS INITIAL.
    CONCATENATE 'Layouts usage Extracting T042E usage for:' "#EC NOTEXT
                LS_T042E-ZBUKR
                LS_T042E-ZLSCH
    INTO LV_TEXT SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
*    ENDIF.

*   Two years back
    CONCATENATE 'PRIDT >'
                IV_TWO_YEARS_BACK
                'AND'
    INTO LV_WHERE1 SEPARATED BY SPACE.

*   Key - zbukr = zbukr , rzawe = zlsch
    CONCATENATE '''' LS_T042E-ZBUKR '''' INTO LV_VALUE.
    CONCATENATE 'ZBUKR ='
                LV_VALUE
                'AND'
    INTO LV_WHERE2 SEPARATED BY SPACE.

    CLEAR : LV_VALUE.
    CONCATENATE '''' LS_T042E-ZLSCH '''' INTO LV_VALUE.
    CONCATENATE 'RZAWE ='
                LV_VALUE
    INTO LV_WHERE3 SEPARATED BY SPACE.

*   Get data from prod two years back per current key
    CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
    DESTINATION P_RFCDES
      EXPORTING
        TABLE         = 'PAYR'
        WHERE1        = LV_WHERE1
        WHERE2        = LV_WHERE2
        WHERE3        = LV_WHERE3
*       where4        =
*       WHERE5        =
     IMPORTING
        ANZAHL        = LV_COUNT.

    IF LV_COUNT > 0.
      LS_PAYR-ZBUKR = LS_T042E-ZBUKR.
      LS_PAYR-RZAWE = LS_T042E-ZLSCH.
      LS_PAYR-COUNT = LV_COUNT.
      APPEND LS_PAYR TO LT_PAYR.
    ENDIF.

*   For reguh the date filed is laufd
*   Two years back
    CLEAR : LV_WHERE1.
    CONCATENATE 'LAUFD >'
                IV_TWO_YEARS_BACK
                'AND'
    INTO LV_WHERE1 SEPARATED BY SPACE.

*   The key fields are the same for reguh
*   as for payr - zbukr and rzawe , use the previous wheres
    CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
    DESTINATION P_RFCDES
      EXPORTING
        TABLE         = 'REGUH'
        WHERE1        = LV_WHERE1
        WHERE2        = LV_WHERE2
        WHERE3        = LV_WHERE3
*       where4        =
*       WHERE5        =
     IMPORTING
        ANZAHL        = LV_COUNT.

    IF LV_COUNT > 0.
      LS_REGUH-ZBUKR = LS_T042E-ZBUKR.
      LS_REGUH-RZAWE = LS_T042E-ZLSCH.
      LS_REGUH-COUNT = LV_COUNT.
      APPEND LS_REGUH TO LT_REGUH.
    ENDIF.
  ENDLOOP.

* Add payr and reguh usage data to xml
  IF NOT LT_PAYR[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  IV_USAGE_NODE
                                  'PAYR_USAGE'
                          CHANGING LV_PAYR_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_PAYR
                                   USING G_IREF_PDOCUMENT
                                         LV_PAYR_NODE
                                         'PAYR'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_PAYR_NODE 'X'.
  ENDIF.

  IF NOT LT_REGUH[] IS INITIAL.
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
                                  IV_USAGE_NODE
                                  'REGUH_USAGE'
                          CHANGING LV_REGUH_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_REGUH
                                   USING G_IREF_PDOCUMENT
                                         LV_REGUH_NODE
                                         'REGUH'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_REGUH_NODE 'X'.
  ENDIF.

ENDFORM.                    " add_layouts_usage

*---------------------------------------------------------------------*
*       FORM EXTRACT_UPL_DATA                                         *
*---------------------------------------------------------------------*
FORM EXTRACT_UPL_DATA.
  DATA: L_T_DATA     TYPE STANDARD TABLE OF UPL_DATA
                          WITH DEFAULT KEY INITIAL SIZE 10,
        UPL_NODE     TYPE XML_ELEMENT,
        UPL_SYS_NODE TYPE XML_ELEMENT.

  DATA:
    L_STARTDATE LIKE SY-DATUM,
    L_STARTTIME LIKE SY-UZEIT.

* Check if upl data is needed and there is a solman connection.
  CHECK NOT G_EXTRACT_UPL IS INITIAL AND NOT P_SM_RFC IS INITIAL.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting UPL Data'. "#EC NOTEXT

* Get the upl data
  PERFORM GET_UPL_DATA TABLES L_T_DATA.
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'UPL_USAGE'
                          CHANGING UPL_NODE.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT UPL_NODE
                                'UPL_SYSTEM'
                          CHANGING UPL_SYS_NODE.
  PERFORM ADD_ATTRIBUTE_TO_NODE USING UPL_SYS_NODE
                                      'SYSTEM_NAME'
                                      RFC_SYSID.

  PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES L_T_DATA
                           USING G_IREF_PDOCUMENT UPL_NODE
                                 'UPL'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING UPL_NODE 'X'.

  PERFORM ADD_TIME_STAT USING 'Extract UPL' "#EC NOTEXT
      L_STARTTIME L_STARTDATE.

ENDFORM.                    " extract_upl_data
*---------------------------------------------------------------------*
*       FORM GET_UPL_DATA                                             *
*---------------------------------------------------------------------*
FORM GET_UPL_DATA TABLES P_T_DATA TYPE UPL_DATA_TAB.
  TYPE-POOLS: RS, RSDRC.
  DATA:
    I_T_SFK     TYPE RSDRI_T_SFK,
    I_L_SFK     TYPE LINE OF RSDRI_T_SFK,
    RANGE_WA    TYPE SM_RSDRI_S_RANGE_RFC,
    E_T_RFCDATA TYPE RSDRI_T_RFCDATA,
    E_T_FIELD   TYPE RSDP0_T_FIELD,
    L_S_DATA    TYPE UPL_DATA,
    FINAL_UPL_T TYPE TABLE OF UPL_DATA,
    FINAL_WA    TYPE UPL_DATA,
    RFC_DATA_WA TYPE RSDRI_S_RFCDATA,
    MONTH(6)    TYPE N,
    L_T_SFC     TYPE TABLE OF RSDRI_S_SFC,
    L_T_RANGE   TYPE TABLE OF SM_RSDRI_S_RANGE_RFC,
    SUBRC(4)    TYPE N,
    METH_KEY    TYPE SEOCPDKEY,
    PSMODISRC   TYPE TABLE OF SMODISRC,
    PSMODILOG   TYPE TABLE OF SMODILOG,
    PSOURCE     TYPE TABLE OF ABAPTXT255,
    PTRDIR      TYPE TABLE OF TRDIR,
    PTRDIR_WA   TYPE TRDIR,
    UPL_LINES   TYPE I,
    S_UPL_LINES TYPE STRING.

* The sfc sets what fields will be returning full from the BW data cube
  PERFORM FILL_SFC TABLES L_T_SFC.

*
  I_L_SFK-KYFNM = '0SM_CCLPE'.
  I_L_SFK-KYFALIAS = 'SM_CCLPE'.
  I_L_SFK-AGGR = 'SUM'.

  PERFORM FILL_OBJECT_RANGE TABLES L_T_RANGE
                            CHANGING MONTH.


  DO UPL_MONTH_NUMBER TIMES.
*   Set the wanted month
    CLEAR E_T_RFCDATA[].
    READ TABLE L_T_RANGE WITH KEY CHANM = '0CALMONTH' INTO RANGE_WA.
    RANGE_WA-LOW = MONTH.
    MODIFY L_T_RANGE INDEX SY-TABIX FROM RANGE_WA TRANSPORTING LOW.

    CONCATENATE 'UPL: Getting UPL data for month ' MONTH "#EC NOTEXT
    INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   Read the UPL data
    CALL FUNCTION 'RSDRI_INFOPROV_READ_RFC' DESTINATION P_SM_RFC
      EXPORTING
        I_INFOPROV             = '0SM_UPL'
        I_REFERENCE_DATE       = SY-DATUM
        I_SAVE_IN_TABLE        = ' '
        I_SAVE_IN_FILE         = ' '
        I_AUTHORITY_CHECK      = RSDRC_C_AUTHCHK-READ
      TABLES
        I_T_SFC                = L_T_SFC
        I_T_SFK                = I_T_SFK
        I_T_RANGE              = L_T_RANGE
        E_T_RFCDATA            = E_T_RFCDATA
        E_T_FIELD              = E_T_FIELD
      EXCEPTIONS
        ILLEGAL_INPUT          = 1
        ILLEGAL_INPUT_SFC      = 2
        ILLEGAL_INPUT_SFK      = 3
        ILLEGAL_INPUT_RANGE    = 4
        ILLEGAL_INPUT_TABLESEL = 5
        NO_AUTHORIZATION       = 6
        GENERATION_ERROR       = 7
        ILLEGAL_DOWNLOAD       = 8
        ILLEGAL_TABLENAME      = 9
        ILLEGAL_RESULTTYPE     = 10
        X_MESSAGE              = 11
        DATA_OVERFLOW          = 12
        OTHERS                 = 13.

    IF SY-SUBRC IS INITIAL.
*     Add the the lines of the current week upl to the aggregated list
*      APPEND LINES OF E_T_RFCDATA TO AGR_RFC_DATA.

      CLEAR FINAL_WA.
      CLEAR FINAL_UPL_T.
*     Get the data into the upl structure type
      PERFORM CONVERT_TO_STRUCT TABLES E_T_RFCDATA
                                       E_T_FIELD
                                       FINAL_UPL_T
                                USING  RFC_DATA_WA
                                       FINAL_WA.
      CLEAR E_T_RFCDATA[].
      CLEAR E_T_FIELD[].
*     Go over the data received in this itaration and sum the usage
      LOOP AT FINAL_UPL_T INTO FINAL_WA.
*       Check if the process unit is already in the table
        READ TABLE P_T_DATA WITH KEY SM_CCLPN = FINAL_WA-SM_CCLPN
                                     SM_CCLOT = FINAL_WA-SM_CCLOT
                                     SM_CCLON = FINAL_WA-SM_CCLON
                                     SM_CCLNS = FINAL_WA-SM_CCLNS
                                     SM_CCLTP = FINAL_WA-SM_CCLTP
                                     SM_CCLNP = FINAL_WA-SM_CCLNP
                                     SM_CCLPE = FINAL_WA-SM_CCLPE
                            INTO L_S_DATA.

        IF SY-SUBRC IS INITIAL.
*         Add another usage
          L_S_DATA-MONTH_USED = L_S_DATA-MONTH_USED + 1.
          MODIFY P_T_DATA FROM L_S_DATA INDEX SY-TABIX.
        ELSE.
*         Add the process unit to the table
          L_S_DATA-SM_CCLPN = FINAL_WA-SM_CCLPN.
          L_S_DATA-SM_CCLOT = FINAL_WA-SM_CCLOT.
          L_S_DATA-SM_CCLON = FINAL_WA-SM_CCLON.
          L_S_DATA-SM_CCLNS = FINAL_WA-SM_CCLNS.
          L_S_DATA-SM_CCLTP = FINAL_WA-SM_CCLTP.
          L_S_DATA-SM_CCLNP = FINAL_WA-SM_CCLNP.
          L_S_DATA-CALMONTH = MONTH.
          L_S_DATA-MONTH_USED = 1.
          APPEND L_S_DATA TO P_T_DATA.
        ENDIF.
      ENDLOOP.

      CLEAR FINAL_WA.
      CLEAR FINAL_UPL_T.

    ELSE.
      SUBRC = SY-SUBRC.
      CONCATENATE 'UPL: Error getting UPL month ' "#EC NOTEXT
      MONTH ' system ' "#EC NOTEXT
      RFC_SYSID '. SUBRC ' SUBRC
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
*   Set the week to be the previous month
    MONTH = MONTH - 1.
    IF MONTH+4(2) = '00'.
      MONTH = MONTH - 1.
      MONTH+4(2) = 12.
    ENDIF.
  ENDDO.

  DESCRIBE TABLE P_T_DATA LINES UPL_LINES.
  S_UPL_LINES = UPL_LINES.
  CONCATENATE 'UPL: UPL Lines number extracted ' "#EC NOTEXT
  S_UPL_LINES INTO
  GT_ETL_MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

GT_ETL_MESSAGE = 'UPL: Start getting the methods includes'. "#EC NOTEXT
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Go over the methods and get their include name
  LOOP AT P_T_DATA INTO L_S_DATA WHERE SM_CCLTP = 'METH'.

    METH_KEY-CLSNAME = FINAL_WA-SM_CCLON.
    METH_KEY-CPDNAME = FINAL_WA-SM_CCLNP.
    CLEAR PTRDIR.

    CALL FUNCTION 'METH_GET_OBJECT'
      EXPORTING
        METHODKEY         = METH_KEY
*       R3STATE           = 'A'
      TABLES
        PSMODISRC         = PSMODISRC
        PSMODILOG         = PSMODILOG
        PSOURCE           = PSOURCE
        PTRDIR            = PTRDIR
      EXCEPTIONS
        VERSION_NOT_FOUND = 1
        METH_NOT_EXIST    = 2
        OTHERS            = 3.

    CLEAR PSOURCE[].
    CLEAR PSMODISRC[].
    CLEAR PSMODILOG[].

    READ TABLE PTRDIR INDEX 1 INTO PTRDIR_WA.
    IF SY-SUBRC IS INITIAL.
      L_S_DATA-METHOD_INC = PTRDIR_WA-NAME.
    ENDIF.
  ENDLOOP.

ENDFORM.                              "GET_UPL_DATA
*---------------------------------------------------------------------*
*       FORM FILL_SFC                                                 *
*---------------------------------------------------------------------*
FORM FILL_SFC TABLES G_TH_SFC STRUCTURE RSDRI_S_SFC.

  DATA:
    G_S_SFC      TYPE RSDRI_S_SFC.

* Program name
  CLEAR G_S_SFC.
*   --- name of characteristic
  G_S_SFC-CHANM    = '0SM_CCLPN'.
*   --- name of corresponding column in G_T_DATA
  G_S_SFC-CHAALIAS = 'SM_CCLPN'.
*   --- no ORDER-BY
  G_S_SFC-ORDERBY  = 0.
*   --- include into list of characteristics
  INSERT G_S_SFC INTO TABLE G_TH_SFC.


* Object Name
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SM_CCLON'.
  G_S_SFC-CHAALIAS = 'SM_CCLON'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Month in year
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0CALMONTH'.
  G_S_SFC-CHAALIAS = 'CALMONTH'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* System ID
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SMD_LSID'.
  G_S_SFC-CHAALIAS = 'SMD_LSID'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Object Type
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SM_CCLOT'.
  G_S_SFC-CHAALIAS = 'SM_CCLOT'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Namespace
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SM_CCLNS'.
  G_S_SFC-CHAALIAS = 'SM_CCLNS'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Processing Type
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SM_CCLTP'.
  G_S_SFC-CHAALIAS = 'SM_CCLTP'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Processing block
  CLEAR G_S_SFC.
  G_S_SFC-CHANM    = '0SM_CCLNP'.
  G_S_SFC-CHAALIAS = 'SM_CCLNP'.
  G_S_SFC-ORDERBY  = 0.
  INSERT G_S_SFC INTO TABLE G_TH_SFC.
ENDFORM.                    "fill_sfc
*---------------------------------------------------------------------*
*       FORM FILL_OBJECT_RANGE                                        *
*---------------------------------------------------------------------*
FORM FILL_OBJECT_RANGE TABLES P_T_RANGE
                                        CHANGING MONTH.
  IF GET_ONLY_CUST_UPL = 'X'.
*   Set the customer objects that the upl data is needed for
    LOOP AT CUSTOMER_OBJECTS.
      PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                             USING '0SM_CCLPN'
                                   CUSTOMER_OBJECTS-LOW
                                   CUSTOMER_OBJECTS-OPTION
                                   CUSTOMER_OBJECTS-SIGN.
    ENDLOOP.

    LOOP AT CUST_NAMESPACE_RNG.
      PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                               USING '0SM_CCLPN'
                                     CUST_NAMESPACE_RNG-LOW
                                     CUST_NAMESPACE_RNG-OPTION
                                     CUST_NAMESPACE_RNG-SIGN.
    ENDLOOP.
    PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                               USING '0SM_CCLPN'
                                     'AQ*'
                                     RS_C_RANGE_OPT-PATTERN
                                     RS_C_RANGE_SIGN-INCLUDING.

    PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                               USING '0SM_CCLPN'
                                     '%_C*'
                                     RS_C_RANGE_OPT-PATTERN
                                     RS_C_RANGE_SIGN-INCLUDING.
  ENDIF.
* Set the system that the upl data is needed for
  PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                         USING '0SMD_LSID'
                               RFC_SYSID
                               RS_C_RANGE_OPT-EQUAL
                               RS_C_RANGE_SIGN-INCLUDING.

* Set the month range
  MONTH = SY-DATUM(6).
  PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
                         USING '0CALMONTH'
                               MONTH
                               RS_C_RANGE_OPT-EQUAL
                               RS_C_RANGE_SIGN-INCLUDING.


ENDFORM.                    "FILL_OBJECT_RANGE
*---------------------------------------------------------------------*
*       FORM CONVERT_TO_STRUCT                                        *
*---------------------------------------------------------------------*
FORM  CONVERT_TO_STRUCT TABLES TAB_DATA TYPE RSDRI_T_RFCDATA
                         FIELDS STRUCTURE RSDP0_S_FIELD
                         FINAL_TABLE
                  USING  TAB_WA TYPE RSDRI_S_RFCDATA
                         FINAL_WA TYPE UPL_DATA.

  DATA:
    STRING_WA(1050) TYPE C,
    D_LENGTH        TYPE I VALUE 8,
    T_LENGTH        TYPE I VALUE 6,
    OFFSET          TYPE I VALUE 0,
    FIELD_WA        TYPE RSDP0_S_FIELD,
    SM_CCLPN_POS    TYPE I,
    SM_CCLPN_LEN    TYPE I,
    SM_CCLOT_POS    TYPE I,
    SM_CCLOT_LEN    TYPE I,
    SM_CCLON_POS    TYPE I,
    SM_CCLON_LEN    TYPE I,
    SM_CCLNS_POS    TYPE I,
    SM_CCLNS_LEN    TYPE I,
    SM_CCLTP_POS    TYPE I,
    SM_CCLTP_LEN    TYPE I,
    SM_CCLNP_POS    TYPE I,
    SM_CCLNP_LEN    TYPE I,
    CALMONTH_POS    TYPE I,
    CALMONTH_LEN    TYPE I,
    SM_CCLPE_POS    TYPE I,
    SM_CCLPE_LEN    TYPE I,
    CUR_ROW         TYPE I.

  IF NOT TAB_DATA[] IS INITIAL.
*   Get the offset and length of all of the fields that are needed
    LOOP AT FIELDS INTO FIELD_WA.
      IF FIELD_WA-FIELDTYPE = 'D'.
        FIELD_WA-FIELDLENGTH = D_LENGTH.
      ELSEIF FIELD_WA-FIELDTYPE = 'T'.
        FIELD_WA-FIELDLENGTH = T_LENGTH.
      ENDIF.

      IF FIELD_WA-FIELDNAME = '0SM_CCLPN'.
        SM_CCLPN_POS = OFFSET + 1.
        SM_CCLPN_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLOT'.
        SM_CCLOT_POS = OFFSET + 1.
        SM_CCLOT_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLON'.
        SM_CCLON_POS = OFFSET + 1.
        SM_CCLON_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLNS'.
        SM_CCLNS_POS = OFFSET + 1 .
        SM_CCLNS_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLTP'.
        SM_CCLTP_POS = OFFSET + 1.
        SM_CCLTP_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLNP'.
        SM_CCLNP_POS = OFFSET + 1.
        SM_CCLNP_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0CALMONTH'.
        CALMONTH_POS = OFFSET + 1.
        CALMONTH_LEN = FIELD_WA-FIELDLENGTH.
      ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLPE'.
        SM_CCLPE_POS = OFFSET + 1.
        SM_CCLPE_LEN = FIELD_WA-FIELDLENGTH.
      ENDIF.
      OFFSET = OFFSET + FIELD_WA-FIELDLENGTH.
    ENDLOOP.

    CUR_ROW = 1.
    LOOP AT TAB_DATA INTO TAB_WA.

      OFFSET = ( CUR_ROW - 1 ) * 255.
      STRING_WA+OFFSET = TAB_WA.
      IF TAB_WA-CONT IS INITIAL.
        FINAL_WA-SM_CCLPN = STRING_WA+SM_CCLPN_POS(SM_CCLPN_LEN).
        FINAL_WA-SM_CCLOT = STRING_WA+SM_CCLOT_POS(SM_CCLOT_LEN).
        FINAL_WA-SM_CCLON = STRING_WA+SM_CCLON_POS(SM_CCLON_LEN).
        FINAL_WA-SM_CCLNS = STRING_WA+SM_CCLNS_POS(SM_CCLNS_LEN).
        FINAL_WA-SM_CCLTP = STRING_WA+SM_CCLTP_POS(SM_CCLTP_LEN).
        FINAL_WA-SM_CCLNP = STRING_WA+SM_CCLNP_POS(SM_CCLNP_LEN).
        FINAL_WA-CALMONTH = STRING_WA+CALMONTH_POS(CALMONTH_LEN).
        FINAL_WA-SM_CCLPE = STRING_WA+SM_CCLPE_POS(SM_CCLPE_LEN).
        APPEND FINAL_WA TO FINAL_TABLE.
        CUR_ROW = 1.
        CLEAR STRING_WA.
      ELSE.
        CUR_ROW = CUR_ROW + 1.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    "CONVERT_TO_STRUCT

*---------------------------------------------------------------------*
*       FORM FILL_UPL_RANGE                                           *
*---------------------------------------------------------------------*
FORM FILL_UPL_RANGE TABLES G_T_RANGE
                    USING  FIELD_NAME
                           VALUE
                           OPTION
                           SIGN.
  DATA:
    G_S_RANGE TYPE SM_RSDRI_S_RANGE_RFC.

  CLEAR G_S_RANGE.
  G_S_RANGE-CHANM    = FIELD_NAME.
  G_S_RANGE-SIGN     = SIGN.
  G_S_RANGE-COMPOP   = OPTION.
  G_S_RANGE-LOW      = VALUE.
  APPEND G_S_RANGE TO G_T_RANGE.

ENDFORM.                    "fill_upl_range

*---------------------------------------------------------------------*
*       FORM add_servers_list                                         *
*---------------------------------------------------------------------*
FORM ADD_SERVERS_LIST.

  DATA: ETL_SERVERS_LIST_NODE TYPE XML_ELEMENT.

  IF NOT SERVERS IS INITIAL.

    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'SERVERS_LIST'
                            CHANGING ETL_SERVERS_LIST_NODE.

    PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES SERVERS
                                   USING G_IREF_PDOCUMENT
                                         ETL_SERVERS_LIST_NODE
                                         'SERVER'.

    PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_SERVERS_LIST_NODE 'X'.
    FREE SERVERS.

  ENDIF.

ENDFORM.                    "add_servers_list

*&---------------------------------------------------------------------*
*&      Form  get_solar_raw_data
*&---------------------------------------------------------------------*
*       Get the data for the business process projects
*----------------------------------------------------------------------*
FORM GET_SOLAR_RAW_DATA.

  DATA:
      SEL           TYPE TABLE OF RFC_DB_OPT,
      SEL_WA        TYPE RFC_DB_OPT,
      FIELDS        TYPE TABLE OF RFC_DB_FLD,
      TPROJECT_TAB  TYPE TABLE OF SM_PROJECT_TYPE,
      TPROJECT_WA   TYPE SM_PROJECT_TYPE,
      TOBJECTP_TAB  TYPE TABLE OF TOBJECTP,
      TOBJECT_WA    TYPE TOBJECTP,
      TOBJECT       TYPE TOBJECTP,
      TBOM_HEADER_TAB TYPE SM_AGS_TBOM_HEAD_TAB,
      TBOM_HEADER_WA  TYPE SM_AGS_TBOM_HEAD,
      TMP_BASE_TAB  TYPE TABLE OF SM_AGS_TBOM_BASE,
      TBOM_BASE_TAB TYPE TABLE OF SM_AGS_TBOM_BASE,
      TBOM_BASE_WA  TYPE SM_AGS_TBOM_BASE,
      LS_FIELDS     LIKE LINE OF FIELDS,
      STR_UZEIT     TYPE STRING,
      IS_FIRST      TYPE C VALUE 'X',
      MODIFY_TABIX  LIKE SY-TABIX.

  DATA:
      MESSAGE        TYPE  HIER_MESS,
      HANDLES_TAB    TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
      SOLAR_PROJECTS_NODE  TYPE XML_ELEMENT,
      SOLAR_PROJECTS_TYPE TYPE XML_ELEMENT,
      SOLAR_PROJ_NODE_TEXT  TYPE XML_ELEMENT,
      BMTNODES       TYPE XML_ELEMENT,
      SOLAR_TRANSACTIONS_NODE TYPE XML_ELEMENT,
      SOLAR_URLS_NODE     TYPE XML_ELEMENT.

  DATA:
      ALL_NODES TYPE TABLE OF SM_PROJECT_TREE_NODE,
      ALL_NODES_WA LIKE LINE OF ALL_NODES,
      NODES     TYPE TABLE OF HIER_IFACE,
      NODE_WA   LIKE LINE OF NODES,
      ALL_TEXTS TYPE TABLE OF HIER_TEXTS,
      TEXTS     TYPE TABLE OF HIER_TEXTS.

  DATA:
      BMT_TREE_REF TYPE TABLE OF BMTNODE01R,
      TMP_BMT_REFS TYPE TABLE OF BMTNODE01R,
      RES_BMTNODE_R TYPE TABLE OF BMTNODE01R,
      RES_DFURLS TYPE TABLE OF SM_DFURLS,
      DFURLS     TYPE TABLE OF SM_DFURLS,
      BMT_TREE   TYPE TABLE OF SM_PROJECT_TREE,
      COUNTER    TYPE I VALUE 0,
      L_STARTTIME LIKE SY-UZEIT,
      L_STARTDATE LIKE SY-DATUM.

  CHECK EXTRACT_SOLAR_DATA = 'X' AND NOT P_SM_RFC IS INITIAL.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
          'Extracting Solution Manager Projects'. "#EC NOTEXT

*------------------------------------------------------------------
  PERFORM APPEND_STRING_TO_FILE USING '<SOLAR_DATA>'.

* Create a child node for the Project node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'SOLAR_PROJECTS'
                          CHANGING SOLAR_PROJECTS_TYPE.

  CONCATENATE 'SOLAR:1.Getting SOLAR Projects' "#EC NOTEXT
      'from tables TPROJECT and TOBJECTP' "#EC NOTEXT
  INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  LS_FIELDS-FIELDNAME = 'PROJECT_ID'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'CLASS'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'BEGIN_DATE'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'END_DATE'.
  APPEND LS_FIELDS TO FIELDS.

  PERFORM RFC_READ_TABLE USING 'TPROJECT'
                               P_SM_RFC
                               SEL
                               FIELDS
                      CHANGING TPROJECT_TAB.
  CLEAR: SEL, FIELDS, HANDLES_TAB[].

* Get the projects objects
  APPEND 'OBJ_TYPE = `CUST`' TO SEL.

  PERFORM RFC_READ_TABLE USING   'TOBJECTP'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING TOBJECTP_TAB.

  LOOP AT TPROJECT_TAB INTO TPROJECT_WA.
    MODIFY_TABIX = SY-TABIX.
    READ TABLE TOBJECTP_TAB WITH KEY PROJECT_ID = TPROJECT_WA-PROJECT_ID
                INTO TOBJECT_WA .
    TPROJECT_WA-GUID = TOBJECT_WA-OBJECT_ID.
    MODIFY TPROJECT_TAB INDEX MODIFY_TABIX FROM TPROJECT_WA
    TRANSPORTING GUID.
  ENDLOOP.
*  Add the Project data to the current node
  PERFORM ADD_ITAB_TO_XML TABLES TPROJECT_TAB HANDLES_TAB
                          USING G_IREF_PDOCUMENT SOLAR_PROJECTS_TYPE
                              'PROJECT_TYPE'.
  CLEAR: SEL, FIELDS, HANDLES_TAB[].
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                      SOLAR_PROJECTS_TYPE 'X'.

*-----------------------------------------------------------------------
* Create a child node for the Project node
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'PROJECT_NODES'
                          CHANGING SOLAR_PROJECTS_NODE.

CONCATENATE 'SOLAR:2.Getting projects hierarchy ' "#EC NOTEXT
'using func SASAP_HIERARCHY_READ' "#EC NOTEXT
INTO GT_ETL_MESSAGE-MESSAGE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Getting the Solar data tree nodes
  LOOP AT TPROJECT_TAB INTO TPROJECT_WA.

    CONCATENATE 'SOLAR:3.Get hier of proj' "#EC NOTEXT
    TPROJECT_WA-PROJECT_ID
                TPROJECT_WA-GUID
          INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM ADD_USED_MEMORY_TO_LOG.

    CALL FUNCTION 'SASAP_HIERARCHY_READ' DESTINATION P_SM_RFC
      EXPORTING
        STRUCTURE_ID          = TPROJECT_WA-GUID
        READ_TEXTS            = 'X'
        INCLUDE_SUBSTRUCTURES = 'X'
      IMPORTING
        MESSAGE               = MESSAGE
      TABLES
        LIST_OF_NODES         = NODES
        LIST_OF_TEXTS         = TEXTS.

    IF NOT MESSAGE IS INITIAL.
      CONCATENATE 'SOLAR:3.1' MESSAGE INTO GT_ETL_MESSAGE-MESSAGE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    LOOP AT NODES INTO NODE_WA.
      MOVE-CORRESPONDING NODE_WA TO ALL_NODES_WA.
      APPEND ALL_NODES_WA TO ALL_NODES.
    ENDLOOP.

    APPEND LINES OF TEXTS TO ALL_TEXTS.
    CLEAR: NODES, TEXTS.

  ENDLOOP.

* Add the Project data to the current node
  PERFORM ADD_ITAB_TO_XML TABLES ALL_NODES HANDLES_TAB
                          USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
                              'PROJECT_NODE'.
  CLEAR HANDLES_TAB[].
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                     SOLAR_PROJECTS_NODE 'X'.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'PROJECT_NODES_TEXTS'
                          CHANGING SOLAR_PROJ_NODE_TEXT.

  PERFORM ADD_ITAB_TO_XML TABLES ALL_TEXTS HANDLES_TAB
                          USING G_IREF_PDOCUMENT SOLAR_PROJ_NODE_TEXT
                              'PROJECT_NODE_TEXT'.
  CLEAR HANDLES_TAB[].
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                     SOLAR_PROJ_NODE_TEXT 'X'.



  CLEAR: ALL_TEXTS, SOLAR_PROJECTS_NODE.
*-----------------------------------------------------------------------

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'TRANSACTION_TREES'
                          CHANGING SOLAR_PROJECTS_NODE.

* Read from BMTNODE01R with nodes-REFNOD_ID.
* Get the business process trees
  GT_ETL_MESSAGE-MESSAGE =
  'SOLAR:4. Get business process trees-table BMTNODE01R'. "#EC NOTEXT
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  IS_FIRST = 'X'.
  LOOP AT ALL_NODES INTO ALL_NODES_WA.
    IF IS_FIRST = 'X'.
      CLEAR IS_FIRST.
      SEL_WA = 'REF_TYPE = `TREE`'.
      APPEND SEL_WA TO SEL.
      CONCATENATE 'AND  ( NODE_ID = `' ALL_NODES_WA-REFNODE_ID '`'
      INTO SEL_WA.
    ELSE.
      CONCATENATE 'OR NODE_ID = `' ALL_NODES_WA-REFNODE_ID '`'
      INTO SEL_WA.
    ENDIF.


    COUNTER = COUNTER + 1.
*   Select options are limited, we limit it to 1000 per query
    IF COUNTER = MAX_SELECT_OPTIONS.
      CONCATENATE SEL_WA ')' INTO SEL_WA.
      APPEND SEL_WA TO SEL.

      CONCATENATE
      'SOLAR:4.1 Read tree for bulk with last tree' "#EC NOTEXT
        ALL_NODES_WA-REFNODE_ID
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      PERFORM ADD_USED_MEMORY_TO_LOG.

      PERFORM RFC_READ_TABLE USING   'BMTNODE01R'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING TMP_BMT_REFS.
      APPEND LINES OF TMP_BMT_REFS TO BMT_TREE_REF.
      COUNTER = 0.
      CLEAR SEL.
      IS_FIRST = 'X'.
    ELSE.
      AT LAST.
        CONCATENATE SEL_WA ')' INTO SEL_WA.
        APPEND SEL_WA TO SEL.

        GT_ETL_MESSAGE-MESSAGE =
'SOLAR:4.1 Reading last batch of business process trees'. "#EC NOTEXT
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM ADD_USED_MEMORY_TO_LOG.

*       Get the last bulk of the trees
        PERFORM RFC_READ_TABLE USING   'BMTNODE01R'
                                       P_SM_RFC
                                       SEL
                                       FIELDS
                               CHANGING TMP_BMT_REFS.
        APPEND LINES OF TMP_BMT_REFS TO BMT_TREE_REF.
        CLEAR TMP_BMT_REFS.
      ENDAT.

      APPEND SEL_WA TO SEL.
    ENDIF.
  ENDLOOP.
  CLEAR: SEL, ALL_NODES, FIELDS.

* Create a node for the BMT nodes
* (all the nodes in the business process TREE)
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'BMT_TREES'
                            CHANGING BMTNODES.
* Get the BMT nodes
  PERFORM ADD_ITAB_TO_XML TABLES BMT_TREE_REF HANDLES_TAB
                           USING G_IREF_PDOCUMENT BMTNODES
                               'BMT_TREE'.
  CLEAR HANDLES_TAB[].
  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                      BMTNODES 'X'.


* Get all of the transactions
* (all of the objects in the transactions TAB OF SOLAR1)
  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'SOLAR_TRANSACTIONS'
                            CHANGING SOLAR_TRANSACTIONS_NODE.
* Getting the transactions objects
  PERFORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE
                                               BMT_TREE_REF
                                      USING 'BMTA'
                                      CHANGING SOLAR_TRANSACTIONS_NODE.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                  'SOLAR_URLS'
                            CHANGING SOLAR_URLS_NODE.
* Getting the other objects in the transaction tab.
  PERFORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE
                                               BMT_TREE_REF
                                      USING 'BMSO'
                                      CHANGING SOLAR_URLS_NODE.

  PERFORM ADD_ITAB_TO_XML TABLES BMT_TREE HANDLES_TAB
                           USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
                               'BMT_TREE_NODES'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                      SOLAR_PROJECTS_NODE 'X'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                      SOLAR_TRANSACTIONS_NODE 'X'.


  PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                      SOLAR_URLS_NODE 'X'.

  CLEAR: BMT_TREE, BMT_TREE_REF.
*-----------------------------------------------------------------------

  IF TBOM_EXTRACTION  EQ 'X' . " only extract if tbom is enabled

* Get the TBOM headers
    PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                    'TBOM_HEADS'
                              CHANGING SOLAR_PROJECTS_NODE.

    GT_ETL_MESSAGE-MESSAGE =
    'SOLAR:7. Getting TBOM headers AGS_TBOM_HEAD'. "#EC NOTEXT
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Since the line is too long - do not extract certain fields
    LS_FIELDS-FIELDNAME = 'GUID'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'DESCRIPTION'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'DYNAMIC'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'E2ETRACE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'STATIC'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'STATUS'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'ORIG_SYS'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'ORIG_CLIENT'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'CREATEDBY'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'CREATEDATE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'CREATETIME'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'UPDATEDBY'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'UPDATEDATE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'UPDATETIME'.
    APPEND LS_FIELDS TO FIELDS.

    PERFORM RFC_READ_TABLE USING 'AGS_TBOM_HEAD'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING TBOM_HEADER_TAB[].
    CLEAR: SEL, FIELDS.

    PERFORM ADD_ITAB_TO_XML TABLES TBOM_HEADER_TAB HANDLES_TAB
                             USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
                                 'TBOM_HEAD'.
    CLEAR HANDLES_TAB[].
    PERFORM APPEND_XML_ELEMENT_TO_FILE USING
                                        SOLAR_PROJECTS_NODE 'X'.

*----------------------------------------------------------------------
*  Get all of the TBOM entries
    DATA:
        LINES TYPE I,
        SLINES TYPE STRING,
        MAX_RFC_LINES TYPE I VALUE 10000,
        KEEP_READING TYPE C VALUE 'X',
        LAST_GUID TYPE STRING,
        LAST_POS TYPE DDPOSITION.

    PERFORM APPEND_STRING_TO_FILE USING '<DYNAMIC_TBOMS>'.

    DATA:STRUCT_FIELDS TYPE TABLE OF RFC_FIELDS,
          FIELD_WA LIKE LINE OF STRUCT_FIELDS,
          BASE_NUMBER TYPE I,
          STR_BASE_NUM TYPE STRING.

    GT_ETL_MESSAGE-MESSAGE =
    'SOLAR:8. Start to read dyn TBOM'. "#EC NOTEXT
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    PERFORM GET_RFC_STRUCTURE TABLES STRUCT_FIELDS
                              USING  'AGS_TBOM_BASE'
                                     P_SM_RFC.

    SORT STRUCT_FIELDS BY FIELDNAME.

    LS_FIELDS-FIELDNAME = 'GUID'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'AS4POS'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'PGMID'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'OBJECT'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'OBJ_NAME'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'OBJ_SOURCE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'OBJ_CLASS_TYPE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'OBJ_CLASS_VALUE'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'DEVCLASS'.
    APPEND LS_FIELDS TO FIELDS.
    LS_FIELDS-FIELDNAME = 'DLVUNIT'.
    APPEND LS_FIELDS TO FIELDS.
* Check if the field exists in the solman destination because there are
* differences between the different versions of solman
    READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_PGMID' BINARY
  SEARCH
      INTO FIELD_WA.
    IF SY-SUBRC IS INITIAL.
      LS_FIELDS-FIELDNAME = 'PARENT_PGMID'.
      APPEND LS_FIELDS TO FIELDS.
    ELSE.
      GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field PARENT_PGMID not in solman AGS_TBOM_BASE'. "#EC NOTEXT
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_OBJECT' BINARY
  SEARCH
      INTO FIELD_WA.
    IF SY-SUBRC IS INITIAL.
      LS_FIELDS-FIELDNAME = 'PARENT_OBJECT'.
      APPEND LS_FIELDS TO FIELDS.
    ELSE.
      GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field PARENT_OBJECT not in solman AGS_TBOM_BASE'. "#EC NOTEXT
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_OBJ_NAME'
    BINARY
          SEARCH
             INTO FIELD_WA.
    IF SY-SUBRC IS INITIAL.
      LS_FIELDS-FIELDNAME = 'PARENT_OBJ_NAME'.
      APPEND LS_FIELDS TO FIELDS.
    ELSE.
    CONCATENATE 'SOLAR:8.2 field PARENT_OBJ_NAME not in ' "#EC NOTEXT
    'solman AGS_TBOM_BASE' "#EC NOTEXT
    INTO GT_ETL_MESSAGE-MESSAGE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'SUB_OBJ_NAME' BINARY
  SEARCH
      INTO FIELD_WA.
    IF SY-SUBRC IS INITIAL.
      LS_FIELDS-FIELDNAME = 'SUB_OBJ_NAME'.
      APPEND LS_FIELDS TO FIELDS.
    ELSE.
      GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field SUB_OBJ_NAME not in solman AGS_TBOM_BASE'. "#EC NOTEXT
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.
    READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'TAB_HAS_KEY' BINARY
  SEARCH
      INTO FIELD_WA.
    IF SY-SUBRC IS INITIAL.
      LS_FIELDS-FIELDNAME = 'TAB_HAS_KEY'.
      APPEND LS_FIELDS TO FIELDS.
    ELSE.
      GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field TAB_HAS_KEY not in solman AGS_TBOM_BASE'. "#EC NOTEXT
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
    ENDIF.

    BASE_NUMBER = 0.
    DESCRIBE TABLE TBOM_HEADER_TAB LINES LINES.
    SLINES = LINES.
    CONCATENATE 'SOLAR:8.2 number of TBOM headers read:' "#EC NOTEXT
                    SLINES
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

    LOOP AT TBOM_HEADER_TAB INTO TBOM_HEADER_WA.
*   Get the number of entries in the base table for the header

      CONCATENATE 'SOLAR:8.3 Read dyn tbom for header' "#EC NOTEXT
                  TBOM_HEADER_WA-GUID
      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      PERFORM ADD_USED_MEMORY_TO_LOG.

      IF TBOM_HEADER_WA-E2ETRACE IS INITIAL AND
         TBOM_HEADER_WA-STATIC IS INITIAL.
*     In different versions of SOLMAN there are different fields.
*     Only TBOM for Dynamic or Semi-Dynamic are needed.
        KEEP_READING = 'X'.
      ELSE.
        CLEAR KEEP_READING.
      ENDIF.
*   Loop until finished reading all of the entries in the table
      WHILE KEEP_READING = 'X'.
*     Set the options to read from the last record that was read
        CONCATENATE 'GUID = `' TBOM_HEADER_WA-GUID '`' INTO SEL_WA.
        APPEND SEL_WA TO SEL.
        CONCATENATE ' AND AS4POS > `' LAST_POS '`' INTO SEL_WA.
        APPEND SEL_WA TO SEL.

*     Read from the TBOM table with limit of lines
        PERFORM RFC_READ_TABLE_WITH_ROWCOUNT USING 'AGS_TBOM_BASE'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                                 MAX_RFC_LINES
                        CHANGING TMP_BASE_TAB[].
*     Append the result of the current iteration to the global results
        PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TMP_BASE_TAB
                                     USING G_IREF_PDOCUMENT
                                           'DYN_TBOM'.

        DESCRIBE TABLE TMP_BASE_TAB LINES LINES.
        BASE_NUMBER = BASE_NUMBER + LINES.

*     If the number of lines read in the current iteration is less
*     than the maximum lines that we can read, it means that it reached
*     the end of the table.
        IF LINES < MAX_RFC_LINES.
          CLEAR KEEP_READING.
          STR_BASE_NUM = BASE_NUMBER.
          CONCATENATE 'SOLAR:8.4 Header' "#EC NOTEXT
                      TBOM_HEADER_WA-GUID
                      'has' "#EC NOTEXT
                      STR_BASE_NUM
                      'entries' "#EC NOTEXT
                      INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
          PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
          CLEAR: BASE_NUMBER, LAST_POS, LAST_GUID.
        ELSE.
*       Get the last record read in the current iteration and set the
*       key as the last read GUID and POS for the next iteration
          READ TABLE TMP_BASE_TAB INTO TBOM_BASE_WA INDEX LINES.
          LAST_GUID = TBOM_BASE_WA-GUID.
          LAST_POS = TBOM_BASE_WA-AS4POS.
        ENDIF.
        CLEAR: SEL, TMP_BASE_TAB.
      ENDWHILE.
    ENDLOOP.

    CLEAR: FIELDS, HANDLES_TAB[].
    PERFORM APPEND_STRING_TO_FILE USING '</DYNAMIC_TBOMS>'.
*----------------------------------------------------------------------

  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '</SOLAR_DATA>'.
  PERFORM ADD_TIME_STAT
  USING 'Extract Solution Manager Projects' "#EC NOTEXT
  L_STARTTIME L_STARTDATE.

ENDFORM.                                         "GET_SOLAR_RAW_DATA.

*&---------------------------------------------------------------------*
*&      Form  GET_SOLAR_TREE_NODES_AND_REFS
*&---------------------------------------------------------------------*
*        Get solar tree nodes
*----------------------------------------------------------------------*
* BMT_TREE (OUT) - All of the nodes of the tree
* BMT_TREE_REF (IN) - The references for the trees to be read
* TYPE - The type of the node read (Transaction/other objects)
* P_XML_ELEMENT - the XML element for the references
*----------------------------------------------------------------------*

FORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE_NODES
                                          BMT_TREE_REF
                                   USING TYPE
                                   CHANGING P_XML_ELEMENT  TYPE
XML_ELEMENT.

  DATA:
        HANDLES_TAB    TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
        BMTNODE_WA TYPE BMTNODE01,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        LS_FIELDS LIKE LINE OF FIELDS,
        SEL TYPE TABLE OF RFC_DB_OPT,
        SEL_WA TYPE RFC_DB_OPT,
        COUNTER TYPE I VALUE 0,
        IS_FIRST TYPE C VALUE 'X',
        BMTNODE_REFS TYPE TABLE OF BMTNODE01R,
        RES_BMTNODE_R TYPE TABLE OF BMTNODE01R,
        RES_DFURLS TYPE TABLE OF SM_DFURLS.

* Read the nodes of the Business process tree
  PERFORM GET_NODES TABLES BMT_TREE_REF
                           BMT_TREE_NODES
                    USING TYPE.



  CONCATENATE
  'SOLAR:6. Start reading node references for type' "#EC NOTEXT
               TYPE
       INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  CLEAR: SEL, FIELDS.
  COUNTER = 0.
  IS_FIRST = 'X'.
  LOOP AT BMT_TREE_NODES INTO BMTNODE_WA.
*   Create the select options
*   Only the first line does not start with 'OR'
    IF IS_FIRST = 'X'.
      CLEAR IS_FIRST.
      CONCATENATE '( NODE_ID = `' BMTNODE_WA-NODE_ID '`'
      INTO SEL_WA.
    ELSE.
      CONCATENATE 'OR NODE_ID = `' BMTNODE_WA-NODE_ID '`'
      INTO SEL_WA.
    ENDIF.

    COUNTER = COUNTER + 1.
*   Limit the select option to 1000 rows
    IF COUNTER = MAX_SELECT_OPTIONS.
*     Check if it runs for transactions or for the other objects
*     and read the relevant nodes

      CONCATENATE SEL_WA ')' INTO SEL_WA SEPARATED BY SPACE.
      APPEND SEL_WA TO SEL.

      IF TYPE = 'BMTA'.

        SEL_WA = 'AND ( REF_TYPE = `BMTA` OR REF_TYPE = `BMRE` )'.
        APPEND SEL_WA TO SEL.

        CONCATENATE
             'SOLAR:6.1 trans batch with last node ' "#EC NOTEXT
             BMTNODE_WA-NODE_ID
             'for type BMTA'
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM ADD_USED_MEMORY_TO_LOG.

        PERFORM READ_NODES_REF_TABLE TABLES RES_BMTNODE_R
                                     USING SEL
                                           FIELDS.
      ELSEIF TYPE = 'BMSO'.

        CONCATENATE
'SOLAR:6.1 Read Business Process URLS with last node ' "#EC NOTEXT
           BMTNODE_WA-NODE_ID
           'for type BMSO' "#EC NOTEXT
        INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM ADD_USED_MEMORY_TO_LOG.

        PERFORM READ_NODES_URL_TABLE TABLES RES_DFURLS
                                     USING SEL
                                           FIELDS.
      ENDIF.
*     Reset for new run
      CLEAR SEL.
      COUNTER = 0.
      IS_FIRST = 'X'.
    ELSE.
      AT LAST.
        CONCATENATE SEL_WA ')' INTO SEL_WA SEPARATED BY SPACE.
      ENDAT.
      APPEND SEL_WA TO SEL.
    ENDIF.
  ENDLOOP.

* If the counter is not reseted, it means that there are still
* records to read
  IF COUNTER > 0.
*   Read the relevant nodes (Transactions or other objects)
*   BMTA = transacitons, read from bmtnode01r
*   BMSO = other objects, read from dfurls.
    IF TYPE = 'BMTA'.
      SEL_WA = 'AND ( REF_TYPE = `BMTA` OR REF_TYPE = `BMRE` )'.
      APPEND SEL_WA TO SEL.

      GT_ETL_MESSAGE-MESSAGE =
'SOLAR:6.1 Reading last batch of transactions (TYPE BMTA)'. "#EC NOTEXT
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      PERFORM ADD_USED_MEMORY_TO_LOG.

      PERFORM READ_NODES_REF_TABLE TABLES RES_BMTNODE_R
                                   USING SEL
                                         FIELDS.
    ELSEIF TYPE = 'BMSO'.

CONCATENATE 'SOLAR:6.1 Reading last batch of business' "#EC NOTEXT
'URLS(TYPE BMSO)'  "#EC NOTEXT
INTO GT_ETL_MESSAGE-MESSAGE.

      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
      PERFORM ADD_USED_MEMORY_TO_LOG.

      PERFORM READ_NODES_URL_TABLE TABLES RES_DFURLS
                                   USING SEL
                                         FIELDS.
    ENDIF.
  ENDIF.


* Add the nodes to the xml file
  IF TYPE = 'BMTA'.
    PERFORM ADD_ITAB_TO_XML TABLES RES_BMTNODE_R HANDLES_TAB
                           USING G_IREF_PDOCUMENT P_XML_ELEMENT
                               'BMTNODER'.
  ELSEIF TYPE = 'BMSO'.
    PERFORM ADD_ITAB_TO_XML TABLES RES_DFURLS HANDLES_TAB
                           USING G_IREF_PDOCUMENT P_XML_ELEMENT
                               'DFURLS'.
  ENDIF.
  CLEAR HANDLES_TAB[].
ENDFORM.                               "GET_SOLAR_TREE_NODES_AND_REFS

*&---------------------------------------------------------------------*
*&      Form  GET_NODES
*&---------------------------------------------------------------------*
*       Get tree nodes according to the type.
*----------------------------------------------------------------------*
* BMTNODE_REFS (IN) - Refrence to the trees to read
* ALL_BMTNODES (OUT) - all of the nodes of the trees
*----------------------------------------------------------------------*
FORM GET_NODES TABLES BMTNODE_REFS
                      ALL_BMTNODES
               USING    TYPE.
  DATA:
        BMTNODE_R_WA TYPE BMTNODE01R,
        BMTNODES TYPE TABLE OF SM_PROJECT_TREE,
        FIELDS TYPE TABLE OF RFC_DB_FLD,
        LS_FIELDS LIKE LINE OF FIELDS,
        SEL TYPE TABLE OF RFC_DB_OPT,
        SEL_WA TYPE RFC_DB_OPT,
        COUNTER TYPE I VALUE 0,
        IS_FIRST TYPE C VALUE 'X',
        LINES TYPE I.

  CLEAR: SEL, FIELDS.
* Since the line is too long get only the relevant fields
  LS_FIELDS-FIELDNAME = 'TREE_ID'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'EXTENSION'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'NODE_ID'.
  APPEND LS_FIELDS TO FIELDS.
  LS_FIELDS-FIELDNAME = 'EXT_KEY'.
  APPEND LS_FIELDS TO FIELDS.

  CONCATENATE
  'SOLAR:5 Start reading Business Process nodes for type ' "#EC NOTEXT
              TYPE
              'from table BMTNODE01' "#EC NOTEXT
              INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  PERFORM ADD_USED_MEMORY_TO_LOG.

  IS_FIRST = 'X'.
  LOOP AT BMTNODE_REFS INTO BMTNODE_R_WA.
    IF IS_FIRST = 'X'.
*     At the first iteration append the type and format the
*     select option
      CLEAR IS_FIRST.

      IF TYPE = 'BMTA'.
        SEL_WA = '( NODE_TYPE = `BMTA`'.
        APPEND SEL_WA TO SEL.
        SEL_WA = ' OR NODE_TYPE = `BMRE` )'.
        APPEND SEL_WA TO SEL.
      ELSE.
        CONCATENATE 'NODE_TYPE = `' TYPE '`' INTO SEL_WA.
        APPEND SEL_WA TO SEL.
      ENDIF.

      CONCATENATE 'AND  ( TREE_ID = `' BMTNODE_R_WA-REF_OBJECT '`'
      INTO SEL_WA.
    ELSE.
*     All other lines but the first, begin with 'OR'
      CONCATENATE 'OR TREE_ID = `' BMTNODE_R_WA-REF_OBJECT '`'
      INTO SEL_WA.
    ENDIF.

    COUNTER = COUNTER + 1.
*   Here the limit of the select option is 500 (and not 1000)
*   because of the mass of results that are expected back
    IF COUNTER  = MAX_SEL_OPT_LARGE_DATA.
*     close the select options before executing
      CONCATENATE SEL_WA ')' INTO SEL_WA.
      APPEND SEL_WA TO SEL.

      CONCATENATE 'SOLAR:5.1 read tree nodes- last tree' "#EC NOTEXT
                  BMTNODE_R_WA-REF_OBJECT
                  'for type' "#EC NOTEXT
                  TYPE
                  INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
      PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

      PERFORM ADD_USED_MEMORY_TO_LOG.

      PERFORM RFC_READ_TABLE USING   'BMTNODE01'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING BMTNODES.
*     Append current iteration result to the final results
      APPEND LINES OF BMTNODES TO ALL_BMTNODES.
*     Reset all for the next run
      CLEAR: SEL.
      COUNTER = 0.
      IS_FIRST = 'X'.
    ELSE.
      AT LAST.
*       If this is the last row, so it needs to close the select option
        CONCATENATE SEL_WA ')' INTO SEL_WA.
        APPEND SEL_WA TO SEL.

        CONCATENATE
            'SOLAR:5.1 Reading nodes of ' "#EC NOTEXT
            'trees for the last batch ' "#EC NOTEXT
            'for type'
            TYPE
            INTO GT_ETL_MESSAGE-MESSAGE .
        PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

        PERFORM ADD_USED_MEMORY_TO_LOG.

        PERFORM RFC_READ_TABLE USING   'BMTNODE01'
                                P_SM_RFC
                                SEL
                                FIELDS
                       CHANGING BMTNODES.
        APPEND LINES OF BMTNODES TO ALL_BMTNODES.
        CLEAR: SEL, FIELDS.
      ENDAT.
      APPEND SEL_WA TO SEL.
    ENDIF.

  ENDLOOP.
  CLEAR BMTNODE_REFS.
ENDFORM.                              "GET_NODES

*&---------------------------------------------------------------------*
*&      Form  READ_NODES_REF_TABLE
*&---------------------------------------------------------------------*
*       Read from BMTNODE01R
*----------------------------------------------------------------------*
* RESULTS (OUT) - the results from the table
* SEL (IN) - the select options to select by
* FIELDS (IN) - the list of field to read from the table
*----------------------------------------------------------------------*
FORM READ_NODES_REF_TABLE TABLES RESULTS
                          USING SEL TYPE TT_OPTIONS
                                FIELDS TYPE TT_FIELDS.
  DATA:
      BMTNODE_REFS TYPE TABLE OF BMTNODE01R.

  GT_ETL_MESSAGE-MESSAGE =
  'SOLAR:6.1.1 Get trnasactions from table BMTNODE01R'. "#EC NOTEXT
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  PERFORM RFC_READ_TABLE USING 'BMTNODE01R'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING BMTNODE_REFS.

  APPEND LINES OF BMTNODE_REFS TO RESULTS.

ENDFORM.                               "READ_NODES_REF_TABLE

*&---------------------------------------------------------------------*
*&      Form  READ_NODES_URL_TABLE
*&---------------------------------------------------------------------*
*       Read from DFURLS
*----------------------------------------------------------------------*
* RESULTS (OUT) - the results from the table
* SEL (IN) - the select options to select by
* FIELDS (IN) - the list of field to read from the table
*----------------------------------------------------------------------*
FORM READ_NODES_URL_TABLE TABLES RESULTS
                          USING SEL TYPE TT_OPTIONS
                                FIELDS TYPE TT_FIELDS.
  DATA:
      URLS_REFS TYPE TABLE OF SM_DFURLS.


  GT_ETL_MESSAGE-MESSAGE =
  'SOLAR:6.1.1 Get URLS from table DFURLS'. "#EC NOTEXT
  PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

  PERFORM RFC_READ_TABLE USING 'DFURLS'
                                 P_SM_RFC
                                 SEL
                                 FIELDS
                        CHANGING URLS_REFS.

  APPEND LINES OF URLS_REFS TO RESULTS.

ENDFORM.                               "READ_NODES_URL_TABLE

*---------------------------------------------------------------------*
*       FORM add_time_stats                                           *
*---------------------------------------------------------------------*
FORM ADD_TIME_STATS.

  DATA: TIME_STATS_NODE TYPE XML_ELEMENT.

* Insert the total execution of ETL time
  PERFORM ADD_TIME_STAT USING
        'Total ETL execution time' "#EC NOTEXT
      STARTTIME STARTDATE.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'TIME_STATS'
                          CHANGING TIME_STATS_NODE.

  PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_TIME_STAT
                                 USING G_IREF_PDOCUMENT
                                       TIME_STATS_NODE
                                       'TIME_STAT'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING TIME_STATS_NODE 'X'.

ENDFORM.                    "ADD_TIME_STATS

*---------------------------------------------------------------------*
*       FORM add_etl_error_messages                                   *
*---------------------------------------------------------------------*
FORM ADD_ETL_ERROR_MESSAGES.

  DATA: ETL_MESSAGES_NODE TYPE XML_ELEMENT.

  SORT GT_ETL_MESSAGE BY ORDER.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'ETL_MESSAGES'
                          CHANGING ETL_MESSAGES_NODE.

  PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_MESSAGE
                                 USING G_IREF_PDOCUMENT
                                       ETL_MESSAGES_NODE
                                       'ETL_MESSAGE'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_MESSAGES_NODE 'X'.

ENDFORM.                    "add_etl_error_messages

*&---------------------------------------------------------------------*
*&      Form  ADD_ETL_NOTIFICATIONS
*&---------------------------------------------------------------------*
FORM ADD_ETL_NOTIFICATIONS.

  IF NOT GT_ETL_NOTIFICATIONS[] IS INITIAL.
    PERFORM APPEND_STRING_TO_FILE USING '<ETL_NOTIFICATIONS>'.
    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES GT_ETL_NOTIFICATIONS
                                    USING  G_IREF_PDOCUMENT
                                           'ETL_NOTIFICATION'.
    PERFORM APPEND_STRING_TO_FILE USING '</ETL_NOTIFICATIONS>'.
  ENDIF.

ENDFORM.                    "ADD_ETL_NOTIFICATIONS

*---------------------------------------------------------------------*
*       FORM add_etl_joblog                                           *
*---------------------------------------------------------------------*
FORM ADD_ETL_JOBLOG.

  DATA: ETL_JOBLOG_NODE TYPE XML_ELEMENT.

  SORT GT_ETL_JOBLOG BY ORDER.

  PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
                                'ETL_JOBLOG'
                          CHANGING ETL_JOBLOG_NODE.

  PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_JOBLOG
                                 USING G_IREF_PDOCUMENT
                                       ETL_JOBLOG_NODE
                                       'ETL_JOBLOG'.

  PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_JOBLOG_NODE 'X'.

ENDFORM.                    "add_etl_joblog

*&---------------------------------------------------------------------*
*&  Include           ZETL_EXTRACT_ECC6_FIORI
*&---------------------------------------------------------------------*
FORM EXTRACT_FIORI_APP .

  TYPES: BEGIN OF TY_APP_DESCRIPTOR,
           APP_NAME    TYPE CHAR30,
           MANIFEST    TYPE STRING,
           DEVCLASS    TYPE DEVCLASS,
           DESCRIPTION TYPE TEXT80,
         END OF TY_APP_DESCRIPTOR.

  DATA: LT_APP_MANIFEST TYPE STANDARD TABLE OF TY_APP_DESCRIPTOR.
  DATA: LS_APP_MANIFEST TYPE TY_APP_DESCRIPTOR.
  DATA: LV_APPDESC_CONTENT TYPE STRING.
  DATA: LT_TADIR_OBJECT TYPE TABLE OF TADIR.
  DATA: LS_TADIR_OBJECT TYPE TADIR.
  DATA: LT_TXT TYPE TABLE OF O2APPLT.
  DATA: LS_TXT TYPE O2APPLT.

  DATA LS_DD02L TYPE DD02L.

  DATA: LV_CLASS_EXIST TYPE CHAR1.
  DATA: LV_BSP_APP_NAME TYPE STRING.
  DATA: LV_MANIFEST1 TYPE STRING VALUE 'WebContent/manifest.json'.
  DATA: LV_MANIFEST2 TYPE STRING VALUE 'manifest.json'.
  DATA: GT_PAR    TYPE ABAP_PARMBIND_TAB.
  DATA: GS_PAR    LIKE LINE OF GT_PAR.
  DATA: OREF1 TYPE REF TO OBJECT,
        DREF  TYPE REF TO DATA.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK P_UI5 = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Fiori Apps'."#EC NOTEXT

  "Validatoins
  SELECT SINGLE * FROM DD02L
    INTO LS_DD02L
    WHERE TABNAME = '/UI5/APPIDX'.
  CHECK SY-SUBRC = 0.

  CALL FUNCTION 'RS_CHECK_CLASS'
    EXPORTING
      TYPE  = '/UI5/CL_UI5_REP_RT'
    IMPORTING
      CLASS = LV_CLASS_EXIST.
  CHECK LV_CLASS_EXIST = 'X'.


  "get Apps List
  DATA LT_APP TYPE TABLE OF O2APPLNAME.
  FIELD-SYMBOLS: <FS_APP> TYPE O2APPLNAME.
  SELECT BSP_APPL_NAME FROM ('/UI5/APPIDX')
    INTO TABLE LT_APP.

  "get relavant Tadir objects
  SELECT * FROM TADIR
    INTO TABLE LT_TADIR_OBJECT
    WHERE PGMID = 'R3TR'
      AND OBJECT = 'WAPA'.


  "Get Apps text description
  IF LT_APP IS NOT INITIAL.
    SELECT * FROM O2APPLT
      INTO TABLE LT_TXT
      FOR ALL ENTRIES IN LT_APP
      WHERE APPLNAME = LT_APP-TABLE_LINE.
  ENDIF.


  LOOP AT LT_APP ASSIGNING <FS_APP>.
    CHECK <FS_APP> IS NOT INITIAL.
    CLEAR: LS_APP_MANIFEST, LV_APPDESC_CONTENT, LV_BSP_APP_NAME.
    REFRESH GT_PAR.

    LV_BSP_APP_NAME = <FS_APP>.
    GET REFERENCE OF LV_BSP_APP_NAME INTO DREF.
    GS_PAR-NAME = 'IV_NAME'.
    GS_PAR-KIND =  'E'.
    GS_PAR-VALUE = DREF.
    INSERT  GS_PAR INTO  TABLE GT_PAR.
    GET REFERENCE OF OREF1 INTO DREF.
    GS_PAR-NAME = 'RO_INSTANCE'.
    GS_PAR-KIND =  'R'.
    GS_PAR-VALUE = DREF.
    INSERT  GS_PAR INTO  TABLE GT_PAR.
    TRY .
      CALL METHOD ('/UI5/CL_UI5_REP_RT')=>('/UI5/IF_UI5_REP_RT~GET_API')
        PARAMETER-TABLE
          GT_PAR.

      REFRESH GT_PAR.
      GET REFERENCE OF LV_MANIFEST1 INTO DREF.
      GS_PAR-NAME = 'IV_PATH'.
      GS_PAR-KIND =  'E'.
      GS_PAR-VALUE = DREF.
      INSERT  GS_PAR INTO  TABLE GT_PAR.

      GET REFERENCE OF LV_APPDESC_CONTENT INTO DREF.
      GS_PAR-NAME = 'EV_FILE_CONTENT_AS_STRING'.
      GS_PAR-KIND =  'I'.
      GS_PAR-VALUE = DREF.
      INSERT  GS_PAR INTO  TABLE GT_PAR.

      TRY .
        CALL METHOD OREF1->('/UI5/IF_UI5_REP_RT~GET_FILE')
          PARAMETER-TABLE GT_PAR.

        CATCH CX_ROOT.
          REFRESH GT_PAR.
          GET REFERENCE OF LV_MANIFEST2 INTO DREF.
          GS_PAR-NAME = 'IV_PATH'.
          GS_PAR-KIND =  'E'.
          GS_PAR-VALUE = DREF.
          INSERT  GS_PAR INTO  TABLE GT_PAR.

          GET REFERENCE OF LV_APPDESC_CONTENT INTO DREF.
          GS_PAR-NAME = 'EV_FILE_CONTENT_AS_STRING'.
          GS_PAR-KIND =  'I'.
          GS_PAR-VALUE = DREF.
          INSERT  GS_PAR INTO  TABLE GT_PAR.
          TRY .
            CALL METHOD OREF1->('/UI5/IF_UI5_REP_RT~GET_FILE')
              PARAMETER-TABLE GT_PAR.
            CATCH CX_ROOT.
             "" CONTINUE.
          ENDTRY.
        ENDTRY.

        READ TABLE LT_TADIR_OBJECT INTO LS_TADIR_OBJECT
          WITH KEY OBJ_NAME = <FS_APP>.
        IF SY-SUBRC = 0.
          LS_APP_MANIFEST-DEVCLASS = LS_TADIR_OBJECT-DEVCLASS.
        ENDIF.

        READ TABLE LT_TXT INTO LS_TXT
          WITH KEY APPLNAME = <FS_APP>.
        IF SY-SUBRC = 0.
          LS_APP_MANIFEST-DESCRIPTION = LS_TXT-TEXT.
        ENDIF.

        LS_APP_MANIFEST-APP_NAME = <FS_APP>.
        LS_APP_MANIFEST-MANIFEST = LV_APPDESC_CONTENT.
        APPEND LS_APP_MANIFEST TO LT_APP_MANIFEST.

      CATCH CX_ROOT. "catch get_api
        CONTINUE.
    ENDTRY.
  ENDLOOP.

  PERFORM APPEND_STRING_TO_FILE USING '<UI5_APPS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_APP_MANIFEST
                                  USING  G_IREF_PDOCUMENT
                                         'UI_APP'.
  PERFORM APPEND_STRING_TO_FILE USING '</UI5_APPS>'.

  PERFORM ADD_TIME_STAT USING
        'Extract Fiori Apps' "#EC NOTEXT
         L_STARTTIME L_STARTDATE.
ENDFORM.

*&---------------------------------------------------------------------*
*&  Include           ZETL_EXTRACT_ECC6_ODATA
*&---------------------------------------------------------------------*
FORM EXTRACT_ODATA_SERVICE.
  TYPES: BEGIN OF TY_IWFND_MED_SRH,
           SRV_IDENTIFIER     TYPE CHAR40,
           IS_ACTIVE          TYPE CHAR1,
           NAMESPACE          TYPE CHAR10,
           OBJECT_NAME        TYPE CHAR35,
           SERVICE_NAME       TYPE CHAR40,
           SERVICE_VERSION    TYPE NUMC4,
           CREATED_BY         TYPE SYUNAME,
           CHANGED_BY         TYPE SYUNAME,
           CREATED_TIMESTMP   TYPE TZNTSTMPS,
           CHANGED_TIMESTMP   TYPE TZNTSTMPS,
           IS_SAP_SERVICE     TYPE CHAR1,
           SOFT_STATE_STAT    TYPE CHAR1,
           PROCESS_MODE       TYPE CHAR1,
           RELEASE_STATUSTYPE TYPE C LENGTH 184,
         END OF TY_IWFND_MED_SRH.

  TYPES: BEGIN OF TY_IWBEP_SBD_GA,
           PROJECT           TYPE CHAR30,
           NODE_UUID         TYPE RAW16,
           CREATION_USER_ID TYPE SYUNAME,
           CREATION_TIME     TYPE TIMESTAMPL,
           LAST_CHG_USER_ID TYPE SYUNAME,
           LAST_CHG_TIME     TYPE TIMESTAMPL,
           NAME             TYPE CHAR128,
           PGMID             TYPE PGMID,
           TROBJ_TYPE       TYPE TROBJTYPE,
           TROBJ_NAME       TYPE SOBJ_NAME,
           GEN_ART_TYPE     TYPE CHAR4,
           HASH             TYPE HASH160X,
           RFC_NAME         TYPE CHAR30,
         END OF TY_IWBEP_SBD_GA.

  TYPES: BEGIN OF TY_IWBEP_SBD_DS,
           PROJECT          TYPE CHAR30,
           NODE_UUID         TYPE RAW16,
           PARENT_UUID      TYPE RAW16,
           NAME             TYPE CHAR128,
           DS_GROUP         TYPE CHAR40,
           DS_TYPE          TYPE CHAR1,
           RFC_DEST         TYPE RFCDEST,
           FUNCTION_NAME    TYPE RS38L_FNAM,
           MAX_HITS_CHANGED TYPE CHAR1,
           MAX_HITS_DS_ATTR TYPE CHAR255,
           LOG_CHANGED       TYPE CHAR1,
           LOG_DS_ATTR       TYPE CHAR255,
           EXTERNAL_DS_NAME TYPE STRING,
           RFC_NAME         TYPE CHAR30,
           OBJ_TYPE         TYPE CHAR10,
         END OF TY_IWBEP_SBD_DS.

  TYPES: BEGIN OF TY_ODATA_SRV.
      INCLUDE TYPE TY_IWFND_MED_SRH AS SRV.
  TYPES:
    DPC         TYPE SEOCLSNAME,
    DEVCLASS    TYPE DEVCLASS,
    DESCRIPTION TYPE TEXT80,
    END OF TY_ODATA_SRV.

  TYPES: BEGIN OF TY_ODATA_SRV_GA.
      INCLUDE TYPE TY_IWBEP_SBD_GA AS SRV.
  TYPES: ORIGIN        TYPE CHAR1,
         EXTERNAL_NAME TYPE CHAR40,
         END OF TY_ODATA_SRV_GA.

  TYPES: BEGIN OF TY_ODATA_SRV_DS.
      INCLUDE TYPE TY_IWBEP_SBD_DS AS SRV.
  TYPES: ORIGIN        TYPE CHAR1,
         EXTERNAL_NAME TYPE CHAR40,
         END OF TY_ODATA_SRV_DS.


  TYPES: BEGIN OF TY_SRV_TEXT,
           SRV_IDENTIFIER TYPE CHAR40,
           IS_ACTIVE TYPE CHAR1,
           LANGUAGE TYPE LANGU,
           DESCRIPTION    TYPE TEXT80,
         END OF TY_SRV_TEXT.

  TYPES: BEGIN OF TY_SRV_PROJECT,
           PROJECT       TYPE CHAR30,
           EXTERNAL_NAME TYPE CHAR40,
         END OF TY_SRV_PROJECT.

  TYPES: BEGIN OF TY_SRV_DPC,
           EXTERNAL_NAME TYPE CHAR40,
           VERSION       TYPE NUMC4,
           CLASS_NAME    TYPE CHAR30,
         END OF TY_SRV_DPC.


  DATA: LT_ODATA_SRV_OUT   TYPE STANDARD TABLE OF TY_ODATA_SRV.
  DATA: LS_ODATA_SRV_OUT   TYPE TY_ODATA_SRV.
  DATA: LT_ODATA_SERVICE   TYPE STANDARD TABLE OF TY_IWFND_MED_SRH.
  DATA: LT_ODATA_SRV_TXT   TYPE STANDARD TABLE OF TY_SRV_TEXT.
  DATA: LT_SRV_DPC         TYPE STANDARD TABLE OF TY_SRV_DPC.
  DATA: LT_SRV_PROJECT     TYPE STANDARD TABLE OF TY_SRV_PROJECT.
  DATA: LT_SRV_GEN_ART     TYPE STANDARD TABLE OF TY_ODATA_SRV_GA.
  DATA: LT_SRV_DATA_SOURCE TYPE STANDARD TABLE OF TY_ODATA_SRV_DS.
  DATA: LT_SRV_TADIR       TYPE STANDARD TABLE OF TADIR.

  DATA: LS_SRV_DPC     LIKE LINE OF LT_SRV_DPC.
  DATA: LS_TADIR       TYPE TADIR.
  DATA: LS_ODATA_TEXT  LIKE LINE OF LT_ODATA_SRV_TXT.
  DATA: L_STARTTIME    TYPE SY-UZEIT,
        L_STARTDATE    TYPE SY-DATUM.

  DATA LS_DD02L TYPE DD02L.

  FIELD-SYMBOLS: <FS_SRV>      TYPE  TY_IWFND_MED_SRH.
  FIELD-SYMBOLS: <FS_SRV_PROJ> TYPE  TY_SRV_PROJECT.
  FIELD-SYMBOLS: <FS_SRV_DS>   TYPE  TY_ODATA_SRV_DS.
  FIELD-SYMBOLS: <FS_SRV_GA>   TYPE  TY_ODATA_SRV_GA.


  CHECK P_UI5 = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting OData Services '."#EC NOTEXT


  "Validations prerequisite
  SELECT SINGLE * FROM DD02L
    INTO LS_DD02L
    WHERE TABNAME = '/IWFND/I_MED_SRH'.
  CHECK SY-SUBRC = 0.

  SELECT * FROM ('/IWFND/I_MED_SRH')
    INTO CORRESPONDING FIELDS OF TABLE LT_ODATA_SERVICE.

  IF SY-SUBRC = 0.

    SELECT SRV_IDENTIFIER DESCRIPTION FROM ('/IWFND/I_MED_SRT')
      INTO CORRESPONDING FIELDS OF TABLE LT_ODATA_SRV_TXT
      FOR ALL ENTRIES IN LT_ODATA_SERVICE
      WHERE SRV_IDENTIFIER = LT_ODATA_SERVICE-SRV_IDENTIFIER
        AND IS_ACTIVE = 'A'.

    SELECT * FROM ('/IWBEP/I_MGW_SRH')
      INTO CORRESPONDING FIELDS OF TABLE LT_SRV_DPC
      FOR ALL ENTRIES IN LT_ODATA_SERVICE
      WHERE EXTERNAL_NAME = LT_ODATA_SERVICE-SERVICE_NAME.

    SELECT * FROM TADIR
      INTO TABLE LT_SRV_TADIR
      WHERE PGMID = 'R3TR'
        AND OBJECT = 'IWPR'.

    SELECT PROJECT EXTERNAL_NAME FROM ('/IWBEP/I_SBD_SV')
      INTO CORRESPONDING FIELDS OF TABLE LT_SRV_PROJECT
      FOR ALL ENTRIES IN LT_ODATA_SERVICE
      WHERE EXTERNAL_NAME = LT_ODATA_SERVICE-SERVICE_NAME.

    IF SY-SUBRC  = 0.
      SELECT * FROM ('/IWBEP/I_SBD_GA')
        INTO CORRESPONDING FIELDS OF TABLE LT_SRV_GEN_ART
        FOR ALL ENTRIES IN LT_SRV_PROJECT
        WHERE PROJECT = LT_SRV_PROJECT-PROJECT.

      SELECT * FROM ('/IWBEP/I_SBD_DS')
        INTO CORRESPONDING FIELDS OF TABLE LT_SRV_DATA_SOURCE
        FOR ALL ENTRIES IN LT_SRV_PROJECT
        WHERE PROJECT = LT_SRV_PROJECT-PROJECT.
    ENDIF.

    LOOP AT LT_ODATA_SERVICE ASSIGNING <FS_SRV>.
      CLEAR: LS_ODATA_SRV_OUT,LS_SRV_DPC.

      LS_ODATA_SRV_OUT-SRV = <FS_SRV>.

      READ TABLE LT_ODATA_SRV_TXT INTO LS_ODATA_TEXT
        WITH KEY SRV_IDENTIFIER = <FS_SRV>-SRV_IDENTIFIER
                 LANGUAGE = SY-LANGU.
      IF SY-SUBRC = 0.
        LS_ODATA_SRV_OUT-DESCRIPTION = LS_ODATA_TEXT-DESCRIPTION.
      ELSE.
        READ TABLE LT_ODATA_SRV_TXT INTO LS_ODATA_TEXT
          WITH KEY SRV_IDENTIFIER = <FS_SRV>-SRV_IDENTIFIER
                   LANGUAGE = 'EN'.
        IF SY-SUBRC = 0.
          LS_ODATA_SRV_OUT-DESCRIPTION = LS_ODATA_TEXT-DESCRIPTION.
        ELSE.
          READ TABLE LT_ODATA_SRV_TXT INTO LS_ODATA_TEXT
            WITH KEY SRV_IDENTIFIER = <FS_SRV>-SRV_IDENTIFIER.
          IF SY-SUBRC = 0.
            LS_ODATA_SRV_OUT-DESCRIPTION = LS_ODATA_TEXT-DESCRIPTION.
          ENDIF.
        ENDIF.
      ENDIF.

      READ TABLE LT_SRV_DPC INTO LS_SRV_DPC
        WITH KEY EXTERNAL_NAME = <FS_SRV>-SERVICE_NAME
                 VERSION       = <FS_SRV>-SERVICE_VERSION.

      IF SY-SUBRC = 0.
        LS_ODATA_SRV_OUT-DPC = LS_SRV_DPC-CLASS_NAME.
      ENDIF.

      READ TABLE LT_SRV_PROJECT ASSIGNING <FS_SRV_PROJ>
              WITH KEY EXTERNAL_NAME =  <FS_SRV>-SERVICE_NAME.
      IF SY-SUBRC = 0.
        READ TABLE LT_SRV_TADIR INTO LS_TADIR
             WITH KEY PGMID = 'R3TR'
                      OBJECT = 'IWPR'
                      OBJ_NAME = <FS_SRV_PROJ>-PROJECT.
        IF SY-SUBRC = 0.
          LS_ODATA_SRV_OUT-DEVCLASS = LS_TADIR-DEVCLASS.
        ENDIF.

      ENDIF.

      APPEND LS_ODATA_SRV_OUT TO LT_ODATA_SRV_OUT.
    ENDLOOP.

    LOOP AT LT_SRV_GEN_ART ASSIGNING <FS_SRV_GA>.
      CLEAR: LS_TADIR.
      READ TABLE LT_SRV_TADIR INTO LS_TADIR
        WITH KEY PGMID = 'R3TR'
                 OBJECT = 'IWPR'
                 OBJ_NAME = <FS_SRV_GA>-PROJECT.

      IF SY-SUBRC = 0.
        IF LS_TADIR-AUTHOR <> 'SAP'.
          <FS_SRV_GA>-ORIGIN = 'C'.
        ELSE.
          <FS_SRV_GA>-ORIGIN = 'S'.
        ENDIF.
      ELSE.
        <FS_SRV_GA>-ORIGIN = 'U'.
      ENDIF.
      READ TABLE LT_SRV_PROJECT ASSIGNING <FS_SRV_PROJ>
         WITH KEY PROJECT =  <FS_SRV_GA>-PROJECT.
      IF SY-SUBRC = 0.
        <FS_SRV_GA>-EXTERNAL_NAME = <FS_SRV_PROJ>-EXTERNAL_NAME.
      ENDIF.
    ENDLOOP.

    LOOP AT LT_SRV_DATA_SOURCE ASSIGNING <FS_SRV_DS>.
      CLEAR: LS_TADIR.
      READ TABLE LT_SRV_TADIR INTO LS_TADIR
        WITH KEY PGMID = 'R3TR'
                 OBJECT = 'IWPR'
                 OBJ_NAME = <FS_SRV_DS>-PROJECT.

      IF SY-SUBRC = 0.
        IF LS_TADIR-AUTHOR <> 'SAP'.
          <FS_SRV_DS>-ORIGIN = 'C'.
        ELSE.
          <FS_SRV_DS>-ORIGIN = 'S'.
        ENDIF.
      ELSE.
        <FS_SRV_DS>-ORIGIN = 'U'.
      ENDIF.
      READ TABLE LT_SRV_PROJECT ASSIGNING <FS_SRV_PROJ>
        WITH KEY PROJECT =  <FS_SRV_DS>-PROJECT.
      IF SY-SUBRC = 0.
        <FS_SRV_DS>-EXTERNAL_NAME = <FS_SRV_PROJ>-EXTERNAL_NAME.
      ENDIF.
    ENDLOOP.

  ENDIF.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_SERVICES>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_ODATA_SRV_OUT
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_SERVICES>'.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_SERVICES_PROJECT>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SRV_PROJECT
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_PROJECT'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_SERVICES_PROJECT>'.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_SERVICES_GA>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SRV_GEN_ART
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_GA'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_SERVICES_GA>'.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_SERVICES_DS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES  LT_SRV_DATA_SOURCE
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_DS'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_SERVICES_DS>'.

  PERFORM ADD_TIME_STAT USING
      'Extracting OData Services' "#EC NOTEXT
       L_STARTTIME L_STARTDATE.

ENDFORM.

*&---------------------------------------------------------------------*
*&  Include           ZETL_EXTRACT_ECC6_ODATA_USAGE
*&---------------------------------------------------------------------*
FORM EXTRACT_ODATA_USAGE.

 TYPES: BEGIN OF TY_ODATA_METERING,
          TECH_SRV_NAME TYPE CHAR40,
          ENTITY_TYPE   TYPE C LENGTH 60,
        END OF TY_ODATA_METERING.

 TYPES: BEGIN OF TY_IWFND_METAGR,
          MANDT TYPE MANDT,
          AGR_YEAR TYPE SCAL_YEAR,
          AGR_MONTH TYPE SCAL_MONTH,
          USER_AGENT TYPE CHAR16,
          TECH_SRV_NAME TYPE CHAR35,
          TECH_SRV_VERSION TYPE NUMC4,
          NAMESPACE TYPE CHAR10,
          CALLS_TOTAL TYPE RSUVM_CNT,
          XML_SIZE_TOTAL TYPE HASHC,
          AGR_PERIOD TYPE CHAR1,
          AGR_DATE TYPE DATS,
        END OF TY_IWFND_METAGR.

  DATA:
    LT_METAGR  TYPE STANDARD TABLE OF TY_IWFND_METAGR,
    LT_MET_DAT TYPE STANDARD TABLE OF TY_ODATA_METERING,
    LT_MET_COL TYPE STANDARD TABLE OF TY_ODATA_METERING.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  CHECK P_UI5 = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING
    'Extracting OData Service Usage'.   "#EC NOTEXT


  PERFORM GET_ODATA_METERING_AGGR TABLES LT_METAGR.
  PERFORM GET_ODATA_METERING
     TABLES LT_MET_COL USING '/IWFND/L_MET_COL' 'X'.
  PERFORM GET_ODATA_METERING
     TABLES LT_MET_DAT USING '/IWFND/L_MET_DAT' ' '.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_USAGES>'.
  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_USAGE_AGGR>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_METAGR
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_AGGR'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_USAGE_AGGR>'.

  PERFORM APPEND_STRING_TO_FILE USING '<ODATA_USAGE_DATA>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MET_COL
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_USAGE'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MET_DAT
                                  USING  G_IREF_PDOCUMENT
                                        'ODATA_USAGE'.
  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_USAGE_DATA>'.

  PERFORM APPEND_STRING_TO_FILE USING '</ODATA_USAGES>'.

  PERFORM ADD_TIME_STAT USING
      'Extract OData Service Usage' "#EC NOTEXT
       L_STARTTIME L_STARTDATE.

ENDFORM.


*&---------------------------------------------------------------------*
*&      Form  GET_ODATA_METERING_AGGR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->RESULT     text
*----------------------------------------------------------------------*
FORM GET_ODATA_METERING_AGGR TABLES RESULT.

 TYPES: BEGIN OF TY_IWFND_METAGR,
           MANDT TYPE MANDT,
           AGR_YEAR TYPE SCAL_YEAR,
           AGR_MONTH TYPE SCAL_MONTH,
           USER_AGENT TYPE CHAR16,
           TECH_SRV_NAME TYPE CHAR35,
           TECH_SRV_VERSION TYPE NUMC4,
           NAMESPACE TYPE CHAR10,
           CALLS_TOTAL TYPE RSUVM_CNT,
           XML_SIZE_TOTAL TYPE HASHC,
           AGR_PERIOD TYPE CHAR1,
           AGR_DATE TYPE DATS,
         END OF TY_IWFND_METAGR.

  DATA: SEL        TYPE TABLE OF RFC_DB_OPT,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.
  DATA: LV_MESSAGE TYPE C LENGTH 512.
  DATA: LT_TAB512 TYPE TABLE OF TAB512.
  DATA: LS_METAGR TYPE TY_IWFND_METAGR.
  DATA: LV_STR_SY_SUBRC TYPE STRING.
  DATA: LINES TYPE NUMC10.

  FIELD-SYMBOLS: <FS_DATA> TYPE ANY.
  FIELD-SYMBOLS: <FS_TAB512> TYPE TAB512.
  FIELD-SYMBOLS: <FS_FIELD> TYPE RFC_DB_FLD.


  CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
    EXPORTING
      QUERY_TABLE          = '/IWFND/L_METAGR'
      NO_DATA              = SPACE
    TABLES
      OPTIONS              = SEL
      FIELDS               = FIELDS_TAB
      DATA                 = LT_TAB512
    EXCEPTIONS
      TABLE_NOT_AVAILABLE  = 1
      TABLE_WITHOUT_DATA   = 2
      OPTION_NOT_VALID     = 3
      FIELD_NOT_VALID      = 4
      NOT_AUTHORIZED       = 5
      DATA_BUFFER_EXCEEDED = 6
      OTHERS               = 7.
  IF SY-SUBRC <> 0.
    LV_STR_SY_SUBRC = SY-SUBRC.
    CONCATENATE
       'Extract OData usage: Fail to call RFC_READ_TABLE for table'
       '/IWFND/L_METAGR, subrc = '
       LV_STR_SY_SUBRC INTO LV_MESSAGE RESPECTING BLANKS.
    PERFORM ADD_MESSAGE USING LV_MESSAGE ' '.
  ELSE.
    LINES  = LINES( LT_TAB512 ).
    CONCATENATE
       'Extract OData usage: /IWFND/L_METAGR usage count '
       LINES INTO LV_MESSAGE RESPECTING BLANKS.
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_FALSE.
  ENDIF.

  LOOP AT LT_TAB512 ASSIGNING <FS_TAB512>.
    CLEAR LS_METAGR.
    LOOP AT FIELDS_TAB ASSIGNING <FS_FIELD>.
      ASSIGN COMPONENT <FS_FIELD>-FIELDNAME OF STRUCTURE LS_METAGR
        TO <FS_DATA>.
      <FS_DATA> = <FS_TAB512>-WA+<FS_FIELD>-OFFSET(<FS_FIELD>-LENGTH).
    ENDLOOP.
    APPEND LS_METAGR TO RESULT.
  ENDLOOP.

ENDFORM.                    "GET_ODATA_METERING_AGGR



*&---------------------------------------------------------------------*
*&      Form  GET_ODATA_METERING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->RESULTS    text
*      -->TABLE_NAME text
*      -->ONLY_COUNT text
*----------------------------------------------------------------------*
FORM GET_ODATA_METERING TABLES RESULTS
                        USING TABLE_NAME
                              ONLY_COUNT.

  DATA: SEL        TYPE TABLE OF RFC_DB_OPT,
        LS_SEL     TYPE RFC_DB_OPT,
        FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
        LS_FIELD   TYPE RFC_DB_FLD.
  DATA: LV_MESSAGE TYPE C LENGTH 512.
  DATA: LV_COUNT TYPE I.
  DATA: LV_COUNT_C TYPE NUMC10.
  DATA: LV_NOW TYPE TIMESTAMP.
  DATA: LV_STR_SY_SUBRC TYPE STRING.
  DATA: LINES TYPE NUMC10.
  DATA: LV_START_TIME TYPE TZNTSTMPL.
  DATA: LV_HALF_YEAR TYPE INT4.
  DATA: LV_WHERE_CLAUSE TYPE STRING.
  DATA: LV_START_TIME_C TYPE CHAR22.

  GET TIME STAMP FIELD LV_NOW.

  LV_HALF_YEAR = 86400 * 180.
  LV_START_TIME = CL_ABAP_TSTMP=>SUBTRACTSECS(
      TSTMP   = LV_NOW
      SECS    = LV_HALF_YEAR  ).
  LV_START_TIME_C = LV_START_TIME.

  CONCATENATE  'AGGREGATED = '' '' AND TIMESTAMP > '''
    LV_START_TIME_C
    ''''
    INTO LV_WHERE_CLAUSE RESPECTING BLANKS.

  CALL FUNCTION 'SELECT_COUNT' DESTINATION P_RFCDES
    EXPORTING
      TABNAME              = TABLE_NAME
      WHERE                = LV_WHERE_CLAUSE
    IMPORTING
      HITS                 = LV_COUNT
    EXCEPTIONS
      OTHERS               = 3.
  IF SY-SUBRC = 0.
    LV_COUNT_C = LV_COUNT.
    CONCATENATE 'Extract OData usage: '
                TABLE_NAME
                ' usage count '
                LV_COUNT_C
                INTO LV_MESSAGE RESPECTING BLANKS.
    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_FALSE.
  ELSE.
    LV_STR_SY_SUBRC  = SY-SUBRC.
    CONCATENATE 'Extract OData usage: Fail to call SEL_COUNT for table '
                TABLE_NAME
                ' subrc =  '
                LV_STR_SY_SUBRC INTO LV_MESSAGE RESPECTING BLANKS.

    PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_FALSE.
  ENDIF.

  IF ONLY_COUNT <> 'X'.

    LS_SEL = LV_WHERE_CLAUSE.
    APPEND LS_SEL TO SEL.
    LS_FIELD-FIELDNAME = 'TECH_SRV_NAME'.
    APPEND LS_FIELD TO FIELDS_TAB.
    LS_FIELD-FIELDNAME = 'ENTITY_TYPE'.
    APPEND LS_FIELD TO FIELDS_TAB.

    CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
      EXPORTING
        QUERY_TABLE          = TABLE_NAME
        NO_DATA              = SPACE
      TABLES
        OPTIONS              = SEL
        FIELDS               = FIELDS_TAB
        DATA                 = RESULTS
      EXCEPTIONS
        TABLE_NOT_AVAILABLE  = 1
        TABLE_WITHOUT_DATA   = 2
        OPTION_NOT_VALID     = 3
        FIELD_NOT_VALID      = 4
        NOT_AUTHORIZED       = 5
        DATA_BUFFER_EXCEEDED = 6
        OTHERS               = 7.
    IF SY-SUBRC <> 0.
      LV_STR_SY_SUBRC  = SY-SUBRC.
      CONCATENATE
       'Extract OData usage: Fail to call RFC_READ_TABLE FOR table '
       TABLE_NAME
       ' subrc =  '
       LV_STR_SY_SUBRC INTO LV_MESSAGE RESPECTING BLANKS.
      PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_FALSE.
    ENDIF.
  ENDIF.

  SORT RESULTS.
  DELETE ADJACENT DUPLICATES FROM RESULTS.
  LINES = LINES( RESULTS ).
  CONCATENATE 'Extract OData usage: unique entries table '
                TABLE_NAME
                ' - '
                LINES INTO LV_MESSAGE RESPECTING BLANKS.
  PERFORM ADD_MESSAGE USING LV_MESSAGE ABAP_FALSE.

ENDFORM.                    "GET_ODATA_METERING

FORM EXTRACT_WHERE_USED_LIST.

  TYPES: BEGIN OF TY_WHERE_USED_CNT,
           WBCROSSGT           TYPE INT4,
           WBCROSSGT_CUSTOMER  TYPE INT4,
           CROSS               TYPE INT4,
           CROSS_CUSTOMER      TYPE INT4,
         END OF TY_WHERE_USED_CNT.

  TYPES: BEGIN OF TY_CLASS_METHOD_MAP,
           INCLUDE TYPE WBCROSSGT-INCLUDE,
           CLASS   TYPE SEOCLSKEY-CLSNAME,
           METHOD  TYPE SEOCPDNAME,
         END OF TY_CLASS_METHOD_MAP.

  DATA: LT_COUNTERS TYPE TABLE OF TY_WHERE_USED_CNT.
  DATA: LS_COUNTERS TYPE TY_WHERE_USED_CNT.

  DATA: LT_WBCROSSGT TYPE TABLE OF WBCROSSGT.
  DATA: LT_WBCROSSGT_INCLUDE TYPE TABLE OF WBCROSSGT-INCLUDE.
  DATA: LT_INCLUDE_METHOD_MAP TYPE TABLE OF TY_CLASS_METHOD_MAP,
        LS_INCLUDE_METHOD_MAP TYPE TY_CLASS_METHOD_MAP.
  DATA: LT_METHOD_2_INCLUDE TYPE TABLE OF TY_CLASS_METHOD_MAP.
  DATA: LS_METHOD_2_INCLUDE TYPE TY_CLASS_METHOD_MAP.
  DATA: LT_CROSS TYPE TABLE OF CROSS.

  DATA: LV_DATA_OR_TYPE TYPE CHAR32.
  DATA: LV_INTERFACE_NAME TYPE CHAR100.
  DATA: LV_METHOD_NAME TYPE SEOCPDNAME,
        LV_CLASS_NAME  TYPE SEOCLSKEY-CLSNAME.
  DATA: LS_METHOD_KEY TYPE SEOCPDKEY.
  DATA: L_STARTTIME TYPE SY-UZEIT,
        L_STARTDATE TYPE SY-DATUM.

  DATA: LRNG_WHERE_USED_CUST_OBJ TYPE RANGE OF TADIR-OBJ_NAME.
  DATA: LS_RNG_NAMESPACE LIKE LINE OF CUST_NAMESPACE_RNG.
  DATA: LS_RNG_CUST_OBJ LIKE LINE OF LRNG_WHERE_USED_CUST_OBJ
     VALUE 'ICP'.

  FIELD-SYMBOLS: <FS_CROSSGT> TYPE WBCROSSGT.
  FIELD-SYMBOLS: <FS_CROSSGT_INCLUDE> TYPE WBCROSSGT-INCLUDE.
  FIELD-SYMBOLS: <FS_METHOD_MAP> TYPE TY_CLASS_METHOD_MAP.

  LOOP AT CUST_NAMESPACE_RNG INTO LS_RNG_NAMESPACE.
    CHECK LS_RNG_NAMESPACE-LOW IS NOT INITIAL.
    CHECK LS_RNG_NAMESPACE-LOW <> '*'.
    LS_RNG_CUST_OBJ-LOW =   LS_RNG_NAMESPACE-LOW .
    APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.
  ENDLOOP.

  LOOP AT LT_TDEVC INTO LS_TDEVC.
    CHECK LS_TDEVC-NAMESPACE <> '/0CUST/'.

    CONCATENATE
      'Where used Namespace '  LS_TDEVC-NAMESPACE
      'from Development Class ' LS_TDEVC-DEVCLASS
       INTO GT_ETL_MESSAGE-MESSAGE RESPECTING BLANKS .
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

    CHECK  LS_TDEVC-NAMESPACE IS NOT INITIAL.
    CONCATENATE LS_TDEVC-NAMESPACE '*' INTO LS_RNG_CUST_OBJ-LOW.

    CONCATENATE
      'Where Used added namespace into range  '  LS_RNG_CUST_OBJ-LOW
       INTO GT_ETL_MESSAGE-MESSAGE RESPECTING BLANKS .
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

    APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.
  ENDLOOP.

  IF LRNG_WHERE_USED_CUST_OBJ[] IS INITIAL.
    GT_ETL_MESSAGE-MESSAGE = 'Where Used range is empty  '.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
  ENDIF.

  "ADD custom or modified VOFM programs
  PERFORM POPULATE_VOFM_PROGRAMS_RNG
    TABLES LRNG_WHERE_USED_CUST_OBJ.

  SORT LRNG_WHERE_USED_CUST_OBJ.
  DELETE ADJACENT DUPLICATES FROM LRNG_WHERE_USED_CUST_OBJ.

 LOOP AT LRNG_WHERE_USED_CUST_OBJ INTO LS_RNG_CUST_OBJ.
     CONCATENATE 'Where Used range  '
       LS_RNG_CUST_OBJ-SIGN LS_RNG_CUST_OBJ-OPTION LS_RNG_CUST_OBJ-LOW
       INTO GT_ETL_MESSAGE-MESSAGE RESPECTING BLANKS.
    PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
  ENDLOOP.

  SELECT COUNT(*) FROM WBCROSSGT INTO LS_COUNTERS-WBCROSSGT.

  SELECT COUNT(*) FROM WBCROSSGT INTO LS_COUNTERS-WBCROSSGT_CUSTOMER
    WHERE INCLUDE IN LRNG_WHERE_USED_CUST_OBJ.

  SELECT COUNT(*) FROM CROSS INTO LS_COUNTERS-CROSS.

  SELECT COUNT(*) FROM CROSS INTO LS_COUNTERS-CROSS_CUSTOMER
    WHERE INCLUDE IN LRNG_WHERE_USED_CUST_OBJ.

  APPEND LS_COUNTERS TO LT_COUNTERS.
  PERFORM APPEND_STRING_TO_FILE USING '<WHERE_USED_COUNTERS>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_COUNTERS
                                    USING  G_IREF_PDOCUMENT
                                          'COUNTERS'.
  PERFORM APPEND_STRING_TO_FILE USING '</WHERE_USED_COUNTERS>'.

  CHECK EXTRACT_WHERE_USED_LIST = 'X'.

  GET TIME.
  L_STARTTIME = SY-UZEIT.
  L_STARTDATE = SY-DATUM.

  PERFORM UPDATE_PROGRESS USING 'Extracting Where Used List'."#EC NOTEXT

  PERFORM APPEND_STRING_TO_FILE USING '<WHERE_USED_TABLE>'.

  SELECT * FROM WBCROSSGT
    INTO TABLE LT_WBCROSSGT
    PACKAGE SIZE PAC_SIZE
    WHERE INCLUDE IN LRNG_WHERE_USED_CUST_OBJ.

    PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_WBCROSSGT
                                    USING  G_IREF_PDOCUMENT
                                           'WBCROSSGT'.

    LOOP AT LT_WBCROSSGT ASSIGNING <FS_CROSSGT>.
      CLEAR: LS_METHOD_2_INCLUDE,LV_METHOD_NAME, LV_DATA_OR_TYPE.
      CLEAR: LV_INTERFACE_NAME.

      IF <FS_CROSSGT>-NAME CS '\ME:'.
        IF <FS_CROSSGT>-NAME CS '\IN:'.
          SPLIT  <FS_CROSSGT>-NAME AT '\IN:'
            INTO  LS_METHOD_2_INCLUDE-CLASS LV_INTERFACE_NAME.
          SPLIT  LV_INTERFACE_NAME AT '\ME:'
            INTO  LV_INTERFACE_NAME LV_METHOD_NAME.
          CONCATENATE LV_INTERFACE_NAME '~' LV_METHOD_NAME
            INTO LV_METHOD_NAME.
        ELSE.
          SPLIT <FS_CROSSGT>-NAME AT '\ME:'
            INTO LS_METHOD_2_INCLUDE-CLASS LV_METHOD_NAME.
        ENDIF.

        IF LS_METHOD_2_INCLUDE-CLASS IS NOT INITIAL AND
           LV_METHOD_NAME IS NOT INITIAL.
           SPLIT LV_METHOD_NAME AT '\'
             INTO LS_METHOD_2_INCLUDE-METHOD LV_DATA_OR_TYPE.
           APPEND LS_METHOD_2_INCLUDE TO LT_METHOD_2_INCLUDE.
        ENDIF.
      ENDIF.

      APPEND <FS_CROSSGT>-INCLUDE TO LT_WBCROSSGT_INCLUDE.
    ENDLOOP.

    SORT LT_WBCROSSGT_INCLUDE.
    DELETE ADJACENT DUPLICATES FROM LT_WBCROSSGT_INCLUDE.

    IF SY-DBCNT >= WHERE_USED_MAX_LINES.
      EXIT.
    ENDIF.
  ENDSELECT.

  SELECT * FROM CROSS
    INTO TABLE LT_CROSS
    PACKAGE SIZE PAC_SIZE
    WHERE INCLUDE IN LRNG_WHERE_USED_CUST_OBJ.
      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_CROSS
                                      USING  G_IREF_PDOCUMENT
                                            'CROSS'.
    IF SY-DBCNT >= WHERE_USED_MAX_LINES.
      EXIT.
    ENDIF.
  ENDSELECT.

  PERFORM APPEND_STRING_TO_FILE USING '</WHERE_USED_TABLE>'.

  "resolve class and method by include name
  LOOP AT LT_WBCROSSGT_INCLUDE ASSIGNING <FS_CROSSGT_INCLUDE>.
    CLEAR: LS_INCLUDE_METHOD_MAP,LS_METHOD_KEY.
    CL_OO_CLASSNAME_SERVICE=>GET_METHOD_BY_INCLUDE(
      EXPORTING
        INCNAME             = <FS_CROSSGT_INCLUDE>
      RECEIVING
        MTDKEY              =  LS_METHOD_KEY
      EXCEPTIONS
        CLASS_NOT_EXISTING  = 1
        METHOD_NOT_EXISTING = 2
        OTHERS              = 3 ).
    IF SY-SUBRC = 0.
        LS_INCLUDE_METHOD_MAP-INCLUDE  = <FS_CROSSGT_INCLUDE>.
        LS_INCLUDE_METHOD_MAP-CLASS    = LS_METHOD_KEY-CLSNAME.
        LS_INCLUDE_METHOD_MAP-METHOD   = LS_METHOD_KEY-CPDNAME.
        APPEND LS_INCLUDE_METHOD_MAP TO LT_INCLUDE_METHOD_MAP.
    ENDIF.

  ENDLOOP.

  SORT LT_METHOD_2_INCLUDE.
  DELETE ADJACENT DUPLICATES FROM LT_METHOD_2_INCLUDE.

  "resolve include name by class and method
  LOOP AT LT_METHOD_2_INCLUDE ASSIGNING <FS_METHOD_MAP>.
    CLEAR LS_METHOD_KEY.
    LS_METHOD_KEY-CLSNAME = <FS_METHOD_MAP>-CLASS.
    LS_METHOD_KEY-CPDNAME = <FS_METHOD_MAP>-METHOD.

    CL_OO_CLASSNAME_SERVICE=>GET_METHOD_INCLUDE(
      EXPORTING
        MTDKEY              = LS_METHOD_KEY
      RECEIVING
        RESULT              = <FS_METHOD_MAP>-INCLUDE
      EXCEPTIONS
        CLASS_NOT_EXISTING  = 1
        METHOD_NOT_EXISTING = 2
         OTHERS              = 3 ).
  ENDLOOP.

  APPEND LINES OF LT_METHOD_2_INCLUDE TO LT_INCLUDE_METHOD_MAP.
  SORT LT_INCLUDE_METHOD_MAP.
  DELETE ADJACENT DUPLICATES FROM LT_INCLUDE_METHOD_MAP.

  PERFORM APPEND_STRING_TO_FILE USING '<WHERE_USED_METHOD_MAP>'.
  PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_INCLUDE_METHOD_MAP
                                  USING  G_IREF_PDOCUMENT
                                        'METHOD_MAP'.
  PERFORM APPEND_STRING_TO_FILE USING '</WHERE_USED_METHOD_MAP>'.

  PERFORM ADD_TIME_STAT USING
      'Extract Where Used List' "#EC NOTEXT
       L_STARTTIME L_STARTDATE.

ENDFORM.

FORM POPULATE_VOFM_PROGRAMS_RNG TABLES LRNG_WHERE_USED_CUST_OBJ.

  DATA LT_PREFIX TYPE TABLE OF CHAR5.
  DATA LS_PREFIX LIKE LINE OF LT_PREFIX.
  DATA LT_DUMMY_RNG TYPE RANGE OF TADIR-OBJ_NAME.
  DATA LS_RNG_CUST_OBJ LIKE LINE OF LT_DUMMY_RNG VALUE 'IBT'.

  APPEND 'RV45C' TO LT_PREFIX.
  APPEND 'RV50B' TO LT_PREFIX.
  APPEND 'RV50C' TO LT_PREFIX.
  APPEND 'RV60C' TO LT_PREFIX.
  APPEND 'RV61A' TO LT_PREFIX.
  APPEND 'RV62A' TO LT_PREFIX.
  APPEND 'RV63A' TO LT_PREFIX.
  APPEND 'RV64A' TO LT_PREFIX.

  "Additional
  APPEND 'RV45B' TO LT_PREFIX.
  APPEND 'RV60B' TO LT_PREFIX.
  APPEND 'RV43A' TO LT_PREFIX.
  APPEND 'RV45T' TO LT_PREFIX.
  APPEND 'RV44A' TO LT_PREFIX.
  APPEND 'RV51A' TO LT_PREFIX.
  APPEND 'RV56C' TO LT_PREFIX.
  APPEND 'RV70T' TO LT_PREFIX.
  APPEND 'RV46T' TO LT_PREFIX.
  APPEND 'RVKMP' TO LT_PREFIX.
  APPEND 'RRISK' TO LT_PREFIX.
  APPEND 'RV62N' TO LT_PREFIX.
  APPEND 'RV623' TO LT_PREFIX.
  APPEND 'RBBYN' TO LT_PREFIX.
  APPEND 'RWVK1' TO LT_PREFIX.
  APPEND 'RV61M' TO LT_PREFIX.
  APPEND 'RV61P' TO LT_PREFIX.
  APPEND 'RV61D' TO LT_PREFIX.
  APPEND 'RV61B' TO LT_PREFIX.
  APPEND 'RV61C' TO LT_PREFIX.
  APPEND 'RV61G' TO LT_PREFIX.
  APPEND 'R080M' TO LT_PREFIX.
  APPEND 'RV01F' TO LT_PREFIX.
  APPEND 'RMDBF' TO LT_PREFIX.
  APPEND 'RV52E' TO LT_PREFIX.
  APPEND 'RV13Z' TO LT_PREFIX.
  APPEND 'RV65A' TO LT_PREFIX.
  APPEND 'RV61N' TO LT_PREFIX.
  APPEND 'RV77U' TO LT_PREFIX.
  APPEND 'FMCA1' TO LT_PREFIX.
  APPEND 'FMCA2' TO LT_PREFIX.
  APPEND 'FMCV1' TO LT_PREFIX.
  APPEND 'FMCV2' TO LT_PREFIX.
  APPEND 'FMCT1' TO LT_PREFIX.
  APPEND 'FMCT2' TO LT_PREFIX.
  APPEND 'FMCE1' TO LT_PREFIX.
  APPEND 'FMCE2' TO LT_PREFIX.
  APPEND 'FMCF1' TO LT_PREFIX.
  APPEND 'FMCF2' TO LT_PREFIX.
  APPEND 'FMCB1' TO LT_PREFIX.
  APPEND 'FMCB2' TO LT_PREFIX.
  APPEND 'FMCW1' TO LT_PREFIX.
  APPEND 'FMCW2' TO LT_PREFIX.
  APPEND 'FMCL1' TO LT_PREFIX.
  APPEND 'FMCL2' TO LT_PREFIX.
  APPEND 'FMCZ1' TO LT_PREFIX.
  APPEND 'FMCZ2' TO LT_PREFIX.
  APPEND 'FMCQ1' TO LT_PREFIX.
  APPEND 'FMCQ2' TO LT_PREFIX.
  APPEND 'FMCI1' TO LT_PREFIX.
  APPEND 'FMCI2' TO LT_PREFIX.
  APPEND 'AKUSR' TO LT_PREFIX.
  APPEND 'RKUSR' TO LT_PREFIX.
  APPEND 'DKUSR' TO LT_PREFIX.
  APPEND 'KAUSR' TO LT_PREFIX.
  APPEND '/SPE/VAL' TO LT_PREFIX.
  APPEND 'RVCAU' TO LT_PREFIX.
  APPEND 'RV57A' TO LT_PREFIX.
  APPEND 'FMCU1' TO LT_PREFIX.
  APPEND 'FMCU2' TO LT_PREFIX.
  APPEND 'FJCV1' TO LT_PREFIX.
  APPEND 'FJCV2' TO LT_PREFIX.
  APPEND 'RJ3GJ' TO LT_PREFIX.

  LOOP AT LT_PREFIX INTO LS_PREFIX.
    CONCATENATE LS_PREFIX '600' INTO LS_RNG_CUST_OBJ-LOW.
    CONCATENATE LS_PREFIX '999' INTO LS_RNG_CUST_OBJ-HIGH.
    APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.
  ENDLOOP.

  CONCATENATE 'RV07A' '900' INTO LS_RNG_CUST_OBJ-LOW.
  CONCATENATE 'RV07A' '999' INTO LS_RNG_CUST_OBJ-HIGH.
  APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.

  CONCATENATE 'RV45TE' '50' INTO LS_RNG_CUST_OBJ-LOW.
  CONCATENATE 'RV45TE' '99' INTO LS_RNG_CUST_OBJ-HIGH.
  APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.

  CONCATENATE 'RV65A' '50' INTO LS_RNG_CUST_OBJ-LOW.
  CONCATENATE 'RV65A' '99' INTO LS_RNG_CUST_OBJ-HIGH.
  APPEND LS_RNG_CUST_OBJ  TO LRNG_WHERE_USED_CUST_OBJ.

ENDFORM.
