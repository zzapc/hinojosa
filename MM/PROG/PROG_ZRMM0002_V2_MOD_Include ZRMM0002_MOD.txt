*&---------------------------------------------------------------------*
*&  Include           ZRMM0002_MOD
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*&      Module  STATUS_1000  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_1000 OUTPUT.

* GST - 21/05/2015 ->
  DATA: ls_ztmm0006 TYPE ztmm0006.
  CLEAR: gv_pedido_ok, gv_ebeln.
* GST - 21/05/2015 <-

  SET PF-STATUS '1000'.
  SET TITLEBAR '1000'.

* Ocultar los precios
  IF sy-tcode = 'ZMM0003'.
    LOOP AT SCREEN .
      IF screen-group1 = 'SUP'.
        screen-invisible = '1'.
        screen-active = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ELSEIF sy-tcode = 'ZMM0004'.

* GST - 21/05/2015 ->
    CLEAR: ls_ztmm0006, gv_pedido_ok.
    IF gv_entrada IS NOT INITIAL.
      SELECT SINGLE * INTO ls_ztmm0006
        FROM ztmm0006
        WHERE zentrada = gv_entrada.

      IF ls_ztmm0006-ebeln IS NOT INITIAL.
        gv_ebeln = ls_ztmm0006-ebeln.
        gv_pedido_ok = 'X'.
      ENDIF.
    ENDIF.
* GST - 21/05/2015 <-

* GST - 02/03/2015 ->
    IF gv_contabilizado = 'X'.
      LOOP AT SCREEN .
        IF screen-group2 = 'CTB'.
*        screen-invisible = '1'.
*        screen-active = '0'.
          screen-output = '1'.
          screen-input = '0'.
          MODIFY SCREEN.
        ENDIF.
      ENDLOOP.
    ENDIF.
* GST - 02/03/2015 <-

* GST - 21/05/2015 ->
    IF gv_pedido_ok = 'X'.
      LOOP AT SCREEN .
        IF screen-group3 = 'CPO'.
*        screen-invisible = '1'.
*        screen-active = '0'.
          screen-output = '1'.
          screen-input = '0'.
          MODIFY SCREEN.
        ENDIF.
      ENDLOOP.
    ENDIF.
* GST - 21/05/2015 <-
  ENDIF.

  PERFORM cargar_pantalla_1000.

ENDMODULE.                 " STATUS_1000  OUTPUT


*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_1000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_1000 INPUT.

  DATA: lv_answer2 TYPE c.

* GST - 19/05/2015 ->
  DATA: lv_ok         TYPE xflag,
        lv_periodo(7).

  CLEAR: lv_ok, lv_periodo.
* GST - 19/05/2015 <-

  CASE gv_okcode.
*   Para volver
    WHEN 'EXIT'
      OR 'BACK'. " add jtm 07.10.2015
* GST - 03/03/2015 ->
      IF gt_datos_1000[] IS NOT INITIAL AND gv_contabilizado IS INITIAL.
        CLEAR lv_answer2.
        CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
          EXPORTING
            text   = text-011
            title  = text-004
          IMPORTING
            answer = lv_answer2.

        IF lv_answer2 = 'J'.
PERFORM bloquear USING 'D' gv_entrada space CHANGING sw_ok. " add jtm 07.10.2015
          SET SCREEN 0.
          LEAVE SCREEN.
        ENDIF.

      ELSE.
PERFORM bloquear USING 'D' gv_entrada space CHANGING sw_ok.  " add jtm 07.10.2015
        SET SCREEN 0.
        LEAVE SCREEN.

      ENDIF.
* GST - 03/03/2015 <-
*  del jtm 07.10.2015
*    WHEN 'BACK'.
*
** GST - 03/03/2015 ->
*      IF gt_datos_1000[] IS NOT INITIAL AND gv_contabilizado IS INITIAL.
*        CLEAR lv_answer2.
*        CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
*          EXPORTING
*            text   = text-011
*            title  = text-004
*          IMPORTING
*            answer = lv_answer2.
*
*        IF lv_answer2 = 'J'.
*          SET SCREEN 0.
*          LEAVE SCREEN.
*        ENDIF.
*
*      ELSE.
** GST - 03/03/2015 <-
*
*        SET SCREEN 0.
*        LEAVE SCREEN.
** GST - 03/03/2015 ->
*      ENDIF.
** GST - 03/03/2015 <-

*   fin del jtm 07.10.2015
    WHEN 'OK_CODE'.

* GST - 03/03/2015 ->
      IF gv_lifnr IS INITIAL OR gv_xblnr IS INITIAL OR
         gv_matricula1 IS INITIAL OR gv_matricula2 IS INITIAL.
        MESSAGE w055(00) DISPLAY LIKE 'E'.
      ELSE.
* GST - 03/03/2015 <-

* 1.- recuperar numero de registro para entrada de mercancias provisional
        MOVE 'X' TO sw_ok.
        IF gv_entrada IS INITIAL.
          PERFORM recuperar_contador CHANGING gv_entrada.
          PERFORM bloquear USING 'B' gv_entrada space CHANGING sw_ok.
        ENDIF.
*       add 07.10.2015
        IF sw_ok EQ 'X'.
*       fin de add jtm 07.10.2015
          CLEAR: gv_posnr, gs_output_param, gt_messages.
          REFRESH: gt_messages.

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
          CLEAR lv_ok.
          CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
            EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
              i_bukrs = gv_bukrs
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
              i_budat = gv_budat
            IMPORTING
              e_ok    = lv_ok.

          IF lv_ok <> 'X'.
            CLEAR lv_periodo.
            CONCATENATE gv_budat+4(2) gv_budat+0(4)
                        INTO lv_periodo SEPARATED BY '.'.
            MESSAGE i097(zmm) WITH lv_periodo.
          ELSE.
* GST - 19/05/2015 <-

            CALL SCREEN '2000'.
* GST - 19/05/2015 ->
          ENDIF.
* GST - 19/05/2015 <-

* GST - 03/03/2015 ->
        ENDIF.
      ENDIF. " 07.10.2015
* GST - 03/03/2015 <-

  ENDCASE.
  CLEAR gv_okcode.

ENDMODULE.                 " USER_COMMAND_1000  INPUT

*&---------------------------------------------------------------------*
*&      Module  GV_LIFNR  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_lifnr INPUT.

  DATA: lv_contratos TYPE i.
  CLEAR lv_contratos.
  DATA: lv_answer TYPE c.
  DATA: lt_spopli LIKE spopli OCCURS 0,
        ls_spopli TYPE spopli.
  DATA: lv_lifnr TYPE elifn.

  IF NOT gv_lifnr IS INITIAL.

    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_lifnr
      IMPORTING
        output = lv_lifnr.

* RECUPERAMOS EL NOMBRE DEL PROVEEDOR
    CLEAR gv_name1.
    SELECT SINGLE name1 INTO gv_name1
    FROM lfa1
    WHERE lifnr = lv_lifnr.

**************************************************************************************
* SELECCIONAMOS LOS CONTRATOS MARCO PARA UN PROVEEDOR ACTIVOS EN LA FECHA SELECCIONADA
    CLEAR gt_contrato_marco.
    REFRESH: gt_contrato_marco, lt_spopli.
    CLEAR lv_lifnr .
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_lifnr
      IMPORTING
        output = lv_lifnr.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_contrato_marco
    FROM ekko
    INNER JOIN ekpo ON ekpo~ebeln = ekko~ebeln
    WHERE lifnr = lv_lifnr
    AND ( kdatb <= gv_bldat
    AND kdate >= gv_bldat )
    AND ekpo~werks = gv_werks
    AND ekpo~loekz = ''.

    SORT gt_contrato_marco BY ebeln.

    DELETE ADJACENT DUPLICATES FROM gt_contrato_marco COMPARING ebeln.

* MIRAMOS CUANTOS CONTRATOS SE RECUPERAN
    DESCRIBE TABLE gt_contrato_marco LINES lv_contratos.
    IF lv_contratos > 1.
* EN CASO DE SER MAS DE UNO MOSTRAMOS UN POP-UP PARA QUE EL USUARIO SELECCIONE UNO
      LOOP AT gt_contrato_marco INTO gs_contrato_marco.
CONCATENATE gs_contrato_marco-ebeln gs_contrato_marco-kdatb gs_contrato_marco-kdate
INTO ls_spopli-varoption SEPARATED BY '-'.

        APPEND ls_spopli TO lt_spopli.
      ENDLOOP.

      CLEAR lv_answer.
      CALL FUNCTION 'POPUP_TO_DECIDE_LIST'
        EXPORTING
*         CURSORLINE         = 1
*         MARK_FLAG          = ' '
*         MARK_MAX           = 1
*         START_COL          = 0
*         START_ROW          = 0
          textline1          = text-002
*         TEXTLINE2          = ' '
*         TEXTLINE3          = ' '
          titel              = text-001
*         DISPLAY_ONLY       = ' '
        IMPORTING
          answer             = lv_answer
        TABLES
          t_spopli           = lt_spopli
        EXCEPTIONS
          not_enough_answers = 1
          too_much_answers   = 2
          too_much_marks     = 3
          OTHERS             = 4.

      IF lv_answer <> 'A'.
        READ TABLE gt_contrato_marco INTO gs_contrato_marco
        INDEX lv_answer.
      ENDIF.


    ELSEIF lv_contratos = 0.
* SI NO EXISTE NINGUN CONTRATO MARCO MOSTRAMOS UN ERROR
      MESSAGE e022 WITH gv_lifnr.

    ELSEIF lv_contratos = 1.
* EN CASO DE SER SOLO UNO LO SELECCIONAMOS
      READ TABLE gt_contrato_marco INTO gs_contrato_marco
      INDEX 1.
    ENDIF.
  ELSE.
    CLEAR gv_name1.
  ENDIF.

ENDMODULE.                 " GV_LIFNR  INPUT

*&---------------------------------------------------------------------*
*&      Module  STATUS_2000  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_2000 OUTPUT.

  SET PF-STATUS '2000'.
  SET TITLEBAR '2000'.

* Ocultar botones de grabar y contabilizar en caso de estar contabilizado
  IF sy-tcode = 'ZMM0004' AND NOT gv_contabilizado IS INITIAL.
    LOOP AT SCREEN .
      IF screen-group1 = 'SUP'.
        screen-invisible = '1'.
        screen-active = '0'.
        MODIFY SCREEN.
      ENDIF.
* GST - 02/03/2015 ->
      IF screen-group2 = 'CTB' AND screen-group1 <> 'SUP'.
        screen-output = '1'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
* GST - 02/03/2015 <-
    ENDLOOP.
  ENDIF.

* GST - 21/05/2015 ->
  IF sy-tcode = 'ZMM0004' AND gv_pedido_ok = 'X'.
    LOOP AT SCREEN .
      IF screen-group3 = 'CTO'.
        screen-output = '1'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ENDIF.
* GST - 21/05/2015 <-

** QUITAMOS LOS BOTONES DE PESADAS, EL SUPERVISOR SOLO LAS PUEDE MODIFICAR
*  IF sy-tcode = 'ZMM0004'.
*    LOOP AT SCREEN .
*      IF screen-group1 = 'PES'.
*        screen-invisible = '1'.
*        screen-active = '0'.
*        MODIFY SCREEN.
*      ENDIF.
*    ENDLOOP.
*  ENDIF.

  IF g_custom_container IS INITIAL.
*   Creamos los objetos
    CREATE OBJECT g_custom_container
      EXPORTING
        container_name = gc_container.
*    CREATE OBJECT grid
*           EXPORTING i_parent = g_custom_container.
    CREATE OBJECT grid
      EXPORTING
        i_parent      = g_custom_container
        i_appl_events = 'X'.

**   Para los eventos
    CREATE OBJECT g_application.
    SET HANDLER g_application->handle_data_changed FOR grid.
    SET HANDLER g_application->handle_data_changed_finished FOR grid.
    SET HANDLER g_application->handle_toolbar
                g_application->handle_hotspot_click
                g_application->handle_user_command FOR grid.

*   Cuando es editable -> para que escuche los eventos: ENTER...
    CALL METHOD grid->register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=>mc_evt_modified.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos.
*   Mostramos el ALV
    PERFORM mostrar_datos.

  ELSE.
    CALL METHOD grid->refresh_table_display.
  ENDIF.

ENDMODULE.                 " STATUS_2000  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_2000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_2000 INPUT.

  DATA: ls_datos_1000 LIKE LINE OF pesadas.
  DATA: lv_answer5 TYPE c.

** GST - 21/05/2015 ->
*  DATA: ls_ztmm0006 type ztmm0006.
** GST - 21/05/2015 <-

*        lv_answer2    TYPE         c.

* GST - 19/05/2015 ->
  CLEAR: lv_ok, lv_periodo.
* GST - 19/05/2015 <-

  CASE gv_okcode2.
*   Para volver
    WHEN 'EXIT'.
** GST - 03/03/2015 ->
*      IF gt_datos_1000[] IS NOT INITIAL.
*        CLEAR lv_answer2.
*        CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
*          EXPORTING
*            text   = text-011
*            title  = text-004
*          IMPORTING
*            answer = lv_answer2.
*
*        IF lv_answer2 = 'J'.
*          SET SCREEN 0.
*          LEAVE SCREEN.
*        ENDIF.
*      ELSE.
      SET SCREEN 0.
      LEAVE SCREEN.
*      ENDIF.
** GST - 03/03/2015 <-

    WHEN 'BACK'.
** GST - 03/03/2015 ->
*      IF gt_datos_1000[] IS NOT INITIAL.
*        CLEAR lv_answer2.
*        CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
*          EXPORTING
*            text   = text-011
*            title  = text-004
*          IMPORTING
*            answer = lv_answer2.
*
*        IF lv_answer2 = 'J'.
*          SET SCREEN 0.
*          LEAVE SCREEN.
*        ENDIF.
*      ELSE.
      SET SCREEN 0.
      LEAVE SCREEN.
*      ENDIF.
** GST - 03/03/2015 <-

    WHEN 'PPARC'.

* COMPROBAR QUE EXITA UNA PESADA BRUTA
      READ TABLE gt_datos_1000 INTO ls_datos_1000
      WITH KEY ztipo_pesada = 'F'.
      IF sy-subrc <> 0.
        MESSAGE e060 DISPLAY LIKE 'I'.
      ELSE.

*   Recuperar datos a mostrar
        PERFORM recuperar_datos3.
        CLEAR: gv_pesada,
              gv_ntgew_c.

*   Recuperar datos a mostrar
        PERFORM recuperar_datos3.

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
        ELSE.
* GST - 19/05/2015 <-

          CALL SCREEN '3000'.

* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-

      ENDIF.

    WHEN 'PFINAL'.
      CLEAR: gv_pesada,
      gv_brgew.

* COMPROBAR QUE NO EXITA YA UNA PESADA FINAL
      READ TABLE gt_datos_1000 INTO ls_datos_1000
      WITH KEY ztipo_pesada = 'F'.
      IF sy-subrc = 0.
        MESSAGE w050 DISPLAY LIKE 'I'.
      ELSE.
*   Recuperar datos a mostrar
        PERFORM recuperar_datos4.

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
        ELSE.
* GST - 19/05/2015 <-

          CALL SCREEN '4000'.
* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-
      ENDIF.

    WHEN 'BTN_SAVE'.

* Para que antes pase por los eventos del GRID y se puedan grabar los ultimos datos modificados
* EN ESTE CASO LOS PRECIOS QUE HAYA MODIFICADO EL SUPERVISOR
      IF sy-tcode = 'ZMM0004'.
        CALL METHOD grid->check_changed_data.
      ENDIF.

** 1.A.- comprobar que todas las posiciones tengan cantidad
*      PERFORM comprobacion_cantidad.

      IF gt_datos_1000[] IS INITIAL.
        MESSAGE w067.
      ELSE.

* GST - 19/05/2015 ->
* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_bukrs = gv_bukrs
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
        ELSE.
* GST - 19/05/2015 <-

* 2.-A.- guardar cabecera
          PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
          PERFORM guardar_posiciones.

* GST - 30/06/2015 ->
* Imprimir etiquetas al pulsar el botón de grabar:
          IF gt_etiquetas[] IS NOT INITIAL.
            CLEAR lv_answer5.
            CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
              EXPORTING
                text   = text-017
                title  = text-018
              IMPORTING
                answer = lv_answer5.

            IF lv_answer5 = 'J'.
* GST - 08/07/2015 ->
*          PERFORM imprimir_etiquetas.
              PERFORM imprimir_etiquetas_nuevas.
* GST - 08/07/2015 <-
            ENDIF.
* GST - 30/06/2015 <-
          ENDIF.

          MESSAGE s026.

* inicializar variables
          PERFORM inicializar_vbles.

* GST - 19/05/2015 ->
          IF sy-tcode = 'ZMM0004'.
            LEAVE PROGRAM.
          ELSE.
            SET SCREEN 0.
            LEAVE SCREEN.
          ENDIF.
* GST - 19/05/2015 <-

* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-
      ENDIF.

* MOSTRAR LOG DE ACCIONES

* GST - 05/03/2015 ->
*      SET SCREEN 0.
*      LEAVE SCREEN.

** GST - 19/05/2015 ->
*      IF sy-tcode = 'ZMM0004'.
*        LEAVE PROGRAM.
*      ELSE.
*        SET SCREEN 0.
*        LEAVE SCREEN.
*      ENDIF.
** GST - 19/05/2015 <-

* GST - 05/03/2015 <-

    WHEN 'BTN_CONT'.

* Para que antes pase por los eventos del GRID y se puedan grabar los ultimos datos modificados
* EN ESTE CASO LOS PRECIOS QUE HAYA MODIFICADO EL SUPERVISOR
      IF sy-tcode = 'ZMM0004'.
        CALL METHOD grid->check_changed_data.
      ENDIF.

** 1.- comprobar que todas las posiciones tengan cantidad
*      PERFORM comprobacion_cantidad.

      IF gt_datos_1000[] IS INITIAL.
        MESSAGE w067.
      ELSE.

* GST - 19/05/2015 ->
* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_bukrs = gv_bukrs
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
*          IF sy-tcode = 'ZMM0004'.
*            LEAVE PROGRAM.
*          ELSE.
*            SET SCREEN 0.
*            LEAVE SCREEN.
*          ENDIF.
        ELSE.
* GST - 19/05/2015 <-

* 2.-A.- guardar cabecera
          PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
          PERFORM guardar_posiciones.

* GST - 21/05/2015 ->
          IF gv_entrada IS NOT INITIAL.
            CLEAR ls_ztmm0006.
            SELECT SINGLE * INTO ls_ztmm0006
              FROM ztmm0006
              WHERE zentrada = gv_entrada.
          ENDIF.
* GST - 21/05/2015 <-

* 3.- CREAR PEDIDO DE COMPRAS
* GST - 21/05/2015 ->
          IF ls_ztmm0006-zcontabilizado <> 'X' AND
              ls_ztmm0006-ebeln IS INITIAL.
            PERFORM crear_pedido_compras.
          ELSE.
            gv_ebeln = ls_ztmm0006-ebeln.
          ENDIF.
*      PERFORM crear_pedido_compras.
* GST - 21/05/2015 <-

* 4.- HACER ENTRADA DE MERCANCIAS
* GST - 21/05/2015 ->
*          IF NOT gv_ebeln IS INITIAL.
          IF ls_ztmm0006-zcontabilizado <> 'X' AND
            gv_ebeln IS NOT INITIAL.
* GST - 21/05/2015 <-
            PERFORM crear_entrada_mercancias.
          ENDIF.


* inicializar variables
          PERFORM inicializar_vbles.

* MOSTRAR LOG DE ACCIONES
          PERFORM mostrar_log.

* GST - 05/03/2015 ->
*        SET SCREEN 0.
*        LEAVE SCREEN.
          IF sy-tcode = 'ZMM0004'.
            LEAVE PROGRAM.
          ELSE.
            SET SCREEN 0.
            LEAVE SCREEN.
          ENDIF.
* GST - 05/03/2015 <-

* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-

      ENDIF.


  ENDCASE.
  CLEAR gv_okcode2.

ENDMODULE.                 " USER_COMMAND_2000  INPUT

*&---------------------------------------------------------------------*
*&      Module  STATUS_3000  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_3000 OUTPUT.

  SET PF-STATUS '3000'.
  SET TITLEBAR '3000'.


* en caso de modificar pesada se dejan los campos en visualizacion
  IF gv_okcode2 = 'BT_MODIF'.

    LOOP AT SCREEN.
      IF screen-name = 'GV_PESADA'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

  ENDIF.

  IF g_custom_container3 IS INITIAL.
*   Creamos los objetos
    CREATE OBJECT g_custom_container3
      EXPORTING
        container_name = gc_container3.
*    CREATE OBJECT grid
*           EXPORTING i_parent = g_custom_container.
    CREATE OBJECT grid3
      EXPORTING
        i_parent      = g_custom_container3
        i_appl_events = 'X'.

**   Para los eventos
    CREATE OBJECT g_application3.
    SET HANDLER g_application3->handle_data_changed FOR grid3.
    SET HANDLER g_application3->handle_data_changed_finished FOR grid3.
    SET HANDLER g_application3->handle_toolbar
                g_application3->handle_hotspot_click
                g_application3->handle_user_command FOR grid3.

*   Cuando es editable -> para que escuche los eventos: ENTER...
    CALL METHOD grid3->register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=>mc_evt_modified.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos3.
*   Mostramos el ALV
    PERFORM mostrar_datos3.

  ELSE.

** BORRAMOS LA TABLA DEL CONTRATO MARCO AL ACCEDER A LA DYNPRO POR PESADA PARCIAL NUEVA
*    IF gv_okcode2 = 'PPARC' AND gv_okcode3 IS INITIAL.
**      CLEAR gt_pparcial.
**      REFRESH gt_pparcial.
**   Recuperar datos a mostrar
*    PERFORM recuperar_datos3.
*    ENDIF.

**NOS GUARDAMOS LA POSICION DEL CURSO
    CALL METHOD grid3->get_current_cell
      IMPORTING
        es_row_id = gs_celda-row_id
        es_col_id = gs_celda-column_id
        es_row_no = gs_celda-row_no.

    CALL METHOD grid3->refresh_table_display.


**SITUAMOS EL CURSOR
    CALL METHOD grid3->set_current_cell_via_id
      EXPORTING
        is_row_id    = gs_celda-row_id
        is_column_id = gs_celda-column_id
        is_row_no    = gs_celda-row_no.

  ENDIF.

ENDMODULE.                 " STATUS_3000  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_3000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_3000 INPUT.

  DATA: lv_ctd       TYPE i,
        lv_ex_datos2 TYPE xflag.

  CASE gv_okcode3.
*   Para volver
    WHEN 'EXIT'.
      SET SCREEN 0.
      LEAVE SCREEN.
* GST - 03/03/2015 ->
      CLEAR: lti_mod_cells_3000.
      REFRESH: lti_mod_cells_3000.
* GST - 03/03/2015 <-


    WHEN 'BACK'.
      SET SCREEN 0.
      LEAVE SCREEN.
* GST - 03/03/2015 ->
      CLEAR: lti_mod_cells_3000.
      REFRESH: lti_mod_cells_3000.
* GST - 03/03/2015 <-


    WHEN 'REG_PES'.

* Para que antes pase por los eventos del GRID y se puedan grabar los ultimos datos modificados
      CALL METHOD grid3->check_changed_data
*  IMPORTING
*    e_valid   =
*  CHANGING
*    c_refresh = 'X'
        .

* GST - 05/03/2015 ->
* REVISIÓN DATOS A REGISTRAR NO NULOS:
      CLEAR lv_ex_datos2.
     LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk  IS INITIAL.
        lv_ex_datos2 = 'X'.
        EXIT.
      ENDLOOP.
      IF lv_ex_datos2 <> 'X'.
        CLEAR gv_okcode3.
        CLEAR lv_ex_datos2.
        MESSAGE i086(zmm).
        EXIT.
      ELSE.
* GST - 05/03/2015 <-

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
        ELSE.

* GST - 19/05/2015 <-

* REVISAR QUE ESTEN LOS ALMACENES RELLENOS
          PERFORM revisar_almacen USING gv_okcode3.

          CLEAR lv_answer.
          CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
            EXPORTING
* GST - 03/03/2015 ->
*             text   = text-003
              text   = text-014
* GST - 03/03/2015 <-
              title  = text-004
            IMPORTING
              answer = lv_answer.

          IF lv_answer = 'J'.

* GST - 03/03/2015 ->
* CALCULAMOS EL REPARTO DE PESO
            PERFORM traspasar_datos USING gv_okcode3.
* GST - 03/03/2015 <-

* CREAMOS LOTES
            PERFORM crear_lotes USING gv_okcode3
                                      lv_ctd
                                      lv_ctd.

** GST - 03/03/2015 ->
** CALCULAMOS EL REPARTO DE PESO
*        PERFORM traspasar_datos USING gv_okcode3.
** GST - 03/03/2015 <-


* Añadir posiciones y repartir pesos
            IF NOT gv_ntgew IS INITIAL.
              PERFORM repartir_peso_camion_nueva_cal.
            ENDIF.

* GST - 19/05/2015 ->
* Si no hay errores, al imprimir las etiquetas, se hacen las entradas en tabla:
* 2.-A.- guardar cabecera
            PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
            PERFORM guardar_posiciones.

* GST - 19/05/2015 <-

            SET SCREEN 0.
            LEAVE SCREEN.

* GST - 03/03/2015 ->
            CLEAR: lti_mod_cells_3000.
            REFRESH: lti_mod_cells_3000.
* GST - 03/03/2015 <-

          ENDIF.

* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-

* GST - 05/03/2015 ->
      ENDIF.
* GST - 05/03/2015 <-

  ENDCASE.
  CLEAR gv_okcode3.

ENDMODULE.                 " USER_COMMAND_3000  INPUT

*&---------------------------------------------------------------------*
*&      Module  GV_BVVREL  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_bvvrel INPUT.
  DATA: lv_index LIKE sy-tabix.
  DATA: lv_tot_peso_fijado TYPE ktmng.


IF NOT gv_bvvrel IS INITIAL AND NOT gt_datos_1000[] IS INITIAL AND gv_ntgew > 0.
*    IF gv_ntgew > 0.
    IF gv_bvvrel <= 100 OR gv_bvvrel >= 0.
      CLEAR lv_index.
LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL AND zpeso_fijado IS INITIAL.
        lv_index = sy-tabix.
        gs_datos_1000-menge = ( gs_datos_1000-ktmng * gv_bvvrel ) / 100.
        gs_datos_1000-menge = gs_datos_1000-ktmng - gs_datos_1000-menge.
        MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
      ENDLOOP.
    ELSE.

    ENDIF.
*    ENDIF.
  ELSE.
    IF gv_bvvrel > 100 OR gv_bvvrel < 0.
      MESSAGE e048.
    ENDIF.
  ENDIF.

ENDMODULE.                 " GV_BVVREL  INPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_4000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_4000 INPUT.
*  DATA: lv_ctd TYPE i.

  DATA: lv_ex_datos TYPE xflag.

  CASE gv_okcode4.
*   Para volver
    WHEN 'EXIT'.
      SET SCREEN 0.
      LEAVE SCREEN.
* GST - 03/03/2015 ->
      CLEAR: lti_mod_cells_4000.
      REFRESH: lti_mod_cells_4000.
* GST - 03/03/2015 <-

    WHEN 'BACK'.
      SET SCREEN 0.
      LEAVE SCREEN.
* GST - 03/03/2015 ->
      CLEAR: lti_mod_cells_4000.
      REFRESH: lti_mod_cells_4000.
* GST - 03/03/2015 <-

    WHEN 'BTN_PESF'.

      CALL METHOD grid4->check_changed_data
*  IMPORTING
*    e_valid   =
*  CHANGING
*    c_refresh = 'X'
        .

* GST - 05/03/2015 ->
* REVISIÓN DATOS A REGISTRAR NO NULOS:
      CLEAR lv_ex_datos.
      LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk  IS INITIAL.
        lv_ex_datos = 'X'.
        EXIT.
      ENDLOOP.
      IF lv_ex_datos <> 'X'.
        CLEAR gv_okcode4.
        CLEAR lv_ex_datos.
        MESSAGE i086(zmm).
        EXIT.
      ELSE.
* GST - 05/03/2015 <-

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
        CLEAR: lv_ok, lv_periodo.
        CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
          EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            i_budat = gv_budat
          IMPORTING
            e_ok    = lv_ok.

        IF lv_ok <> 'X'.
          CLEAR lv_periodo.
          CONCATENATE gv_budat+4(2) gv_budat+0(4)
                      INTO lv_periodo SEPARATED BY '.'.
          MESSAGE i097(zmm) WITH lv_periodo.
        ELSE.
* GST - 19/05/2015 <-

* REVISAR QUE ESTEN LOS ALMACENES RELLENOS
          PERFORM revisar_almacen USING gv_okcode4.

          CLEAR lv_answer.
          CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
            EXPORTING
              text   = text-007
              title  = text-004
            IMPORTING
              answer = lv_answer.

          IF lv_answer = 'J'.
* CALCULAMOS EL REPARTO DE PESO
            PERFORM traspasar_datos USING gv_okcode4.


* CREAMOS LOTES
            PERFORM crear_lotes USING gv_okcode4
                                      lv_ctd
                                      lv_ctd.

* Popup para solicitar el peso del camion vacio
            PERFORM peso_camion.

* GST - 19/05/2015 ->
* Si no hay errores, al imprimir las etiquetas, se hacen las entradas en tabla:
* 2.-A.- guardar cabecera
            PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
            PERFORM guardar_posiciones.

* GST - 19/05/2015 <-

            SET SCREEN 0.
            LEAVE SCREEN.

* GST - 03/03/2015 ->
            CLEAR: lti_mod_cells_4000.
            REFRESH: lti_mod_cells_4000.
* GST - 03/03/2015 <-

          ENDIF.

* GST - 19/05/2015 ->
        ENDIF.
* GST - 19/05/2015 <-

* GST - 05/03/2015 ->
      ENDIF.
* GST - 05/03/2015 <-


  ENDCASE.
  CLEAR gv_okcode4.


ENDMODULE.                 " USER_COMMAND_4000  INPUT

*&---------------------------------------------------------------------*
*&      Module  STATUS_4000  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_4000 OUTPUT.

  SET PF-STATUS '4000'.
  SET TITLEBAR '4000'.

* en caso de modificar pesada se dejan los campos en visualizacion
  IF gv_okcode2 = 'BT_MODIF'.
    LOOP AT SCREEN.
      IF screen-name = 'GV_PESADA'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF g_custom_container4 IS INITIAL.
*   Creamos los objetos
    CREATE OBJECT g_custom_container4
      EXPORTING
        container_name = gc_container4.
*    CREATE OBJECT grid
*           EXPORTING i_parent = g_custom_container.
    CREATE OBJECT grid4
      EXPORTING
        i_parent      = g_custom_container4
        i_appl_events = 'X'.

**   Para los eventos
    CREATE OBJECT g_application4.
    SET HANDLER g_application4->handle_data_changed FOR grid4.
    SET HANDLER g_application4->handle_data_changed_finished FOR grid4.
    SET HANDLER g_application4->handle_toolbar
                g_application4->handle_hotspot_click
                g_application4->handle_user_command FOR grid4.

*   Cuando es editable -> para que escuche los eventos: ENTER...
    CALL METHOD grid4->register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=>mc_evt_modified.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos4.
*   Mostramos el ALV
    PERFORM mostrar_datos4.

  ELSE.

** BORRAMOS LA TABLA DEL CONTRATO MARCO AL ACCEDER A LA DYNPRO POR PESADA PARCIAL NUEVA
*    IF gv_okcode2 = 'PPARC' AND gv_okcode3 IS INITIAL.
**      CLEAR gt_pparcial.
**      REFRESH gt_pparcial.
**   Recuperar datos a mostrar
*    PERFORM recuperar_datos3.
*    ENDIF.

**NOS GUARDAMOS LA POSICION DEL CURSO
    CALL METHOD grid4->get_current_cell
      IMPORTING
        es_row_id = gs_celda-row_id
        es_col_id = gs_celda-column_id
        es_row_no = gs_celda-row_no.

    CALL METHOD grid4->refresh_table_display.


**SITUAMOS EL CURSOR
    CALL METHOD grid4->set_current_cell_via_id
      EXPORTING
        is_row_id    = gs_celda-row_id
        is_column_id = gs_celda-column_id
        is_row_no    = gs_celda-row_no.

  ENDIF.

ENDMODULE.                 " STATUS_4000  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  GV_NTGEW  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_ntgew INPUT.

** 1.B.- COMPROBAR  QUE LA TARA SEA MENOR QUE EL PESO BRUTO
  IF gv_okcode2 = 'BTN_SAVE' OR gv_okcode2 = 'BTN_CONT'.

    IF gv_ntgew >= gv_brgew.
      MESSAGE e079.
    ELSE.

      PERFORM repartir_peso_camion_nueva_cal.
    ENDIF.
  ELSE.
    PERFORM repartir_peso_camion_nueva_cal.
  ENDIF.

ENDMODULE.                 " GV_NTGEW  INPUT

*&---------------------------------------------------------------------*
*&      Module  GV_TRANSP  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_transp INPUT.
  DATA: ls_a903 TYPE a903.
  DATA: lv_prov TYPE lifnr.

* PRIMERO SE TIENE QUE RELLENAR EL PROVEEDOR Y DESPUES EL TRANSPORTISTA
* PORQUE DEPENDE LA TARIFA DEL PROVEEDOR
  IF NOT gv_lifnr IS INITIAL.

    IF gv_transp IS INITIAL.
      CLEAR: gv_kbetr, gv_konwa, gv_kmein, gv_kpein, gv_name1_trans.
    ENDIF.

    IF NOT gv_transp IS INITIAL AND gv_kbetr IS INITIAL.

      CLEAR lv_lifnr.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = gv_transp
        IMPORTING
          output = lv_lifnr.

      CLEAR gv_name1_trans.
      SELECT SINGLE name1 INTO gv_name1_trans
      FROM lfa1
      WHERE lifnr = lv_lifnr.
      IF sy-subrc <> 0.
        CLEAR gv_name1_trans.
      ENDIF.

      CLEAR lv_prov.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = gv_lifnr
        IMPORTING
          output = lv_prov.

      CLEAR ls_a903.
      SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a903
      FROM a903
*    INNER JOIN lfa1 ON lfa1~lifnr = a903~llief
*                    AND lfa1~llief = a903~llief
      WHERE a903~kschl = 'ZTTR'
      AND a903~lifnr = lv_lifnr
      AND datab <= sy-datum
      AND datbi >= sy-datum
*      AND a903~lifnr = lv_lifnr
        AND llief = lv_prov.
      IF sy-subrc = 0.
SELECT SINGLE kbetr konwa kmein kpein INTO (gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
FROM konp
WHERE knumh = ls_a903-knumh.
      ENDIF.

    ENDIF.

  ELSE.
CLEAR: gv_transp, gv_kbetr, gv_konwa, gv_kmein, gv_kpein, gv_name1_trans.
    MESSAGE i087.
  ENDIF.

ENDMODULE.                 " GV_TRANSP  INPUT

*&---------------------------------------------------------------------*
*&      Module  GV_PESADA  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_pesada INPUT.

*  DATA ls_datos_1000 LIKE LINE OF pesadas.
  IF gv_okcode2 <> 'BT_MODIF'.

*    CLEAR ls_datos_1000.
*    READ TABLE gt_datos_1000 INTO ls_datos_1000
*    WITH KEY znum_pesada = gv_pesada.
*    IF sy-subrc = 0.
*      MESSAGE e049 WITH gv_pesada.
*    ENDIF.

  ENDIF.

ENDMODULE.                 " GV_PESADA  INPUT

*&---------------------------------------------------------------------*
*&      Module  EXIT_3000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE exit_3000 INPUT.

  DATA: lv_answer4 TYPE c.
* GST - 03/03/2015 ->
  CALL METHOD grid3->check_changed_data.
  IF lti_mod_cells_3000[] IS NOT INITIAL.

    CLEAR: gv_okcode3.
    CLEAR lv_answer4.
    CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
      EXPORTING
        text   = text-013
        title  = text-004
      IMPORTING
        answer = lv_answer4.

    IF lv_answer4 = 'J'.
      CLEAR: lti_mod_cells_3000.
      REFRESH: lti_mod_cells_3000.
      SET SCREEN 0.
      LEAVE SCREEN.
    ENDIF.
  ELSE.
    CLEAR: gv_okcode3.
* GST - 03/03/2015 <-

    SET SCREEN 0.
    LEAVE SCREEN.

* GST - 03/03/2015 ->
  ENDIF.
* GST - 03/03/2015 <-


ENDMODULE.                 " EXIT_3000  INPUT

*&---------------------------------------------------------------------*
*&      Module  EXIT_4000  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE exit_4000 INPUT.

  DATA: lv_answer3 TYPE c.
* GST - 03/03/2015 ->
  CALL METHOD grid4->check_changed_data.
  IF lti_mod_cells_4000[] IS NOT INITIAL.
    CLEAR: gv_okcode4, gv_bck_modif.
    CLEAR lv_answer3.
    CALL FUNCTION 'SWO_POPUP_TO_CONFIRM'
      EXPORTING
        text   = text-012
        title  = text-004
      IMPORTING
        answer = lv_answer3.

    IF lv_answer3 = 'J'.
      CLEAR: lti_mod_cells_4000.
      REFRESH: lti_mod_cells_4000.
      SET SCREEN 0.
      LEAVE SCREEN.
    ENDIF.
  ELSE.
    CLEAR: gv_okcode4, gv_bck_modif.
* GST - 03/03/2015 <-

    SET SCREEN 0.
    LEAVE SCREEN.

* GST - 03/03/2015 ->
  ENDIF.
* GST - 03/03/2015 <-

ENDMODULE.                 " EXIT_4000  INPUT

*&---------------------------------------------------------------------*
*&      Module  STATUS_0500  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0500 OUTPUT.

  SET PF-STATUS '0500'.
  SET TITLEBAR '0500'.

  CALL SELECTION-SCREEN 0501 STARTING AT 5 5.

ENDMODULE.                 " STATUS_0500  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  STATUS_0600  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0600 OUTPUT.

  SET PF-STATUS '0600'.
  SET TITLEBAR '0600'.

** GST - 02/03/2015 ->
*  CALL SELECTION-SCREEN 0501 STARTING AT 5 5.
** GST - 02/03/2015 <-

  IF g_custom_container6 IS INITIAL.

*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*   Obtener el centro y el nombre de este del usuario actual
    SELECT SINGLE u~parva t~name1 FROM usr05 AS u
    INNER JOIN t001w AS t ON t~werks = u~parva
    INTO (gv_werks, gv_name1_werks)
    WHERE bname = sy-uname AND
    parid = 'WRK'.

    gv_bukrs = gv_werks. " Asignamos la misma sociedad que el centro
*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--

* GST - 02/03/2015 ->
    CALL SELECTION-SCREEN 0501 STARTING AT 5 5.
* GST - 02/03/2015 <-

*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*   Asignamos el centro elegido por parámetro a las variables globales
    gv_werks = p_werks.
    gv_bukrs = p_werks.
*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--

*   Creamos los objetos
    CREATE OBJECT g_custom_container6
      EXPORTING
        container_name = gc_container6.
*    CREATE OBJECT grid
*           EXPORTING i_parent = g_custom_container.
    CREATE OBJECT grid6
      EXPORTING
        i_parent      = g_custom_container6
        i_appl_events = 'X'.

**   Para los eventos
    CREATE OBJECT g_application6.
    SET HANDLER g_application6->handle_data_changed FOR grid6.
    SET HANDLER g_application6->handle_data_changed_finished FOR grid6.
    SET HANDLER g_application6->handle_toolbar
                g_application6->handle_hotspot_click
                g_application6->handle_user_command FOR grid6.

*   Cuando es editable -> para que escuche los eventos: ENTER...
    CALL METHOD grid6->register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=>mc_evt_modified.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos6.
*   Mostramos el ALV
    PERFORM mostrar_datos6.

  ELSE.

**NOS GUARDAMOS LA POSICION DEL CURSO
    CALL METHOD grid6->get_current_cell
      IMPORTING
        es_row_id = gs_celda-row_id
        es_col_id = gs_celda-column_id
        es_row_no = gs_celda-row_no.

    CALL METHOD grid6->refresh_table_display.


**SITUAMOS EL CURSOR
    CALL METHOD grid6->set_current_cell_via_id
      EXPORTING
        is_row_id    = gs_celda-row_id
        is_column_id = gs_celda-column_id
        is_row_no    = gs_celda-row_no.

  ENDIF.

ENDMODULE.                 " STATUS_0600  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0600  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0600 INPUT.

  CASE gv_okcode600.
*   Para volver
    WHEN 'EXIT'.
      SET SCREEN 0.
      LEAVE SCREEN.

    WHEN 'BACK'.
      SET SCREEN 0.
      LEAVE SCREEN.

  ENDCASE.
  CLEAR gv_okcode600.

ENDMODULE.                 " USER_COMMAND_0600  INPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0500  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0500 INPUT.

  CASE gv_okcode500.
*   Para volver
    WHEN 'EXIT'.
      SET SCREEN 0.
      LEAVE SCREEN.

    WHEN 'BACK'.
      SET SCREEN 0.
      LEAVE SCREEN.

  ENDCASE.
  CLEAR gv_okcode500.

ENDMODULE.                 " USER_COMMAND_0500  INPUT
*&---------------------------------------------------------------------*
*&      Module  GV_ZNUM_PESADA  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE gv_znum_pesada INPUT.

  IF gv_okcode2 = 'BTN_SAVE' OR gv_okcode2 = 'BTN_CONT'.
    CLEAR gs_datos_1000.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY ztipo_pesada = 'F'.
    IF sy-subrc = 0 AND gv_znum_pesada IS INITIAL.
      MESSAGE e069.
    ENDIF.

* GST - 02/03/2015 ->
    IF gv_znum_pesada IS NOT INITIAL.
      LOOP AT gt_datos_1000 INTO gs_datos_1000.
        lv_index = sy-tabix.
        gs_datos_1000-znum_pesada = gv_znum_pesada.
        MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
      ENDLOOP.

    ENDIF.
* GST - 02/03/2015 <-

  ENDIF.

ENDMODULE.                 " GV_ZNUM_PESADA  INPUT
