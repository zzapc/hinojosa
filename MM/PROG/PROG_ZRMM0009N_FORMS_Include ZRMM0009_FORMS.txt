*&---------------------------------------------------------------------*
*&  Include           ZRMM0009_FORMS
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos .

  DATA: ls_datos  TYPE zstmm_bob_calidad_n,
*        lv_werks  TYPE werks_d,
        lv_flag   TYPE xflag,
        lv_name   TYPE name1_gp,
        lv_kunnr  TYPE kunnr,
        lv_merknr TYPE merknr.

  DATA: lv_company_user TYPE uscomp,
        lv_company_vble TYPE uscomp.

  DATA: BEGIN OF lt_datos_aux OCCURS 0.
          INCLUDE STRUCTURE zstmm_bob_calidad_n.
        DATA: END OF lt_datos_aux.

* GST - 23/04/2015 ->
  DATA: rg_values TYPE RANGE OF cawn-atwrt,
        ls_values LIKE LINE OF  rg_values,
        ls_vcode  LIKE LINE OF  so_vcode.
* GST - 23/04/2015 <-

* GST - 05/08/2015 ->
  DATA: lv_rollo TYPE xflag,
        lv_mtart TYPE mtart.
* GST - 05/08/2015 <-

* SAT: 7000014633 - 19/04/2017
  DATA: lt_item_in     TYPE TABLE OF bapiitemin,
        lt_partner     TYPE TABLE OF bapipartnr,
        lt_bapicond_ex TYPE TABLE OF bapicond,
        ls_header      TYPE          bapisdhead,
        ls_item_in     TYPE          bapiitemin,
        ls_partner     TYPE          bapipartnr,
        ls_bapicond_ex TYPE          bapicond,
        ls_return      TYPE          bapireturn.
* SAT: 7000014633 - 19/04/2017

  DATA: l_hora_ko TYPE flag.

  CLEAR: gt_datos, lt_datos_aux, ls_datos, gt_datos_aux[].
  REFRESH: gt_datos, lt_datos_aux.

* Recuperamos datos de tablas MCHB y MARA:

****   Camp eliminat---> "Eliminar lineas en blanco"
***  IF p_stock = 'X'.
***    SELECT b~mtart a~matnr b~matkl b~zzcalidad b~zzgramaje b~zzancho
***           b~zzlargo a~werks a~lgort a~charg b~meins
***           a~clabs a~cumlm a~cinsm a~ceinm a~cspem a~cretm
***           a~cvmla a~cvmum a~cvmin a~cvmei a~cvmsp a~cvmre
***      INTO CORRESPONDING FIELDS OF TABLE gt_datos_aux "lt_datos_aux
***      FROM mchb AS a
***      INNER JOIN mara AS b ON b~matnr = a~matnr
***      WHERE a~matnr IN so_matnr
***      AND a~werks IN so_werks
***      AND a~lgort IN so_lgort
***      AND a~charg IN so_charg
****      AND b~mtart IN so_mtart
***      AND b~matkl IN so_matkl
****      AND b~zzcalidad IN so_zzcal
****      AND b~zzgramaje IN so_zzgra
****      AND b~zzancho IN so_zzanc
***      AND ( a~clabs <> 0 OR a~cumlm <> 0 OR a~cinsm <> 0
***            OR a~ceinm <> 0 OR a~cspem <> 0 OR a~cretm <> 0
***            OR a~cretm <> 0 OR a~cvmum <> 0 OR a~cvmin <> 0
***            OR a~cvmei <> 0 OR a~cvmsp <> 0 OR a~cvmre <> 0 )
***      AND a~ersda BETWEEN g_data_ini AND g_data_fin.

***  ELSE.

  CASE 'X'.
    WHEN pr_stock.  "SELECCION POR STOCK (MCHB)
      SELECT b~mtart a~matnr b~matkl b~zzcalidad b~zzgramaje b~zzancho
             b~zzlargo a~werks a~lgort a~charg b~meins
             a~clabs a~cumlm a~cinsm a~ceinm a~cspem a~cretm
             a~cvmla a~cvmum a~cvmin a~cvmei a~cvmsp a~cvmre
         INTO CORRESPONDING FIELDS OF TABLE gt_datos_aux "lt_datos_aux
         FROM mchb AS a
         INNER JOIN mara AS b ON b~matnr = a~matnr
         WHERE a~matnr IN so_matnr
*         AND a~werks IN so_werks
         AND a~werks = p_werks
         AND a~lgort IN so_lgort
         AND a~charg IN so_charg
         AND b~matkl IN so_matkl
         AND b~mtart = 'ZPAP'
         AND ( a~clabs <> 0 OR a~cumlm <> 0 OR a~cinsm <> 0
            OR a~ceinm <> 0 OR a~cspem <> 0 OR a~cretm <> 0
            OR a~cretm <> 0 OR a~cvmum <> 0 OR a~cvmin <> 0
            OR a~cvmei <> 0 OR a~cvmsp <> 0 OR a~cvmre <> 0 ).
*         AND a~ersda BETWEEN g_data_ini AND g_data_fin.

    WHEN pr_fabri. " OR pr_froll.  " SELECCION POR FECHA DE FABRICACION (MSEG)

      IF so_charg IS NOT INITIAL AND so_hsdat IS INITIAL .
        SELECT sg~werks , sg~lgort , sg~matnr , sg~charg ,  sg~budat_mkpf , sg~cputm_mkpf , sg~erfmg  AS clabs ,
               ma~mtart , ma~matkl , ma~zzcalidad , ma~zzgramaje , ma~zzancho ,
               ma~zzlargo , ma~meins
          FROM mseg AS sg
           INNER JOIN mara AS ma ON sg~matnr = ma~matnr
*        APPENDING TABLE @gt_datos_mseg_101
           INTO CORRESPONDING FIELDS OF TABLE @gt_datos_aux "lt_datos_aux

          WHERE sg~matnr IN @so_matnr
*          AND sg~werks IN @so_werks
            AND sg~werks =  @p_werks
            AND sg~charg IN @so_charg
            AND sg~lgort IN @so_lgort
            AND sg~kunnr IN @so_kunnr
            AND bwart = '101'
            AND sg~charg <> ' '
            AND ma~mtart = 'ZPAP'
            AND sg~menge <> 0
            ORDER BY sg~budat_mkpf , sg~cputm_mkpf.

      ELSE.


        SELECT sg~werks , sg~lgort , sg~matnr , sg~charg ,  sg~budat_mkpf , sg~cputm_mkpf , sg~erfmg  AS clabs ,
               ma~mtart , ma~matkl , ma~zzcalidad , ma~zzgramaje , ma~zzancho ,
               ma~zzlargo , ma~meins
          FROM mseg AS sg
           INNER JOIN mara AS ma ON sg~matnr = ma~matnr
*        APPENDING TABLE @gt_datos_mseg_101
           INTO CORRESPONDING FIELDS OF TABLE @gt_datos_aux "lt_datos_aux

          WHERE sg~matnr IN @so_matnr
*          AND sg~werks IN @so_werks
            AND sg~werks =  @p_werks
            AND sg~charg IN @so_charg
            AND sg~lgort IN @so_lgort
            AND sg~kunnr IN @so_kunnr
            AND budat_mkpf BETWEEN @g_data_ini AND @g_data_fin
            AND bwart = '101'
            AND sg~charg <> ' '
            AND ma~mtart = 'ZPAP'
            AND sg~menge <> 0
            ORDER BY sg~budat_mkpf , sg~cputm_mkpf.
      ENDIF.

    WHEN pr_froll.  " SELECCION POR FECHA DE FABRICACION DE ROLLO

      SELECT sg~werks , sg~lgort , sg~matnr , sg~charg ,  sg~budat_mkpf , sg~cputm_mkpf , sg~erfmg  AS clabs ,
             ma~mtart , ma~matkl , ma~zzcalidad , ma~zzgramaje , ma~zzancho ,
             ma~zzlargo , ma~meins
        FROM mseg AS sg
         INNER JOIN mara AS ma ON sg~matnr = ma~matnr
         INTO CORRESPONDING FIELDS OF TABLE @gt_datos_aux
        WHERE sg~matnr IN @so_matnr
          AND sg~werks =  @p_werks
          AND sg~charg IN @so_charg
          AND sg~lgort IN @so_lgort
          AND sg~kunnr IN @so_kunnr
          AND bwart = '101'
          AND sg~charg <> ' '
          AND ma~mtart = 'ZPAP'
          AND sg~menge <> 0
          ORDER BY sg~budat_mkpf , sg~cputm_mkpf.

    WHEN OTHERS.
  ENDCASE.

  CLEAR: ls_values, rg_values, ls_vcode.
  REFRESH: rg_values.

  LOOP AT so_vcode INTO ls_vcode.
    CLEAR ls_values.
    ls_values-sign = ls_vcode-sign.
    ls_values-option = ls_vcode-option.
    IF ls_vcode-low IS NOT INITIAL.
      CONCATENATE 'DE' ls_vcode-low INTO ls_values-low
                  SEPARATED BY space.
    ENDIF.
    IF ls_vcode-high IS NOT INITIAL.
      CONCATENATE 'DE' ls_vcode-high INTO ls_values-high
                  SEPARATED BY space.
    ENDIF.
    APPEND ls_values TO rg_values.
  ENDLOOP.

* Trasladamos la obtención de la compañia por usuario fuera del bucle!!!, el usuario es siempre el mismo.......
  CLEAR: lv_company_user, lv_company_vble.

  lv_company_vble = text-004.

  SELECT SINGLE company INTO lv_company_user
  FROM user_addr
  WHERE bname = sy-uname.


*  LOOP AT lt_datos_aux INTO ls_datos.
  LOOP AT gt_datos_aux INTO ls_datos.

* Chequeo de cliente:
    PERFORM recuperar_cliente USING ls_datos-matnr
                                    ls_datos-charg
                              CHANGING ls_datos-kunnr
                                       ls_datos-vcode
                                       ls_datos-hsdat
                                       ls_datos-zcontramaestre
                                       ls_datos-zoperario
                                       .

    " Turno:
    PERFORM recup_turno USING ls_datos
                    CHANGING ls_datos-turno
                             l_hora_ko
                             ls_datos-hsdat.

    " si se informa lote, tipo seleccion por fecha prod, pero no se informa, y si se informa lote, registro válido.
    CHECK l_hora_ko IS INITIAL OR ( so_hsdat IS INITIAL AND so_charg IS NOT INITIAL ).


    CHECK ls_datos-vcode IN rg_values.

    CHECK ls_datos-kunnr IN so_kunnr.
    "AND ls_stock-kunnr IS NOT INITIAL.

*    CLEAR lv_werks.
*    IF ls_datos-kunnr IS NOT INITIAL.
*      SELECT  werks INTO lv_werks UP TO 1 ROWS
*        FROM t001w
*        WHERE kunnr = ls_datos-kunnr.
*      ENDSELECT.
*    ENDIF.

*EBELLVER solicita que se salte la autorización para los usuarios que en
*la tabla USER_ADDR
* el campo COMPANY tenga 'PAPELERA L'ALQUERIA'

* INI CMS
*    CLEAR: lv_company_user, lv_company_vble.
*
*    lv_company_vble = text-004.
*
*
*    SELECT SINGLE company INTO lv_company_user
*    FROM user_addr
*    WHERE bname = sy-uname.
* FIN CMS
    IF lv_company_user <> lv_company_vble.

*---> SAT 7*12702 el usuario tiene que mostrar los datos del centro
*     que le estamos indicando por la pantalla de seleccion aunque
*     lv_werks <> so_werks.

*      IF lv_werks IS NOT INITIAL.
      AUTHORITY-CHECK OBJECT 'M_MATE_WRK'
                  ID 'ACTVT' FIELD '03'
                  ID 'WERKS' FIELD p_werks.
      "lv_werks
*          CHECK sy-subrc = 0.
*      ELSE.
      IF ls_datos-kunnr IS INITIAL.
        CONTINUE.
      ENDIF.
*<---
    ENDIF.

* INI CMS Tratamiento de fechas por Turnos. Sel.reg.Fecha INI -->hora > 6:00h i Fecha FIn hora < 6:00
* Recuperación descripciones de registros restantes:
    PERFORM obtener_descriptivos USING  ls_datos-matnr
                                        ls_datos-matkl
                                        ls_datos-werks
                                        ls_datos-lgort
                                        ls_datos-kunnr
                               CHANGING ls_datos-maktx
                                        ls_datos-wgbez60
                                        ls_datos-werks_name
                                        ls_datos-lgort_name
                                        ls_datos-kunnr_name.

* FIN CMS Tratamiento de fechas por Turnos. Sel.reg.Fecha INI -->hora > 6:00h i Fecha FIn hora < 6:00

    ls_datos-zcont = 1.

    " Leemos datos de la clasificación bobina:
    PERFORM dat_bobina USING ls_datos-matnr
                             ls_datos-charg
                             ls_datos-werks
                       CHANGING ls_datos-lote_orig
                                ls_datos-matnr_orig
                                ls_datos-motiv_reproc
                                ls_datos-motiv_remanip
                                ls_datos-aufnr_bobina.

* GST - 05/08/2015 ->
*    " Recuperamos los datos del material rollo:
*    PERFORM dat_rollo USING ls_datos-lote_orig
*                            ls_datos-matnr_orig
*                      CHANGING ls_datos-hsdat_rollo
*                               ls_datos-turno_rollo.

    CLEAR: lv_rollo, lv_mtart.
    WHILE ( ls_datos-lote_ins IS INITIAL AND lv_rollo <> 'X').
* GST - 05/08/2015 <-

      " Recuperamos datos de calidad: Lote inspección y origen
      PERFORM recup_qm USING ls_datos-matnr
                             ls_datos-charg
                             ls_datos-matnr_orig
                             ls_datos-lote_orig
                       CHANGING ls_datos-lote_ins
                                ls_datos-origen_lote
                                ls_datos-vdatum
                                ls_datos-plnnr.

* GST - 05/08/2015 ->

      IF ls_datos-matnr_orig IS NOT INITIAL AND
         ls_datos-lote_orig IS NOT INITIAL.

        " Recuperamos los datos del material rollo:
        PERFORM dat_rollo USING ls_datos-lote_orig
                                ls_datos-matnr_orig
                          CHANGING ls_datos-hsdat_rollo
                                   ls_datos-turno_rollo
                                   ls_datos-aufnr_rollo.

        CLEAR lv_mtart.
        SELECT SINGLE mtart zzancho INTO ( lv_mtart , ls_datos-zancho_rollo )
          FROM mara
          WHERE matnr = ls_datos-matnr_orig.

        IF lv_mtart = 'ZROL'.
          lv_rollo = 'X'.
* GST - 16/10/2015 ->
*          ls_datos-origen_lote = 'R'.
*        ELSE.
*          ls_datos-origen_lote = 'B'.
* GST - 16/10/2015 <-
        ENDIF.

        IF ls_datos-lote_ins IS INITIAL AND lv_rollo <> 'X'.
          PERFORM buscar_rollo CHANGING ls_datos-matnr_orig
                                        ls_datos-lote_orig.

          IF ls_datos-matnr_orig IS INITIAL OR  ls_datos-lote_orig IS
          INITIAL.
            lv_rollo = 'X'.
          ENDIF.

        ENDIF.

      ELSE.
        lv_rollo = 'X'.
      ENDIF.


    ENDWHILE.

* Si la selección es por F.Prod.Rollo, validamos que el reg. esté dentro del rango. CMS 01/07/2019
    IF pr_froll = 'X'.
      CHECK ls_datos-hsdat_rollo IN so_darol.
    ENDIF.

* GST - 05/08/2015 <-

    IF ls_datos-lote_ins IS NOT INITIAL.

      " Recuperamos datos de calidad: GRAMAJE MEDIO
      PERFORM recup_grm USING ls_datos-lote_ins
                              ls_datos-plnnr
                        CHANGING ls_datos-grm_num
                                 ls_datos-grm_dec
                                 ls_datos-grm_lim_pap
                                 ls_datos-grm_lim_pap_dec
                                 ls_datos-grm_desv
                                 ls_datos-grm_icon
                                 ls_datos-grm_val_teor
                                 ls_datos-grm_val_teor_dec.
* sat 12894
*data: lt_plmk TYPE TABLE OF plmk .
*obtener n.i.gramaje SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
       WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                         AND verwmerkm EQ '00001000'.

      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nigramaje
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.

      " Recuperamos datos de calidad: SCT
      PERFORM recup_sct USING ls_datos-lote_ins
                              ls_datos-plnnr
                        CHANGING ls_datos-sct_num
                                 ls_datos-sct_dec
                                 ls_datos-sct_lim_pap
                                 ls_datos-sct_lim_pap_dec
                                 ls_datos-sct_desv
                                 ls_datos-sct_icon
                                 ls_datos-sct_val_teor
                                 ls_datos-sct_val_teor_dec.
*obtener n.i.sct SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001001'.

      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nisct
        WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.

      " Recuperamos datos de calidad: CMT
      PERFORM recup_cmt USING ls_datos-lote_ins
                              ls_datos-plnnr
                        CHANGING ls_datos-cmt_num
                                 ls_datos-cmt_dec
                                 ls_datos-cmt_lim_pap
                                 ls_datos-cmt_lim_pap_dec
                                 ls_datos-cmt_desv
                                 ls_datos-cmt_icon
                                 ls_datos-cmt_val_teor
                                 ls_datos-cmt_val_teor_dec.
*obtener n.i.CMT SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001002'.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nicmt
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.

      " Recuperamos datos de calidad: ESTALLIDO
      PERFORM recup_est USING ls_datos-lote_ins
                              ls_datos-plnnr
                        CHANGING ls_datos-est_num
                                 ls_datos-est_dec
                                 ls_datos-est_lim_pap
                                 ls_datos-est_lim_pap_dec
                                 ls_datos-est_desv
                                 ls_datos-est_icon
                                 ls_datos-est_val_teor
                                 ls_datos-est_val_teor_dec.

      " Recuperamos datos de calidad: COBB60
      PERFORM recup_cobb60 USING ls_datos-lote_ins
                                 ls_datos-plnnr
                           CHANGING ls_datos-cobb60_num
                                    ls_datos-cobb60_dec
                                    ls_datos-cobb60_lim_pap
                                    ls_datos-cobb60_lim_pap_dec
                                    ls_datos-cobb60_desv
                                    ls_datos-cobb60_icon
                                    ls_datos-cobb60_val_teor
                                    ls_datos-cobb60_val_teor_dec.

      " Recuperamos datos de calidad: COBB1800
      PERFORM recup_cobb1800 USING ls_datos-lote_ins
                                   ls_datos-plnnr
                             CHANGING ls_datos-cobb1800_num
                                      ls_datos-cobb1800_dec
                                      ls_datos-cobb1800_lim_pap
                                      ls_datos-cobb1800_lim_pap_dec
                                      ls_datos-cobb1800_desv
                                      ls_datos-cobb1800_icon
                                      ls_datos-cobb1800_val_teor
                                      ls_datos-cobb1800_val_teor_dec.

      PERFORM recup_humedad USING ls_datos-lote_ins
                            ls_datos-plnnr
                   CHANGING ls_datos-hum_num
                            ls_datos-hum_dec
                            ls_datos-hum_lim_pap
                            ls_datos-hum_lim_pap_dec
                            ls_datos-hum_desv
                            ls_datos-hum_val_teor
                            ls_datos-hum_val_teor_dec
                            ls_datos-hum_icon.

* CMS INI 21/09/2020 Añadir datos de porosidad.
      PERFORM recup_porosidad USING ls_datos-lote_ins
                               ls_datos-plnnr
                         CHANGING ls_datos-poro_num
                                  ls_datos-poro_dec
                                  ls_datos-poro_lim_pap
                                  ls_datos-poro_lim_pap_dec
                                  ls_datos-poro_desv
                                  ls_datos-poro_icon
                                  ls_datos-poro_val_teor
                                  ls_datos-poro_val_teor_dec
                                  ls_datos-poro_lim_inf
                                  ls_datos-poro_lim_inf_dec.

* CMS FIN 21/09/2020 Añadir datos de porosidad.


      " Recuperamos datos de calidad: GOTA
      PERFORM recup_gota USING ls_datos-lote_ins
                               ls_datos-plnnr
                         CHANGING ls_datos-gota_num
                                  ls_datos-gota_dec
                                  ls_datos-gota_lim_pap
                                  ls_datos-gota_lim_pap_dec
                                  ls_datos-gota_desv
                                  ls_datos-gota_icon
                                  ls_datos-gota_val_teor
                                  ls_datos-gota_val_teor_dec.
*obtener n.i.gota SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001006'.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nigota
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.
*obtener n.i.estallido SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001003'.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-niestallido
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.
*obtener n.i.cobb 60 SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001004'.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nicobb60
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.
*obtener n.i.cobb 1800 SAT 12894
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ '00001005'.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-nicobb1800
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.

*obtener n.i.POROSIDAD CMS 22/09/2020 - 62888 - Añadir caract.POROSIDAD
      SELECT SINGLE merknr FROM plmk INTO lv_merknr
        WHERE plnty EQ 'Q' AND plnnr EQ ls_datos-plnnr
                          AND verwmerkm EQ c_poro.
      SELECT SINGLE pruefbemkt FROM qamr INTO ls_datos-niporo
       WHERE prueflos = ls_datos-lote_ins AND merknr = lv_merknr.
      CLEAR lv_merknr.

    ENDIF.

* SAT: 7000014633 - 19/04/2017
    CLEAR: ls_header,
           lt_item_in[],
           lt_partner[].
*
    " ORDER HEADER
    CLEAR ls_header.
    ls_header-doc_type   = 'ZTA'.
    ls_header-sales_org  = ls_datos-werks.
    ls_header-distr_chan = '10'.
    ls_header-division   = '20'.
    ls_header-req_date_h = sy-datum.
    ls_header-price_date = sy-datum.
    ls_header-dlv_block  = '01'.
*
    " ITEMS
    CLEAR: ls_item_in.
    SELECT SINGLE meins INTO ls_item_in-sales_unit
      FROM mara
      WHERE matnr EQ ls_datos-matnr.
    ls_item_in-material   = ls_datos-matnr.

    APPEND ls_item_in TO lt_item_in.

    " PARTNERS
    IF ls_datos-kunnr IS NOT INITIAL.
      CLEAR ls_partner.
      ls_partner-partn_role = 'AG'.
      IF ls_datos-kunnr EQ '0'.
        ls_partner-partn_numb = '0000100614'.
      ELSE.
*        ls_partner-partn_numb = ls_datos-kunnr.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = ls_datos-kunnr
          importing
            output = ls_partner-partn_numb.

      ENDIF.
      APPEND ls_partner TO lt_partner.
    ENDIF.

    CLEAR: lt_bapicond_ex[],
           ls_return.
    CALL FUNCTION 'BAPI_SALESORDER_SIMULATE'
      EXPORTING
        order_header_in    = ls_header
      IMPORTING
        return             = ls_return
      TABLES
        order_items_in     = lt_item_in
        order_partners     = lt_partner
        order_condition_ex = lt_bapicond_ex.

    CLEAR: ls_bapicond_ex.
    READ TABLE lt_bapicond_ex INTO ls_bapicond_ex
                              WITH KEY cond_type = 'ZPRP'.
    IF sy-subrc EQ 0.
      ls_datos-precio_venta_bobina = ls_bapicond_ex-cond_value.
      ls_datos-waers               = ls_bapicond_ex-currency.
    ENDIF.

    " Pérdida por bobina (Descuento del 30%)
    ls_datos-perdida_por_bobina = ( ls_datos-precio_venta_bobina * 30 ) / 100.

    " Total venta bobina
    ls_datos-total_venta_bobina = ls_datos-precio_venta_bobina - ls_datos-perdida_por_bobina.
* SAT: 7000014633 - 19/04/2017

* SAT: 7000014840 - 04/05/2017
    " Precio venta por bobina
    ls_datos-precio_vta_por_bob   = ls_datos-precio_venta_bobina * ( ls_datos-clabs / 1000 ).
    " Descuento por bobina
    ls_datos-descuento_por_bobina = ls_datos-perdida_por_bobina  * ( ls_datos-clabs / 1000 ).
    " Total venta por bobina
    ls_datos-total_vta_por_bobina = ls_datos-total_venta_bobina  * ( ls_datos-clabs / 1000 ).
* SAT: 7000014840 - 04/05/2017

    APPEND ls_datos TO gt_datos.

  ENDLOOP.

ENDFORM.                    " RECUPERAR_DATOS


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CLIENTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_STOCK_MATNR  text
*      -->P_LS_STOCK_CHARG  text
*      <--P_LS_STOCK_KUNNR  text
*----------------------------------------------------------------------*
FORM recuperar_cliente  USING    p_matnr
                                 p_charg
                        CHANGING p_kunnr
                                 p_vcode
                                 p_hsdat
                                 p_contramaestre
                                 p_operario.

  DATA: lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        lv_num               TYPE i,
        lv_fec_n             TYPE n LENGTH 8.

  REFRESH: lt_alloc_values_num, lt_alloc_values_char.
  REFRESH: lt_alloc_values_curr, lt_return.
  CLEAR: lv_object, ls_alloc_values_char.
  CLEAR: lt_alloc_values_num, lt_alloc_values_char.
  CLEAR: lt_alloc_values_curr, lt_return.

  CONCATENATE p_matnr p_charg INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
*   IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.

  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_CLIENTE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_kunnr = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_kunnr.
  ENDIF.


* RECUPERAR DECISION DE EMPLEO
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'LOBM_UDCODE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_vcode = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_vcode.
  ENDIF.

* FECHA FABRICACIÓN:
  CLEAR ls_alloc_values_num.
  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                               WITH KEY charact = 'Z_FECHA_FABRICACION'.
  IF ls_alloc_values_num IS NOT INITIAL.
    CLEAR: lv_num, lv_fec_n.
    lv_num = ls_alloc_values_num-value_from.
    lv_fec_n = lv_num.
    p_hsdat = lv_fec_n .
  ELSE.
    p_hsdat = '00000000'.
  ENDIF.

* 05/01/2021 - 63679 - CMS - Añadir contramaestre y operario.
  CLEAR: p_contramaestre , p_operario.
  TRY.
      p_contramaestre = lt_alloc_values_char[ charact = 'Z_CONTRAMAESTRE' ]-value_char.
    CATCH cx_root .
  ENDTRY.

  TRY.
      p_operario = lt_alloc_values_char[ charact = 'Z_OPERARIO' ]-value_char.
    CATCH cx_root .
  ENDTRY.

ENDFORM.                    " RECUPERAR_CLIENTE

*&---------------------------------------------------------------------*
*&      Form  OBTENER_CLASIFICACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_STOCK_MATNR  text
*      -->P_LS_STOCK_CHARG  text
*      <--P_LS_STOCK_CHARG  text
*----------------------------------------------------------------------*
FORM obtener_clasificacion  USING    p_matnr
                                     p_charg
                            CHANGING p_hsdat.

  DATA: lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        lv_num               TYPE i,
        lv_fec_n             TYPE n LENGTH 8.

  CLEAR: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr
  , lt_return.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char,
  lt_alloc_values_curr, lt_return.


  CLEAR: lv_object, p_hsdat.
  CONCATENATE p_matnr p_charg INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
* IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.


  CLEAR ls_alloc_values_num.
  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                                 WITH KEY charact =
                                 'Z_FECHA_FABRICACION'.
  IF ls_alloc_values_num IS NOT INITIAL.
    CLEAR: lv_num, lv_fec_n.
    lv_num = ls_alloc_values_num-value_from.
    lv_fec_n = lv_num.
    p_hsdat = lv_fec_n .
  ELSE.
    p_hsdat = '00000000'.
  ENDIF.

ENDFORM.                    " OBTENER_CLASIFICACION
*&---------------------------------------------------------------------*
*&      Form  DAT_BOBINA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_MATNR  text
*      -->P_LS_DATOS_CHARG  text
*      <--P_LS_DATOS_LOTE_ORIG  text
*      <--P_LS_DATOS_MATNR_ORIG  text
*----------------------------------------------------------------------*
FORM dat_bobina  USING    p_matnr
                          p_charg
                          p_werks
                 CHANGING p_lote_orig
                          p_matnr_orig
                          p_motiv_reproc
                          p_motiv_remanip
                          p_aufnr_bobina.

  DATA: lv_object             TYPE objnum,
        lt_alloc_values_num   TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char  TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr  TYPE tt_bapi1003_alloc_values_curr,
        lt_return             TYPE bapiret2_tab,
        ls_alloc_values_num   TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char  TYPE bapi1003_alloc_values_char,
        lv_motiv_reproc       TYPE zpp_motiv_reproc,
        lv_motiv_reproc_scada TYPE zpp_motiv_reproc.

  DATA: BEGIN OF lt_materiales OCCURS 0,
          matnr TYPE matnr,
          charg TYPE charg_d,
          mtart TYPE mtart,
        END OF lt_materiales.
  DATA: ls_materiales LIKE LINE OF lt_materiales.

  CLEAR: p_lote_orig, p_matnr_orig, p_motiv_reproc.
  CLEAR: p_motiv_remanip.
  CLEAR: lv_object, ls_alloc_values_num, ls_alloc_values_num.
  CLEAR: lt_alloc_values_num, lt_alloc_values_char,
         lt_alloc_values_curr, lt_return.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char,
           lt_alloc_values_curr, lt_return.

  CLEAR: lt_materiales, ls_materiales.
  REFRESH: lt_materiales.

  SELECT SINGLE aufnr
    FROM aufm
    INTO ( p_aufnr_bobina )
    WHERE charg = p_charg AND
          matnr = p_matnr AND
          werks = p_werks.


  CONCATENATE p_matnr p_charg INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
* IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.

  " Valores char de las características:
  CLEAR: lv_motiv_reproc, lv_motiv_reproc_scada.
  LOOP AT lt_alloc_values_char INTO ls_alloc_values_char.
    CASE ls_alloc_values_char-charact.
        " Lote rollo origen:
      WHEN 'Z_LOTE_ORIGEN'.
        CONDENSE ls_alloc_values_char-value_char.
        p_lote_orig = ls_alloc_values_char-value_char.

        " Material rollo origen:
      WHEN 'Z_ROLLO_ORIGEN_V2'.
        CONDENSE ls_alloc_values_char-value_char.
        p_matnr_orig = ls_alloc_values_char-value_char.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = p_matnr_orig
          IMPORTING
            output = p_matnr_orig.

* GST - 30/09/2015 - Motivo reproceso ->
      WHEN 'ZPPI_MOTIVO_REPROCESO_BOBINA'.
        CONDENSE ls_alloc_values_char-value_char.
        lv_motiv_reproc = ls_alloc_values_char-value_char.
        TRANSLATE lv_motiv_reproc TO UPPER CASE.
* GST - 30/09/2015 - Motivo reproceso <-

* GST - 22/10/2015 - Motivo reproceso SCADA ->
      WHEN 'Z_MOTIVO_REPROCESO_BOBINA'.
        CONDENSE ls_alloc_values_char-value_char.
        lv_motiv_reproc_scada = ls_alloc_values_char-value_char.
        TRANSLATE lv_motiv_reproc_scada TO UPPER CASE.
* GST - 22/10/2015 - Motivo reproceso SCADA <-

* GST - 09/11/2015 - Motivo remanipulado ->
      WHEN 'ZPPI_MOTIVO_REMANIPULADO'.
        CONDENSE ls_alloc_values_char-value_char.
        p_motiv_remanip = ls_alloc_values_char-value_char.
        TRANSLATE p_motiv_remanip TO UPPER CASE.
* GST - 09/11/2015 - Motivo remanipulado <-

    ENDCASE.
  ENDLOOP.


* GST - 30/09/2015 - Motivo reproceso ->
  IF lv_motiv_reproc IS NOT INITIAL.
    p_motiv_reproc = lv_motiv_reproc.
* GST - 30/09/2015 - Motivo reproceso <-
* GST - 22/10/2015 - Motivo reproceso SCADA ->
  ELSEIF lv_motiv_reproc_scada IS NOT INITIAL.
    p_motiv_reproc = lv_motiv_reproc_scada.
* GST - 22/10/2015 - Motivo reproceso SCADA <-
  ENDIF.


* Si el material rollo origen está vacío, lo recuperaremos de
* la MCH1:
  IF p_matnr_orig IS INITIAL.

    SELECT a~matnr a~charg b~mtart
      INTO CORRESPONDING FIELDS OF TABLE lt_materiales
      FROM mch1 AS a
      INNER JOIN mara AS b ON b~matnr = a~matnr
      WHERE a~charg = p_lote_orig
      AND b~mtart = 'ZROL'.

    IF lt_materiales[] IS NOT INITIAL.
      CLEAR ls_materiales.
      READ TABLE lt_materiales INTO ls_materiales INDEX 1.
      p_matnr_orig = ls_materiales-matnr.
    ENDIF.

  ENDIF.

ENDFORM.                    " DAT_BOBINA
*&---------------------------------------------------------------------*
*&      Form  RECUP_QM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_MATNR  text
*      -->P_LS_DATOS_CHARG  text
*      -->P_LS_DATOS_MATNR_ORIG  text
*      -->P_LS_DATOS_LOTE_ORIG  text
*      <--P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_ORIGEN_LOTE  text
*      <--P_LS_DATOS_SCT_NUM  text
*      <--P_LS_DATOS_SCT_DEC  text
*      <--P_LS_DATOS_SCT_LIM_PAP  text
*      <--P_LS_DATOS_SCT_LIM_PAP_DEC  text
*      <--P_LS_DATOS_SCT_DESV  text
*----------------------------------------------------------------------*
FORM recup_qm  USING    p_matnr
                        p_charg
                        p_matnr_orig
                        p_lote_orig
               CHANGING p_lote_ins
                        p_origen_lote
                        p_vdatum
                        p_plnnr.

  DATA: BEGIN OF lt_lotes OCCURS 0,
          prueflos  TYPE qplos,
          vdatum    TYPE qvedatum,
          vezeiterf TYPE qvezeiterf,
          vaedatum  TYPE qvaedatum,
          plnnr     TYPE plnnr,
        END OF lt_lotes.

  DATA: ls_lotes LIKE LINE OF lt_lotes.
  DATA: lv_mtart TYPE mtart.

  CLEAR: p_lote_ins, p_origen_lote.

  REFRESH lt_lotes.
  CLEAR   ls_lotes.

* Obtener el último análisis cerrado
  SELECT b~prueflos b~vdatum b~vezeiterf b~vaedatum a~plnnr
    INTO CORRESPONDING FIELDS OF TABLE lt_lotes
    FROM qals AS a
    INNER JOIN qave AS b ON b~prueflos = a~prueflos
    WHERE a~matnr = p_matnr
    AND   a~charg = p_charg.


  IF lt_lotes[] IS INITIAL.

    SELECT b~prueflos b~vdatum b~vezeiterf b~vaedatum a~plnnr
      INTO CORRESPONDING FIELDS OF TABLE lt_lotes
      FROM qals AS a
      INNER JOIN qave AS b ON b~prueflos = a~prueflos
      WHERE a~matnr = p_matnr_orig
      AND   a~charg = p_lote_orig.

* GST - 16/10/2015 ->
    CLEAR lv_mtart.
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = p_matnr_orig.

    IF lt_lotes[] IS NOT INITIAL AND lv_mtart = 'ZROL'.
      p_origen_lote = 'R'.
    ELSEIF lt_lotes[] IS NOT INITIAL AND lv_mtart <> 'ZROL'.
      p_origen_lote = 'P'.
    ELSE.
      CLEAR p_origen_lote.
    ENDIF.
* GST - 16/10/2015 <-

  ELSE.
* GST - 16/10/2015 ->
    CLEAR lv_mtart.
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = p_matnr.

    IF lv_mtart = 'ZROL'.
      p_origen_lote = 'R'.
    ELSE.
      p_origen_lote = 'P'.
    ENDIF.
* GST - 16/10/2015 <-
  ENDIF.

  SORT lt_lotes BY vdatum    DESCENDING
                   vezeiterf DESCENDING.

  READ TABLE lt_lotes INTO ls_lotes INDEX 1.

  p_lote_ins = ls_lotes-prueflos.
  p_plnnr = ls_lotes-plnnr.

  IF ls_lotes-vaedatum IS NOT INITIAL.
    p_vdatum = ls_lotes-vaedatum.
  ELSE.
    p_vdatum = ls_lotes-vdatum.
  ENDIF.

ENDFORM.                    " RECUP_QM
*&---------------------------------------------------------------------*
*&      Form  RECUP_SCT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_SCT_NUM  text
*      <--P_LS_DATOS_SCT_DEC  text
*      <--P_LS_DATOS_SCT_LIM_PAP  text
*      <--P_LS_DATOS_SCT_LIM_PAP_DEC  text
*      <--P_LS_DATOS_SCT_DESV  text
*----------------------------------------------------------------------*
FORM recup_sct  USING    p_lote_ins
                         p_plnnr
                CHANGING p_sct_num
                         p_sct_dec
                         p_sct_lim_pap
                         p_sct_lim_pap_dec
                         p_sct_desv
                         p_sct_icon
                         p_sct_vt
                         p_sct_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.
  DATA: lv_lim_sup     TYPE qtolob,
        lv_lim_inf_dec TYPE zsct_lim_pap,
        lv_lim_sup_dec TYPE zsct_lim_pap.

  CLEAR: p_sct_num, p_sct_dec, p_sct_lim_pap, p_sct_icon.
  CLEAR: p_sct_lim_pap_dec, p_sct_desv, lv_merknr.
  CLEAR: lv_lim_sup, lv_lim_sup_dec, lv_lim_inf_dec.
  CLEAR: p_sct_vt, p_sct_vt_dec.

  CLEAR: lv_zaehl, lv_merknr.
* Obtener especificaciones de SCT y posición de la característica
  SELECT toleranzun toleranzob merknr zaehl INTO (p_sct_lim_pap,
  lv_lim_sup, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_sct.
  ENDSELECT.

* Obtener el resultado de SCT
  SELECT mittelwert INTO p_sct_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_sct_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

* Volcamos Lim Papelera y SCT para mostrar con tres decimales en el ALV
  MOVE p_sct_num TO p_sct_dec.
  MOVE p_sct_lim_pap TO p_sct_lim_pap_dec.
  MOVE p_sct_vt TO p_sct_vt_dec.

* Mirar si valor medio dentro de los límites:
  MOVE p_sct_lim_pap TO lv_lim_inf_dec.
  MOVE lv_lim_sup TO lv_lim_sup_dec.
  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_sct_dec <= lv_lim_sup_dec AND p_sct_dec >= lv_lim_inf_dec.
      p_sct_icon = '@0V@'.
    ELSE.
      p_sct_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_sct_dec >= lv_lim_inf_dec.
      p_sct_icon = '@0V@'.
    ELSE.
      p_sct_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_sct_icon <= lv_lim_sup_dec.
      p_sct_icon = '@0V@'.
    ELSE.
      p_sct_icon = '@0W@'.
    ENDIF.
  ENDIF.


*  IF p_sct_lim_pap = 0.
*    p_sct_desv = 100.
*  ELSE.
*    p_sct_desv = ( p_sct_num * 100 ) / p_sct_lim_pap.
*    p_sct_desv = p_sct_desv - 100.
*  ENDIF.

  IF p_sct_vt = 0.
    p_sct_desv = 100.
  ELSE.
    p_sct_desv = ( p_sct_num * 100 ) / p_sct_vt.
    p_sct_desv = p_sct_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_SCT
*&---------------------------------------------------------------------*
*&      Form  RECUP_GRM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_GRM_NUM  text
*      <--P_LS_DATOS_GRM_DEC  text
*      <--P_LS_DATOS_GRM_LIM_PAP  text
*      <--P_LS_DATOS_GRM_LIM_PAP_DEC  text
*      <--P_LS_DATOS_GRM_DESV  text
*----------------------------------------------------------------------*
FORM recup_grm  USING    p_lote_ins
                         p_plnnr
                CHANGING p_grm_num
                         p_grm_dec
                         p_grm_lim_pap
                         p_grm_lim_pap_dec
                         p_grm_desv
                         p_grm_icon
                         p_grm_vt
                         p_grm_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_sup     TYPE qtolob,
        lv_lim_inf_dec TYPE zgrm_lim_pap,
        lv_lim_sup_dec TYPE zgrm_lim_pap.

  CLEAR: p_grm_num, p_grm_dec, p_grm_lim_pap, p_grm_icon.
  CLEAR: p_grm_lim_pap_dec, p_grm_desv, lv_merknr.
  CLEAR: lv_lim_sup, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_grm_vt, p_grm_vt_dec.


  CLEAR: lv_zaehl, lv_merknr.
  SELECT toleranzun toleranzob merknr zaehl INTO (p_grm_lim_pap,
  lv_lim_sup, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_gramaje.
  ENDSELECT.


* Obtener el resultado de SCT
  SELECT mittelwert INTO p_grm_num
  FROM  qamr
  WHERE prueflos = p_lote_ins
  AND   merknr   = lv_merknr.
  ENDSELECT.


  SELECT sollwert INTO p_grm_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.


  MOVE p_grm_num TO p_grm_dec.
  MOVE p_grm_lim_pap TO p_grm_lim_pap_dec.
  MOVE p_grm_vt TO p_grm_vt_dec.

* Mirar si el valor medio está dentro de los límites:
  MOVE p_grm_lim_pap TO lv_lim_inf_dec.
  MOVE lv_lim_sup TO lv_lim_sup_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_grm_dec <= lv_lim_sup_dec AND p_grm_dec >= lv_lim_inf_dec.
      p_grm_icon = '@0V@'.
    ELSE.
      p_grm_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_grm_dec >= lv_lim_inf_dec.
      p_grm_icon = '@0V@'.
    ELSE.
      p_grm_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_grm_dec <= lv_lim_sup_dec.
      p_grm_icon = '@0V@'.
    ELSE.
      p_grm_icon = '@0W@'.
    ENDIF.
  ENDIF.

*  IF p_grm_lim_pap = 0.
*    p_grm_desv = 100.
*  ELSE.
*    p_grm_desv = ( p_grm_num * 100 ) / p_grm_lim_pap.
*    p_grm_desv = p_grm_desv - 100.
*  ENDIF.

  IF p_grm_vt = 0.
    p_grm_desv = 100.
  ELSE.
    p_grm_desv = ( p_grm_num * 100 ) / p_grm_vt.
    p_grm_desv = p_grm_desv - 100.
  ENDIF.

ENDFORM.                    " RECUP_GRM
*&---------------------------------------------------------------------*
*&      Form  RECUP_CMT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_CMT_NUM  text
*      <--P_LS_DATOS_CMT_DEC  text
*      <--P_LS_DATOS_CMT_LIM_PAP  text
*      <--P_LS_DATOS_CMT_LIM_PAP_DEC  text
*      <--P_LS_DATOS_CMT_DESV  text
*----------------------------------------------------------------------*
FORM recup_cmt  USING    p_lote_ins
                         p_plnnr
                CHANGING p_cmt_num
                         p_cmt_dec
                         p_cmt_lim_pap
                         p_cmt_lim_pap_dec
                         p_cmt_desv
                         p_cmt_icon
                         p_cmt_vt
                         p_cmt_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_sup     TYPE qtolob,
        lv_lim_inf_dec TYPE zcmt_lim_pap,
        lv_lim_sup_dec TYPE zcmt_lim_pap.

  CLEAR: p_cmt_num, p_cmt_dec, p_cmt_lim_pap, p_cmt_icon.
  CLEAR: p_cmt_lim_pap_dec, p_cmt_desv, lv_merknr.
  CLEAR: lv_lim_sup, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_cmt_vt, p_cmt_vt_dec.

  SELECT toleranzun toleranzob merknr zaehl INTO (p_cmt_lim_pap,
  lv_lim_sup, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_cmt.
  ENDSELECT.

* Obtener el resultado de SCT
  SELECT mittelwert INTO p_cmt_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_cmt_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

  MOVE p_cmt_num TO p_cmt_dec.
  MOVE p_cmt_lim_pap TO p_cmt_lim_pap_dec.
  MOVE p_cmt_vt TO p_cmt_vt_dec.

* Miramos si el valor medio está dentro de los límites:
  MOVE p_cmt_lim_pap TO lv_lim_inf_dec.
  MOVE lv_lim_sup TO lv_lim_sup_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cmt_dec <= lv_lim_sup_dec AND p_cmt_dec >= lv_lim_inf_dec.
      p_cmt_icon = '@0V@'.
    ELSE.
      p_cmt_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_cmt_dec >= lv_lim_inf_dec.
      p_cmt_icon = '@0V@'.
    ELSE.
      p_cmt_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cmt_dec <= lv_lim_sup_dec.
      p_cmt_icon = '@0V@'.
    ELSE.
      p_cmt_icon = '@0W@'.
    ENDIF.
  ENDIF.

*  IF p_cmt_lim_pap = 0.
*    p_cmt_desv = 100.
*  ELSE.
*    p_cmt_desv = ( p_cmt_num * 100 ) / p_cmt_lim_pap.
*    p_cmt_desv = p_cmt_desv - 100.
*  ENDIF.

  IF p_cmt_vt = 0.
    p_cmt_desv = 100.
  ELSE.
    p_cmt_desv = ( p_cmt_num * 100 ) / p_cmt_vt.
    p_cmt_desv = p_cmt_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_CMT
*&---------------------------------------------------------------------*
*&      Form  RECUP_EST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_EST_NUM  text
*      <--P_LS_DATOS_EST_DEC  text
*      <--P_LS_DATOS_EST_LIM_PAP  text
*      <--P_LS_DATOS_EST_LIM_PAP_DEC  text
*      <--P_LS_DATOS_EST_DESV  text
*----------------------------------------------------------------------*
FORM recup_est  USING    p_lote_ins
                         p_plnnr
                CHANGING p_est_num
                         p_est_dec
                         p_est_lim_pap
                         p_est_lim_pap_dec
                         p_est_desv
                         p_est_icon
                         p_est_vt
                         p_est_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_sup     TYPE qtolob,
        lv_lim_inf_dec TYPE zest_lim_pap,
        lv_lim_sup_dec TYPE zest_lim_pap.

  CLEAR: p_est_num, p_est_dec, p_est_lim_pap, p_est_icon.
  CLEAR: p_est_lim_pap_dec, p_est_desv, lv_merknr.
  CLEAR: lv_lim_sup, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_est_vt, p_est_vt_dec.

* Obtener especificaciones de EST y posición de la característica
  SELECT toleranzun toleranzob merknr zaehl INTO (p_est_lim_pap,
  lv_lim_sup, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_estallido.
  ENDSELECT.

* Obtener el resultado de SCT
  SELECT mittelwert INTO p_est_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_est_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

* Volcamos Lim Papelera y EST para mostrar con tres decimales en el ALV
  MOVE p_est_num TO p_est_dec.
  MOVE p_est_lim_pap TO p_est_lim_pap_dec.
  MOVE p_est_vt TO p_est_vt_dec.

* Mirar si el valor medio está dentro de los límites:
  MOVE p_est_lim_pap TO lv_lim_inf_dec.
  MOVE lv_lim_sup TO lv_lim_sup_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_est_dec <= lv_lim_sup_dec AND p_est_dec >= lv_lim_inf_dec.
      p_est_icon = '@0V@'.
    ELSE.
      p_est_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_est_dec >= lv_lim_inf_dec.
      p_est_icon = '@0V@'.
    ELSE.
      p_est_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_est_dec <= lv_lim_sup_dec.
      p_est_icon = '@0V@'.
    ELSE.
      p_est_icon = '@0W@'.
    ENDIF.
  ENDIF.


*  IF p_est_lim_pap = 0.
*    p_est_desv = 100.
*  ELSE.
*    p_est_desv = ( p_est_num * 100 ) / p_est_lim_pap.
*    p_est_desv = p_est_desv - 100.
*  ENDIF.

  IF p_est_vt = 0.
    p_est_desv = 100.
  ELSE.
    p_est_desv = ( p_est_num * 100 ) / p_est_vt.
    p_est_desv = p_est_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_EST
*&---------------------------------------------------------------------*
*&      Form  RECUP_COBB60
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_COBB60_NUM  text
*      <--P_LS_DATOS_COBB60_DEC  text
*      <--P_LS_DATOS_COBB60_LIM_PAP  text
*      <--P_LS_DATOS_COBB60_LIM_PAP_DEC  text
*      <--P_LS_DATOS_COBB60_DESV  text
*----------------------------------------------------------------------*
FORM recup_cobb60  USING    p_lote_ins
                            p_plnnr
                   CHANGING p_cobb60_num
                            p_cobb60_dec
                            p_cobb60_lim_pap
                            p_cobb60_lim_pap_dec
                            p_cobb60_desv
                            p_cobb60_icon
                            p_cobb60_vt
                            p_cobb60_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_inf     TYPE qtolun,
        lv_lim_inf_dec TYPE zcobb60_lim_pap,
        lv_lim_sup_dec TYPE zcobb60_lim_pap.


  CLEAR: p_cobb60_num, p_cobb60_dec, p_cobb60_lim_pap, p_cobb60_icon.
  CLEAR: p_cobb60_lim_pap_dec, p_cobb60_desv, lv_merknr.
  CLEAR: lv_lim_inf, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_cobb60_vt, p_cobb60_vt_dec.

* Obtener especificaciones de COBB60 y posición de la característica
  SELECT toleranzob toleranzun merknr zaehl INTO (p_cobb60_lim_pap,
  lv_lim_inf, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_cobb60.
  ENDSELECT.

* Obtener el resultado de SCT
  SELECT mittelwert INTO p_cobb60_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_cobb60_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.


*Volcamos Lim Papelera y COBB60 para mostrar con tres decimales en el
*ALV
  MOVE p_cobb60_num TO p_cobb60_dec.
  MOVE p_cobb60_lim_pap TO p_cobb60_lim_pap_dec.
  MOVE p_cobb60_vt TO p_cobb60_vt_dec.

* Mirar si el valor medio está entre los límites:
  MOVE p_cobb60_lim_pap TO lv_lim_sup_dec.
  MOVE lv_lim_inf TO lv_lim_inf_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cobb60_dec <= lv_lim_sup_dec AND p_cobb60_dec >= lv_lim_inf_dec
    .
      p_cobb60_icon = '@0V@'.
    ELSE.
      p_cobb60_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_cobb60_dec >= lv_lim_inf_dec.
      p_cobb60_icon = '@0V@'.
    ELSE.
      p_cobb60_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cobb60_dec <= lv_lim_sup_dec.
      p_cobb60_icon = '@0V@'.
    ELSE.
      p_cobb60_icon = '@0W@'.
    ENDIF.
  ENDIF.


*  IF p_cobb60_lim_pap = 0.
*    p_cobb60_desv = 100.
*  ELSE.
*    p_cobb60_desv = ( p_cobb60_num * 100 ) / p_cobb60_lim_pap.
*    p_cobb60_desv = p_cobb60_desv - 100.
*  ENDIF.

  IF p_cobb60_vt = 0.
    p_cobb60_desv = 100.
  ELSE.
    p_cobb60_desv = ( p_cobb60_num * 100 ) / p_cobb60_vt.
    p_cobb60_desv = p_cobb60_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_COBB60
*&---------------------------------------------------------------------*
*&      Form  RECUP_COBB1800
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_COBB1800_NUM  text
*      <--P_LS_DATOS_COBB1800_DEC  text
*      <--P_LS_DATOS_COBB1800_LIM_PAP  text
*      <--P_LS_DATOS_COBB1800_LIM_PAP_DEC  text
*      <--P_LS_DATOS_COBB1800_DESV  text
*----------------------------------------------------------------------*
FORM recup_cobb1800  USING    p_lote_ins
                              p_plnnr
                     CHANGING p_cobb1800_num
                              p_cobb1800_dec
                              p_cobb1800_lim_pap
                              p_cobb1800_lim_pap_dec
                              p_cobb1800_desv
                              p_cobb1800_icon
                              p_cobb1800_vt
                              p_cobb1800_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_inf     TYPE qtolun,
        lv_lim_inf_dec TYPE zcobb1800_lim_pap,
        lv_lim_sup_dec TYPE zcobb1800_lim_pap.

  CLEAR: p_cobb1800_num, p_cobb1800_dec, p_cobb1800_lim_pap.
  CLEAR: p_cobb1800_icon.
  CLEAR: p_cobb1800_lim_pap_dec, p_cobb1800_desv, lv_merknr.
  CLEAR: lv_lim_inf, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_cobb1800_vt, p_cobb1800_vt_dec.

* Obtener especificaciones de COBB1800 y posición de la característica
  SELECT toleranzob toleranzun merknr zaehl INTO (p_cobb1800_lim_pap,
  lv_lim_inf, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_cobb1800.
  ENDSELECT.

* Obtener el resultado de COBB1800
  SELECT mittelwert INTO p_cobb1800_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_cobb1800_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

*Volcamos Lim Papelera y COBB1800 para mostrar con tres decimales en el
*ALV
  MOVE p_cobb1800_num TO p_cobb1800_dec.
  MOVE p_cobb1800_lim_pap TO p_cobb1800_lim_pap_dec.
  MOVE p_cobb1800_vt TO p_cobb1800_vt_dec.

* Mirar si el valor medio está entre los límites:
  MOVE p_cobb1800_lim_pap TO lv_lim_sup_dec.
  MOVE lv_lim_inf TO lv_lim_inf_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cobb1800_dec <= lv_lim_sup_dec AND p_cobb1800_dec >=
    lv_lim_inf_dec.
      p_cobb1800_icon = '@0V@'.
    ELSE.
      p_cobb1800_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_cobb1800_dec >= lv_lim_inf_dec.
      p_cobb1800_icon = '@0V@'.
    ELSE.
      p_cobb1800_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_cobb1800_dec <= lv_lim_sup_dec.
      p_cobb1800_icon = '@0V@'.
    ELSE.
      p_cobb1800_icon = '@0W@'.
    ENDIF.
  ENDIF.


*  IF p_cobb1800_lim_pap = 0.
*    p_cobb1800_desv = 100.
*  ELSE.
*    p_cobb1800_desv = ( p_cobb1800_num * 100 ) / p_cobb1800_lim_pap.
*    p_cobb1800_desv = p_cobb1800_desv - 100.
*  ENDIF.

  IF p_cobb1800_vt = 0.
    p_cobb1800_desv = 100.
  ELSE.
    p_cobb1800_desv = ( p_cobb1800_num * 100 ) / p_cobb1800_vt.
    p_cobb1800_desv = p_cobb1800_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_COBB1800
*&---------------------------------------------------------------------*
*&      Form  RECUP_GOTA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_INS  text
*      <--P_LS_DATOS_GOTA_NUM  text
*      <--P_LS_DATOS_GOTA_DEC  text
*      <--P_LS_DATOS_GOTA_LIM_PAP  text
*      <--P_LS_DATOS_GOTA_LIM_PAP_DEC  text
*      <--P_LS_DATOS_GOTA_DESV  text
*----------------------------------------------------------------------*
FORM recup_gota  USING    p_lote_ins
                          p_plnnr
                 CHANGING p_gota_num
                          p_gota_dec
                          p_gota_lim_pap
                          p_gota_lim_pap_dec
                          p_gota_desv
                          p_gota_icon
                          p_gota_vt
                          p_gota_vt_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_inf     TYPE qtolun,
        lv_lim_inf_dec TYPE zgota_lim_pap,
        lv_lim_sup_dec TYPE zgota_lim_pap.

  CLEAR: p_gota_num, p_gota_dec, p_gota_lim_pap, p_gota_icon.
  CLEAR: p_gota_lim_pap_dec, p_gota_desv, lv_merknr.
  CLEAR: lv_lim_inf, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_gota_vt, p_gota_vt_dec.

* Obtener especificaciones de GOTA y posición de la característica
  SELECT toleranzob toleranzun merknr zaehl INTO (p_gota_lim_pap,
  lv_lim_inf, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    " En vez de 3000 el que indiquemos por selección
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
    AND   verwmerkm  = c_gota.
  ENDSELECT.

* Obtener el resultado de GOTA
  SELECT mittelwert INTO p_gota_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_gota_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

* Volcamos Lim Papelera y GOTA para mostrar con tres decimales en el ALV
  MOVE p_gota_num TO p_gota_dec.
  MOVE p_gota_lim_pap TO p_gota_lim_pap_dec.
  MOVE p_gota_vt TO p_gota_vt_dec.

* Mirar si el valor medio está dentro de los límites:
  MOVE p_gota_lim_pap TO lv_lim_sup_dec.
  MOVE lv_lim_inf TO lv_lim_inf_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_gota_dec <= lv_lim_sup_dec AND p_gota_dec >= lv_lim_inf_dec.
      p_gota_icon = '@0V@'.
    ELSE.
      p_gota_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_gota_dec >= lv_lim_inf_dec.
      p_gota_icon = '@0V@'.
    ELSE.
      p_gota_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_gota_dec <= lv_lim_sup_dec.
      p_gota_icon = '@0V@'.
    ELSE.
      p_gota_icon = '@0W@'.
    ENDIF.
  ENDIF.


*  IF p_gota_lim_pap = 0.
*    p_gota_desv = 100.
*  ELSE.
*    p_gota_desv = ( p_gota_num * 100 ) / p_gota_lim_pap.
*    p_gota_desv = p_gota_desv - 100.
*  ENDIF.

  IF p_gota_vt = 0.
    p_gota_desv = 100.
  ELSE.
    p_gota_desv = ( p_gota_num * 100 ) / p_gota_vt.
    p_gota_desv = p_gota_desv - 100.
  ENDIF.


ENDFORM.                    " RECUP_GOTA
*&---------------------------------------------------------------------*
*&      Form  RECUP_TURNO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_MATNR  text
*      -->P_LS_DATOS_CHARG  text
*      -->P_LS_DATOS_LGORT  text
*      -->P_LS_DATOS_WERKS  text
*      <--P_LS_DATOS_TURNO  text
*----------------------------------------------------------------------*
FORM recup_turno  USING    p_reg TYPE zstmm_bob_calidad_n
                  CHANGING p_turno
                           p_sw_turno_out
                           p_date.
  DATA: l_t3_mati_nit TYPE char1.
  CLEAR p_sw_turno_out.

  CHECK pr_fabri = 'X' OR pr_froll = 'X'.

  IF ( p_reg-cputm_mkpf >= '060000' AND p_reg-cputm_mkpf <= '135959' ).
    p_turno = 'T1'.
  ELSEIF ( p_reg-cputm_mkpf >= '140000' AND p_reg-cputm_mkpf <= '215959' ).
    p_turno = 'T2'.
  ELSEIF ( p_reg-cputm_mkpf >= '220000' AND p_reg-cputm_mkpf <= '235959' ).
    p_turno = 'T3'.
    l_t3_mati_nit = 'N'.
  ELSEIF ( p_reg-cputm_mkpf >= '000000' AND p_reg-cputm_mkpf <= '055959' ).
    p_turno = 'T3'.
    l_t3_mati_nit = 'M'.
    p_date = p_date - 1.
  ELSE.
    CLEAR p_turno.
  ENDIF.

* Si es (T1 Y dia inicial Y Mañana[00:00-05:59]) o (T2/T3 Y dia final Y Noche[22:00-23:59]), despreciamos el registro
  CLEAR p_sw_turno_out.
  IF p_reg-budat_mkpf = g_data_ini AND p_turno = 'T3' AND l_t3_mati_nit = 'M'.
    p_sw_turno_out = 'X'.
  ELSEIF p_reg-budat_mkpf = g_data_fin AND
    (  p_turno = 'T1' OR p_turno = 'T2' OR ( p_turno = 'T3' AND l_t3_mati_nit = 'N' ) ).
    p_sw_turno_out = 'X'.
  ENDIF.


ENDFORM.                    " RECUP_TURNO
*&---------------------------------------------------------------------*
*&      Form  DAT_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_LOTE_ORIG  text
*      -->P_LS_DATOS_MATNR_ORIG  text
*      <--P_LS_DATOS_HSDAT_ROLLO  text
*      <--P_LS_DATOS_TURNO_ROLLO  text
*----------------------------------------------------------------------*
FORM dat_rollo  USING    p_charg
                         p_matnr
                CHANGING p_hsdat
                         p_turno
                         p_aufnr_rollo.

  DATA: lv_mblnr TYPE mblnr,
        lv_mjahr TYPE mjahr,
        lv_cputm TYPE cputm,
        lv_cpudt TYPE cpudt,
        lv_matnr TYPE matnr.

  CLEAR: p_turno, p_hsdat.
  CLEAR: lv_mblnr, lv_mjahr, lv_cputm, lv_cpudt, lv_matnr.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = p_matnr
    IMPORTING
      output = lv_matnr.

  SELECT SINGLE mblnr mjahr aufnr INTO (lv_mblnr, lv_mjahr,  p_aufnr_rollo)
    FROM aufm
    WHERE matnr = lv_matnr
    AND charg = p_charg
    AND bwart = '101'.

  IF lv_mblnr IS NOT INITIAL AND lv_mjahr IS NOT INITIAL.
    SELECT SINGLE cpudt cputm INTO (lv_cpudt, lv_cputm)
      FROM mkpf
      WHERE mblnr = lv_mblnr
      AND mjahr = lv_mjahr.


    " Determinar el turno en base a la hora de fabricación:
    IF ( lv_cputm >= '060000' AND lv_cputm <= '135959' ).
      p_turno = 'T1'.
      p_hsdat = lv_cpudt.
    ELSEIF ( lv_cputm >= '140000' AND lv_cputm <= '215959' ).
      p_turno = 'T2'.
      p_hsdat = lv_cpudt.
    ELSEIF ( lv_cputm >= '220000' AND lv_cputm <= '235959' ).
      p_turno = 'T3'.
      p_hsdat = lv_cpudt.
    ELSEIF ( lv_cputm >= '000000' AND lv_cputm <= '055959' ).
      p_turno = 'T3'.
      p_hsdat = lv_cpudt - 1.
    ELSE.
      CLEAR: p_turno, p_hsdat.
    ENDIF.

  ENDIF.

ENDFORM.                    " DAT_ROLLO
*&---------------------------------------------------------------------*
*&      Form  BUSCAR_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_DATOS_MATNR_ORIG  text
*      <--P_LS_DATOS_LOTE_ORIG  text
*----------------------------------------------------------------------*
FORM buscar_rollo  CHANGING p_matnr
                            p_lote.


  DATA: lv_matnr TYPE matnr,
        lv_charg TYPE charg_d.

  DATA: lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char.

  DATA: BEGIN OF lt_materiales OCCURS 0,
          matnr TYPE matnr,
          charg TYPE charg_d,
          mtart TYPE mtart,
        END OF lt_materiales.
  DATA: ls_materiales LIKE LINE OF lt_materiales.

  CLEAR: lt_materiales, ls_materiales.
  REFRESH: lt_materiales.

  CLEAR: lv_object, ls_alloc_values_num, ls_alloc_values_num.
  CLEAR: lt_alloc_values_num, lt_alloc_values_char,
         lt_alloc_values_curr, lt_return.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char,
           lt_alloc_values_curr, lt_return.


  CLEAR: lv_matnr, lv_charg.
  CONCATENATE p_matnr p_lote INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
* IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.

  " Valores char de las características:
  LOOP AT lt_alloc_values_char INTO ls_alloc_values_char.
    CASE ls_alloc_values_char-charact.
        " Lote rollo origen:
      WHEN 'Z_LOTE_ORIGEN'.
        CONDENSE ls_alloc_values_char-value_char.
        lv_charg = ls_alloc_values_char-value_char.

        " Material rollo origen:
      WHEN 'Z_ROLLO_ORIGEN_V2'.
        CONDENSE ls_alloc_values_char-value_char.
        lv_matnr = ls_alloc_values_char-value_char.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = lv_matnr
          IMPORTING
            output = lv_matnr.
    ENDCASE.
  ENDLOOP.

  IF lv_matnr IS INITIAL AND lv_charg IS NOT INITIAL.

    SELECT a~matnr a~charg b~mtart
      INTO CORRESPONDING FIELDS OF TABLE lt_materiales
      FROM mch1 AS a
      INNER JOIN mara AS b ON b~matnr = a~matnr
      WHERE a~charg = lv_charg.

    IF lt_materiales[] IS NOT INITIAL.
      CLEAR ls_materiales.
      READ TABLE lt_materiales INTO ls_materiales INDEX 1.
      lv_matnr = ls_materiales-matnr.
    ENDIF.

  ENDIF.

  IF lv_matnr IS INITIAL OR lv_charg IS INITIAL.

    CLEAR: lv_matnr, lv_charg.
    CONCATENATE p_matnr p_lote INTO lv_object.

    CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
      EXPORTING
        objectkey       = lv_object
        objecttable     = 'MCH1'
        classnum        = 'Z_BOBINA_REP'
        classtype       = '023'
*       KEYDATE         = SY-DATUM
*       UNVALUATED_CHARS       = ' '
*       LANGUAGE        = SY-LANGU
* IMPORTING
*       STATUS          =
*       STANDARDCLASS   =
      TABLES
        allocvaluesnum  = lt_alloc_values_num
        allocvalueschar = lt_alloc_values_char
        allocvaluescurr = lt_alloc_values_curr
        return          = lt_return.

    " Valores char de las características:
    LOOP AT lt_alloc_values_char INTO ls_alloc_values_char.
      CASE ls_alloc_values_char-charact.
          " Lote rollo origen:
        WHEN 'Z_LOTE_ORIGEN'.
          CONDENSE ls_alloc_values_char-value_char.
          lv_charg = ls_alloc_values_char-value_char.

          " Material rollo origen:
        WHEN 'Z_ROLLO_ORIGEN_V2'.
          CONDENSE ls_alloc_values_char-value_char.
          lv_matnr = ls_alloc_values_char-value_char.
          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = lv_matnr
            IMPORTING
              output = lv_matnr.
      ENDCASE.
    ENDLOOP.

    IF lv_matnr IS INITIAL AND lv_charg IS NOT INITIAL.

      SELECT a~matnr a~charg b~mtart
        INTO CORRESPONDING FIELDS OF TABLE lt_materiales
        FROM mch1 AS a
        INNER JOIN mara AS b ON b~matnr = a~matnr
        WHERE a~charg = lv_charg.

      IF lt_materiales[] IS NOT INITIAL.
        CLEAR ls_materiales.
        READ TABLE lt_materiales INTO ls_materiales INDEX 1.
        lv_matnr = ls_materiales-matnr.
      ENDIF.

    ENDIF.

  ENDIF.

  p_matnr = lv_matnr.
  p_lote = lv_charg.

ENDFORM.                    " BUSCAR_ROLLO

* CMS 21/09/2020 Recuperar los valores de POROSIDAD de manera idéntica a GOTA.

FORM recup_porosidad  USING    p_lote_ins
                          p_plnnr
                 CHANGING p_poro_num
                          p_poro_dec
                          p_poro_lim_pap
                          p_poro_lim_pap_dec
                          p_poro_desv
                          p_poro_icon
                          p_poro_vt
                          p_poro_vt_dec
                          p_lim_inf
                          p_lim_inf_dec.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA: lv_lim_inf     TYPE qtolun,
        lv_lim_inf_dec TYPE zgota_lim_pap,
        lv_lim_sup_dec TYPE zgota_lim_pap.

  CLEAR: p_poro_num, p_poro_dec, p_poro_lim_pap, p_poro_icon.
  CLEAR: p_poro_lim_pap_dec, p_poro_desv, lv_merknr.
  CLEAR: lv_lim_inf, lv_lim_inf_dec, lv_lim_sup_dec.
  CLEAR: p_poro_vt, p_poro_vt_dec.

* Obtener especificaciones de poro y posición de la característica
  SELECT toleranzob toleranzun merknr zaehl INTO (p_poro_lim_pap,
*  lv_lim_inf, lv_merknr, lv_zaehl)
  p_lim_inf, lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
    AND   qpmk_werks = p_werks
    AND   verwmerkm  = c_poro. " '00001008'. "Código Porosidad
  ENDSELECT.

* Obtener el resultado de poro
  SELECT mittelwert INTO p_poro_num
    FROM  qamr
    WHERE prueflos = p_lote_ins
    AND   merknr   = lv_merknr.
  ENDSELECT.

  SELECT sollwert INTO p_poro_vt
    FROM plmk
    WHERE plnty = 'Q'
    AND plnnr = p_plnnr
    AND merknr = lv_merknr
    AND zaehl = lv_zaehl.
  ENDSELECT.

* Volcamos Lim Papelera y poro para mostrar con tres decimales en el ALV
  MOVE p_poro_num TO p_poro_dec.
  MOVE p_poro_lim_pap TO p_poro_lim_pap_dec.
*  MOVE p_poro_vt TO p_poro_vt_dec.

* Mirar si el valor medio está dentro de los límites:
  MOVE p_poro_lim_pap TO lv_lim_sup_dec.
*  MOVE lv_lim_inf TO lv_lim_inf_dec.
  MOVE p_lim_inf TO p_lim_inf_dec.


  IF p_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_poro_dec <= lv_lim_sup_dec AND p_poro_dec >= p_lim_inf_dec.
      p_poro_icon = '@0V@'.
    ELSE.
      p_poro_icon = '@0W@'.
    ENDIF.
  ELSEIF p_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_poro_dec >= lv_lim_inf_dec.
      p_poro_icon = '@0V@'.
    ELSE.
      p_poro_icon = '@0W@'.
    ENDIF.
  ELSEIF p_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_poro_dec <= lv_lim_sup_dec.
      p_poro_icon = '@0V@'.
    ELSE.
      p_poro_icon = '@0W@'.
    ENDIF.
  ENDIF.

  IF p_poro_vt = 0.
    p_poro_desv = 100.
  ELSE.
    p_poro_desv = ( p_poro_num * 100 ) / p_poro_vt.
    p_poro_desv = p_poro_desv - 100.
  ENDIF.

ENDFORM.

FORM recup_humedad  USING p_lote_ins
                          p_plnnr
                 CHANGING p_hum_num
                          p_hum_dec
                          p_hum_lim_pap
                          p_hum_lim_pap_dec
                          p_hum_desv
                          p_hum_vt
                          p_hum_vt_dec
                          p_icon.

  DATA: lv_merknr TYPE qmerknrp,
        lv_zaehl  TYPE cim_count.

  DATA lv_lim_inf TYPE qtolun.
  DATA lv_lim_inf_dec TYPE zhum_lim_pap_dec0.
  DATA lv_lim_sup_dec TYPE zhum_lim_pap_dec0.

  CLEAR: p_hum_num, p_hum_dec, p_hum_lim_pap.
  CLEAR: p_hum_lim_pap_dec, p_hum_desv, lv_merknr, lv_zaehl.
  CLEAR: p_hum_vt, p_hum_vt_dec.

* Obtener especificaciones de HUMEDAD y posición de la característica
  SELECT SINGLE toleranzob toleranzun merknr zaehl INTO (p_hum_lim_pap, lv_lim_inf,lv_merknr, lv_zaehl)
    FROM  qamv
    WHERE prueflos   = p_lote_ins
*    AND   qpmk_werks IN so_werks
    AND   qpmk_werks = p_werks
    AND   verwmerkm  = c_hum.

* Obtener el resultado de HUMEDAD
  IF sy-subrc = 0.
    SELECT SINGLE mittelwert INTO p_hum_num
      FROM  qamr
      WHERE prueflos = p_lote_ins
      AND   merknr   = lv_merknr.

    SELECT SINGLE sollwert INTO p_hum_vt
      FROM plmk
      WHERE plnty = 'Q'
      AND plnnr = p_plnnr
      AND merknr = lv_merknr
      AND zaehl = lv_zaehl.

*   Volcamos Lim Papelera y HUMEDAD para mostrar con tres decimales en el ALV
    MOVE p_hum_num TO p_hum_dec.
    MOVE p_hum_lim_pap TO p_hum_lim_pap_dec.
    MOVE p_hum_vt TO p_hum_vt_dec.
  ENDIF.



  p_hum_desv = p_hum_num - p_hum_vt.

  lv_lim_inf_dec = lv_lim_inf.
  lv_lim_sup_dec =  p_hum_lim_pap_dec.

  IF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_hum_dec <= lv_lim_sup_dec AND p_hum_dec >= lv_lim_inf_dec.
      p_icon = '@0V@'.
    ELSE.
      p_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS NOT INITIAL AND lv_lim_sup_dec IS INITIAL.
    IF p_hum_dec >= lv_lim_inf_dec.
      p_icon = '@0V@'.
    ELSE.
      p_icon = '@0W@'.
    ENDIF.
  ELSEIF lv_lim_inf_dec IS INITIAL AND lv_lim_sup_dec IS NOT INITIAL.
    IF p_hum_dec <= lv_lim_sup_dec.
      p_icon = '@0V@'.
    ELSE.
      p_icon = '@0W@'.
    ENDIF.
  ENDIF.


ENDFORM.

* INI CMS Tratamiento de fechas por Turnos. Sel.reg.Fecha INI -->hora > 6:00h i Fecha FIn hora < 6:00
FORM tratar_fechas.
  IF so_hsdat IS NOT INITIAL.

    CASE so_hsdat-option.
      WHEN 'EQ'.
        g_data_ini = so_hsdat-low.
        g_data_fin = so_hsdat-low + 1.

      WHEN 'BT'.
        IF so_hsdat-low = so_hsdat-high.
          g_data_ini = so_hsdat-low.
          g_data_fin = so_hsdat-low + 1.
        ELSE.
          g_data_ini = so_hsdat-low.
          g_data_fin = so_hsdat-high + 1.
        ENDIF.

      WHEN OTHERS.
    ENDCASE.

  ENDIF.
* Para la selección por Fecha Fabricación Rollo, ampliaremos el rango y los trasladaremos a bobina.
  IF so_darol IS NOT INITIAL.

    CASE so_darol-option.
      WHEN 'EQ'.
        g_data_ini = so_darol-low.
        g_data_fin = so_darol-low + 1.

      WHEN 'BT'.
        IF so_darol-low = so_darol-high.
          g_data_ini = so_darol-low.
          g_data_fin = so_darol-low + 1.
        ELSE.
          g_data_ini = so_darol-low.
          g_data_fin = so_darol-high + 1.
        ENDIF.

      WHEN OTHERS.
    ENDCASE.
* A partir del rango de F.Prod_Rollo, aplicamos en mismo filtro para bobinas
    PERFORM obtener_lotes_rollo_fecha_prod.

  ENDIF.


ENDFORM.


FORM obtener_descriptivos USING  p_matnr
                                 p_matkl
                                 p_werks
                                 p_lgort
                                 p_kunnr
                        CHANGING p_maktx
                                 p_wgbez60
                                 p_werks_name
                                 p_lgort_name
                                 p_kunnr_name.

* Obtener descr.Material
  READ TABLE gt_matnr INTO DATA(ls_matnr) WITH KEY matnr = p_matnr.
  IF sy-subrc = 0.
    p_maktx = ls_matnr-makt.
  ELSE.
    SELECT matnr maktx
      FROM makt
      APPENDING TABLE  gt_matnr
      WHERE matnr = p_matnr AND
            spras = sy-langu.

    READ TABLE gt_matnr INTO ls_matnr WITH KEY matnr = p_matnr.
    p_maktx = ls_matnr-makt.
  ENDIF.

* Obtener descr.Tipo Material
  READ TABLE gt_matkl INTO DATA(ls_matkl) WITH KEY matkl = p_matkl.
  IF sy-subrc = 0.
    p_wgbez60 = ls_matkl-wgbez60.
  ELSE.
    SELECT matkl wgbez60
      FROM t023t
      APPENDING TABLE gt_matkl
      WHERE matkl = p_matnr AND
            spras = sy-langu.

    READ TABLE gt_matkl INTO ls_matkl WITH KEY matkl = p_matkl.
    p_wgbez60 = ls_matkl-wgbez60.

  ENDIF.

* Obtener descr.Centro
  READ TABLE gt_werks INTO DATA(ls_werks) WITH KEY werks = p_werks.
  IF sy-subrc = 0.
    p_werks_name = ls_werks-name1.
  ELSE.
    SELECT werks name1
      FROM t001w
      APPENDING TABLE gt_werks
      WHERE werks = p_werks.

    READ TABLE gt_werks INTO ls_werks WITH KEY werks = p_werks.
    p_werks_name = ls_werks-name1.

  ENDIF.

* Obtener descr.Almacen
  READ TABLE gt_lgort INTO DATA(ls_lgort) WITH KEY werks = p_werks
                                                   lgort = p_lgort.
  IF sy-subrc = 0.
    p_lgort_name = ls_lgort-lgobe.
  ELSE.
    SELECT werks lgort lgobe
      FROM t001l
      APPENDING TABLE gt_lgort
      WHERE werks = p_werks AND
            lgort = p_lgort.

    READ TABLE gt_lgort INTO ls_lgort WITH KEY werks = p_werks
                                               lgort = p_lgort.
    p_lgort_name = ls_lgort-lgobe.

  ENDIF.


* Obtener descr.Cliente
  READ TABLE gt_kna INTO DATA(ls_kna) WITH KEY kunnr = p_kunnr.
  IF sy-subrc = 0.
    p_kunnr_name = ls_kna-name1.
  ELSE.
    SELECT kunnr name1
      FROM kna1
      APPENDING TABLE gt_kna
      WHERE kunnr = p_kunnr.

    READ TABLE gt_kna INTO ls_kna WITH KEY kunnr = p_kunnr.
    p_kunnr_name = ls_kna-name1.

  ENDIF.

ENDFORM.
* FIN CMS Tratamiento de fechas por Turnos. Sel.reg.Fecha INI -->hora > 6:00h i Fecha FIn hora < 6:00

FORM obtener_werks_usr.

  SELECT SINGLE parva
      FROM usr05
      INTO p_werks
      WHERE bname = sy-uname AND
      parid = 'WRK'.


ENDFORM.

FORM f4_layouts USING i_restrict TYPE salv_de_layout_restriction
             CHANGING c_layout TYPE disvariant-variant.

  DATA: ls_layout TYPE salv_s_layout_info,
        ls_key    TYPE salv_s_layout_key.

  ls_key-report = sy-repid.

  ls_layout = cl_salv_layout_service=>f4_layouts(
    s_key    = ls_key
    restrict = i_restrict ).

  c_layout = ls_layout-layout.

ENDFORM.                    " f4_layouts


FORM obtener_lotes_rollo_fecha_prod.

  SELECT  sg~charg " ,  sg~budat_mkpf , sg~cputm_mkpf , sg~erfmg  AS clabs ,
*               ma~mtart , ma~matkl , ma~zzcalidad , ma~zzgramaje , ma~zzancho ,
*               ma~zzlargo , ma~meins
    FROM mseg AS sg
     INNER JOIN mara AS ma ON sg~matnr = ma~matnr
     INTO  TABLE @DATA(lt_rollos) "gt_datos_aux "lt_datos_aux

    WHERE
      sg~werks =  @p_werks
*            AND sg~charg IN @so_charg
*            AND sg~lgort IN @so_lgort
      AND sg~kunnr IN @so_kunnr
      AND budat_mkpf BETWEEN @g_data_ini AND @g_data_fin
      AND bwart = '101'
      AND sg~charg <> ' '
      AND ma~mtart = 'ZROL'
      AND sg~menge <> 0
      ORDER BY sg~budat_mkpf , sg~cputm_mkpf.

*** Obtenemos ordenes (de rollo) correspondientes a los rollos.
  SELECT aufnr , matnr , charg , menge , bwart , lgort , mblnr , mjahr FROM aufm
    INTO TABLE @DATA(lt_ordenes_rollo)
    FOR ALL ENTRIES IN @lt_rollos
    WHERE werks = @p_werks AND
          charg = @lt_rollos-charg .

*** A partir de las órdenes de rollo, obtenemos las órdenes de bobina
  SELECT aufnr , zzebeln1 , zzebelp1 , zzkunnr1 FROM aufk
    INTO TABLE @DATA(lt_ordenes_bobina)
    FOR ALL ENTRIES IN @lt_ordenes_rollo
    WHERE zzaufnr_rollo = @lt_ordenes_rollo-aufnr AND
          auart = 'ZI02'.

*** A partir de las órdenes de bobina, obtenemos los lotes de BOBINA asociados.
  SELECT aufnr , matnr , charg , menge , bwart , mblnr , mjahr FROM aufm
    INTO  TABLE @DATA(lt_lotes_bob)
    FOR ALL ENTRIES IN @lt_ordenes_bobina
    WHERE werks = @p_werks AND
          aufnr = @lt_ordenes_bobina-aufnr AND
          ( bwart = '101' OR bwart = '531' ).


* Informamos el SO de lotes de bobina con los datos extraidos a partir de fecha de producción de rollo.
  CLEAR so_charg[].
  LOOP AT lt_lotes_bob INTO DATA(ls_bob).
    APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_bob-charg ) TO so_charg.
  ENDLOOP.

ENDFORM.
