*&---------------------------------------------------------------------*
*&  Include           ZRMM0002_FORM
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  CARGAR_PANTALLA_1000
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM cargar_pantalla_1000 .

  IF sy-tcode = 'ZMM0003'.
    gv_bldat = sy-datum.
    gv_budat = sy-datum.
  ENDIF.

ENDFORM.                    " CARGAR_PANTALLA_1000

*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos.

ENDFORM.                    " RECUPERAR_DATOS

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos .

  DATA: ls_variant TYPE disvariant.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat.

* Para que muestre el ancho de las columnas optimizado
  t_layout-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout-stylefname = 'CELLTAB'.
  t_layout-sel_mode   = 'A'.

  ls_variant-report   = sy-repid.

* Mostrar alv
  CALL METHOD grid->set_table_for_first_display
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID'
      is_layout        = t_layout
      is_variant       = ls_variant
      i_save           = 'U'
      i_default        = 'X'
    CHANGING
      it_outtab        = gt_datos_1000[]
      it_fieldcatalog  = gti_fieldcat.

  SET HANDLER
*              g_application->handle_menu_button
              g_application->handle_data_changed
              g_application->handle_user_command
              g_application->handle_hotspot_click
              g_application->handle_toolbar FOR grid.

ENDFORM.                    " MOSTRAR_DATOS


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID'
    CHANGING
      ct_fieldcat      = gti_fieldcat.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'MENGE'.
        ls_fieldcat-scrtext_l = 'Cantidad S/HUM'.
        ls_fieldcat-scrtext_m = 'Cantidad S/HUM'.
        ls_fieldcat-scrtext_s = 'Cantidad S/HUM'.
        ls_fieldcat-reptext   = 'Cantidad S/HUM'.

      WHEN 'KTMNG'.
        ls_fieldcat-scrtext_l = 'Cantidad'.
        ls_fieldcat-scrtext_m = 'Cantidad'.
        ls_fieldcat-scrtext_s = 'Cantidad'.
        ls_fieldcat-reptext   = 'Cantidad'.

      WHEN 'FTANZPK'.
        ls_fieldcat-outputlen = 18.

      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'EBELN'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'EBELP'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        IF sy-tcode = 'ZMM0003'.
          ls_fieldcat-no_out = 'X'.
        ELSEIF  sy-tcode = 'ZMM0004' AND gv_contabilizado IS INITIAL.
          ls_fieldcat-edit = 'X'.
        ENDIF.


      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'LGORT'.
        ls_fieldcat-f4availabl = 'X'.
        ls_fieldcat-outputlen = 15.

      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-no_out = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT

*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos3.

  DATA: lv_contratos TYPE i.
  CLEAR lv_contratos.
  DATA: lv_answer TYPE c.
  DATA: lt_spopli LIKE spopli OCCURS 0,
        ls_spopli TYPE spopli.
  DATA: lv_index LIKE sy-tabix.

  CLEAR gt_pparcial.
  REFRESH gt_pparcial.

** SELECCIONAMOS LOS CONTRATOS MARCO PARA UN PROVEEDOR ACTIVOS EN LA FECHA SELECCIONADA
*  CLEAR gt_contrato_marco.
*  REFRESH gt_contrato_marco.
*  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_contrato_marco
*  FROM ekko
*  WHERE lifnr = gv_lifnr
*  AND ( kdatb <= gv_bldat
*  AND kdate >= gv_bldat ).
*
** MIRAMOS CUANTOS CONTRATOS SE RECUPERAN
*  DESCRIBE TABLE gt_contrato_marco LINES lv_contratos.
*  IF lv_contratos > 1.
** EN CASO DE SER MAS DE UNO MOSTRAMOS UN POP-UP PARA QUE EL USUARIO SELECCIONE UNO
*    LOOP AT gt_contrato_marco INTO gs_contrato_marco.
*      CONCATENATE gs_contrato_marco-ebeln gs_contrato_marco-kdatb gs_contrato_marco-kdate
*      INTO ls_spopli-varoption SEPARATED BY '-'.
*
*      APPEND ls_spopli TO lt_spopli.
*    ENDLOOP.
*
*    CLEAR lv_answer.
*    CALL FUNCTION 'POPUP_TO_DECIDE_LIST'
*      EXPORTING
**       CURSORLINE         = 1
**       MARK_FLAG          = ' '
**       MARK_MAX           = 1
**       START_COL          = 0
**       START_ROW          = 0
*        textline1          = text-002
**       TEXTLINE2          = ' '
**       TEXTLINE3          = ' '
*        titel              = text-001
**       DISPLAY_ONLY       = ' '
*      IMPORTING
*        answer             = lv_answer
*      TABLES
*        t_spopli           = lt_spopli
*      EXCEPTIONS
*        not_enough_answers = 1
*        too_much_answers   = 2
*        too_much_marks     = 3
*        OTHERS             = 4.
*
*    IF lv_answer <> 'A'.
*      READ TABLE gt_contrato_marco INTO gs_contrato_marco
*      INDEX lv_answer.
*    ENDIF.
*
*
*  ELSEIF lv_contratos = 0.
** SI NO EXISTE NINGUN CONTRATO MARCO MOSTRAMOS UN ERROR
*    MESSAGE e022 WITH gv_lifnr.
*
*  ELSEIF lv_contratos = 1.
** EN CASO DE SER SOLO UNO LO SELECCIONAMOS
*    READ TABLE gt_contrato_marco INTO gs_contrato_marco
*    INDEX 1.
*  ENDIF.

* SELECCIONAMOS LAS POSICIONES DEL CONTRATO MARCO PARA MOSTRAR LOS MATERIALES POSIBLES A PESAR
  IF NOT gs_contrato_marco-ebeln IS INITIAL.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_pparcial
    FROM ekpo
    WHERE ebeln = gs_contrato_marco-ebeln
    AND loekz <> 'L'.

  ENDIF.

  LOOP AT gt_pparcial INTO gs_pparcial.
    lv_index = sy-tabix.

    SELECT SINGLE maktx INTO gs_pparcial-maktx
    FROM makt
    WHERE matnr = gs_pparcial-matnr
    AND spras = sy-langu.
    CLEAR gs_pparcial-ktmng.

* MONEDA
    SELECT SINGLE waers INTO gs_pparcial-waers
    FROM ekko
    WHERE ebeln = gs_pparcial-ebeln.

    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY matnr = gs_pparcial-matnr.
    IF sy-subrc <> 0.
      MODIFY gt_pparcial FROM gs_pparcial.
    ELSE.
      DELETE gt_pparcial INDEX lv_index.
    ENDIF.

  ENDLOOP.


ENDFORM.                    " RECUPERAR_DATOS3

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos3 .

  DATA: ls_variant3 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat3.


* Para que muestre el ancho de las columnas optimizado
*  t_layout3-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout3-stylefname = 'CELLTAB'.
  t_layout3-sel_mode   = 'A'.

  ls_variant3-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid3->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID3'
      is_layout            = t_layout3
      is_variant           = ls_variant3
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_pparcial[]
      it_fieldcatalog      = gti_fieldcat3.

  SET HANDLER
              g_application3->handle_data_changed
              g_application3->handle_user_command
              g_application3->handle_hotspot_click
              g_application3->handle_toolbar FOR grid3.
*  SET HANDLER g_application3->handle_data_changed_finished FOR grid3.

ENDFORM.                    " MOSTRAR_DATOS3


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat3 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID3'
    CHANGING
      ct_fieldcat      = gti_fieldcat3.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat3 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-scrtext_l = 'Disconformidad'.
        ls_fieldcat-scrtext_m = 'Disconformidad'.
        ls_fieldcat-scrtext_s = 'Disconformidad'.
        ls_fieldcat-reptext   = 'Disconformidad'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-checkbox = 'X'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'FTANZPK'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '15'.
*        ls_fieldcat-col_opt = 'X'.
      WHEN 'LGORT'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '10'.
        ls_fieldcat-f4availabl = 'X'.
      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'MATNR'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'MAKTX'.
        ls_fieldcat-col_opt = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat3 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT3

*&---------------------------------------------------------------------*
*&      Form  TRASPASAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM traspasar_datos USING ok_code.
  DATA: lv_index LIKE sy-tabix.
  DATA: lv_pos TYPE i.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS PARCIALES
  IF  ok_code = 'REG_PES'.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      DELETE gt_datos_1000 INDEX sy-tabix.
    ENDLOOP.

    CLEAR lv_pos.
    DESCRIBE TABLE gt_datos_1000 LINES lv_pos.
    gv_posnr = lv_pos.

* GUARDAMOS EL CONTADOR DE POSICIONES
    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.
      lv_index = sy-tabix.
      gv_posnr = gv_posnr + 1.
      gs_pparcial-posnr = gv_posnr.
      MODIFY gt_pparcial FROM gs_pparcial INDEX lv_index.
    ENDLOOP.

* TRANSFERIMOS DATOS
    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.

      CLEAR gs_datos_1000.
      gs_datos_1000-posnr = gs_pparcial-posnr.
      gs_datos_1000-matnr = gs_pparcial-matnr.
      gs_datos_1000-maktx = gs_pparcial-maktx.
      gs_datos_1000-znum_pesada = gv_pesada.
      gs_datos_1000-ktmng = gs_pparcial-ktmng.
      IF NOT gv_bvvrel IS INITIAL.
        gs_datos_1000-menge = ( gs_pparcial-ktmng * gv_bvvrel ) / 100.
        gs_datos_1000-menge = gs_pparcial-ktmng - gs_datos_1000-menge.
      ELSE.
        gs_datos_1000-menge = gs_pparcial-ktmng.
      ENDIF.

      gs_datos_1000-meins = 'KG'.
      gs_datos_1000-ftanzpk = gs_pparcial-ftanzpk.
      gs_datos_1000-lgort = gs_pparcial-lgort.
      gs_datos_1000-ztipo_pesada = 'P'.
      gs_datos_1000-ebeln = gs_pparcial-ebeln.
      gs_datos_1000-ebelp = gs_pparcial-ebelp.
      gs_datos_1000-netpr = gs_pparcial-netpr.
      gs_datos_1000-waers = gs_pparcial-waers.
      gs_datos_1000-ntgew = gv_ntgew_c.
      gs_datos_1000-zdisconformidad = gs_pparcial-zdisconformidad.

      APPEND gs_datos_1000 TO gt_datos_1000.

    ENDLOOP.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS FINALES
  ELSEIF ok_code = 'BTN_PESF'.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      DELETE gt_datos_1000 INDEX sy-tabix.
    ENDLOOP.

    CLEAR lv_pos.
    DESCRIBE TABLE gt_datos_1000 LINES lv_pos.
    gv_posnr = lv_pos.

* GUARDAMOS EL CONTADOR DE POSICIONES
    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.
      lv_index = sy-tabix.
      gv_posnr = gv_posnr + 1.
      gs_pfinal-posnr = gv_posnr.
      MODIFY gt_pfinal FROM gs_pfinal INDEX lv_index.
    ENDLOOP.

    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.

      CLEAR gs_datos_1000.
      gv_posnr = gv_posnr + 1.
      gs_datos_1000-posnr = gs_pfinal-posnr.
      gs_datos_1000-matnr = gs_pfinal-matnr.
      gs_datos_1000-maktx = gs_pfinal-maktx.
      gs_datos_1000-znum_pesada = gv_pesada.
      gs_datos_1000-ktmng = gs_pfinal-ktmng.
*      IF NOT gv_bvvrel IS INITIAL.
*        gs_datos_1000-menge = ( gs_pFINAL-ktmng * gv_bvvrel ) / 100.
*      ENDIF.

      gs_datos_1000-meins = 'KG'.
      gs_datos_1000-ftanzpk = gs_pfinal-ftanzpk.
      gs_datos_1000-lgort = gs_pfinal-lgort.
      gs_datos_1000-ztipo_pesada = 'F'.
      gs_datos_1000-ebeln = gs_pfinal-ebeln.
      gs_datos_1000-ebelp = gs_pfinal-ebelp.
      gs_datos_1000-netpr = gs_pfinal-netpr.
      gs_datos_1000-waers = gs_pfinal-waers.
      gs_datos_1000-ntgew = gv_ntgew_b.
      gs_datos_1000-zdisconformidad = gs_pfinal-zdisconformidad.

      APPEND gs_datos_1000 TO gt_datos_1000.

    ENDLOOP.

  ENDIF.


ENDFORM.                    " TRASPASAR_DATOS


*&---------------------------------------------------------------------*
*&      Form  REVISAR_ALMACEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM revisar_almacen USING ok_code.

  DATA: ls_mard TYPE mard.

* COMPROBAR QUE SE INTRODUZCA EL ALMACEN EN LA PESADA PARCIAL
  IF  ok_code = 'REG_PES'.

    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk  IS INITIAL.
      IF gs_pparcial-lgort IS INITIAL.
        MESSAGE e025 DISPLAY LIKE 'I'.
      ELSE.
        SELECT SINGLE * INTO ls_mard
        FROM mard
        WHERE matnr = gs_pparcial-matnr
        AND werks = gc_werks
        AND lgort = gs_pparcial-lgort .
        IF sy-subrc <> 0.
          MESSAGE e352(m3) WITH gs_pparcial-matnr gs_pparcial-lgort gc_werks.
*   Material & en el almacén & del centro & no actualizado.
        ENDIF.
      ENDIF.
    ENDLOOP.

* COMPROBAR QUE SE INTRODUZCA EL ALMACEN EN LA PESADA FINAL
  ELSEIF ok_code = 'BTN_PESF'.

    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk  IS INITIAL.
      IF gs_pfinal-lgort IS INITIAL.
        MESSAGE e025 DISPLAY LIKE 'I'.
      ELSE.
        SELECT SINGLE * INTO ls_mard
        FROM mard
        WHERE matnr = gs_pfinal-matnr
        AND werks = gc_werks
        AND lgort = gs_pfinal-lgort .
        IF sy-subrc <> 0.
          MESSAGE e352(m3) WITH gs_pfinal-matnr gs_pfinal-lgort gc_werks.
*   Material & en el almacén & del centro & no actualizado.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDIF.

ENDFORM.                    " REVISAR_ALMACEN


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CONTADOR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_contador CHANGING lv_entrada.

  CLEAR lv_entrada.

  CALL FUNCTION 'NUMBER_GET_NEXT'
    EXPORTING
      nr_range_nr             = '01'
      object                  = 'ZC_MM'
      quantity                = '1'
*     SUBOBJECT               = ' '
*     TOYEAR                  = '0000'
*     IGNORE_BUFFER           = ' '
    IMPORTING
      number                  = lv_entrada
*     QUANTITY                =
*     RETURNCODE              =
    EXCEPTIONS
      interval_not_found      = 1
      number_range_not_intern = 2
      object_not_found        = 3
      quantity_is_0           = 4
      quantity_is_not_1       = 5
      interval_overflow       = 6
      buffer_overflow         = 7
      OTHERS                  = 8.


ENDFORM.                    " RECUPERAR_CONTADOR

*&---------------------------------------------------------------------*
*&      Form  GUARDAR_CABECERA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM guardar_cabecera .

  DATA: ls_cab06 TYPE ztmm0006.
  CLEAR ztmm0006.

* SI ACCEDE EL OPERARIO
  IF sy-tcode = 'ZMM0003'.
    ztmm0006-zentrada = gv_entrada.
    ztmm0006-xblnr = gv_xblnr.
    ztmm0006-lifnr = gv_lifnr.
    ztmm0006-bldat = gv_bldat.
    ztmm0006-budat = gv_budat.
    ztmm0006-ztransito = gv_transito.
    ztmm0006-bktxt = gv_bktxt.
    ztmm0006-ztransportista = gv_transp.
    ztmm0006-zmatricula1 = gv_matricula1.
    ztmm0006-zmatricula2 = gv_matricula2.
    ztmm0006-zhumedad = gv_bvvrel.
    ztmm0006-ntgew = gv_ntgew.
* ztmm0006-ZCONTABILIZADO
    ztmm0006-gewei = 'KG'.
    ztmm0006-kbetr = gv_kbetr.
    ztmm0006-konwa = gv_konwa.
    INSERT ztmm0006.
  ENDIF.

* SI ACCEDE EL SUPERVISOR
  IF sy-tcode = 'ZMM0004'.

    ls_cab06-zentrada = gv_entrada.
    ls_cab06-xblnr = gv_xblnr.
    ls_cab06-lifnr = gv_lifnr.
    ls_cab06-bldat = gv_bldat.
    ls_cab06-budat = gv_budat.
    ls_cab06-ztransito = gv_transito.
    ls_cab06-bktxt = gv_bktxt.
    ls_cab06-ztransportista = gv_transp.
    ls_cab06-zmatricula1 = gv_matricula1.
    ls_cab06-zmatricula2 = gv_matricula2.
    ls_cab06-zhumedad = gv_bvvrel.
    ls_cab06-ntgew = gv_ntgew.
* ztmm0006-ZCONTABILIZADO
    ls_cab06-gewei = 'KG'.
    ls_cab06-kbetr = gv_kbetr.
    ls_cab06-konwa = gv_konwa.

    UPDATE ztmm0006 FROM ls_cab06.

  ENDIF.

ENDFORM.                    " GUARDAR_CABECERA

*&---------------------------------------------------------------------*
*&      Form  GUARDAR_POSICIONES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM guardar_posiciones .

  DATA: ls_pos07 TYPE ztmm0007.

* SI ACCEDE EL OPERARIO
  IF sy-tcode = 'ZMM0003'.
    LOOP AT gt_datos_1000 INTO gs_datos_1000.
      CLEAR ztmm0007.

      ztmm0007-zentrada = gv_entrada.
      ztmm0007-posnr = sy-tabix.
      ztmm0007-matnr = gs_datos_1000-matnr.
      ztmm0007-znum_pesada = gs_datos_1000-znum_pesada.
      ztmm0007-ktmng = gs_datos_1000-ktmng .
      ztmm0007-menge = gs_datos_1000-menge.
      ztmm0007-meins = gs_datos_1000-meins.
      ztmm0007-ftanzpk = gs_datos_1000-ftanzpk.
      ztmm0007-lgort = gs_datos_1000-lgort.
      ztmm0007-ztipo_pesada = gs_datos_1000-ztipo_pesada.
      ztmm0007-netpr = gs_datos_1000-netpr.
      ztmm0007-ntgew = gs_datos_1000-ntgew.
      ztmm0007-waers = 'EUR'.
      ztmm0007-ebeln = gs_datos_1000-ebeln.
      ztmm0007-ebelp = gs_datos_1000-ebelp.

      INSERT ztmm0007.
    ENDLOOP.
  ENDIF.


* SI ACCEDE EL SUPERVISOR
  IF sy-tcode = 'ZMM0004'.

* PRIMERO BORRAMOS LAS POSICIONES
    DELETE FROM ztmm0007
    WHERE zentrada = gv_entrada.

* AHORA CREAMOS DE NUEVO LAS POSICIONES MODIFICADAS
    LOOP AT gt_datos_1000 INTO gs_datos_1000.
      CLEAR ztmm0007.

      ztmm0007-zentrada = gv_entrada.
      ztmm0007-posnr = sy-tabix.
      ztmm0007-matnr = gs_datos_1000-matnr.
      ztmm0007-znum_pesada = gs_datos_1000-znum_pesada.
      ztmm0007-ktmng = gs_datos_1000-ktmng .
      ztmm0007-menge = gs_datos_1000-menge.
      ztmm0007-meins = gs_datos_1000-meins.
      ztmm0007-ftanzpk = gs_datos_1000-ftanzpk.
      ztmm0007-lgort = gs_datos_1000-lgort.
      ztmm0007-ztipo_pesada = gs_datos_1000-ztipo_pesada.
      ztmm0007-netpr = gs_datos_1000-netpr.
      ztmm0007-ntgew = gs_datos_1000-ntgew.
      ztmm0007-waers = 'EUR'.
      ztmm0007-ebeln = gs_datos_1000-ebeln.
      ztmm0007-ebelp = gs_datos_1000-ebelp.

      INSERT ztmm0007.
    ENDLOOP.
*    LOOP AT gt_datos_1000 INTO gs_datos_1000.
*
*      ls_pos07-zentrada = gv_entrada.
*      ls_pos07-posnr = sy-tabix.
*      ls_pos07-matnr = gs_datos_1000-matnr.
*      ls_pos07-znum_pesada = gs_datos_1000-znum_pesada.
*      ls_pos07-ktmng = gs_datos_1000-ktmng .
*      ls_pos07-menge = gs_datos_1000-menge.
*      ls_pos07-meins = gs_datos_1000-meins.
*      ls_pos07-ftanzpk = gs_datos_1000-ftanzpk.
*      ls_pos07-lgort = gs_datos_1000-lgort.
*      ls_pos07-ztipo_pesada = gs_datos_1000-ztipo_pesada.
*      ls_pos07-netpr = gs_datos_1000-netpr.
*      ls_pos07-ntgew = gs_datos_1000-ntgew.
*      ls_pos07-waers = 'EUR'.
*      ls_pos07-ebeln = gs_datos_1000-ebeln.
*      ls_pos07-ebelp = gs_datos_1000-ebelp.
*
*      UPDATE ztmm0007 FROM ls_pos07.
*    ENDLOOP.
  ENDIF.

ENDFORM.                    " GUARDAR_POSICIONES


*&---------------------------------------------------------------------*
*&      Form  INICIALIZAR_VBLES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM inicializar_vbles .

  CLEAR: gv_lifnr,
         gv_transp,
         gv_entrada,
         gv_xblnr,
         gv_transito,
         gv_bktxt,
         gv_matricula1,
         gv_matricula2.

  CLEAR: gt_datos_1000,
         gt_pparcial.

  REFRESH: gt_datos_1000,
         gt_pparcial.

  CLEAR: gv_okcode,
         gv_okcode2,
         gv_okcode3.

ENDFORM.                    " INICIALIZAR_VBLES


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos4 .

  DATA: lv_contratos TYPE i.
  CLEAR lv_contratos.
  DATA: lv_answer TYPE c.
  DATA: lt_spopli LIKE spopli OCCURS 0,
        ls_spopli TYPE spopli.
  DATA: lv_index LIKE sy-tabix.

  CLEAR gt_pfinal.
  REFRESH gt_pfinal.

* SELECCIONAMOS LAS POSICIONES DEL CONTRATO MARCO PARA MOSTRAR LOS MATERIALES POSIBLES A PESAR
  IF NOT gs_contrato_marco-ebeln IS INITIAL.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_pfinal
    FROM ekpo
    WHERE ebeln = gs_contrato_marco-ebeln
    AND loekz <> 'L'.

  ENDIF.

  LOOP AT gt_pfinal INTO gs_pfinal.
    lv_index = sy-tabix.

    SELECT SINGLE maktx INTO gs_pfinal-maktx
    FROM makt
    WHERE matnr = gs_pfinal-matnr
    AND spras = sy-langu.
    CLEAR gs_pfinal-ktmng.

* MONEDA
    SELECT SINGLE waers INTO gs_pfinal-waers
    FROM ekko
    WHERE ebeln = gs_pfinal-ebeln.

    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY matnr = gs_pfinal-matnr.
    IF sy-subrc <> 0.
      MODIFY gt_pfinal FROM gs_pfinal.
    ELSE.
      DELETE gt_pfinal INDEX lv_index.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " RECUPERAR_DATOS4

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos4 .

  DATA: ls_variant4 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat4.


* Para que muestre el ancho de las columnas optimizado
*  t_layout4-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout4-stylefname = 'CELLTAB'.
  t_layout4-sel_mode   = 'A'.

  ls_variant4-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid4->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID3'
      is_layout            = t_layout4
      is_variant           = ls_variant4
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_pfinal[]
      it_fieldcatalog      = gti_fieldcat4.

  SET HANDLER
*              g_application4->handle_menu_button
              g_application4->handle_user_command
              g_application4->handle_hotspot_click
              g_application4->handle_toolbar FOR grid4.
  SET HANDLER g_application4->handle_data_changed_finished FOR grid4.

ENDFORM.                    " MOSTRAR_DATOS4

*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat4 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID3'
    CHANGING
      ct_fieldcat      = gti_fieldcat4.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat4 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-scrtext_l = 'Disconformidad'.
        ls_fieldcat-scrtext_m = 'Disconformidad'.
        ls_fieldcat-scrtext_s = 'Disconformidad'.
        ls_fieldcat-reptext   = 'Disconformidad'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-checkbox = 'X'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'FTANZPK'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '15'.
*        ls_fieldcat-col_opt = 'X'.
      WHEN 'LGORT'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '10'.
*        ls_fieldcat-col_opt = 'X'.
        ls_fieldcat-f4availabl = 'X'.
      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'MATNR'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'MAKTX'.
        ls_fieldcat-col_opt = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat4 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT4

*&---------------------------------------------------------------------*
*&      Form  MODIFICAR_PESADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM modificar_pesada USING e_ucomm.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  IF gs_datos_1000-ztipo_pesada = 'P'.

    CLEAR: gv_ntgew_c.
    gv_pesada = gs_datos_1000-znum_pesada.
    gv_ntgew_c = gs_datos_1000-ntgew.

    CLEAR gt_pparcial.
    REFRESH gt_pparcial.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos3.

    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      MOVE-CORRESPONDING gs_datos_1000 TO gs_pparcial.
      APPEND gs_pparcial TO gt_pparcial.
    ENDLOOP.

    gv_okcode2 = e_ucomm.

    CALL SCREEN '3000'.

  ELSEIF gs_datos_1000-ztipo_pesada = 'F'.

    CLEAR: gv_ntgew_c.
    gv_pesada = gs_datos_1000-znum_pesada.
    gv_ntgew_b = gs_datos_1000-ntgew.

    CLEAR gt_pfinal.
    REFRESH gt_pfinal.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos4.

    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      MOVE-CORRESPONDING gs_datos_1000 TO gs_pfinal.
      APPEND gs_pfinal TO gt_pfinal.
    ENDLOOP.

    gv_okcode2 = e_ucomm.

    CALL SCREEN '4000'.

  ENDIF.

ENDFORM.                    " MODIFICAR_PESADA

*&---------------------------------------------------------------------*
*&      Form  BORRAR_PESADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM borrar_pesada .

  DATA: lv_pesada TYPE zed_pesada.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  CLEAR lv_pesada.
  lv_pesada = gs_datos_1000-znum_pesada.

  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = lv_pesada.
    DELETE gt_datos_1000 INDEX sy-tabix.
  ENDLOOP.

  CLEAR: gt_pparcial, gt_pfinal.
  REFRESH: gt_pparcial, gt_pfinal.

  CALL METHOD grid->refresh_table_display.

ENDFORM.                    " BORRAR_PESADA

*&---------------------------------------------------------------------*
*&      Form  CREAR_LOTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_lotes USING ok_code.

  DATA: lv_batch    TYPE bapibatchkey-batch,
        lv_batchatr TYPE bapibatchatt,
        lt_return   LIKE bapiret2 OCCURS 0,
        ls_return   TYPE bapiret2,
        ls_batchatr TYPE bapibatchatt.
  DATA: lv_lifnr TYPE elifn.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS PARCIALES
  IF  ok_code = 'REG_PES'.

    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.
      CLEAR ls_batchatr.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = gv_lifnr
        IMPORTING
          output = lv_lifnr.
      ls_batchatr-vendor_no = lv_lifnr.
      CONCATENATE gv_entrada gs_pparcial-posnr INTO ls_batchatr-vendrbatch.

      DO  gs_pparcial-ftanzpk TIMES.

        CLEAR: lv_batch, lv_batchatr, lt_return.
        REFRESH lt_return.
        CALL FUNCTION 'BAPI_BATCH_CREATE'
          EXPORTING
            material             = gs_pparcial-matnr
*           BATCH                =
            plant                = gc_werks
            batchattributes      = ls_batchatr
*           BATCHCONTROLFIELDS   =
            batchstoragelocation = gs_pparcial-lgort
*           INTERNALNUMBERCOM    =
*           EXTENSION1           =
*           MATERIAL_EVG         =
          IMPORTING
            batch                = lv_batch
            batchattributes      = lv_batchatr
          TABLES
            return               = lt_return.

        READ TABLE lt_return INTO ls_return
        WITH KEY type = 'E'.
        IF sy-subrc <> 0.
          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
            EXPORTING
              wait = 'X'.

* GUARDAR LOS CON LOS LOTES CREADOS
          READ TABLE lt_return INTO ls_return
          WITH KEY type = 'S'.
          CLEAR gs_messages.
          gs_messages = ls_return.
          APPEND gs_messages TO gt_messages.

* IMPRIMIMOS UNA ETIQUETA POR CADA LOTE CREADO

          PERFORM imprimir_etiqueta USING lv_batch
                                          gs_pparcial .

        ELSE.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
          LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
            DELETE gt_datos_1000 INDEX sy-tabix.
          ENDLOOP.

* MOSTRAR EL ERROR Y NO DEJAR CONTINUAR LA EJECUCION DEL PROGRAMA
          MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number
          WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4.

        ENDIF.
      ENDDO.
    ENDLOOP.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS FINALES
  ELSEIF ok_code = 'BTN_PESF'.

    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.
      CLEAR ls_batchatr.
      ls_batchatr-vendor_no = gv_lifnr.
      CONCATENATE gv_entrada gs_pfinal-posnr INTO ls_batchatr-vendrbatch.

      DO  gs_pfinal-ftanzpk TIMES.

        CLEAR: lv_batch, lv_batchatr.
        refresh lt_return.
        CALL FUNCTION 'BAPI_BATCH_CREATE'
          EXPORTING
            material             = gs_pfinal-matnr
*           BATCH                =
            plant                = gc_werks
            batchattributes      = ls_batchatr
*           BATCHCONTROLFIELDS   =
            batchstoragelocation = gs_pfinal-lgort
*           INTERNALNUMBERCOM    =
*           EXTENSION1           =
*           MATERIAL_EVG         =
          IMPORTING
            batch                = lv_batch
            batchattributes      = lv_batchatr
          TABLES
            return               = lt_return.

        READ TABLE lt_return INTO ls_return
        WITH KEY type = 'E'.
        IF sy-subrc <> 0.
          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
            EXPORTING
              wait = 'X'.

* GUARDAR LOS CON LOS LOTES CREADOS
          READ TABLE lt_return INTO ls_return
          WITH KEY type = 'S'.
          CLEAR gs_messages.
          gs_messages = ls_return.
          APPEND gs_messages TO gt_messages.

* IMPRIMIMOS UNA ETIQUETA POR CADA LOTE CREADO

          PERFORM imprimir_etiqueta USING lv_batch
                                          gs_pfinal .


        ELSE.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
          LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
            DELETE gt_datos_1000 INDEX sy-tabix.
          ENDLOOP.

* MOSTRAR EL ERROR Y NO DEJAR CONTINUAR LA EJECUCION DEL PROGRAMA
          MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number.

        ENDIF.
      ENDDO.
    ENDLOOP.

  ENDIF.

ENDFORM.                    " CREAR_LOTES


*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta USING  v_charg
                              ls_impr LIKE LINE OF pesada_parcial.


  DATA: lf_formname TYPE fpname VALUE 'ZAF_ETIQUETA_GENERICA_A5'.
  DATA: lf_fm_name TYPE rs38l_fnam.
  DATA: ls_eti TYPE zsmm_etiqueta_generica.
  DATA ls_doc_param TYPE sfpdocparams.
  DATA: lv_matnr TYPE matnr.

* RELLENAR LA ESTRUCTURA A IMPRIMIR
  CLEAR ls_eti.
  ls_eti-matnr = ls_impr-matnr.
  ls_eti-maktx = ls_impr-maktx.
  ls_eti-charg = v_charg.
*  ls_eti-clabs = ls_impr-ktmng.
*  ls_eti-meins = ls_impr-meins.
  ls_eti-lifnr = gv_lifnr.
  ls_eti-name1 = gv_name1.
  ls_eti-lwedt = gv_bldat.
  ls_eti-lgort = ls_impr-lgort.
*  ls_eti-licha = .

  SELECT SINGLE lgobe INTO ls_eti-lgobe
  FROM t001l
  WHERE werks = gc_werks
  AND lgort = ls_impr-lgort.

  CLEAR lv_matnr.
  lv_matnr = ls_impr-matnr.
*  CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
*    EXPORTING
*      input  = ls_impr-matnr
*    IMPORTING
*      output = lv_matnr.

  CONCATENATE lv_matnr v_charg INTO ls_eti-cod_barras.

  IF gs_output_param IS INITIAL.
    CLEAR gs_output_param.
    gs_output_param-dest = 'LP01'.
    gs_output_param-reqimm = 'X'.

  ELSE.
    gs_output_param-nodialog = 'X'.
  ENDIF.


  CALL FUNCTION 'FP_JOB_OPEN'
    CHANGING
      ie_outputparams = gs_output_param
    EXCEPTIONS
      cancel          = 1
      usage_error     = 2
      system_error    = 3
      internal_error  = 4
      OTHERS          = 5.

*&---- Get the name of the generated function module
  CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
    EXPORTING
      i_name     = lf_formname
    IMPORTING
      e_funcname = lf_fm_name.


  CALL FUNCTION lf_fm_name
    EXPORTING
      /1bcdwb/docparams = ls_doc_param
      ls_eti            = ls_eti
* IMPORTING
*     /1BCDWB/FORMOUTPUT       =
    EXCEPTIONS
      usage_error       = 1
      system_error      = 2
      internal_error    = 3
      OTHERS            = 4.

* Close spool job
  CALL FUNCTION 'FP_JOB_CLOSE'
*   IMPORTING
*     E_RESULT             = result
    EXCEPTIONS
      usage_error    = 1
      system_error   = 2
      internal_error = 3
      OTHERS         = 4.

ENDFORM.                    " IMPRIMIR_ETIQUETA

*&---------------------------------------------------------------------*
*&      Form  REIMPRIMIR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_E_UCOMM  text
*----------------------------------------------------------------------*
FORM reimprimir  USING  e_ucomm.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  DATA: lf_formname TYPE fpname VALUE 'ZAF_ETIQUETA_GENERICA'.
  DATA: lf_fm_name TYPE rs38l_fnam.
  DATA: ls_eti TYPE zsmm_etiqueta_generica.
  DATA ls_doc_param TYPE sfpdocparams.
  DATA: lv_licha TYPE lichn.
  DATA: lt_mch1 LIKE mch1 OCCURS 0,
        ls_mch1 TYPE mch1.
  DATA: lv_matnr TYPE matnr.


  CLEAR lv_licha .
  CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.  " SEPARATED BY '/'.

  CLEAR lt_mch1.
  REFRESH lt_mch1.
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE lt_mch1
    FROM mch1
    WHERE matnr = gs_datos_1000-matnr
    AND licha = lv_licha.

  LOOP AT lt_mch1 INTO ls_mch1.

* RELLENAR LA ESTRUCTURA A IMPRIMIR
    CLEAR ls_eti.
    ls_eti-matnr = gs_datos_1000-matnr.
    ls_eti-maktx = gs_datos_1000-maktx.

    ls_eti-charg = ls_mch1-charg.
*  ls_eti-clabs = ls_impr-matnr.
*  ls_eti-meins = ls_impr-matnr.
    ls_eti-lifnr = gv_lifnr.
    ls_eti-name1 = gv_name1.
    ls_eti-lwedt = gv_bldat.
    ls_eti-lgort = gs_datos_1000-lgort.
*  ls_eti-licha = .

    SELECT SINGLE lgobe INTO ls_eti-lgobe
    FROM t001l
    WHERE werks = gc_werks
    AND lgort = gs_datos_1000-lgort.

    CLEAR lv_matnr.
    CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
      EXPORTING
        input  = gs_datos_1000-matnr
      IMPORTING
        output = lv_matnr.

    CONCATENATE lv_matnr ls_mch1-charg INTO ls_eti-cod_barras.

    IF sy-tabix = 1.
      CLEAR gs_output_param.
      gs_output_param-dest = 'LP01'.
      gs_output_param-reqimm = 'X'.
*  gs_output_param-copies = gs_datos_1000-ftanzpk.
    ELSE.
      gs_output_param-nodialog = 'X'.
    ENDIF.


    CALL FUNCTION 'FP_JOB_OPEN'
      CHANGING
        ie_outputparams = gs_output_param
      EXCEPTIONS
        cancel          = 1
        usage_error     = 2
        system_error    = 3
        internal_error  = 4
        OTHERS          = 5.

*&---- Get the name of the generated function module
    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
      EXPORTING
        i_name     = lf_formname
      IMPORTING
        e_funcname = lf_fm_name.


    CALL FUNCTION lf_fm_name
      EXPORTING
        /1bcdwb/docparams = ls_doc_param
        ls_eti            = ls_eti
* IMPORTING
*       /1BCDWB/FORMOUTPUT       =
      EXCEPTIONS
        usage_error       = 1
        system_error      = 2
        internal_error    = 3
        OTHERS            = 4.

* Close spool job
    CALL FUNCTION 'FP_JOB_CLOSE'
*   IMPORTING
*     E_RESULT             = result
      EXCEPTIONS
        usage_error    = 1
        system_error   = 2
        internal_error = 3
        OTHERS         = 4.

  ENDLOOP.

ENDFORM.                    " REIMPRIMIR

*&---------------------------------------------------------------------*
*&      Form  CREAR_PEDIDO_COMPRAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_pedido_compras .

  DATA: ls_header      TYPE bapimepoheader,
        ls_headerx     TYPE bapimepoheaderx,
        lt_return      LIKE bapiret2 OCCURS 0,
        ls_return      TYPE bapiret2,
        lt_item        LIKE bapimepoitem OCCURS 0,
        ls_item        TYPE bapimepoitem,
        lt_itemx       LIKE bapimepoitemx OCCURS 0,
        ls_itemx       TYPE bapimepoitemx,
        lt_condheader  LIKE bapimepocondheader OCCURS 0,
        ls_condheader  TYPE bapimepocondheader,
        lt_condheaderx LIKE bapimepocondheaderx OCCURS 0,
        ls_condheaderx TYPE bapimepocondheaderx,
        lt_cond        LIKE bapimepocond OCCURS 0,
        ls_cond        TYPE bapimepocond,
        lt_condx       LIKE bapimepocondx OCCURS 0,
        ls_condx       TYPE bapimepocondx,
        lt_textitem    LIKE bapimepotext OCCURS 0,
        ls_textitem    TYPE bapimepotext.

  DATA: lv_ebeln  LIKE bapimepoheader-po_number,
        lo_header TYPE bapimepoheader,
        lo_eikp   LIKE bapieikp.
  DATA: lv_lifnr TYPE elifn.

  DATA: ls_cab06 TYPE ztmm0006.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = gv_lifnr
    IMPORTING
      output = lv_lifnr.


  CLEAR: ls_header, ls_headerx.
  ls_header-comp_code = gc_bukrs.
  ls_headerx-comp_code = 'X'.
  ls_header-doc_type = gc_bsart.
  ls_headerx-doc_type = 'X'.
  ls_header-vendor = lv_lifnr.
  ls_headerx-vendor = 'X'.
  ls_header-purch_org = gc_ekorg.
  ls_headerx-purch_org = 'X'.
  ls_header-pur_group = gc_ekgrp.
  ls_headerx-pur_group = 'X'.
  ls_header-doc_date = gv_bldat.
  ls_headerx-doc_date = 'X'.


  REFRESH: lt_condheader, lt_condheaderx.
  IF gv_transito = 'X'.
    CLEAR: lt_condheader, ls_condheader, ls_condheaderx, lt_condheaderx.


    ls_condheader-cond_st_no = '001'.
    ls_condheaderx-cond_st_no = 'X'.
    ls_condheader-cond_type = 'ZTRA'.
    ls_condheaderx-cond_type = 'X'.
*    ls_condheader-cond_value  = '001'.
    ls_condheader-currency = 'EUR'.
    ls_condheaderx-currency = 'X'.
    ls_condheader-currency_iso  = 'EUR'.
    ls_condheaderx-currency_iso  = 'X'.
    ls_condheader-change_id = 'I'.
    ls_condheaderx-change_id = 'X'.

    APPEND ls_condheader TO lt_condheader.
    APPEND ls_condheaderx TO lt_condheaderx.
  ENDIF.

* En caso de que se haya rellenado el transportista
  IF NOT gv_transp IS INITIAL .
    CLEAR: ls_condheader, ls_condheaderx.

    READ TABLE lt_condheader INTO ls_condheader
    INDEX 1.
    IF sy-subrc = 0.
      CLEAR ls_condheader.
      ls_condheader-cond_st_no = '002'.
      ls_condheaderx-cond_st_no = 'X'.
    ELSE.
      CLEAR ls_condheader.
      ls_condheader-cond_st_no = '001'.
      ls_condheaderx-cond_st_no = 'X'.
    ENDIF.

    ls_condheader-cond_type = 'ZFR1'.
    ls_condheaderx-cond_type = 'X'.
    ls_condheader-cond_value  = gv_kbetr.
    ls_condheaderx-cond_value  = 'X'.
    ls_condheader-currency = gv_konwa.
    ls_condheaderx-currency = 'X'.
    ls_condheader-currency_iso  = gv_konwa.
    ls_condheaderx-currency_iso  = 'X'.
    ls_condheader-change_id = 'I'.
    ls_condheaderx-change_id = 'X'.

    APPEND ls_condheader TO lt_condheader.
    APPEND ls_condheaderx TO lt_condheaderx.

  ENDIF.

  CLEAR: lt_item, lt_itemx, ls_item, ls_itemx, ls_textitem, ls_cond, ls_condx.
  REFRESH: lt_item, lt_itemx, lt_textitem, lt_cond, lt_condx.
  LOOP AT gt_datos_1000 INTO gs_datos_1000.
    CLEAR: ls_item, ls_itemx.
    ls_item-po_item = gs_datos_1000-posnr.
    ls_itemx-po_item = gs_datos_1000-posnr.
    ls_item-material = gs_datos_1000-matnr.
    ls_itemx-material = 'X'.
    ls_item-plant = gc_werks.
    ls_itemx-plant = 'X'.
    ls_item-stge_loc = gs_datos_1000-lgort.
    ls_itemx-stge_loc = 'X'.
    ls_item-quantity = gs_datos_1000-menge.
    ls_itemx-quantity = 'X'.
    ls_item-agreement = gs_datos_1000-ebeln.
    ls_itemx-agreement = 'X'.
    ls_item-agmt_item = gs_datos_1000-ebelp.
    ls_itemx-agmt_item = 'X'.

    APPEND ls_item TO lt_item.
    APPEND ls_itemx TO lt_itemx.

* TEXTO DISCONFORMIDAD
    IF gs_datos_1000-zdisconformidad = 'X'.
      CLEAR ls_textitem.
      ls_textitem-po_item = gs_datos_1000-posnr.
      ls_textitem-text_id = 'F01'.
      ls_textitem-text_line = 'Posición con disconformidad'.
      APPEND ls_textitem TO lt_textitem.
    ENDIF.

* EN CASO DE ACCEDER POR LA TRANSACCION DEL SUPERVISOR SE PASAN LOS PRECIOS
* POR SI HAN SIDO MODIFICADOS
    IF sy-tcode = 'ZMM0004'.
      ls_cond-itm_number = gs_datos_1000-posnr.
      ls_condx-itm_number = gs_datos_1000-posnr.
      ls_cond-cond_st_no = '001'.
      ls_condx-cond_st_no = 'X'.
      ls_cond-cond_type = 'PB00'.
      ls_condx-cond_type = 'X'.
      ls_cond-cond_value = gs_datos_1000-netpr.
      ls_condx-cond_value = 'X'.
      ls_cond-currency = gs_datos_1000-waers.
      ls_condx-currency = 'X'.
      ls_cond-currency_iso = gs_datos_1000-waers.
      ls_condx-currency_iso = 'X'.
      ls_cond-cond_unit = 1.
      ls_condx-cond_unit = 'X'.
      ls_cond-cond_unit = 1.
      ls_condx-cond_unit = 'X'.
      ls_cond-change_id = 'U'.
      ls_condx-change_id = 'X'.
      APPEND ls_cond TO lt_cond.
    ENDIF.

  ENDLOOP.


  CLEAR gv_ebeln.

  CALL FUNCTION 'BAPI_PO_CREATE1'
    EXPORTING
      poheader          = ls_header
      poheaderx         = ls_headerx
*     POADDRVENDOR      =
*     TESTRUN           =
*     MEMORY_UNCOMPLETE =
*     MEMORY_COMPLETE   =
*     POEXPIMPHEADER    =
*     POEXPIMPHEADERX   =
*     VERSIONS          =
*     NO_MESSAGING      =
*     NO_MESSAGE_REQ    =
*     NO_AUTHORITY      =
*     NO_PRICE_FROM_PO  =
*     PARK_COMPLETE     =
*     PARK_UNCOMPLETE   =
    IMPORTING
      exppurchaseorder  = gv_ebeln
      expheader         = lo_header
      exppoexpimpheader = lo_eikp
    TABLES
      return            = lt_return
      poitem            = lt_item
      poitemx           = lt_itemx
*     POADDRDELIVERY    =
*     POSCHEDULE        =
*     POSCHEDULEX       =
*     POACCOUNT         =
*     POACCOUNTPROFITSEGMENT       =
*     POACCOUNTX        =
      pocondheader      = lt_condheader
      pocondheaderx     = lt_condheaderx
      pocond            = lt_cond
      pocondx           = lt_condx
*     POLIMITS          =
*     POCONTRACTLIMITS  =
*     POSERVICES        =
*     POSRVACCESSVALUES =
*     POSERVICESTEXT    =
*     EXTENSIONIN       =
*     EXTENSIONOUT      =
*     POEXPIMPITEM      =
*     POEXPIMPITEMX     =
*     POTEXTHEADER      =
      potextitem        = lt_textitem
*     ALLVERSIONS       =
*     POPARTNER         =
*     POCOMPONENTS      =
*     POCOMPONENTSX     =
*     POSHIPPING        =
*     POSHIPPINGX       =
*     POSHIPPINGEXP     =
*     SERIALNUMBER      =
*     SERIALNUMBERX     =
*     INVPLANHEADER     =
*     INVPLANHEADERX    =
*     INVPLANITEM       =
*     INVPLANITEMX      =
    .

  READ TABLE lt_return INTO ls_return
  WITH KEY type = 'E'.
  IF sy-subrc <> 0.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

* GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    READ TABLE lt_return INTO ls_return
    WITH KEY type = 'S'.
    CLEAR gs_messages.
    gs_messages = ls_return.
    APPEND gs_messages TO gt_messages.

* ACTUALIZAMOS LA TABLA DE CABECERA COMO CONTABILIZADA
    SELECT SINGLE * INTO ls_cab06
        FROM ztmm0006
        WHERE zentrada = gv_entrada.
    IF sy-subrc = 0.
      ls_cab06-zcontabilizado = 'X'.
      UPDATE ztmm0006 FROM ls_cab06.
    ENDIF.

*    gv_ebeln = lo_header-po_number.
  ELSE.
* REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

  ENDIF.


ENDFORM.                    " CREAR_PEDIDO_COMPRAS

*&---------------------------------------------------------------------*
*&      Form  CREAR_ENTRADA_MERCANCIAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_entrada_mercancias .

  DATA: ls_header   TYPE bapi2017_gm_head_01,
        ls_code     TYPE bapi2017_gm_code,
        lt_item     LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item     TYPE bapi2017_gm_item_create,
        lt_return   LIKE bapiret2 OCCURS 0,
        ls_return   TYPE bapiret2,
        ls_headret  TYPE bapi2017_gm_head_ret,
        lv_document TYPE bapi2017_gm_head_ret-mat_doc,
        lv_year     TYPE bapi2017_gm_head_ret-doc_year.
  DATA: lv_licha TYPE lichn.
  DATA: ls_mch1 TYPE mch1.

  DATA: ls_cab06 TYPE ztmm0006.

  CLEAR ls_header.
  ls_header-pstng_date = gv_budat.
  ls_header-doc_date = gv_bldat.
  ls_header-ref_doc_no = gv_xblnr.
  IF NOT gv_matricula1 IS INITIAL OR NOT gv_matricula2 IS INITIAL.
    CONCATENATE gv_matricula1 gv_matricula2 INTO ls_header-bill_of_lading SEPARATED BY '/'.
  ENDIF.
  ls_header-header_txt = gv_bktxt.

  CLEAR ls_code.
  ls_code-gm_code = '01'.

  CLEAR: lt_item, ls_item.
  REFRESH lt_item.
  LOOP AT gt_datos_1000 INTO gs_datos_1000.
    CLEAR lv_licha.
    CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.
    SELECT * INTO ls_mch1
    FROM mch1
    WHERE licha = lv_licha.

      ls_item-material = ls_mch1-matnr.
      ls_item-plant = gc_werks.
      ls_item-stge_loc = gs_datos_1000-lgort.
      ls_item-batch = ls_mch1-charg.
      ls_item-move_type = '101'.
      ls_item-entry_qnt = gs_datos_1000-menge / gs_datos_1000-ftanzpk.
      ls_item-po_number = gv_ebeln.
      SELECT SINGLE ebelp INTO ls_item-po_item
      FROM ekpo
      WHERE ebeln = gv_ebeln
      AND matnr = ls_mch1-matnr
      AND lgort = gs_datos_1000-lgort.

      ls_item-mvt_ind = 'B'.
*      IF gs_datos_1000-zdisconformidad = 'X'.
*        ls_item-item_text = 'X'.
*      ENDIF.

      APPEND ls_item TO lt_item.
      CLEAR ls_item.

    ENDSELECT.
  ENDLOOP.

  CLEAR: ls_headret, lv_document, lv_year.

  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = ls_code
*     TESTRUN          = ' '
*     GOODSMVT_REF_EWM =
    IMPORTING
      goodsmvt_headret = ls_headret
      materialdocument = lv_document
      matdocumentyear  = lv_year
    TABLES
      goodsmvt_item    = lt_item
*     GOODSMVT_SERIALNUMBER         =
      return           = lt_return
*     GOODSMVT_SERV_PART_DATA       =
*     EXTENSIONIN      =
    .

  READ TABLE lt_return INTO ls_return
  WITH KEY type = 'E'.
  IF sy-subrc <> 0.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

* modificar la tabla como contabilizada
    CLEAR ls_cab06.
    SELECT SINGLE * INTO ls_cab06
    FROM ztmm0006
    WHERE zentrada = gv_entrada.
    IF sy-subrc = 0.
      ls_cab06-zcontabilizado = 'X'.
      UPDATE ztmm0006 FROM ls_cab06.
    ENDIF.

* GUARDAR LOS CON LOS LOTES CREADOS
    CLEAR gs_messages.
    gs_messages-type = 'S'.
    gs_messages-id = 'ZMM'.
    gs_messages-number = '027'.
    gs_messages-message = text-005.
*    gs_messages-log_no = .
*    gs_messages-log_msg_no = .
    gs_messages-message_v1 = lv_document.
    gs_messages-message_v2 = lv_year.
*    gs_messages-message_v3 = .
*    gs_messages-message_v4 = .
    APPEND gs_messages TO gt_messages.

  ELSE.
* REGISTRAR ERROR EN CASO DE NO CREACION DEL LOTE
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

* COMPROBAR SI SE HA CREADO EL PEDIDO PERO NO LA ENTRADA DE MERCANCIA
    IF NOT gv_ebeln IS INITIAL.
      CLEAR gs_messages.
      gs_messages-type = 'W'.
      gs_messages-id = 'ZMM'.
      gs_messages-number = '051'.
      gs_messages-message = text-008.
*    gs_messages-log_no = .
*    gs_messages-log_msg_no = .
      gs_messages-message_v1 = gv_ebeln.
*    gs_messages-message_v2 = .
*    gs_messages-message_v3 = .
*    gs_messages-message_v4 = .
      APPEND gs_messages TO gt_messages.

    ENDIF.

  ENDIF.

ENDFORM.                    " CREAR_ENTRADA_MERCANCIAS


*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_log .

  CALL FUNCTION 'C14ALD_BAPIRET2_SHOW'
    TABLES
      i_bapiret2_tab = gt_messages.


** Mostramos el LOG de errores
*  CALL FUNCTION 'ZMOSTRAR_ALV_MENSAJES'
*    EXPORTING
*      i_title     = 'Log de Errores'(105)
*    TABLES
*      it_messages = gt_messages.

ENDFORM.                    " MOSTRAR_LOG

*&---------------------------------------------------------------------*
*&      Form  COMPROBACION_CANTIDAD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM comprobacion_cantidad .

  CLEAR gs_datos_1000.
  READ TABLE gt_datos_1000 INTO gs_datos_1000
  WITH KEY ztipo_pesada = 'F'.
  IF sy-subrc = 0 AND gv_ntgew IS INITIAL.
    MESSAGE e028 DISPLAY LIKE 'I'.
  ENDIF.

ENDFORM.                    " COMPROBACION_CANTIDAD

*&---------------------------------------------------------------------*
*&      Form  PESO_CAMION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM peso_camion .
  DATA: lv_return TYPE c,
        lt_fields LIKE sval OCCURS 0,
        ls_fields TYPE sval.

  CLEAR: ls_fields, lv_return.
  ls_fields-tabname = 'EKPO'.
  ls_fields-fieldname = 'NTGEW'.
  APPEND ls_fields TO lt_fields.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-006
*     START_COLUMN    = '5'
*     START_ROW       = '5'
    IMPORTING
      returncode      = lv_return
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
  CLEAR ls_fields.
  READ TABLE lt_fields INTO ls_fields
  INDEX 1.
  gv_ntgew = ls_fields-value.
  IF NOT gv_ntgew IS INITIAL.
    PERFORM repartir_peso_camion.
  ENDIF.


ENDFORM.                    " PESO_CAMION

*&---------------------------------------------------------------------*
*&      Form  REPARTIR_PESO_CAMION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM repartir_peso_camion .

  DATA: lv_index LIKE sy-tabix.

  DATA: lv_ntgew_n TYPE entge.
  DATA: lv_bultos_tot TYPE ftanzpk.

  CLEAR gs_datos_1000.
  READ TABLE gt_datos_1000 INTO gs_datos_1000
  WITH KEY ztipo_pesada = 'F'.

* REVISAR QUE SE GUARDE O CONTABILICE CON EL PESO DEL CAMION RELLENO
* EN CASO DE TENER UNA PESADA FINAL
  IF gv_okcode2 = 'BTN_SAVE' OR gv_okcode2 = 'BTN_CONT'.

    CLEAR gs_datos_1000.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY ztipo_pesada = 'F'.
    IF sy-subrc = 0 AND gv_ntgew IS INITIAL.
      MESSAGE e028.
    ENDIF.

  ENDIF.

* calculamos el peso neto de la pesada final,
* restando el peso del camion al peso de la mercancia + camion
  CLEAR lv_ntgew_n.
  lv_ntgew_n = gs_datos_1000-ntgew - gv_ntgew.

* CALCUALMOS EL NUMERO TOTAL DE BULTOS
  CLEAR lv_bultos_tot.
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE ztipo_pesada = 'F'.
    lv_bultos_tot = lv_bultos_tot + gs_datos_1000-ftanzpk.
  ENDLOOP.

* REPARTIR EL PESO DE LA PESADA FINAL
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ftanzpk IS INITIAL
                                             AND ztipo_pesada = 'F'.
    lv_index = sy-tabix.
    gs_datos_1000-ktmng = ( gs_datos_1000-ftanzpk * lv_ntgew_n ) / lv_bultos_tot.
    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
  ENDLOOP.

* CALCULAR LA CANTIDAD CON EL PORCENTAJE DE HUMIDAD
  IF NOT gv_bvvrel IS INITIAL AND NOT gt_datos_1000[] IS INITIAL.
    CLEAR lv_index.
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-menge = ( gs_datos_1000-ktmng * gv_bvvrel ) / 100.
      gs_datos_1000-menge = gs_datos_1000-ktmng - gs_datos_1000-menge.
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.
  ELSE.
    CLEAR lv_index.
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-menge = gs_datos_1000-ktmng .
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.

  ENDIF.

ENDFORM.                    " REPARTIR_PESO_CAMION

*&---------------------------------------------------------------------*
*&      Form  DUPLICAR_LINEA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM duplicar_linea USING lv_dynpro.

* Llenar la tabla pesadas con la linea a duplicar
  IF lv_dynpro = '3000'.
    LOOP AT lt_sel_rows INTO ls_selected_line.
      READ TABLE gt_pparcial INTO gs_pparcial
      INDEX ls_selected_line-row_id.
      IF sy-subrc = 0.
        CLEAR: gs_pparcial-ktmng, gs_pparcial-ftanzpk, gs_pparcial-lgort.
        APPEND gs_pparcial TO gt_pparcial.
      ENDIF.

    ENDLOOP.

  ELSEIF lv_dynpro = '4000'.
    LOOP AT lt_sel_rows INTO ls_selected_line.
      READ TABLE gt_pfinal INTO gs_pfinal
      INDEX ls_selected_line-row_id.
      IF sy-subrc = 0.
        CLEAR: gs_pfinal-ktmng, gs_pfinal-ftanzpk, gs_pfinal-lgort.
        APPEND gs_pfinal TO gt_pfinal.
      ENDIF.

    ENDLOOP.
  ENDIF.

  MESSAGE s044.

ENDFORM.                    " DUPLICAR_LINEA

*&---------------------------------------------------------------------*
*&      Form  SELECCIONAR_DATOS_SUP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM seleccionar_datos_sup .

  DATA: lv_index LIKE sy-tabix.

  gv_entrada = gs_supervisor-zentrada.

* SELECCIONAMOS CABECERA
  SELECT SINGLE bldat budat lifnr xblnr ztransito bktxt ztransportista zmatricula1 zmatricula2
    zhumedad ntgew zcontabilizado
  INTO (gv_bldat, gv_budat, gv_lifnr, gv_xblnr, gv_transito, gv_bktxt, gv_transp, gv_matricula1,
        gv_matricula2, gv_bvvrel, gv_ntgew, gv_contabilizado)
  FROM ztmm0006
  WHERE zentrada = gs_supervisor-zentrada.

* SELECCIONAMOS POSICCIONES
  SELECT *
   INTO CORRESPONDING FIELDS OF TABLE gt_datos_1000
   FROM ztmm0007
   WHERE zentrada = gs_supervisor-zentrada.

  LOOP AT gt_datos_1000 INTO gs_datos_1000.
    lv_index = sy-tabix.
    SELECT SINGLE maktx INTO gs_datos_1000-maktx
    FROM makt
    WHERE matnr = gs_datos_1000-matnr
    AND spras = sy-langu.
    gs_datos_1000-zcontabilizado = gv_contabilizado.
    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.

  ENDLOOP.


ENDFORM.                    " SELECCIONAR_DATOS_SUP


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos6 .

  CLEAR gt_supervisor.
  REFRESH gt_supervisor.

  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_supervisor
  FROM ztmm0006
  INNER JOIN ztmm0007 ON ztmm0006~zentrada = ztmm0007~zentrada
  WHERE ztmm0006~zentrada IN s_entra
  AND ztmm0006~lifnr      IN s_lifnr
  AND ztmm0006~bldat      IN s_bldat
    AND ztmm0006~budat      IN s_budat
    AND ztmm0006~xblnr      IN s_xblnr
    AND ztmm0006~bktxt      IN s_bktxt
    AND ztmm0006~ztransito      IN s_ztran
    AND ztmm0006~zhumedad     IN s_zhum
    AND ztmm0006~ztransportista      IN s_ztrans
    AND ztmm0006~zmatricula1      IN s_zmatr1
    AND ztmm0006~zmatricula2      IN s_zmatr2
    AND ztmm0007~matnr      IN s_matnr
    AND ztmm0007~znum_pesada      IN s_znpes
    AND ztmm0007~lgort     IN s_lgort
    AND ztmm0007~ebeln      IN s_ebeln
    AND ztmm0006~zcontabilizado      IN s_zconta.

ENDFORM.                    " RECUPERAR_DATOS6

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos6 .

  DATA: ls_variant6 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat6.


* Para que muestre el ancho de las columnas optimizado
*  t_layout6-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout6-stylefname = 'CELLTAB'.
  t_layout6-sel_mode   = 'A'.

  ls_variant6-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid6->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID6'
      is_layout            = t_layout6
      is_variant           = ls_variant6
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_supervisor[]
      it_fieldcatalog      = gti_fieldcat6.

  SET HANDLER
*              g_application6->handle_menu_button
*              g_application6->handle_user_command
              g_application6->handle_hotspot_click FOR grid6.
*              g_application6->handle_toolbar FOR grid6.
*  SET HANDLER g_application6->handle_data_changed_finished FOR grid6.

ENDFORM.                    " MOSTRAR_DATOS6


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat6 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID6'
    CHANGING
      ct_fieldcat      = gti_fieldcat6.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat6 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZENTRADA'.
        ls_fieldcat-hotspot = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat6 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT6
