*&---------------------------------------------------------------------*
*&  Include           ZRMM0002_FORM
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  CARGAR_PANTALLA_1000
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM cargar_pantalla_1000 .

  DATA: lv_lifnr TYPE elifn,
*        ls_a903  TYPE a903,     "ya no se utiliza
        ls_a924  TYPE a924.
*        ls_a909  TYPE a909.

  DATA: lv_prov TYPE lifnr.

  CLEAR gv_id_reg_vehi.

* INI CMS - 17/08/2020 - 52522 - enlace con Registro de Vehículos

  DATA: l_werks      TYPE werks_d,
        l_peso_bruto TYPE char17,
        l_tara_bruta TYPE char17.


  IF gv_sw_reg_vehi = ' '.

    GET PARAMETER ID: 'ZREG_VEHIWERKS'           FIELD l_werks.

    IF l_werks IS NOT INITIAL.

      gv_werks = l_werks.









      GET PARAMETER ID: 'ZVEHI_TRANS'         FIELD gv_transp,
                        'ZVEHI_MAT1'          FIELD gv_matricula1,
                        'ZVEHI_MAT2'          FIELD gv_matricula2,
                        'ZVEHI_ALB'           FIELD gv_xblnr,
                        'ZVEHI_PESOBRUTO'     FIELD l_peso_bruto.

      SET PARAMETER ID: 'ZREG_VEHIWERKS'      FIELD space,
                        'ZVEHI_TRANS'         FIELD space,
                        'ZVEHI_MAT1'          FIELD space,
                        'ZVEHI_MAT2'          FIELD space,
                        'ZVEHI_ALB'           FIELD space,
                        'ZVEHI_PESOBRUTO'     FIELD space.

      gv_sw_reg_vehi = 'X'.
      gv_regvehi_pesobru = CONV #( l_peso_bruto ).
    ENDIF.
  ENDIF.

  DATA: l_tara_alfa TYPE char17,
        l_tara      TYPE menge_d.

  IF sy-tcode = 'ZMM0004_REG_VEH'.







    GET PARAMETER ID: 'ZVEHI_SAL_ID'      FIELD gs_supervisor-zentrada,
                      'ZVEHI_SAL_WERKS'   FIELD gv_werks,
                      'ZVEHI_SAL_NUMPES'  FIELD gs_supervisor-znum_pesada,
                      'ZVEHI_SAL_TARA'    FIELD l_tara_alfa.

    gv_bukrs = gv_werks.
    l_tara = CONV #( l_tara_alfa ).

    SELECT SINGLE id_reg_vehiculo  INTO g_reg_vehi
      FROM ztmm0006
      WHERE zentrada = gs_supervisor-zentrada.

    PERFORM bloquear USING 'B' gs_supervisor-zentrada space CHANGING sw_ok. " add jtm 07.10.2015
    IF sw_ok EQ 'X'. " add jtm 07.10.2015
*           SELECCIONAMOS DATOS GRABADOS PARA MOSTRAR
      PERFORM seleccionar_datos_sup.

      gv_ntgew = l_tara.

    ENDIF.

  ENDIF.

* FIN CMS - 17/08/2020 - 52522 - enlace con Registro de Vehículos


  IF sy-tcode = 'ZMM0003'.
    gv_bldat = sy-datum.
    gv_budat = sy-datum.

*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
    IF gv_werks IS INITIAL.
*   Obtener el centro y el nombre de este del usuario actual
      CLEAR gv_name1_werks.

      SELECT SINGLE u~parva t~name1 FROM usr05 AS u
      INNER JOIN t001w AS t ON t~werks = u~parva
      INTO (gv_werks, gv_name1_werks)
      WHERE bname = sy-uname AND
      parid = 'WRK'.

    ELSE.
*   Obtener el nombre del centro
      CLEAR gv_name1_werks.

      SELECT SINGLE name1 FROM t001w
      INTO gv_name1_werks
      WHERE werks = gv_werks.
    ENDIF.

    gv_bukrs = gv_werks.
*   SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
  ENDIF.

  CLEAR lv_lifnr.
  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = gv_lifnr
    IMPORTING
      output = lv_lifnr.

  SELECT SINGLE name1 INTO gv_name1
                      FROM lfa1
                      WHERE lifnr = lv_lifnr.

* GST - 02/03/2015 ->
* Inicializar datos transportista:
  IF NOT gv_transp IS INITIAL ."AND gv_kbetr IS INITIAL.

    CLEAR lv_lifnr.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_transp
      IMPORTING
        output = lv_lifnr.

    CLEAR gv_name1_trans.
    SELECT SINGLE name1 INTO gv_name1_trans
    FROM lfa1
    WHERE lifnr = lv_lifnr.

    CLEAR lv_prov.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_lifnr
      IMPORTING
        output = lv_prov.

* INICIO SCT 04.11.2016 se recupera la tarifa de la tabla 909 por centro
*
*    CLEAR ls_a903.
*    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a903
*    FROM a903
**    INNER JOIN lfa1 ON lfa1~lifnr = a903~llief
**                    AND lfa1~llief = a903~llief
*    WHERE a903~kschl = 'ZTTR'
*    AND a903~lifnr = lv_lifnr
*    AND datab <= sy-datum
*    AND datbi >= sy-datum
**      AND a903~lifnr = lv_lifnr
*      AND llief = lv_prov.
*    IF sy-subrc = 0.
*           SELECT SINGLE kbetr konwa kmein kpein INTO (gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
*           FROM konp
*          WHERE knumh = ls_a903-knumh.
*    ENDIF.

* INI UDEFINEDES 25.10.2017 Ticket 44589
*    CLEAR ls_a909.
*    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a909
*    FROM a909
*    WHERE a909~kschl = 'ZTTR'
*    AND a909~lifnr = lv_lifnr     "transportista
*    AND a909~lifnr = gv_werks
*    AND datab <= sy-datum
*    AND datbi >= sy-datum
*    AND llief = lv_prov.          "proveedor recorte
*    IF sy-subrc = 0.
*      SELECT SINGLE kbetr konwa kmein kpein INTO (gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
*               FROM konp
*              WHERE knumh = ls_a909-knumh.
*    ENDIF.
    CLEAR: gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein, ls_a924.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a924
    FROM a924
    WHERE a924~kschl = 'ZTTR'
    AND a924~lifnr = lv_lifnr        "transportista
    AND a924~werks = gv_werks
    AND datab <= sy-datum
    AND datbi >= sy-datum
    AND llief = lv_prov               "proveedor recorte
    AND zzptorec = gv_zzptorec.
    IF sy-subrc = 0.
      SELECT SINGLE kschl kbetr konwa kmein kpein INTO
        (gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
               FROM konp
               WHERE knumh = ls_a924-knumh AND loevm_ko EQ abap_false.

    ELSE.

      CLEAR ls_a924.
      SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a924
      FROM a924
      WHERE a924~kschl = 'ZTT2'
      AND a924~lifnr = lv_lifnr        "transportista
      AND a924~werks = gv_werks
      AND datab <= sy-datum
      AND datbi >= sy-datum
      AND llief = lv_prov             "proveedor recorte
      AND zzptorec = gv_zzptorec.
      IF sy-subrc = 0.
        SELECT SINGLE kschl kbetr konwa kmein kpein INTO
          (gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
                 FROM konp
                 WHERE knumh = ls_a924-knumh AND loevm_ko EQ abap_false.
* FIN UDEFINEDES
      ENDIF.
    ENDIF.
* FIN SCT 04.11.2016

  ENDIF.
* GST - 02/03/2015 <-
  DATA: l_transp TYPE lifnr.
  IF gs_residuos-trans_residuos IS NOT INITIAL.

    l_transp = |{ gs_residuos-trans_residuos ALPHA = IN }|.
*    CALL METHOD zcl_utils_hpap_pp=>get_descrip_proveedor
*      EXPORTING
*        i_lifnr = l_transp
*      RECEIVING
*        r_name1 = gs_residuos-desc_trans_res.
    SELECT SINGLE nombre
      INTO  @gs_residuos-desc_trans_res
      FROM ztpp0065
      WHERE tp_gestor = 'TR'       AND
            werks     = @gv_werks  AND
            cir       = @gs_residuos-trans_residuos AND
            lvorm     = ' '.
    IF sy-subrc <> 0.
      CLEAR gs_residuos-desc_trans_res.

    ENDIF.
  ELSE.
    CLEAR gs_residuos-desc_trans_res.
  ENDIF.

ENDFORM.                    " CARGAR_PANTALLA_1000

*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos.

ENDFORM.                    " RECUPERAR_DATOS

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos .

  DATA: ls_variant TYPE disvariant.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat.

* Para que muestre el ancho de las columnas optimizado
  t_layout-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout-stylefname = 'CELLTAB'.
  t_layout-sel_mode   = 'A'.

  ls_variant-report   = sy-repid.

* Mostrar alv
  CALL METHOD grid->set_table_for_first_display
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID'
      is_layout        = t_layout
      is_variant       = ls_variant
      i_save           = 'U'
      i_default        = 'X'
    CHANGING
      it_outtab        = gt_datos_1000[]
      it_fieldcatalog  = gti_fieldcat.

  SET HANDLER
*              g_application->handle_menu_button
              g_application->handle_data_changed
              g_application->handle_user_command
              g_application->handle_hotspot_click
              g_application->handle_toolbar FOR grid.

ENDFORM.                    " MOSTRAR_DATOS


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID'
    CHANGING
      ct_fieldcat      = gti_fieldcat.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'LOEKZ'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'ICON_LOEKZ'.
        ls_fieldcat-col_pos = 1.

      WHEN 'MATNR'.
        ls_fieldcat-col_pos = 2.
        ls_fieldcat-outputlen = 12.

      WHEN 'MAKTX'.
        ls_fieldcat-col_pos = 3.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'FTANZPK'.
        ls_fieldcat-col_pos = 4.
        ls_fieldcat-outputlen = 18.
        ls_fieldcat-scrtext_l = 'Nº Balas'.
        ls_fieldcat-scrtext_m = 'Nº Balas'.
        ls_fieldcat-scrtext_s = 'Nº Balas'.
        ls_fieldcat-reptext   = 'Nº Balas'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'LGORT'.
        ls_fieldcat-col_pos = 5.
*        ls_fieldcat-f4availabl = 'X'.
        ls_fieldcat-outputlen = 10.

      WHEN 'BRGEW'.
        ls_fieldcat-col_pos = 6.

      WHEN 'NTGEW'.
        ls_fieldcat-col_pos = 7.
        ls_fieldcat-col_opt = 'X'.
        ls_fieldcat-scrtext_l = 'TARA'.
        ls_fieldcat-scrtext_m = 'TARA'.
        ls_fieldcat-scrtext_s = 'TARA'.
        ls_fieldcat-reptext   = 'TARA'.

      WHEN 'KTMNG'.
        ls_fieldcat-col_pos = 8.
        ls_fieldcat-scrtext_l = 'Peso Neto'.
        ls_fieldcat-scrtext_m = 'Peso Neto'.
        ls_fieldcat-scrtext_s = 'Peso Neto'.
        ls_fieldcat-reptext   = 'Peso Neto'.

      WHEN 'MENGE'.
        ls_fieldcat-col_pos = 9.
        ls_fieldcat-outputlen = 25.
        ls_fieldcat-scrtext_l = 'Peso Neto S/HUM'.
        ls_fieldcat-scrtext_m = 'Peso Neto S/HUM'.
        ls_fieldcat-scrtext_s = 'Peso Neto S/HUM'.
        ls_fieldcat-reptext   = 'Peso Neto S/HUM'.

      WHEN 'ZPESO_FIJADO'.
        ls_fieldcat-col_pos = 10.
*        ls_fieldcat-col_opt = 'X'.
        ls_fieldcat-outputlen = 12.
        ls_fieldcat-scrtext_l = 'Peso Fijado'.
        ls_fieldcat-scrtext_m = 'Peso Fijado'.
        ls_fieldcat-scrtext_s = 'Peso Fijado'.
        ls_fieldcat-reptext   = 'Peso Fijado'.

      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'EBELN'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'EBELP'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'ZNUM_PESADA'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        IF sy-tcode = 'ZMM0003'.
          ls_fieldcat-no_out = 'X'.
* GST - 21/05/2015 ->
        ELSEIF  sy-tcode = 'ZMM0004' AND gv_contabilizado IS INITIAL
                AND gv_ebeln IS INITIAL.
*        ELSEIF  sy-tcode = 'ZMM0004' AND gv_contabilizado IS INITIAL.
* GST - 21/05/2015 <-
          ls_fieldcat-edit = 'X'.
        ENDIF.

      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.



      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-no_out = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT

*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos3.
* cambiar jtm 02.10.2015 7000008127
  PERFORM get_contr_marco TABLES gt_pparcial gt_datos_1000 USING gs_contrato_marco.
*
*  DATA: lv_contratos TYPE i.
*  CLEAR lv_contratos.
*  DATA: lv_answer TYPE c.
*  DATA: lt_spopli LIKE spopli OCCURS 0,
*        ls_spopli TYPE spopli.
*  DATA: lv_index LIKE sy-tabix.
*
*  CLEAR gt_pparcial.
*  REFRESH gt_pparcial.
*
*** SELECCIONAMOS LOS CONTRATOS MARCO PARA UN PROVEEDOR ACTIVOS EN LA FECHA SELECCIONADA
**  CLEAR gt_contrato_marco.
**  REFRESH gt_contrato_marco.
**  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_contrato_marco
**  FROM ekko
**  WHERE lifnr = gv_lifnr
**  AND ( kdatb <= gv_bldat
**  AND kdate >= gv_bldat ).
**
*** MIRAMOS CUANTOS CONTRATOS SE RECUPERAN
**  DESCRIBE TABLE gt_contrato_marco LINES lv_contratos.
**  IF lv_contratos > 1.
*** EN CASO DE SER MAS DE UNO MOSTRAMOS UN POP-UP PARA QUE EL USUARIO SELECCIONE UNO
**    LOOP AT gt_contrato_marco INTO gs_contrato_marco.
**      CONCATENATE gs_contrato_marco-ebeln gs_contrato_marco-kdatb gs_contrato_marco-kdate
**      INTO ls_spopli-varoption SEPARATED BY '-'.
**
**      APPEND ls_spopli TO lt_spopli.
**    ENDLOOP.
**
**    CLEAR lv_answer.
**    CALL FUNCTION 'POPUP_TO_DECIDE_LIST'
**      EXPORTING
***       CURSORLINE         = 1
***       MARK_FLAG          = ' '
***       MARK_MAX           = 1
***       START_COL          = 0
***       START_ROW          = 0
**        textline1          = text-002
***       TEXTLINE2          = ' '
***       TEXTLINE3          = ' '
**        titel              = text-001
***       DISPLAY_ONLY       = ' '
**      IMPORTING
**        answer             = lv_answer
**      TABLES
**        t_spopli           = lt_spopli
**      EXCEPTIONS
**        not_enough_answers = 1
**        too_much_answers   = 2
**        too_much_marks     = 3
**        OTHERS             = 4.
**
**    IF lv_answer <> 'A'.
**      READ TABLE gt_contrato_marco INTO gs_contrato_marco
**      INDEX lv_answer.
**    ENDIF.
**
**
**  ELSEIF lv_contratos = 0.
*** SI NO EXISTE NINGUN CONTRATO MARCO MOSTRAMOS UN ERROR
**    MESSAGE e022 WITH gv_lifnr.
**
**  ELSEIF lv_contratos = 1.
*** EN CASO DE SER SOLO UNO LO SELECCIONAMOS
**    READ TABLE gt_contrato_marco INTO gs_contrato_marco
**    INDEX 1.
**  ENDIF.
*
** SELECCIONAMOS LAS POSICIONES DEL CONTRATO MARCO PARA MOSTRAR LOS MATERIALES POSIBLES A PESAR
*  IF NOT gs_contrato_marco-ebeln IS INITIAL.
*
*    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_pparcial
*    FROM ekpo
*    WHERE ebeln = gs_contrato_marco-ebeln
*    AND loekz <> 'L'.
*
*  ENDIF.
*
*  LOOP AT gt_pparcial INTO gs_pparcial.
*    lv_index = sy-tabix.
*
*    SELECT SINGLE maktx INTO gs_pparcial-maktx
*    FROM makt
*    WHERE matnr = gs_pparcial-matnr
*    AND spras = sy-langu.
*    CLEAR gs_pparcial-ktmng.
*
** MONEDA
*    SELECT SINGLE waers INTO gs_pparcial-waers
*    FROM ekko
*    WHERE ebeln = gs_pparcial-ebeln.
*
*    READ TABLE gt_datos_1000 INTO gs_datos_1000
*    WITH KEY matnr = gs_pparcial-matnr.
*    IF sy-subrc <> 0.
*      MODIFY gt_pparcial FROM gs_pparcial.
*    ELSE.
*      DELETE gt_pparcial INDEX lv_index.
*    ENDIF.
*
*  ENDLOOP.

* fin de cambiar jtm 02.10.2015 7000008127

ENDFORM.                    " RECUPERAR_DATOS3

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos3 .

  DATA: ls_variant3 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat3.


* Para que muestre el ancho de las columnas optimizado
*  t_layout3-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout3-stylefname = 'CELLTAB'.
  t_layout3-sel_mode   = 'A'.

  ls_variant3-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid3->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID3'
      is_layout            = t_layout3
      is_variant           = ls_variant3
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_pparcial[]
      it_fieldcatalog      = gti_fieldcat3.

  SET HANDLER
              g_application3->handle_data_changed
              g_application3->handle_user_command
              g_application3->handle_hotspot_click
              g_application3->handle_toolbar FOR grid3.
*  SET HANDLER g_application3->handle_data_changed_finished FOR grid3.

ENDFORM.                    " MOSTRAR_DATOS3


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat3 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID3'
    CHANGING
      ct_fieldcat      = gti_fieldcat3.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat3 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-scrtext_l = 'Disconformidad'.
        ls_fieldcat-scrtext_m = 'Disconformidad'.
        ls_fieldcat-scrtext_s = 'Disconformidad'.
        ls_fieldcat-reptext   = 'Disconformidad'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-checkbox = 'X'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'FTANZPK'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '15'.
*        ls_fieldcat-col_opt = 'X'.
      WHEN 'LGORT'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '10'.
*        ls_fieldcat-f4availabl = 'X'.
      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'MATNR'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'MAKTX'.
        ls_fieldcat-col_opt = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat3 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT3

*&---------------------------------------------------------------------*
*&      Form  TRASPASAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM traspasar_datos USING ok_code.
  DATA: lv_index LIKE sy-tabix.
  DATA: lv_pos TYPE i.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS PARCIALES
  IF  ok_code = 'REG_PES'.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
*    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
*      DELETE gt_datos_1000 INDEX sy-tabix.
*    ENDLOOP.

    CLEAR lv_pos.
    DESCRIBE TABLE gt_datos_1000 LINES lv_pos.
    gv_posnr = lv_pos.

* GUARDAMOS EL CONTADOR DE POSICIONES
    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.
      lv_index = sy-tabix.
      gv_posnr = gv_posnr + 1.
      gs_pparcial-posnr = gv_posnr.
      MODIFY gt_pparcial FROM gs_pparcial INDEX lv_index.
    ENDLOOP.

* TRANSFERIMOS DATOS
    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.

      CLEAR gs_datos_1000.
      gs_datos_1000-posnr = gs_pparcial-posnr.
      gs_datos_1000-matnr = gs_pparcial-matnr.
      gs_datos_1000-maktx = gs_pparcial-maktx.
      gs_datos_1000-znum_pesada = '111'.  "gv_pesada.
      gs_datos_1000-ktmng = gs_pparcial-ktmng.
      gs_datos_1000-brgew = gv_brgew.
      IF NOT gv_bvvrel IS INITIAL.
        gs_datos_1000-menge = ( gs_pparcial-ktmng * gv_bvvrel ) / 100.
        gs_datos_1000-menge = gs_pparcial-ktmng - gs_datos_1000-menge.
      ELSE.
        gs_datos_1000-menge = gs_pparcial-ktmng.
      ENDIF.

      gs_datos_1000-meins = 'KG'.
      gs_datos_1000-ftanzpk = gs_pparcial-ftanzpk.
      gs_datos_1000-lgort = gs_pparcial-lgort.
      gs_datos_1000-ztipo_pesada = 'P'.
      gs_datos_1000-ebeln = gs_pparcial-ebeln.
      gs_datos_1000-ebelp = gs_pparcial-ebelp.
      gs_datos_1000-netpr = gs_pparcial-netpr.
* GST - 02/03/2015 ->
      gs_datos_1000-peinh = gs_pparcial-peinh.
* GST - 02/03/2015 <-
      gs_datos_1000-waers = gs_pparcial-waers.
      gs_datos_1000-ntgew = gv_ntgew.
      gs_datos_1000-zdisconformidad = gs_pparcial-zdisconformidad.

      APPEND gs_datos_1000 TO gt_datos_1000.

    ENDLOOP.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS FINALES
  ELSEIF ok_code = 'BTN_PESF'.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      DELETE gt_datos_1000 INDEX sy-tabix.
    ENDLOOP.

    CLEAR lv_pos.
    DESCRIBE TABLE gt_datos_1000 LINES lv_pos.
    gv_posnr = lv_pos.

* GUARDAMOS EL CONTADOR DE POSICIONES
    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.
      lv_index = sy-tabix.
      gv_posnr = gv_posnr + 1.
      gs_pfinal-posnr = gv_posnr.
      MODIFY gt_pfinal FROM gs_pfinal INDEX lv_index.
    ENDLOOP.

    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.

      CLEAR gs_datos_1000.
      gv_posnr = gv_posnr + 1.
      gs_datos_1000-posnr = gs_pfinal-posnr.
      gs_datos_1000-matnr = gs_pfinal-matnr.
      gs_datos_1000-maktx = gs_pfinal-maktx.
      gs_datos_1000-znum_pesada = gv_pesada.
*      gs_datos_1000-ktmng = gs_pfinal-ktmng.
*      IF NOT gv_bvvrel IS INITIAL.
*        gs_datos_1000-menge = ( gs_pFINAL-ktmng * gv_bvvrel ) / 100.
*      ENDIF.

      gs_datos_1000-meins = 'KG'.
      gs_datos_1000-ftanzpk = gs_pfinal-ftanzpk.
      gs_datos_1000-lgort = gs_pfinal-lgort.
      gs_datos_1000-brgew = gv_brgew.
      gs_datos_1000-ztipo_pesada = 'F'.
      gs_datos_1000-ebeln = gs_pfinal-ebeln.
      gs_datos_1000-ebelp = gs_pfinal-ebelp.
      gs_datos_1000-netpr = gs_pfinal-netpr.
* GST - 02/03/2015 ->
      gs_datos_1000-peinh = gs_pfinal-peinh.
* GST - 02/03/2015 <-
      gs_datos_1000-waers = gs_pfinal-waers.
      gs_datos_1000-ntgew = gv_ntgew.
      gs_datos_1000-zdisconformidad = gs_pfinal-zdisconformidad.

      APPEND gs_datos_1000 TO gt_datos_1000.

    ENDLOOP.

  ENDIF.


ENDFORM.                    " TRASPASAR_DATOS


*&---------------------------------------------------------------------*
*&      Form  REVISAR_ALMACEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM revisar_almacen USING ok_code.

  DATA: ls_mard TYPE mard.
  DATA: lt_pparcial_aux LIKE         pesada_parcial OCCURS 0,
        ls_pparcial_aux LIKE LINE OF lt_pparcial_aux,
        lv_cont         TYPE         i,
        lt_pfinal_aux   LIKE         pesada_parcial OCCURS 0,
        ls_pfinal_aux   LIKE LINE OF lt_pfinal_aux.

* COMPROBAR QUE SE INTRODUZCA EL ALMACEN EN LA PESADA PARCIAL
  IF  ok_code = 'REG_PES'.
* GST - 03/03/2015 ->
    CLEAR lt_pparcial_aux.
    REFRESH lt_pparcial_aux.
    lt_pparcial_aux[] = gt_pparcial[].
* GST - 03/03/2015 <-

    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk  IS INITIAL.
      IF gs_pparcial-lgort IS INITIAL.
        MESSAGE e025 DISPLAY LIKE 'I'.
      ELSE.
        SELECT SINGLE * INTO ls_mard
        FROM mard
        WHERE matnr = gs_pparcial-matnr
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
        AND werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
        AND lgort = gs_pparcial-lgort .
        IF sy-subrc <> 0.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
          MESSAGE e352(m3) WITH gs_pparcial-matnr gs_pparcial-lgort gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*   Material & en el almacén & del centro & no actualizado.
* GST - 03/03/2015 ->
        ELSE.
          CLEAR: ls_pparcial_aux, lv_cont.
          LOOP AT lt_pparcial_aux INTO ls_pparcial_aux
      WHERE ftanzpk IS NOT INITIAL AND "ftanzpk <> gs_pparcial-ftanzpk )
            matnr = gs_pparcial-matnr AND
            lgort = gs_pparcial-lgort.
            lv_cont = lv_cont + 1.
            IF lv_cont > 1.
              MESSAGE e085(zmm).
            ENDIF.
          ENDLOOP.
* GST - 03/03/2015 <-
        ENDIF.
      ENDIF.
    ENDLOOP.

* COMPROBAR QUE SE INTRODUZCA EL ALMACEN EN LA PESADA FINAL
  ELSEIF ok_code = 'BTN_PESF'.
* GST - 03/03/2015 ->
    CLEAR lt_pfinal_aux.
    REFRESH lt_pfinal_aux.
    lt_pfinal_aux[] = gt_pfinal[].
* GST - 03/03/2015 <-

    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk  IS INITIAL.
      IF gs_pfinal-lgort IS INITIAL.
        MESSAGE e025 DISPLAY LIKE 'I'.
      ELSE.
        SELECT SINGLE * INTO ls_mard
        FROM mard
        WHERE matnr = gs_pfinal-matnr
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
        AND werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
        AND lgort = gs_pfinal-lgort .
        IF sy-subrc <> 0.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
          MESSAGE e352(m3) WITH gs_pfinal-matnr gs_pfinal-lgort gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*   Material & en el almacén & del centro & no actualizado.
* GST - 03/03/2015 ->
        ELSE.
          CLEAR: ls_pfinal_aux, lv_cont.
          LOOP AT lt_pfinal_aux INTO ls_pfinal_aux
      WHERE ftanzpk IS NOT INITIAL AND "ftanzpk <> gs_pparcial-ftanzpk )
            matnr = gs_pfinal-matnr AND
            lgort = gs_pfinal-lgort.
            lv_cont = lv_cont + 1.
            IF lv_cont > 1.
              MESSAGE e085(zmm).
            ENDIF.
          ENDLOOP.
* GST - 03/03/2015 <-

        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDIF.

ENDFORM.                    " REVISAR_ALMACEN


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CONTADOR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_contador CHANGING lv_entrada.

  CLEAR lv_entrada.

  CALL FUNCTION 'NUMBER_GET_NEXT'
    EXPORTING
      nr_range_nr             = '01'
      object                  = 'ZC_MM'
      quantity                = '1'
*     SUBOBJECT               = ' '
*     TOYEAR                  = '0000'
*     IGNORE_BUFFER           = ' '
    IMPORTING
      number                  = lv_entrada
*     QUANTITY                =
*     RETURNCODE              =
    EXCEPTIONS
      interval_not_found      = 1
      number_range_not_intern = 2
      object_not_found        = 3
      quantity_is_0           = 4
      quantity_is_not_1       = 5
      interval_overflow       = 6
      buffer_overflow         = 7
      OTHERS                  = 8.


ENDFORM.                    " RECUPERAR_CONTADOR

*&---------------------------------------------------------------------*
*&      Form  GUARDAR_CABECERA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM guardar_cabecera .

  DATA: ls_cab06 TYPE ztmm0006.
  CLEAR ztmm0006.

* SI ACCEDE EL OPERARIO
  IF sy-tcode = 'ZMM0003'.
* GST - 19/05/2015 ->
*    ztmm0006-zentrada = gv_entrada.
*    ztmm0006-xblnr = gv_xblnr.
*    ztmm0006-lifnr = gv_lifnr.
*    ztmm0006-bldat = gv_bldat.
*    ztmm0006-budat = gv_budat.
*    ztmm0006-ztransito = gv_transito.
*    ztmm0006-bktxt = gv_bktxt.
*    ztmm0006-ztransportista = gv_transp.
*    ztmm0006-zmatricula1 = gv_matricula1.
*    ztmm0006-zmatricula2 = gv_matricula2.
*    ztmm0006-zhumedad = gv_bvvrel.
*    ztmm0006-ntgew = gv_ntgew.
*    ztmm0006-brgew = gv_brgew.
** ztmm0006-ZCONTABILIZADO
*    ztmm0006-gewei = 'KG'.
*    ztmm0006-kbetr = gv_kbetr.
*    ztmm0006-konwa = gv_konwa.
*    INSERT ztmm0006.

    CLEAR ls_cab06.
    ls_cab06-zentrada = gv_entrada.
    ls_cab06-xblnr = gv_xblnr.
    ls_cab06-lifnr = gv_lifnr.
    ls_cab06-bldat = gv_bldat.
    ls_cab06-budat = gv_budat.
    ls_cab06-ztransito = gv_transito.
    ls_cab06-bktxt = gv_bktxt.
    ls_cab06-ztransportista = gv_transp.
    ls_cab06-zptorec = gv_zzptorec. "44589
    ls_cab06-zmatricula1 = gv_matricula1.
    ls_cab06-zmatricula2 = gv_matricula2.
    ls_cab06-zhumedad = gv_bvvrel.
    ls_cab06-ntgew = gv_ntgew.
    ls_cab06-brgew = gv_brgew.
* ztmm0006-ZCONTABILIZADO
    ls_cab06-gewei = 'KG'.
    ls_cab06-kbetr = gv_kbetr.
    ls_cab06-konwa = gv_konwa.
    ls_cab06-kpein = gv_kpein. "44589
    ls_cab06-kmein = gv_kmein. "44589
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
    ls_cab06-werks = gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--


* Datos de Registro de residuos

    ls_cab06-trans_residuos       = |{ gs_residuos-trans_residuos ALPHA = IN }|.
    ls_cab06-dir                  = gs_residuos-dir.
    ls_cab06-ler                  = gs_residuos-ler.
    ls_cab06-id_entrada_residuos  = gs_residuos-id_entrada_residuos.

    IF gs_residuos-id_entrada_residuos IS INITIAL .
      PERFORM obtener_id_residuos USING gv_werks
                               CHANGING ls_cab06-id_entrada_residuos.
    ENDIF.

    MODIFY ztmm0006 FROM ls_cab06.


* GST - 19/05/2015 <-
  ENDIF.

* SI ACCEDE EL SUPERVISOR

* 09-11-2020 Acceso para RV
*  IF sy-tcode = 'ZMM0004'.
  IF sy-tcode = 'ZMM0004'  OR sy-tcode = 'ZMM0004_REG_VEH'.
    ls_cab06-ebeln   = gv_ebeln.
    ls_cab06-zentrada = gv_entrada.
    ls_cab06-xblnr = gv_xblnr.
    ls_cab06-lifnr = gv_lifnr.
    ls_cab06-bldat = gv_bldat.
    ls_cab06-budat = gv_budat.
    ls_cab06-ztransito = gv_transito.
    ls_cab06-bktxt = gv_bktxt.
    ls_cab06-ztransportista = gv_transp.
    ls_cab06-zptorec = gv_zzptorec. "44589
    ls_cab06-zmatricula1 = gv_matricula1.
    ls_cab06-zmatricula2 = gv_matricula2.
    ls_cab06-zhumedad = gv_bvvrel.
    ls_cab06-ntgew = gv_ntgew.
    ls_cab06-brgew = gv_brgew.
* ztmm0006-ZCONTABILIZADO
    ls_cab06-gewei = 'KG'.
    ls_cab06-kbetr = gv_kbetr.
    ls_cab06-konwa = gv_konwa.
    ls_cab06-kpein = gv_kpein. "44589
    ls_cab06-kmein = gv_kmein. "44589
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
    ls_cab06-werks = gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--

* Datos de Registro de Vehículos y residuos
    ls_cab06-id_reg_vehiculo = g_reg_vehi.
    ls_cab06-trans_residuos       = |{ gs_residuos-trans_residuos ALPHA = IN }|.
    ls_cab06-dir                  = gs_residuos-dir.
    ls_cab06-ler                  = gs_residuos-ler.
    ls_cab06-id_entrada_residuos  = gs_residuos-id_entrada_residuos.

    UPDATE ztmm0006 FROM ls_cab06.

  ENDIF.

ENDFORM.                    " GUARDAR_CABECERA

*&---------------------------------------------------------------------*
*&      Form  GUARDAR_POSICIONES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM guardar_posiciones .

  DATA: ls_pos07 TYPE ztmm0007,
        lv_index LIKE sy-index.

* SI ACCEDE EL OPERARIO
  IF sy-tcode = 'ZMM0003'.

** GST - 19/05/2015 ->
** PRIMERO BORRAMOS LAS POSICIONES
*    DELETE FROM ztmm0007
*    WHERE zentrada = gv_entrada.
** GST - 19/05/2015 <-

    LOOP AT gt_datos_1000 INTO gs_datos_1000.

      CLEAR: ztmm0007, ls_pos07.
      SELECT SINGLE * INTO ls_pos07
      FROM ztmm0007
      WHERE zentrada = gv_entrada
      AND matnr = gs_datos_1000-matnr.
      IF sy-subrc = 0.
        lv_index = sy-index.

        ls_pos07-zentrada = ls_pos07-zentrada.
        ls_pos07-posnr = ls_pos07-posnr.
        ls_pos07-matnr = ls_pos07-matnr.
        ls_pos07-znum_pesada = gs_datos_1000-znum_pesada.
        ls_pos07-ktmng = gs_datos_1000-ktmng.
        ls_pos07-menge = gs_datos_1000-menge.
        ls_pos07-meins = gs_datos_1000-meins.
        ls_pos07-ftanzpk = gs_datos_1000-ftanzpk.
        ls_pos07-lgort = gs_datos_1000-lgort.
        ls_pos07-ztipo_pesada = gs_datos_1000-ztipo_pesada.
        ls_pos07-netpr = gs_datos_1000-netpr.
        ls_pos07-ntgew = gs_datos_1000-ntgew.
* GST - 02/03/2015 ->
        ls_pos07-brgew = gs_datos_1000-brgew.
        ls_pos07-peinh = gs_datos_1000-peinh.
        ls_pos07-zdisconformidad = gs_datos_1000-zdisconformidad.
* GST - 02/03/2015 <-
        ls_pos07-waers = 'EUR'.
        ls_pos07-ebeln = gs_datos_1000-ebeln.
        ls_pos07-ebelp = gs_datos_1000-ebelp.
        ls_pos07-zpeso_fijado = gs_datos_1000-zpeso_fijado.
        ls_pos07-loekz = gs_datos_1000-loekz.
        ls_pos07-icon_loekz = gs_datos_1000-icon_loekz.

        UPDATE ztmm0007 FROM ls_pos07.



      ELSE.

        ztmm0007-zentrada = gv_entrada.
        ztmm0007-posnr = sy-tabix.
        ztmm0007-matnr = gs_datos_1000-matnr.
        ztmm0007-znum_pesada = gs_datos_1000-znum_pesada.
        ztmm0007-ktmng = gs_datos_1000-ktmng .
        ztmm0007-menge = gs_datos_1000-menge.
        ztmm0007-meins = gs_datos_1000-meins.
        ztmm0007-ftanzpk = gs_datos_1000-ftanzpk.
        ztmm0007-lgort = gs_datos_1000-lgort.
        ztmm0007-ztipo_pesada = gs_datos_1000-ztipo_pesada.
        ztmm0007-netpr = gs_datos_1000-netpr.
        ztmm0007-ntgew = gs_datos_1000-ntgew.
* GST - 02/03/2015 ->
        ztmm0007-brgew = gs_datos_1000-brgew.
        ztmm0007-peinh = gs_datos_1000-peinh.
        ztmm0007-zdisconformidad = gs_datos_1000-zdisconformidad.
* GST - 02/03/2015 <-
        ztmm0007-waers = 'EUR'.
        ztmm0007-ebeln = gs_datos_1000-ebeln.
        ztmm0007-ebelp = gs_datos_1000-ebelp.
        ztmm0007-zpeso_fijado = gs_datos_1000-zpeso_fijado.
        ls_pos07-loekz = gs_datos_1000-loekz.
        ls_pos07-icon_loekz = gs_datos_1000-icon_loekz.

        INSERT ztmm0007.

      ENDIF.


    ENDLOOP.
  ENDIF.


* SI ACCEDE EL SUPERVISOR
*  IF sy-tcode = 'ZMM0004'.
  IF sy-tcode = 'ZMM0004' OR sy-tcode = 'ZMM0004_REG_VEH'.

** PRIMERO BORRAMOS LAS POSICIONES
*    DELETE FROM ztmm0007
*    WHERE zentrada = gv_entrada.

* AHORA CREAMOS DE NUEVO LAS POSICIONES MODIFICADAS
    LOOP AT gt_datos_1000 INTO gs_datos_1000.

      CLEAR: ztmm0007, ls_pos07.
      SELECT SINGLE * INTO ls_pos07
      FROM ztmm0007
      WHERE zentrada = gv_entrada
      AND matnr = gs_datos_1000-matnr.
      IF sy-subrc = 0.

        lv_index = sy-index.

        ls_pos07-zentrada = ls_pos07-zentrada.
        ls_pos07-posnr = ls_pos07-posnr.
        ls_pos07-matnr = ls_pos07-matnr.
        ls_pos07-znum_pesada = gs_datos_1000-znum_pesada.
        ls_pos07-ktmng = gs_datos_1000-ktmng .
        ls_pos07-menge = gs_datos_1000-menge.
        ls_pos07-meins = gs_datos_1000-meins.
        ls_pos07-ftanzpk = gs_datos_1000-ftanzpk.
        ls_pos07-lgort = gs_datos_1000-lgort.
        ls_pos07-ztipo_pesada = gs_datos_1000-ztipo_pesada.
        ls_pos07-netpr = gs_datos_1000-netpr.
        ls_pos07-ntgew = gs_datos_1000-ntgew.
* GST - 02/03/2015 ->
        ls_pos07-brgew = gs_datos_1000-brgew.
        ls_pos07-peinh = gs_datos_1000-peinh.
        ls_pos07-zdisconformidad = gs_datos_1000-zdisconformidad.
* GST - 02/03/2015 <-
        ls_pos07-waers = 'EUR'.
        ls_pos07-ebeln = gs_datos_1000-ebeln.
        ls_pos07-ebelp = gs_datos_1000-ebelp.
        ls_pos07-zpeso_fijado = gs_datos_1000-zpeso_fijado.
        ls_pos07-loekz = gs_datos_1000-loekz.
        ls_pos07-icon_loekz = gs_datos_1000-icon_loekz.

        UPDATE ztmm0007 FROM ls_pos07.

      ELSE.

        ztmm0007-zentrada = gv_entrada.
        ztmm0007-posnr = sy-tabix.
        ztmm0007-matnr = gs_datos_1000-matnr.
        ztmm0007-znum_pesada = gs_datos_1000-znum_pesada.
        ztmm0007-ktmng = gs_datos_1000-ktmng .
        ztmm0007-menge = gs_datos_1000-menge.
        ztmm0007-meins = gs_datos_1000-meins.
        ztmm0007-ftanzpk = gs_datos_1000-ftanzpk.
        ztmm0007-lgort = gs_datos_1000-lgort.
        ztmm0007-ztipo_pesada = gs_datos_1000-ztipo_pesada.
        ztmm0007-netpr = gs_datos_1000-netpr.
        ztmm0007-ntgew = gs_datos_1000-ntgew.
* GST - 02/03/2015 ->
        ztmm0007-brgew = gs_datos_1000-brgew.
        ztmm0007-peinh = gs_datos_1000-peinh.
        ztmm0007-zdisconformidad = gs_datos_1000-zdisconformidad.
* GST - 02/03/2015 <-
        ztmm0007-waers = 'EUR'.
        ztmm0007-ebeln = gs_datos_1000-ebeln.
        ztmm0007-ebelp = gs_datos_1000-ebelp.
        ztmm0007-zpeso_fijado = gs_datos_1000-zpeso_fijado.
        ls_pos07-loekz = gs_datos_1000-loekz.
        ls_pos07-icon_loekz = gs_datos_1000-icon_loekz.

        INSERT ztmm0007.

      ENDIF.

    ENDLOOP.
*    LOOP AT gt_datos_1000 INTO gs_datos_1000.
*
*      ls_pos07-zentrada = gv_entrada.
*      ls_pos07-posnr = sy-tabix.
*      ls_pos07-matnr = gs_datos_1000-matnr.
*      ls_pos07-znum_pesada = gs_datos_1000-znum_pesada.
*      ls_pos07-ktmng = gs_datos_1000-ktmng .
*      ls_pos07-menge = gs_datos_1000-menge.
*      ls_pos07-meins = gs_datos_1000-meins.
*      ls_pos07-ftanzpk = gs_datos_1000-ftanzpk.
*      ls_pos07-lgort = gs_datos_1000-lgort.
*      ls_pos07-ztipo_pesada = gs_datos_1000-ztipo_pesada.
*      ls_pos07-netpr = gs_datos_1000-netpr.
*      ls_pos07-ntgew = gs_datos_1000-ntgew.
*      ls_pos07-waers = 'EUR'.
*      ls_pos07-ebeln = gs_datos_1000-ebeln.
*      ls_pos07-ebelp = gs_datos_1000-ebelp.
*
*      UPDATE ztmm0007 FROM ls_pos07.
*    ENDLOOP.
  ENDIF.

ENDFORM.                    " GUARDAR_POSICIONES


*&---------------------------------------------------------------------*
*&      Form  INICIALIZAR_VBLES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM inicializar_vbles .

  CLEAR: gv_lifnr,
         gv_lifnr_old,
         gv_lifnr_input,
         gv_transp,
         gv_zzptorec, "44589
         gv_entrada,
         gv_xblnr,
         gv_transito,
         gv_bktxt,
         gv_matricula1,
         gv_matricula2,
         gv_ntgew,
         gv_znum_pesada,
* GST - 02/03/2015 ->
         gv_name1,
         gv_brgew,
         gv_kbetr,
         gv_kpein, "44589
         gv_konwa,
* GST - 02/03/2015 <-
         gv_bvvrel.

* GST - 21/05/2015 ->
  CLEAR gv_pedido_ok.
* GST - 21/05/2015 <-

  CLEAR: gt_datos_1000,
         gt_pparcial.

  REFRESH: gt_datos_1000,
         gt_pparcial.

* GST - 08/07/2015 ->
  CLEAR: gt_etiquetas.
  REFRESH: gt_etiquetas.
* GST - 08/07/2015 <-

  CLEAR: gv_okcode,
         gv_okcode2,
         gv_okcode3.

ENDFORM.                    " INICIALIZAR_VBLES


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos4 .

  DATA: lv_contratos TYPE i.
  CLEAR lv_contratos.
  DATA: lv_answer TYPE c.
  DATA: lt_spopli LIKE spopli OCCURS 0,
        ls_spopli TYPE spopli.

* cambiar jtm 02.10.2015 7000008127
*  DATA: lv_index LIKE sy-tabix.
  PERFORM get_contr_marco TABLES gt_pfinal gt_datos_1000 USING gs_contrato_marco.

  IF gv_sw_reg_vehi = 'X'.
    gv_brgew =   CONV #( gv_regvehi_pesobru ).
  ENDIF.

* APC20240719 Recuperamos datos LER
  LOOP AT gt_pfinal ASSIGNING FIELD-SYMBOL(<p>).
    SELECT SINGLE urzzt FROM  eina
      INTO <p>-urzzt
           WHERE  matnr  = <p>-matnr
           AND    lifnr  = gv_lifnr
           AND    loekz  = ''.
  ENDLOOP.
*  CLEAR gt_pfinal.
*  REFRESH gt_pfinal.
*
** SELECCIONAMOS LAS POSICIONES DEL CONTRATO MARCO PARA MOSTRAR LOS MATERIALES POSIBLES A PESAR
*  IF NOT gs_contrato_marco-ebeln IS INITIAL.
*
*    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_pfinal
*    FROM ekpo
*    WHERE ebeln = gs_contrato_marco-ebeln
*    AND loekz <> 'L'.
*
*  ENDIF.
*
*  LOOP AT gt_pfinal INTO gs_pfinal.
*    lv_index = sy-tabix.
*
*    SELECT SINGLE maktx INTO gs_pfinal-maktx
*    FROM makt
*    WHERE matnr = gs_pfinal-matnr
*    AND spras = sy-langu.
*    CLEAR gs_pfinal-ktmng.
*
** MONEDA
*    SELECT SINGLE waers INTO gs_pfinal-waers
*    FROM ekko
*    WHERE ebeln = gs_pfinal-ebeln.
*
*    READ TABLE gt_datos_1000 INTO gs_datos_1000
*    WITH KEY matnr = gs_pfinal-matnr.
*    IF sy-subrc <> 0.
*      MODIFY gt_pfinal FROM gs_pfinal.
*    ELSE.
*      DELETE gt_pfinal INDEX lv_index.
*    ENDIF.
*
*  ENDLOOP.
* fin de cambiar jtm 02.10.2015 7000008127
ENDFORM.                    " RECUPERAR_DATOS4

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos4 .

  DATA: ls_variant4 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat4.


* Para que muestre el ancho de las columnas optimizado
*  t_layout4-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout4-stylefname = 'CELLTAB'.
  t_layout4-sel_mode   = 'A'.

  ls_variant4-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid4->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID3'
      is_layout            = t_layout4
      is_variant           = ls_variant4
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_pfinal[]
      it_fieldcatalog      = gti_fieldcat4.

  SET HANDLER
*              g_application4->handle_menu_button
              g_application4->handle_user_command
              g_application4->handle_hotspot_click
              g_application4->handle_toolbar FOR grid4.
  SET HANDLER g_application4->handle_data_changed_finished FOR grid4.

  SET HANDLER g_application4->on_f4 FOR grid4 .
  PERFORM register_f4_fields.    "set cells with search help

*   Cuando es editable -> para que escuche los eventos: ENTER...
  CALL METHOD grid4->register_edit_event
    EXPORTING
      i_event_id = cl_gui_alv_grid=>mc_evt_modified.

ENDFORM.                    " MOSTRAR_DATOS4

*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT4
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat4 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID3'
    CHANGING
      ct_fieldcat      = gti_fieldcat4.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat4 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-scrtext_l = 'Disconformidad'.
        ls_fieldcat-scrtext_m = 'Disconformidad'.
        ls_fieldcat-scrtext_s = 'Disconformidad'.
        ls_fieldcat-reptext   = 'Disconformidad'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-checkbox = 'X'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'FTANZPK'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '15'.
        ls_fieldcat-scrtext_l = 'Nº de Balas'.
        ls_fieldcat-scrtext_m = 'Nº Balas'.
        ls_fieldcat-scrtext_s = 'Nº Balas'.
        ls_fieldcat-reptext   = 'Nº de Balas'.
*        ls_fieldcat-col_opt = 'X'.
      WHEN 'LGORT'.
        ls_fieldcat-edit   = 'X'.
        ls_fieldcat-outputlen = '10'.
*        ls_fieldcat-col_opt = 'X'.
        ls_fieldcat-f4availabl = 'X'.
        ls_fieldcat-scrtext_l = 'Almacén'.
        ls_fieldcat-scrtext_m = 'Almacén'.
        ls_fieldcat-scrtext_s = 'Almacén'.
        ls_fieldcat-reptext   = 'Almacén'.

      WHEN 'MEINS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'NETPR'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'WAERS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'MATNR'.
        ls_fieldcat-col_opt = 'X'.

      WHEN 'MAKTX'.
        ls_fieldcat-col_opt = 'X'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat4 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT4

*&---------------------------------------------------------------------*
*&      Form  MODIFICAR_PESADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM modificar_pesada USING e_ucomm.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  IF gs_datos_1000-ztipo_pesada = 'P'.

    CLEAR: gv_ntgew_c.
    gv_pesada = gs_datos_1000-znum_pesada.
    gv_ntgew_c = gs_datos_1000-ntgew.

    CLEAR gt_pparcial.
    REFRESH gt_pparcial.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos3.

    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      MOVE-CORRESPONDING gs_datos_1000 TO gs_pparcial.
      APPEND gs_pparcial TO gt_pparcial.
    ENDLOOP.

    gv_okcode2 = e_ucomm.

    CALL SCREEN '3000'.

  ELSEIF gs_datos_1000-ztipo_pesada = 'F'.

    CLEAR: gv_ntgew_c.
    gv_pesada = gs_datos_1000-znum_pesada.
    gv_brgew = gs_datos_1000-ntgew.

    CLEAR gt_pfinal.
    REFRESH gt_pfinal.

*   Recuperar datos a mostrar
    PERFORM recuperar_datos4.

    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
      MOVE-CORRESPONDING gs_datos_1000 TO gs_pfinal.
      APPEND gs_pfinal TO gt_pfinal.
    ENDLOOP.

    gv_okcode2 = e_ucomm.

    CALL SCREEN '4000'.

  ENDIF.

ENDFORM.                    " MODIFICAR_PESADA

*&---------------------------------------------------------------------*
*&      Form  BORRAR_PESADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM borrar_pesada .

  DATA: lv_pesada TYPE zed_pesada.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.

* --> hfc - marcar borrado posición

    gs_datos_1000-loekz = 'X'.
    gs_datos_1000-icon_loekz = icon_delete.

    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX ls_sel_rows-row_id.

*    DELETE gt_datos_1000 INDEX ls_sel_rows-row_id.

* <-- hfc - marcar borrado posición

  ENDLOOP.



* REAPARTIMOS EL PESO RESTANTE EN LAS OTRAS POSICIONES
  PERFORM repartir_peso_camion_nueva_cal.

*  CLEAR lv_pesada.
*  lv_pesada = gs_datos_1000-znum_pesada.
*
*  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = lv_pesada.
*    DELETE gt_datos_1000 INDEX sy-tabix.
*  ENDLOOP.
*
*  CLEAR: gt_pparcial, gt_pfinal.
*  REFRESH: gt_pparcial, gt_pfinal.
*
  CALL METHOD grid->refresh_table_display.

ENDFORM.                    " BORRAR_PESADA

*&---------------------------------------------------------------------*
*&      Form  CREAR_LOTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_lotes USING ok_code
                        lv_ftanzpk
                        lv_pos.

  DATA: lv_batch    TYPE bapibatchkey-batch,
        lv_batchatr TYPE bapibatchatt,
        lt_return   LIKE bapiret2 OCCURS 0,
        ls_return   TYPE bapiret2,
        ls_batchatr TYPE bapibatchatt.
  DATA: lv_lifnr TYPE elifn.
  DATA: lv_posnr TYPE ebelp.
  DATA: ls_licha     LIKE mch1-licha,
        ls_batchatrx TYPE bapibatchattx.
  DATA: lt_mch1 LIKE mch1 OCCURS 0,
        ls_mch1 TYPE mch1.

* GST - 08/07/2015 ->
  DATA: ls_etiquetas LIKE LINE OF etiquetas.
* GST - 08/07/2015 <-

*  DATA: lf_formname TYPE fpname VALUE 'ZAF_ETIQUETA_GENERICA_A5'.
  DATA: lf_fm_name TYPE rs38l_fnam.

* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS PARCIALES
  IF  ok_code = 'REG_PES'.


*    IF gs_output_param IS INITIAL.
*      CLEAR gs_output_param.
*      gs_output_param-dest = 'LOCAL_TOSHIBA'.
*      gs_output_param-reqimm = 'X'.
*
*    ELSE.
*      gs_output_param-nodialog = 'X'.
*    ENDIF.
*
*
*    CALL FUNCTION 'FP_JOB_OPEN'
*      CHANGING
*        ie_outputparams = gs_output_param
*      EXCEPTIONS
*        cancel          = 1
*        usage_error     = 2
*        system_error    = 3
*        internal_error  = 4
*        OTHERS          = 5.
*
**&---- Get the name of the generated function module
*    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
*      EXPORTING
*        i_name     = lf_formname
*      IMPORTING
*        e_funcname = lf_fm_name.

    LOOP AT gt_pparcial INTO gs_pparcial WHERE NOT ftanzpk IS INITIAL.
      CLEAR ls_batchatr.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = gv_lifnr
        IMPORTING
          output = lv_lifnr.
      ls_batchatr-vendor_no = lv_lifnr.
      CONCATENATE gv_entrada gs_pparcial-posnr INTO ls_batchatr-vendrbatch.

      DO  gs_pparcial-ftanzpk TIMES.

        CLEAR: lv_batch, lv_batchatr, lt_return.
        REFRESH lt_return.
        CALL FUNCTION 'BAPI_BATCH_CREATE'
          EXPORTING
            material             = gs_pparcial-matnr
*           BATCH                =
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
            plant                = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
            batchattributes      = ls_batchatr
*           BATCHCONTROLFIELDS   =
            batchstoragelocation = gs_pparcial-lgort
*           INTERNALNUMBERCOM    =
*           EXTENSION1           =
*           MATERIAL_EVG         =
          IMPORTING
            batch                = lv_batch
            batchattributes      = lv_batchatr
          TABLES
            return               = lt_return.

        READ TABLE lt_return INTO ls_return
        WITH KEY type = 'E'.
        IF sy-subrc <> 0.

*          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*            EXPORTING
*              wait = 'X'.
          PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

* GUARDAR LOS CON LOS LOTES CREADOS
          READ TABLE lt_return INTO ls_return
          WITH KEY type = 'S'.
          CLEAR gs_messages.
          gs_messages = ls_return.
          APPEND gs_messages TO gt_messages.

* IMPRIMIMOS UNA ETIQUETA POR CADA LOTE CREADO

*          PERFORM imprimir_etiqueta USING lv_batch
*                                          gs_pparcial
*                                          lf_fm_name.

* GST - 30/06/2015 ->
* Ahora las etiquetas sólo se imprimen al grabar:
*          PERFORM imprimir_etiqueta_smartform USING lv_batch
*                                          gs_pparcial
*                                          lf_fm_name.
* GST - 30/06/2015 <-

* GST - 08/07/2015 ->
* Guardamos registro de etiqueta a imprimir al grabar:
          CLEAR ls_etiquetas.
          MOVE-CORRESPONDING gs_pparcial TO ls_etiquetas.
          ls_etiquetas-charg = lv_batch.
          APPEND ls_etiquetas TO gt_etiquetas.
* GST - 08/07/2015 <-

        ELSE.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
          LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
            DELETE gt_datos_1000 INDEX sy-tabix.
          ENDLOOP.

* MOSTRAR EL ERROR Y NO DEJAR CONTINUAR LA EJECUCION DEL PROGRAMA
          MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number
     WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4.

        ENDIF.
      ENDDO.
    ENDLOOP.

** Close spool job
*    CALL FUNCTION 'FP_JOB_CLOSE'
**   IMPORTING
**     E_RESULT             = result
*      EXCEPTIONS
*        usage_error    = 1
*        system_error   = 2
*        internal_error = 3
*        OTHERS         = 4.



* TRASPASAMOS LOS DATOS DEL ALV DE PESADAS FINALES
  ELSEIF ok_code = 'BTN_PESF'.

*****
*    IF gs_output_param IS INITIAL.
*      CLEAR gs_output_param.
*      gs_output_param-dest = 'LOCAL_TOSHIBA'.
*      gs_output_param-reqimm = 'X'.
*      gs_output_param-reqnew = 'X'.
*
*    ELSE.
*      gs_output_param-nodialog = 'X'.
*    ENDIF.
*
*
*    CALL FUNCTION 'FP_JOB_OPEN'
*      CHANGING
*        ie_outputparams = gs_output_param
*      EXCEPTIONS
*        cancel          = 1
*        usage_error     = 2
*        system_error    = 3
*        internal_error  = 4
*        OTHERS          = 5.
*
**&---- Get the name of the generated function module
*    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
*      EXPORTING
*        i_name     = lf_formname
*      IMPORTING
*        e_funcname = lf_fm_name.
*****

* BORRAR EL LICHA DE LOS LOTES QUE EXISTIERAN CON ESTE NUMERO DE PESADA
* EN CASO DE BORRAR ALGUNAS SE DEBERIAN REETIQUETAR
    CLEAR ls_licha.
    CONCATENATE gv_entrada '%' INTO ls_licha.

    CLEAR: lt_mch1, ls_mch1.
    REFRESH lt_mch1.
    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mch1
    FROM mch1
    WHERE licha LIKE ls_licha.

    LOOP AT lt_mch1 INTO ls_mch1.

      CLEAR: ls_batchatr, ls_batchatrx.
*            REFRESH: ls_batchatr, lv_batchatrx.
      ls_batchatr-vendrbatch = ''.
      ls_batchatrx-vendrbatch = 'X'.

      CALL FUNCTION 'BAPI_BATCH_CHANGE'
        EXPORTING
          material         = ls_mch1-matnr
          batch            = ls_mch1-charg
*         PLANT            =
          batchattributes  = ls_batchatr
          batchattributesx = ls_batchatrx
*         BATCHCONTROLFIELDS       =
*         INTERNALNUMBERCOM        =
*         EXTENSION1       =
*         MATERIAL_EVG     =
*         IMPORTING
*         BATCHATTRIBUTES  =
*         TABLES
*         RETURN           =
        .

*      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*        EXPORTING
*          wait = 'X'.
      PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok.
    ENDLOOP.



    LOOP AT gt_pfinal INTO gs_pfinal WHERE NOT ftanzpk IS INITIAL.

*APC20240719 "Sólo entramos aqui si el material está sujeto a lote
      SELECT SINGLE matnr FROM marc
        INTO gs_pfinal-matnr
       WHERE matnr = gs_pfinal-matnr
         AND werks = gv_werks
         AND xchpf = 'X'.
      IF sy-subrc = 0.
        CLEAR ls_batchatr.
        ls_batchatr-vendor_no = gv_lifnr.
        CONCATENATE gv_entrada gs_pfinal-posnr INTO ls_batchatr-vendrbatch.

        DO  gs_pfinal-ftanzpk TIMES.

          CLEAR: lv_batch, lv_batchatr.
          REFRESH lt_return.
          CALL FUNCTION 'BAPI_BATCH_CREATE'
            EXPORTING
              material             = gs_pfinal-matnr
*             BATCH                =
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
              plant                = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
              batchattributes      = ls_batchatr
*             BATCHCONTROLFIELDS   =
              batchstoragelocation = gs_pfinal-lgort
*             INTERNALNUMBERCOM    =
*             EXTENSION1           =
*             MATERIAL_EVG         =
            IMPORTING
              batch                = lv_batch
              batchattributes      = lv_batchatr
            TABLES
              return               = lt_return.

          READ TABLE lt_return INTO ls_return
          WITH KEY type = 'E'.
          IF sy-subrc <> 0.
*          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*            EXPORTING
*              wait = 'X'.
            PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

* GUARDAR LOS CON LOS LOTES CREADOS
            READ TABLE lt_return INTO ls_return
            WITH KEY type = 'S'.
            CLEAR gs_messages.
            gs_messages = ls_return.
            APPEND gs_messages TO gt_messages.

* IMPRIMIMOS UNA ETIQUETA POR CADA LOTE CREADO

*          PERFORM imprimir_etiqueta USING lv_batch
*                                          gs_pfinal
*                                          lf_fm_name.

* GST - 30/06/2015 ->
* Ahora las etiquetas sólo se van a imprimir al grabar la información:
*          PERFORM imprimir_etiqueta_smartform USING lv_batch
*                                          gs_pfinal
*                                          lf_fm_name.
* GST - 30/06/2015 <-

* GST - 08/07/2015 ->
* Guardamos registro de etiqueta a imprimir al grabar:
            CLEAR ls_etiquetas.
            MOVE-CORRESPONDING gs_pfinal TO ls_etiquetas.
            ls_etiquetas-charg = lv_batch.
            APPEND ls_etiquetas TO gt_etiquetas.
* GST - 08/07/2015 <-

          ELSE.

* PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
            LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
              DELETE gt_datos_1000 INDEX sy-tabix.
            ENDLOOP.

* BORRAMOS TODOS LOS LOTES PROVEEDORES DE LOS LOTES CREADOS EN LA PESADA FINAL Y SE HAN PARADO POR ERROR
            CLEAR ls_licha.
            CONCATENATE gv_entrada '%' INTO ls_licha.

            CLEAR: lt_mch1, ls_mch1.
            REFRESH lt_mch1.
            SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mch1
            FROM mch1
            WHERE licha LIKE ls_licha.

            LOOP AT lt_mch1 INTO ls_mch1.

              CLEAR: ls_batchatr, ls_batchatrx.
*            REFRESH: ls_batchatr, lv_batchatrx.
              ls_batchatr-vendrbatch = ''.
              ls_batchatrx-vendrbatch = 'X'.

              CALL FUNCTION 'BAPI_BATCH_CHANGE'
                EXPORTING
                  material         = ls_mch1-matnr
                  batch            = ls_mch1-charg
*                 PLANT            =
                  batchattributes  = ls_batchatr
                  batchattributesx = ls_batchatrx
*                 BATCHCONTROLFIELDS       =
*                 INTERNALNUMBERCOM        =
*                 EXTENSION1       =
*                 MATERIAL_EVG     =
*         IMPORTING
*                 BATCHATTRIBUTES  =
*         TABLES
*                 RETURN           =
                .

*            CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*              EXPORTING
*                wait = 'X'.
              PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

            ENDLOOP.
*          ENDSELECT.

* MOSTRAR EL ERROR Y NO DEJAR CONTINUAR LA EJECUCION DEL PROGRAMA
            MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number
       WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4.

          ENDIF.
        ENDDO.
      ENDIF.
    ENDLOOP.

** Close spool job
*    CALL FUNCTION 'FP_JOB_CLOSE'
**   IMPORTING
**     E_RESULT             = result
*      EXCEPTIONS
*        usage_error    = 1
*        system_error   = 2
*        internal_error = 3
*        OTHERS         = 4.



* CREAR LOTES DESDE AÑADIR BALA
  ELSEIF ok_code = 'BT_ANADIR'.

    CLEAR ls_batchatr.
    ls_batchatr-vendor_no = gv_lifnr.
    CLEAR lv_posnr.
    lv_posnr = lv_pos.
    CONCATENATE gv_entrada lv_posnr INTO ls_batchatr-vendrbatch.

    DO  lv_ftanzpk TIMES.

      CLEAR: lv_batch, lv_batchatr.
      REFRESH lt_return.
      CALL FUNCTION 'BAPI_BATCH_CREATE'
        EXPORTING
          material             = gs_datos_1000-matnr
*         BATCH                =
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
          plant                = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
          batchattributes      = ls_batchatr
*         BATCHCONTROLFIELDS   =
          batchstoragelocation = gs_datos_1000-lgort
*         INTERNALNUMBERCOM    =
*         EXTENSION1           =
*         MATERIAL_EVG         =
        IMPORTING
          batch                = lv_batch
          batchattributes      = lv_batchatr
        TABLES
          return               = lt_return.

      READ TABLE lt_return INTO ls_return
      WITH KEY type = 'E'.
      IF sy-subrc <> 0.
*        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*          EXPORTING
*            wait = 'X'.
        PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

* GUARDAR LOS CON LOS LOTES CREADOS
        READ TABLE lt_return INTO ls_return
        WITH KEY type = 'S'.
        CLEAR gs_messages.
        gs_messages = ls_return.
        APPEND gs_messages TO gt_messages.

* IMPRIMIMOS UNA ETIQUETA POR CADA LOTE CREADO

*          PERFORM imprimir_etiqueta USING lv_batch
*                                          gs_pfinal
*                                          lf_fm_name.

* GST - 30/06/2015 ->
* Ahora las etiquetas sólo se van a imprimir desde el botón imprimir:
*        PERFORM imprimir_etiqueta_smartform USING lv_batch
*                                        gs_pfinal
*                                        lf_fm_name.
* GST - 30/06/2015 <-

* GST - 08/07/2015 ->
        CLEAR ls_etiquetas.
        MOVE-CORRESPONDING gs_datos_1000 TO ls_etiquetas.
        ls_etiquetas-charg = lv_batch.
        APPEND ls_etiquetas TO gt_etiquetas.
* GST - 08/07/2015 <-

      ELSE.

** PRIMERO BORRAMOS SI EXISTE ALGUNA PESADA CON ESE NUMERO
*        LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE znum_pesada = gv_pesada.
*          DELETE gt_datos_1000 INDEX sy-tabix.
*        ENDLOOP.

* MOSTRAR EL ERROR Y NO DEJAR CONTINUAR LA EJECUCION DEL PROGRAMA
        MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number.

      ENDIF.
    ENDDO.


  ENDIF.

ENDFORM.                    " CREAR_LOTES


**&---------------------------------------------------------------------*
**&      Form  IMPRIMIR_ETIQUETA
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**  -->  p1        text
**  <--  p2        text
**----------------------------------------------------------------------*
*FORM imprimir_etiqueta USING  v_charg
*                              ls_impr LIKE LINE OF pesada_parcial
*                              lf_fm_name TYPE rs38l_fnam.
*
*
*  DATA: lf_formname TYPE fpname VALUE 'ZAF_ETIQUETA_GENERICA_A5'.
**  DATA: lf_fm_name TYPE rs38l_fnam.
*  DATA: ls_eti TYPE zsmm_etiqueta_generica.
*  DATA ls_doc_param TYPE sfpdocparams.
*  DATA: lv_matnr TYPE matnr.
*
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*  CLEAR ls_eti.
*  ls_eti-matnr = ls_impr-matnr.
*  ls_eti-maktx = ls_impr-maktx.
*  ls_eti-charg = v_charg.
**  ls_eti-clabs = ls_impr-ktmng.
**  ls_eti-meins = ls_impr-meins.
*  ls_eti-lifnr = gv_lifnr.
*  ls_eti-name1 = gv_name1.
*  ls_eti-lwedt = gv_bldat.
*  ls_eti-lgort = ls_impr-lgort.
**  ls_eti-licha = .
*
*  SELECT SINGLE lgobe INTO ls_eti-lgobe
*  FROM t001l
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*  WHERE werks = gv_werks
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*  AND lgort = ls_impr-lgort.
*
*  CLEAR lv_matnr.
*  lv_matnr = ls_impr-matnr.
**  CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
**    EXPORTING
**      input  = ls_impr-matnr
**    IMPORTING
**      output = lv_matnr.
*
*  CONCATENATE lv_matnr v_charg INTO ls_eti-cod_barras.
*
*  IF gs_output_param IS INITIAL.
*    CLEAR gs_output_param.
*    gs_output_param-dest = 'LOCAL_TOSHIBA'.
*    gs_output_param-reqimm = 'X'.
*
*  ELSE.
*    gs_output_param-nodialog = 'X'.
*  ENDIF.
*
*
*  CALL FUNCTION 'FP_JOB_OPEN'
*    CHANGING
*      ie_outputparams = gs_output_param
*    EXCEPTIONS
*      cancel          = 1
*      usage_error     = 2
*      system_error    = 3
*      internal_error  = 4
*      OTHERS          = 5.
*
**&---- Get the name of the generated function module
*CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
*EXPORTING
*i_name     = lf_formname
*IMPORTING
*e_funcname = lf_fm_name.
*
*
*  CALL FUNCTION lf_fm_name
*    EXPORTING
*      /1bcdwb/docparams = ls_doc_param
*      ls_eti            = ls_eti
** IMPORTING
**     /1BCDWB/FORMOUTPUT       =
*    EXCEPTIONS
*      usage_error       = 1
*      system_error      = 2
*      internal_error    = 3
*      OTHERS            = 4.
*
** Close spool job
*  CALL FUNCTION 'FP_JOB_CLOSE'
**   IMPORTING
**     E_RESULT             = result
*    EXCEPTIONS
*      usage_error    = 1
*      system_error   = 2
*      internal_error = 3
*      OTHERS         = 4.
*
*ENDFORM.                    " IMPRIMIR_ETIQUETA

**&---------------------------------------------------------------------*
**&      Form  REIMPRIMIR
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_E_UCOMM  text
**----------------------------------------------------------------------*
*FORM reimprimir  USING  e_ucomm.
*
*  CLEAR gv_pesada.
*  LOOP AT lt_sel_rows INTO ls_sel_rows.
*    READ TABLE gt_datos_1000 INTO gs_datos_1000
*    INDEX ls_sel_rows-row_id.
*  ENDLOOP.
*
*  DATA: lf_formname TYPE fpname VALUE 'ZAF_ETIQUETA_GENERICA_A5'.
*  DATA: lf_fm_name TYPE rs38l_fnam.
*  DATA: ls_eti TYPE zsmm_etiqueta_generica.
*  DATA ls_doc_param TYPE sfpdocparams.
*  DATA: lv_licha TYPE lichn.
*  DATA: lt_mch1 LIKE mch1 OCCURS 0,
*        ls_mch1 TYPE mch1.
*  DATA: lv_matnr TYPE matnr.
*
*
*  CLEAR lv_licha .
*  CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.  " SEPARATED BY '/'.
*
*  CLEAR lt_mch1.
*  REFRESH lt_mch1.
*  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE lt_mch1
*    FROM mch1
*    WHERE matnr = gs_datos_1000-matnr
*    AND licha = lv_licha.
*
*  LOOP AT lt_mch1 INTO ls_mch1.
*
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*    CLEAR ls_eti.
*    ls_eti-matnr = gs_datos_1000-matnr.
*    ls_eti-maktx = gs_datos_1000-maktx.
*
*    ls_eti-charg = ls_mch1-charg.
**  ls_eti-clabs = ls_impr-matnr.
**  ls_eti-meins = ls_impr-matnr.
*    ls_eti-lifnr = gv_lifnr.
*    ls_eti-name1 = gv_name1.
*    ls_eti-lwedt = gv_bldat.
*    ls_eti-lgort = gs_datos_1000-lgort.
**  ls_eti-licha = .
*
*    SELECT SINGLE lgobe INTO ls_eti-lgobe
*    FROM t001l
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*    WHERE werks = gv_werks
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*    AND lgort = gs_datos_1000-lgort.
*
*    CLEAR lv_matnr.
*    CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
*      EXPORTING
*        input  = gs_datos_1000-matnr
*      IMPORTING
*        output = lv_matnr.
*
*    CONCATENATE lv_matnr ls_mch1-charg INTO ls_eti-cod_barras.
*
*    IF sy-tabix = 1.
*      CLEAR gs_output_param.
*      gs_output_param-dest = 'LOCAL_TOSHIBA'.
*      gs_output_param-reqimm = 'X'.
*      gs_output_param-reqnew = 'X'.
**  gs_output_param-copies = gs_datos_1000-ftanzpk.
*    ELSE.
*      gs_output_param-nodialog = 'X'.
*    ENDIF.
*
*
*    CALL FUNCTION 'FP_JOB_OPEN'
*      CHANGING
*        ie_outputparams = gs_output_param
*      EXCEPTIONS
*        cancel          = 1
*        usage_error     = 2
*        system_error    = 3
*        internal_error  = 4
*        OTHERS          = 5.
*
**&---- Get the name of the generated function module
*    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'           "& Form Processing Generation
*      EXPORTING
*        i_name     = lf_formname
*      IMPORTING
*        e_funcname = lf_fm_name.
*
*
*    CALL FUNCTION lf_fm_name
*      EXPORTING
*        /1bcdwb/docparams = ls_doc_param
*        ls_eti            = ls_eti
** IMPORTING
**       /1BCDWB/FORMOUTPUT       =
*      EXCEPTIONS
*        usage_error       = 1
*        system_error      = 2
*        internal_error    = 3
*        OTHERS            = 4.
*
** Close spool job
*    CALL FUNCTION 'FP_JOB_CLOSE'
**   IMPORTING
**     E_RESULT             = result
*      EXCEPTIONS
*        usage_error    = 1
*        system_error   = 2
*        internal_error = 3
*        OTHERS         = 4.
*
*  ENDLOOP.
*
*ENDFORM.                    " REIMPRIMIR

*&---------------------------------------------------------------------*
*&      Form  CREAR_PEDIDO_COMPRAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_pedido_compras .

  CONSTANTS: lc_zfc1 TYPE char4 VALUE 'ZFC1',
             lc_zfr1 TYPE char4 VALUE 'ZFR1'.

  DATA: ls_header      TYPE bapimepoheader,
        ls_headerx     TYPE bapimepoheaderx,
        lt_return      LIKE bapiret2 OCCURS 0,
        ls_return      TYPE bapiret2,
        lt_item        LIKE bapimepoitem OCCURS 0,
        ls_item        TYPE bapimepoitem,
        lt_itemx       LIKE bapimepoitemx OCCURS 0,
        ls_itemx       TYPE bapimepoitemx,
        lt_condheader  LIKE bapimepocondheader OCCURS 0,
        ls_condheader  TYPE bapimepocondheader,
        lt_condheaderx LIKE bapimepocondheaderx OCCURS 0,
        ls_condheaderx TYPE bapimepocondheaderx,
        lt_cond        LIKE bapimepocond OCCURS 0,
        ls_cond        TYPE bapimepocond,
        lt_condx       LIKE bapimepocondx OCCURS 0,
        ls_condx       TYPE bapimepocondx,
        lt_textitem    LIKE bapimepotext OCCURS 0,
        ls_textitem    TYPE bapimepotext.

  DATA: lv_ebeln  LIKE bapimepoheader-po_number,
        lo_header TYPE bapimepoheader,
        lo_eikp   LIKE bapieikp.
  DATA: lv_lifnr TYPE elifn.

  DATA: ls_cab06 TYPE ztmm0006.
*  DATA: ls_a044 TYPE a044.
  DATA: ls_a911 TYPE a911.       "Condicion ZTRA por centro
  DATA l_answer TYPE c.

  IF gv_kschl IS INITIAL.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar      = 'Punto de recogida sin condición de precio'(022)
*       DIAGNOSE_OBJECT       = ' '
*       display_cancel_button = ' '
        text_question = 'Para el punto de recogida no existe condición de precio ¿Desear continuar?'(023)
      IMPORTING
        answer        = l_answer.

    IF l_answer NE '1'.
* Grabamos la cancelación en la tabla de mensajes para no volver y finalizar el RV.
      CLEAR gs_messages.
      gs_messages-type = 'E'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = 363. "'Cancelado por usuario, tras punto de recogida sin condición de precio'.
      INSERT gs_messages INTO TABLE gt_messages.
      RETURN.
    ENDIF.

  ENDIF.

**  IF l_answer NE '1' AND gv_kschl IS INITIAL.
**    RETURN.
**  ENDIF.
  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = gv_lifnr
    IMPORTING
      output = lv_lifnr.


  CLEAR: ls_header, ls_headerx.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
  ls_header-comp_code   = gv_bukrs.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
  ls_headerx-comp_code  = 'X'.
  ls_header-doc_type    = gc_bsart.
  ls_headerx-doc_type   = 'X'.
  ls_header-vendor      = lv_lifnr.
  ls_headerx-vendor     = 'X'.
  ls_header-purch_org   = gc_ekorg.
  ls_headerx-purch_org  = 'X'.
*  ls_header-pur_group = gc_ekgrp.
  ls_header-pur_group   = gs_contrato_marco-ekgrp.
  ls_headerx-pur_group  = 'X'.
  ls_header-doc_date    = gv_bldat.
  ls_headerx-doc_date   = 'X'.
  ls_header-ref_1       = gv_entrada.
  ls_headerx-ref_1      = 'X'.
* GST - 03/03/2015 ->
  IF gv_bvvrel IS NOT INITIAL.
    WRITE gv_bvvrel TO ls_header-our_ref.
    CONDENSE ls_header-our_ref.
    CONCATENATE 'HUM' ls_header-our_ref '%' INTO ls_header-our_ref
                SEPARATED BY space.
    ls_headerx-our_ref = 'X'.
  ENDIF.
* GST - 03/03/2015 <-


  REFRESH: lt_condheader, lt_condheaderx.
  IF gv_transito = 'X'.
    CLEAR: lt_condheader, ls_condheader, ls_condheaderx, lt_condheaderx.

* SCT 08.11.2016 se incluye la condicion ZTRA solo si se encuentra
* registro de condición. Se cambia este codigo de lugar
*    ls_condheader-cond_st_no = '001'.
*    ls_condheaderx-cond_st_no = 'X'.
*    ls_condheader-cond_type = 'ZTRA'.
*    ls_condheaderx-cond_type = 'X'.
**    ls_condheader-cond_value  = '001'.
*    ls_condheader-currency = 'EUR'.
*    ls_condheaderx-currency = 'X'.
*    ls_condheader-currency_iso  = 'EUR'.
*    ls_condheaderx-currency_iso  = 'X'.
*    ls_condheader-change_id = 'I'.
*    ls_condheaderx-change_id = 'X'.

*** SCT INICIO 08.11.2016 modificamos tabla 44 a tabla 911 pues
*   la condición ZTRA se modifica a nivel de centro
*    CLEAR ls_a044.
*    SELECT SINGLE * INTO ls_a044
*    FROM a044
*    WHERE kappl = 'M'
*    AND kschl = 'ZTRA'
*    AND ekorg = '1000'
*    AND lifnr = lv_lifnr
*    AND datbi >= sy-datum
*    AND datab <= sy-datum.
*    IF sy-subrc EQ 0.
*      SELECT * FROM konp UP TO 1 ROWS
*      WHERE knumh = ls_a044-knumh
*      AND kschl = ls_a044-kschl.
*        ls_condheader-cond_unit  = konp-kmein.
*        ls_condheaderx-cond_unit  = 'X'.
*        ls_condheader-cond_p_unt  = konp-kpein.
*        ls_condheaderx-cond_p_unt  = 'X'.
*
*      ENDSELECT.
*    ENDIF.

    CLEAR ls_a911.
    SELECT SINGLE * INTO ls_a911
    FROM a911
    WHERE kappl = 'M'
    AND kschl = 'ZTRA'
    AND ekorg = '1000'
    AND lifnr = lv_lifnr
    AND werks = gv_werks
    AND datbi >= sy-datum
    AND datab <= sy-datum.
    IF sy-subrc EQ 0.
      SELECT * FROM konp UP TO 1 ROWS
      WHERE knumh = ls_a911-knumh
      AND kschl = ls_a911-kschl AND loevm_ko = space.
        IF sy-subrc EQ 0.
          ls_condheader-cond_st_no = '001'.
          ls_condheaderx-cond_st_no = 'X'.
          ls_condheader-cond_type = 'ZTRA'.
          ls_condheaderx-cond_type = 'X'.
*    ls_condheader-cond_value  = '001'.
          ls_condheader-currency = 'EUR'.
          ls_condheaderx-currency = 'X'.
          ls_condheader-currency_iso  = 'EUR'.
          ls_condheaderx-currency_iso  = 'X'.
          ls_condheader-change_id = 'I'.
          ls_condheaderx-change_id = 'X'.
          ls_condheader-cond_unit  = konp-kmein.
          ls_condheaderx-cond_unit  = 'X'.
          ls_condheader-cond_p_unt  = konp-kpein.
          ls_condheaderx-cond_p_unt  = 'X'.
        ENDIF.
      ENDSELECT.
    ENDIF.
*** FIN SCT 08.11.2016

    APPEND ls_condheader TO lt_condheader.
    APPEND ls_condheaderx TO lt_condheaderx.
  ENDIF.

* En caso de que se haya rellenado el transportista
  IF NOT gv_transp IS INITIAL AND gv_kschl IS NOT INITIAL.
    CLEAR: ls_condheader, ls_condheaderx.

    READ TABLE lt_condheader INTO ls_condheader
    INDEX 1.
    IF sy-subrc = 0.
      CLEAR ls_condheader.
      ls_condheader-cond_st_no = '002'.
      ls_condheaderx-cond_st_no = 'X'.
    ELSE.
      CLEAR ls_condheader.
      ls_condheader-cond_st_no = '001'.
      ls_condheaderx-cond_st_no = 'X'.
    ENDIF.

* INI UDEFINEDES 25.10.2017
    IF NOT gv_kschl IS INITIAL.
      IF gv_kschl EQ 'ZTTR'.
        ls_condheader-cond_type = lc_zfc1.
      ELSE.
        ls_condheader-cond_type = lc_zfr1.
      ENDIF.
      ls_condheaderx-cond_type = 'X'.
    ENDIF.
* FIN UDEFINEDES 25.10.2017

    ls_condheader-vendor_no = gv_transp.
    ls_condheaderx-vendor_no = 'X'.

* INI UDEFINEDES 25.10.2017
    IF NOT gv_kbetr IS INITIAL.
      ls_condheader-cond_value  = gv_kbetr.
      ls_condheaderx-cond_value  = 'X'.
    ENDIF.
* FIN UDEFINEDES 25.10.2017

    ls_condheader-currency = gv_konwa.
    ls_condheaderx-currency = 'X'.
    ls_condheader-currency_iso  = gv_konwa.
    ls_condheaderx-currency_iso  = 'X'.
    ls_condheader-change_id = 'I'.
    ls_condheaderx-change_id = 'X'.
    ls_condheader-cond_unit  = gv_kmein.
    ls_condheaderx-cond_unit  = 'X'.
    ls_condheader-cond_p_unt  = gv_kpein.
    ls_condheaderx-cond_p_unt  = 'X'.

    APPEND ls_condheader TO lt_condheader.
    APPEND ls_condheaderx TO lt_condheaderx.

  ENDIF.

  CLEAR: lt_item, lt_itemx, ls_item, ls_itemx, ls_textitem, ls_cond, ls_condx.
  REFRESH: lt_item, lt_itemx, lt_textitem, lt_cond, lt_condx.
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE loekz IS INITIAL.
    CLEAR: ls_item, ls_itemx.
    ls_item-po_item = gs_datos_1000-posnr.
    ls_itemx-po_item = gs_datos_1000-posnr.
    ls_item-material = gs_datos_1000-matnr.
    ls_itemx-material = 'X'.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
    ls_item-plant = gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
    ls_itemx-plant = 'X'.
    ls_item-stge_loc = gs_datos_1000-lgort.
    ls_itemx-stge_loc = 'X'.
    ls_item-quantity = gs_datos_1000-menge.
    ls_itemx-quantity = 'X'.
    ls_item-agreement = gs_datos_1000-ebeln.
    ls_itemx-agreement = 'X'.
    ls_item-agmt_item = gs_datos_1000-ebelp.
    ls_itemx-agmt_item = 'X'.

    APPEND ls_item TO lt_item.
    APPEND ls_itemx TO lt_itemx.

* TEXTO DISCONFORMIDAD
    IF gs_datos_1000-zdisconformidad = 'X'.
      CLEAR ls_textitem.
      ls_textitem-po_item = gs_datos_1000-posnr.
      ls_textitem-text_id = 'F01'.
      ls_textitem-text_line = 'Disconformidad'.
      APPEND ls_textitem TO lt_textitem.
    ENDIF.

* EN CASO DE ACCEDER POR LA TRANSACCION DEL SUPERVISOR SE PASAN LOS PRECIOS
* POR SI HAN SIDO MODIFICADOS
*    IF sy-tcode = 'ZMM0004'.
    IF sy-tcode = 'ZMM0004'  OR sy-tcode = 'ZMM0004_REG_VEH'.
* GST - 02/03/2015 ->
      CLEAR: ls_cond, ls_condx.
* GST - 02/03/2015 <-
      ls_cond-itm_number = gs_datos_1000-posnr.
      ls_condx-itm_number = gs_datos_1000-posnr.
      ls_cond-cond_st_no = '001'.
      ls_condx-cond_st_no = 'X'.
      ls_cond-cond_type = 'PB00'.
      ls_condx-cond_type = 'X'.
      ls_cond-cond_value = gs_datos_1000-netpr.
      ls_condx-cond_value = 'X'.
      ls_cond-currency = gs_datos_1000-waers.
      ls_condx-currency = 'X'.
      ls_cond-currency_iso = gs_datos_1000-waers.
      ls_condx-currency_iso = 'X'.
* GST - 02/03/2015 ->
*      ls_cond-cond_unit = 1.
*      ls_condx-cond_unit = 'X'.
      ls_cond-cond_unit = 'KG'.
      ls_condx-cond_unit = 'X'.
* GST - 02/03/2015 <-
      ls_cond-change_id = 'U'.
      ls_condx-change_id = 'X'.
* GST - 02/03/2015 ->
      ls_cond-cond_p_unt = gs_datos_1000-peinh.
      ls_condx-cond_p_unt = 'X'.
* GST - 02/03/2015 <-
      APPEND ls_cond TO lt_cond.
* GST - 02/03/2015 ->
      APPEND ls_condx TO lt_condx.
* GST - 02/03/2015 <-
    ENDIF.

  ENDLOOP.


  CLEAR gv_ebeln.

  CALL FUNCTION 'BAPI_PO_CREATE1'
    EXPORTING
      poheader          = ls_header
      poheaderx         = ls_headerx
*     POADDRVENDOR      =
*     TESTRUN           =
*     MEMORY_UNCOMPLETE =
*     MEMORY_COMPLETE   =
*     POEXPIMPHEADER    =
*     POEXPIMPHEADERX   =
*     VERSIONS          =
*     NO_MESSAGING      =
*     NO_MESSAGE_REQ    =
*     NO_AUTHORITY      =
*     NO_PRICE_FROM_PO  =
*     PARK_COMPLETE     =
*     PARK_UNCOMPLETE   =
    IMPORTING
      exppurchaseorder  = gv_ebeln
      expheader         = lo_header
      exppoexpimpheader = lo_eikp
    TABLES
      return            = lt_return
      poitem            = lt_item
      poitemx           = lt_itemx
*     POADDRDELIVERY    =
*     POSCHEDULE        =
*     POSCHEDULEX       =
*     POACCOUNT         =
*     POACCOUNTPROFITSEGMENT       =
*     POACCOUNTX        =
      pocondheader      = lt_condheader
      pocondheaderx     = lt_condheaderx
      pocond            = lt_cond
      pocondx           = lt_condx
*     POLIMITS          =
*     POCONTRACTLIMITS  =
*     POSERVICES        =
*     POSRVACCESSVALUES =
*     POSERVICESTEXT    =
*     EXTENSIONIN       =
*     EXTENSIONOUT      =
*     POEXPIMPITEM      =
*     POEXPIMPITEMX     =
*     POTEXTHEADER      =
      potextitem        = lt_textitem
*     ALLVERSIONS       =
*     POPARTNER         =
*     POCOMPONENTS      =
*     POCOMPONENTSX     =
*     POSHIPPING        =
*     POSHIPPINGX       =
*     POSHIPPINGEXP     =
*     SERIALNUMBER      =
*     SERIALNUMBERX     =
*     INVPLANHEADER     =
*     INVPLANHEADERX    =
*     INVPLANITEM       =
*     INVPLANITEMX      =
    .

  READ TABLE lt_return INTO ls_return
  WITH KEY type = 'E'.
  IF sy-subrc <> 0.

* GST - 21/05/2015 ->
* ACTUALIZAMOS LA TABLA DE CABECERA COMO CONTABILIZADA
    SELECT SINGLE * INTO ls_cab06
        FROM ztmm0006
        WHERE zentrada = gv_entrada.
    IF sy-subrc = 0.
*      ls_cab06-zcontabilizado = 'X'.
      ls_cab06-ebeln = gv_ebeln.
      UPDATE ztmm0006 FROM ls_cab06.
    ENDIF.
* GST - 21/05/2015 <-

*    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*      EXPORTING
*        wait = 'X'.
    PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

* GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    READ TABLE lt_return INTO ls_return
    WITH KEY type = 'S'.
    CLEAR gs_messages.
    gs_messages = ls_return.
    APPEND gs_messages TO gt_messages.

** GST - 21/05/2015 ->
** ACTUALIZAMOS LA TABLA DE CABECERA COMO CONTABILIZADA
*    SELECT SINGLE * INTO ls_cab06
*        FROM ztmm0006
*        WHERE zentrada = gv_entrada.
*    IF sy-subrc = 0.
*      ls_cab06-zcontabilizado = 'X'.
*      ls_cab06-ebeln = gv_ebeln.
*      UPDATE ztmm0006 FROM ls_cab06.
*    ENDIF.
** GST - 21/05/2015 <-

*    gv_ebeln = lo_header-po_number.
  ELSE.
* REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

  ENDIF.


ENDFORM.                    " CREAR_PEDIDO_COMPRAS

*&---------------------------------------------------------------------*
*&      Form  CREAR_ENTRADA_MERCANCIAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_entrada_mercancias .

  DATA: ls_header   TYPE bapi2017_gm_head_01,
        ls_code     TYPE bapi2017_gm_code,
        lt_item     LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item     TYPE bapi2017_gm_item_create,
        lt_return   LIKE bapiret2 OCCURS 0,
        ls_return   TYPE bapiret2,
        ls_headret  TYPE bapi2017_gm_head_ret,
        lv_document TYPE bapi2017_gm_head_ret-mat_doc,
        lv_year     TYPE bapi2017_gm_head_ret-doc_year.
  DATA: lv_licha TYPE lichn.
  DATA: ls_mch1 TYPE mch1.

  DATA: ls_cab06 TYPE ztmm0006.
  DATA: n_bultos_totales LIKE gs_datos_1000-ftanzpk,
        n_bultos_cont    LIKE gs_datos_1000-ftanzpk.


  CLEAR ls_header.
  ls_header-pstng_date = gv_budat.
  ls_header-doc_date = gv_bldat.
  ls_header-ref_doc_no = gv_xblnr.
  IF NOT gv_matricula1 IS INITIAL OR NOT gv_matricula2 IS INITIAL.
    CONCATENATE gv_matricula1 gv_matricula2 INTO ls_header-bill_of_lading SEPARATED BY '/'.
  ENDIF.
  ls_header-header_txt = gv_bktxt.

  CLEAR ls_code.
  ls_code-gm_code = '01'.

  CLEAR: lt_item, ls_item.
  REFRESH lt_item.
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE loekz IS INITIAL.
    n_bultos_totales = gs_datos_1000-ftanzpk .
    n_bultos_cont    = 0.
    CLEAR lv_licha.
    CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.
    SELECT * INTO ls_mch1
    FROM mch1
    WHERE licha = lv_licha
    AND matnr = gs_datos_1000-matnr
    AND lvorm = ''.

      ls_item-material = ls_mch1-matnr.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
      ls_item-plant = gv_werks.
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
      ls_item-stge_loc = gs_datos_1000-lgort.
      ls_item-batch = ls_mch1-charg.
      ls_item-move_type = '101'.
      ls_item-entry_qnt = gs_datos_1000-menge / gs_datos_1000-ftanzpk.
      ls_item-po_number = gv_ebeln.
      SELECT SINGLE ebelp INTO ls_item-po_item
      FROM ekpo
      WHERE ebeln = gv_ebeln
      AND matnr = ls_mch1-matnr
      AND lgort = gs_datos_1000-lgort.

      ls_item-mvt_ind = 'B'.
      IF gs_datos_1000-zdisconformidad = 'X'.
        ls_item-item_text = 'Disconformidad'.
      ENDIF.

* GST - 03/03/2015 ->
      IF gv_bvvrel IS NOT INITIAL.
        WRITE gv_bvvrel TO ls_item-unload_pt.
        CONDENSE ls_item-unload_pt.
        CONCATENATE 'HUM' ls_item-unload_pt '%' INTO ls_item-unload_pt
                    SEPARATED BY space.
      ENDIF.
* GST - 03/03/2015 <-

      APPEND ls_item TO lt_item.
      CLEAR ls_item.
      ADD 1 TO n_bultos_cont.

      CHECK n_bultos_cont >= n_bultos_totales.
      EXIT.
    ENDSELECT.
  ENDLOOP.

  CLEAR: ls_headret, lv_document, lv_year.

  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = ls_code
*     TESTRUN          = ' '
*     GOODSMVT_REF_EWM =
    IMPORTING
      goodsmvt_headret = ls_headret
      materialdocument = lv_document
      matdocumentyear  = lv_year
    TABLES
      goodsmvt_item    = lt_item
*     GOODSMVT_SERIALNUMBER         =
      return           = lt_return
*     GOODSMVT_SERV_PART_DATA       =
*     EXTENSIONIN      =
    .

  READ TABLE lt_return INTO ls_return
  WITH KEY type = 'E'.
  IF sy-subrc <> 0.

* GST - 21/05/2015 ->
* modificar la tabla como contabilizada
    CLEAR ls_cab06.
    SELECT SINGLE * INTO ls_cab06
    FROM ztmm0006
    WHERE zentrada = gv_entrada.
    IF sy-subrc = 0.
      ls_cab06-zcontabilizado = 'X'.
      UPDATE ztmm0006 FROM ls_cab06.
    ENDIF.
* GST - 21/05/2015 <-

*    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*      EXPORTING
*        wait = 'X'.
    PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

*--> INI FCARDONA - 81935 EM RFID filtro papelera SARRIÀ

    "Hardcodeamos esto para acortar el problema.
    "Cuando llevemos RFID a 3020 eliminamos el filtro.
*APC20240912 Cambiamos el hardcode por entrada en tabla de parametros
*    IF ( gv_werks EQ '3000' ).
     if zcl_ap_parametros=>existe( clave = 'ZRFIDPARAM'
                                   campo = gv_werks
                                   valor = 'X' ).

      "INI CGIJON - 11.08.23 - MANDAMOS LAS ETIQUETAS CON LAS CANTIDADES AL PI
      IF sw_ok = 'X'.
        DATA: it_mseg TYPE  ty_t_mseg,
              is_mkpf TYPE  mkpf,
              e_datos TYPE  zmt_etiquetas_clase10.

        SELECT SINGLE * FROM mkpf
           INTO is_mkpf
           WHERE mblnr = lv_document AND
                mjahr = lv_year.

        SELECT * FROM mseg
              INTO TABLE it_mseg
              WHERE mblnr = lv_document AND
                    mjahr = lv_year.

        CALL FUNCTION 'ZCLASE10_ETIQUETAS_BALA'
          EXPORTING
            it_mseg = it_mseg
            is_mkpf = is_mkpf
          IMPORTING
            e_datos = e_datos.
      ENDIF.
      "FIN CGIJON - 11.08.23 - MANDAMOS LAS ETIQUETAS CON LAS CANTIDADES AL PI


    ENDIF.

*<-- FIN FCARDONA - 81935 EM RFID filtro papelera SARRIÀ

** GST - 21/05/2015 ->
** modificar la tabla como contabilizada
*    CLEAR ls_cab06.
*    SELECT SINGLE * INTO ls_cab06
*    FROM ztmm0006
*    WHERE zentrada = gv_entrada.
*    IF sy-subrc = 0.
*      ls_cab06-zcontabilizado = 'X'.
*      UPDATE ztmm0006 FROM ls_cab06.
*    ENDIF.
** GST - 21/05/2015 <-

* GUARDAR LOS CON LOS LOTES CREADOS
    CLEAR gs_messages.
    gs_messages-type = 'S'.
    gs_messages-id = 'ZMM'.
    gs_messages-number = '027'.
    gs_messages-message = text-005.
*    gs_messages-log_no = .
*    gs_messages-log_msg_no = .
    gs_messages-message_v1 = lv_document.
    gs_messages-message_v2 = lv_year.
*    gs_messages-message_v3 = .
*    gs_messages-message_v4 = .
    APPEND gs_messages TO gt_messages.

  ELSE.
* REGISTRAR ERROR EN CASO DE NO CREACION DEL LOTE
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

* COMPROBAR SI SE HA CREADO EL PEDIDO PERO NO LA ENTRADA DE MERCANCIA
    IF NOT gv_ebeln IS INITIAL.
      CLEAR gs_messages.
      gs_messages-type = 'W'.
      gs_messages-id = 'ZMM'.
      gs_messages-number = '051'.
      gs_messages-message = text-008.
*    gs_messages-log_no = .
*    gs_messages-log_msg_no = .
      gs_messages-message_v1 = gv_ebeln.
*    gs_messages-message_v2 = .
*    gs_messages-message_v3 = .
*    gs_messages-message_v4 = .
      APPEND gs_messages TO gt_messages.

    ENDIF.

  ENDIF.

ENDFORM.                    " CREAR_ENTRADA_MERCANCIAS


*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_log .

  CALL FUNCTION 'C14ALD_BAPIRET2_SHOW'
    TABLES
      i_bapiret2_tab = gt_messages.


** Mostramos el LOG de errores
*  CALL FUNCTION 'ZMOSTRAR_ALV_MENSAJES'
*    EXPORTING
*      i_title     = 'Log de Errores'(105)
*    TABLES
*      it_messages = gt_messages.

ENDFORM.                    " MOSTRAR_LOG

*&---------------------------------------------------------------------*
*&      Form  COMPROBACION_CANTIDAD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM comprobacion_cantidad .

  CLEAR gs_datos_1000.
  READ TABLE gt_datos_1000 INTO gs_datos_1000
  WITH KEY ztipo_pesada = 'F'.
  IF sy-subrc = 0 AND gv_ntgew IS INITIAL.
    MESSAGE e028 DISPLAY LIKE 'I'.
  ENDIF.

ENDFORM.                    " COMPROBACION_CANTIDAD

*&---------------------------------------------------------------------*
*&      Form  PESO_CAMION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM peso_camion .
  DATA: lv_return TYPE c,
        lt_fields LIKE sval OCCURS 0,
        ls_fields TYPE sval.

*  CLEAR: ls_fields, lv_return.
*  ls_fields-tabname = 'EKPO'.
*  ls_fields-fieldname = 'NTGEW'.
*  ls_fields-fieldtext = 'TARA'.
*  APPEND ls_fields TO lt_fields.
*
*  CLEAR ls_fields.
*  ls_fields-tabname = 'ZRMM0002_V2_GRID'.
*  ls_fields-fieldname = 'ZNUM_PESADA'.
*  ls_fields-fieldtext = 'Nº Ticket'.
*  APPEND ls_fields TO lt_fields.
*
*  CALL FUNCTION 'POPUP_GET_VALUES'
*    EXPORTING
**     NO_VALUE_CHECK  = ' '
*      popup_title     = text-006
**     START_COLUMN    = '5'
**     START_ROW       = '5'
*    IMPORTING
*      returncode      = lv_return
*    TABLES
*      fields          = lt_fields
*    EXCEPTIONS
*      error_in_fields = 1
*      OTHERS          = 2.
*  CLEAR ls_fields.
*  READ TABLE lt_fields INTO ls_fields
*  INDEX 1.
*  gv_ntgew = ls_fields-value.
*
*  CLEAR ls_fields.
*  READ TABLE lt_fields INTO ls_fields
*  INDEX 2.
*  gv_znum_pesada = ls_fields-value.


  gv_ntgew = 1.
  gv_znum_pesada = '1'.

  IF NOT gv_ntgew IS INITIAL.
    PERFORM repartir_peso_camion.
  ENDIF.


ENDFORM.                    " PESO_CAMION

*&---------------------------------------------------------------------*
*&      Form  REPARTIR_PESO_CAMION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM repartir_peso_camion .

  DATA: lv_index LIKE sy-tabix.

  DATA: lv_ntgew_n TYPE entge.
  DATA: lv_bultos_tot TYPE ftanzpk.

  CLEAR gs_datos_1000.
  READ TABLE gt_datos_1000 INTO gs_datos_1000
  WITH KEY ztipo_pesada = 'F'.

* REVISAR QUE SE GUARDE O CONTABILICE CON EL PESO DEL CAMION RELLENO
* EN CASO DE TENER UNA PESADA FINAL
  IF gv_okcode2 = 'BTN_SAVE' OR gv_okcode2 = 'BTN_CONT'.

    CLEAR gs_datos_1000.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY ztipo_pesada = 'F'.
    IF sy-subrc = 0 AND gv_ntgew IS INITIAL.
      MESSAGE e028.
    ENDIF.

  ENDIF.

* calculamos el peso neto de la pesada final,
* restando el peso del camion al peso de la mercancia + camion
  CLEAR lv_ntgew_n.
*  lv_ntgew_n = gs_datos_1000-ntgew - gv_ntgew.
  lv_ntgew_n = gv_brgew - gv_ntgew.

* CALCUALMOS EL NUMERO TOTAL DE BULTOS
  CLEAR lv_bultos_tot.
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE ztipo_pesada = 'F'.
    lv_bultos_tot = lv_bultos_tot + gs_datos_1000-ftanzpk.
  ENDLOOP.

* REPARTIR EL PESO DE LA PESADA FINAL
  LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ftanzpk IS INITIAL
                                             AND ztipo_pesada = 'F'.
    lv_index = sy-tabix.
    gs_datos_1000-ktmng = ( gs_datos_1000-ftanzpk * lv_ntgew_n ) / lv_bultos_tot.
    gs_datos_1000-ntgew = gv_ntgew.
    gs_datos_1000-znum_pesada = gv_znum_pesada.
    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
  ENDLOOP.

* CALCULAR LA CANTIDAD CON EL PORCENTAJE DE HUMIDAD
  IF NOT gv_bvvrel IS INITIAL AND NOT gt_datos_1000[] IS INITIAL.
    CLEAR lv_index.
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-menge = ( gs_datos_1000-ktmng * gv_bvvrel ) / 100.
      gs_datos_1000-menge = gs_datos_1000-ktmng - gs_datos_1000-menge.
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.
  ELSE.
    CLEAR lv_index.
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-menge = gs_datos_1000-ktmng .
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.

  ENDIF.

ENDFORM.                    " REPARTIR_PESO_CAMION

*&---------------------------------------------------------------------*
*&      Form  DUPLICAR_LINEA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM duplicar_linea USING lv_dynpro.

* Llenar la tabla pesadas con la linea a duplicar
  IF lv_dynpro = '3000'.
    LOOP AT lt_sel_rows INTO ls_selected_line.
      READ TABLE gt_pparcial INTO gs_pparcial
      INDEX ls_selected_line-row_id.
      IF sy-subrc = 0.
        CLEAR: gs_pparcial-ktmng, gs_pparcial-ftanzpk, gs_pparcial-lgort.
        APPEND gs_pparcial TO gt_pparcial.
      ENDIF.

    ENDLOOP.

  ELSEIF lv_dynpro = '4000'.
    LOOP AT lt_sel_rows INTO ls_selected_line.
      READ TABLE gt_pfinal INTO gs_pfinal
      INDEX ls_selected_line-row_id.
      IF sy-subrc = 0.
        CLEAR: gs_pfinal-ktmng, gs_pfinal-ftanzpk, gs_pfinal-lgort.
        APPEND gs_pfinal TO gt_pfinal.
      ENDIF.

    ENDLOOP.
  ENDIF.

  MESSAGE s044.

ENDFORM.                    " DUPLICAR_LINEA

*&---------------------------------------------------------------------*
*&      Form  SELECCIONAR_DATOS_SUP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM seleccionar_datos_sup .

  DATA: lv_index LIKE sy-tabix.

  gv_entrada = gs_supervisor-zentrada.

* SELECCIONAMOS CABECERA
  SELECT SINGLE bldat budat lifnr xblnr ztransito bktxt ztransportista zptorec zmatricula1 zmatricula2
  zhumedad ntgew zcontabilizado brgew
    trans_residuos dir ler id_entrada_residuos
     "kbetr konwa kpein
  INTO (gv_bldat, gv_budat, gv_lifnr, gv_xblnr, gv_transito, gv_bktxt, gv_transp, gv_zzptorec,
    gv_matricula1, gv_matricula2, gv_bvvrel, gv_ntgew, gv_contabilizado, gv_brgew ,
    gs_residuos-trans_residuos , gs_residuos-dir , gs_residuos-ler , gs_residuos-id_entrada_residuos

*    gs_data_residuos,
*        trans_residuos TYPE lifnr,
*        dir            TYPE zdir,
*        ler            TYPE zler,
*        ID_ENTRADA_RESIDUOS


    ) "gv_kbetr, gv_konwa, gv_kpein)
  FROM ztmm0006
  WHERE zentrada = gs_supervisor-zentrada.


  SELECT SINGLE zzptorecdes INTO gv_zzptorecdes
    FROM ztmm0021 WHERE zzptorec = gv_zzptorec.
* GST - 02/03/2015 ->
  gv_znum_pesada = gs_supervisor-znum_pesada.
* GST - 02/03/2015 <-

* SELECCIONAMOS POSICCIONES
  SELECT *
   INTO CORRESPONDING FIELDS OF TABLE gt_datos_1000
   FROM ztmm0007
   WHERE zentrada = gs_supervisor-zentrada.

  LOOP AT gt_datos_1000 INTO gs_datos_1000.
    lv_index = sy-tabix.

    IF gs_datos_1000-loekz = 'X'.
      gs_datos_1000-icon_loekz = icon_delete.
    ENDIF.

    SELECT SINGLE maktx INTO gs_datos_1000-maktx
    FROM makt
    WHERE matnr = gs_datos_1000-matnr
    AND spras = sy-langu.
    gs_datos_1000-zcontabilizado = gv_contabilizado.
    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.

  ENDLOOP.


ENDFORM.                    " SELECCIONAR_DATOS_SUP


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos6 .

  DATA: ls_supervisor LIKE LINE OF supervisor,
        lv_index      LIKE         sy-tabix.

  CLEAR gt_supervisor.
  REFRESH gt_supervisor.

*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
* Indicamos un rango para obtener las entradas que tengan el centro vacío
* e igual al indicado en la pantalla de selección
  DATA: ls_rang_werks TYPE werks_rang,
        lt_rang_werks TYPE werks_t_range.

  ls_rang_werks-sign   = 'I'.
  ls_rang_werks-option = 'EQ'.
  ls_rang_werks-low    = ''.

  APPEND ls_rang_werks TO lt_rang_werks.

  ls_rang_werks-sign   = 'I'.
  ls_rang_werks-option = 'EQ'.
  ls_rang_werks-low    = p_werks.

  APPEND ls_rang_werks TO lt_rang_werks.

*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--

* GST - 22/04/2015 ->
* Recuperar pedido compras y entrada mercancía (ALV):

  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_supervisor
  FROM ztmm0006
  INNER JOIN ztmm0007 ON ztmm0006~zentrada = ztmm0007~zentrada
  WHERE ztmm0006~zentrada IN s_entra
  AND ztmm0006~lifnr      IN s_lifnr
  AND ztmm0006~bldat      IN s_bldat
    AND ztmm0006~budat      IN s_budat
    AND ztmm0006~xblnr      IN s_xblnr
    AND ztmm0006~bktxt      IN s_bktxt
    AND ztmm0006~ztransito      IN s_ztran
    AND ztmm0006~zhumedad     IN s_zhum
    AND ztmm0006~ztransportista      IN s_ztrans
    AND ztmm0006~zmatricula1      IN s_zmatr1
    AND ztmm0006~zmatricula2      IN s_zmatr2
    AND ztmm0007~matnr      IN s_matnr
    AND ztmm0007~znum_pesada      IN s_znpes
    AND ztmm0007~lgort     IN s_lgort
    AND ztmm0007~ebeln      IN s_ebeln
    AND ztmm0006~zcontabilizado      IN s_zconta
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 -->
    AND ztmm0006~werks IN lt_rang_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 29.06.2016 <--
* GST - 08/07/2015 ->
    AND ztmm0006~zborrado <> 'X'
    AND ztmm0007~zborrado <> 'X'.
* GST - 08/07/2015 <-

  CLEAR: ls_supervisor, lv_index.

  LOOP AT gt_supervisor INTO ls_supervisor WHERE zcontabilizado = 'X'.
    lv_index = sy-tabix.
    " Recuperar pedido de compras:
    SELECT SINGLE ebeln INTO ls_supervisor-zebeln
      FROM ztmm0006
      WHERE zentrada = ls_supervisor-zentrada.

    IF ls_supervisor-zebeln IS NOT INITIAL.
      " Recuperar documento de material:
      SELECT SINGLE belnr INTO ls_supervisor-belnr
        FROM ekbe
        WHERE ebeln = ls_supervisor-zebeln
        AND vgabe = '1'.
    ENDIF.

    MODIFY gt_supervisor FROM ls_supervisor INDEX lv_index.
  ENDLOOP.

* GST - 22/04/2015 <-

* CMS 20/11/2019 Calcular nuevo campo Peso Neto = Peso Bruto - Tara.
  LOOP AT gt_supervisor ASSIGNING FIELD-SYMBOL(<fs>).

    <fs>-peso_neto = <fs>-brgew - <fs>-ntgew.

  ENDLOOP.


ENDFORM.                    " RECUPERAR_DATOS6

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos6 .

  DATA: ls_variant6 TYPE disvariant.
  DATA: lti_exc TYPE ui_functions.
  DATA: ls_exc TYPE ui_func.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat6.


* Para que muestre el ancho de las columnas optimizado
*  t_layout6-cwidth_opt = 'X'.
*  t_layout-box_fname = 'BOX'.
  t_layout6-stylefname = 'CELLTAB'.
  t_layout6-sel_mode   = 'A'.

  ls_variant6-report   = sy-repid.

* Excluir botones
  ls_exc = cl_gui_alv_grid=>mc_fg_edit.
  APPEND ls_exc TO lti_exc.

* Mostrar alv
  CALL METHOD grid6->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZRMM0002_GRID6'
      is_layout            = t_layout6
      is_variant           = ls_variant6
      i_save               = 'U'
      i_default            = 'X'
      it_toolbar_excluding = lti_exc
    CHANGING
      it_outtab            = gt_supervisor[]
      it_fieldcatalog      = gti_fieldcat6.

  SET HANDLER
*              g_application6->handle_menu_button
*              g_application6->handle_user_command
              g_application6->handle_hotspot_click FOR grid6.
*              g_application6->handle_toolbar FOR grid6.
*  SET HANDLER g_application6->handle_data_changed_finished FOR grid6.

ENDFORM.                    " MOSTRAR_DATOS6


*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT6
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat6 .

*Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZRMM0002_GRID6'
    CHANGING
      ct_fieldcat      = gti_fieldcat6.

* Lo recorremos haciendo las modificaciones necesarias
  LOOP AT gti_fieldcat6 INTO ls_fieldcat.

* INTRODUCIMOS CABECERA LISTADO ALV
    CASE ls_fieldcat-fieldname.

      WHEN 'ZENTRADA'.
        ls_fieldcat-hotspot = 'X'.

      WHEN 'ZPESO_FIJADO'.
        ls_fieldcat-no_out = 'X'.
* GST - 22/04/2015 ->
      WHEN 'ZTRANSPORTISTA'.
        ls_fieldcat-scrtext_l = text-015.
        ls_fieldcat-scrtext_m = text-015.
        ls_fieldcat-scrtext_s = text-015.
      WHEN 'ZEBELN'.
        ls_fieldcat-scrtext_l = text-016.
        ls_fieldcat-scrtext_m = text-016.
        ls_fieldcat-scrtext_s = text-016.
* GST - 22/04/2015 <-
      WHEN 'ZTRANSITO'.
        ls_fieldcat-scrtext_l = 'Tránsito'.
        ls_fieldcat-scrtext_m = 'Tránsito'.
        ls_fieldcat-scrtext_s = 'Tránsito'.
      WHEN 'ZPTOREC'.
        ls_fieldcat-scrtext_l = 'Pto. Rec.'.
        ls_fieldcat-scrtext_m = 'Punto recogida'.
        ls_fieldcat-scrtext_s = 'Punto recogida'.
      WHEN 'ZHUMEDAD'.
        ls_fieldcat-scrtext_l = 'Humedad'.
        ls_fieldcat-scrtext_m = 'Humedad'.
        ls_fieldcat-scrtext_s = 'Humedad'.
      WHEN 'ZDISCONFORMIDAD'.
        ls_fieldcat-scrtext_l = 'Disconf.'.
        ls_fieldcat-scrtext_m = 'Disconformidad'.
        ls_fieldcat-scrtext_s = 'disconformidad'.
      WHEN 'NTGEW'.
        ls_fieldcat-scrtext_l = 'Tara'.
        ls_fieldcat-scrtext_m = 'Tara'.
        ls_fieldcat-scrtext_s = 'Tara'.
        ls_fieldcat-reptext   = 'Tara'.
      WHEN 'BRGEW'.
        ls_fieldcat-scrtext_l = 'Peso bruto'.
        ls_fieldcat-scrtext_m = 'Peso bruto'.
        ls_fieldcat-scrtext_s = 'Peso bruto'.
        ls_fieldcat-reptext = 'Peso bruto'.
      WHEN 'PESO_NETO'.
        ls_fieldcat-scrtext_l = 'Peso neto'.
        ls_fieldcat-scrtext_m = 'Peso neto'.
        ls_fieldcat-scrtext_s = 'Peso neto'.
        ls_fieldcat-reptext = 'Peso neto'.
      WHEN 'PEINH'.
        ls_fieldcat-scrtext_l = 'Cant. base'.
        ls_fieldcat-scrtext_m = 'Cantidad base'.
        ls_fieldcat-scrtext_s = 'Cantidad base'.
      WHEN 'ZPESO_FIJADO'.
        ls_fieldcat-scrtext_l = 'Peso fijado'.
        ls_fieldcat-scrtext_m = 'Peso fijado'.
        ls_fieldcat-scrtext_s = 'Peso fijado'.
      WHEN 'TRANS_RESIDUOS'.
        ls_fieldcat-scrtext_l = 'Transportista de residuos'.
        ls_fieldcat-scrtext_m = 'Transportista residuos'.
        ls_fieldcat-scrtext_s = 'Trans.resi'.

    ENDCASE.
*   Modificamos
    MODIFY gti_fieldcat6 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT6


*&---------------------------------------------------------------------*
*&      Form  REPARTIR_PESO_CAMION_NUEVA_CAL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM repartir_peso_camion_nueva_cal .

  DATA: lv_index LIKE sy-tabix.

  DATA: lv_ntgew_n TYPE entge.
  DATA: lv_bultos_tot TYPE ftanzpk.
  DATA: lv_bvvrel TYPE bvvrel.
  DATA: lv_tot_peso_fijado TYPE ktmng.

  CLEAR gs_datos_1000.
  READ TABLE gt_datos_1000 INTO gs_datos_1000
  WITH KEY ztipo_pesada = 'P'.

* REVISAR QUE SE GUARDE O CONTABILICE CON EL PESO DEL CAMION RELLENO
* EN CASO DE TENER UNA PESADA FINAL
  IF gv_okcode2 = 'BTN_SAVE' OR gv_okcode2 = 'BTN_CONT'.

    CLEAR gs_datos_1000.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY ztipo_pesada = 'F'.
    IF sy-subrc = 0 AND gv_ntgew IS INITIAL.
      MESSAGE e028.
    ENDIF.

  ENDIF.


  IF gv_ntgew > 0.

    CLEAR lv_tot_peso_fijado.
* PRIMERO SUMAMOS LAS CANTIDADES DE LAS POSICIONES QUE ESTEN FIJADAS
    IF NOT gt_datos_1000[] IS INITIAL.
      LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL AND zpeso_fijado = 'X' AND loekz IS INITIAL.
        lv_tot_peso_fijado = lv_tot_peso_fijado + gs_datos_1000-ktmng.
      ENDLOOP.
    ENDIF.

* calculamos el peso neto de la pesada final,
* restando el peso del camion al peso de la mercancia + camion
    CLEAR lv_ntgew_n.
*  lv_ntgew_n = gs_datos_1000-ntgew - gv_ntgew.
    lv_ntgew_n = gv_brgew - gv_ntgew.

* quitamos el peso de las posiciones fijadas
    lv_ntgew_n = lv_ntgew_n - lv_tot_peso_fijado.

* CALCUALMOS EL NUMERO TOTAL DE BULTOS
    CLEAR lv_bultos_tot.
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE zpeso_fijado IS INITIAL AND loekz IS INITIAL.
      lv_bultos_tot = lv_bultos_tot + gs_datos_1000-ftanzpk.
    ENDLOOP.

* REPARTIR EL PESO DE LA PESADA FINAL
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ftanzpk IS INITIAL AND zpeso_fijado IS INITIAL AND loekz IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-ktmng = ( gs_datos_1000-ftanzpk * lv_ntgew_n ) / lv_bultos_tot.
      gs_datos_1000-ntgew = gv_ntgew.
      gs_datos_1000-znum_pesada = gv_znum_pesada.
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.

* COPIAR LA NUEVA TARA A TODAS LAS POSICIONES DEL ALV
    LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ftanzpk IS INITIAL AND zpeso_fijado = 'X' AND loekz IS INITIAL.
      lv_index = sy-tabix.
      gs_datos_1000-ntgew = gv_ntgew.
*    gs_datos_1000-znum_pesada = gv_znum_pesada.
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.

* CALCULAR LA CANTIDAD CON EL PORCENTAJE DE HUMIDAD
    IF NOT gv_bvvrel IS INITIAL AND NOT gt_datos_1000[] IS INITIAL.
      CLEAR lv_index.
      LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL AND loekz IS INITIAL.
        lv_index = sy-tabix.
        gs_datos_1000-menge = ( gs_datos_1000-ktmng * gv_bvvrel ) / 100.
        gs_datos_1000-menge = gs_datos_1000-ktmng - gs_datos_1000-menge.
        MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
      ENDLOOP.
    ELSE.
      CLEAR lv_index.
      LOOP AT gt_datos_1000 INTO gs_datos_1000 WHERE NOT ktmng IS INITIAL AND loekz IS INITIAL.
        lv_index = sy-tabix.
        gs_datos_1000-menge = gs_datos_1000-ktmng .
        MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
      ENDLOOP.

    ENDIF.

  ENDIF.

ENDFORM.                    " REPARTIR_PESO_CAMION_NUEVA_CAL

*&---------------------------------------------------------------------*
*&      Form  FIJAR_PESO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fijar_peso USING e_ucomm.


  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  PERFORM solicitar_peso CHANGING gs_datos_1000-ktmng.

  IF gs_datos_1000-zpeso_fijado = 'X'.
    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX ls_sel_rows-row_id.

* REAPARTIMOS EL PESO RESTANTE EN LAS OTRAS POSICIONES
    PERFORM repartir_peso_camion_nueva_cal.

    CALL METHOD grid->refresh_table_display.
  ENDIF.


ENDFORM.                    " FIJAR_PESO


*&---------------------------------------------------------------------*
*&      Form  SOLICITAR_PESO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM solicitar_peso CHANGING lv_ktmng.

  DATA: lv_return TYPE c,
        lt_fields LIKE sval OCCURS 0,
        ls_fields TYPE sval.


  CLEAR: ls_fields, lv_return.
  ls_fields-tabname = 'EKPO'.
  ls_fields-fieldname = 'KTMNG'.
  ls_fields-fieldtext = 'Peso a Fijar'.
  APPEND ls_fields TO lt_fields.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-009
*     START_COLUMN    = '5'
*     START_ROW       = '5'
    IMPORTING
      returncode      = lv_return
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
  CLEAR ls_fields.
  READ TABLE lt_fields INTO ls_fields
  INDEX 1.
  IF NOT ls_fields IS INITIAL AND lv_return IS INITIAL.
    lv_ktmng = ls_fields-value.
    gs_datos_1000-zpeso_fijado = 'X'.
  ENDIF.


ENDFORM.                    " SOLICITAR_PESO

*&---------------------------------------------------------------------*
*&      Form  ANADIR_BALA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_E_UCOMM  text
*----------------------------------------------------------------------*
FORM anadir_bala  USING  e_ucomm.

  DATA: lv_ftanzpk TYPE ftanzpk.
* GST - 19/05/2015 ->
  DATA: lv_ok         TYPE xflag,
        lv_periodo(7).
* GST - 19/05/2015 <-

  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  PERFORM solicitar_balas USING    e_ucomm
                          CHANGING lv_ftanzpk.

  IF lv_ftanzpk <> 0.

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
    CLEAR: lv_ok, lv_periodo.
    CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
      EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
        i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
        i_budat = gv_budat
      IMPORTING
        e_ok    = lv_ok.

    IF lv_ok <> 'X'.
      CLEAR lv_periodo.
      CONCATENATE gv_budat+4(2) gv_budat+0(4)
                  INTO lv_periodo SEPARATED BY '.'.
      MESSAGE i097(zmm) WITH lv_periodo.
    ELSE.
* GST - 19/05/2015 <-

* CREAMOS LOTES
      PERFORM crear_lotes USING e_ucomm
                                lv_ftanzpk
                                ls_sel_rows-row_id.

      gs_datos_1000-ftanzpk = gs_datos_1000-ftanzpk + lv_ftanzpk.

      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX ls_sel_rows-row_id.

* REAPARTIMOS EL PESO RESTANTE EN LAS OTRAS POSICIONES
      PERFORM repartir_peso_camion_nueva_cal.

* GST - 19/05/2015 ->
* Si no hay errores, al imprimir las etiquetas, se hacen las entradas en tabla:
* 2.-A.- guardar cabecera
      PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
      PERFORM guardar_posiciones.

* GST - 19/05/2015 <-

      CALL METHOD grid->refresh_table_display.

* GST - 19/05/2015 ->
    ENDIF.
* GST - 19/05/2015 <-

  ENDIF.



ENDFORM.                    " ANADIR_BALA

*&---------------------------------------------------------------------*
*&      Form  SOLICITAR_BALAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_GS_DATOS_1000_FTANZPK  text
*----------------------------------------------------------------------*
FORM solicitar_balas  USING e_ucomm
                      CHANGING lv_ftanzpk.

  DATA: lv_return TYPE c,
        lt_fields LIKE sval OCCURS 0,
        ls_fields TYPE sval.


  CLEAR: ls_fields, lv_return.
  ls_fields-tabname = 'ZTMM0007'.
  ls_fields-fieldname = 'FTANZPK'.
  IF e_ucomm = 'BT_ANADIR'.
    ls_fields-fieldtext = 'Balas a añadir'.
  ELSEIF e_ucomm = 'BT_DESCONTAR'.
    ls_fields-fieldtext = 'Balas a descontar'.
  ENDIF.

  APPEND ls_fields TO lt_fields.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-010
*     START_COLUMN    = '5'
*     START_ROW       = '5'
    IMPORTING
      returncode      = lv_return
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
  CLEAR ls_fields.
  READ TABLE lt_fields INTO ls_fields
  INDEX 1.
  IF NOT ls_fields IS INITIAL AND lv_return IS INITIAL.
    lv_ftanzpk = ls_fields-value.
  ENDIF.

ENDFORM.                    " SOLICITAR_BALAS

*&---------------------------------------------------------------------*
*&      Form  DESCONTAR_BALA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_E_UCOMM  text
*----------------------------------------------------------------------*
FORM descontar_bala  USING  e_ucomm.

  DATA: lv_ftanzpk TYPE ftanzpk.
  DATA: error_borrar_lote TYPE c.
* GST - 19/05/2015 ->
  DATA: lv_ok         TYPE xflag,
        lv_periodo(7).
* GST - 19/05/2015 <-

  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  IF gs_datos_1000-ftanzpk > 1.

    PERFORM solicitar_balas   USING    e_ucomm
                              CHANGING lv_ftanzpk.

    IF lv_ftanzpk <> 0 AND lv_ftanzpk < gs_datos_1000-ftanzpk.

* GST - 19/05/2015 ->
* SAT 7000006535 - Ticket 6336:

* Comprobar que se puede contabilizar a esa fecha:
      CLEAR: lv_ok, lv_periodo.
      CALL FUNCTION 'ZMFMM_CHECK_CIERRE'
        EXPORTING
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
          i_werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
          i_budat = gv_budat
        IMPORTING
          e_ok    = lv_ok.

      IF lv_ok <> 'X'.
        CLEAR lv_periodo.
        CONCATENATE gv_budat+4(2) gv_budat+0(4)
                    INTO lv_periodo SEPARATED BY '.'.
        MESSAGE i097(zmm) WITH lv_periodo.
      ELSE.
* GST - 19/05/2015 <-

* solicitamos los lotes a borrar
        PERFORM solicitar_lotes USING ls_sel_rows-row_id
                                      lv_ftanzpk
                                CHANGING error_borrar_lote.

* si no ha dado error el borrado de lote
        IF error_borrar_lote IS INITIAL.
          gs_datos_1000-ftanzpk = gs_datos_1000-ftanzpk - lv_ftanzpk.

          MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX ls_sel_rows-row_id.

* REAPARTIMOS EL PESO RESTANTE EN LAS OTRAS POSICIONES
          PERFORM repartir_peso_camion_nueva_cal.

          CALL METHOD grid->refresh_table_display.
        ENDIF.

* GST - 19/05/2015 ->
      ENDIF.
* GST - 19/05/2015 <-

    ELSE.
*      MESSAGE e062.
      MESSAGE w062 DISPLAY LIKE 'I'.
    ENDIF.

  ELSE.
*    MESSAGE e061.
    MESSAGE w061 DISPLAY LIKE 'I'.
  ENDIF.

ENDFORM.                    " DESCONTAR_BALA

*&---------------------------------------------------------------------*
*&      Form  SOLICITAR_LOTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM solicitar_lotes USING lv_indice
                            lv_ftanzpk
                     CHANGING error_borrar_lote.

  DATA: lv_pos TYPE ebelp.
  DATA: lv_sel TYPE i.

  DATA:
    go_popup  TYPE REF TO cl_reca_gui_f4_popup,
    gf_choice TYPE        flag.
  DATA: lv_licha TYPE lichn.


  CLEAR: lv_licha, lv_pos.
  lv_pos = lv_indice.
  CONCATENATE gv_entrada lv_pos INTO lv_licha.
*  lv_licha = gv_entrada && '&'.

  CLEAR gt_charg.
  REFRESH gt_charg.

  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_charg
      FROM mch1
      INNER JOIN makt ON makt~matnr = mch1~matnr
      WHERE licha = lv_licha
      AND mch1~matnr = gs_datos_1000-matnr
      AND lvorm = ''.


  CALL METHOD cl_reca_gui_f4_popup=>factory_grid
    EXPORTING
      it_f4value     = gt_charg[]
      if_multi       = abap_true
      id_title       = text-001
    RECEIVING
      ro_f4_instance = go_popup.



  CALL METHOD go_popup->display
    EXPORTING
      id_start_column = 25 "i_start_column
      id_start_line   = 6  "i_start_line
      id_end_column   = 150 "i_end_column
      id_end_line     = 20 "i_end_line
    IMPORTING
      et_result       = gt_charg[]
      ef_cancelled    = gf_choice.

  IF gf_choice IS INITIAL.
    IF NOT gt_charg[] IS INITIAL.
      CLEAR lv_sel.
      DESCRIBE TABLE gt_charg LINES lv_sel.

      IF lv_sel <> lv_ftanzpk.
        MESSAGE s063.

        PERFORM solicitar_lotes USING lv_indice
                                      lv_ftanzpk
                                CHANGING error_borrar_lote.
      ELSE.
* borramos los lotes seleccionados
        PERFORM borrar_lotes CHANGING error_borrar_lote.
      ENDIF.
    ELSE.
      MESSAGE i064(zmm)." DISPLAY LIKE 'I'.
      error_borrar_lote = 'X'.
    ENDIF.
  ELSE.
    MESSAGE i064(zmm)." DISPLAY LIKE 'I'.
    error_borrar_lote = 'X'.
  ENDIF.

ENDFORM.                    " SOLICITAR_LOTES

*&---------------------------------------------------------------------*
*&      Form  BORRAR_LOTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM borrar_lotes CHANGING error_borrar_lote.

  DATA: ls_batchatt  TYPE bapibatchatt,
        ls_batchattx TYPE bapibatchattx,
        lt_return    LIKE bapiret2 OCCURS 0,
        ls_return    TYPE bapiret2.


  LOOP AT gt_charg INTO gs_charg.

    CLEAR: ls_batchatt, ls_batchattx.

    ls_batchatt-del_flag = 'X'.
    ls_batchattx-del_flag = 'X'.
    ls_batchattx-vendrbatch = 'X'.

    CALL FUNCTION 'BAPI_BATCH_CHANGE'
      EXPORTING
        material         = gs_charg-matnr
        batch            = gs_charg-charg
*       PLANT            =
        batchattributes  = ls_batchatt
        batchattributesx = ls_batchattx
*       BATCHCONTROLFIELDS       =
*       INTERNALNUMBERCOM        =
*       EXTENSION1       =
*       MATERIAL_EVG     =
* IMPORTING
*       BATCHATTRIBUTES  =
      TABLES
        return           = lt_return.

    READ TABLE lt_return INTO ls_return
    WITH KEY type = 'E'.
    IF sy-subrc <> 0.
* GUARDAR LOS CON LOS LOTES CREADOS
      READ TABLE lt_return INTO ls_return
      WITH KEY type = 'S'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      gs_messages-id = 'ZMM'.
      gs_messages-number = 065.
      gs_messages-type = 'W'.
      gs_messages-message_v1 = gs_charg-charg.
*      gs_messages-message_v1 = gs_charg-charg.
      APPEND gs_messages TO gt_messages.
    ELSE.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
      error_borrar_lote = 'X'.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " BORRAR_LOTES


**&---------------------------------------------------------------------*
**&      Form  IMPRIMIR_ETIQUETA_SMARTFORM
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_LV_BATCH  text
**      -->P_GS_PPARCIAL  text
**      -->P_LF_FM_NAME  text
**----------------------------------------------------------------------*
*FORM imprimir_etiqueta_smartform  USING  v_charg
*                              ls_impr LIKE LINE OF pesada_parcial
*                              lf_fm_name TYPE rs38l_fnam.
*
*  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_GENERICA_A5'.
**  DATA: lf_fm_name TYPE rs38l_fnam.
*  DATA: ls_eti TYPE zsmm_etiqueta_generica.
*  DATA ls_doc_param TYPE sfpdocparams.
*  DATA: lv_matnr TYPE matnr.
*  DATA: ls_parameters TYPE ssfctrlop,
*        ls_options    TYPE ssfcompop.
*
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*  CLEAR ls_eti.
*  ls_eti-matnr = ls_impr-matnr.
*  ls_eti-maktx = ls_impr-maktx.
*  ls_eti-charg = v_charg.
**  ls_eti-clabs = ls_impr-ktmng.
**  ls_eti-meins = ls_impr-meins.
*  ls_eti-lifnr = gv_lifnr.
*  ls_eti-name1 = gv_name1.
*  ls_eti-lwedt = gv_bldat.
*  ls_eti-lgort = ls_impr-lgort.
**  ls_eti-licha = .
*
*  SELECT SINGLE lgobe INTO ls_eti-lgobe
*  FROM t001l
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*  WHERE werks = gv_werks
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*  AND lgort = ls_impr-lgort.
*
*  CLEAR lv_matnr.
*  lv_matnr = ls_impr-matnr.
**  CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
**    EXPORTING
**      input  = ls_impr-matnr
**    IMPORTING
**      output = lv_matnr.
*
*  CONCATENATE lv_matnr v_charg INTO ls_eti-cod_barras.
*
*  CLEAR lf_fm_name.
*
*  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
*    EXPORTING
*      formname           = lf_formname
**     VARIANT            = ' '
**     DIRECT_CALL        = ' '
*    IMPORTING
*      fm_name            = lf_fm_name
*    EXCEPTIONS
*      no_form            = 1
*      no_function_module = 2
*      OTHERS             = 3.
*  IF sy-subrc <> 0.
** Implement suitable error handling here
*  ENDIF.
*
**  IF ls_options IS INITIAL.
*  CLEAR: ls_parameters, ls_options.
**  ls_parameters-preview = 'X'.       "Preview the output of Smartform                "<--------
*ls_parameters-no_dialog = 'X'.       "Don't show Dialog                        "<--------
*ls_options-tddest = 'LOCT'.      "Spool: Output device              "<--------
*  ls_options-tdnoprint = ' '.       "No printing from print preview
*  ls_options-tdimmed = 'X'.
*  ls_options-tdnewid = 'X'.
**  ELSE.
**    ls_parameters-no_dialog = 'X'.
**  ENDIF.
*
*  CALL FUNCTION lf_fm_name
*    EXPORTING
*      control_parameters = ls_parameters
*output_options     = ls_options " This is that structure which has printer details
*user_settings      = ''
*ls_eti             = ls_eti
**    IMPORTING
**     job_output_info    = gs_job_output_info
*EXCEPTIONS
*formatting_error   = 1
*internal_error     = 2
*send_error         = 3
*user_canceled      = 4
*OTHERS             = 5.
*
*ENDFORM.                    " IMPRIMIR_ETIQUETA_SMARTFORM


**&---------------------------------------------------------------------*
**&      Form  REIMPRIMIR_SMARTFORMS
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_E_UCOMM  text
**----------------------------------------------------------------------*
*FORM reimprimir_smartforms  USING  e_ucomm.
*
*  CLEAR gv_pesada.
*  LOOP AT lt_sel_rows INTO ls_sel_rows.
*    READ TABLE gt_datos_1000 INTO gs_datos_1000
*    INDEX ls_sel_rows-row_id.
*  ENDLOOP.
*
*  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_GENERICA_A5'.
*  DATA: lf_fm_name TYPE rs38l_fnam.
*  DATA: ls_eti TYPE zsmm_etiqueta_generica.
*  DATA ls_doc_param TYPE sfpdocparams.
*  DATA: lv_licha TYPE lichn.
*  DATA: lt_mch1 LIKE mch1 OCCURS 0,
*        ls_mch1 TYPE mch1.
*  DATA: lv_matnr TYPE matnr.
*
*  DATA: ls_parameters TYPE ssfctrlop,
*        ls_options    TYPE ssfcompop.
*
*
*  CLEAR lv_licha .
*  CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.  " SEPARATED BY '/'.
*
*  CLEAR lt_mch1.
*  REFRESH lt_mch1.
*  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE lt_mch1
*    FROM mch1
*    WHERE matnr = gs_datos_1000-matnr
*    AND licha = lv_licha.
*
*  LOOP AT lt_mch1 INTO ls_mch1.
*
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*    CLEAR ls_eti.
*    ls_eti-matnr = gs_datos_1000-matnr.
*    ls_eti-maktx = gs_datos_1000-maktx.
*
*    ls_eti-charg = ls_mch1-charg.
**  ls_eti-clabs = ls_impr-matnr.
**  ls_eti-meins = ls_impr-matnr.
*    ls_eti-lifnr = gv_lifnr.
*    ls_eti-name1 = gv_name1.
*    ls_eti-lwedt = gv_bldat.
*    ls_eti-lgort = gs_datos_1000-lgort.
**  ls_eti-licha = .
*
*    SELECT SINGLE lgobe INTO ls_eti-lgobe
*    FROM t001l
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*    WHERE werks = gv_werks
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*    AND lgort = gs_datos_1000-lgort.
*
*    CLEAR lv_matnr.
*    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
*      EXPORTING
*        input  = gs_datos_1000-matnr
*      IMPORTING
*        output = lv_matnr.
*
*    CONCATENATE lv_matnr ls_mch1-charg INTO ls_eti-cod_barras.
*
*    CLEAR lf_fm_name.
*
*    CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
*      EXPORTING
*        formname           = lf_formname
**       VARIANT            = ' '
**       DIRECT_CALL        = ' '
*      IMPORTING
*        fm_name            = lf_fm_name
*      EXCEPTIONS
*        no_form            = 1
*        no_function_module = 2
*        OTHERS             = 3.
*    IF sy-subrc <> 0.
** Implement suitable error handling here
*    ENDIF.
*
**  IF ls_options IS INITIAL.
*    IF sy-tabix = 1.
*      CLEAR: ls_parameters, ls_options.
**  ls_parameters-preview = 'X'.       "Preview the output of Smartform                "<--------
**      ls_parameters-no_dialog = 'X'.       "Don't show Dialog                        "<--------
*      ls_options-tddest = 'LOCT'.      "Spool: Output device              "<--------
**      ls_options-tdnoprint = ' '.       "No printing from print preview
*      ls_options-tdimmed = 'X'.
*      ls_options-tdnewid = 'X'.
*    ELSE.
*      ls_parameters-no_dialog = 'X'.
*    ENDIF.
*
*    CALL FUNCTION lf_fm_name
*      EXPORTING
*        control_parameters = ls_parameters
*        output_options     = ls_options " This is that structure which has printer details
*        user_settings      = ''
*        ls_eti             = ls_eti
**    IMPORTING
**       job_output_info    = gs_job_output_info
*      EXCEPTIONS
*        formatting_error   = 1
*        internal_error     = 2
*        send_error         = 3
*        user_canceled      = 4
*        OTHERS             = 5.
*
*  ENDLOOP.
*
*
*ENDFORM.                    " REIMPRIMIR_SMARTFORMS
**&---------------------------------------------------------------------*
**&      Form  IMPRIMIR_ETIQUETAS
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**  -->  p1        text
**  <--  p2        text
**----------------------------------------------------------------------*
*FORM imprimir_etiquetas .
*
*  DATA: lt_mch1 LIKE mch1 OCCURS 0.
*
*  DATA: ls_datos_1000_aux LIKE LINE OF pesadas,
*        ls_mch1           TYPE         mch1.
*
*  DATA: lv_licha   TYPE lichn,
*        lf_fm_name TYPE rs38l_fnam.
*
*LOOP AT gt_datos_1000 INTO ls_datos_1000_aux WHERE NOT ftanzpk IS INITIAL.
*    CLEAR: lv_licha, lt_mch1.
*    REFRESH: lt_mch1.
*    CONCATENATE gv_entrada ls_datos_1000_aux-posnr INTO lv_licha.
*
*    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mch1
*    FROM mch1
*    WHERE licha = lv_licha.
*
*    LOOP AT lt_mch1 INTO  ls_mch1.
*
*      PERFORM imprimir_etiqueta_nueva USING ls_mch1-charg
*                                            ls_datos_1000_aux
*                                            lf_fm_name.
*
*    ENDLOOP.
*
*  ENDLOOP.
*
*ENDFORM.                    " IMPRIMIR_ETIQUETAS
**&---------------------------------------------------------------------*
**&      Form  IMPRIMIR_ETIQUETA_NUEVA
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_LS_MCH1_CHARG  text
**      -->P_LS_DATOS_1000  text
**      -->P_LF_FM_NAME  text
**----------------------------------------------------------------------*
*FORM imprimir_etiqueta_nueva  USING    v_charg
*                                       ls_impr LIKE LINE OF pesadas
*                                       lf_fm_name TYPE rs38l_fnam.
*
*  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_GENERICA_A5'.
**  DATA: lf_fm_name TYPE rs38l_fnam.
*  DATA: ls_eti TYPE zsmm_etiqueta_generica.
*  DATA ls_doc_param TYPE sfpdocparams.
*  DATA: lv_matnr TYPE matnr.
*  DATA: ls_parameters TYPE ssfctrlop,
*        ls_options    TYPE ssfcompop.
*
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*  CLEAR ls_eti.
*  ls_eti-matnr = ls_impr-matnr.
*  ls_eti-maktx = ls_impr-maktx.
*  ls_eti-charg = v_charg.
**  ls_eti-clabs = ls_impr-ktmng.
**  ls_eti-meins = ls_impr-meins.
*  ls_eti-lifnr = gv_lifnr.
*  ls_eti-name1 = gv_name1.
*  ls_eti-lwedt = gv_bldat.
*  ls_eti-lgort = ls_impr-lgort.
*
*  SELECT SINGLE lgobe INTO ls_eti-lgobe
*  FROM t001l
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
*  WHERE werks = gv_werks
**     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
*  AND lgort = ls_impr-lgort.
*
*  CLEAR lv_matnr.
*  lv_matnr = ls_impr-matnr.
*
*  CONCATENATE lv_matnr v_charg INTO ls_eti-cod_barras.
*
*  CLEAR lf_fm_name.
*
*  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
*    EXPORTING
*      formname           = lf_formname
**     VARIANT            = ' '
**     DIRECT_CALL        = ' '
*    IMPORTING
*      fm_name            = lf_fm_name
*    EXCEPTIONS
*      no_form            = 1
*      no_function_module = 2
*      OTHERS             = 3.
*  IF sy-subrc <> 0.
** Implement suitable error handling here
*  ENDIF.
*
**  IF ls_options IS INITIAL.
*  CLEAR: ls_parameters, ls_options.
**  ls_parameters-preview = 'X'.       "Preview the output of Smartform                "<--------
*ls_parameters-no_dialog = 'X'.       "Don't show Dialog                        "<--------
*ls_options-tddest = 'LOCT'.      "Spool: Output device              "<--------
*  ls_options-tdnoprint = ' '.       "No printing from print preview
*  ls_options-tdimmed = 'X'.
*  ls_options-tdnewid = 'X'.
**  ELSE.
**    ls_parameters-no_dialog = 'X'.
**  ENDIF.
*
*  CALL FUNCTION lf_fm_name
*    EXPORTING
*      control_parameters = ls_parameters
*output_options     = ls_options " This is that structure which has printer details
*user_settings      = ''
*ls_eti             = ls_eti
**    IMPORTING
**     job_output_info    = gs_job_output_info
*EXCEPTIONS
*formatting_error   = 1
*internal_error     = 2
*send_error         = 3
*user_canceled      = 4
*OTHERS             = 5.
*
*ENDFORM.                    " IMPRIMIR_ETIQUETA_NUEVA
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETAS_NUEVAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiquetas_nuevas .

  DATA: ls_etiquetas LIKE LINE OF etiquetas.

  DATA: lf_fm_name TYPE rs38l_fnam.

  LOOP AT gt_etiquetas INTO ls_etiquetas.
    PERFORM imprimir_etiqueta_nueva_v2 USING ls_etiquetas
                                             lf_fm_name.

  ENDLOOP.

* Al imprimir las etiquetas, vaciamos la tabla:
  CLEAR gt_etiquetas.
  REFRESH gt_etiquetas.

ENDFORM.                    " IMPRIMIR_ETIQUETAS_NUEVAS
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA_NUEVA_V2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_ETIQUETAS  text
*      -->P_LF_FM_NAME  text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta_nueva_v2  USING ls_impr LIKE LINE OF etiquetas
                                       lf_fm_name TYPE rs38l_fnam.

  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_GENERICA_A5'.
*  DATA: lf_fm_name TYPE rs38l_fnam.
  DATA: ls_eti TYPE zsmm_etiqueta_generica.
  DATA ls_doc_param TYPE sfpdocparams.
  DATA: lv_matnr TYPE matnr.
  DATA: ls_parameters TYPE ssfctrlop,
        ls_options    TYPE ssfcompop.

* RELLENAR LA ESTRUCTURA A IMPRIMIR
  CLEAR ls_eti.
  ls_eti-matnr = ls_impr-matnr.
  ls_eti-maktx = ls_impr-maktx.
  ls_eti-charg = ls_impr-charg.
*  ls_eti-clabs = ls_impr-ktmng.
*  ls_eti-meins = ls_impr-meins.
  ls_eti-lifnr = gv_lifnr.
  ls_eti-name1 = gv_name1.
  ls_eti-lwedt = gv_bldat.
  ls_eti-lgort = ls_impr-lgort.

  SELECT SINGLE lgobe INTO ls_eti-lgobe
  FROM t001l
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 -->
  WHERE werks = gv_werks
*     SKUZMYCHOV ROLLOUT PAPELERA SARRIÁ 28.06.2016 <--
  AND lgort = ls_impr-lgort.

  CLEAR lv_matnr.
  lv_matnr = ls_impr-matnr.

  CONCATENATE lv_matnr ls_impr-charg INTO ls_eti-cod_barras.

  CLEAR lf_fm_name.

  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
    EXPORTING
      formname           = lf_formname
*     VARIANT            = ' '
*     DIRECT_CALL        = ' '
    IMPORTING
      fm_name            = lf_fm_name
    EXCEPTIONS
      no_form            = 1
      no_function_module = 2
      OTHERS             = 3.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.

*  IF ls_options IS INITIAL.
  CLEAR: ls_parameters, ls_options.
*  ls_parameters-preview = 'X'.       "Preview the output of Smartform                "<--------
  ls_parameters-no_dialog = 'X'.       "Don't show Dialog                        "<--------
  ls_options-tddest = 'LOCT'.      "Spool: Output device              "<--------
  ls_options-tdnoprint = ' '.       "No printing from print preview
  ls_options-tdimmed = 'X'.
  ls_options-tdnewid = 'X'.
*  ELSE.
*    ls_parameters-no_dialog = 'X'.
*  ENDIF.

  CALL FUNCTION lf_fm_name
    EXPORTING
      control_parameters = ls_parameters
      output_options     = ls_options " This is that structure which has printer details
      user_settings      = ''
      ls_eti             = ls_eti
*    IMPORTING
*     job_output_info    = gs_job_output_info
    EXCEPTIONS
      formatting_error   = 1
      internal_error     = 2
      send_error         = 3
      user_canceled      = 4
      OTHERS             = 5.

ENDFORM.                    " IMPRIMIR_ETIQUETA_NUEVA_V2
*&---------------------------------------------------------------------*
*&      Form  ALV_PROC_BORRAR_LIN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM alv_proc_borrar_lin .

  DATA: lt_selected_row TYPE lvc_t_roid.

  DATA: ls_selected_row TYPE         lvc_s_roid,
        ls_supervisor   LIKE LINE OF gt_supervisor.

  DATA: lv_index LIKE sy-tabix.

  REFRESH lt_selected_row.
  CALL METHOD grid6->get_selected_rows
    IMPORTING
      et_row_no = lt_selected_row.

*Validación: Que se haya seleccionado mínimo una posición
  CLEAR ls_selected_row.
  READ TABLE lt_selected_row INTO ls_selected_row INDEX 1.
  IF ls_selected_row IS INITIAL.
    MESSAGE i098(zmm).
  ENDIF.

  LOOP AT lt_selected_row INTO ls_selected_row.
    CLEAR: ls_supervisor.
    READ TABLE gt_supervisor INTO ls_supervisor INDEX ls_selected_row-row_id.
    IF ls_supervisor-zebeln IS INITIAL AND ls_supervisor-belnr IS INITIAL.
      PERFORM marc_borrado CHANGING ls_supervisor.
      MODIFY gt_supervisor FROM ls_supervisor INDEX ls_selected_row-row_id.
    ENDIF.
  ENDLOOP.

  " No sacar en el listado los registros borrados:
  CLEAR lv_index.
  LOOP AT gt_supervisor INTO ls_supervisor WHERE zborrado = 'X'.
    lv_index = sy-tabix.
    DELETE gt_supervisor INDEX lv_index.
  ENDLOOP.

  CALL METHOD grid6->refresh_table_display.

ENDFORM.                    " ALV_PROC_BORRAR_LIN
*&---------------------------------------------------------------------*
*&      Form  MARC_BORRADO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_SUPERVISOR  text
*----------------------------------------------------------------------*
FORM marc_borrado  CHANGING ps_supervisor TYPE zrmm0002_grid6.

  DATA: ls_ztmm0006 TYPE ztmm0006,
        ls_ztmm0007 TYPE ztmm0007.
  " Marcamos el registro como borrado en el listado:
  ps_supervisor-zborrado = 'X'.

  " Marcar el registro como borrado en la ZTMM0007:
  CLEAR ls_ztmm0007.
  SELECT SINGLE * INTO ls_ztmm0007
      FROM ztmm0007
      WHERE zentrada = ps_supervisor-zentrada
      AND   posnr    = ps_supervisor-posnr.
  IF ls_ztmm0007 IS NOT INITIAL.
    ls_ztmm0007-zborrado = 'X'.
    UPDATE ztmm0007 FROM ls_ztmm0007.
*      COMMIT WORK AND WAIT.
    PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

  ENDIF.

  " Marcar el registro como borrado en la ZTMM0006, si no tiene
  " ninguna posición activa:
  CLEAR ls_ztmm0007.
  SELECT SINGLE * INTO ls_ztmm0007
    FROM ztmm0007
    WHERE zentrada = ps_supervisor-zentrada
    AND zborrado <> 'X'.
  IF ls_ztmm0007 IS INITIAL.
    CLEAR ls_ztmm0006.
    SELECT SINGLE * INTO ls_ztmm0006
        FROM ztmm0006
        WHERE zentrada = ps_supervisor-zentrada.
    IF ls_ztmm0006 IS NOT INITIAL.
      ls_ztmm0006-zborrado = 'X'.
      UPDATE ztmm0006 FROM ls_ztmm0006.
*      COMMIT WORK AND WAIT.
      PERFORM bloquear USING 'B' gv_entrada 'X' CHANGING sw_ok. "

    ENDIF.
  ENDIF.

ENDFORM.                    " MARC_BORRADO

**&---------------------------------------------------------------------*
**&      Form  ALV_REFRESH_TABLE_DISPLAY
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**  -->  p1        text
**  <--  p2        text
**----------------------------------------------------------------------*
*FORM alv_refresh_table_display .
*
*  DATA: ls_stable TYPE lvc_s_stbl,
*        ls_layout  TYPE lvc_s_layo.
*
**Refresh layout
*  CLEAR ls_layout.
*  CALL METHOD grid6->get_frontend_layout
*    IMPORTING
*      es_layout = ls_layout.
*
*  PERFORM alv_prepare_layout CHANGING ls_layout.
*
*  CALL METHOD grid6->set_frontend_layout
*    EXPORTING
*      is_layout = ls_layout.
*
**Refresh data
*  CLEAR ls_stable.
*  ls_stable-row = 'X'.
*  ls_stable-col = 'X'.
*  CALL METHOD grid6->refresh_table_display
*    EXPORTING
*      is_stable = ls_stable
*    EXCEPTIONS
*      finished  = 1
*      OTHERS    = 2.
*  IF sy-subrc <> 0.
*  ENDIF.
*
*ENDFORM.                    " ALV_REFRESH_TABLE_DISPLAY
*&---------------------------------------------------------------------*
*&      Form  GET_CONTR_MARCO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GT_PFINAL  text
*      -->P_GS_CONTRATO_MARCO  text
*----------------------------------------------------------------------*
FORM get_contr_marco  TABLES   gt_pfinal         STRUCTURE pesada_parcial
                       gt_datos_1000     STRUCTURE pesadas
              USING    gs_contrato_marco LIKE  contrato.
  DATA: lv_index LIKE sy-tabix.

  CLEAR gt_pfinal.
  REFRESH gt_pfinal.

* SELECCIONAMOS LAS POSICIONES DEL CONTRATO MARCO PARA MOSTRAR LOS MATERIALES POSIBLES A PESAR
  IF NOT gs_contrato_marco-ebeln IS INITIAL.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_pfinal
    FROM ekpo
    WHERE ebeln = gs_contrato_marco-ebeln
    AND loekz <> 'L'.

  ENDIF.

  LOOP AT gt_pfinal INTO gs_pfinal.
    lv_index = sy-tabix.

    SELECT SINGLE maktx INTO gs_pfinal-maktx
    FROM makt
    WHERE matnr = gs_pfinal-matnr
    AND spras = sy-langu.
    CLEAR gs_pfinal-ktmng.

* MONEDA
    SELECT SINGLE waers INTO gs_pfinal-waers
    FROM ekko
    WHERE ebeln = gs_pfinal-ebeln.

    READ TABLE gt_datos_1000 INTO gs_datos_1000
    WITH KEY matnr = gs_pfinal-matnr.
    IF sy-subrc <> 0.
*     --------------------------------------------------------------------------------*
*     add jtm 02.10.2015 7000008127                                                   *
*     el precio del contrato marco de la posición no depende
      DATA: r_a016 LIKE a016,
            r_konp LIKE konp.
      SELECT  * UP TO 1 ROWS INTO CORRESPONDING FIELDS OF r_a016
          FROM a016 WHERE kappl EQ 'M'
                      AND kschl EQ 'PB00'
                      AND evrtn EQ gs_pfinal-ebeln
                      AND evrtp EQ gs_pfinal-ebelp
                      AND datab <= sy-datum
                      AND datbi >= sy-datum.
      ENDSELECT.
      IF sy-subrc = 0.
        SELECT * INTO r_konp UP TO 1 ROWS FROM konp WHERE knumh EQ r_a016-knumh AND loevm_ko = space.
        ENDSELECT.
        IF sy-subrc EQ 0.
          gs_pfinal-netpr = r_konp-kbetr.
          gs_pfinal-waers = r_konp-konwa.
          gs_pfinal-peinh = r_konp-kpein.
        ENDIF.
*      FROM konp
*      WHERE knumh = ls_a903-knumh.
      ENDIF.

*     fin de add jtm 02.10.2015 7000008127                                            *
*     --------------------------------------------------------------------------------*
      MODIFY gt_pfinal FROM gs_pfinal.
    ELSE.
      DELETE gt_pfinal INDEX lv_index.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " GET_CONTR_MARCO
*&---------------------------------------------------------------------*
*&      Form  BLOQUEAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_0267   text
*      -->P_GV_ENTRADA  text
*      <--P_SW_OK  text
*----------------------------------------------------------------------*
FORM bloquear  USING    VALUE(p_tipo)
                        p_entrada LIKE ztmm0006-zentrada
                        VALUE(p_commit)
               CHANGING p_ok.
  IF p_commit EQ 'X'.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
  ENDIF.
  MOVE 'X' TO p_ok.
  CASE p_tipo.
    WHEN 'B'.
      CALL FUNCTION 'ENQUEUE_EZED_ENTRADA'
        EXPORTING
*         MODE_ZTMM0006  = 'E'
*         MANDT          = SY-MANDT
          zentrada       = p_entrada
*         X_ZENTRADA     = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0
      AND p_commit NE 'X'.
        CLEAR p_ok.
        DATA uname LIKE sy-uname.
        MOVE sy-uname TO uname.
        MESSAGE i398(00) WITH 'Entrada:' p_entrada ' bloqueada por:' uname.
      ENDIF.
    WHEN 'D'.
      CALL FUNCTION 'DEQUEUE_EZED_ENTRADA'
        EXPORTING
*         MODE_ZTMM0006       = 'E'
*         MANDT    = SY-MANDT
          zentrada = p_entrada
*         X_ZENTRADA          = ' '
*         _SCOPE   = '3'
*         _SYNCHRON           = ' '
*         _COLLECT = ' '
        .

  ENDCASE.
ENDFORM.                    " BLOQUEAR


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_PESADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_pesada .

  DATA: lv_pesada TYPE zed_pesada.

  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.

* --> hfc - marcar borrado posición
    IF gs_datos_1000-loekz = 'X'.
      CLEAR:  gs_datos_1000-loekz, gs_datos_1000-icon_loekz.
    ENDIF.


    MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX ls_sel_rows-row_id.

*    DELETE gt_datos_1000 INDEX ls_sel_rows-row_id.

* <-- hfc - marcar borrado posición

  ENDLOOP.

ENDFORM.                    " RECUPERAR_PESADA
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA_MULTIPLES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta_multiples .

*  DATA: ls_doc_param TYPE sfpdocparams.
  DATA: lv_matnr TYPE matnr.

  DATA: ls_parameters TYPE ssfctrlop,
        ls_options    TYPE ssfcompop,
        lf_fm_name    TYPE rs38l_fnam.

  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_MULT_GENERICA_A5'.

  DATA: ls_etiquetas LIKE LINE OF etiquetas.

  DATA: lt_eti TYPE ztmm_etiqueta_generica,
        ls_eti TYPE zsmm_etiqueta_generica.


* RELLENAR LA ESTRUCTURA A IMPRIMIR
  LOOP AT gt_etiquetas INTO ls_etiquetas.
    CLEAR ls_eti.

    ls_eti-matnr = ls_etiquetas-matnr.
    ls_eti-maktx = ls_etiquetas-maktx.
    ls_eti-charg = ls_etiquetas-charg.
    ls_eti-lifnr = gv_lifnr.
    ls_eti-name1 = gv_name1.
    ls_eti-lwedt = gv_bldat.
    ls_eti-lgort = ls_etiquetas-lgort.

    SELECT SINGLE lgobe INTO ls_eti-lgobe
      FROM t001l
      WHERE werks = gv_werks
        AND lgort = ls_etiquetas-lgort.

    CLEAR lv_matnr.
    lv_matnr = ls_etiquetas-matnr.

    CONCATENATE lv_matnr ls_etiquetas-charg INTO ls_eti-cod_barras.

    APPEND ls_eti TO lt_eti.
  ENDLOOP.

  CLEAR lf_fm_name.

  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
    EXPORTING
      formname           = lf_formname
*     VARIANT            = ' '
*     DIRECT_CALL        = ' '
    IMPORTING
      fm_name            = lf_fm_name
    EXCEPTIONS
      no_form            = 1
      no_function_module = 2
      OTHERS             = 3.
  IF sy-subrc <> 0.
*   Implement suitable error handling here
  ENDIF.

  CLEAR: ls_parameters, ls_options.
*  ls_parameters-preview = 'X'.  "Preview the output of Smartform
  ls_parameters-no_dialog = 'X'. "Don't show Dialog
  ls_options-tddest = 'LOCB'.    "Spool: Output device
  ls_options-tdnoprint = ' '.    "No printing from print preview
  ls_options-tdimmed = 'X'.
  ls_options-tdnewid = 'X'.


  CALL FUNCTION lf_fm_name
    EXPORTING
      control_parameters = ls_parameters
      output_options     = ls_options " This is that structure which has printer details
      user_settings      = ''
      lt_eti             = lt_eti
*    IMPORTING
*     job_output_info    = gs_job_output_info
    EXCEPTIONS
      formatting_error   = 1
      internal_error     = 2
      send_error         = 3
      user_canceled      = 4
      OTHERS             = 5.


* Al imprimir las etiquetas, vaciamos la tabla:
  CLEAR lt_eti.
  REFRESH lt_eti.

*  DATA e_datos TYPE zmt_etiquetas_clase10.
*  DATA: wa_datos TYPE zdt_etiquetas_clase10_linea.
*
*  DATA: lo_proxy    TYPE REF TO cl_proxy_client,
*        lv_log_port TYPE prx_logical_port_name.
*
*  DATA: ls_etiquetas LIKE LINE OF etiquetas.
*
*  DATA: lt_eti TYPE ztmm_etiqueta_generica,
*        ls_eti TYPE zsmm_etiqueta_generica.
*
**
** RELLENAR LA ESTRUCTURA A IMPRIMIR
*  LOOP AT gt_etiquetas INTO ls_etiquetas.
*
*    REFRESH e_datos-mt_etiquetas_clase10-linea.
**   Identificador único del registro (autoincremento)
*    wa_datos-id = ''.
*
*    wa_datos-puesto = ''. " = Mayor que 0 para filtrar etiquetas por puestos, 0 para todos los puestos
*
*    wa_datos-usuario = sy-uname.
*
**   Fecha de creación del registro AAAAMMDD
*    wa_datos-fecha = gv_bldat.
*
**   Hora de creación del registro HHMMSS
*    wa_datos-hora = sy-uzeit.
*
**   Código de barras del producto
*    wa_datos-gtin_02 = ''.
*
**   Descripción del producto
*    SELECT SINGLE maktx FROM makt
*      INTO wa_datos-descripcion
*      WHERE spras = sy-langu AND
*            matnr = ls_etiquetas-matnr.
*
**   Descripción breve del origen del producto
*    wa_datos-origen = ''.
*
**   Literal informativo del formato del producto CAJAS,PIEZAS
*    wa_datos-confeccion = ''. " =
*
**   Lote
*    wa_datos-lot_batch_10 = ls_etiquetas-charg.
*
**   Cantidad (puede llevar decimales)
*    CLEAR wa_datos-cantidad_37.
*
**
*    wa_datos-nombre_fabricante = ''. "
**
*    wa_datos-direccion_fabricante = ''. "
**
*    wa_datos-cp_fabricante = ''. "
**
*    wa_datos-provincia_fabricante = ''.
**
*    SELECT SINGLE hsdat FROM mcha INTO @DATA(lv_hsdat) WHERE matnr = @ls_etiquetas-matnr
*       AND charg = @ls_etiquetas-charg AND werks = @gv_werks.
*    wa_datos-fecha_produccion_13 = lv_hsdat.
*
**   Proveedor y nombre
*    wa_datos-codigo_proveedor_91 = gv_lifnr.
*
*    SELECT SINGLE name1 FROM lfa1
*      INTO wa_datos-nombre_proveedor
*      WHERE lifnr = gv_lifnr.
*
**   Código de material
*    wa_datos-codigo_articulo = ls_etiquetas-matnr.
*
**   Código de Material en proveedor
*    SELECT SINGLE idnlf FROM eina
*      INTO wa_datos-codigo_articulo_cliente_241
*      WHERE matnr = ls_etiquetas-matnr.
*
**   P Pendiente de imprimi
*    wa_datos-estado_envio = 'P'.
*
*
**   centro
*    wa_datos-centro = gv_werks.
*
**   Código almacén(almacen_em) y descriptivo(almacen)
*    wa_datos-almacen_em = ls_etiquetas-lgort.
*
*    SELECT SINGLE lgobe FROM t001l
*      INTO wa_datos-almacen
*      WHERE werks = gv_werks AND lgort = ls_etiquetas-lgort.
*
**   Número de copias a imprimir por defecto
*    wa_datos-copias = ''.
*
**   Valor a grabar en la etiqueta (max con tipo activado 16 de longitud)
*    wa_datos-rfid  = ''.
*
*    APPEND wa_datos TO e_datos-mt_etiquetas_clase10-linea.
*
*
*
*    TRY.
*        CREATE OBJECT lo_proxy
*                TYPE ('ZCO_SI_SAP_ETIQUETAS_BALA_OUT')
*                EXPORTING logical_port_name = lv_log_port.
*
*        CAST zco_si_sap_etiquetas_bala_out( lo_proxy )->si_sap_etiquetas_bala_out_b( output = e_datos ).
*
*        COMMIT WORK AND WAIT.
*
*      CATCH cx_root INTO DATA(lr_exc).
*        MESSAGE text-e01 TYPE 'S' DISPLAY LIKE 'E'.
*        EXIT.
*    ENDTRY.
*  ENDLOOP.
** << JJR 11.07.2023
ENDFORM.                    " IMPRIMIR_ETIQUETA_MULTIPLES
*&---------------------------------------------------------------------*
*&      Form  REIMPRIMIR_SMARTFORMS_MULTIPLE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_E_UCOMM  text
*----------------------------------------------------------------------*
FORM reimprimir_smartforms_multiple  USING  e_ucomm.

  DATA: lf_formname TYPE fpname VALUE 'ZSF_ETIQUETA_MULT_GENERICA_A5'.
  DATA: lf_fm_name TYPE rs38l_fnam.
  DATA ls_doc_param TYPE sfpdocparams.

  DATA: lv_licha TYPE lichn.
  DATA: lt_mch1 LIKE mch1 OCCURS 0,
        ls_mch1 TYPE mch1.
  DATA: lv_matnr TYPE matnr.

  DATA: ls_parameters TYPE ssfctrlop,
        ls_options    TYPE ssfcompop.

  DATA: lt_eti TYPE ztmm_etiqueta_generica,
        ls_eti TYPE zsmm_etiqueta_generica.


  CLEAR gv_pesada.
  LOOP AT lt_sel_rows INTO ls_sel_rows.
    READ TABLE gt_datos_1000 INTO gs_datos_1000
    INDEX ls_sel_rows-row_id.
  ENDLOOP.

  CLEAR lv_licha .
  CONCATENATE gv_entrada gs_datos_1000-posnr INTO lv_licha.

  CLEAR lt_mch1.
  REFRESH lt_mch1.
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE lt_mch1
    FROM mch1
    WHERE matnr = gs_datos_1000-matnr
    AND licha = lv_licha.

* RELLENAR LA ESTRUCTURA A IMPRIMIR
  CLEAR lt_eti.
  REFRESH lt_eti.

  LOOP AT lt_mch1 INTO ls_mch1.
    CLEAR ls_eti.

    ls_eti-matnr = gs_datos_1000-matnr.
    ls_eti-maktx = gs_datos_1000-maktx.
    ls_eti-charg = ls_mch1-charg.
    ls_eti-lifnr = gv_lifnr.
    ls_eti-name1 = gv_name1.
    ls_eti-lwedt = gv_bldat.
    ls_eti-lgort = gs_datos_1000-lgort.

    SELECT SINGLE lgobe INTO ls_eti-lgobe
      FROM t001l
      WHERE werks = gv_werks
        AND lgort = gs_datos_1000-lgort.

    CLEAR lv_matnr.
    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
      EXPORTING
        input  = gs_datos_1000-matnr
      IMPORTING
        output = lv_matnr.

    CONCATENATE lv_matnr ls_mch1-charg INTO ls_eti-cod_barras.

    APPEND ls_eti TO lt_eti.
  ENDLOOP.


  CLEAR: ls_parameters, ls_options.
*  ls_parameters-preview = 'X'.  "Preview the output of Smartform
  ls_parameters-no_dialog = 'X'. "Don't show Dialog
  ls_options-tddest = 'LOCB'.    "Spool: Output device
  ls_options-tdnoprint = ' '.    "No printing from print preview
  ls_options-tdimmed = 'X'.
  ls_options-tdnewid = 'X'.


  CLEAR lf_fm_name.

  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
    EXPORTING
      formname           = lf_formname
*     VARIANT            = ' '
*     DIRECT_CALL        = ' '
    IMPORTING
      fm_name            = lf_fm_name
    EXCEPTIONS
      no_form            = 1
      no_function_module = 2
      OTHERS             = 3.
  IF sy-subrc <> 0.
*   Implement suitable error handling here
  ENDIF.

  CALL FUNCTION lf_fm_name
    EXPORTING
      control_parameters = ls_parameters
      output_options     = ls_options
      user_settings      = ''
      lt_eti             = lt_eti
*    IMPORTING
*     job_output_info    = gs_job_output_info
    EXCEPTIONS
      formatting_error   = 1
      internal_error     = 2
      send_error         = 3
      user_canceled      = 4
      OTHERS             = 5.

* Al imprimir las etiquetas, vaciamos la tabla:
  CLEAR lt_eti.
  REFRESH lt_eti.



ENDFORM.                    " REIMPRIMIR_SMARTFORMS_MULTIPLE
*&---------------------------------------------------------------------*
*&      Form  CHECK_ZZPTOREC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_zzptorec .

  DATA: ls_ztmm0022 TYPE ztmm0022,
*        ls_a909     TYPE a909,
        ls_a924     TYPE a924,
        lv_lifnr1   TYPE lifnr,
        lv_answer   TYPE char1.

  DATA: lv_prov TYPE lifnr.

  IF NOT gv_lifnr_input IS INITIAL.
    PERFORM f4_zzptorec.
    CLEAR gv_lifnr_input.
  ENDIF.

  IF NOT gv_zzptorec IS INITIAL.

    SELECT SINGLE * FROM ztmm0022 INTO ls_ztmm0022
      WHERE llief = gv_lifnr AND zzptorec = gv_zzptorec
        AND loevm = space.

    IF sy-subrc <> 0.
      MESSAGE text-020 TYPE 'E'.
    ENDIF.

    SELECT SINGLE zzptorecdes INTO gv_zzptorecdes
      FROM ztmm0021 WHERE zzptorec = gv_zzptorec AND loevm EQ abap_false.

  ELSE.
    CLEAR gv_zzptorecdes.
  ENDIF.

* Calculamos precio....
  IF gv_zzptorec IS INITIAL OR gv_transp IS INITIAL.
*    MESSAGE text-019 TYPE 'E'.
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        text_question         = text-019
        default_button        = '2'
        display_cancel_button = ' '
      IMPORTING
        answer                = lv_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.

  ENDIF.

  IF lv_answer = 1.
    gv_kbetr = 0.
    gv_konwa = 'EUR'.
*gv_kpein =
  ELSE.
    CLEAR lv_lifnr1.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_transp
      IMPORTING
        output = lv_lifnr1.

* INI UDEFINEDES 25.10.2017 Ticket 44589
    CLEAR lv_prov.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gv_lifnr
      IMPORTING
        output = lv_prov.

    CLEAR: gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein, ls_a924.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a924
    FROM a924
    WHERE a924~kschl = 'ZTTR'
    AND a924~lifnr = lv_lifnr1        "transportista
    AND a924~werks = gv_werks
    AND datab <= sy-datum
    AND datbi >= sy-datum
    AND llief = lv_prov               "proveedor recorte
    AND zzptorec = gv_zzptorec.
    IF sy-subrc = 0.
      SELECT SINGLE kschl kbetr konwa kmein kpein INTO
        (gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
               FROM konp
               WHERE knumh = ls_a924-knumh AND loevm_ko = space.

    ELSE.

      CLEAR ls_a924.
      SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_a924
      FROM a924
      WHERE a924~kschl = 'ZTT2'
      AND a924~lifnr = lv_lifnr1        "transportista
      AND a924~werks = gv_werks
      AND datab <= sy-datum
      AND datbi >= sy-datum
      AND llief = lv_prov             "proveedor recorte
      AND zzptorec = gv_zzptorec.
      IF sy-subrc = 0.
        SELECT SINGLE kschl kbetr konwa kmein kpein INTO
          (gv_kschl, gv_kbetr, gv_konwa, gv_kmein, gv_kpein)
                 FROM konp
                 WHERE knumh = ls_a924-knumh AND loevm_ko = space.
* FIN UDEFINEDES
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  F4_ZZPTOREC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f4_zzptorec .

  DATA: lt_ztmm0022 TYPE TABLE OF ztmm0022 WITH HEADER LINE.

  DATA: BEGIN OF ls_lifnr_data,
          llief       TYPE llief,
          name1       TYPE name1_gp,
          zzptorec    TYPE zzptorec,
          zzptorecdes TYPE zzptorecdes,
        END OF ls_lifnr_data,
        lt_lifnr_data LIKE STANDARD TABLE OF ls_lifnr_data.

  DATA: BEGIN OF lt_match OCCURS 0,  "Esta tabla nos devuelve la ayuda
          shlpname  TYPE ddshretval-shlpname,
          fieldname TYPE ddshretval-fieldname,
          recordpos TYPE ddshretval-recordpos,
          fieldval  TYPE ddshretval-fieldval,
          retfield  TYPE ddshretval-retfield,
        END OF lt_match.

  DATA:lt_dynpro_fields TYPE STANDARD TABLE OF dynpread.

  IF NOT gv_lifnr IS INITIAL AND NOT gv_lifnr_input IS INITIAL.

    SELECT * FROM ztmm0022 JOIN
                  ztmm0021 ON ztmm0022~zzptorec = ztmm0021~zzptorec
                           JOIN
                  lfa1     ON ztmm0022~llief = lfa1~lifnr
      INTO CORRESPONDING FIELDS OF TABLE lt_lifnr_data
      WHERE llief = gv_lifnr AND ztmm0022~loevm EQ space.

    IF sy-dbcnt EQ 1.
*      READ TABLE lt_ztmm0022 INDEX 1.
*      gv_zzptorec = lt_ztmm0022-zzptorec.
      READ TABLE lt_lifnr_data INTO ls_lifnr_data INDEX 1.
      gv_zzptorec = ls_lifnr_data-zzptorec.
      SELECT SINGLE zzptorecdes INTO gv_zzptorecdes
            FROM ztmm0021 WHERE zzptorec = gv_zzptorec.

      APPEND VALUE dynpread( fieldname = 'GV_ZZPTORECDES' fieldvalue = gv_zzptorecdes ) TO lt_dynpro_fields.

      CALL FUNCTION 'DYNP_VALUES_UPDATE'
        EXPORTING
          dyname     = sy-cprog
          dynumb     = sy-dynnr
        TABLES
          dynpfields = lt_dynpro_fields.


      CLEAR gv_lifnr_input.
    ELSEIF sy-dbcnt GT 1.
      CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
        EXPORTING
          retfield        = 'ZZPTOREC'
          dynpprog        = sy-repid
          dynpnr          = sy-dynnr
*         dynprofield     = 'GV_ZZPTOREC'
          value_org       = 'S'
        TABLES
          value_tab       = lt_lifnr_data
          return_tab      = lt_match
        EXCEPTIONS
          parameter_error = 1
          no_values_found = 2
          OTHERS          = 3.

      IF sy-subrc = 0.
* Implement suitable error handling here
        READ TABLE lt_match INDEX 1.
        IF sy-subrc = 0.
          MOVE lt_match-fieldval TO gv_zzptorec.
          SELECT SINGLE zzptorecdes INTO gv_zzptorecdes
            FROM ztmm0021 WHERE zzptorec = gv_zzptorec.

          APPEND VALUE dynpread( fieldname = 'GV_ZZPTORECDES' fieldvalue = gv_zzptorecdes ) TO lt_dynpro_fields.

          CALL FUNCTION 'DYNP_VALUES_UPDATE'
            EXPORTING
              dyname     = sy-cprog
              dynumb     = sy-dynnr
            TABLES
              dynpfields = lt_dynpro_fields.


          CLEAR gv_lifnr_input.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDIF.

ENDFORM.

FORM register_f4_fields.    "which fields will have F4 search help
  DATA: lt_f4 TYPE lvc_t_f4 WITH HEADER LINE.
  DATA: lt_f4_data TYPE lvc_s_f4.

  lt_f4_data-fieldname    = 'LGORT'.
  lt_f4_data-register     = 'X' .
  lt_f4_data-chngeafter   ='X'.
**  lt_f4_data-GETBEFORE   ='X'.

  INSERT lt_f4_data INTO TABLE lt_f4.
  CALL METHOD grid4->register_f4_for_fields
    EXPORTING
      it_f4 = lt_f4[].
ENDFORM.                    "register_f4_fields


FORM on_f4  USING   p_e_fieldname
                    row_id
                    p_er_event_data TYPE REF TO cl_alv_event_data
                    p_et_bad_cells
                    p_e_display.
*                     IR_DATA_CHANGED TYPE REF TO cl_alv_changed_data_protocol.
  DATA: BEGIN OF value_lgort OCCURS 0, "the value table that is passed to F4 fm
          werks TYPE werks_d,
          lgort TYPE lgort,
*          clabs like mchb-clabs,
        END OF value_lgort.
  DATA : ls_mod_cell  TYPE lvc_s_modi,
         ls_del_cell  TYPE lvc_s_moce,
         ls_good_cell TYPE lvc_s_modi,
         lv_value     TYPE lvc_value.
  DATA : ls_mod_row LIKE LINE OF gt_pfinal.
*.....,

*.... *§5 define fields and field-symbols for data-update
  FIELD-SYMBOLS: <itab> TYPE lvc_t_modi.
  DATA: ls_modi TYPE lvc_s_modi.
  DATA: return_tab TYPE STANDARD TABLE OF ddshretval.
*  create object ir_data_changed.
*  SORT er_data_changed->mt_mod_cells BY row_id .

*      lti_mod_cells_4000 = er_data_changed->mt_mod_cells.
*****   Recuperamos las líneas modificadas
****    IF lti_mod_cells_4000[] IS NOT INITIAL.
****      gv_bck_modif = 'X'.
****    ELSE.
****      CLEAR gv_bck_modif.
****    ENDIF.


*  LOOP AT er_data_changed->mt_mod_cells
*  LOOP AT lti_mod_cells_4000 INTO ls_mod_cell.
*  ENDLOOP.
  CASE p_e_fieldname.   "read changed cell
    WHEN 'LGORT'.
      ......
* here must be the code to fill in the possible values table
* and the call to fm F4IF_INT_TABLE_VALUE_REQUEST
      ......

      READ TABLE gt_pfinal ASSIGNING FIELD-SYMBOL(<linea_fin>)
      INDEX row_id.
      IF sy-subrc = 0.

      ENDIF.


      SELECT m~lgort , t~lgobe
        FROM mard AS m
        INNER JOIN t001l AS t ON m~werks = t~werks AND m~lgort = t~lgort
        INTO TABLE @DATA(lt_almacenes)
*        WHERE m~matnr = @gs_pfinal-matnr AND
        WHERE m~matnr = @<linea_fin>-matnr AND
              m~werks = @gv_werks AND
              m~lvorm   = ' '  AND "Almacenes NO borrados
              t~lgobe NOT LIKE '%PULPER%'
        ORDER BY m~lgort
              .

      CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
        EXPORTING
          retfield        = 'LGORT'
          value_org       = 'S'
*         DYNPPROG        = SY-REPID
*         DYNPNR          = SY-DYNNR
*         DYNPROFIELD     = 'PRUEFLOS'
        TABLES
          value_tab       = lt_almacenes
*         field_tab       = field_tab
          return_tab      = return_tab
        EXCEPTIONS
          parameter_error = 1
          no_values_found = 2
          OTHERS          = 3.

      p_er_event_data->m_event_handled = 'X'.
      IF sy-subrc = 0.
        READ TABLE return_tab INTO DATA(ls_return) INDEX 1.

        ls_mod_cell-row_id    = row_id.
        ls_mod_cell-fieldname = 'LGORT'.
        MOVE ls_return-fieldval TO lv_value.
        ls_mod_cell-value = lv_value.
*        append ls_mod_cell to er_data_changed->mt_mod_cells.

        <linea_fin>-lgort = ls_return-fieldval.
      ENDIF.
  ENDCASE.

ENDFORM.                    "register_f4_fields

FORM save_data_after_modify_balas.

*  CHECK sy-tcode = 'ZMM0004'.
  CHECK sy-tcode = 'ZMM0004'  OR sy-tcode = 'ZMM0004_REG_VEH'.

  IF gv_znum_pesada IS NOT INITIAL.
    LOOP AT gt_datos_1000 INTO gs_datos_1000.
      DATA(lv_index) = sy-tabix.
      gs_datos_1000-znum_pesada = gv_znum_pesada.
      MODIFY gt_datos_1000 FROM gs_datos_1000 INDEX lv_index.
    ENDLOOP.

  ENDIF.

  PERFORM repartir_peso_camion_nueva_cal.

  PERFORM guardar_cabecera.

* 2.-b.- guardar posiciones
  PERFORM guardar_posiciones.

ENDFORM.

FORM f4_trans_residuos.

  DATA: lt_return  TYPE TABLE OF ddshretval.
  DATA:lt_dynpro_fields TYPE STANDARD TABLE OF dynpread.

*  SELECT lifnr , name1
*    INTO TABLE @DATA(gs_data_residuos)
*    FROM zvpp_transportis
*    WHERE sort2 = 'TRANSP RESIDUOS'.

*  SELECT  name1 , lifnr
**  SELECT lifnr , name1
*    INTO TABLE @DATA(lt_transport)
*    FROM zvpp_trans_resid
*    WHERE sort2 = 'TRANSP RESIDUOS'.


  SELECT  nombre , cir
    INTO TABLE @DATA(lt_transport)
    FROM ztpp0065
    WHERE tp_gestor = 'TR'       AND
          werks     = @gv_werks  AND
          lvorm = ' '.


  CHECK lt_transport IS NOT INITIAL.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
*     retfield        = 'TRANS_RESIDUOS'
      retfield        = 'GS_RESIDUOS-TRANS_RESIDUOS'
      value_org       = 'S'
    TABLES
      value_tab       = lt_transport
      return_tab      = lt_return
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc = 0.
    TRY.
        DATA(ls_selec) = lt_return[ 1 ] .
        gs_residuos-trans_residuos = |{ ls_selec-fieldval ALPHA = OUT }|.

      CATCH cx_root .
    ENDTRY.

  ENDIF.



*        READ TABLE lt_match INDEX 1.
*        IF sy-subrc = 0.
*          MOVE lt_match-fieldval TO gv_zzptorec.
*          SELECT SINGLE zzptorecdes INTO gv_zzptorecdes
*            FROM ztmm0021 WHERE zzptorec = gv_zzptorec.

*  DATA:lt_dynpro_fields TYPE STANDARD TABLE OF dynpread.

*          APPEND VALUE dynpread( fieldname = 'GV_ZZPTORECDES' fieldvalue = gv_zzptorecdes ) TO lt_dynpro_fields.
*
*          CALL FUNCTION 'DYNP_VALUES_UPDATE'
*            EXPORTING
*              dyname     = sy-cprog
*              dynumb     = sy-dynnr
*            TABLES
*              dynpfields = lt_dynpro_fields.
*
*
*          CLEAR gv_lifnr_input.




*    APPEND VALUE dynpread( fieldname = 'GS_RESIDUOS-TRANS_RESIDUOS' fieldvalue = gv_zzptorecdes ) TO lt_dynpro_fields.
*
*    CALL FUNCTION 'DYNP_VALUES_UPDATE'
*      EXPORTING
*        dyname     = sy-cprog
*        dynumb     = sy-dynnr
*      TABLES
*        dynpfields = lt_dynpro_fields.


ENDFORM.

FORM obtener_id_residuos USING p_werks TYPE werks_d
                      CHANGING p_id_residuos TYPE zpp_num_entrada_residuos.

  DATA l_rango_ids TYPE nrobj.

  CASE p_werks.
    WHEN '3000'. l_rango_ids = 'ZPP_RE3000'.
    WHEN '3020'. l_rango_ids = 'ZPP_RE3020'.
    WHEN OTHERS.
  ENDCASE.

  CALL FUNCTION 'NUMBER_GET_NEXT'
    EXPORTING
      nr_range_nr             = '10'
      object                  = l_rango_ids
      quantity                = '1'
*     SUBOBJECT               = ' '
*     TOYEAR                  = '0000'
      ignore_buffer           = 'X'
    IMPORTING
      number                  = p_id_residuos
*     QUANTITY                =
*     RETURNCODE              =
    EXCEPTIONS
      interval_not_found      = 1
      number_range_not_intern = 2
      object_not_found        = 3
      quantity_is_0           = 4
      quantity_is_not_1       = 5
      interval_overflow       = 6
      buffer_overflow         = 7
      OTHERS                  = 8.
  IF sy-subrc <> 0.
    CLEAR p_id_residuos.
  ELSE.
    gs_residuos-id_entrada_residuos = p_id_residuos.
  ENDIF.


ENDFORM.

FORM validaciones_dyn1000 CHANGING p_error TYPE char1.
  DATA: l_lif TYPE lifnr.

  p_error = ' '.

  IF gv_lifnr IS INITIAL.
    MESSAGE |Informar proveedor.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.


  IF gv_xblnr IS INITIAL.
    MESSAGE |Informar nota de entrega.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.

  IF gv_matricula1 IS INITIAL.
    MESSAGE |Informar matrícula tractora.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.

  IF gv_matricula2 IS INITIAL.
    MESSAGE |Informar matrícula remolque.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.

  IF gv_transp IS INITIAL.
    MESSAGE |Informar transportista de facturación.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.



* 69265 - 28/10/2021 - Validar nº albaran del proveedor tratado en el año en curso

  IF gv_entrada IS INITIAL.

    CALL METHOD zclpp_reg_vehiculo_master=>validar_albaran_proveedor
      EXPORTING
        i_albaran = gv_xblnr
        i_lifnr   = gv_lifnr
      IMPORTING
        o_rc      = DATA(l_rc).
  ELSE.

    CALL METHOD zclpp_reg_vehiculo_master=>validar_albaran_proveedor
      EXPORTING
        i_albaran = gv_xblnr
        i_lifnr   = gv_lifnr
        i_entrada = gv_entrada
      IMPORTING
        o_rc      = l_rc.
  ENDIF.

  IF l_rc <> '00'.
    MESSAGE |Albarán { gv_xblnr } duplicado para proveedor { gv_name1 }.| TYPE 'I' DISPLAY LIKE 'E'.
    p_error = 'X'.
    EXIT.
  ENDIF.


* De momento se permite transportista de residuos a blanco.
*  IF gs_residuos-trans_residuos IS INITIAL.
*    MESSAGE |Informar transportista de residuos.| TYPE 'I' DISPLAY LIKE 'E'.
*    p_error = 'X'.
*    EXIT.
*  endif.

  IF gs_residuos-trans_residuos IS NOT INITIAL.

* Validar transportista de residuos.

    SELECT SINGLE nombre
      INTO  @gs_residuos-desc_trans_res
      FROM ztpp0065
      WHERE tp_gestor = 'TR'       AND
            werks     = @gv_werks  AND
            cir       = @gs_residuos-trans_residuos AND
            lvorm     = ' '.
    IF sy-subrc <> 0.
      CLEAR gs_alta_tr-descr_tr.
      CALL SCREEN 1200 STARTING AT 10 4 ENDING AT 59 12.
    ENDIF.
  ENDIF.

*APC20240719 El código LER se recoge al meter el material
*  IF gs_residuos-trans_residuos IS INITIAL OR
*     gs_residuos-dir            IS INITIAL OR
*     gs_residuos-ler            IS INITIAL.
*
*    DATA: l_answer TYPE char1.
*    DATA(l_text_question) = |Datos de residuos en blanco ¿Desea revisarlos?|.
*    CALL FUNCTION 'POPUP_TO_CONFIRM'
*      EXPORTING
*        titlebar              = 'Datos de residuos en blanco'
**       DIAGNOSE_OBJECT       = ' '
*        display_cancel_button = ' '
**       text_question         = 'Se creará el código {  } {} ¿Desear continuar?'(023)
*        text_question         = l_text_question
*        text_button_1         = 'Aceptar'
*        icon_button_1         = '@0V@'
*        text_button_2         = 'Cancelar'
*        icon_button_2         = '@02@'
*      IMPORTING
*        answer                = l_answer.
*
*    IF l_answer NE '1'.
*      EXIT.
*    ELSE.
*      p_error = 'X'.
*      EXIT.
*    ENDIF.
*
*  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA_3000
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta_3000 .

  DATA e_datos TYPE zmt_etiquetas_clase10.
  DATA: wa_datos TYPE zdt_etiquetas_clase10_linea.

  DATA: lo_proxy    TYPE REF TO cl_proxy_client,
        lv_log_port TYPE prx_logical_port_name.

  DATA: ls_etiquetas LIKE LINE OF etiquetas.

  DATA: lt_eti TYPE ztmm_etiqueta_generica,
        ls_eti TYPE zsmm_etiqueta_generica.

*
* RELLENAR LA ESTRUCTURA A IMPRIMIR
  LOOP AT gt_etiquetas INTO ls_etiquetas.

    REFRESH e_datos-mt_etiquetas_clase10-linea.
*   Identificador único del registro (autoincremento)
    wa_datos-id = ''.

    wa_datos-puesto = ''. " = Mayor que 0 para filtrar etiquetas por puestos, 0 para todos los puestos

    wa_datos-usuario = sy-uname.

*   Fecha de creación del registro AAAAMMDD
    wa_datos-fecha = gv_bldat.

*   Hora de creación del registro HHMMSS
    wa_datos-hora = sy-uzeit.

*   Código de barras del producto
    wa_datos-gtin_02 = ''.

*   Descripción del producto
    SELECT SINGLE maktx FROM makt
      INTO wa_datos-descripcion
      WHERE spras = sy-langu AND
            matnr = ls_etiquetas-matnr.

*   Descripción breve del origen del producto
    wa_datos-origen = ''.

*   Literal informativo del formato del producto CAJAS,PIEZAS
    wa_datos-confeccion = ''. " =

*   Lote
    wa_datos-lot_batch_10 = ls_etiquetas-charg.

*   Cantidad (puede llevar decimales)
    CLEAR wa_datos-cantidad_37.

*
    wa_datos-nombre_fabricante = ''. "
*
    wa_datos-direccion_fabricante = ''. "
*
    wa_datos-cp_fabricante = ''. "
*
    wa_datos-provincia_fabricante = ''.
*
    SELECT SINGLE hsdat FROM mcha INTO @DATA(lv_hsdat) WHERE matnr = @ls_etiquetas-matnr
       AND charg = @ls_etiquetas-charg AND werks = @gv_werks.
    wa_datos-fecha_produccion_13 = lv_hsdat.

*   Proveedor y nombre
    wa_datos-codigo_proveedor_91 = gv_lifnr.

    SELECT SINGLE name1 FROM lfa1
      INTO wa_datos-nombre_proveedor
      WHERE lifnr = gv_lifnr.

*   Código de material
    wa_datos-codigo_articulo = ls_etiquetas-matnr.

*   Código de Material en proveedor
    SELECT SINGLE idnlf FROM eina
      INTO wa_datos-codigo_articulo_cliente_241
      WHERE matnr = ls_etiquetas-matnr.

*   P Pendiente de imprimi
    wa_datos-estado_envio = 'P'.


*   centro
    wa_datos-centro = gv_werks.

*   Código almacén(almacen_em) y descriptivo(almacen)
    wa_datos-almacen_em = ls_etiquetas-lgort.

    SELECT SINGLE lgobe FROM t001l
      INTO wa_datos-almacen
      WHERE werks = gv_werks AND lgort = ls_etiquetas-lgort.

*   Número de copias a imprimir por defecto
    wa_datos-copias = ''.

*   Valor a grabar en la etiqueta (max con tipo activado 16 de longitud)
    wa_datos-rfid  = ''.

    APPEND wa_datos TO e_datos-mt_etiquetas_clase10-linea.



    TRY.
        CREATE OBJECT lo_proxy
                TYPE ('ZCO_SI_SAP_ETIQUETAS_BALA_OUT')
                EXPORTING logical_port_name = lv_log_port.

        CAST zco_si_sap_etiquetas_bala_out( lo_proxy )->si_sap_etiquetas_bala_out_b( output = e_datos ).

        COMMIT WORK AND WAIT.

      CATCH cx_root INTO DATA(lr_exc).
        MESSAGE text-e01 TYPE 'S' DISPLAY LIKE 'E'.
        EXIT.
    ENDTRY.
  ENDLOOP.
* << JJR 11.07.2023
ENDFORM.
*&---------------------------------------------------------------------*
*&      Module  VALIDAR_LER  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE validar_ler INPUT.

  CHECK sy-ucomm = 'BTN_PESF'.
  IF gs_residuos-ler IS INITIAL.
    MESSAGE 'Informe código LER' TYPE 'E'.
  ENDIF.

ENDMODULE.
