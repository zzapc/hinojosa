*&---------------------------------------------------------------------*
*&  Include           ZRMM0006_FORMS
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos .
  DATA: ls_stock TYPE zstmm_stock,
        lv_werks TYPE werks_d,
        lv_flag  TYPE xflag,
        lv_name  TYPE name1_gp,
        lv_kunnr TYPE kunnr.

  DATA: lv_company_user TYPE uscomp,
        lv_company_vble TYPE uscomp,
        lv_pico         TYPE menge_d,
        lv_dinamico(1).

  DATA: BEGIN OF lt_stock_aux OCCURS 0.
          INCLUDE STRUCTURE zstmm_stock.
  DATA: END OF lt_stock_aux.

  SELECT SINGLE * FROM tvarvc
    WHERE name EQ 'ZMM2001_PICO'
      INTO @DATA(tvarvc).

  IF sy-subrc EQ 0 AND tvarvc-low NE 'DINAMICA'.
    MOVE tvarvc-low TO lv_pico.
  ELSEIF sy-subrc EQ 0 AND tvarvc-low EQ 'DINAMICA'. " en ese caso, cogemos tolerancia dinámica
    lv_dinamico = abap_true.
  ELSE.
    lv_pico = 400.
  ENDIF.

  CLEAR: gt_stock, lt_stock_aux, ls_stock.
  REFRESH: gt_stock, lt_stock_aux.

  IF so_lenum[] IS NOT INITIAL.

    SELECT b~mtart a~matnr b~matkl b~zzcalidad b~zzgramaje b~zzancho
           b~zzlargo a~werks a~lgort a~charg b~meins
           a~clabs a~cumlm a~cinsm a~ceinm a~cspem a~cretm
           a~cvmla a~cvmum a~cvmin a~cvmei a~cvmsp a~cvmre
           a~ersda a~laeda d~nfmat " ins - cvivo - 05.03.2018 47105: Campo entrada en almacén
      INTO CORRESPONDING FIELDS OF TABLE lt_stock_aux
      FROM mchb AS a
      INNER JOIN mara AS b ON b~matnr = a~matnr
      INNER JOIN marc AS d ON d~matnr = a~matnr " 63129 - cvivo
      INNER JOIN lqua AS c ON c~charg = a~charg
          AND c~werks = a~werks
      WHERE a~matnr IN so_matnr
      AND a~werks IN so_werks
      AND d~werks IN so_werks
      AND a~lgort IN so_lgort
      AND a~charg IN so_charg "GST - 23/03/2015
      AND b~mtart IN so_mtart
      AND b~matkl IN so_matkl
      AND b~zzcalidad IN so_zzcal
      AND b~zzgramaje IN so_zzgra
      AND b~zzancho IN so_zzanc
      AND ( a~clabs <> 0 OR a~cumlm <> 0 OR a~cinsm <> 0
            OR a~ceinm <> 0 OR a~cspem <> 0 OR a~cretm <> 0
            OR a~cretm <> 0 )
      AND c~verme > 0
      AND c~lenum IN so_lenum.
  ELSE.
    SELECT b~mtart a~matnr b~matkl b~zzcalidad b~zzgramaje b~zzancho
           b~zzlargo a~werks a~lgort a~charg b~meins
           a~clabs a~cumlm a~cinsm a~ceinm a~cspem a~cretm
           a~cvmla a~cvmum a~cvmin a~cvmei a~cvmsp a~cvmre
           a~ersda a~laeda d~nfmat " ins - cvivo - 05.03.2018 47105: Campo entrada en almacén
      INTO CORRESPONDING FIELDS OF TABLE lt_stock_aux
      FROM mchb AS a
      INNER JOIN mara AS b ON b~matnr = a~matnr
      INNER JOIN marc AS d ON d~matnr = a~matnr " 63129 - cvivo
      WHERE a~matnr IN so_matnr
      AND a~werks IN so_werks
      AND d~werks IN so_werks
      AND a~lgort IN so_lgort
      AND a~charg IN so_charg "GST - 23/03/2015
      AND b~mtart IN so_mtart
      AND b~matkl IN so_matkl
      AND b~zzcalidad IN so_zzcal
      AND b~zzgramaje IN so_zzgra
      AND b~zzancho IN so_zzanc
      AND ( a~clabs <> 0 OR a~cumlm <> 0 OR a~cinsm <> 0
            OR a~ceinm <> 0 OR a~cspem <> 0 OR a~cretm <> 0
            OR a~cretm <> 0 ).
  ENDIF.

* Recuperar resto de información para mostrar en el alv
  LOOP AT lt_stock_aux INTO ls_stock.
    IF ls_stock-werks = '4000'. "cipasi
      PERFORM recuperar_caract_cipasi  USING ls_stock-matnr
                                             ls_stock-charg
                                      CHANGING ls_stock-kunnr
                                               ls_stock-pedido
                                               ls_stock-posicion
                                               ls_stock-z_materialventa
                                               ls_stock-z_un_med_esp_lote
                                               ls_stock-z_orden
                                               ls_stock-z_aptoalim
                                               ls_stock-z_caduc_corona
                                               ls_stock-z_coex
                                               ls_stock-z_ubicacion
                                               ls_stock-z_inc_planta
                                               ls_stock-z_rech_prod
                                               ls_stock-z_inc_externa
                                               ls_stock-z_devolucion
                                               ls_stock-z_exceso
                                               ls_stock-z_mot_exceso.
    ELSEIF ls_stock-werks CP '2*'. " excluímos cartoneras - cvivo - Proyecto WM
* Para cartoneras buscamos el pedido de compras
      PERFORM pedido_compras  USING ls_stock
                                    lv_pico
                                    lv_dinamico
                           CHANGING ls_stock-pedido
                                    ls_stock-posicion
                                    ls_stock-bob_entera
                                    ls_stock-bob_media
                                    ls_stock-bob_pico.
    ELSE.
      PERFORM recuperar_caract USING ls_stock-matnr
                                     ls_stock-charg
                               CHANGING ls_stock-kunnr
                                        ls_stock-pedido
                                        ls_stock-posicion
                                        ls_stock-vcode
                                        ls_stock-hsdat
                                        ls_stock-z_ubic_hpap
                                        ls_stock-motivo_rechazo
                                        ls_stock-longitud
                                        .
    ENDIF.

    PERFORM calcular_ind_tolerancia CHANGING ls_stock.

    " ini - cvivo - 05.03.2018 47105: Campo entrada en almacén
    IF ls_stock-laeda IS NOT INITIAL. " la fecha de entrada en almacén es la creación si no hay modificación
*      ls_stock-ersda = ls_stock-laeda. " si hay modificación, es esa -> cvivo - 51501 - La fecha de modificación está informando de las salidas parciales del almacén
    ENDIF.
    " fin - cvivo - 05.03.2018 47105: Campo entrada en almacén

*   Campo cliente valor interno:
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = ls_stock-kunnr
      IMPORTING
        output = ls_stock-kunnr.

    CHECK ls_stock-kunnr IN so_kunnr. "AND ls_stock-kunnr IS NOT INITIAL.

    CLEAR lv_werks.
    IF ls_stock-kunnr IS NOT INITIAL.
      SELECT  werks INTO lv_werks UP TO 1 ROWS
        FROM t001w
        WHERE kunnr = ls_stock-kunnr.
      ENDSELECT.
    ENDIF.

*   EBELLVER solicita que se salte la autorización para los usuarios que en
*   la tabla USER_ADDR, el campo COMPANY tenga 'PAPELERA L'ALQUERIA'
    CLEAR: lv_company_user, lv_company_vble.

    lv_company_vble = text-004.

    SELECT SINGLE company INTO lv_company_user
      FROM user_addr
      WHERE bname = sy-uname.

    IF lv_company_user <> lv_company_vble.
*---> SAT 7*12702 el usuario tiene que mostrar los datos del centro
*     que le estamos indicando por la pantalla de seleccion aunque
*     lv_werks <> so_werks.
*      IF lv_werks IS NOT INITIAL.
      AUTHORITY-CHECK OBJECT 'M_MATE_WRK'
                  ID 'ACTVT' FIELD '03'
                  ID 'WERKS' FIELD so_werks.
      "lv_werks
*          CHECK sy-subrc = 0.
*      ELSE.
      IF ls_stock-kunnr IS INITIAL AND ls_stock-werks CP '3*'. " cvivo - no excluimos CIPASI, incluimos solo papeleras
        CONTINUE.
      ENDIF.
*<---
    ENDIF.

* Recuperación descripciones de registros restantes:
    " Descripción texto breve material:
    SELECT SINGLE maktx INTO ls_stock-maktx
      FROM makt
      WHERE matnr = ls_stock-matnr
      AND spras = sy-langu.

    IF ls_stock-nfmat IS NOT INITIAL.
      SELECT SINGLE maktx INTO ls_stock-zmaktx_reempl
        FROM makt
        WHERE matnr = ls_stock-nfmat
        AND spras = sy-langu.
    ENDIF.

    " Descripción grupo de artículos:
    SELECT SINGLE wgbez60 INTO ls_stock-wgbez60
      FROM t023t
      WHERE spras = sy-langu
      AND matkl = ls_stock-matkl.

    " Descripción centro:
    SELECT SINGLE name1 INTO ls_stock-werks_name
      FROM t001w
      WHERE werks = ls_stock-werks.

    " Descripción almacén:
    SELECT SINGLE lgobe INTO ls_stock-lgort_name
      FROM t001l
      WHERE werks = ls_stock-werks
      AND lgort = ls_stock-lgort.

    " Descripción cliente:
    SELECT SINGLE name1 INTO  ls_stock-kunnr_name
      FROM kna1
      WHERE kunnr = ls_stock-kunnr.

    ls_stock-zcont = 1.

    PERFORM recuperar_cantidades_pedido USING ls_stock-pedido   "jvillarta 16/6/17 7000015456 (nuevo form)
                                              ls_stock-posicion
                                     CHANGING ls_stock-ctd_pedida
                                              ls_stock-ctd_servida
                                              ls_stock-ctd_restante.
    APPEND ls_stock TO gt_stock.
  ENDLOOP.


ENDFORM.                    " RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CLIENTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_STOCK_MATNR  text
*      -->P_LS_STOCK_CHARG  text
*      <--P_LS_STOCK_KUNNR  text
*----------------------------------------------------------------------*
FORM recuperar_caract_cipasi  USING    p_matnr
                                       p_charg
                              CHANGING p_kunnr
                                       p_pedido
                                       p_posicion
                                       p_materialventa
                                       p_un_med_esp_lote
                                       p_aufnr
                                       p_aptoalim
                                       p_caduc_corona
                                       p_coex
                                       p_ubicacion
                                       p_inc_planta
                                       p_rech_prod
                                       p_inc_externa
                                       p_devolucion
                                       p_exceso
                                       p_mot_exceso.



  DATA: lv_mtart             TYPE mtart,
        lv_classnum          TYPE bapi1003_key-classnum,
        lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        lv_num               TYPE i,
        lv_fec_n             TYPE n LENGTH 8.

  REFRESH: lt_alloc_values_num, lt_alloc_values_char.
  REFRESH: lt_alloc_values_curr, lt_return.

  CLEAR: lv_object, lv_classnum, ls_alloc_values_char.
  CLEAR: lt_alloc_values_num, lt_alloc_values_char.
  CLEAR: lt_alloc_values_curr, lt_return.

  CONCATENATE p_matnr p_charg INTO lv_object.

  SELECT SINGLE mtart FROM mara
    INTO lv_mtart
    WHERE matnr = p_matnr.

  IF lv_mtart = 'ZPMP'.
    lv_classnum = 'Z_ZPMP'.
  ELSEIF lv_mtart = 'ZPLP'.
    lv_classnum = 'Z_ZPLP'.
  ENDIF.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = lv_classnum
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
*   IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.

* CLIENTE:
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_CLIENTE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_kunnr = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_kunnr.
  ENDIF.



* PEDIDO:
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_PEDIDO'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_pedido = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_pedido.
  ENDIF.

* POSICIÓN:
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_POSICION'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_posicion = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_posicion.
  ENDIF.

* MATERIAL DE VENTA
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_MATERIALVENTA'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_materialventa = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_materialventa.
  ENDIF.

* PESO
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_UN_MED_ESP_LOTE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_un_med_esp_lote = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_un_med_esp_lote.
  ENDIF.


* ORDEN
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_ORDEN'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_aufnr = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_aufnr.
  ENDIF.

* APTOALIM
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_APTOALIM'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_aptoalim = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_aptoalim.
  ENDIF.

* CADUC_CORONA
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_CADUC_CORONA'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_caduc_corona = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_caduc_corona.
  ENDIF.

* COEX
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_COEX'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_coex = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_coex.
  ENDIF.


* UBICACION
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_UBICACION'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_ubicacion = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_ubicacion.
  ENDIF.

* INC_PLANTA
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_INC_PLANTA'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_inc_planta = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_inc_planta.
  ENDIF.

* RECH_PROD
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_RECH_PROD'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_rech_prod = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_rech_prod.
  ENDIF.

* INC_EXTERNA
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_INC_EXTERNA'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_inc_externa = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_inc_externa.
  ENDIF.

* DEVOLUCION
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_DEVOLUCION'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_devolucion = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_devolucion.
  ENDIF.


* EXCESO
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_EXCESO'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_exceso = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_exceso.
  ENDIF.

* MOT_EXCESO
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_MOT_EXCESO'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_mot_exceso = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_mot_exceso.
  ENDIF.

ENDFORM.                    " RECUPERAR_CLIENTE
*&---------------------------------------------------------------------*
*&      Form  OBTENER_CLASIFICACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_STOCK_MATNR  text
*      -->P_LS_STOCK_CHARG  text
*      <--P_LS_STOCK_CHARG  text
*----------------------------------------------------------------------*
FORM obtener_clasificacion  USING    p_matnr
                                     p_charg
                            CHANGING p_hsdat.

  DATA: lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        lv_num               TYPE i,
        lv_fec_n             TYPE n LENGTH 8.

  CLEAR: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr,
  lt_return.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr
  , lt_return.


  CLEAR: lv_object, p_hsdat.
  CONCATENATE p_matnr p_charg INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
* IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.


  CLEAR ls_alloc_values_num.
  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                               WITH KEY charact = 'Z_FECHA_FABRICACION'.
  IF ls_alloc_values_num IS NOT INITIAL.
    CLEAR: lv_num, lv_fec_n.
    lv_num = ls_alloc_values_num-value_from.
    lv_fec_n = lv_num.
    p_hsdat = lv_fec_n .
  ELSE.
    p_hsdat = '00000000'.
  ENDIF.

ENDFORM.                    " OBTENER_CLASIFICACION
*&---------------------------------------------------------------------*
*&      Form  INITIALIZATION_SEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM initialization_sel .

  DATA: ls_werks LIKE LINE OF so_werks,
        lv_werks TYPE         werks_d.

  CLEAR: ls_werks, lv_werks.

  SELECT SINGLE parva FROM usr05
    INTO lv_werks
    WHERE bname = sy-uname AND
          parid = 'WRK'.

  IF lv_werks IS NOT INITIAL.
    ls_werks-sign = 'I'.
    ls_werks-option = 'EQ'.
    ls_werks-low = lv_werks.
    APPEND ls_werks TO so_werks.
  ENDIF.

ENDFORM.                    " INITIALIZATION_SEL
*&---------------------------------------------------------------------*
*&      Form  EXPORTAR_EXCEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM exportar_excel .
*----------------------------Declaración de variables-----------------------------------
  DATA: lv_filename TYPE cgpl_object_text.
  DATA: lv_rutacompleta   TYPE rlgrap-filename,
        lv_rutastr        TYPE epsf-epspath,
        lv_fichero_correo TYPE rlgrap-filename.

  DATA: lt_tablconvertida TYPE truxs_t_text_data.
  DATA: lv_fname2       TYPE         string,
        lv_fname_local  TYPE         string,
        lv_cabecera     LIKE LINE OF lt_tablconvertida,
        lt_emails       TYPE         zttpp0001,
        lv_icmdata      TYPE         icmdata,
        wa_email        TYPE         ad_smtpadr,
        lt_content_bin  TYPE         solix_tab,
        lv_content      TYPE         string,
        lv_content_line TYPE         string.

  DATA: wa_ltdx      TYPE                   ltdx,
        v_varkey     TYPE                   ltdxkey,
        it_fcat      TYPE STANDARD TABLE OF ltdxdata,
        it_sort_info TYPE STANDARD TABLE OF ltdxdata,
        it_filter    TYPE STANDARD TABLE OF ltdxdata.

  DATA: l_varkey       TYPE ltdxkey,
        wa_ltdxdata    TYPE ltdxdata,
        flag_no_out(1),
        wa_fieldcat    TYPE lvc_s_fcat,
        it_fieldcat    TYPE lvc_t_fcat,
        l_struc_index  TYPE i,
        l_path(120).

  DATA: tab TYPE x VALUE 9.
  DATA: l_r_structdescr TYPE REF TO cl_abap_structdescr.

  FIELD-SYMBOLS: <dyn_table> TYPE STANDARD TABLE,
                 <dyn_wa>,
                 <dyn_field>.

  DATA: dy_table       TYPE REF TO  data,
        dy_line        TYPE REF TO  data,
        wa_cab_data    TYPE REF TO  data,
        xfc            TYPE         lvc_s_fcat,
        ifc            TYPE         lvc_t_fcat,
        l_string(1024),
        f_flag         TYPE         xfeld,
*        ls_fieldcat    TYPE LINE OF slis_t_fieldcat_alv,
        ls_fieldcat    TYPE LINE OF lvc_t_fcat,
        l_xls(1024).

  DATA: it_descriptivos TYPE STANDARD TABLE OF dfies,
        wa_desc         TYPE                   dfies.

  DATA: binary_content TYPE solix_tab,
        ls_binary      TYPE solix.
  DATA size TYPE so_obj_len.

****--------------------------Declaración de variables-----------------------------------

  IF gs_variant_flag IS NOT INITIAL.
    SELECT SINGLE * FROM ltdx INTO wa_ltdx
         WHERE relid = c_relid
         AND report =  repid
         AND variant = gs_variant_flag-variant.
  ELSEIF gs_variant IS NOT INITIAL.
    SELECT SINGLE * FROM ltdx INTO wa_ltdx
         WHERE relid = c_relid
         AND report =  repid
         AND variant = gs_variant-variant.
  ENDIF.

  IF  sy-subrc = 0.
    MOVE-CORRESPONDING wa_ltdx TO  v_varkey.

*  Esta función convierte el LTDX de la select en un fieldcat,
*pero en un formato de fieldcat que es necesario convertir tambien.
    CALL FUNCTION 'LT_DBDATA_READ_FROM_LTDX'
      EXPORTING
        i_tool       = c_relid
        is_varkey    = v_varkey
      TABLES
        t_dbfieldcat = it_fcat               " Fieldcat
        t_dbsortinfo = it_sort_info          " Criterio ordenamiento
        t_dbfilter   = it_filter.            " Criterio filtrado

    IF sy-subrc = 0.
      LOOP AT it_fcat INTO wa_ltdxdata.
        AT NEW key1.
          CLEAR flag_no_out.
        ENDAT.
*       Rechazar aquellas columnas que están ocultas
        IF wa_ltdxdata-param = 'NO_OUT' AND wa_ltdxdata-value = 'X'.
          flag_no_out = 'X'.
        ENDIF.

        AT END OF key1.
          IF flag_no_out IS INITIAL.
            CLEAR wa_fieldcat.
*           Leer el fildcat global para obtener el nombre de la tabla estándar a la que hacer referencia cada columna (MARA, BKPF, etc)
            READ TABLE gt_fieldcat WITH KEY fieldname =  wa_ltdxdata-key1 INTO ls_fieldcat.
            wa_fieldcat-fieldname = wa_ltdxdata-key1.
            wa_fieldcat-ref_table = ls_fieldcat-ref_table.

            IF ls_fieldcat-ref_field IS NOT INITIAL.

              wa_fieldcat-ref_field = ls_fieldcat-ref_field.
            ELSE.
              wa_fieldcat-ref_field = wa_ltdxdata-key1.
            ENDIF.
*     LLamamos a la función DDIF_FIELDINFO_GET
            CALL FUNCTION 'DDIF_FIELDINFO_GET'
              EXPORTING
                tabname        = wa_fieldcat-ref_table
                fieldname      = wa_fieldcat-fieldname
              TABLES
                dfies_tab      = it_descriptivos
              EXCEPTIONS
                not_found      = 1
                internal_error = 2
                OTHERS         = 3.

            IF sy-subrc <> 0.
              CALL FUNCTION 'DDIF_FIELDINFO_GET'
                EXPORTING
                  tabname        = wa_fieldcat-ref_table
                  fieldname      = wa_fieldcat-ref_field
                TABLES
                  dfies_tab      = it_descriptivos
                EXCEPTIONS
                  not_found      = 1
                  internal_error = 2
                  OTHERS         = 3.
            ENDIF.

            READ TABLE it_descriptivos INTO wa_desc INDEX 1.
            wa_fieldcat-scrtext_s = wa_desc-scrtext_s.
            wa_fieldcat-scrtext_m = wa_desc-scrtext_m.
            wa_fieldcat-scrtext_l = wa_desc-scrtext_l.
*
            IF wa_fieldcat-fieldname <> 'ZCONT'.
              APPEND wa_fieldcat TO it_fieldcat.
            ENDIF.
          ENDIF.
        ENDAT.
      ENDLOOP.
    ENDIF.

** Con el fieldcatalog en formato ALV crear la tabla dinámica que contendrá solo las columnas de la variante.
    CALL METHOD cl_alv_table_create=>create_dynamic_table
      EXPORTING
        it_fieldcatalog  = it_fieldcat
        i_length_in_byte = 'X'
      IMPORTING
        ep_table         = dy_table.
    ASSIGN dy_table->* TO <dyn_table>.

**   Rellenar las cabeceras a partir del fieldcat generado con la variante (it_fieldcat). Se usa texto largo, se puede cambiar por scrtext_m (medio) o scrtext_s (corto)
    CLEAR f_flag.
    LOOP AT it_fieldcat INTO wa_fieldcat.
      IF sy-subrc = 0.
        IF f_flag IS INITIAL. "Si el flag está vacío, es la primera columna, asignarla directamente a la cabecera y marcar el flag
          lv_cabecera = wa_fieldcat-scrtext_s.
          f_flag = 'X'.
        ELSE. "Si el flag ya está relleno, no es la primera columna, concatenar la columna a lo que ya estaba en la cabecera y separarlo con gc_tab
          CONCATENATE lv_cabecera gc_tab wa_fieldcat-scrtext_s INTO lv_cabecera.
        ENDIF.
      ENDIF.
    ENDLOOP.

**   Mover las columnas y filas de la tabla que las contiene todas a la tabla dinámica de la selección reducida
    MOVE-CORRESPONDING gt_stock[] TO <dyn_table>.
**
  ELSE. "No se ha seleccionado ninguna variante o no existe, usar el fieldcat creado por defecto
** Mover los datos del fieldcatalog global (por defecto) al formato que se necesita en cl_alv_table_create=>create_dynamic_table
    LOOP AT gt_fieldcat INTO ls_fieldcat.
      CLEAR wa_fieldcat.
      MOVE-CORRESPONDING ls_fieldcat TO wa_fieldcat.
      wa_fieldcat-ref_table = ls_fieldcat-ref_table. "Asignar tabla de referencia
      wa_fieldcat-ref_field = ls_fieldcat-ref_field. "Asignar campo de la tabla de referencia
      IF wa_fieldcat-fieldname <> 'ZCONT'.
        APPEND wa_fieldcat TO it_fieldcat.
      ENDIF.
    ENDLOOP.

    CALL METHOD cl_alv_table_create=>create_dynamic_table
      EXPORTING
        it_fieldcatalog  = it_fieldcat[]
        i_length_in_byte = 'X'
      IMPORTING
        ep_table         = dy_table.
    ASSIGN dy_table->* TO <dyn_table>.

*   Rellenar las cabeceras a partir del fieldcat generado con la variante (it_fieldcat). Se usa texto largo, se puede cambiar por scrtext_m (medio) o scrtext_s (corto)
    CLEAR: f_flag, l_struc_index.
    LOOP AT it_fieldcat INTO wa_fieldcat.
*       Obtener el descriptivo de la columna (Se le pasa el nombre de la tabla que contiene el campo y el nombre del campo en sí.
*       Retorna una tabla con los descriptivos corto, medio y largo)
      CALL FUNCTION 'DDIF_FIELDINFO_GET'
        EXPORTING
          tabname        = wa_fieldcat-ref_table
          fieldname      = wa_fieldcat-fieldname
        TABLES
          dfies_tab      = it_descriptivos
        EXCEPTIONS
          not_found      = 1
          internal_error = 2
          OTHERS         = 3.

      IF sy-subrc <> 0.

        CALL FUNCTION 'DDIF_FIELDINFO_GET'
          EXPORTING
            tabname        = wa_fieldcat-ref_table
            fieldname      = wa_fieldcat-ref_field
          TABLES
            dfies_tab      = it_descriptivos
          EXCEPTIONS
            not_found      = 1
            internal_error = 2
            OTHERS         = 3.

      ENDIF.


      IF sy-subrc = 0.
*       Si la función OK, leer la primera linea y asignar el descriptivo largo
        READ TABLE it_descriptivos INTO wa_desc INDEX 1.
        IF sy-subrc = 0.
          IF f_flag IS INITIAL. "Si el flag está vacío, es la primera columna, asignarla directamente a la cabecera y marcar el flag
            lv_cabecera = wa_desc-scrtext_s.
            f_flag = 'X'.
          ELSE. "Si el flag ya está relleno, no es la primera columna, concatenar la columna a lo que ya estaba en la cabecera y separarlo con gc_tab
            CONCATENATE lv_cabecera gc_tab wa_desc-scrtext_s INTO lv_cabecera.
          ENDIF.
        ENDIF.

      ENDIF.
    ENDLOOP.

*   Mover las columnas y filas de la tabla que las contiene todas a la tabla dinámica de la selección reducida
    MOVE-CORRESPONDING gt_stock[] TO <dyn_table>.
  ENDIF.

  CONCATENATE 'STK_CL' sy-datum sy-uzeit '.xls' INTO lv_filename.
  CONCATENATE 'C:\' lv_filename INTO lv_fname_local.

  CALL FUNCTION 'SAP_CONVERT_TO_TEX_FORMAT'
    EXPORTING
      i_field_seperator    = gc_tab
    TABLES
      i_tab_sap_data       = <dyn_table>
    CHANGING
      i_tab_converted_data = lt_tablconvertida
    EXCEPTIONS
      conversion_failed    = 1
      OTHERS               = 2.


* Insertar la cabecera en la primera posición de la tabla CSV
  INSERT lv_cabecera INTO lt_tablconvertida INDEX 1.

  CLEAR lv_content.
  LOOP AT lt_tablconvertida INTO lv_content_line.
    CONCATENATE lv_content lv_content_line gc_crlf INTO lv_content.
  ENDLOOP.

  TRY.
      cl_bcs_convert=>string_to_solix(
        EXPORTING
          iv_string   = lv_content
          iv_codepage = '4103'  "suitable for MS Excel, leave empty
          iv_add_bom  = 'X'     "for other doc types
        IMPORTING
          et_solix  = binary_content
          ev_size   = size ).
    CATCH cx_bcs.
      MESSAGE e445(so).
  ENDTRY.


  IF s_excel IS INITIAL.
    "Siempre guardar el archivo en la carpeta temporal
    s_excel-low = './'.
    APPEND s_excel.
  ENDIF.

  IF s_excel IS NOT INITIAL.

    LOOP AT s_excel.
      CONCATENATE s_excel-low lv_filename INTO lv_rutacompleta.

      OPEN DATASET lv_rutacompleta FOR OUTPUT IN BINARY MODE.
      IF sy-subrc = 0.
        LOOP AT binary_content INTO ls_binary.

          TRANSFER ls_binary-line TO lv_rutacompleta.

        ENDLOOP.
        CLOSE DATASET lv_rutacompleta.
        MOVE lv_rutacompleta TO lv_rutastr.
      ENDIF.
    ENDLOOP.

  ENDIF.

  IF s_email IS NOT INITIAL.
    LOOP AT s_email.
      wa_email = s_email-low.
      APPEND wa_email TO lt_emails.
    ENDLOOP.


    CALL FUNCTION 'ZFM_EXCEL_SEND_EMAIL'
      EXPORTING
        i_excel       = lv_icmdata
        i_header      = gv_titulo " cvivo - Proyecto WM
        i_attach_name = lv_filename
        full_path     = lv_rutastr
      TABLES
        it_email      = lt_emails.
  ENDIF.

ENDFORM.                    " EXPORTAR_EXCEL


************************************************************************
* Initialization: Read default variant
************************************************************************
FORM inicializar_variantes.

* prepare the areas for the different display variants
  repid = sy-repid.
  CLEAR : variante.
  MOVE  : repid              TO  variante-report.

  def_variante = variante.

  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = 'A'
    CHANGING
      cs_variant = def_variante
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 0.
    gs_variant = def_variante.
    MOVE  def_variante-variant    TO  g_f_vari.
    MOVE  def_variante-variant    TO  g_f_vari_initial.
  ENDIF.

  p_vari =  g_f_vari.

ENDFORM.                               " INITIALISIERUNG

*&---------------------------------------------------------------------*
*&      Form  F4_FOR_VARIANT
*&---------------------------------------------------------------------*
*       F4-Hilfe für Reportvariante                                    *
*----------------------------------------------------------------------*
FORM f4_for_variant.


  MOVE variante          TO  def_variante_f4.

  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = def_variante_f4
      i_save     = 'A'
*     it_default_fieldcat =
    IMPORTING
      e_exit     = variant_exit
      es_variant = def_variante
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF variant_exit = space.
*     save the selected display variant
      gs_variant = def_variante.
      p_vari = def_variante-variant.
      MOVE  p_vari         TO  g_f_vari.
    ENDIF.
  ENDIF.

ENDFORM.                               " F4_FOR_VARIANT

*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CANTIDADES_PEDIDO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM recuperar_cantidades_pedido  USING    pu_pedido TYPE char10
                                           pu_posicion TYPE char6
                                  CHANGING pc_ctd_pedida TYPE ktmng
                                           pc_ctd_servida TYPE ktmng
                                           pc_ctd_restante TYPE ktmng.

  TYPES: BEGIN OF ty_ekbe,
           zekkn TYPE ekbe-zekkn,
           vgabe TYPE ekbe-vgabe,
           gjahr TYPE ekbe-gjahr,
           belnr TYPE ekbe-belnr,
           buzei TYPE ekbe-buzei,
           menge TYPE ekbe-menge,
         END OF ty_ekbe.

  TYPES: BEGIN OF ty_lips,
           vbeln TYPE lips-vbeln,
           posnr TYPE lips-posnr,
           lfimg TYPE lips-lfimg,
         END OF ty_lips.

  DATA: ls_ekbe TYPE          ty_ekbe,
        lt_ekbe TYPE TABLE OF ty_ekbe.

  DATA: ls_lips TYPE          ty_lips,
        lt_lips TYPE TABLE OF ty_lips.

  DATA: lv_pos_com   TYPE ebelp,
        lv_pos_vta   TYPE posnr_va,
        lv_ped_input TYPE char10,
        ls_stock     TYPE zstmm_stock,
        lv_loekz     TYPE eloek, " cvivo - Proyecto WM - cantidades finalizadas
        lv_elikz     TYPE elikz. " cvivo - Proyecto WM - cantidades finalizadas

  CLEAR: pc_ctd_pedida, pc_ctd_servida, lt_ekbe, lt_lips, ls_stock.

*Si ya hay otro registro con los mismos parámetros pedido-posición en el ALV, los resultados serán los mismos
  READ TABLE gt_stock INTO ls_stock WITH KEY pedido = pu_pedido
                                             posicion = pu_posicion.
  IF sy-subrc = 0.
    pc_ctd_pedida = ls_stock-ctd_pedida.
    pc_ctd_servida = ls_stock-ctd_servida.
    pc_ctd_restante = ls_stock-ctd_restante.
    EXIT.
  ENDIF.

*Las columnas se rellenarán de distinta forma en función de
*si se trata de un pedido de compra o de un pedido de venta.
*Comprobamos que exista el pedido de compras, en caso contrario
*será de ventas
*Hacemos mapeo output->input.
  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = pu_pedido
    IMPORTING
      output = lv_ped_input.

  lv_pos_com = pu_posicion.

  SELECT SINGLE menge loekz elikz
  INTO ( pc_ctd_pedida, lv_loekz, lv_elikz ) " cvivo - Proyecto WM - cantidades finalizadas
  FROM ekpo
  WHERE ebeln = lv_ped_input
    AND ebelp = lv_pos_com.

  IF sy-subrc = 0.
    SELECT zekkn vgabe gjahr belnr buzei menge
    INTO TABLE lt_ekbe
    FROM ekbe
    WHERE ebeln = lv_ped_input
      AND ebelp = lv_pos_com
      AND bewtp = 'U'.

    LOOP AT lt_ekbe INTO ls_ekbe.
      pc_ctd_servida = pc_ctd_servida + ls_ekbe-menge.
    ENDLOOP.
  ELSE.
    lv_pos_vta = pu_posicion.

    SELECT SINGLE kwmeng
    INTO pc_ctd_pedida
    FROM vbap
    WHERE vbeln = lv_ped_input
      AND posnr = lv_pos_vta.

    SELECT vbeln posnr lfimg
    INTO TABLE lt_lips
    FROM lips
    WHERE vgbel = lv_ped_input
      AND vgpos = lv_pos_vta.

    LOOP AT lt_lips INTO ls_lips.
      pc_ctd_servida = pc_ctd_servida + ls_lips-lfimg.
    ENDLOOP.
  ENDIF.

  pc_ctd_restante = pc_ctd_pedida - pc_ctd_servida.

  IF lv_loekz IS NOT INITIAL OR lv_elikz IS NOT INITIAL. " cvivo - Proyecto WM - cantidades finalizadas
    CLEAR pc_ctd_restante.
  ENDIF.
ENDFORM.                    " RECUPERAR_CANTIDADES_PEDIDO
*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_CARACT_BOBINA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_STOCK_MATNR  text
*      -->P_LS_STOCK_CHARG  text
*      <--P_LS_STOCK_VCODE  text
*      <--P_LS_STOCK_HSDAT  text
*      <--P_LS_STOCK_PEDIDO  text
*      <--P_LS_STOCK_POSICION  text
*----------------------------------------------------------------------*
FORM recuperar_caract  USING    p_matnr
                                 p_charg
                        CHANGING p_kunnr
                                 p_pedido
                                 p_posicion
                                 p_vcode
                                 p_hsdat
                                 p_ubic
                                 p_motivo_rechazo
                                 p_longitud
                          .

  DATA: lv_object            TYPE objnum,
        lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        lt_return            TYPE bapiret2_tab,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        lv_num               TYPE i,
        lv_fec_n             TYPE n LENGTH 8.

  REFRESH: lt_alloc_values_num, lt_alloc_values_char.
  REFRESH: lt_alloc_values_curr, lt_return.
  CLEAR: lv_object, ls_alloc_values_char.
  CLEAR: lt_alloc_values_num, lt_alloc_values_char.
  CLEAR: lt_alloc_values_curr, lt_return.

  CONCATENATE p_matnr p_charg INTO lv_object.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = lv_object
      objecttable     = 'MCH1'
      classnum        = 'Z_BOBINA'
      classtype       = '023'
*     KEYDATE         = SY-DATUM
*     UNVALUATED_CHARS       = ' '
*     LANGUAGE        = SY-LANGU
*   IMPORTING
*     STATUS          =
*     STANDARDCLASS   =
    TABLES
      allocvaluesnum  = lt_alloc_values_num
      allocvalueschar = lt_alloc_values_char
      allocvaluescurr = lt_alloc_values_curr
      return          = lt_return.


  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_CLIENTE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_kunnr = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_kunnr.
  ENDIF.


* PEDIDO:
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_PEDIDO'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_pedido = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_pedido.
  ENDIF.

* POSICIÓN:
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_POSICION'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_posicion = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_posicion.
  ENDIF.


* DECISION DE EMPLEO
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'LOBM_UDCODE'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_vcode = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_vcode.
  ENDIF.


* Papelera - Ubicacion Bobina - UDEFINE 27/06/2018
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'Z_UBIC_HPAP'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_ubic = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_ubic.
  ENDIF.

* Papelera - MOtivo rechazo
  CLEAR ls_alloc_values_char.
  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
             WITH KEY charact = 'ZPPI_MOTIVO_REPROCESO_BOBINA'.

  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
    CONDENSE ls_alloc_values_char-value_neutral.
    p_motivo_rechazo = ls_alloc_values_char-value_neutral.
  ELSE.
    CLEAR p_motivo_rechazo.
  ENDIF.


* FECHA FABRICACIÓN:
  CLEAR ls_alloc_values_num.
  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                               WITH KEY charact = 'Z_FECHA_FABRICACION'.
  IF ls_alloc_values_num IS NOT INITIAL.
    CLEAR: lv_num, lv_fec_n.
    lv_num = ls_alloc_values_num-value_from.
    lv_fec_n = lv_num.
    p_hsdat = lv_fec_n .
  ELSE.
    p_hsdat = '00000000'.
  ENDIF.

*LONGITUD BOBINA
  DATA l_longitud TYPE i.
  CLEAR ls_alloc_values_num.
  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                               WITH KEY charact = 'Z_LONGITUD_B'.
  IF ls_alloc_values_num IS NOT INITIAL.
    CLEAR: lv_num, lv_fec_n.
    lv_num = ls_alloc_values_num-value_from.
    l_longitud = lv_num.
    p_longitud = l_longitud.
  ELSE.
    p_hsdat = '00000000'.
  ENDIF.



ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  PEDIDO_COMPRAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM pedido_compras USING    p_stock TYPE zstmm_stock
                             p_lim_pico TYPE menge_d
                             p_dinamico TYPE flag
                    CHANGING p_pedido
                             p_posicion
                             p_entera
                             p_media
                             p_pico. " cvivo - Proyecto WM

  DATA: lv_cantidad TYPE labst,
        lv_menge    TYPE menge_d.

  lv_cantidad = p_stock-clabs + p_stock-cumlm + p_stock-cinsm + p_stock-ceinm + p_stock-cspem + p_stock-cretm.

  SELECT SINGLE ebeln ebelp menge FROM ekbe
    INTO ( p_pedido, p_posicion, lv_menge )
    WHERE matnr EQ p_stock-matnr
      AND charg EQ p_stock-charg
      AND werks EQ p_stock-werks
      AND vgabe EQ '1' " EM
      AND bewtp EQ 'E' " EM
      AND bwart EQ '101'.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = p_pedido
    IMPORTING
      output = p_pedido.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = p_posicion
    IMPORTING
      output = p_posicion.

*   Verificamos la tolerancia
  IF p_dinamico IS NOT INITIAL.
    SELECT SINGLE *
      INTO @DATA(ls_tolerancia)
      FROM zwm_tolerancia
      WHERE werks = @p_stock-werks AND
            lgort = @space AND
            dinamico NE @space.

    IF sy-subrc EQ 0.
      p_lim_pico = ( ls_tolerancia-minutos * ls_tolerancia-velocidad * p_stock-zzgramaje * p_stock-zzancho ) / 1000000.
      p_lim_pico = trunc( p_lim_pico ).
    ENDIF.
  ENDIF.


  IF lv_cantidad EQ lv_menge.
    p_entera = 1.
  ELSEIF lv_cantidad LT p_lim_pico.
    p_pico = 1.
  ELSE.
    p_media = 1.
  ENDIF.

ENDFORM.
FORM calcular_ind_tolerancia CHANGING ps_stock TYPE zstmm_stock.

  DATA:         lv_peso_teorico TYPE atflv,
                lv_dif_peso     TYPE atflv,
                lv_gramaje      TYPE mara-zzgramaje,
                lv_longitud     TYPE p DECIMALS 2,
                lv_ancho        TYPE mara-zzancho,
                lv_coeficiente  TYPE atflv.

  DATA wa_ztpp0008 TYPE ztpp0008.

  DATA l_arbpl TYPE arbpl.

  CASE ps_stock-werks.
    WHEN '3000'.
      l_arbpl = 'BOBI_01'.
    WHEN OTHERS.
      l_arbpl = 'BOBI_10'.
  ENDCASE.

  SELECT SINGLE * FROM ztpp0008
   INTO wa_ztpp0008
   WHERE werks = ps_stock-werks AND
         arbpl = l_arbpl.


  SELECT SINGLE zzgramaje zzancho FROM mara
                                  INTO ( lv_gramaje, lv_ancho )
                                  WHERE matnr = ps_stock-matnr.

* Peso (kg) = (Gramaje (g/m2) x Ancho (m) x Longitud (m)/1000)

  lv_peso_teorico  = ( lv_gramaje * ( lv_ancho / 1000 )  * ( ps_stock-longitud / 1000 ) ).
  IF lv_peso_teorico NE 0.

    lv_dif_peso     = lv_peso_teorico - ps_stock-clabs.

    lv_dif_peso     = abs( lv_dif_peso ).

    lv_coeficiente  = ( lv_dif_peso / lv_peso_teorico  ) * 100.


    IF lv_coeficiente > wa_ztpp0008-tolerancia_peso.
      ps_stock-tolerancia_peso = '@1A@'.
    ENDIF.



  ELSE.

    ps_stock-tolerancia_peso = '@1A@'.

  ENDIF.

  ps_stock-peso_teorico_sup = lv_peso_teorico + ( lv_peso_teorico * wa_ztpp0008-tolerancia_peso / 100 ).
  ps_stock-peso_teorico_inf = lv_peso_teorico - ( lv_peso_teorico * wa_ztpp0008-tolerancia_peso / 100 ).

ENDFORM.
