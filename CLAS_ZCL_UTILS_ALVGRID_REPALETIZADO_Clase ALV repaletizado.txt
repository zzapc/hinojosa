
class ZCL_UTILS_ALVGRID_REPALETIZADO definition
  public
  inheriting from ZCL_UTILS_ALV_GRID
  final
  create public .

public section.

  class-methods S_GET_SET_DATA_4_LGNUM
    importing
      !I_LGNUM type LGNUM
    exporting
      !E_LGTYP_O type LGTYP
      !E_LGPLA_O type LGPLA
      !E_LGTYP_F type LGTYP
      !E_LGPLA_F type LGPLA .
  methods SELECT_DATA
    importing
      !I_LGNUM type LGNUM
      !I_LGTYP type LGTYP
      !I_LGPLA type LGPLA
      !I_T_R_MATNR type FRE_MATNR_RANG_TTY
      !I_T_R_CHARG type SHP_CHARG_RANGE_T
    returning
      value(R_T_DATA) type ZTT_WM_REPALETIZADO_DATA .

  methods ON_DATA_CHANGE
    redefinition .
  methods ON_TOOLBAR
    redefinition .
  methods ON_USER_COMMAND
    redefinition .
PROTECTED SECTION.
private section.

  types:
    BEGIN OF ty_mvt_doc_from,
    material        TYPE matnr,
    plant           TYPE werks_d,
    stge_loc        TYPE lgort_d,
    batch           TYPE charg_d,
    spec_stock      TYPE sobkz,
    val_sales_ord   TYPE kdauf,
    val_s_ord_item  TYPE kdpos,
    entry_qnt       TYPE erfmg,
    entry_uom       TYPE erfme,
  END OF ty_mvt_doc_from .
  types:
    BEGIN OF ty_mvt_doc_to,
    move_mat      TYPE ummat,
    move_plant    TYPE umwrk,
    move_stloc    TYPE umlgo,
    move_batch    TYPE umcha,
    spec_stock    TYPE sobkz,
    sales_ord     TYPE kdauf,
    s_ord_item    TYPE kdpos,
    move_val_type TYPE umbar,
  END OF ty_mvt_doc_to .

  data _OUTTAB type ZTT_WM_REPALETIZADO_DATA .

  methods _ADD_ROW .
  methods _CHANGE_CHARG .
  methods _CHANGE_SONUM .
  methods _CHECK_CONSISTENT_DATA
    importing
      !I_SHOW_POPUP type ABAP_BOOL default 'X'
      !I_CHECK_BESTQ_INITIAL type ABAP_BOOL default 'X'
      !I_CHECK_QPLOS_INITIAL type ABAP_BOOL default 'X'
      !I_CHECK_MATNR_SAME type ABAP_BOOL default 'X'
      !I_CHECK_CHARG_SAME type ABAP_BOOL default 'X'
      !I_CHECK_SOBKZ_SAME type ABAP_BOOL default 'X'
      !I_CHECK_SONUM_SAME type ABAP_BOOL default 'X'
      !I_T_DATA type ZTT_WM_REPALETIZADO_DATA
    returning
      value(R_IS_OK) type ABAP_BOOL .
  methods _CHECK_NO_QPLOS .
  methods _CHECK_QUANTITIES
    importing
      !I_SHOWING_POPUP type ABAP_BOOL optional
      !I_CHECK_NOZERO type ABAP_BOOL default 'X'
      !I_CHECK_MAX_QTY type ABAP_BOOL default 'X'
      !I_CHECK_BAJAS type ABAP_BOOL default 'X'
    exporting
      value(R_IS_OK_NOZERO) type ABAP_BOOL
      !R_IS_OK_MAX_QTY type ABAP_BOOL
      !R_IS_OK_BAJAS type ABAP_BOOL .
  methods _CHECK_SELECTION
    importing
      !I_SHOWING_POPUP type ABAP_BOOL default ''
    returning
      value(R_IS_OK) type ABAP_BOOL .
  methods _DEL_ROW .
  methods _GET_BAPIRET_4_MSGID
    importing
      !I_MSGID type SY-MSGID
      !I_MSGNO type SY-MSGNO
      !I_MSGV1 type SYST_MSGV optional
      !I_MSGV2 type SYST_MSGV optional
      !I_MSGV3 type SYST_MSGV optional
      !I_MSGV4 type SYST_MSGV optional
    returning
      value(R_BAPIRET2) type BAPIRET2 .
  methods _GET_LQUA_4_SELDATA
    importing
      !I_SEL_DATA type ZST_WM_REPALETIZADO_DATA
    returning
      value(R_LQUA) type LQUA
    exceptions
      NO_DATA .
  methods _GET_TOTALS_4_QUANTITIES
    exporting
      !E_GESME_TOT type LQUA_GESME
      !E_NEW_MENGE_TOT type ZNEW_MENGE .
  methods _LAUNCH_DE .
  methods _MVT_DOCUMENT_CHANGE
    importing
      !I_ITEM_FROM type TY_MVT_DOC_FROM
      !I_ITEM_TO type TY_MVT_DOC_TO
      !I_MOVE_TYPE type BWART
      !I_COMMIT type ABAP_BOOL default 'X'
    exporting
      !E_RETURN type BAPIRET2
    returning
      value(R_MATDOC) type BAPI2017_GM_HEAD_RET-MAT_DOC .
  methods _REPALETIZA_1 .
  methods _REPALETIZA_2 .
  methods _PRINT_LABELS .
endclass. "ZCL_UTILS_ALVGRID_REPALETIZADO definition
class ZCL_UTILS_ALVGRID_REPALETIZADO implementation.
METHOD _add_row.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: ls_data LIKE LINE OF me->_outtab.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

*** ASSIGN

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

  IF ( <ft_data> IS ASSIGNED ).

*** ADD ROW

    READ TABLE <ft_data> INTO ls_data  INDEX 1.

    ls_data-lenum = space.
    ls_data-gesme = space.

    APPEND ls_data TO <ft_data>.

  ENDIF.


ENDMETHOD.
METHOD _change_charg.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_sel_data   LIKE me->_outtab,
        ls_sel_data   LIKE LINE OF me->_outtab,
        ls_nex_data   LIKE LINE OF me->_outtab,
        ls_item_from  TYPE ty_mvt_doc_from,
        ls_item_to    TYPE ty_mvt_doc_to,
        ls_return     TYPE bapiret2,
        lv_matdoc     TYPE bapi2017_gm_head_ret-mat_doc.

  DATA: lv_msg_v1     TYPE string,
        lv_msg_v2     TYPE string,
        lv_msg_v3     TYPE string,
        lv_msg_v4     TYPE string.

  DATA: lt_sval       TYPE ty_sval,
        ls_sval       TYPE sval.

  DATA: ls_r_lqnum    TYPE zst_r_lqnum,
        lt_r_lqnum    TYPE ztt_r_lqnum.

  DATA: lo_wm_utils   TYPE REF TO zcl_utils_wm.

  DATA: lv_checks     TYPE abap_bool VALUE IS INITIAL,
        ls_chk_data   LIKE LINE OF me->_outtab.

  DATA: lv_lines      TYPE i,
        lv_index      TYPE i,
        lv_loops      TYPE i,
        lv_postd      TYPE abap_bool.

  DATA: ls_lqua       TYPE lqua.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( me->_check_selection( i_showing_popup = abap_true ) EQ abap_false ).
    EXIT.
  ENDIF.

*** GET SELECTED DATA

  me->get_selected_data(
    IMPORTING
      e_t_data = lt_sel_data
  ).

*** CHECK SELECTED DATA

** CHECK NO QPLOS

  READ TABLE lt_sel_data INTO ls_chk_data INDEX 1.

  LOOP AT lt_sel_data INTO ls_sel_data.

    "Indicador especial de stock
    IF ( ls_sel_data-bestq IS NOT INITIAL ).
      CLEAR: lv_msg_v3.
      CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-bestq INTO lv_msg_v3 SEPARATED BY space.
      me->_launch_popup_msg( i_msg1 = 'No pueden seleccionarse registros con stock especial' i_msg3 = lv_msg_v3 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

    "Lote de inspección
    IF ( ls_sel_data-qplos IS NOT INITIAL ).
      CLEAR: lv_msg_v3.
      CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-qplos INTO lv_msg_v3 SEPARATED BY space.
      me->_launch_popup_msg( i_msg1 = 'No pueden seleccionarse stocks con DE pendiente' i_msg3 = lv_msg_v3 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

    "Material siempre igual
    IF ( ls_sel_data-matnr NE ls_chk_data-matnr ).
      CLEAR: lv_msg_v3, lv_msg_v4.
      MOVE ls_sel_data-matnr TO lv_msg_v3.
      MOVE ls_chk_data-matnr TO lv_msg_v4.
      me->_launch_popup_msg( i_msg1 = 'Ha seleccionado dos materiales diferentes' i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

  ENDLOOP.

  IF ( lv_checks EQ abap_true ).
    EXIT.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** SORT BY

  SORT lt_sel_data BY matnr charg sonum.

*** USER BATCH

  "Pedimos lote al usuario
  CLEAR: ls_sval.
  ls_sval-tabname = 'LQUA'.
  ls_sval-fieldname = 'CHARG'.
  APPEND ls_sval TO lt_sval.
  me->_launch_popup_values_get(
    EXPORTING
      i_valuecheck = abap_false
    CHANGING
      c_t_val      = lt_sval    " Tipo de tabla para SVAL
  ).

  "Compruebo si ha insertado valor
  READ TABLE lt_sval INTO ls_sval INDEX 1.
  IF ( ls_sval-value IS INITIAL ). "Si valor
    me->_launch_popup_msg( i_msg1 = 'Acción cancelada por el usuario' ).
    EXIT.
  ENDIF.

**** CHANGE BATCH

  CLEAR: lv_lines, lv_index.

  lv_lines = lines( lt_sel_data ).

  "Hacemos un loop de n líneas -1.
  DO lv_lines TIMES.

*** PREPARE DATA

    "Limpio variables
    CLEAR: lv_postd, ls_sel_data, ls_nex_data.

    "Calculo índice actual
    ADD 1 TO lv_index.

    "Obtengo registro actual
    READ TABLE lt_sel_data INTO ls_sel_data INDEX lv_index.
    CHECK sy-subrc EQ 0.

    "Si lv_lines tiene más de un registro, recupero siguiente.
    IF ( lv_lines GT 1 ).

      "Obtengo registro siguiente
      READ TABLE lt_sel_data INTO ls_nex_data INDEX lv_index + 1.
      IF ( sy-subrc NE 0 ).
        CLEAR: ls_nex_data.
      ENDIF.

    ELSE.

      IF ( lv_index = lv_lines ).
        CLEAR: ls_nex_data.
      ENDIF.

    ENDIF.

**** CHECK CHANGES

*** CHECK CHARG NE

    "Comprobamos si lote origen y destino son iguales
    IF ( ls_sel_data-charg EQ ls_sval-value ).
      CONTINUE.
    ENDIF.

*** CHECK LAST

    "Comprobamos si última línea
    IF ( lv_index = lv_lines ).

      "Crear doc.mat.
      MOVE abap_true TO lv_postd.

    ENDIF.

*** CHARG | SONUM

    "Comprobamos si hay cambio de lote o stock especial
    IF ( ( ls_sel_data-charg NE ls_nex_data-charg )     "Lote
      OR ( ls_sel_data-sonum NE ls_nex_data-sonum ) ).  "Stock especial

      "Compruebo si ya está marcado crear doc.mat.
      IF ( lv_postd EQ abap_false ).

        "Crear doc.mat.
        MOVE abap_true TO lv_postd.

      ENDIF.

    ENDIF.

**** FILL DATA

*    "Obtengo datos de LQUA
*    SELECT SINGLE *
*      FROM lqua
*      INTO @DATA(ls_lqua)
*     WHERE lgnum EQ @ls_sel_data-lgnum
*       AND lgtyp EQ @ls_sel_data-lgtyp
*       AND lgpla EQ @ls_sel_data-lgpla
*       AND lenum EQ @ls_sel_data-lenum
*       AND matnr EQ @ls_sel_data-matnr
*       AND charg EQ @ls_sel_data-charg
*       AND sobkz EQ @ls_sel_data-sobkz
*       AND sonum EQ @ls_sel_data-sonum
*       AND bestq EQ @space
*       AND gesme EQ @ls_sel_data-gesme.
*
*    IF ( sy-subrc NE 0 ).
*      CONTINUE.
*    ENDIF.

  CLEAR: ls_lqua.
  me->_get_lqua_4_seldata(
    EXPORTING
      i_sel_data = ls_sel_data    " Estructura para report ZHWM_REPALETIZADO
    RECEIVING
      r_lqua     = ls_lqua    " Cuantos
    EXCEPTIONS
      no_data    = 1
      others     = 2 ).
  IF ( sy-subrc <> 0 ).
    CONTINUE.
  ENDIF.

*** MATNR

* FROM

    IF ( ls_item_from-material IS INITIAL ).
      MOVE ls_lqua-matnr TO ls_item_from-material.
    ENDIF.

* TO

    IF ( ls_item_to-move_mat IS INITIAL ).
      MOVE ls_lqua-matnr TO ls_item_to-move_mat.
    ENDIF.

*** WERKS

** FROM

    IF ( ls_item_from-plant IS INITIAL ).
      MOVE ls_lqua-werks TO ls_item_from-plant.
    ENDIF.

** TO

    IF ( ls_item_to-move_plant IS INITIAL ).
      MOVE ls_lqua-werks TO ls_item_to-move_plant.
    ENDIF.

*** LGORT

** FROM

    IF ( ls_item_from-stge_loc IS INITIAL ).
      MOVE ls_lqua-lgort TO ls_item_from-stge_loc.
    ENDIF.

** TO

    IF ( ls_item_to-move_stloc IS INITIAL ).
      MOVE ls_lqua-lgort TO ls_item_to-move_stloc.
    ENDIF.

*** CHARG

** FROM

    IF ( ls_item_from-batch IS INITIAL ).
      MOVE ls_lqua-charg TO ls_item_from-batch.
    ENDIF.

** TO

    IF ( ls_item_to-move_batch IS INITIAL ).
      MOVE ls_sval-value TO ls_item_to-move_batch.
    ENDIF.

*** UOM

    IF ( ls_item_from-entry_uom IS INITIAL ).

      SELECT SINGLE meins
        FROM mara
        INTO ls_item_from-entry_uom
       WHERE matnr EQ ls_lqua-matnr.

    ENDIF.

*** SOBKZ

    IF ( ls_lqua-sobkz IS NOT INITIAL ).

** FROM

      IF ( ls_item_from-spec_stock IS INITIAL ).
        MOVE ls_lqua-sobkz TO ls_item_from-spec_stock.
      ENDIF.

** TO

      IF ( ls_item_to-spec_stock IS INITIAL ).
        MOVE ls_lqua-sobkz TO ls_item_to-spec_stock.
      ENDIF.

    ENDIF.

*** SONUM

    IF ( ls_lqua-sonum IS NOT INITIAL ).

** FROM

      "KDAUF
      IF ( ls_item_from-val_sales_ord IS INITIAL ).
        MOVE ls_lqua-sonum(10) TO ls_item_from-val_sales_ord.
      ENDIF.

      "KDPOS
      IF ( ls_item_from-val_s_ord_item IS INITIAL ).
        MOVE ls_lqua-sonum+10(6) TO ls_item_from-val_s_ord_item.
      ENDIF.

** TO

      "KDAUF
      IF ( ls_item_to-sales_ord IS INITIAL ).
        MOVE ls_lqua-sonum(10) TO ls_item_to-sales_ord.
      ENDIF.

      "KDPOS
      IF ( ls_item_to-s_ord_item IS INITIAL ).
        MOVE ls_lqua-sonum+10(6) TO ls_item_to-s_ord_item.
      ENDIF.

    ENDIF.

*** QTY

** IM

    "Convierto a UN base
    CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
      EXPORTING
        i_matnr                    = ls_lqua-matnr
        i_in_me                    = ls_lqua-meins
        i_out_me                   = ls_item_from-entry_uom
        i_menge                    = ls_lqua-gesme
      IMPORTING
        e_menge                    = ls_lqua-gesme
      EXCEPTIONS
        error_in_application       = 1
        error                      = 2
        OTHERS                     = 3.

    ADD ls_lqua-gesme TO ls_item_from-entry_qnt.

*** LENUM

    CLEAR: ls_r_lqnum.
    ls_r_lqnum-sign       = 'I'.
    ls_r_lqnum-option     = 'EQ'.
    ls_r_lqnum-lqnum_low  = ls_lqua-lqnum.
    APPEND ls_r_lqnum TO lt_r_lqnum.

**** CREATE

    "Chequeamos si hay que crear doc.mat.
    IF ( lv_postd EQ abap_true ).

*** POSTING CHANGE IM

      CLEAR: ls_return.

      me->_mvt_document_change(
        EXPORTING
          i_item_from = ls_item_from  " Datos procedencia
          i_item_to   = ls_item_to    " Datos destino
          i_move_type = '309'         " Clase de movimiento (gestión stocks)
*          i_commit    = 'X'    " 'X'=ok; ''=ko
        IMPORTING
          e_return    = ls_return    " Parámetro de retorno
        RECEIVING
          r_matdoc    = lv_matdoc    " Número de documento de material
      ).

      IF ( ls_return-type = 'E' ).
        CLEAR: lv_msg_v1.
        MOVE ls_return-message TO lv_msg_v1.
        me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
        EXIT.
      ENDIF.

*** POSTING CHANGE WM

** CREATE ZCL_UTILS_WM

      IF ( lo_wm_utils IS NOT BOUND ).
        TRY .
          lo_wm_utils = NEW zcl_utils_wm( i_werks = ls_item_from-plant i_lgort = ls_item_from-stge_loc ).
        CATCH  zcx_wm_exception INTO DATA(lo_wm_exception).
          CLEAR: lv_msg_v1.
          MOVE lo_wm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
          EXIT.
        CATCH zcx_mm_exception INTO DATA(lo_mm_exception).
          CLEAR: lv_msg_v1.
          MOVE lo_mm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
          EXIT.
        ENDTRY.
      ENDIF.

** CREATE TO

      IF ( lo_wm_utils IS BOUND ).

        "Obtengo número de traspaso
        DO 10 TIMES.

          SELECT SINGLE ubnum
            FROM mseg
            INTO @DATA(lv_ubnum)
           WHERE mblnr EQ @lv_matdoc
             AND mjahr EQ @sy-datum(4)
             AND ubnum NE @space.

          IF ( lv_ubnum IS INITIAL ).
            WAIT UP TO 1 SECONDS.
          ELSE.
            EXIT.
          ENDIF.

        ENDDO.

        lo_wm_utils->create_to_4_posting_change(
          EXPORTING
            i_ubnum     = lv_ubnum      " Número de traspaso
            i_t_r_lqnum = lt_r_lqnum    " Tabla rangos para cuantos
            i_updtask   = abap_false    " 'X'=ok; ''=ko
            i_commit    = abap_true     " 'X'=ok; ''=ko
        ).

        CLEAR: ls_item_from, ls_item_to, lt_r_lqnum.", lv_ubnum.

      ENDIF.

    ENDIF.

  ENDDO.

ENDMETHOD.
METHOD _change_sonum.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_sel_data   LIKE me->_outtab,
        ls_sel_data   LIKE LINE OF me->_outtab,
        ls_nex_data   LIKE LINE OF me->_outtab,
        ls_item_from  TYPE ty_mvt_doc_from,
        ls_item_to    TYPE ty_mvt_doc_to,
        ls_return     TYPE bapiret2,
        lv_matdoc     TYPE bapi2017_gm_head_ret-mat_doc.

  DATA: lv_msg_v1     TYPE string,
        lv_msg_v2     TYPE string,
        lv_msg_v3     TYPE string,
        lv_msg_v4     TYPE string.

  DATA: lt_sval       TYPE ty_sval,
        ls_sval       TYPE sval.

  DATA: ls_r_lqnum    TYPE zst_r_lqnum,
        lt_r_lqnum    TYPE ztt_r_lqnum.

  DATA: lo_wm_utils   TYPE REF TO zcl_utils_wm.

  DATA: lv_checks     TYPE abap_bool VALUE IS INITIAL,
        ls_chk_data   LIKE LINE OF me->_outtab.

  DATA: lv_lines      TYPE i,
        lv_index      TYPE i,
        lv_loops      TYPE i,
        lv_postd      TYPE abap_bool.

  DATA: lv_new_sonum  TYPE lqua-sonum.

  DATA: lv_rcode      TYPE char1.

  DATA: lv_bwart      TYPE bwart.

  DATA: ls_lqua       TYPE lqua.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( me->_check_selection( i_showing_popup = abap_true ) EQ abap_false ).
    EXIT.
  ENDIF.

*** GET SELECTED DATA

  me->get_selected_data(
    IMPORTING
      e_t_data = lt_sel_data
  ).

*** CHECK SELECTED DATA

** CHECK NO QPLOS

  READ TABLE lt_sel_data INTO ls_chk_data INDEX 1.

  LOOP AT lt_sel_data INTO ls_sel_data.

    "Indicador especial de stock
    IF ( ls_sel_data-bestq IS NOT INITIAL ).
      CLEAR: lv_msg_v3.
      CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-bestq INTO lv_msg_v3 SEPARATED BY space.
      me->_launch_popup_msg( i_msg1 = 'No pueden seleccionarse registros con stock especial' i_msg3 = lv_msg_v3 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

    "Lote de inspección
    IF ( ls_sel_data-qplos IS NOT INITIAL ).
      CLEAR: lv_msg_v3.
      CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-qplos INTO lv_msg_v3 SEPARATED BY space.
      me->_launch_popup_msg( i_msg1 = 'No pueden seleccionarse stocks con DE pendiente' i_msg3 = lv_msg_v3 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

    "Material siempre igual
    IF ( ls_sel_data-matnr NE ls_chk_data-matnr ).
      CLEAR: lv_msg_v3, lv_msg_v4.
      MOVE ls_sel_data-matnr TO lv_msg_v3.
      MOVE ls_chk_data-matnr TO lv_msg_v4.
      me->_launch_popup_msg( i_msg1 = 'Ha seleccionado dos materiales diferentes' i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).
      MOVE abap_true TO lv_checks.
      EXIT.
    ENDIF.

  ENDLOOP.

  IF ( lv_checks EQ abap_true ).
    EXIT.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** SORT BY

  SORT lt_sel_data BY matnr charg sonum.

*** USER SONUM

  "Pedimos valores al usuario
  CLEAR: ls_sval.
  ls_sval-tabname = 'MSEG'.
  ls_sval-fieldname = 'KDAUF'.
  APPEND ls_sval TO lt_sval.
  CLEAR: ls_sval.
  ls_sval-tabname = 'MSEG'.
  ls_sval-fieldname = 'KDPOS'.
  APPEND ls_sval TO lt_sval.
  lv_rcode = me->_launch_popup_values_get(
                  EXPORTING
                    i_valuecheck = abap_false
                  CHANGING
                    c_t_val      = lt_sval    " Tipo de tabla para SVAL
                ).

  IF ( lv_rcode IS NOT INITIAL ).

    me->_launch_popup_msg( i_msg1 = 'Acción cancelada por el usuario' ).
    EXIT.

  ELSE.

    CLEAR: lv_new_sonum.

    "Compruebo si ha insertado valor de pedido
    READ TABLE lt_sval INTO ls_sval INDEX 1.
    IF ( ls_sval-value IS INITIAL ). "Si no valor

      "Validamos liberar stock
      IF ( me->_launch_popup_to_confirm( i_question = 'Vas a liberar el stock. ¿estás de acuerdo?' i_popup_type = 'ICON_ALERT' ) EQ abap_false ).
        me->_launch_popup_msg( i_msg1 = 'Acción cancelada por el usuario' ).
        EXIT.
      ENDIF.

    ELSE.

      MOVE ls_sval-value TO lv_new_sonum.

      "Compruebo si ha insertado valor de posición
      READ TABLE lt_sval INTO ls_sval INDEX 2.
      IF ( ls_sval-value IS INITIAL ). "Si valor
        me->_launch_popup_msg( i_msg1 = 'No se ha informado la posición de pedido' ).
        EXIT.
      ELSE.
        CONCATENATE lv_new_sonum ls_sval-value INTO lv_new_sonum.
      ENDIF.

    ENDIF.

  ENDIF.

**** CHANGE SONUM

  CLEAR: lv_lines, lv_index.

  lv_lines = lines( lt_sel_data ).

  "Hacemos un loop de n líneas -1.
  DO lv_lines TIMES.

*** PREPARE DATA

    "Limpio variables
    CLEAR: lv_postd, ls_sel_data, ls_nex_data.

    "Calculo índice actual
    ADD 1 TO lv_index.

    "Obtengo registro actual
    READ TABLE lt_sel_data INTO ls_sel_data INDEX lv_index.
    CHECK sy-subrc EQ 0.

    "Si lv_lines tiene más de un registro, recupero siguiente.
    IF ( lv_lines GT 1 ).

      "Obtengo registro siguiente
      READ TABLE lt_sel_data INTO ls_nex_data INDEX lv_index + 1.
      IF ( sy-subrc NE 0 ).
        CLEAR: ls_nex_data.
      ENDIF.

    ELSE.

      IF ( lv_index = lv_lines ).
        CLEAR: ls_nex_data.
      ENDIF.

    ENDIF.

**** CHECK CHANGES

*** CHECK SONUM NE NEW_SONUM

    "Comprobamos si lote origen y destino son iguales
    IF ( ls_sel_data-sonum EQ lv_new_sonum ).
      CONTINUE.
    ENDIF.

*** CHECK LAST

    "Comprobamos si última línea
    IF ( lv_index = lv_lines ).

      "Crear doc.mat.
      MOVE abap_true TO lv_postd.

    ENDIF.

*** CHARG | SONUM

    "Comprobamos si hay cambio de lote o stock especial
    IF ( ( ls_sel_data-charg NE ls_nex_data-charg )     "Lote
      OR ( ls_sel_data-sonum NE ls_nex_data-sonum ) ).  "Stock especial

      "Compruebo si ya está marcado crear doc.mat.
      IF ( lv_postd EQ abap_false ).

        "Crear doc.mat.
        MOVE abap_true TO lv_postd.

      ENDIF.

    ENDIF.

**** FILL DATA

    "Obtengo datos de LQUA
*    SELECT SINGLE *
*      FROM lqua
*      INTO @DATA(ls_lqua)
*     WHERE lgnum EQ @ls_sel_data-lgnum
*       AND lgtyp EQ @ls_sel_data-lgtyp
*       AND lgpla EQ @ls_sel_data-lgpla
*       AND lenum EQ @ls_sel_data-lenum
*       AND matnr EQ @ls_sel_data-matnr
*       AND charg EQ @ls_sel_data-charg
*       AND sobkz EQ @ls_sel_data-sobkz
*       AND sonum EQ @ls_sel_data-sonum
*       AND bestq EQ @space
*       AND gesme EQ @ls_sel_data-gesme.
*
*    IF ( sy-subrc NE 0 ).
*      CONTINUE.
*    ENDIF  .

*  DATA(ls_lqua) = me->get_lqua_4_seldata

  CLEAR: ls_lqua.
  me->_get_lqua_4_seldata(
    EXPORTING
      i_sel_data = ls_sel_data    " Estructura para report ZHWM_REPALETIZADO
    RECEIVING
      r_lqua     = ls_lqua    " Cuantos
    EXCEPTIONS
      no_data    = 1
      others     = 2 ).
  IF ( sy-subrc <> 0 ).
    CONTINUE.
  ENDIF.

*** MATNR

* FROM

    IF ( ls_item_from-material IS INITIAL ).
      MOVE ls_lqua-matnr TO ls_item_from-material.
    ENDIF.

* TO

    IF ( ls_item_to-move_mat IS INITIAL ).
      MOVE ls_lqua-matnr TO ls_item_to-move_mat.
    ENDIF.

*** WERKS

** FROM

    IF ( ls_item_from-plant IS INITIAL ).
      MOVE ls_lqua-werks TO ls_item_from-plant.
    ENDIF.

** TO

    IF ( ls_item_to-move_plant IS INITIAL ).
      MOVE ls_lqua-werks TO ls_item_to-move_plant.
    ENDIF.

*** LGORT

** FROM

    IF ( ls_item_from-stge_loc IS INITIAL ).
      MOVE ls_lqua-lgort TO ls_item_from-stge_loc.
    ENDIF.

** TO

    IF ( ls_item_to-move_stloc IS INITIAL ).
      MOVE ls_lqua-lgort TO ls_item_to-move_stloc.
    ENDIF.

*** CHARG

** FROM

    IF ( ls_item_from-batch IS INITIAL ).
      MOVE ls_lqua-charg TO ls_item_from-batch.
    ENDIF.

** TO

    IF ( ls_item_to-move_batch IS INITIAL ).
      MOVE ls_lqua-charg TO ls_item_to-move_batch.
    ENDIF.

*** SOBKZ

** FROM

    IF ( ls_item_from-spec_stock IS INITIAL ).
      MOVE ls_lqua-sobkz TO ls_item_from-spec_stock.
    ENDIF.

** TO

    IF ( lv_new_sonum IS NOT INITIAL ).
      IF ( ls_item_to-spec_stock IS INITIAL ).
        MOVE 'E' TO ls_item_to-spec_stock.
      ENDIF.
    ENDIF.

*** SONUM

** FROM

    "KDAUF
    IF ( ls_item_from-val_sales_ord IS INITIAL ).
      MOVE ls_lqua-sonum(10) TO ls_item_from-val_sales_ord.
    ENDIF.

    "KDPOS
    IF ( ls_item_from-val_s_ord_item IS INITIAL ).
      MOVE ls_lqua-sonum+10(6) TO ls_item_from-val_s_ord_item.
    ENDIF.

** TO

    IF ( lv_new_sonum IS NOT INITIAL ).

      "KDAUF
      IF ( ls_item_to-sales_ord IS INITIAL ).
        MOVE lv_new_sonum(10) TO ls_item_to-sales_ord.
      ENDIF.

      "KDPOS
      IF ( ls_item_to-s_ord_item IS INITIAL ).
        MOVE lv_new_sonum+10(6) TO ls_item_to-s_ord_item.
      ENDIF.

    ENDIF.

*** UOM

    IF ( ls_item_from-entry_uom IS INITIAL ).

      SELECT SINGLE meins
        FROM mara
        INTO ls_item_from-entry_uom
       WHERE matnr EQ ls_lqua-matnr.

    ENDIF.

*** QTY

** IM

    "Convierto a UN base
    CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
      EXPORTING
        i_matnr                    = ls_lqua-matnr
        i_in_me                    = ls_lqua-meins
        i_out_me                   = ls_item_from-entry_uom
        i_menge                    = ls_lqua-gesme
      IMPORTING
        e_menge                    = ls_lqua-gesme
      EXCEPTIONS
        error_in_application       = 1
        error                      = 2
        OTHERS                     = 3.

    ADD ls_lqua-gesme TO ls_item_from-entry_qnt.

*** LENUM

    CLEAR: ls_r_lqnum.
    ls_r_lqnum-sign       = 'I'.
    ls_r_lqnum-option     = 'EQ'.
    ls_r_lqnum-lqnum_low  = ls_lqua-lqnum.
    APPEND ls_r_lqnum TO lt_r_lqnum.

**** CREATE

    "Chequeamos si hay que crear doc.mat.
    IF ( lv_postd EQ abap_true ).

*** POSTING CHANGE IM

      CLEAR: ls_return, lv_bwart.

      "Determinamos clase de movimiento
      IF ( ls_item_from-val_sales_ord IS NOT INITIAL ). "FROM con sonum

        "Comprobamos si TO sonum es inicial
        IF ( ls_item_to-sales_ord IS NOT INITIAL ). "TO con sonum
          MOVE '413' TO lv_bwart. "cambio de sonum
        ELSE. "TO sin sonum
          MOVE '411' TO lv_bwart. "sonum a libre
        ENDIF.

      ELSE. "FROM sin sonum

        "Comprobamos si TO sonum es inicial
        IF ( ls_item_to-sales_ord IS NOT INITIAL ). "TO con sonum

          "En este caso, hay que cambiar el from por el to y viceversa
          MOVE ls_item_to-spec_stock  TO ls_item_from-spec_stock.
          MOVE ls_item_to-sales_ord   TO ls_item_from-val_sales_ord.
          MOVE ls_item_to-s_ord_item  TO ls_item_from-val_s_ord_item.

          CLEAR: ls_item_to-sales_ord, ls_item_to-s_ord_item.

          MOVE '412' TO lv_bwart. "libre a sonum

        ELSE. "TO sin sonum

          CONTINUE.               "Sin cambios.

        ENDIF.

      ENDIF.

      me->_mvt_document_change(
        EXPORTING
          i_item_from = ls_item_from  " Datos procedencia
          i_item_to   = ls_item_to    " Datos destino
          i_move_type = lv_bwart         " Clase de movimiento (gestión stocks)
*          i_commit    = 'X'    " 'X'=ok; ''=ko
        IMPORTING
          e_return    = ls_return    " Parámetro de retorno
        RECEIVING
          r_matdoc    = lv_matdoc    " Número de documento de material
      ).

      IF ( ls_return-type = 'E' ).
        CLEAR: lv_msg_v1.
        MOVE ls_return-message TO lv_msg_v1.
        me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
        EXIT.
      ENDIF.

*** POSTING CHANGE WM

** CREATE ZCL_UTILS_WM

      IF ( lo_wm_utils IS NOT BOUND ).
        TRY .
          lo_wm_utils = NEW zcl_utils_wm( i_werks = ls_item_from-plant i_lgort = ls_item_from-stge_loc ).
        CATCH  zcx_wm_exception INTO DATA(lo_wm_exception).
          CLEAR: lv_msg_v1.
          MOVE lo_wm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
          EXIT.
        CATCH zcx_mm_exception INTO DATA(lo_mm_exception).
          CLEAR: lv_msg_v1.
          MOVE lo_mm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
          EXIT.
        ENDTRY.
      ENDIF.

** CREATE TO

      IF ( lo_wm_utils IS BOUND ).

        "Obtengo número de traspaso
        DO 10 TIMES.

          SELECT SINGLE ubnum
            FROM mseg
            INTO @DATA(lv_ubnum)
           WHERE mblnr EQ @lv_matdoc
             AND mjahr EQ @sy-datum(4)
             AND ubnum NE @space.

          IF ( lv_ubnum IS INITIAL ).
            WAIT UP TO 1 SECONDS.
          ELSE.
            EXIT.
          ENDIF.

        ENDDO.

        lo_wm_utils->create_to_4_posting_change(
          EXPORTING
            i_ubnum     = lv_ubnum      " Número de traspaso
            i_t_r_lqnum = lt_r_lqnum    " Tabla rangos para cuantos
            i_updtask   = abap_false    " 'X'=ok; ''=ko
            i_commit    = abap_true     " 'X'=ok; ''=ko
        ).

        CLEAR: ls_item_from, ls_item_to, lt_r_lqnum.", lv_ubnum.

      ENDIF.

    ENDIF.

  ENDDO.

ENDMETHOD.
METHOD _check_consistent_data.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_sel_data   LIKE LINE OF i_t_data,
        ls_chk_data   LIKE LINE OF i_t_data.

  DATA: lv_msg_v1     TYPE string,
        lv_msg_v2     TYPE string,
        lv_msg_v3     TYPE string,
        lv_msg_v4     TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

  CHECK lines( i_t_data ) GT 0.

**********************************************************************
* Lógica
**********************************************************************

**** INIT

  MOVE abap_true TO r_is_ok.

**** GET FIRST LINE TO COMPARE DATA

  READ TABLE i_t_data INTO ls_chk_data INDEX 1.

  "Recorremos la tabla de datos
  LOOP AT i_t_data INTO ls_sel_data.

*** CHECK BESTQ INITIAL

    IF ( i_check_bestq_initial EQ abap_true ).

      "Indicador especial de stock
      IF ( ls_sel_data-bestq IS NOT INITIAL ).

        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3.
          MOVE text-110 TO lv_msg_v1.
          CONCATENATE lv_msg_v1 ls_sel_data-bestq INTO lv_msg_v1 SEPARATED BY space.
          CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-bestq INTO lv_msg_v3 SEPARATED BY space.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 ).

        ENDIF.

        MOVE abap_false TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

*** CHECK QPLOS

    IF ( i_check_qplos_initial EQ abap_true ).

      "Lote de inspección
      IF ( ls_sel_data-qplos IS NOT INITIAL ).

        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3.
          MOVE text-111 TO lv_msg_v1.
          CONCATENATE ls_sel_data-matnr ls_sel_data-charg ls_sel_data-qplos INTO lv_msg_v3 SEPARATED BY space.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 ).

        ENDIF.

        MOVE abap_false TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

*** MATNR SIEMPRE IGUAL

    IF ( i_check_matnr_same EQ abap_true ).

      "Material siempre igual
      IF ( ls_sel_data-matnr NE ls_chk_data-matnr ).

        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
          MOVE text-112 TO lv_msg_v1.
          MOVE ls_sel_data-matnr TO lv_msg_v3.
          MOVE ls_chk_data-matnr TO lv_msg_v4.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).

        ENDIF.

        MOVE abap_false TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

*** CHARG SIEMPRE IGUAL

    IF ( i_check_charg_same EQ abap_true ).

      "Lote siempre igual
      IF ( ls_sel_data-charg NE ls_chk_data-charg ).

        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
          MOVE text-113 TO lv_msg_v1.
          MOVE ls_sel_data-charg TO lv_msg_v3.
          MOVE ls_chk_data-charg TO lv_msg_v4.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).

        ENDIF.

        MOVE abap_false TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

*** SONUM SIEMPRE IGUAL

    IF ( i_check_sonum_same EQ abap_true ).

      "Stock especial siempre igual
      IF ( ls_sel_data-sonum NE ls_chk_data-sonum ).

        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
          MOVE text-114 TO lv_msg_v1.
          MOVE ls_sel_data-sonum TO lv_msg_v3.
          MOVE ls_chk_data-sonum TO lv_msg_v4.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).

        ENDIF.

        MOVE abap_true TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

*** SOBKZ SIEMPRE IGUAL

    IF ( i_check_sobkz_same EQ abap_true ).

      "Indicador de stock especial siempre igual
      IF ( ls_sel_data-sobkz NE ls_chk_data-sobkz ).


        IF ( i_show_popup EQ abap_true ).

          CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
          MOVE text-115 TO lv_msg_v1.
          MOVE ls_sel_data-sobkz TO lv_msg_v3.
          MOVE ls_chk_data-sobkz TO lv_msg_v4.
          me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).

        ENDIF.

        MOVE abap_true TO r_is_ok.
        EXIT.

      ENDIF.

    ENDIF.

  ENDLOOP.

ENDMETHOD.
  method _CHECK_NO_QPLOS.
  endmethod.
METHOD _check_quantities.

**********************************************************************
* Parámetrops locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: lv_gesme_tot TYPE lqua_gesme,
        lv_gesme_str TYPE string,
        lv_menge_tot TYPE znew_menge,
        lv_menge_str TYPE string,
        lv_difer     TYPE lqua_gesme,
        lv_difer_str TYPE string,
        lv_msg1      TYPE string,
        lv_msg2      TYPE string,
        lv_msg3      TYPE string,
        lv_msg4      TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

*** GET CURRENT TOTAL QUANTITIES

  me->_get_totals_4_quantities(
    IMPORTING
      e_gesme_tot     = lv_gesme_tot    " Cantidad total
      e_new_menge_tot = lv_menge_tot    " Cantidad nueva tipo entero
  ).

*** CHECKS

** CHECK 1 --> Cantidad total de reparto no igual a cero

  IF ( i_check_nozero EQ abap_true ).

    "Cantidad repartida = 0
    IF ( lv_menge_tot EQ 0 ).

      MOVE abap_false TO r_is_ok_nozero.

      IF ( i_showing_popup EQ abap_true ).

        "Transformo nueva cantidad a string
        MOVE lv_menge_tot TO lv_menge_str.
        SHIFT lv_menge_str LEFT DELETING LEADING '0'.
        CONDENSE lv_menge_str NO-GAPS.

        "Montamos texto 1
        MOVE text-105 TO lv_msg1.
        "Montamos texto 3
        CONCATENATE: 'Cantidad repartida' lv_menge_str INTO lv_msg4 SEPARATED BY space.

        me->_launch_popup_msg( i_msg1 = lv_msg1 i_msg2 = lv_msg2 i_msg3 = lv_msg3 i_msg4 = lv_msg4 ).

      ENDIF.

    ELSE.

      MOVE abap_true TO r_is_ok_nozero.

    ENDIF.

  ENDIF.

** CHECK 2 --> Cantidad de reparto no mayor a cantidad de stock

  IF ( i_check_max_qty EQ abap_true ).

    "Cantidad stock menor a nueva cantidad
    IF ( lv_gesme_tot LT lv_menge_tot ).

      MOVE abap_false TO r_is_ok_max_qty.

      IF ( i_showing_popup EQ abap_true ).

        "Transformo stock a string
        MOVE lv_gesme_tot TO lv_gesme_str.
        CONDENSE lv_gesme_str NO-GAPS.

        "Transformo nueva cantidad a string
        MOVE lv_menge_tot TO lv_menge_str.
        SHIFT lv_menge_str LEFT DELETING LEADING '0'.
        CONDENSE lv_menge_str NO-GAPS.

        "Montamos texto 1
        MOVE text-101 TO lv_msg1.
        "Montamos texto 2
        CONCATENATE: 'Cantidad disponible:' lv_gesme_str INTO lv_msg3 SEPARATED BY space.
        "Montamos texto 3
        CONCATENATE: 'Cantidad repartida' lv_menge_str INTO lv_msg4 SEPARATED BY space.

        me->_launch_popup_msg( i_msg1 = lv_msg1 i_msg2 = lv_msg2 i_msg3 = lv_msg3 i_msg4 = lv_msg4 ).

      ENDIF.

    ELSE.

      MOVE abap_true TO r_is_ok_max_qty.

    ENDIF.

  ENDIF.

** CHECK 3 --> Cantidad de reparto menos a cantidad de stock

  IF ( i_check_bajas EQ abap_true ).

    "Cantidad stock mayor a nueva cantidad
    IF ( lv_gesme_tot GT lv_menge_tot ).

      MOVE abap_false TO r_is_ok_bajas.

      IF ( i_showing_popup EQ abap_true ).

        "Transformo stock a string
        MOVE lv_gesme_tot TO lv_gesme_str.
        CONDENSE lv_gesme_str NO-GAPS.

        "Transformo nueva cantidad a string
        MOVE lv_menge_tot TO lv_menge_str.
        SHIFT lv_menge_str LEFT DELETING LEADING '0'.
        CONDENSE lv_menge_str NO-GAPS.

        "Cálculo diferencia
        lv_difer = lv_gesme_tot - lv_menge_tot.
        MOVE lv_difer TO lv_difer_str.
        CONDENSE lv_difer_str NO-GAPS.

        "Montamos texto 1
        MOVE text-106 TO lv_msg1.
        "Montamos texto 2
        CONCATENATE: 'Cantidad disponible:' lv_gesme_str INTO lv_msg2 SEPARATED BY space.
        "Montamos texto 3
        CONCATENATE: 'Cantidad repartida:' lv_menge_str INTO lv_msg3 SEPARATED BY space.
        "Montamos texto 4
        CONCATENATE: 'Cantidad a dar de baja:' lv_difer_str INTO lv_msg4 SEPARATED BY space.

        me->_launch_popup_msg( i_msg1 = lv_msg1 i_msg2 = lv_msg2 i_msg3 = lv_msg3 i_msg4 = lv_msg4 ).

      ENDIF.

    ELSE.

      MOVE abap_true TO r_is_ok_bajas.

    ENDIF.

  ENDIF.

ENDMETHOD.
METHOD _check_selection.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: lt_row    TYPE lvc_t_row,
        lt_rowid  TYPE lvc_t_roid.

  DATA: lv_message TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

  MOVE abap_true TO r_is_ok.

*** NO SELECTION

  "get rows selected
  me->_o_alv_grid->get_selected_rows(
    IMPORTING
      et_index_rows = lt_row
      et_row_no     = lt_rowid
  ).

  IF ( lines( lt_row ) LE 0 ).

    MOVE abap_false TO r_is_ok.

    IF ( i_showing_popup EQ abap_true ).

      CLEAR: lv_message.
      MOVE text-102 TO lv_message.
      me->_launch_popup_msg( i_msg1 = lv_message ).

    ENDIF.

    EXIT.

  ENDIF.

ENDMETHOD.
METHOD _del_row.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: lt_row    TYPE lvc_t_row,
        ls_row    TYPE lvc_s_row.

  DATA: lv_msg_v1 TYPE string.

**********************************************************************
* Validaciones
**********************************************************************


**********************************************************************
* Lógica
**********************************************************************

*** ASSIGN

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

  IF ( <ft_data> IS ASSIGNED ).

    me->_o_alv_grid->get_selected_rows(
      IMPORTING
        et_index_rows = lt_row
*        et_row_no     =
    ).

    SORT lt_row BY index DESCENDING.

    IF ( lines( lt_row ) GT 0 ).

      LOOP AT lt_row INTO ls_row.

        DELETE <ft_data> INDEX ls_row-index.

      ENDLOOP.

    ELSE.

      CLEAR: lv_msg_v1.
      MOVE text-117 TO lv_msg_v1.
      me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
      EXIT.

    ENDIF.

  ENDIF.

ENDMETHOD.
METHOD _get_bapiret_4_msgid.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <fv_textid> TYPE any.

  DATA: lv_textid  TYPE string.

  DATA: lv_message TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

  CHECK i_msgid IS NOT INITIAL.
  CHECK i_msgno IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

*** RETURN BAPIRET

  "Comprobamos ID y NUMERO
  IF ( i_msgid(1) EQ 'Z' ). "MENSAJE Z

    CONCATENATE 'TEXT-' i_msgno INTO lv_textid.

    ASSIGN (lv_textid) TO <fv_textid>.
    IF ( <fv_textid> IS ASSIGNED ).

      r_bapiret2-id     = i_msgid.
      r_bapiret2-number = i_msgno.
      MOVE <fv_textid> TO r_bapiret2-message.
      r_bapiret2-type   = 'E'.

      UNASSIGN <fv_textid>.

    ENDIF.

  ELSE. "MENSAJE ESTÁNDAR

    r_bapiret2-id     = i_msgid.
    r_bapiret2-number = i_msgno.
    r_bapiret2-type   = 'E'.

    CALL FUNCTION 'BAPI_MESSAGE_GETDETAIL'
      EXPORTING
        id                 = i_msgid
        number             = i_msgno
        textformat         = 'ASC'
        message_v1         = i_msgv1
        message_v2         = i_msgv2
        message_v3         = i_msgv3
        message_v4         = i_msgv4
       IMPORTING
         message            = r_bapiret2-message.

  ENDIF.



ENDMETHOD.
METHOD _get_lqua_4_seldata.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**** IMPORT DATA

  IF ( i_sel_data-lenum IS INITIAL ).
    RAISE no_data.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

**** SELECT DATA

  "Obtengo datos de LQUA
  SELECT SINGLE *
    FROM lqua
    INTO @r_lqua
   WHERE lgnum EQ @i_sel_data-lgnum
     AND lgtyp EQ @i_sel_data-lgtyp
     AND lgpla EQ @i_sel_data-lgpla
     AND lenum EQ @i_sel_data-lenum
     AND matnr EQ @i_sel_data-matnr
     AND charg EQ @i_sel_data-charg
     AND sobkz EQ @i_sel_data-sobkz
     AND sonum EQ @i_sel_data-sonum
     AND bestq EQ @space
     AND gesme EQ @i_sel_data-gesme.

  IF ( sy-subrc NE 0 ).
    RAISE no_data.
  ENDIF.

ENDMETHOD.
METHOD _get_totals_4_quantities.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: ls_data LIKE LINE OF me->_outtab.

**********************************************************************
* Validaciones
**********************************************************************º

**********************************************************************
* Lógica
**********************************************************************

*** GET OUTTAB DATA

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

*** GET TOTALS

  IF ( <ft_data> IS ASSIGNED ).

    LOOP AT <ft_data> INTO ls_data.

      ADD ls_data-gesme TO e_gesme_tot.
      ADD ls_data-new_menge TO e_new_menge_tot.

    ENDLOOP.

  ENDIF.

ENDMETHOD.
METHOD _launch_de.

**********************************************************************
* Parámetros locales
**********************************************************************

  TYPES: BEGIN OF ty_r_qplos,
    sign    TYPE sign,
    option  TYPE option,
    low     TYPE qplos,
    high    TYPE qplos,
  END OF ty_r_qplos.


  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: ls_data   LIKE LINE OF me->_outtab.

  DATA: lt_row    TYPE lvc_t_row,
        ls_row    TYPE lvc_s_row,
        lt_rowid  TYPE lvc_t_roid.

  DATA: ls_r_qplos TYPE ty_r_qplos,
        lt_r_qplos TYPE TABLE OF ty_r_qplos.

*  DATA: lt_row    TYPE lvc_t_row,
*        lt_rowid  TYPE lvc_t_roid.
*
*  DATA: lv_gesme_tot TYPE lqua_gesme,
*        lv_menge_tot TYPE znew_menge,
*        lv_difer_tot TYPE lqua_gesme,
*        lv_difer_str TYPE string,
*        lv_answer    TYPE abap_bool.
*
*  DATA: lv_message TYPE string.
*
*  DATA: lv_check_nozero TYPE abap_bool,
*        lv_check_maxqty TYPE abap_bool,
*        lv_check_minqty TYPE abap_bool.


**********************************************************************
* Validaciones
**********************************************************************



**********************************************************************
* Lógica
**********************************************************************

***

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

  IF ( <ft_data> IS ASSIGNED ).

    IF ( me->_check_selection( i_showing_popup = abap_true ) EQ abap_true ).

      "get rows selected
      me->_o_alv_grid->get_selected_rows(
        IMPORTING
          et_index_rows = lt_row
          et_row_no     = lt_rowid
      ).

      CLEAR: ls_r_qplos.
      ls_r_qplos-sign = 'I'.
      ls_r_qplos-option = 'EQ'.
      ls_r_qplos-low = space.
      APPEND ls_r_qplos TO lt_r_qplos.

      "Modificamos DE para todas las seleccionadas
      LOOP AT lt_row INTO ls_row.

        READ TABLE <ft_data> INTO ls_data INDEX ls_row-index.
        IF ( sy-subrc EQ 0 ).

          IF ( ls_data-bestq EQ 'Q' AND ls_data-qplos IS NOT INITIAL ).

            "Comprobamos que no haya sido ya tratado
            IF ( ls_data-qplos NOT IN lt_r_qplos ).

              SET PARAMETER ID 'QLS' FIELD ls_data-qplos.

              CALL FUNCTION 'QAUT_CHECK_TCODE'
                EXPORTING
                  i_tcode = 'QA11'.

               CALL TRANSACTION 'QA11' AND SKIP FIRST SCREEN.

               CLEAR: ls_r_qplos.
               ls_r_qplos-sign = 'I'.
               ls_r_qplos-option = 'EQ'.
               ls_r_qplos-low = ls_data-qplos.
               APPEND ls_r_qplos TO lt_r_qplos.

            ENDIF.

          ELSE.

            me->_launch_popup_msg( i_msg1 = 'Posición con DE ya tomada' ).

          ENDIF.

        ENDIF.
      ENDLOOP.

    ENDIF.

  ENDIF.

ENDMETHOD.
METHOD _mvt_document_change.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_header TYPE bapi2017_gm_head_01,
        ls_code   TYPE bapi2017_gm_code,
        lt_items  TYPE TABLE OF bapi2017_gm_item_create,
        ls_item   TYPE bapi2017_gm_item_create,

        lt_return TYPE TABLE OF bapiret2,
        ls_return TYPE bapiret2,

        lv_mblnr  TYPE bapi2017_gm_head_ret-mat_doc,
        lv_mjahr  TYPE bapi2017_gm_head_ret-doc_year,

        lv_testrun TYPE abap_bool,

        lv_message TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

*** MVT TYPE

  IF ( i_move_type IS INITIAL ).

    CLEAR: ls_return, lv_message.
    ls_return = me->_get_bapiret_4_msgid( i_msgid = me->zif_msg_utils~_c_cl_msgid_label i_msgno = 109 ).
    MOVE ls_return-message TO lv_message.
    me->_launch_popup_msg( i_msg1 = lv_message ).
    EXIT.

  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** FILL HEADER

  CLEAR: ls_header.
  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.

*** FILL CODE

  CLEAR: ls_code.
  ls_code-gm_code      = '04'.

*** FILL ITEM

  CLEAR: ls_item.

** MVT

  ls_item-move_type   = i_move_type.

** FROM

  ls_item-material        = i_item_from-material.
  ls_item-plant           = i_item_from-plant.
  ls_item-stge_loc        = i_item_from-stge_loc.
  ls_item-batch           = i_item_from-batch.
  ls_item-entry_qnt       = i_item_from-entry_qnt.
  ls_item-entry_uom       = i_item_from-entry_uom.
  ls_item-spec_stock      = i_item_from-spec_stock.
  ls_item-val_sales_ord   = i_item_from-val_sales_ord.
  ls_item-val_s_ord_item  = i_item_from-val_s_ord_item.

** TO

  ls_item-move_mat    = i_item_to-move_mat.
  ls_item-move_plant  = i_item_to-move_plant.
  ls_item-move_stloc  = i_item_to-move_stloc.
  ls_item-move_batch  = i_item_to-move_batch.
  ls_item-sales_ord   = i_item_to-sales_ord.
  ls_item-s_ord_item  = i_item_to-s_ord_item.

  APPEND ls_item TO lt_items.

*** TESTRUN

  IF ( i_commit EQ abap_true ).
    lv_testrun = abap_false.
  ELSE.
    lv_testrun = abap_true.
  ENDIF.

*** BAPI CALL

  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header               = ls_header
      goodsmvt_code                 = ls_code
      testrun                       = lv_testrun
*     GOODSMVT_REF_EWM              =
    IMPORTING
*     GOODSMVT_HEADRET              =
      materialdocument              = lv_mblnr
      matdocumentyear               = lv_mjahr
    TABLES
      goodsmvt_item                 = lt_items
*     GOODSMVT_SERIALNUMBER         =
      return                        = lt_return
*     GOODSMVT_SERV_PART_DATA       =
*     EXTENSIONIN                   =
            .

  READ TABLE lt_return INTO e_return WITH KEY type = 'E'.
  IF ( sy-subrc EQ 0 ).
    ROLLBACK WORK.
  ELSE.
    IF ( i_commit EQ abap_true ).
      MOVE lv_mblnr TO r_matdoc.
      COMMIT WORK AND WAIT.
    ELSE.
      ROLLBACK WORK.
    ENDIF.
  ENDIF.


ENDMETHOD.
METHOD _print_labels.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_bartender_mngr TYPE REF TO zcl_wm_bartender_print_manager.

  DATA: lt_sel_data LIKE me->_outtab,
        ls_sel_data LIKE LINE OF me->_outtab.

  DATA: ls_lqua TYPE lqua.

  DATA: lv_msgv1 TYPE string,
        lv_msgv2 TYPE string,
        lv_msgv3 TYPE string,
        lv_msgv4 TYPE string.

  DATA: lv_mvttype TYPE zmvttype.

**********************************************************************
* Validaciones
**********************************************************************

**** SELECTED DATA

  if ( me->_check_selection( i_showing_popup = abap_true ) EQ abap_false ).
    EXIT.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

**** CREATE INSTANCE

*** GET WERKS AND LGORT

  "Obtengo datos seleccionados
  me->get_selected_data(
    IMPORTING
      e_t_data = lt_sel_data
  ).

  "Obtengo primer registro para obtener cuanto
  READ TABLE lt_sel_data INTO ls_sel_data INDEX 1.
  IF ( sy-subrc EQ 0 ).

    "Obtengo datos de cuanto
    me->_get_lqua_4_seldata(
      EXPORTING
        i_sel_data = ls_sel_data  " Estructura para report ZHWM_REPALETIZADO
      RECEIVING
        r_lqua     = ls_lqua      " Cuantos
      EXCEPTIONS
        no_data    = 1
        OTHERS     = 2
    ).

    IF ( sy-subrc = 0 ).

      "Creo instancia de objeto
      TRY .
        lo_bartender_mngr = NEW zcl_wm_bartender_print_manager( i_werks = ls_lqua-werks i_lgort = ls_lqua-lgort ).
      CATCH zcx_wm_exception.

      ENDTRY.


    ENDIF.

  ENDIF.

**** ASK FOR PRINT METHOD

  DATA: lt_sval       TYPE ty_sval,
        ls_sval       TYPE sval.

  "Pedimos lote al usuario
  CLEAR: ls_sval.
  ls_sval-tabname = 'ZST_BARTENDER_LABEL_DATA'.
  ls_sval-fieldname = 'MVTTYPE'.
  APPEND ls_sval TO lt_sval.
  me->_launch_popup_values_get(
    EXPORTING
      i_valuecheck = abap_false
    CHANGING
      c_t_val      = lt_sval    " Tipo de tabla para SVAL
  ).
  READ TABLE lt_sval INTO ls_sval INDEX 1.
  IF ( ls_sval-value IS NOT INITIAL ).

    MOVE ls_sval-value TO lv_mvttype.

  ELSE.

    me->_launch_popup_msg( i_msg1 = 'Acción cancelada por el usuario' ).
    EXIT.

  ENDIF.


**** ADD DATA TO PRINT

  IF ( lo_bartender_mngr IS BOUND ).

    LOOP AT lt_sel_data INTO ls_sel_data.

      IF ( ls_sel_data-lenum IS NOT INITIAL ).



*--> INI FCARDONA - 20.06.2024 - Cambio excepción de método lo_bartender_mngr->set_new_label_data_4_lenum a clase
*
***** Comento por cambiar la excepción a clase
*
*        lo_bartender_mngr->set_new_label_data_4_lenum(
*          EXPORTING
*            i_mvttype        = lv_mvttype           " Tipo de movimiento para BARTENDER
*            i_lenum          = ls_sel_data-lenum    " Número de unidad de almacén
*          EXCEPTIONS
*            no_valid_iparams = 1
*            no_lqua_data     = 2
*            error_internal   = 3
*            no_valid_data    = 4
*            others           = 5
*        ).
*        IF ( sy-subrc <> 0 ).
*
*          CLEAR: lv_msgv1, lv_msgv2.
*          CASE sy-subrc.
*            WHEN 1.
*              MOVE 'Parámetros IMPORT no válidos' TO lv_msgv1.
*            WHEN 2.
*              MOVE 'No existen datos para el cuanto' TO lv_msgv1.
*            WHEN 3.
*              MOVE 'Error interno' TO lv_msgv1.
*            WHEN 4.
*              MOVE 'Datos no válidos para imprimir' TO lv_msgv1.
*            WHEN OTHERS.
*              MOVE 'Error interno' TO lv_msgv1.
*          ENDCASE.
*
*          MOVE ls_sel_data-lenum TO lv_msgv3.
*          MOVE lv_mvttype TO lv_msgv4.
*
*          me->_launch_popup_msg( i_msg1 = lv_msgv1 i_msg3 = lv_msgv3 i_msg4 = lv_msgv4 ).
*          EXIT.
*
*        ENDIF.

          TRY .
            lo_bartender_mngr->set_new_label_data_4_lenum( i_mvttype = lv_mvttype i_lenum = ls_sel_data-lenum ).
          CATCH zcx_exception INTO DATA(lo_exception).    "
            MOVE lo_exception->if_t100_message~t100key-attr1 TO lv_msgv1.
            MOVE ls_sel_data-lenum TO lv_msgv3.
            MOVE lv_mvttype TO lv_msgv4.
            me->_launch_popup_msg( i_msg1 = lv_msgv1 i_msg3 = lv_msgv3 i_msg4 = lv_msgv4 ).
            EXIT.
          ENDTRY.

*<-- FIN FCARDONA - 20.06.2024 - Cambio excepción de método lo_bartender_mngr->set_new_label_data_4_lenum a clase



      ENDIF.

    ENDLOOP.

    IF ( lines( lo_bartender_mngr->_t_bartender_data ) GT 0 ).

      lo_bartender_mngr->send_label_data_2_bartender_fl(
        EXCEPTIONS
          file_no_created = 1
          others          = 2
      ).
      IF ( sy-subrc EQ 0 ).

        CLEAR: lv_msgv1.
        MOVE 'Ficehro de impresión creado' TO lv_msgv1.
        me->_launch_popup_msg( i_msg1 = lv_msgv1 ).
        EXIT.

      ELSE.

        CLEAR: lv_msgv1.
        MOVE 'No se ha podido crear el ficehro de impresión' TO lv_msgv1.
        me->_launch_popup_msg( i_msg1 = lv_msgv1 ).
        EXIT.

      ENDIF.

    ENDIF.

  ELSE.

    me->_launch_popup_msg( i_msg1 = 'No es posible imprimir los datos. Contacte a su administrador.' ).
    EXIT.

  ENDIF.




ENDMETHOD.
METHOD _REPALETIZA_1.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_sel_data   LIKE me->_outtab,
        ls_sel_data   LIKE LINE OF me->_outtab.

  DATA: lv_gesme_tot  TYPE lqua_gesme,
        lv_menge_tot  TYPE znew_menge,
        lv_difer_tot  TYPE lqua_gesme,
        lv_difer_str  TYPE string.

  DATA: lv_msg_v1     TYPE string,
        lv_msg_v2     TYPE string,
        lv_msg_v3     TYPE string,
        lv_msg_v4     TYPE string.

  DATA: lv_answer     TYPE abap_bool.

  DATA: lv_checks     TYPE abap_bool VALUE IS INITIAL,
        ls_chk_data   LIKE LINE OF me->_outtab.

  DATA: lo_wm_utils   TYPE REF TO zcl_utils_wm.

**********************************************************************
* Validaciones
**********************************************************************

**** SELECTION DATA

  IF ( me->_check_selection( i_showing_popup = abap_true ) EQ abap_false ).
    sy-ucomm = 'KO'.
    EXIT.
  ENDIF.

**** GET SELECTED DATA

  me->get_selected_data(
    IMPORTING
      e_t_data = lt_sel_data
  ).

**** CHECK SELECTED DATA

*** CHECK CONSISTENCY

  IF ( me->_check_consistent_data( i_t_data = lt_sel_data ) EQ abap_false ).
    sy-ucomm = 'KO'.
    EXIT.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

ENDMETHOD.
METHOD _repaletiza_2.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data> LIKE me->_outtab.

  DATA: ls_sel_data     LIKE LINE OF me->_outtab.

  DATA: ls_lqua         TYPE lqua,
        ls_lqua_model   TYPE lqua.

  DATA: lv_gesme_tot    TYPE lqua_gesme,
        lv_menge_tot    TYPE znew_menge,
        lv_gesme_str    TYPE string,
        lv_menge_str    TYPE string.

  DATA: lv_msg_v1       TYPE string,
        lv_msg_v2       TYPE string,
        lv_msg_v3       TYPE string,
        lv_msg_v4       TYPE string.

  DATA: lo_wm_utils     TYPE REF TO zcl_utils_wm,
        lo_wm_exception TYPE REF TO zcx_wm_exception,
        lo_mm_exception TYPE REF TO zcx_mm_exception.

  DATA: ls_return       TYPE bapiret2.

  DATA: lt_ot_data      TYPE ztt_wm_utils_ot_creation,
        ls_ot_data      TYPE zst_wm_utils_ot_creation.

  DATA: lv_f_lgtyp      TYPE lgtyp,
        lv_f_lgpla      TYPE lgpla.

  DATA: lv_new_gesme    TYPE lqua_gesme.

  DATA: lt_ltap_create  TYPE msr_t_insp_wmc_ltap_create,
        ls_ltap_create  TYPE ltap_creat.

**********************************************************************
* Validaciones
**********************************************************************

**** ASSIGN DATA

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

**** CHECK SELECTED DATA

*** CHECK CONSISTENCY

  IF ( me->_check_consistent_data( i_t_data = <ft_data> ) EQ abap_false ).
    sy-ucomm = 'KO'.
    EXIT.
  ENDIF.

*** CHECK QUANTITIES

  LOOP AT <ft_data> INTO ls_sel_data.

    ADD ls_sel_data-gesme TO lv_gesme_tot.
    ADD ls_sel_data-new_menge TO lv_menge_tot.

  ENDLOOP.

  IF ( lv_gesme_tot NE lv_menge_tot ).

    CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
    MOVE text-116 TO lv_msg_v1.
    MOVE lv_gesme_tot TO lv_gesme_str.
    SHIFT lv_gesme_str LEFT DELETING LEADING '0'.
    MOVE lv_menge_tot TO lv_menge_str.
    SHIFT lv_menge_str LEFT DELETING LEADING '0'.
    CONCATENATE: 'Total stock:' lv_gesme_str INTO lv_msg_v3 SEPARATED BY space.
    CONCATENATE: 'Total reparto:' lv_menge_str INTO lv_msg_v4 SEPARATED BY space.
    me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).
    sy-ucomm = 'KO'.
    EXIT.

  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

**** INIT object

*** GET WERKS AND LGORT

  CLEAR ls_sel_data.
  READ TABLE <ft_data> INTO ls_sel_data INDEX 1.

  "Obtengo LQUA modelo
  me->_get_lqua_4_seldata(
    EXPORTING
      i_sel_data = ls_sel_data      " Estructura para report ZHWM_REPALETIZADO
    RECEIVING
      r_lqua     = ls_lqua_model    " Cuantos
    EXCEPTIONS
      no_data    = 1
      OTHERS     = 2 ).
  IF ( sy-subrc <> 0 ).

    CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
    MOVE text-118 TO lv_msg_v1.
    me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
    sy-ucomm = 'KO'.
    EXIT.

  ENDIF.

*** INIT OBJECT

  TRY.

    lo_wm_utils = NEW zcl_utils_wm( i_werks = ls_lqua_model-werks i_lgort = ls_lqua_model-lgort ).

  CATCH zcx_wm_exception INTO lo_wm_exception.  "

    CLEAR: lv_msg_v1.
    MOVE lo_wm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
    me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
    sy-ucomm = 'KO'.
    EXIT.

  CATCH zcx_mm_exception INTO lo_mm_exception.  "

    CLEAR: lv_msg_v1.
    MOVE lo_mm_exception->if_t100_message~t100key-attr1 TO lv_msg_v1.
    me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
    sy-ucomm = 'KO'.
    EXIT.

  ENDTRY.

**** CHECK LGPLA DATA

  zcl_utils_alvgrid_repaletizado=>s_get_set_data_4_lgnum(
    EXPORTING
      i_lgnum   = ls_lqua_model-lgnum    " Núm.almacén/Complejo alm.
    IMPORTING
*      e_lgtyp_o =     " Tipo almacén origen
*      e_lgpla_o =     " Ubicación origen
      e_lgtyp_f = lv_f_lgtyp    " Tipo almacén final
      e_lgpla_f = lv_f_lgpla    " Ubicación final
  ).

**** REPAL

  IF ( lo_wm_utils IS BOUND ).

*** CREATE OT DATA

** APPEND FIRST LINE

    LOOP AT <ft_data> INTO ls_sel_data.

      CLEAR: ls_lqua, ls_ot_data, lv_new_gesme, ls_return, ls_ltap_create.

      me->_get_lqua_4_seldata(
         EXPORTING
           i_sel_data = ls_sel_data    " Estructura para report ZHWM_REPALETIZADO
         RECEIVING
           r_lqua     = ls_lqua    " Cuantos
         EXCEPTIONS
           no_data    = 1
           OTHERS     = 2 ).

      "Comprobamos si existe en LQUA
      IF ( sy-subrc EQ 0 ).

        "Obtengo todos los datos del cuanto

        "Datos material
        MOVE ls_lqua-matnr TO ls_ltap_create-matnr. "Material
        MOVE ls_lqua-charg TO ls_ltap_create-charg. "Lote
        MOVE ls_lqua-bestq TO ls_ltap_create-bestq. "Stock especial
        MOVE ls_lqua-sobkz TO ls_ltap_create-sobkz. "Indicador stock especial
        MOVE ls_lqua-sonum TO ls_ltap_create-sonum. "Número stock especial

        MOVE ls_lqua-werks TO ls_ltap_create-werks. "Centro
        MOVE ls_lqua-lgort TO ls_ltap_create-lgort. "Almacén
        MOVE ls_lqua-letyp TO ls_ltap_create-letyp. "Tipo de UA

        "Otros
        MOVE 'REPROCESO'  TO ls_ltap_create-zeugn.   "certificado
        MOVE abap_true    TO ls_ltap_create-squit.     "Confirmación auto

        IF ( ls_sel_data-gesme GT ls_sel_data-new_menge ).

          lv_new_gesme = ls_sel_data-gesme - ls_sel_data-new_menge.

          "Cantidad
          MOVE lv_new_gesme   TO ls_ltap_create-anfme.  "Cantidad
          MOVE ls_lqua-meins  TO ls_ltap_create-altme.  "UMA

          "Origen
          MOVE ls_lqua-lgtyp TO ls_ltap_create-vltyp. "TA origen
          MOVE ls_lqua-lgpla TO ls_ltap_create-vlpla. "Ubicación origen
          MOVE ls_lqua-lenum TO ls_ltap_create-vlenr. "UA procedencia
*          MOVE ls_lqua-lqnum TO ls_ltap_create-vlqnr. "cuanto

          "Destino
          MOVE lv_f_lgtyp TO ls_ltap_create-nltyp.  "TA destino
          MOVE lv_f_lgpla TO ls_ltap_create-nlpla.  "Ubicación destino

          APPEND ls_ltap_create TO lt_ltap_create.

        ELSEIF ( ls_sel_data-gesme LT  ls_sel_data-new_menge ).

          lv_new_gesme = ls_sel_data-new_menge - ls_sel_data-gesme.

          "Cantidad
          MOVE lv_new_gesme   TO ls_ltap_create-anfme.  "Cantidad
          MOVE ls_lqua-meins  TO ls_ltap_create-altme.  "UMA

          "Origen
          MOVE lv_f_lgtyp TO ls_ltap_create-vltyp. "TA origen
          MOVE lv_f_lgpla TO ls_ltap_create-vlpla. "Ubicación origen

          "Destino
          MOVE ls_lqua-lgtyp TO ls_ltap_create-nltyp.  "TA destino
          MOVE ls_lqua-lgpla TO ls_ltap_create-nlpla.  "Ubicación destino
          MOVE ls_lqua-lenum TO ls_ltap_create-nlenr.  "UA destion

          APPEND ls_ltap_create TO lt_ltap_create.

        ELSE.

          CONTINUE.

        ENDIF.


      ELSE. "No existe en LQUA

        "Obtenemos datos de cuanto modelo

        "Datos material
        MOVE ls_lqua_model-matnr TO ls_ltap_create-matnr.   "Material
        MOVE ls_lqua_model-charg TO ls_ltap_create-charg.   "Lote
        MOVE ls_lqua_model-bestq TO ls_ltap_create-bestq.   "Stock especial
        MOVE ls_lqua_model-sobkz TO ls_ltap_create-sobkz.   "Indicador stock especial
        MOVE ls_lqua_model-sonum TO ls_ltap_create-sonum.   "Número stock especial

        MOVE ls_lqua_model-werks TO ls_ltap_create-werks. "Centro
        MOVE ls_lqua_model-lgort TO ls_ltap_create-lgort. "Almacén
        MOVE ls_lqua_model-letyp TO ls_ltap_create-letyp. "Tipo de UA

        "Otros
        MOVE 'REPROCESO'  TO ls_ltap_create-zeugn.   "certificado
        MOVE abap_true    TO ls_ltap_create-squit.   "Confirmación auto

        "En este caso stock es cero y por tanto solo valido esto
        IF ( ls_sel_data-gesme LT ls_sel_data-new_menge ).  "Stock menor a cantidad nueva

          lv_new_gesme = ls_sel_data-new_menge - ls_sel_data-gesme.

          "Cantidad
          MOVE lv_new_gesme         TO ls_ltap_create-anfme.  "Cantidad
          MOVE ls_lqua_model-meins  TO ls_ltap_create-altme.  "UMA

          "Origen
          MOVE lv_f_lgtyp TO ls_ltap_create-vltyp. "TA origen
          MOVE lv_f_lgpla TO ls_ltap_create-vlpla. "Ubicación origen

          "Destino
          MOVE ls_lqua_model-lgtyp TO ls_ltap_create-nltyp.  "TA destino
          MOVE ls_lqua_model-lgpla TO ls_ltap_create-nlpla.  "Ubicación destino
*          MOVE ls_lqua_model-lenum TO ls_ltap_create-nlenr.  "UA destion --> Para el caso siempre son UAs nuevas

          APPEND ls_ltap_create TO lt_ltap_create.

        ELSE. "Stock cero

          CONTINUE.

        ENDIF.

      ENDIF.

    ENDLOOP.

** CREATE OT

    lo_wm_utils->create_to_multiple(
      EXPORTING
        i_bwlvs         = '999'            " Cl.movim.gestión almacenes
        i_t_ltap_create = lt_ltap_create   " Table Input for Transfer Order Item Creation
      IMPORTING
        e_return        = ls_return        " Parámetro de retorno
    ).

*    lo_wm_utils->create_to_multiple_4_lqnums(
*      EXPORTING
*        i_bwlvs     = '999'         " Cl.movim.gestión almacenes
**        i_updtask   = ''           " Actualizar en fondo
**        i_commit    = 'X'          " Guardar cambios
*        i_t_ot_data = lt_ot_data    " Tabla para estructura ZST_WM_UTILS_OT_CREATION
*      importing
*        e_return    = ls_return     " Parámetro de retorno
**      RECEIVING
**        r_tanum     =              " Número de orden de transporte
*    ).

    IF ( ls_return-type = 'E' ).
      MOVE ls_return-message TO lv_msg_v1.
      me->_launch_popup_msg( i_msg1 = lv_msg_v1 ).
      EXIT.
    ENDIF.

  ENDIF.

ENDMETHOD.
METHOD on_data_change.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <ft_data>  LIKE me->_outtab,
                 <fs_data>  LIKE LINE OF me->_outtab,
                 <fv_field> TYPE any.

  DATA: lv_msg_v1     TYPE string,
        lv_msg_v2     TYPE string,
        lv_msg_v3     TYPE string,
        lv_msg_v4     TYPE string.

  DATA: "lt_data     LIKE me->_outtab,
        ls_data     LIKE LINE OF me->_outtab,
        ls_modif    TYPE lvc_s_modi.

  DATA: lv_gesme_tot TYPE lqua_gesme,
        lv_gesme_str TYPE string,
        lv_menge_tot TYPE znew_menge,
        lv_menge_str TYPE string,
        lv_msg1      TYPE string,
        lv_msg2      TYPE string,
        lv_msg3      TYPE string,
        lv_msg4      TYPE string,
        lv_continue  TYPE abap_bool,
        lv_mlines    TYPE int1,
        lv_dlines    TYPE int1.

  DATA: lt_idx_rows   TYPE lvc_t_row,
        ls_idx_rows   TYPE lvc_s_row.

  DATA: lv_lines      TYPE i.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

**** SUPER

  super->on_data_change( er_data_changed = er_data_changed e_onf4 = e_onf4 e_onf4_before = e_onf4_before e_onf4_after = e_onf4_after e_ucomm = e_ucomm ).

**** GET OUTTAB

  ASSIGN me->_o_alv_grid->mr_table->* TO <ft_data>.

*** MODIFY TABLE

  IF ( <ft_data> IS ASSIGNED ).

    "obtengo lineas modificadas
    lv_mlines = lines( er_data_changed->mt_mod_cells ).

    "Recorremos modificaciones para actualizar valores.
    LOOP AT er_data_changed->mt_mod_cells INTO ls_modif.

      "Chequeamos que sea valor numérico
      CALL FUNCTION 'CATS_NUMERIC_INPUT_CHECK'
        EXPORTING
          input            = ls_modif-value
        exceptions
          no_numeric       = 1
          others           = 2.
      CHECK sy-subrc EQ 0.

      "Limpiamos variables
      CLEAR: lv_gesme_tot, lv_menge_tot.

      "Si solo hay un registro
      IF ( lv_mlines EQ 1 ).

        "Chequeo si es la primera línea
        IF ( ls_modif-row_id EQ 1 ). "Hay registro

          MOVE abap_true TO lv_continue.

          "Compruebo si todas las filas están vacías y calculo cantidad total en palets
          LOOP AT <ft_data> INTO ls_data.

            "Cantidad total
            ADD ls_data-gesme TO lv_gesme_tot.

          ENDLOOP.

          IF ( ls_modif-value GT lv_gesme_tot ).

            CLEAR: lv_msg_v1, lv_msg_v3, lv_msg_v4.
            MOVE text-116 TO lv_msg_v1.

            MOVE lv_gesme_tot TO lv_msg_v3.
            SHIFT lv_msg_v3 LEFT DELETING LEADING '0'.
            CONCATENATE 'CS:' lv_msg_v3 INTO lv_msg_v3 SEPARATED BY space.
            MOVE lv_menge_tot TO lv_msg_v4.
            SHIFT lv_msg_v4 LEFT DELETING LEADING '0'.
            CONCATENATE 'CR:' lv_msg_v4 INTO lv_msg_v4 SEPARATED BY space.
            me->_launch_popup_msg( i_msg1 = lv_msg_v1 i_msg3 = lv_msg_v3 i_msg4 = lv_msg_v4 ).
            EXIT.

          ENDIF.

          lv_lines = lines( <ft_data> ).

          LOOP AT <ft_data> ASSIGNING <fs_data>.

            CHECK lv_gesme_tot GT 0.
            CHECK sy-index NE ls_modif-row_id.

            "Chequeo última línea
            IF ( lv_lines GT 1 ). "No

              "Si cantidad total >= valor de modificación
              IF ( lv_gesme_tot GE ls_modif-value ).

                MOVE ls_modif-value TO <fs_data>-new_menge.
                lv_gesme_tot = lv_gesme_tot - <fs_data>-new_menge.
                lv_lines = lv_lines - 1.

              ELSE. "Cantidad total < valor de modificación

                MOVE lv_gesme_tot TO <fs_data>-new_menge.
                lv_gesme_tot = lv_gesme_tot - <fs_data>-new_menge.
                lv_lines = 0.

              ENDIF.

            ELSE. "Última linea

              "Si cantidad total >= valor de modificación
              IF ( lv_gesme_tot GT ls_modif-value ).

                MOVE ls_modif-value TO <fs_data>-new_menge.
                lv_gesme_tot = lv_gesme_tot - <fs_data>-new_menge.
                me->_add_row( ).

              ELSE. "Cantidad total < valor de modificación

                MOVE lv_gesme_tot TO <fs_data>-new_menge.
                lv_gesme_tot = lv_gesme_tot - <fs_data>-new_menge.
                lv_lines = lv_lines - 1.

              ENDIF.

            ENDIF.

          ENDLOOP.

        ELSE.

          "Leemos registro de tabla
          READ TABLE <ft_data> ASSIGNING <fs_data> INDEX ls_modif-row_id.
          IF ( <fs_data> IS ASSIGNED ).

            "Compruebo si nuevo valor es inicial
            IF ( ls_modif-value IS INITIAL ).

              IF ( <fs_data>-lenum EQ space AND <fs_data>-gesme EQ 0 ).

*                DELETE <ft_data> FROM <fs_data>.

              ELSE.

                "Modificamos valor
                ASSIGN COMPONENT ls_modif-fieldname OF STRUCTURE <fs_data> TO <fv_field>.
                IF ( <fv_field> IS ASSIGNED ).
                  MOVE ls_modif-value TO <fv_field>.
                ENDIF.

              ENDIF.

            ELSE. "No es inicial

              "Modificamos valor
              ASSIGN COMPONENT ls_modif-fieldname OF STRUCTURE <fs_data> TO <fv_field>.
              IF ( <fv_field> IS ASSIGNED ).
                MOVE ls_modif-value TO <fv_field>.
              ENDIF.

            ENDIF.

          ENDIF.

        ENDIF.

      ELSE.

        "Leemos registro de tabla
        READ TABLE <ft_data> ASSIGNING <fs_data> INDEX ls_modif-row_id.
        IF ( <fs_data> IS ASSIGNED ).

          "Compruebo si nuevo valor es inicial
          IF ( ls_modif-value IS INITIAL ).

            IF ( <fs_data>-lenum EQ space AND <fs_data>-gesme EQ 0 ).

*              DELETE <ft_data> INDEX sy-index.

            ELSE.

              "Modificamos valor
              ASSIGN COMPONENT ls_modif-fieldname OF STRUCTURE <fs_data> TO <fv_field>.
              IF ( <fv_field> IS ASSIGNED ).
                MOVE ls_modif-value TO <fv_field>.
              ENDIF.

            ENDIF.

          ELSE. "No es inicial

            "Modificamos valor
            ASSIGN COMPONENT ls_modif-fieldname OF STRUCTURE <fs_data> TO <fv_field>.
            IF ( <fv_field> IS ASSIGNED ).
              MOVE ls_modif-value TO <fv_field>.
            ENDIF.

          ENDIF.

        ENDIF.

      ENDIF.

    ENDLOOP.

  ENDIF.

  "Refrescamos ALV
  me->refresh_alv( ).

  "Volvemos a seleccionar las líneas
  me->_o_alv_grid->set_selected_rows( it_index_rows = lt_idx_rows ).

ENDMETHOD.
  METHOD on_toolbar.
*CALL METHOD SUPER->ON_TOOLBAR
*  EXPORTING
*    E_OBJECT =
*    .
  ENDMETHOD.
METHOD on_user_command.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

*** COMMANDS

  super->on_user_command( e_ucomm = e_ucomm ).

  CASE e_ucomm.

    WHEN 'REFR'.

      me->refresh_alv( ).

    WHEN 'CHRG'.

      me->_change_charg( ).

    WHEN 'VEAZ'.

      me->_launch_de( ).

    WHEN 'REPA1'.

      me->_repaletiza_1( ).

    WHEN 'SNUM'.

      me->_change_sonum( ).

    WHEN 'ADD'.

      me->_add_row( ).

    WHEN 'SUBS'.

      me->_del_row( ).

    WHEN 'SAVEP'.

      me->_repaletiza_2( ).

    WHEN 'PRINT'.

      me->_print_labels( ).

    WHEN OTHERS.

*      LEAVE TO SCREEN 0.

  ENDCASE.


ENDMETHOD.
METHOD s_get_set_data_4_lgnum.

**********************************************************************
* Parámetros locales
**********************************************************************

  CONSTANTS: lc_setnr TYPE setnamenew VALUE '0000ZWM_SET_REPALETIZADO'.

  DATA: lt_set_lines  TYPE TABLE OF rgsbv,
        lv_message    TYPE scx_t100key.

  DATA: lv_set_lname  TYPE SETSYN.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

**** GET DATA FROM SET

  CALL FUNCTION 'G_SET_FETCH'
    EXPORTING
      langu                     = 'S'
      no_authority_check        = abap_true
      setnr                     = lc_setnr
    TABLES
      set_lines_basic           = lt_set_lines
    exceptions
      no_authority              = 1
      set_is_broken             = 2
      set_not_found             = 3
      OTHERS                    = 4.

  IF ( sy-subrc = 0 ).

   "Datos O
   CLEAR: lv_set_lname.
   CONCATENATE i_lgnum 'O' INTO lv_set_lname.
   READ TABLE lt_set_lines INTO DATA(ls_set_line) WITH KEY from = lv_set_lname.
   IF ( sy-subrc EQ 0 ).
     MOVE ls_set_line-lname+3(3) TO e_lgtyp_o.
     MOVE ls_set_line-title TO e_lgpla_o.
   ELSE.
     EXIT.
   ENDIF.

   "Datos F
   CLEAR: lv_set_lname.
   CONCATENATE i_lgnum 'F' INTO lv_set_lname.
   READ TABLE lt_set_lines INTO ls_set_line WITH KEY from = lv_set_lname.
   IF ( sy-subrc EQ 0 ).
     MOVE ls_set_line-lname+3(3) TO e_lgtyp_f.
     MOVE ls_set_line-title TO e_lgpla_f.
   ELSE.
     CLEAR: e_lgtyp_o, e_lgpla_o.
     EXIT.
   ENDIF.

  ENDIF.

ENDMETHOD.
METHOD select_data.

**********************************************************************
* Parámetros locales
**********************************************************************

  FIELD-SYMBOLS: <fs_data> LIKE LINE OF me->_outtab.

  DATA: lt_r_mtart TYPE md_range_t_mtart.

  DATA: ls_data LIKE LINE OF me->_outtab.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

*** LQUA

*  SELECT *
*    FROM lqua
*    INTO CORRESPONDING FIELDS OF TABLE me->_outtab
*   WHERE lgnum EQ i_lgnum
*     AND lgtyp EQ i_lgtyp
*     AND lgpla EQ i_lgpla
*     AND matnr IN i_t_r_matnr
*     AND charg IN i_t_r_charg
*    ORDER BY lgnum lgtyp lgpla matnr charg bestq sobkz sonum.

  CLEAR: me->_outtab.

  SELECT *
    FROM lqua
    INTO CORRESPONDING FIELDS OF @ls_data
   WHERE lgnum EQ @i_lgnum
     AND lgtyp EQ @i_lgtyp
     AND lgpla EQ @i_lgpla
     AND matnr IN @i_t_r_matnr
     AND charg IN @i_t_r_charg
    ORDER BY lgnum, lgtyp, lgpla, matnr, charg, bestq, sobkz, sonum.

    SELECT SINGLE mtart
      FROM mara
      INTO @DATA(lv_mtart)
     WHERE matnr EQ @ls_data-matnr.

    IF ( lv_mtart IS NOT INITIAL ).
      APPEND ls_data TO me->_outtab.
    ENDIF.

  ENDSELECT.

*** CHECKS

  LOOP AT me->_outtab ASSIGNING <fs_data>.

** QPLOS AND BESTQ

    "Comprobamos tiene Q
    IF ( <fs_data>-bestq NE 'Q' ).

      CLEAR: <fs_data>-qplos.
      CONTINUE.

    ENDIF.

    "Compruebo lotes de inspección no tenga DE.
    IF ( <fs_data>-qplos IS NOT INITIAL ).

      SELECT COUNT(*) UP TO 1 ROWS
        FROM qals
       WHERE prueflos EQ <fs_data>-qplos
         AND stat34 EQ abap_false
         AND stat35 EQ abap_false.

      IF ( sy-subrc NE 0 ).

        CLEAR: <fs_data>-qplos.

      ENDIF.

    ELSE. "LI no recuperados

      SELECT prueflos
        FROM zswm_uas_accione
        INTO @DATA(lv_prueflos)
       WHERE lgnum EQ @<fs_data>-lgnum
         AND lenum EQ @<fs_data>-lenum.

        IF ( lv_prueflos IS NOT INITIAL ).

          SELECT SINGLE prueflos
            FROM qals
            INTO @<fs_data>-qplos
           WHERE prueflos EQ @lv_prueflos
             AND stat34 EQ @abap_false
             AND stat35 EQ @abap_false.

        ENDIF.

      ENDSELECT.

    ENDIF.

  ENDLOOP.

  MOVE-CORRESPONDING me->_outtab TO r_t_data.

ENDMETHOD.
