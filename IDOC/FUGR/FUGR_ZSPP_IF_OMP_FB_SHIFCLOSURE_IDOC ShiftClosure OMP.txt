FUNCTION zspp_if_omp_fb_shifclosure.
*"----------------------------------------------------------------------
*"*"Interfase local
*"  IMPORTING
*"     VALUE(INPUT_METHOD) LIKE  BDWFAP_PAR-INPUTMETHD
*"     VALUE(MASS_PROCESSING) LIKE  BDWFAP_PAR-MASS_PROC
*"  EXPORTING
*"     VALUE(WORKFLOW_RESULT) LIKE  BDWF_PARAM-RESULT
*"     VALUE(APPLICATION_VARIABLE) LIKE  BDWF_PARAM-APPL_VAR
*"     VALUE(IN_UPDATE_TASK) LIKE  BDWFAP_PAR-UPDATETASK
*"     VALUE(CALL_TRANSACTION_DONE) LIKE  BDWFAP_PAR-CALLTRANS
*"  TABLES
*"      IDOC_CONTRL STRUCTURE  EDIDC
*"      IDOC_DATA STRUCTURE  EDIDD
*"      IDOC_STATUS STRUCTURE  BDIDOCSTAT
*"      RETURN_VARIABLES STRUCTURE  BDWFRETVAR
*"      SERIALIZATION_INFO STRUCTURE  BDI_SER
*"  EXCEPTIONS
*"      WRONG_FUNCTION_CALLED
*"----------------------------------------------------------------------

  CONSTANTS: c_processed_idocs(15) VALUE 'Processed_IDOCs',
             c_appl_objects(12)    VALUE 'Appl_Objects'.

  DATA(lo_log) =  NEW zcl_seidor_guardar_log( ).
  lo_log->refresh( ).

  SELECT SINGLE waitsec INTO @DATA(lv_waitsec) FROM zsppt_wait WHERE funcion EQ 'ZSPP_IF_OMP_FB_SHIFCLOSURE'.

  TYPES: BEGIN OF ty_complete,
           vornr    TYPE vornr,
           complete TYPE xfeld,
         END OF ty_complete.
  DATA it_complete TYPE TABLE OF ty_complete.

  DATA: wa_head TYPE zspp_order_head,
        wa_oper TYPE zspp_order_oper,
        it_oper TYPE TABLE OF zspp_order_oper,
        wa_comp TYPE zspp_order_compo,
        it_comp TYPE TABLE OF zspp_order_compo.
  DATA num_heads TYPE i.
  CLEAR num_heads.

  DATA: lv_msj1 TYPE symsgv,
        lv_msj2 TYPE symsgv.

  LOOP AT idoc_data INTO DATA(wa_data_head) WHERE segnam EQ 'ZSPP_ORDER_HEAD'.
    wa_head = wa_data_head-sdata.
    wa_head-orden = |{ wa_head-orden ALPHA = IN }|.
    LOOP AT idoc_data INTO DATA(wa_data) WHERE segnam EQ 'ZSPP_ORDER_OPER' AND docnum EQ wa_data_head-docnum.
      wa_oper = wa_data-sdata.
      wa_oper-operacion = |{ wa_oper-operacion ALPHA = IN }|.
      APPEND wa_oper TO it_oper.
      APPEND INITIAL LINE TO it_complete ASSIGNING FIELD-SYMBOL(<fs_complete>).
      <fs_complete>-vornr = wa_oper-operacion.
      TRANSLATE wa_oper-status_oper TO UPPER CASE.
      IF wa_oper-status_oper = 'COMPLETE'.
        <fs_complete>-complete = 'X'.
      ENDIF.
    ENDLOOP.
    num_heads = num_heads + 1.
  ENDLOOP.

  IF num_heads > 1.
    workflow_result = '99999'.
    CLEAR idoc_status.
    idoc_status-msgty    = 'E'.
    idoc_status-msgid    = '00'.
    idoc_status-msgno    = '398'.
    idoc_status-msgv1    = 'Se ha enviado más de una cabecera'.
    idoc_status-msgv2    = ''.
    idoc_status-msgv3    = ''.
    idoc_status-msgv4    = ''.
    idoc_status-status   = '51'.
    idoc_status-repid    = sy-repid.
    APPEND idoc_status.
    CLEAR return_variables.
    return_variables-wf_param = 'Error_IDOCs'.
    LOOP AT idoc_contrl.
      idoc_status-docnum = idoc_contrl-docnum.
      APPEND idoc_status.
      return_variables-doc_number = idoc_contrl-docnum.
      APPEND return_variables.
    ENDLOOP.

    lo_log->guardar_mensaje(
    EXPORTING
      i_type       = 'E'
      i_id         = 'ZEDI_OMP'
      i_number     = '001'
      i_message_v1 = ''
*        i_message_v2 =
*        i_message_v3 =
*        i_message_v4 =
      ).

    DATA(salir) = 'X'. "RETURN.

  ELSEIF num_heads = 0.

    workflow_result = '99999'.
    CLEAR idoc_status.
    idoc_status-msgty    = 'E'.
    idoc_status-msgid    = '00'.
    idoc_status-msgno    = '398'.
    idoc_status-msgv1    = 'No se ha enviado ninguna cabecera'.
    idoc_status-msgv2    = ''.
    idoc_status-msgv3    = ''.
    idoc_status-msgv4    = ''.
    idoc_status-status   = '51'.
    idoc_status-repid    = sy-repid.
    APPEND idoc_status.
    CLEAR return_variables.
    return_variables-wf_param = 'Error_IDOCs'.
    LOOP AT idoc_contrl.
      idoc_status-docnum = idoc_contrl-docnum.
      APPEND idoc_status.
      return_variables-doc_number = idoc_contrl-docnum.
      APPEND return_variables.
    ENDLOOP.

    salir = 'X'. "RETURN.

    lo_log->guardar_mensaje(
    EXPORTING
      i_type       = 'E'
      i_id         = 'ZEDI_OMP'
      i_number     = '002'
      i_message_v1 = ''
*        i_message_v2 =
*        i_message_v3 =
*        i_message_v4 =
      ).


  ENDIF.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = wa_head-orden
    IMPORTING
      output = wa_head-orden.
  SELECT SINGLE aufnr INTO @DATA(lv_aufnr) FROM aufk WHERE aufnr EQ @wa_head-orden.
  IF sy-subrc <> 0.
    workflow_result = '99999'.
    CLEAR idoc_status.
    idoc_status-msgty    = 'E'.
    idoc_status-msgid    = 'ZEDI_OMP'.
    idoc_status-msgno    = '004'.
    idoc_status-msgv1    = 'La orden indicada no exista'.
    idoc_status-msgv2    = ''.
    idoc_status-msgv3    = ''.
    idoc_status-msgv4    = ''.
    idoc_status-status   = '51'.
    idoc_status-repid    = sy-repid.
    APPEND idoc_status.
    CLEAR return_variables.
    return_variables-wf_param = 'Error_IDOCs'.
    LOOP AT idoc_contrl.
      idoc_status-docnum = idoc_contrl-docnum.
      APPEND idoc_status.
      return_variables-doc_number = idoc_contrl-docnum.
      APPEND return_variables.
    ENDLOOP.

    salir = 'X'. "RETURN.

    lo_log->guardar_mensaje(
    EXPORTING
      i_type       = 'E'
      i_id         = 'ZEDI_OMP'
      i_number     = '004'
      i_message_v1 = ''
*        i_message_v2 =
*        i_message_v3 =
*        i_message_v4 =
      ).
  ENDIF.
  IF salir EQ space.
    "Ordenamos por operacion/fecha/hora y ajustamos
    SORT it_oper BY operacion fini_oper hini_oper ASCENDING.

    "Cálculo del RATIO OUT IN
    "Finalmente lo que vamos a hacer para pasar el ratiooutin en cada operación es:
    "Dividir el UMREZ de la operación antecesora al UMREZ de la operación predecesora, y tomar la última operación como UMREZ = “1”.
    TYPES: BEGIN OF ty_ratio,
             vornr TYPE vornr,
             ratio TYPE menge_d,
           END OF ty_ratio.
    DATA it_ratio TYPE TABLE OF ty_ratio.

    SELECT aufnr, vornr, umrez INTO TABLE @DATA(it_operation)
      FROM afvv AS t1 INNER JOIN afvc AS t2 ON t1~aufpl EQ t2~aufpl AND t1~aplzl EQ t2~aplzl
      INNER JOIN afko AS t3 ON t2~aufpl EQ t3~aufpl
      WHERE aufnr EQ @wa_head-orden
      AND steus NOT IN ( 'PP02', 'PP03' ).

    SORT it_operation BY vornr ASCENDING.
    LOOP AT it_operation INTO DATA(wa_operation).
      APPEND INITIAL LINE TO it_ratio ASSIGNING FIELD-SYMBOL(<ratio>).
      <ratio>-vornr = wa_operation-vornr.
      LOOP AT it_operation INTO DATA(wa_oper2) WHERE vornr > wa_operation-vornr.
        <ratio>-ratio = wa_operation-umrez / wa_oper2-umrez.
        EXIT.
      ENDLOOP.
      IF sy-subrc <> 0.
        <ratio>-ratio = wa_operation-umrez / 1.
      ENDIF.
    ENDLOOP.



    SELECT SINGLE rsnum INTO @DATA(lv_rsnum) FROM resb WHERE aufnr EQ @wa_head-orden.

    DATA: wa_propose TYPE bapi_pp_conf_prop,
          wa_return  TYPE bapiret1,
          it_tt      TYPE TABLE OF bapi_pp_timeticket,
          it_goods   TYPE TABLE OF bapi2017_gm_item_create,
          it_link    TYPE TABLE OF bapi_link_conf_goodsmov,
          it_return  TYPE TABLE OF bapi_coru_return.

    SELECT t1~*, t2~vornr INTO TABLE @DATA(it_afvv)
      FROM afvv AS t1 INNER JOIN afvc AS t2
           ON t1~aufpl EQ t2~aufpl AND t1~aplzl EQ t2~aplzl
           INNER JOIN afko AS t3 ON t2~aufpl EQ t3~aufpl
      WHERE aufnr EQ @wa_head-orden.

    DATA: lv_vbeln TYPE vbeln_va,
          lv_posnr TYPE posnr.
    CLEAR: lv_posnr, lv_vbeln.

    SELECT SINGLE * INTO @DATA(wa_aufk) FROM aufk WHERE aufnr EQ @wa_head-orden.
    lv_vbeln = wa_aufk-kdauf."sales_order.
    lv_posnr = wa_aufk-kdpos."sales_order_item.
*APC20250220 Comentamos esto porque ya no se usan estas variables
*    IF lv_vbeln IS INITIAL.
*      "Recuperar de la vista Z
*      SELECT SINGLE kdauf kdpos
*      INTO ( lv_vbeln, lv_posnr )
*      FROM zpp0002
*      WHERE aufnr EQ wa_head-orden.
*    ENDIF.
*  ENDIF.
    DATA contribution TYPE p DECIMALS 10.

    SELECT SINGLE * INTO @DATA(wa_afko) FROM afko WHERE aufnr EQ @wa_head-orden.

    LOOP AT it_oper ASSIGNING FIELD-SYMBOL(<fs_oper>).
      wa_propose = ' XXXXXX'.

      IF <fs_oper>-userfield03 IS NOT INITIAL.
        CONDENSE <fs_oper>-userfield03.
        REPLACE ALL OCCURRENCES OF '.' IN <fs_oper>-userfield03 WITH ','.
        CLEAR contribution.
        CALL FUNCTION 'MOVE_CHAR_TO_NUM'
          EXPORTING
            chr             = <fs_oper>-userfield03
          IMPORTING
            num             = contribution
          EXCEPTIONS
            convt_no_number = 1
            convt_overflow  = 2
            OTHERS          = 3.
        IF sy-subrc <> 0.
          CLEAR contribution.
        ENDIF.
      ENDIF.
***      contribution = ceil( contribution ). "APC20240515 Queremos el valor exácto que llega

      READ TABLE it_afvv WITH KEY vornr = <fs_oper>-operacion INTO DATA(wa_afvv).
      IF sy-subrc <> 0.

        workflow_result = '99999'.
        CLEAR idoc_status.
        idoc_status-msgty    = 'E'.
        idoc_status-msgid    = 'ZEDI_OMP'.
        idoc_status-msgno    = '004'.
        idoc_status-msgv1    = 'La Operación' && <fs_oper>-operacion && 'no exista'.
        idoc_status-msgv2    = 'en la orden'.
        idoc_status-msgv3    = wa_head-orden.
        idoc_status-msgv4    = ''.
        idoc_status-status   = '51'.
        idoc_status-repid    = sy-repid.
        APPEND idoc_status.
        CLEAR return_variables.
        return_variables-wf_param = 'Error_IDOCs'.
        LOOP AT idoc_contrl.
          idoc_status-docnum = idoc_contrl-docnum.
          APPEND idoc_status.
          return_variables-doc_number = idoc_contrl-docnum.
          APPEND return_variables.
        ENDLOOP.

        CONTINUE.

      ENDIF.

      CLEAR: it_tt, it_goods, it_link, it_return.
      REFRESH: it_tt, it_goods, it_link, it_return.

      APPEND INITIAL LINE TO it_tt ASSIGNING FIELD-SYMBOL(<fs>).
      <fs>-operation = <fs_oper>-operacion.
*      <fs>-conf_quan_unit = <fs_oper>-cant_base_op.
      <fs>-orderid = wa_head-orden.
      DATA lv_buena TYPE menge_d.
      DATA lv_scrap TYPE menge_d.

      "Sólo dividimos por UMREZ cuando sea una operación con RATIOOUTIN, para ello replicamos el cálculo
      "que realizamos en el ORDERS
      READ TABLE it_ratio WITH KEY vornr = <fs_oper>-operacion ASSIGNING <ratio>.
      IF sy-subrc = 0.
        lv_buena = ceil( <fs_oper>-cant_base_op / <ratio>-ratio ).

*        lv_scrap = ceil( <fs_oper>-userfield01 / <ratio>-ratio ). "Comentado JVM 24/07/2024
        lv_scrap = ceil( <fs_oper>-userfield01  ) + ceil( <fs_oper>-userfield04 / <ratio>-ratio ). "ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
      ELSE.
        lv_buena = ceil( <fs_oper>-cant_base_op / wa_afvv-t1-umrez ).

*        lv_scrap = ceil( <fs_oper>-userfield01 / wa_afvv-t1-umrez )."Comentado JVM 24/07/2024
        lv_scrap = ceil( <fs_oper>-userfield01 ) + ceil( <fs_oper>-userfield04 / wa_afvv-t1-umrez ). "ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
      ENDIF.
      <fs>-yield = lv_buena.
      <fs>-scrap = lv_scrap.

      WAIT UP TO lv_waitsec SECONDS.

      CALL FUNCTION 'BAPI_PRODORDCONF_GET_TT_PROP'
        EXPORTING
          propose            = wa_propose
        IMPORTING
          return             = wa_return
        TABLES
          timetickets        = it_tt
          goodsmovements     = it_goods
          link_conf_goodsmov = it_link
          detail_return      = it_return.

      LOOP AT it_return INTO DATA(wa_return_tt).
        IF wa_return_tt-type IS NOT INITIAL.
          lo_log->guardar_mensaje(
          EXPORTING
            i_type       = wa_return_tt-type
            i_id         = wa_return_tt-id
            i_number     = wa_return_tt-number
            i_message_v1 = wa_return_tt-message_v1
            i_message_v2 = wa_return_tt-message_v2
            i_message_v3 = wa_return_tt-message_v3
            i_message_v4 = wa_return_tt-message_v4
            ).
          IF wa_return_tt-type EQ 'A' OR wa_return_tt-type EQ 'E' OR wa_return_tt-type EQ 'X'.
            DATA(lv_error_get_notif) = 'X'.
          ENDIF.
        ENDIF.
      ENDLOOP.

      IF NOT (  wa_afko-prodnet IS NOT INITIAL AND wa_afko-maufnr IS NOT INITIAL ). "ADD 01/10/2024 JVM(SEI)-No Eliminar 101 en OFs grafo inferior SHIFTCLOSURE
        DELETE it_goods WHERE move_type EQ '101'.
      ENDIF."ADD 01/10/2024 JVM(SEI)-No Eliminar 101 en OFs grafo inferior SHIFTCLOSURE

      IF lv_error_get_notif = 'X'.
        WRITE wa_head-orden TO lv_msj1 LEFT-JUSTIFIED NO-ZERO.
        WRITE <fs_oper>-operacion TO lv_msj2 LEFT-JUSTIFIED NO-ZERO.
        CONDENSE: lv_msj1, lv_msj2.
        lo_log->guardar_mensaje(
        EXPORTING
          i_type       = 'E'
          i_id         = 'ZEDI_OMP'
          i_number     = '003'
          i_message_v1 = lv_msj1
          i_message_v2 = lv_msj2
*          i_message_v3 =
*          i_message_v4 =
          ).
        CONTINUE.
      ENDIF.
      CLEAR lv_error_get_notif.

      "actividad 1 - setup
      "actividad 2 - ejecucion
      "actividad 3 - desmontaje = 0
      "actividad 4 - QuantityOut convertida a M2 Costes indirectos
      "actividad 5 - QuantityOut convertida a M2 Costes indirectos

      "13/05/2022 - No vamos a eliminar los consumos propuestos
****      CLEAR: it_goods[], it_goods, it_link, it_link[].

      "Recuperamos aquellos componentes asignados a la operación que no tienen
      "toma retroactiva y no son papeles
      SELECT t1~* INTO TABLE @DATA(it_componentes)
        FROM resb AS t1 INNER JOIN mara AS t2 ON t1~matnr EQ t2~matnr
        WHERE aufnr EQ @wa_head-orden
        AND rgekz EQ @space
        AND mtart <> 'ZPAP'
        AND vornr EQ @<fs_oper>-operacion
        AND xloek EQ @space
        AND dumps EQ @space "Excluir DUMMYS
        AND postp EQ 'L'.

      ""INI JVM - GAPPP08 - Grupo Hinojosa tiene la necesidad de consumir un lote en específico en algunas órdenes
      "de fabricación. Suele darse el caso cuando se consume semiterminado, ya que una
      "determinada plancha debe consumirse en la OF de producto terminado correspondiente para
      "ese producto. Así, se garantiza la trazabilidad SEMI – PT.
      SELECT t1~matnr, t1~aufnr, t1~rsnum, t1~rspos, t1~rsart, t1~charg, vornr, ( bdmng - enmng ) AS cantidad, mtart
        FROM resb AS t1 INNER JOIN mara AS t2 ON t1~matnr EQ t2~matnr
        INTO TABLE @DATA(it_resb_lotes)
        WHERE t1~aufnr EQ @wa_head-orden
        AND vornr EQ @<fs_oper>-operacion
        AND t2~mtart IN ( 'ZPSE', 'ZPTO' )
        AND t1~xloek EQ @space
        AND t1~charg <> @space.
      "FJVM - GAPPP08

      "JVM - GAPPP002
*      esta funcionalidad de determinación de lotes en consumo en base a fifo-uas deberá aplicar para materiales
*      (en principio las tintas¿?¿) que gestionen lote. se excluirán los materiales que contengan el set
*      zmm_pt_carton, el cual está en la clase zcl_mm_material_zpt con el método estático
*      zintf_mm_material_master~s_get_mtart_compatibles.
*
*      la solución técnica pasa por recoger de la actual función zswm_deter_ubi_salidas_wt la lógica de determinación
*      de ua (sort por fecha sobre tabla interna lt_lqua) para movimiento wm 961 y trasladarla a la función
*      zspp_if_omp_fb_shifclosure de manera que la bapi de consumos posterior se alimente con el/los lotes determinados.
*      además, estas mismas uas deberán determinarse en la actual función zswm_deter_ubi_salidas_wt, respetando la lógica.

      "Obtenemos los MTARTS del set de datos
      TRY.
          DATA(lt_r_mtart) = zcl_mm_material_zpt=>zintf_mm_material_master~s_get_mtart_compatibles( i_setname = zcl_mm_material_zpt=>_c_setname_value ).
        CATCH zcx_mm_exception.
      ENDTRY.
      SELECT DISTINCT t1~* INTO TABLE @DATA(lt_lotes_fifo)
          FROM resb AS t1 INNER JOIN marc AS t2 ON t1~matnr EQ t2~matnr
          WHERE aufnr EQ @wa_head-orden
*          AND rgekz EQ @space
          AND vornr EQ @<fs_oper>-operacion
          AND xloek EQ @space.

      SORT lt_lotes_fifo BY rsnum rspos ASCENDING.
      DELETE ADJACENT DUPLICATES FROM lt_lotes_fifo COMPARING rsnum rspos.

      "Descartamos los lotes que no sean de los tipos de material que toca
      LOOP AT lt_lotes_fifo ASSIGNING FIELD-SYMBOL(<lf>).
        DATA(lv_indice_fifo) = sy-tabix.
        SELECT SINGLE mtart INTO @DATA(lv_mtart_fifo) FROM mara WHERE matnr = @<lf>-matnr.
        IF lv_mtart_fifo IN lt_r_mtart AND lt_r_mtart[] IS NOT INITIAL.
          DELETE lt_lotes_fifo INDEX lv_indice_fifo.
        ENDIF.
      ENDLOOP.

      DATA(lv_ubicacion_asp) = zspp_utils=>get_asp_puesto(
                                   i_arbpl = zspp_utils=>get_puesto_trabajo(
                                                 i_aufnr =  wa_head-orden
                                                 i_vornr = <fs_oper>-operacion
*                                           i_ktsch = ''
                                             )
                                   i_werks = zspp_utils=>get_centro_of( i_aufnr = wa_head-orden )
                               ).

      IF lt_lotes_fifo[] IS NOT INITIAL.


*        LOOP AT lt_lotes_fifo INTO DATA(wa_lotes_fifo).
*          DATA(lv_lgnum) = zspp_utils=>get_lgnum_of_werks(
*                       i_werks = wa_lotes_fifo-werks
*                       i_lgort = wa_lotes_fifo-lgort
*                   ).
*
*          SELECT *
*              APPENDING TABLE @DATA(tt_lqua)
*              FROM lqua
*              WHERE lgnum EQ @lv_lgnum
*                AND lgtyp EQ @wa_lotes_fifo-lgtyp
*                AND lgpla EQ @lv_ubicacion_asp
*                AND werks EQ @wa_lotes_fifo-werks
*                AND lgort EQ @wa_lotes_fifo-lgort
*                AND matnr EQ @wa_lotes_fifo-matnr
*                AND sobkz EQ @wa_lotes_fifo-sobkz
*                AND verme >  0.
*
*          CLEAR lv_lgnum.
*
*            SORT tt_lqua BY wdatu lqnum lgpla.
*        ENDLOOP.



      ENDIF.
      "FJVM

      READ TABLE it_afvv WITH KEY vornr = <fs_oper>-operacion INTO wa_afvv.
      IF sy-subrc = 0.
        READ TABLE it_tt WITH KEY operation = <fs_oper>-operacion ASSIGNING FIELD-SYMBOL(<tt>).

*      Los conf_activity* son campos calculados en base a regla de 3 obteniendo su cantidad base en la bapi BAPI_PRODORDCONF_GET_TT_PROP .
*      Con los conf_Activitry de esta bapi calculamos la cantidad del conf activity* de la siguiente forma:
*      Confactivity = (confactivity de la tickets de la BAPI_PRODORDCONF_GET_TT_PROP) X  (yield + scrap del idoc) /  (
*      yield+scrap de la tickets de la BAPI_PRODORDCONF_GET_TT_PROP )
*      •  Y en cuanto al scrap; NO permite decimales con la unidad de medida UN, habrá que redondear hacia arriba y pasárselo a la tickets de la CREATE

*        DATA lv_buena TYPE menge_d.
*        DATA lv_scrap TYPE menge_d.
        "Sólo dividimos por UMREZ cuando sea una operación con RATIOOUTIN, para ello replicamos el cálculo
        "que realizamos en el ORDERS
        READ TABLE it_ratio WITH KEY vornr = <fs_oper>-operacion ASSIGNING <ratio>.
        IF sy-subrc = 0.
          lv_buena = ceil( <fs_oper>-cant_base_op / <ratio>-ratio ).

*          lv_scrap = ceil( <fs_oper>-userfield01 / <ratio>-ratio )."Comentado JVM 24/07/2024
          lv_scrap = ceil( <fs_oper>-userfield01 ) + ceil( <fs_oper>-userfield04 / <ratio>-ratio )."ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
        ELSE.
          lv_buena = ceil( <fs_oper>-cant_base_op / wa_afvv-t1-umrez ).

*          lv_scrap = ceil( <fs_oper>-userfield01 / wa_afvv-t1-umrez )."Comentado JVM 24/07/2024
          lv_scrap = ceil( <fs_oper>-userfield01 ) + ceil( <fs_oper>-userfield04 / wa_afvv-t1-umrez )."ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
        ENDIF.

*        <tt>-conf_activity1 = ( <tt>-conf_activity1 * ( <tt>-scrap + <tt>-yield ) ) / ( <tt>-scrap + <tt>-yield ).
*        <tt>-conf_activity1 = ( <tt>-conf_activity1 * ( lv_buena + lv_scrap ) ) / ( <tt>-scrap + <tt>-yield ).
*        <tt>-conf_activity2 = ( <tt>-conf_activity2 * ( <tt>-scrap + <tt>-yield ) ) / ( <tt>-scrap + <tt>-yield ).
*        <tt>-conf_activity2 = ( <tt>-conf_activity2 * ( lv_buena + lv_scrap ) ) / ( <tt>-scrap + <tt>-yield ).
*        <tt>-conf_activity3 = ( <tt>-conf_activity3 * ( <tt>-scrap + <tt>-yield ) ) / ( <tt>-scrap + <tt>-yield ).
*        <tt>-conf_activity3 = ( <tt>-conf_activity3 * ( lv_buena + lv_scrap ) ) / ( <tt>-scrap + <tt>-yield ).

        IF <tt>-conf_acti_unit1 IS NOT INITIAL.
          <tt>-conf_activity1 = <fs_oper>-tiempo_prep + <fs_oper>-tiempo_ejec + <fs_oper>-tiempo_desmont.
          <tt>-conf_acti_unit1 = 'S'.
        ENDIF.

        IF <tt>-conf_acti_unit2 IS NOT INITIAL.
          <tt>-conf_activity2 = <fs_oper>-tiempo_prep + <fs_oper>-tiempo_ejec + <fs_oper>-tiempo_desmont.
          <tt>-conf_acti_unit2 = 'S'.
        ENDIF.

        IF <tt>-conf_acti_unit3 IS NOT INITIAL.
          <tt>-conf_activity3 = <fs_oper>-tiempo_prep + <fs_oper>-tiempo_ejec + <fs_oper>-tiempo_desmont.
          <tt>-conf_acti_unit3 = 'S'.
        ENDIF.

        IF contribution IS NOT INITIAL.
          <tt>-conf_activity1 =  ceil( <tt>-conf_activity1 * contribution ).
          <tt>-conf_activity2 =  ceil( <tt>-conf_activity2 * contribution ).
          <tt>-conf_activity3 =  ceil( <tt>-conf_activity3 * contribution ).
        ENDIF.

        "Convertir la cantidad a M2
        TRY.
            "Dividir por AFVV-UMREZ la cantidad que venga en quantity y waste.
*            <tt>-conf_activity4 = <fs_oper>-cant_base_op / wa_afvv-t1-umrez.
            IF <tt>-conf_acti_unit4 IS NOT INITIAL.
              <tt>-conf_activity4 = <tt>-conf_activity4 * ( ( lv_buena + lv_scrap )  / ( <tt>-scrap + <tt>-yield ) ).
              <tt>-conf_acti_unit4 = 'M2'.
            ENDIF.
***          DATA: lv_menge_in  TYPE menge_d,
***                lv_menge_out TYPE menge_d,
***                lv_matnr     TYPE matnr.
***
***          CLEAR: lv_menge_in, lv_menge_out, lv_matnr.
***
***          lv_matnr = wa_afko-plnbez.
***          lv_menge_in = <tt>-conf_activity4.
***
***          CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
***            EXPORTING
***              i_matnr              = lv_matnr
***              i_in_me              = 'UN'
***              i_out_me             = 'M2'
***              i_menge              = lv_menge_in
***            IMPORTING
***              e_menge              = lv_menge_out
***            EXCEPTIONS
***              error_in_application = 1
***              error                = 2
***              OTHERS               = 3.
***          IF sy-subrc = 0.
**** Implement suitable error handling here
***            <tt>-conf_activity4 = lv_menge_out.
***          ELSE.
***            "LOG NO HAY CONVERSIÓN A M2
***          ENDIF.
          CATCH cx_root.
        ENDTRY.

        TRY.
*            <tt>-conf_activity5 = <fs_oper>-cant_base_op / wa_afvv-t1-umrez.
            IF <tt>-conf_acti_unit5 IS NOT INITIAL.
              <tt>-conf_activity5 = <tt>-conf_activity5 * ( ( lv_buena + lv_scrap )  / ( <tt>-scrap + <tt>-yield ) ).
              <tt>-conf_acti_unit5 = 'M2'.
            ENDIF.
          CATCH cx_root.
        ENDTRY.
        TRY.
***          CLEAR: lv_menge_in, lv_menge_out, lv_matnr.
***
***          lv_matnr = wa_afko-plnbez.
***          lv_menge_in = <tt>-conf_activity5.
***
***          CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
***            EXPORTING
***              i_matnr              = lv_matnr
***              i_in_me              = 'UN'
***              i_out_me             = 'M2'
***              i_menge              = lv_menge_in
***            IMPORTING
***              e_menge              = lv_menge_out
***            EXCEPTIONS
***              error_in_application = 1
***              error                = 2
***              OTHERS               = 3.
***          IF sy-subrc = 0.
**** Implement suitable error handling here
***            <tt>-conf_activity5 = lv_menge_out.
***          ELSE.
***            "LOG NO HAY CONVERSIÓN A M2
***          ENDIF.




          CATCH cx_root.
        ENDTRY.

        READ TABLE it_ratio WITH KEY vornr = <fs_oper>-operacion ASSIGNING <ratio>.
        IF sy-subrc = 0.
          <tt>-yield = ceil( <fs_oper>-cant_base_op / <ratio>-ratio ).

*          <tt>-scrap = ceil( <fs_oper>-userfield01 / <ratio>-ratio )."Comentado JVM 24/07/2024
          <tt>-scrap = ceil( <fs_oper>-userfield01 ) + ceil( <fs_oper>-userfield04 / <ratio>-ratio )."ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
        ELSE.
          <tt>-yield = ceil( <fs_oper>-cant_base_op / wa_afvv-t1-umrez ).

*          <tt>-scrap = ceil( <fs_oper>-userfield01 / wa_afvv-t1-umrez )."Comentado JVM 24/07/2024
          <tt>-scrap = ceil( <fs_oper>-userfield01 ) + ceil( <fs_oper>-userfield04 / wa_afvv-t1-umrez )."ADD JVM 24/07/2024 se enviarán 2 waste desde OMP WASTEIN y WASTEOUT, solo el IN debe dividirse
        ENDIF.

        "Reason -> Motivo de rechazo -> cuando haya waste
        DATA(lv_longitud) = strlen( <fs_oper>-userfield02 ).
        IF lv_longitud <= 0 OR lv_longitud > 4.
          <tt>-dev_reason = ''.
        ELSEIF lv_longitud EQ 1.
          <tt>-dev_reason = '000' && <fs_oper>-userfield02. "Lo que hay que tener en cuenta es que en SAP son 4 char 00** y en Omp 2.  Mail 29/03/2022
        ELSEIF lv_longitud EQ 2.
          <tt>-dev_reason = '00' && <fs_oper>-userfield02. "Lo que hay que tener en cuenta es que en SAP son 4 char 00** y en Omp 2.  Mail 29/03/2022
        ELSEIF lv_longitud EQ 3.
          <tt>-dev_reason = '0' && <fs_oper>-userfield02. "Lo que hay que tener en cuenta es que en SAP son 4 char 00** y en Omp 2.  Mail 29/03/2022
        ELSEIF lv_longitud EQ 4.
          <tt>-dev_reason = <fs_oper>-userfield02. "Lo que hay que tener en cuenta es que en SAP son 4 char 00** y en Omp 2.  Mail 29/03/2022
        ENDIF.
        <tt>-exec_start_date = <fs_oper>-fini_oper.
        <tt>-exec_start_time = <fs_oper>-hini_oper.
        CONVERT DATE <tt>-exec_start_date TIME <tt>-exec_start_time INTO TIME STAMP DATA(lv_start) TIME ZONE sy-zonlo.
        CONVERT DATE sy-datum TIME sy-uzeit INTO TIME STAMP DATA(lv_actual) TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-exec_start_time DATE <tt>-exec_start_date.
        ENDIF.
        <tt>-exec_fin_date = <fs_oper>-ffin_oper.
        <tt>-exec_fin_time = <fs_oper>-hfin_oper.

        CONVERT DATE <tt>-exec_fin_date TIME <tt>-exec_fin_time INTO TIME STAMP lv_start TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-exec_fin_time DATE <tt>-exec_fin_date.
        ENDIF.

        <tt>-setup_fin_date = <fs_oper>-fini_ejec.
        <tt>-setup_fin_time = <fs_oper>-hini_ejec.
        CONVERT DATE <tt>-setup_fin_date TIME <tt>-setup_fin_time INTO TIME STAMP lv_start TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-setup_fin_time DATE <tt>-setup_fin_date.
        ENDIF.

        <tt>-proc_start_date = <fs_oper>-fini_ejec.
        <tt>-proc_start_time = <fs_oper>-hini_ejec.
        CONVERT DATE <tt>-proc_start_date TIME <tt>-proc_start_time INTO TIME STAMP lv_start TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-proc_start_time DATE <tt>-proc_start_date.
        ENDIF.

        <tt>-teardown_start_date = <tt>-proc_fin_date = <fs_oper>-fini_desmont.
        <tt>-teardown_start_time = <tt>-proc_fin_time = <fs_oper>-hini_desmont.
        CONVERT DATE <tt>-teardown_start_date TIME <tt>-teardown_start_time INTO TIME STAMP lv_start TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-teardown_start_time DATE <tt>-teardown_start_date.
        ENDIF.

        CONVERT DATE <tt>-proc_fin_date TIME <tt>-proc_fin_time INTO TIME STAMP lv_start TIME ZONE sy-zonlo.
        IF lv_start > lv_actual.
          lv_start = lv_actual.
          CONVERT TIME STAMP lv_start TIME ZONE sy-zonlo INTO TIME <tt>-proc_fin_time DATE <tt>-proc_fin_date.
        ENDIF.


        <tt>-postg_date = <fs_oper>-fini_oper.
        IF <tt>-postg_date > sy-datum.
          <tt>-postg_date = sy-datum.
        ENDIF.

        <tt>-work_cntr = <fs_oper>-puesto_trab.

        READ TABLE it_complete TRANSPORTING NO FIELDS WITH KEY vornr = <fs_oper>-operacion complete = 'X'.
        IF sy-subrc = 0.
          <tt>-fin_conf = abap_true.
        ENDIF.

        LOOP AT it_componentes INTO DATA(wa_compo).
          APPEND INITIAL LINE TO it_goods ASSIGNING FIELD-SYMBOL(<good>).
          <good>-material = wa_compo-matnr.
*          <good>-quantity = <fs_oper>-cant_base_op * wa_compo-bdmng / wa_afko-gamng."REPLACE
          <good>-entry_qnt = <fs_oper>-cant_base_op * wa_compo-bdmng / wa_afko-gamng.
          IF wa_compo-meins EQ 'UN'.
*            <good>-quantity = ceil( <good>-quantity )."REPLACE
            <good>-entry_qnt = ceil( <good>-entry_qnt ).
          ENDIF.
          <good>-plant = wa_compo-werks.

          <good>-stge_loc = wa_compo-lgort.

          <good>-batch = wa_compo-charg.
*          <good>-mvt_ind = 'F'.
          <good>-move_type = '261'.
          <good>-orderid = wa_head-orden.
          <good>-res_item = wa_compo-rspos.
          <good>-reserv_no = wa_compo-rsnum.
          <good>-entry_uom = wa_compo-meins.


        ENDLOOP.

        IF it_goods[] IS NOT INITIAL.
          SELECT t1~matnr, mtart, clabs, t2~charg, t4~lwedt, t2~werks, lgort
            INTO TABLE @DATA(it_mtarts)
            FROM mara AS t1 INNER JOIN mchb AS t2 ON t1~matnr EQ t2~matnr
            INNER JOIN mcha AS t3 ON t2~matnr EQ t3~matnr AND t2~charg EQ t3~charg AND t2~werks EQ t3~werks
            INNER JOIN mch1 AS t4 ON t3~matnr = t4~matnr AND t3~charg = t4~charg
            FOR ALL ENTRIES IN @it_goods
              WHERE t1~matnr EQ @it_goods-material
                AND t2~werks EQ @it_goods-plant
*                AND lgort EQ @it_goods-stge_loc
                AND mtart IN ('ZPSE', 'ZPTO').
*          IF sy-subrc <> 0.
          SELECT t1~matnr, mtart, t2~kalab AS clabs, t2~charg, t4~lwedt, t2~werks, lgort
            APPENDING TABLE @it_mtarts
                FROM mara AS t1
                INNER JOIN mska AS t2 ON t1~matnr EQ t2~matnr
                INNER JOIN mcha AS t3 ON t1~matnr EQ t3~matnr AND t2~charg EQ t3~charg AND t2~werks EQ t3~werks
                INNER JOIN mch1 AS t4 ON t3~matnr = t4~matnr AND t3~charg = t4~charg
                FOR ALL ENTRIES IN @it_goods
                WHERE t1~matnr EQ @it_goods-material
                AND t3~werks EQ @it_goods-plant
*                  AND vbeln EQ @lv_vbeln
*                  AND posnr EQ @lv_posnr
*                AND lgort EQ @it_goods-stge_loc
                AND mtart IN ('ZPSE', 'ZPTO').
*          ENDIF.

*         IF sy-subrc = 0.

          SORT it_mtarts BY matnr lwedt ASCENDING.
          DELETE it_mtarts WHERE clabs <= 0.
          DATA it_repeticiones TYPE TABLE OF bapi2017_gm_item_create.
          DATA wa_auxiliar TYPE bapi2017_gm_item_create.
          CLEAR it_repeticiones[].

          LOOP AT it_goods ASSIGNING <good>.
            DATA(lv_cant_necesaria) = <good>-entry_qnt.
            CHECK lv_cant_necesaria > 0.
            "GAPPP08 Consumir lotes indicados en OF
            READ TABLE it_resb_lotes WITH KEY rsnum = <good>-reserv_no rspos = <good>-res_item matnr = <good>-material charg = <good>-batch TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              CONTINUE.
            ENDIF.
            "GAPPP08 Consumir lotes indicados en OF

            "ADD JVM GAPPP02 - 17/01/2024 - Añadir consumos de los lotes FIFO
            READ TABLE lt_lotes_fifo INTO DATA(wa_lotes_fifo) WITH KEY rsnum = <good>-reserv_no
                                                                     rspos = <good>-res_item.
            IF sy-subrc = 0.

              DATA(lv_lgnum) = zspp_utils=>get_lgnum_of_werks(
                           i_werks = wa_lotes_fifo-werks
                           i_lgort = wa_lotes_fifo-lgort ).

              SELECT *
                  INTO TABLE @DATA(tt_lqua)
                  FROM lqua
                  WHERE lgnum EQ @lv_lgnum
                    AND lgtyp EQ @wa_lotes_fifo-lgtyp
                    AND lgpla EQ @lv_ubicacion_asp
                    AND werks EQ @wa_lotes_fifo-werks
                    AND lgort EQ @wa_lotes_fifo-lgort
                    AND matnr EQ @wa_lotes_fifo-matnr
                    AND sobkz EQ @wa_lotes_fifo-sobkz
                    AND verme >  0.

              "Debemos chequear adicionalmente si hay NTs abiertas para restarlas del stock disponible
              SELECT t2~lgnum, t2~tbnum, t2~tbpos, t2~matnr, t2~charg, t2~menge, t2~meins, t2~menga, t2~altme, t2~werks, t2~lgort
                INTO TABLE @DATA(it_nts)
                FROM ltbk AS t1 INNER JOIN ltbp AS t2 ON t1~lgnum = t2~lgnum AND t1~tbnum = t2~tbnum
                WHERE matnr = @wa_lotes_fifo-matnr
*                AND charg = @wa_lotes_fifo-charg
                AND lgort = @wa_lotes_fifo-lgort
                AND werks = @wa_lotes_fifo-werks
                AND bwlvs = '961'
                AND t2~lgnum = @lv_lgnum
                AND t2~elikz = @space.

              LOOP AT tt_lqua ASSIGNING FIELD-SYMBOL(<aj>).
                LOOP AT it_nts ASSIGNING FIELD-SYMBOL(<nt>) WHERE matnr = <aj>-matnr AND charg = <aj>-charg AND werks = <aj>-werks AND lgort = <aj>-lgort AND lgnum = <aj>-lgnum.
                  <aj>-verme = <aj>-verme - <nt>-menge.
                ENDLOOP.
              ENDLOOP.
              DELETE tt_lqua WHERE verme <= 0.

              CLEAR lv_lgnum.

              SORT tt_lqua BY wdatu.

              LOOP AT tt_lqua ASSIGNING FIELD-SYMBOL(<wa_lqua>) WHERE matnr = <good>-material AND verme > 0.
                IF <wa_lqua>-verme >= lv_cant_necesaria.
                  <good>-batch = <wa_lqua>-charg.
                  <good>-plant = <wa_lqua>-werks.
                  <good>-stge_loc = <wa_lqua>-lgort.
                  <good>-entry_qnt = lv_cant_necesaria.
                  <good>-stge_type = <wa_lqua>-lgtyp.
                  <good>-stge_bin = <wa_lqua>-lgpla.
                  <good>-unload_pt = <wa_lqua>-lenum.
                  <wa_lqua>-verme = <wa_lqua>-verme - lv_cant_necesaria.
                  lv_cant_necesaria = 0.
                  EXIT.
                ELSE.
                  <good>-batch = <wa_lqua>-charg.
                  <good>-entry_qnt = <wa_lqua>-verme. "<good>-entry_qnt -
                  <good>-plant = <wa_lqua>-werks.
                  <good>-stge_loc = <wa_lqua>-lgort.
                  lv_cant_necesaria = lv_cant_necesaria - <wa_lqua>-verme.
                  <wa_lqua>-verme = 0.
                  <good>-stge_type = <wa_lqua>-lgtyp.
                  <good>-stge_bin = <wa_lqua>-lgpla.
                  wa_auxiliar = <good>.
                  wa_auxiliar-unload_pt = <wa_lqua>-lenum.
                  APPEND wa_auxiliar TO it_repeticiones.
                  DATA(lv_indice_rep) = sy-tabix.
                ENDIF.
              ENDLOOP.
              IF lv_cant_necesaria > 0 AND sy-subrc = 0.
                "Si todavía quedase cantidad por consumir deberá ir a la COGI
                wa_auxiliar = <good>.
                wa_auxiliar-unload_pt = 'LLEVAR_A_COGI'.
                wa_auxiliar-entry_qnt = lv_cant_necesaria.
                CLEAR: wa_auxiliar-batch,
                       wa_auxiliar-stge_type,
                       wa_auxiliar-stge_bin.
                TRY.
                    DELETE it_repeticiones INDEX lv_indice_rep.
                  CATCH cx_root.
                ENDTRY.
                APPEND wa_auxiliar TO it_repeticiones.
              ENDIF.

            ELSE."JVM GAPPP002

              LOOP AT it_mtarts ASSIGNING FIELD-SYMBOL(<wa_mtarts>) WHERE matnr = <good>-material AND clabs > 0.
                IF <wa_mtarts>-clabs >= lv_cant_necesaria.
                  <good>-batch = <wa_mtarts>-charg.
                  <good>-plant = <wa_mtarts>-werks.
                  <good>-stge_loc = <wa_mtarts>-lgort.
                  <good>-entry_qnt = lv_cant_necesaria.
                  <wa_mtarts>-clabs = <wa_mtarts>-clabs - lv_cant_necesaria.
                  lv_cant_necesaria = 0.
                  EXIT.
                ELSE.
                  <good>-batch = <wa_mtarts>-charg.
                  <good>-entry_qnt = <wa_mtarts>-clabs. "<good>-entry_qnt -
                  <good>-plant = <wa_mtarts>-werks.
                  <good>-stge_loc = <wa_mtarts>-lgort.
                  lv_cant_necesaria = lv_cant_necesaria - <wa_mtarts>-clabs.
                  <wa_mtarts>-clabs = 0.
                  wa_auxiliar = <good>.
                  APPEND wa_auxiliar TO it_repeticiones.
                  lv_indice_rep = sy-tabix.
                ENDIF.
              ENDLOOP.
              IF lv_cant_necesaria > 0 AND sy-subrc = 0.
                "Si todavía quedase cantidad por consumir se la metermos al último componente
                <good>-entry_qnt = <good>-entry_qnt + lv_cant_necesaria.
                TRY.
                    DELETE it_repeticiones INDEX lv_indice_rep.
                  CATCH cx_root.
                ENDTRY.
              ENDIF.

            ENDIF. "JVM - GAPPP002
*              READ TABLE it_mtarts ASSIGNING <wa_mtarts> WITH KEY matnr = <good>-material .
*              IF sy-subrc = 0.
*                IF <wa_mtarts>-clabs >= lv_cant_necesaria.
*
*                ENDIF.
*              ENDIF.
          ENDLOOP.
          APPEND LINES OF it_repeticiones TO it_goods.

        ENDIF.

      ENDIF.

*        Tenemos que meter en la BAPI_PRODORDCONF_CREATE_TT una línea en la goodmovements para
*        aquellos componentes de la orden que estén asignados a la operación que se esté notificando
*        y que sean MTART = ZPSE O ZPTO con la cantidad que corresponda obteniendo esta cantidad de la
*        BAPI_PRODORDCONF_GET_TT_PROP. LE pasamos a esta BAPI en el PROPOSE marcamos goodmovements,
*        y en la timetickets pasamos:
*        •  ORDERID = AUFNR
*        •  OPERATION = codigo operación a notificar
*        •  YIELD = cantidad operación a notificar
*        Y recuperamos una goodmevents donde sólo debemos recuperar los registros donde el MTART
*        del componente sea ZPSE O ZPTO
*        Ahora a la BAPI_PRODORDCONF_CREATE_TT al margen de la timetickets que ya LE estamos pasando,
*        a la goodmovements hay que pasarle lo siguiente:
*        •  MATERIAL: BAPI_PRODORDCONF_GET_TT_PROP- goodmevents-MATNR
*        •  PLANT : BAPI_PRODORDCONF_GET_TT_PROP- goodmevents-WERKS
*        •  STGE_LOC: BAPI_PRODORDCONF_GET_TT_PROP- goodmevents-LGORT
*        •  BATCH: BAPI_PRODORDCONF_GET_TT_PROP- goodmevents-BATCH
*        •  MOVE_TYPE: “261”
*        •  ENTRY_QNT  : PRODORDCONF_GET_TT_PROP- goodmevents- ENTRY_QNT
*        •  ENTRY_UOM  : PRODORDCONF_GET_TT_PROP- goodmevents- ENTRY_UOM
*        •  ORDERID: PRODORDCONF_GET_TT_PROP- goodmevents- ORDERID
*        •  RESERV_NO: PRODORDCONF_GET_TT_PROP- goodmevents- RESERV_NO
*        •  RES_ITEM : PRODORDCONF_GET_TT_PROP- goodmevents- RES_ITEM

      DATA(lt_link) = it_link[].
      CLEAR: it_link, it_link[].

      IF it_goods IS NOT INITIAL.
*         add jtm 22.12.2022 Sacamos el número de almacen de los consumos
        DATA lgnum TYPE lgnum.
        CLEAR lgnum.
        LOOP AT it_goods INTO DATA(rt_goods).
          SELECT SINGLE lgnum INTO lgnum FROM t320 WHERE werks EQ rt_goods-plant
                                                     AND lgort EQ rt_goods-stge_loc.
          CHECK sy-subrc EQ 0 AND lgnum IS NOT INITIAL.
          EXIT.
        ENDLOOP.
        IF lgnum IS NOT INITIAL.
*         fin de add jtm 22.12.2022
          SELECT t1~* FROM lqua AS t1 INNER JOIN mara AS t2 ON t1~matnr EQ t2~matnr
             INTO TABLE @DATA(t_lqua)
            FOR ALL ENTRIES IN @it_goods
              WHERE t1~matnr = @it_goods-material
                AND t1~lgnum = @lgnum" add jtm 22.12.2022
                AND charg = @it_goods-batch
                AND t1~werks = @it_goods-plant
                AND lenum <> ''
                AND lgtyp NOT IN ( 'MUE','916','922','998','999' )
                AND mtart IN ('ZPSE', 'ZPTO').

          SORT t_lqua BY lgnum lqnum ASCENDING.
          DELETE ADJACENT DUPLICATES FROM t_lqua COMPARING lgnum lqnum.
        ENDIF.
      ENDIF.


      DATA: l_cant   TYPE menge_d,
            tt_lenum TYPE  zswm_change_lenum_sonum_tt,
            l_lenum  TYPE zswm_change_lenum_sonum_scr,
            l_error  TYPE flag,
            tt_log   TYPE bapiret2_t.


*        LOOP AT it_goods ASSIGNING <good>.
*
*          l_cant = <good>-quantity.
*          REFRESH: tt_lenum.
*          LOOP AT t_lqua ASSIGNING FIELD-SYMBOL(<fs_lqua>) WHERE matnr = <good>-material AND charg = <good>-batch AND werks = <good>-plant.
*            IF l_cant <= 0.
*              EXIT.
*            ENDIF.
*            l_cant = l_cant - <fs_lqua>-verme.
*            l_lenum-lenum = <fs_lqua>-lenum.
*            l_lenum-new_sonum = lv_vbeln && lv_posnr.
*
*            APPEND l_lenum TO tt_lenum.
*          ENDLOOP.
*
*          CALL FUNCTION 'ZSWM_CHANGE_SONUM_LENUM'
*            EXPORTING
*              tt_lenum = tt_lenum    " TT ZSWM_PRINT_EXIDV_LENUM_SCR
**             wait     = 'X'    " Indicador general
**              IMPORTING
**             gm_headret =     " MMIM: Estructura output p.MF general p.movimiento mcía.
*              error    = l_error    " Indicador general
*              tt_log   = tt_log.    " Tabla retorno
*
*        ENDLOOP.

      "JVM - Ajuste para arranque XATIVA, QUITAR
      DATA it_goods_new TYPE TABLE OF bapi2017_gm_item_create.
      FREE it_goods_new.
      LOOP AT it_goods ASSIGNING <good>.
        DATA(lv_indice_new) = sy-tabix.

        IF sy-datum < '20241021'
          AND <good>-plant = '2000'
          AND ( abap_true = zspp_utils=>get_tinta( i_matnr = <good>-material ) )
          AND  <good>-stge_loc = '1000'.

          <good>-stge_loc = '1010'.
          DATA(it_lotes) = zspp_utils=>get_lote_tinta( i_matnr = <good>-material
                                                       i_lgort = <good>-stge_loc
                                                       i_werks = <good>-plant
                                                       i_clabs = <good>-entry_qnt ).

          LOOP AT it_lotes ASSIGNING FIELD-SYMBOL(<fnew>).
            APPEND INITIAL LINE TO it_goods_new ASSIGNING FIELD-SYMBOL(<good_new>).
            MOVE-CORRESPONDING <good> TO <good_new>.
            <good_new>-batch = <fnew>-charg.
            <good_new>-entry_qnt = <fnew>-clabs.
            IF <fnew>-charg = 'NONSTOCK'.
              CLEAR <good_new>-batch.
            ENDIF.
          ENDLOOP.
          IF sy-subrc = 0.
            DELETE it_goods INDEX lv_indice_new.
          ENDIF.
        ENDIF.

      ENDLOOP.
      APPEND LINES OF it_goods_new TO it_goods.
      "JVM - Ajuste para arranque XATIVA, QUITAR

      LOOP AT it_goods ASSIGNING <good>.
        READ TABLE lt_link WITH KEY index_goodsmov = sy-tabix ASSIGNING FIELD-SYMBOL(<lnk>).
        IF sy-subrc = 0.
          DATA(lv_refpos) = <lnk>-index_gm_depend.
        ELSE.
          CLEAR lv_refpos.
        ENDIF.
        " LRE 28.10.2022 quitar consumo en stock special E para cualquier componente
        <good>-spec_stock = ' '.
        <good>-sales_ord = ' ' .
        <good>-s_ord_item = ' '.
        " FIN LRE
        DATA(lv_linea) = sy-tabix.
        APPEND INITIAL LINE TO it_link ASSIGNING FIELD-SYMBOL(<link>).
        <link>-index_confirm = '1'.
        <link>-index_goodsmov = lv_linea.
        IF lv_refpos IS NOT INITIAL.
          <link>-index_gm_depend = lv_refpos.
        ENDIF.
        l_cant = <good>-entry_qnt.
*          <good>-entry_qnt = 0. "JVM - Comentado 22/12/2022
        REFRESH: tt_lenum.
        LOOP AT t_lqua ASSIGNING FIELD-SYMBOL(<fs_lqua>) WHERE matnr = <good>-material AND charg = <good>-batch AND werks = <good>-plant.
          IF l_cant <= 0.
            EXIT.
          ENDIF.

          l_cant = l_cant - <fs_lqua>-verme.
          l_lenum-lenum = <fs_lqua>-lenum.
          l_lenum-new_sonum = ' '. "lv_vbeln && lv_posnr.
          l_lenum-aufnr     = lv_aufnr.
          APPEND l_lenum TO tt_lenum.

*            <good>-entry_qnt =  <good>-entry_qnt + <fs_lqua>-verme."JVM - Comentado 22/12/2022

        ENDLOOP.
*          IF sy-subrc <> 0."JVM - Comentado 22/12/2022
*            <good>-entry_qnt = l_cant."JVM - Comentado 22/12/2022
*          ENDIF."JVM - Comentado 22/12/2022
        IF tt_lenum[] IS NOT INITIAL.
          CALL FUNCTION 'ZSWM_CHANGE_SONUM_LENUM'
            EXPORTING
              tt_lenum = tt_lenum    " TT ZSWM_PRINT_EXIDV_LENUM_SCR
*             wait     = 'X'    " Indicador general
            IMPORTING
*             gm_headret =     " MMIM: Estructura output p.MF general p.movimiento mcía.
              error    = l_error    " Indicador general
              tt_log   = tt_log.    " Tabla retorno
        ENDIF.

      ENDLOOP.

      CALL FUNCTION 'BAPI_PRODORDCONF_CREATE_TT'
*             EXPORTING
*               POST_WRONG_ENTRIES             = '0'
*               TESTRUN                        =
*               CALL_ON_INBOUND_QUEUE          = ' '
*             IMPORTING
*               RETURN                         =
        TABLES
          timetickets        = it_tt
          goodsmovements     = it_goods
          link_conf_goodsmov = it_link
*         CHARACTERISTICS_WIPBATCH       =
*         LINK_CONF_CHAR_WIPBATCH        =
          detail_return      = it_return
*         CHARACTERISTICS_BATCH          =
*         LINK_GM_CHAR_BATCH =
        .
      LOOP AT it_return INTO wa_return_tt.
        IF wa_return_tt-type IS NOT INITIAL.
          lo_log->guardar_mensaje(
          EXPORTING
            i_type       = wa_return_tt-type
            i_id         = wa_return_tt-id
            i_number     = wa_return_tt-number
            i_message_v1 = wa_return_tt-message_v1
            i_message_v2 = wa_return_tt-message_v2
            i_message_v3 = wa_return_tt-message_v3
            i_message_v4 = wa_return_tt-message_v4
            ).
        ENDIF.
      ENDLOOP.

      COMMIT WORK.

      COMMIT WORK AND WAIT.
      PERFORM wait_aufnr USING wa_head-orden.
      PERFORM wait_rsnum USING lv_rsnum.
*          EXIT.
      IF lv_waitsec IS INITIAL.
        WAIT UP TO 2 SECONDS.
      ELSE.
        WAIT UP TO lv_waitsec SECONDS.
      ENDIF.
*        ENDDO.
*      ENDIF.

    ENDLOOP.





*    workflow_result = '99999'.
*    CLEAR idoc_status.
*    idoc_status-msgty    = 'S'."wa_return-type.
*    idoc_status-msgid    = '00'."wa_return-id.
*    idoc_status-msgno    = '398'."wa_return-number.
*    idoc_status-msgv1    = 'IDOC contabilizado correctamente'."wa_return-message_v1.
*    idoc_status-msgv2    = |para OF { wa_head-orden ALPHA = OUT }| .
*    idoc_status-msgv3    = ''.
*    idoc_status-msgv4    = ''.
*    idoc_status-status   = '52'.
*    idoc_status-repid    = sy-repid.
*    CLEAR return_variables.
*    return_variables-wf_param = 'PROCESS_IDOCs'.
*    LOOP AT idoc_contrl.
*      idoc_status-docnum = idoc_contrl-docnum.
*      APPEND idoc_status.
*      return_variables-doc_number = idoc_contrl-docnum.
*      APPEND return_variables.
*    ENDLOOP.

    COMMIT WORK AND WAIT.
  ENDIF.

  lo_log->guardar_log(
  EXPORTING
    objeto    = 'ZEDI_OMP'    " Log aplicación: Nombre objeto (sigla de aplicación)
*    subobjeto = 'ZEDI_OMP'    " Log aplicación: Objeto inferior "JVM - cambiamos subobjeto para el log
    subobjeto = 'ZSHIFT'    " Log aplicación: Objeto inferior "JVM - cambiamos subobjeto para el log
*    extnumber =     " Log aplicación: Identificación externa
  IMPORTING
    lognumber = DATA(lv_lognum)    " Número de LOG
    ).

*  LOOP AT idoc_status ASSIGNING FIELD-SYMBOL(<idoc>).
*    <idoc>-appl_log = lv_lognum.
*  ENDLOOP.
*  IF sy-subrc <> 0.
**    APPEND INITIAL LINE TO idoc_status ASSIGNING <idoc>.
*    idoc_status-msgty    = 'S'."wa_return-type.
*    idoc_status-msgid    = '00'."wa_return-id.
*    idoc_status-msgno    = '398'."wa_return-number.
*    idoc_status-msgv1    = 'IDOC contabilizado correctamente'."wa_return-message_v1.
*    idoc_status-msgv2    = |para OF { wa_head-orden ALPHA = OUT }| .
*    idoc_status-msgv3    = ''.
*    idoc_status-msgv4    = ''.
*    idoc_status-status   = '53'.
*    idoc_status-repid    = sy-repid.
*    idoc_status-appl_log = lv_lognum.
*    LOOP AT idoc_contrl.
*      idoc_status-docnum = idoc_contrl-docnum.
*      APPEND idoc_status.
*      return_variables-doc_number = idoc_contrl-docnum.
*      APPEND return_variables.
*    ENDLOOP.
*  ENDIF.

  DATA it_logtab TYPE bapiret2_tab.
  lo_log->get_bapiret_tab(
  IMPORTING
    gt_bapiret = it_logtab
    ).
  LOOP AT it_logtab TRANSPORTING NO FIELDS WHERE type EQ 'E' OR type EQ 'A' OR type EQ 'X'.
    DATA(lv_err_idoc) = 'X'.
    EXIT.
  ENDLOOP.
  LOOP AT idoc_status TRANSPORTING NO FIELDS WHERE msgty EQ 'E' OR msgty EQ 'A' OR msgty EQ 'X'.
    lv_err_idoc = 'X'.
    EXIT.
  ENDLOOP.
  REFRESH idoc_status.
  CLEAR idoc_status.

  workflow_result = '99999'.
  CLEAR idoc_status.

  IF lv_err_idoc = 'X'.
    idoc_status-msgty    = 'E'.
    idoc_status-status   = '63'.
  ELSE.
    idoc_status-msgty    = 'S'.
    idoc_status-status   = '53'.
  ENDIF.
  idoc_status-msgid    = '00'.
  idoc_status-msgno    = '398'.
  idoc_status-msgv1    = 'Revisar LOG de Aplicación'.
  idoc_status-msgv2    = ''.
  idoc_status-msgv3    = ''.
  idoc_status-msgv4    = ''.

  idoc_status-repid    = sy-repid.
  idoc_status-appl_log = lv_lognum.
  CLEAR return_variables.
  return_variables-wf_param = 'PROCESS_IDOCs'.
  LOOP AT idoc_contrl.
    idoc_status-docnum = idoc_contrl-docnum.
    APPEND idoc_status.
    return_variables-doc_number = idoc_contrl-docnum.
    APPEND return_variables.
  ENDLOOP.

  SORT return_variables.
  DELETE ADJACENT DUPLICATES FROM return_variables.


  CALL FUNCTION 'DB_COMMIT'.
  CALL FUNCTION 'DEQUEUE_ALL'.
  COMMIT WORK.

ENDFUNCTION.
