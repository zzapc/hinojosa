FUNCTION zspp_idoc_orders.
*"----------------------------------------------------------------------
*"*"Interfase local
*"  IMPORTING
*"     VALUE(I_AUFNR) TYPE  AUFNR OPTIONAL
*"     VALUE(NO_GENERA_IDOC) TYPE  XFELD OPTIONAL
*"  TABLES
*"      OT_IDOC TYPE  EDIDD_TT OPTIONAL
*"      IT_HEADER STRUCTURE  CAUFVDB
*"      IT_ITEM STRUCTURE  AFPOB
*"      IT_SEQUENCE STRUCTURE  AFFLB
*"      IT_OPERATION STRUCTURE  AFVGB
*"      IT_COMPONENT STRUCTURE  RESBB
*"      IT_DOCLINK STRUCTURE  AFDLD
*"      IT_PRT_ALLOCATION STRUCTURE  AFFHB
*"----------------------------------------------------------------------
*do.enddo.
  "Añadir chequeos para no enviar el ORDERS si está LIB, CTEC o PTBO
  WAIT UP TO 2 SECONDS.

  DATA lv_objnr TYPE j_objnr.

  TRY.
      lv_objnr = it_header[ 1 ]-objnr.

      CALL FUNCTION 'STATUS_CHECK'
        EXPORTING
*         BYPASS_BUFFER     = ' '
*         CLIENT            = SY-MANDT
          objnr             = lv_objnr
          status            = 'I0002'
        EXCEPTIONS
          object_not_found  = 1
          status_not_active = 2
          OTHERS            = 3.
      IF sy-subrc <> 0.
* Implement suitable error handling here
        CALL FUNCTION 'STATUS_CHECK'
          EXPORTING
*           BYPASS_BUFFER     = ' '
*           CLIENT            = SY-MANDT
            objnr             = lv_objnr
            status            = 'I0045'
          EXCEPTIONS
            object_not_found  = 1
            status_not_active = 2
            OTHERS            = 3.
        IF sy-subrc <> 0.
* Implement suitable error handling here
          CALL FUNCTION 'STATUS_CHECK'
            EXPORTING
*             BYPASS_BUFFER     = ' '
*             CLIENT            = SY-MANDT
              objnr             = lv_objnr
              status            = 'I0076'
            EXCEPTIONS
              object_not_found  = 1
              status_not_active = 2
              OTHERS            = 3.
          IF sy-subrc = 0.
* Implement suitable error handling here
            RETURN.
          ENDIF.
        ELSE.
          RETURN.
        ENDIF.
      ELSE.
        "Si está liberada, verificamos si ha habido un cambio de fechas, si lo hubiera, enviamos el idoc, sino no hacemos nada
        CALL FUNCTION 'ZSPP_IDOC_ORDERS_FECHAS_LIB'
          TABLES
            it_header    = it_header
            it_item      = it_item
            it_component = it_component.

        RETURN.
      ENDIF.


    CATCH cx_root.

  ENDTRY.



  DATA(it_operation_all) = it_operation[].
  DELETE it_operation WHERE steus EQ 'PP02' OR steus EQ 'PP03'.

  "Para no enviar OFs de subco, ya que si sólo tienen operación de subco no se deben enviar
  CHECK it_operation[] IS NOT INITIAL.

  DATA: ls_idoc_header       TYPE edidc,
        lt_idoc_comm_control TYPE TABLE OF edidc,
        ls_idoc_comm_control TYPE edidc,
        lt_return            TYPE bapiret2_t,
        ls_return            TYPE bapiret2,
        ls_return1           TYPE bapiret1,
        t_edidd              TYPE edidd_tt,
        t_edidd_aux          TYPE edidd_tt.

*  DATA zccorder2 TYPE zccorder2.
  DATA: wa_productionorderinfo      TYPE zccproductionorderinfo,
        wa_productionorderinfodata  TYPE zccproductionorderinfodata,
        wa_plannedorderconfirmation TYPE zccplannedorderconfirmation,
        wa_plannedorderconfdata     TYPE zccplannedorderconfdata,
        wa_plannedorder             TYPE zccplannedorder,
        wa_plannedorderdata         TYPE zccplannedorderdata,
        wa_stopcode                 TYPE zccstopcode,
        wa_stopcodedata             TYPE zccstopcodedata,
        wa_operaltmach              TYPE zccoperaltmach,
        wa_operaltmachdata          TYPE zccoperaltmachdata,
        wa_operres                  TYPE zccoperres,
        wa_operresdata              TYPE zccoperresdata,
        wa_opermat                  TYPE zccopermat,
        wa_opermatdata              TYPE zccopermatdata,
        wa_operation                TYPE zccoperation,
        wa_operationdata1           TYPE zccoperationdata1,
        wa_operationdata2           TYPE zccoperationdata2,
        wa_resource                 TYPE zccresource,
        wa_resourcedata             TYPE zccresourcedata,
        wa_product                  TYPE zccproduct,
        wa_productdata1             TYPE zccproductdata1,
        wa_productdata2             TYPE zccproductdata2,
        wa_process                  TYPE zccprocess,
        wa_processdata              TYPE zccprocessdata,
        wa_orderaltgrade            TYPE zccorderaltgrade,
        wa_orderaltgradedata        TYPE zccorderaltgradedata,
        wa_order                    TYPE zccorder,
        wa_orderdata                TYPE zccorderdata,
        wa_delivery                 TYPE zccdelivery,
        wa_deliverydata             TYPE zccdeliverydata,
        wa_customer                 TYPE zcccustomer,
        wa_customerdata             TYPE zcccustomerdata.


  DATA: lv_number        LIKE  bapi_order_key-order_number.
*        lv_order_objects LIKE  bapi_pp_order_objects,
*        wa_return        LIKE  bapiret2,
*        it_header        TYPE TABLE OF bapi_order_header1,
*        it_item      TYPE TABLE OF  bapi_order_item,
*        it_sequence      TYPE TABLE OF  bapi_order_sequence,
*        it_operation     TYPE TABLE OF  bapi_order_operation1,
*        it_trigger_point TYPE TABLE OF  bapi_order_trigger_point,
*        it_component     TYPE TABLE OF  bapi_order_component,
*        it_prod_rel_tool TYPE TABLE OF  bapi_order_prod_rel_tools.
*  DATA i_aufnr TYPE aufnr.
  IF i_aufnr IS INITIAL.
    TRY.
        i_aufnr = it_header[ 1 ]-aufnr.
        CHECK it_header[ 1 ]-autyp EQ '10' AND ( it_header[ 1 ]-werks EQ c_pacs OR it_header[ 1 ]-werks EQ c_sarria
        OR it_header[ 1 ]-werks EQ c_xativa ). "JVM - ADD 11/05/2023 - Adaptaciones Xátiva
      CATCH cx_root.
        RETURN.
    ENDTRY.
  ENDIF.


  CHECK i_aufnr(1) NE '%'.
  CHECK NOT i_aufnr CS '%'.


*  IF sy-datum = '20240701'
*    AND sy-uname EQ 'CONSULTOR PP'
*    AND sy-sysid EQ 'HEQ'
*    AND i_aufnr = '000041000279'.
*    DO.
*
*    ENDDO.
*  ENDIF.

  DO 15 TIMES.
    SELECT SINGLE aufnr INTO @DATA(lv_aufnr) FROM aufk WHERE aufnr EQ @i_aufnr.
    IF sy-subrc <> 0.
      WAIT UP TO 1 SECONDS.
      DATA(lv_encontrada_of) = ''.
    ELSE.
      lv_encontrada_of = 'X'.
      EXIT.
    ENDIF.
  ENDDO.

  CHECK lv_encontrada_of = 'X'.


  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = i_aufnr
    IMPORTING
      output = lv_number.


  IF it_component[] IS INITIAL.

    SELECT * INTO TABLE @DATA(it_resbd) FROM resb WHERE aufnr EQ @i_aufnr AND xloek EQ @space.
    it_component[] = CORRESPONDING #( it_resbd[] ).

  ENDIF.
  DATA: lv_werks TYPE werks_d,
        lv_lgort TYPE lgort_d,
        lv_matnr TYPE matnr.
  lv_werks = it_item[ 1 ]-dwerk.""prod_plant.
  lv_lgort = it_item[ 1 ]-lgort."storage_location.
  lv_matnr = it_item[ 1 ]-matnr."material.

  DATA: lv_vbeln TYPE vbeln_va,
        lv_posnr TYPE posnr.

*  lv_vbeln = it_header_imp[ 1 ]-kdauf."sales_order.
*  lv_posnr = it_header[ 1 ]-kdpos."sales_order_item.
*
*  IF lv_vbeln IS INITIAL.
  lv_vbeln = it_item[ 1 ]-kdauf."sales_order.
  lv_posnr = it_item[ 1 ]-kdpos."sales_order_item.
  IF lv_vbeln IS INITIAL.
    "Recuperar de la vista Z
    SELECT SINGLE kdauf kdpos
    INTO ( lv_vbeln, lv_posnr )
    FROM zpp0002
    WHERE aufnr EQ lv_number.

  ENDIF.
  DATA(lv_erporderid) = lv_vbeln.
  DATA(lv_erporderidp) = lv_posnr.

*  ENDIF.

  DATA lv_matnr_head TYPE matnr.
  lv_matnr_head = it_header[ 1 ]-plnbez.
  SELECT SINGLE mtart INTO @DATA(lv_mtart_head) FROM mara WHERE matnr EQ @lv_matnr_head.
  "excluir status 0045 y 0046 en ordenes de PT para assemblyid
  IF lv_vbeln IS NOT INITIAL.
    SELECT SINGLE * INTO @DATA(wa_kit) FROM vbap WHERE vbeln EQ @lv_vbeln AND posnr EQ @lv_posnr AND abgru EQ @space.
    IF sy-subrc = 0 AND wa_kit-uepos IS NOT INITIAL.
      DATA(lv_es_kit) = 'X'.
      "Es un KIT
      "Buscamos las piezas que conforman el kit
      SELECT * INTO TABLE @DATA(it_kits) FROM vbap WHERE vbeln EQ @lv_vbeln AND uepos EQ @wa_kit-uepos AND abgru EQ @space.
      SELECT SINGLE kwmeng INTO @DATA(lv_num_kits) FROM vbap WHERE vbeln EQ @lv_vbeln AND posnr EQ @wa_kit-uepos AND abgru EQ @space.

      DATA lv_componentes TYPE menge_d.
      CLEAR lv_componentes.
      DATA lv_part TYPE menge_d.
      CLEAR lv_part.

      LOOP AT it_kits INTO DATA(wa_kits).
        "Obtenemos el total de componentes
*        lv_componentes  = lv_componentes  + ( wa_kits-kwmeng / lv_num_kits ).
        IF wa_kits-posnr EQ lv_posnr.
          "Obtenemos el total de componente que estamos tratando
          TRY.
              lv_part = wa_kits-kwmeng / lv_num_kits.
            CATCH cx_root.
          ENDTRY.
        ENDIF.
      ENDLOOP.

    ELSEIF sy-subrc = 0 AND wa_kit-uepos IS INITIAL.

      "No es un KIT
      "buscamos en AUFK todas las OFs con el mismo KDAUF y KDPOS
      SELECT aufk~aufnr, aufk~auart, plnbez, jest~stat, jest~inact, mtart
        INTO TABLE @DATA(it_no_kits)
        FROM aufk INNER JOIN afko ON aufk~aufnr EQ afko~aufnr
        INNER JOIN mara ON afko~plnbez EQ mara~matnr
        LEFT OUTER JOIN jest ON aufk~objnr EQ jest~objnr
        WHERE kdauf EQ @lv_vbeln AND kdpos EQ @lv_posnr.
      IF sy-subrc = 0.
        "Eliminamos OFs cerradas o Ctec
        LOOP AT it_no_kits INTO DATA(wa_no_kits) WHERE inact EQ space AND ( stat EQ 'I0045' OR stat EQ 'I0046' ).
          DELETE it_no_kits WHERE aufnr EQ wa_no_kits-aufnr.
        ENDLOOP.
        "Si estamos en creación de OF, no habremos recuperado de BBDD todavía la orden en curso
        READ TABLE it_no_kits WITH KEY aufnr = lv_number TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          APPEND INITIAL LINE TO it_no_kits ASSIGNING FIELD-SYMBOL(<no_kit>).
          <no_kit>-aufnr = lv_number.
          SELECT SINGLE mtart INTO <no_kit>-mtart
            FROM mara WHERE matnr EQ lv_matnr_head.
          <no_kit>-plnbez = lv_matnr_head.
        ENDIF.

        SORT it_no_kits.
        DELETE ADJACENT DUPLICATES FROM it_no_kits COMPARING aufnr.
        DESCRIBE TABLE it_no_kits LINES DATA(lv_num_no_kits).
        IF lv_num_no_kits >= 2.

          READ TABLE it_no_kits INTO wa_no_kits WITH KEY aufnr = lv_number.
          IF sy-subrc = 0.
            "Si estamos en la OF del PT tenemos que pasar en assembly la OF del Semi, si estamos
            "en el Semi, la del PT
            SELECT SINGLE mtart INTO @DATA(lv_mtart_assembly) FROM mara WHERE matnr EQ @wa_no_kits-plnbez.
            IF sy-subrc = 0.
              LOOP AT it_no_kits INTO wa_no_kits WHERE mtart <> lv_mtart_assembly AND aufnr <> lv_number.
                EXIT.
              ENDLOOP.
              IF sy-subrc = 0.

                DATA(lv_assembly) = 'X'.
                DATA lv_of_assembly TYPE aufnr.
                CLEAR lv_of_assembly.
                lv_of_assembly = lv_vbeln."wa_no_kits-aufnr.
              ENDIF.
            ENDIF.
*          "Buscamos la OF de PTE para pasarla en el assembly id
*          SELECT SINGLE aufnr INTO @DATA(lv_of_assembly)
*            FROM afko AS t1 INNER JOIN mara AS t2 ON t1~plnbez EQ t2~matnr
*            AND mtart LIKE 'ZPRT'.
          ENDIF.
        ENDIF.
      ENDIF.

      "para la OF del PT si tiene semi como componente con MTART ZPSE que
      "tenga MARC-SOBSL = 40 es un cross plant y tenemos que apsarle assembly

      IF lv_mtart_head EQ 'ZPTO' AND lv_of_assembly IS INITIAL.
        "Identificamos si tiene algún componente tipo ZPSE
        IF it_component[] IS NOT INITIAL.
          SELECT DISTINCT mtart, matnr INTO TABLE @DATA(it_zpse)
            FROM mara
            FOR ALL ENTRIES IN @it_component
            WHERE matnr EQ @it_component-matnr
            AND mtart EQ 'ZPSE'.
          IF sy-subrc = 0.
            READ TABLE it_zpse INTO DATA(wa_zpse) INDEX 1.
            "Si tiene componente ZPSE, verificamos si tiene SOBSL = 40 en el centro de la OF que estamos tratando
            SELECT SINGLE sobsl INTO @DATA(lv_sobsl_pse)
              FROM marc
              WHERE matnr EQ @wa_zpse-matnr
              AND werks EQ @lv_werks
              AND sobsl EQ '40'.
            IF sy-subrc = 0.
              lv_assembly = 'X'.
              lv_of_assembly = lv_vbeln.
            ENDIF.
          ENDIF.
        ENDIF.

      ELSEIF lv_mtart_head EQ 'ZPSE' AND lv_of_assembly IS INITIAL.

        IF lv_vbeln IS NOT INITIAL.

          lv_assembly = 'X'.
          lv_of_assembly = lv_vbeln.

        ELSE.

          READ TABLE it_item INTO DATA(ls_item) WITH KEY aufnr = lv_number.
          IF sy-subrc = 0.
            DATA: lv_edelnr TYPE del12,
                  lt_mdrq   TYPE TABLE OF mdrq.
            CLEAR: lv_edelnr, lt_mdrq, lt_mdrq[].
            lv_edelnr = ls_item-plnum.
            "Recuperamos la OP que genera la OF/OP del semiterminado
            CALL FUNCTION 'MD_PEGGING_NODIALOG'
              EXPORTING
                edelet                = '0000'
                edelkz                = 'PA'
                edelnr                = lv_edelnr
                edelps                = '000000'
                eplscn                = '000'
                ematnr                = lv_matnr_head
                ewerks                = lv_werks
                eplaab                = '00'
              TABLES
                imdrqx                = lt_mdrq[]
              EXCEPTIONS
                error                 = 1
                no_requirements_found = 2
                order_not_found       = 3
                OTHERS                = 4.
            IF sy-subrc <> 0.
* Implement suitable error handling here
            ENDIF.

            READ TABLE lt_mdrq INTO DATA(lw_mdrq) WITH KEY delkz = 'VC'.
            IF sy-subrc = 0.
              lv_vbeln = lw_mdrq-delnr.
              lv_of_assembly = lv_vbeln.
              lv_assembly = 'X'.
            ENDIF.

          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.

    IF lv_mtart_head EQ 'ZPTO' AND lv_of_assembly IS INITIAL.
      "Identificamos si tiene algún componente tipo ZPSE
      IF it_component[] IS NOT INITIAL.
        SELECT DISTINCT mtart, matnr INTO TABLE @it_zpse
              FROM mara
              FOR ALL ENTRIES IN @it_component
              WHERE matnr EQ @it_component-matnr
              AND mtart EQ 'ZPSE'.
        IF sy-subrc = 0.
          READ TABLE it_zpse INTO wa_zpse INDEX 1.
          "Si tiene componente ZPSE, verificamos si tiene SOBSL = 40 en el centro de la OF que estamos tratando
          SELECT SINGLE sobsl INTO @lv_sobsl_pse
                FROM marc
                WHERE matnr EQ @wa_zpse-matnr
                AND werks EQ @lv_werks
                AND sobsl EQ '40'.
          IF sy-subrc = 0.
            lv_assembly = 'X'.
            IF lv_vbeln IS INITIAL.

              READ TABLE it_item INTO ls_item WITH KEY aufnr = lv_number.
              IF sy-subrc = 0.
                CLEAR: lv_edelnr, lt_mdrq, lt_mdrq[].
                lv_edelnr = ls_item-plnum.
                "Recuperamos la OP que genera la OF/OP del semiterminado
                CALL FUNCTION 'MD_PEGGING_NODIALOG'
                  EXPORTING
                    edelet                = '0000'
                    edelkz                = 'PA'
                    edelnr                = lv_edelnr
                    edelps                = '000000'
                    eplscn                = '000'
                    ematnr                = lv_matnr_head
                    ewerks                = lv_werks
                    eplaab                = '00'
                  TABLES
                    imdrqx                = lt_mdrq[]
                  EXCEPTIONS
                    error                 = 1
                    no_requirements_found = 2
                    order_not_found       = 3
                    OTHERS                = 4.
                IF sy-subrc <> 0.
* Implement suitable error handling here
                ENDIF.

                READ TABLE lt_mdrq INTO lw_mdrq WITH KEY delkz = 'VC'.
                IF sy-subrc = 0.
                  lv_vbeln = lw_mdrq-delnr.
                  lv_of_assembly = lv_vbeln.
                  lv_assembly = 'X'.
                ENDIF.
              ENDIF.
            ENDIF.
            lv_of_assembly = lv_vbeln.
          ENDIF.
        ENDIF.
      ENDIF.

    ELSEIF lv_mtart_head EQ 'ZPSE' AND lv_of_assembly IS INITIAL.

      IF lv_vbeln IS NOT INITIAL.

        lv_assembly = 'X'.
        lv_of_assembly = lv_vbeln.

      ELSE.

        READ TABLE it_item INTO ls_item WITH KEY aufnr = lv_number.
        IF sy-subrc = 0.
*          DATA: lv_edelnr TYPE del12,
*                lt_mdrq   TYPE TABLE OF mdrq.
          CLEAR: lv_edelnr, lt_mdrq, lt_mdrq[].
          lv_edelnr = ls_item-plnum.
          "Recuperamos la OP que genera la OF/OP del semiterminado
          CALL FUNCTION 'MD_PEGGING_NODIALOG'
            EXPORTING
              edelet                = '0000'
              edelkz                = 'PA'
              edelnr                = lv_edelnr
              edelps                = '000000'
              eplscn                = '000'
              ematnr                = lv_matnr_head
              ewerks                = lv_werks
              eplaab                = '00'
            TABLES
              imdrqx                = lt_mdrq[]
            EXCEPTIONS
              error                 = 1
              no_requirements_found = 2
              order_not_found       = 3
              OTHERS                = 4.
          IF sy-subrc <> 0.
* Implement suitable error handling here
          ENDIF.

          READ TABLE lt_mdrq INTO lw_mdrq WITH KEY delkz = 'VC'.
          IF sy-subrc = 0.
            lv_vbeln = lw_mdrq-delnr.
            lv_of_assembly = lv_vbeln.
            lv_assembly = 'X'.
          ENDIF.

        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  "JVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
*  Cambios derivados de OM Transportes (afecta sólo a Xàtiva)
*  Para los materiales CO* que se finalizan en planta y para los SE* que llevan una operación
*  de subcontratación (no aplicaría en aquellos SE que no van a expedirse ya que acaban en
*  un ASet  grafo y no se van a expedir). Es decir, afecta a todas las OFs que su material
*  de cabecera tenga MTART = ZPTO, y a los que su material de cabecera sea MTART = ZPSE y
*  esa orden no pertenezca a un grafo de órdenes.
  IF lv_werks = c_xativa AND ( lv_mtart_head EQ 'ZPSE' OR lv_mtart_head EQ 'ZPTO' ).
    "Revisamos si es una OF de grafo
    SELECT SINGLE lead_aufnr, prodnet FROM afko
      WHERE aufnr = @lv_aufnr
      INTO @DATA(wa_grafo).
    IF ( lv_mtart_head EQ 'ZPSE' AND wa_grafo-prodnet IS INITIAL ) OR lv_mtart_head EQ 'ZPTO'.
      "Es decir, afecta a todas las OFs que su material
      "de cabecera tenga MTART = ZPTO, y a los que su material de cabecera sea MTART = ZPSE y
      "esa orden no pertenezca a un grafo de órdenes.
      DATA(lv_aplica_pp11) = abap_true.
    ENDIF.

    IF lv_mtart_head EQ 'ZPTO' AND wa_grafo-lead_aufnr IS NOT INITIAL.
      DATA(lv_esgrafo_cab) = 'X'.
    ENDIF.

    IF wa_grafo-lead_aufnr IS NOT INITIAL.
      DATA(lv_es_grafo) = abap_true.
    ENDIF.
  ENDIF.
  "FJVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios

  DATA: it_affhb     TYPE TABLE OF affhb,
        it_affhb_old TYPE TABLE OF affhb.

  IF it_prt_allocation[] IS INITIAL.

    CALL FUNCTION 'CF_BT_CO_AFFHB_TAB_GET'
      TABLES
        affh_bt     = it_affhb
        affh_bt_old = it_affhb_old.

    FIELD-SYMBOLS <ft> TYPE ANY TABLE.
    ASSIGN ('(SAPLCFBT)AUFTFH[]') TO <ft>.
    IF  sy-subrc = 0.
      it_prt_allocation[] = <ft>[].
    ENDIF.

  ENDIF.
  IF lv_vbeln IS NOT INITIAL.
    SELECT SINGLE * INTO @DATA(wa_vbak) FROM vbak WHERE vbeln EQ @lv_vbeln.
    SELECT SINGLE * INTO @DATA(wa_vbap) FROM vbap WHERE vbeln EQ @lv_vbeln AND posnr EQ @lv_posnr.
    SELECT SINGLE * INTO @DATA(wa_vbkd) FROM vbkd WHERE vbeln EQ @lv_vbeln.
    SELECT SINGLE * INTO @DATA(wa_knvv) FROM knvv WHERE kunnr EQ @wa_vbak-kunnr
          AND vkorg EQ @wa_vbak-vkorg
          AND vtweg EQ @wa_vbak-vtweg
          AND spart EQ @wa_vbak-spart.
    SELECT * INTO TABLE @DATA(it_vbpa) FROM vbpa WHERE vbeln EQ @lv_vbeln.

    SELECT SINGLE * INTO @DATA(wa_vbep) FROM vbep WHERE vbeln EQ @lv_vbeln
          AND posnr EQ @lv_posnr
*          AND etenr EQ 1. "JVM - modif 27/01/2023
          AND etenr EQ ( SELECT MIN( etenr ) FROM vbep WHERE vbeln EQ @lv_vbeln AND posnr EQ @lv_posnr ).
*          AND edatu EQ ( SELECT MIN( edatu ) FROM vbep WHERE vbeln EQ @lv_vbeln AND posnr EQ @lv_posnr ).
  ENDIF.



  "Leemos de BBDD y lo que nos llega, ya que si estamos en creación de OF, no existirá nada en BBDD
  "en creación si que llega la tabla IT_MAFS llena, pero cuando se modifica porque se añade o borra un MAF
  "sólo llega lo que se ha modificado, no todo
  DATA it_util_doc TYPE tty_util.
  CLEAR it_util_doc[].
  DATA(it_operation_doc) = it_operation[].

  PERFORM filtrar_anilox TABLES it_util_doc
                                it_operation
                                it_prt_allocation.
  FREE it_util_doc.
  DATA(it_prt_allocation_doc) = it_prt_allocation[].
  PERFORM get_utils TABLES it_util_doc it_operation_doc it_prt_allocation_doc USING lv_number.

  "JVM - ADD 25/04/2024 - Añadir documentos de la OF para campo drawingref
  DATA lv_objky_aux TYPE drad-objky.
  lv_objky_aux = lv_aufnr && '%'.
  IF it_util_doc[] IS NOT INITIAL.
    SELECT t1~doknr, t1~dokvr, settn
      FROM drad AS t1 INNER JOIN zvcxi_pxe_td200 AS t2
      ON t1~dokar EQ t2~dokar
      AND t1~doknr   EQ t2~doknr
      AND t1~dokvr   EQ t2~dokvr
      AND t1~doktl   EQ t2~doktl
      FOR ALL ENTRIES IN @it_util_doc
      WHERE objky LIKE @lv_objky_aux
      AND t1~dokob = 'PORDER'
      AND t1~dokar = 'Y01'
      AND settn = @it_util_doc-matnr
      INTO TABLE @DATA(it_documentos_of).
  ENDIF.
  SORT it_documentos_of BY doknr dokvr DESCENDING.
  DELETE ADJACENT DUPLICATES FROM it_documentos_of COMPARING doknr.
  "FJVM - ADD 25/04/2024 - Añadir documentos de la OF para campo drawingref
* //RESOURCES
  REFRESH: t_edidd_aux.

*  CLEAR: l_edidd.
*  zccorder2-order = 'X'.
*  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = zccorder2 )->get_relative_name( ).
*  l_edidd-sdata = zccorder2.
*  l_edidd-segnum = 1.
*  APPEND  l_edidd TO t_edidd.

  DATA lv_auxlevel TYPE edi_segnum.
  lv_auxlevel = 1.
  wa_order-operation = c_replace.

  l_edidd-sdata = wa_order.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_order )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.

  CLEAR: l_edidd, wa_orderdata.
  IF lv_werks EQ c_pacs "'2001'
    OR lv_werks EQ c_sarria. "'2003'."JVM - add 28/08/2023
    IF wa_kit-uepos IS NOT INITIAL.
*    WRITE lv_vbeln TO wa_orderdata-assemblyid LEFT-JUSTIFIED.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = lv_vbeln
        IMPORTING
          output = lv_vbeln.

      wa_orderdata-assemblyid = lv_vbeln." TO LEFT-JUSTIFIED.
      CONDENSE wa_orderdata-assemblyid.
*    IF lv_part IS NOT INITIAL.
      IF wa_kit-posnr IS NOT INITIAL.
*      WRITE lv_part TO wa_orderdata-assemblyqtypart  DECIMALS 0 LEFT-JUSTIFIED.
        WRITE wa_kit-posnr TO wa_orderdata-assemblyqtypart DECIMALS 0 LEFT-JUSTIFIED NO-ZERO.
        REPLACE ALL OCCURRENCES OF '.' IN wa_orderdata-assemblyqtypart WITH ''.
        CONDENSE wa_orderdata-assemblyqtypart NO-GAPS.
      ENDIF.
      CONCATENATE wa_orderdata-assemblyid wa_orderdata-assemblyqtypart INTO wa_orderdata-assemblyid SEPARATED BY '_'.
*    IF lv_componentes IS NOT INITIAL.
*      WRITE lv_componentes TO wa_orderdata-assemblytotalparts  DECIMALS 0 LEFT-JUSTIFIED.
*      REPLACE ALL OCCURRENCES OF '.' IN wa_orderdata-assemblytotalparts WITH ''.
*    ENDIF.
      IF lv_part IS NOT INITIAL.
        WRITE lv_part TO wa_orderdata-assemblytotalparts  DECIMALS 0 LEFT-JUSTIFIED.
        REPLACE ALL OCCURRENCES OF '.' IN wa_orderdata-assemblytotalparts WITH ''.
        CONDENSE wa_orderdata-assemblyqtypart NO-GAPS.
      ENDIF.

    ELSEIF lv_assembly EQ abap_true.


      IF lv_mtart_head EQ 'ZPTO'.
        lv_of_assembly = it_header[ 1 ]-aufnr.
      ELSE.
        "Si es un semi, buscamos la del PT relacionado
*      SELECT DISTINCT t1~aufnr, stat, inact, baugr, t1~matnr, t2~kdauf, t2~kdpos
*        INTO TABLE @DATA(it_aufnr_pto)
*        FROM resb AS t1 INNER JOIN afpo AS t2 ON t1~baugr EQ t2~matnr "AND t2~kdauf EQ @lv_erporderid AND t2~kdpos EQ @lv_erporderid
*        INNER JOIN aufk AS t3 ON t3~aufnr EQ t2~aufnr
*        INNER JOIN jest ON jest~objnr EQ t3~objnr
*        WHERE t1~matnr EQ @lv_matnr_head
*        AND t2~kdauf EQ @lv_erporderid
*        AND t2~kdpos EQ @lv_erporderidp.
*
*      "Eliminamos OFs cerradas o Ctec
*      LOOP AT it_aufnr_pto INTO DATA(wa_aufnr_pto) WHERE inact EQ space AND ( stat EQ 'I0045' OR stat EQ 'I0046' ).
*        DELETE it_aufnr_pto WHERE aufnr EQ wa_aufnr_pto-aufnr.
*      ENDLOOP.
*      CLEAR wa_aufnr_pto.
*      READ TABLE it_aufnr_pto INTO wa_aufnr_pto INDEX 1.
*      lv_of_assembly = wa_aufnr_pto.
*


        SELECT aufk~aufnr, aufk~auart, plnbez, jest~stat, jest~inact, mtart
          INTO TABLE @DATA(it_aufnr_pto2)
          FROM aufk INNER JOIN afko ON aufk~aufnr EQ afko~aufnr
          INNER JOIN mara ON afko~plnbez EQ mara~matnr
          LEFT OUTER JOIN jest ON aufk~objnr EQ jest~objnr
          WHERE kdauf EQ @lv_vbeln
          AND kdpos EQ @lv_posnr
          AND mara~mtart EQ 'ZPTO'.
        IF sy-subrc = 0.
          "Eliminamos OFs cerradas o Ctec
          LOOP AT it_aufnr_pto2 INTO DATA(wa_aufnr_pto2) WHERE inact EQ space AND ( stat EQ 'I0045' OR stat EQ 'I0046' ).
            DELETE it_aufnr_pto2 WHERE aufnr EQ wa_aufnr_pto2-aufnr.
          ENDLOOP.
          CLEAR wa_aufnr_pto2.
          READ TABLE it_aufnr_pto2 INTO wa_aufnr_pto2 INDEX 1.
          lv_of_assembly = wa_aufnr_pto2-aufnr.

        ENDIF.

      ENDIF.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = lv_of_assembly
        IMPORTING
          output = lv_of_assembly.


      wa_orderdata-assemblyid = lv_of_assembly." TO LEFT-JUSTIFIED .
      CONDENSE wa_orderdata-assemblyid.
      lv_part = 1.
      IF lv_part IS NOT INITIAL.
        WRITE lv_part TO wa_orderdata-assemblyqtypart  DECIMALS 0 LEFT-JUSTIFIED.
        REPLACE ALL OCCURRENCES OF '.' IN wa_orderdata-assemblyqtypart WITH ''.
      ENDIF.
*    lv_componentes = lv_num_no_kits - 1.
*    IF lv_componentes <= 0.
      lv_componentes = 1.
*    ENDIF.
      IF lv_componentes IS NOT INITIAL.
        WRITE lv_componentes TO wa_orderdata-assemblytotalparts  DECIMALS 0 LEFT-JUSTIFIED.
        REPLACE ALL OCCURRENCES OF '.' IN wa_orderdata-assemblytotalparts WITH ''.
      ENDIF.
    ENDIF.
  ELSE. "JVM - add 28/08/2023
    IF lv_werks = c_xativa AND lv_es_grafo EQ abap_true. "JVM - ADD 07/11/2023 No enviar en XATIVA si no son OF's de grafo
      "JVM ADD - Sustitución de tabla 28/06/2024
*      SELECT SINGLE parat
*        FROM zvcxi_p3e_td110
*        INTO @DATA(lv_parat)
*        WHERE matnr = @lv_matnr
*        AND werks = @lv_werks.
*      IF sy-subrc <> 0.
*        "Estaremos en un SEMI, vamos a buscar por el PRODH
*        SELECT SINGLE parat
*          FROM zvcxi_p3e_td110
*          INTO @lv_parat
*          WHERE prodh = ( SELECT prdha FROM mara WHERE matnr = @lv_matnr )
*          AND werks = @lv_werks.
*      ENDIF.

      "Buscamos la OF de grafo ppal
      SELECT SINGLE maufnr, lead_aufnr, prodnet, arsps "JVM - add 28/08/2023
        FROM afko WHERE aufnr EQ @i_aufnr "JVM - add 28/08/2023
        INTO ( @DATA(lv_maufnr), @DATA(lead), @DATA(prodnet), @DATA(lv_posreserva) ) . "JVM - add 28/08/2023
      DATA(lv_subrc_mauf) = sy-subrc.

      IF lv_maufnr IS NOT INITIAL.
        SELECT SINGLE plnbez FROM caufv INTO @DATA(lv_material_superior)
          WHERE aufnr = @lv_maufnr.

        SELECT SINGLE cuobj INTO @DATA(lv_cuobj_padre)
          FROM marc
          WHERE matnr = @lv_material_superior
          AND werks = @lv_werks.
      ENDIF.

      SELECT SINGLE parat INTO @DATA(lv_parat)
        FROM yhp_idx_td101
        WHERE matnr = @lv_matnr
        AND cuobj = @lv_cuobj_padre.
      "JVM FIN ADD - Sustitución de tabla 28/06/2024
      wa_orderdata-assemblyqtypart = lv_parat. "JVM - add 28/08/2023
      CONDENSE wa_orderdata-assemblyqtypart NO-GAPS."JVM - add 28/08/2023

*      SELECT SINGLE maufnr, lead_aufnr, prodnet, arsps "JVM - add 28/08/2023
*         FROM afko WHERE aufnr EQ @i_aufnr "JVM - add 28/08/2023
*        INTO ( @DATA(lv_maufnr), @DATA(lead), @DATA(prodnet), @DATA(lv_posreserva) ) . "JVM - add 28/08/2023
      IF lv_subrc_mauf <> 0. "JVM - add 28/08/2023
        CLEAR lv_maufnr. "JVM - add 28/08/2023
      ELSE. "JVM - add 28/08/2023
        wa_orderdata-assemblyid = |{ lv_maufnr ALPHA = OUT }|. "JVM - add 28/08/2023
        IF lv_maufnr IS INITIAL."JVM - add 28/08/2023
          wa_orderdata-assemblyid = |{ i_aufnr ALPHA = OUT }|. "JVM - add 28/08/2023
        ENDIF."JVM - add 28/08/2023
        IF lead IS INITIAL. "JVM - add 28/08/2023
          wa_orderdata-assemblytotalparts = 1. "JVM - add 28/08/2023
        ELSE. "JVM - add 28/08/2023
          wa_orderdata-assemblytotalparts = lv_posreserva + 1. "JVM - add 28/08/2023
        ENDIF. "JVM - add 28/08/2023
      ENDIF. "JVM - add 28/08/2023
    ENDIF. "FJVM - ADD 07/11/2023 No enviar en XATIVA si no son OF's de grafo
  ENDIF. "JVM - add 28/08/2023
  wa_orderdata-ccordertype = it_header[ 1 ]-auart."order_type.
  wa_orderdata-combinationid = ''.
  wa_orderdata-sopmargin = ''.
  SELECT SINGLE t1~kdmat INTO @DATA(lv_cus_mat)
        FROM knmt AS t1 INNER JOIN vbak AS t2 ON t1~kunnr EQ t2~kunnr
        INNER JOIN vbap AS t3 ON t1~matnr EQ t3~matnr AND t2~vbeln EQ t3~vbeln
*    INNER JOIN afpo AS t4 ON t3~vbeln EQ t4~kdauf AND t3~posnr EQ t4~kdpos
*    WHERE t4~aufnr EQ @lv_number.
        WHERE t2~vbeln EQ @lv_vbeln
        AND posnr EQ @lv_posnr.
  IF sy-subrc <> 0 OR lv_cus_mat IS INITIAL.
    lv_cus_mat = wa_vbap-matnr.
    IF lv_cus_mat IS INITIAL.
      lv_cus_mat = it_header[ 1 ]-plnbez."material.
    ENDIF.
  ENDIF.
  wa_orderdata-cusarticlenr = lv_cus_mat.
  wa_orderdata-cuscomments = ''.
*  SELECT SINGLE t1~* INTO @DATA(lv_vbkd)
*    FROM vbkd AS t1 INNER JOIN afpo AS t2 ON t1~vbeln EQ t2~kdauf
*    WHERE t2~aufnr EQ @lv_number.
  wa_orderdata-cusorderref = wa_vbkd-bstkd.
*  wa_orderdata-cuspriority = wa_knvv-klabc. "Mail CAsenjo Jue 18/01/2024 - 19:24 - Convertir Clasificacion ABC en numérico A = 0 B = 3 C= 6 D =9
  CASE wa_knvv-klabc.
    WHEN 'A'.
      wa_orderdata-cuspriority = 0.
    WHEN 'B'.
      wa_orderdata-cuspriority = 3.
    WHEN 'C'.
      wa_orderdata-cuspriority = 6.
    WHEN 'D'.
      wa_orderdata-cuspriority = 9.
    WHEN OTHERS.
  ENDCASE.
  READ TABLE it_vbpa INTO DATA(wa_vbpa) WITH KEY parvw = 'Y0'.
  IF sy-subrc = 0.
    SELECT SINGLE name1, name2 INTO @DATA(wa_name) FROM lfa1 WHERE lifnr EQ @wa_vbpa-lifnr.
  ENDIF.
*  CONCATENATE wa_vbpa-lifnr wa_name-name1 wa_name-name2 INTO wa_orderdata-cussalesrep SEPARATED BY space.
  CONCATENATE wa_name-name1 wa_name-name2 INTO wa_orderdata-cussalesrep SEPARATED BY space.
  CONDENSE wa_orderdata-cussalesrep.

  wa_orderdata-customerid = wa_vbak-kunnr.

  READ TABLE it_vbpa WITH KEY parvw = 'WE' INTO wa_vbpa.
  IF sy-subrc = 0.
*    SELECT SINGLE name1 INTO wa_orderdata-deliveryid FROM kna1 WHERE kunnr EQ wa_vbpa-kunnr.
    wa_orderdata-deliveryid = wa_vbpa-kunnr.
    SELECT SINGLE remark INTO wa_orderdata-dlycomments
    FROM adrc AS t1 INNER JOIN kna1 AS t2 ON t1~addrnumber EQ t2~adrnr
    INNER JOIN adrct AS t3 ON t1~addrnumber EQ t3~addrnumber
    AND t1~date_from EQ t3~date_from
    AND t1~nation EQ t3~nation
    WHERE kunnr EQ wa_vbpa-kunnr.
  ELSE.
    wa_orderdata-dlycomments = ''.
  ENDIF.
  IF wa_vbep-lddat IS INITIAL.
    wa_vbep-lddat = sy-datum.
  ENDIF.
  IF wa_vbep-edatu IS INITIAL.
    wa_vbep-edatu = sy-datum.
  ENDIF.

  IF wa_vbep-mbdat IS INITIAL.
    wa_vbep-mbdat = sy-datum.
  ENDIF.

  DATA: et_td100 TYPE  yhp_omp_tt_td100,
        et_td101 TYPE  yhp_omp_tt_td101,
        et_td110 TYPE  yhp_omp_tt_td110,
        et_td111 TYPE  yhp_omp_tt_td111,
        et_td130 TYPE  yhp_omp_tt_td130,
        et_td131 TYPE  yhp_omp_tt_td131,
        et_td140 TYPE  yhp_omp_tt_td140,
        et_td150 TYPE  yhp_omp_tt_td150,
        et_td151 TYPE  yhp_omp_tt_td151,
        et_td310 TYPE  yhp_omp_tt_td310,
*        et_td400 TYPE  yhp_omp_tt_td400,
        et_bom   TYPE  yhp_omp_tt_bom,
        et_rte   TYPE  yhp_omp_tt_rte.
  CLEAR: et_td100, et_td101, et_td110, et_td111, et_td130, et_td131, et_td140, et_td150, et_td151, et_td310, et_bom, et_rte.
  REFRESH: et_td100, et_td101, et_td110, et_td111, et_td130, et_td131, et_td140, et_td150, et_td151, et_td310, et_bom, et_rte.

  SELECT SINGLE cuobj INTO @DATA(lv_cuobj) FROM marc WHERE matnr EQ @lv_matnr AND werks EQ @lv_werks.

  CALL FUNCTION 'YHP_OMP_INTERFACE'
    EXPORTING
      if_cuobj = lv_cuobj
    IMPORTING
      et_td100 = et_td100
      et_td101 = et_td101
      et_td110 = et_td110
      et_td111 = et_td111
      et_td130 = et_td130
      et_td131 = et_td131
      et_td140 = et_td140
      et_td150 = et_td150
      et_td151 = et_td151
      et_td310 = et_td310
*     et_td400 = et_td400
      et_bom   = et_bom
      et_rte   = et_rte.

  DATA: it_num_opers TYPE TABLE OF ty_num_opers,
        it_rutas     TYPE TABLE OF ty_ruta,
        ruta_ppal    TYPE yhp_omp_route.

  CLEAR ruta_ppal.

*  PERFORM check_alt_routes TABLES it_num_opers
*                                  it_rutas
*                                  et_rte
*                                  it_operation_all
*                         CHANGING ruta_ppal.
*  IF 1 = 2.
*  PERFORM check_alt_routes_2 TABLES it_num_opers
*                                  it_rutas
*                                  et_rte
*                                  it_operation_all
*                         CHANGING ruta_ppal.
*  IF 1 = 2.
  PERFORM check_alt_routes_3 TABLES it_num_opers
                                  it_rutas
                                  et_rte
                                  it_operation_all
                         CHANGING ruta_ppal.
*  ENDIF.
*  ENDIF.
*
*  CLEAR: it_num_opers[], it_rutas[].
*  DATA: num_opers TYPE p.
*  LOOP AT et_rte ASSIGNING FIELD-SYMBOL(<rte>).
*    READ TABLE it_num_opers ASSIGNING FIELD-SYMBOL(<fs_num>) WITH KEY route = <rte>-route.
*    IF sy-subrc <> 0.
*      num_opers = 1.
*      APPEND INITIAL LINE TO it_num_opers ASSIGNING FIELD-SYMBOL(<num_oper>).
*      <num_oper>-route = <rte>-route.
*      <num_oper>-num_opers = num_opers.
*    ELSE.
*      ADD 1 TO <fs_num>-num_opers.
*    ENDIF.
*  ENDLOOP.
*
*  "Vemos si tiene rutas alternativas
*  DESCRIBE TABLE it_operation_all LINES DATA(operaciones_of).
*  "Recorremos lo que viene de la función de AICOMP para ver cuales son las que no se corresponden con las de la OF y ver si tiene ruta alternativa o maquinas alternativas
*  LOOP AT et_rte ASSIGNING <rte> GROUP BY ( route = <rte>-route ).
*    READ TABLE it_num_opers WITH KEY route = <rte>-route ASSIGNING <fs_num>.
*    IF <fs_num>-num_opers EQ operaciones_of.
*      "Si tiene el mismo número de operaciones que la OF, como mucho podrá tener máquinas alternativas
*      "si tiene diferente número, serán rutas alternativas.
*      LOOP AT GROUP <rte> ASSIGNING FIELD-SYMBOL(<rte_pos>).
*        SELECT SINGLE objid INTO @DATA(lv_arbid) FROM crhd WHERE arbpl = @<rte>-arbpl AND werks EQ @<rte>-werks.
*        READ TABLE it_operation_all ASSIGNING FIELD-SYMBOL(<opall>) WITH KEY plnnr = <rte>-plnnr vornr = <rte>-vornr arbid = lv_arbid.
*        IF sy-subrc <> 0.
*          "Esta maquina no se ha enviado, es una máquina alternativa para la operación
*          APPEND INITIAL LINE TO it_rutas ASSIGNING FIELD-SYMBOL(<ruta_alt>).
*          MOVE-CORRESPONDING <rte_pos> TO <ruta_alt>.
*          CLEAR <ruta_alt>-ruta_alt.
*          <ruta_alt>-maq_alt = abap_true.
*        ENDIF.
*        CLEAR lv_arbid.
*      ENDLOOP.
*    ELSE.
*      "Es una ruta alternativa
*      LOOP AT GROUP <rte> ASSIGNING <rte_pos>.
*        APPEND INITIAL LINE TO it_rutas ASSIGNING <ruta_alt>.
*        MOVE-CORRESPONDING <rte_pos> TO <ruta_alt>.
*        CLEAR <ruta_alt>-maq_alt.
*        <ruta_alt>-ruta_alt = abap_true.
*      ENDLOOP.
*    ENDIF.
*
*  ENDLOOP.



  READ TABLE et_td100 INTO DATA(wa_homologacion) INDEX 1.
  IF wa_vbep-lddat > wa_vbep-edatu.
    wa_vbep-lddat = wa_vbep-edatu.
  ENDIF.
*  wa_orderdata-earliestpromiseddispdate = |{ wa_vbep-lddat+6(2) }/{ wa_vbep-lddat+4(2) }/{ wa_vbep-lddat+(4) },00:00:01|.
*  wa_orderdata-erpregistrationdate = wa_orderdata-earliestpromiseddlydate = |{ wa_vbep-mbdat+6(2) }/{ wa_vbep-mbdat+4(2) }/{ wa_vbep-mbdat+(4) },21:00:00|.
*  wa_orderdata-erpregistrationdate = wa_orderdata-earliestpromiseddlydate = |{ it_header[ 1 ]-gltrs+6(2) }/{ it_header[ 1 ]-gltrs+4(2) }/{ it_header[ 1 ]-gltrs+(4) },21:00:00|."JMV - 29/04/2024 enviar fecha fin extrema
  DATA lv_fecha_envio TYPE datum.
*  lv_fecha_envio = it_header[ 1 ]-gltrp - it_header[ 1 ]-sichz."JMV - 29/04/2024 enviar fecha fin extrema SE DESCARTA ESTO EN 30/05/2024
  lv_fecha_envio = it_header[ 1 ]-gltrs.
  wa_orderdata-erpregistrationdate = wa_orderdata-earliestpromiseddlydate = |{ lv_fecha_envio+6(2) }/{ lv_fecha_envio+4(2) }/{ lv_fecha_envio+(4) },21:00:00|."JMV - 29/04/2024 enviar fecha fin extrema

  wa_orderdata-earliestrequesteddate = space.
  wa_orderdata-erplastmodificationdate = space.
  wa_orderdata-erpcleanupisallowed = 'YES'.
  wa_orderdata-erplaunchdate = ''.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = lv_erporderid
    IMPORTING
      output = lv_erporderid.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = lv_erporderidp
    IMPORTING
      output = lv_erporderidp.

  wa_orderdata-erporderid = lv_erporderid && '-' && lv_erporderidp. "JVM - mail de Carlso Asenjo 15/12/2022, cambiar por concatenado con la posicion
  wa_orderdata-erporderpartnr = lv_posnr.
  wa_orderdata-erpordertotalparts = ''.
  wa_orderdata-erpplantid = it_header[ 1 ]-werks."production_plant.
  CASE wa_homologacion-hflag.
    WHEN 'X'.
      wa_orderdata-firstordersincearticlechanged = 'yes'."wa_homologacion-hflag. "Firstordersincearticlechanged  Primera orden desde que se creo el articulo en ERP. Vacío o "NO".
    WHEN OTHERS.
      wa_orderdata-firstordersincearticlechanged = 'no'.
  ENDCASE.
  "Preguntar a hinojosa	X	Carlos ve con Aicomp si sale a tabla el campo homologacion
  "JVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
  READ TABLE et_td100 INTO DATA(wa_td100_gap11) INDEX 1.
*  wa_orderdata-fixedgrade = ''.
  IF wa_td100_gap11-boars = 'X'.
    wa_orderdata-fixedgrade = 'yes'.
  ELSE.
    wa_orderdata-fixedgrade = 'no'.
  ENDIF.
  "FJVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios

*  wa_orderdata-latestpromiseddispdate = wa_orderdata-earliestpromiseddispdate = |{ wa_vbep-lddat+6(2) }/{ wa_vbep-lddat+4(2) }/{ wa_vbep-lddat+(4) },00:00:01|."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022
*  wa_orderdata-latestpromiseddispdate = wa_orderdata-earliestpromiseddispdate = |{ wa_vbep-mbdat+6(2) }/{ wa_vbep-mbdat+4(2) }/{ wa_vbep-mbdat+(4) },21:00:00|."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022
*  wa_orderdata-latestpromiseddispdate = wa_orderdata-earliestpromiseddispdate = |{ it_header[ 1 ]-gltrs+6(2) }/{ it_header[ 1 ]-gltrs+4(2) }/{ it_header[ 1 ]-gltrs+(4) },21:00:00|.."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022"JMV - 29/04/2024
*enviar fecha fin extrema

  wa_orderdata-latestpromiseddispdate = wa_orderdata-earliestpromiseddispdate = |{ lv_fecha_envio+6(2) }/{ lv_fecha_envio+4(2) }/{ lv_fecha_envio+(4) },21:00:00|.."JMV - 29/04/2024 enviar fecha fin extrema
  wa_orderdata-latestpromiseddlydate =
*  wa_orderdata-latestrequesteddate = |{ wa_vbep-edatu+6(2) }/{ wa_vbep-edatu+4(2) }/{ wa_vbep-edatu+(4) },00:00:00|."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022
*  wa_orderdata-latestrequesteddate = |{ wa_vbep-mbdat+6(2) }/{ wa_vbep-mbdat+4(2) }/{ wa_vbep-mbdat+(4) },21:00:00|."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022
*  wa_orderdata-latestrequesteddate = |{ it_header[ 1 ]-gltrs+6(2) }/{ it_header[ 1 ]-gltrs+4(2) }/{ it_header[ 1 ]-gltrs+(4) },21:00:00|.."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022"JMV - 29/04/2024 enviar fecha fin extrema
  wa_orderdata-latestrequesteddate = |{ lv_fecha_envio+6(2) }/{ lv_fecha_envio+4(2) }/{ lv_fecha_envio+(4) },21:00:00|.."JVM - Modif, nos piden pasar el MBDAT - 29/11/2022"JMV - 29/04/2024 enviar fecha fin extrema
  DATA gamng_aux TYPE afko-gamng.   " add jtm 01.11.2022
  gamng_aux =
  wa_orderdata-orderedqty = it_header[ 1 ]-gamng."target_quantity.
*  wa_orderdata-orderid = it_header[ 1 ]-aufnr."order_number.
  IF ( it_header[ 1 ]-auart EQ 'ZPAC' AND it_header[ 1 ]-aufnr < 40024195 ) OR ( it_header[ 1 ]-auart EQ 'ZSAR' AND it_header[ 1 ]-aufnr < 50006649 ).
    wa_orderdata-orderid = it_header[ 1 ]-aufnr."order_number.
  ELSE.
    wa_orderdata-orderid = |{ it_header[ 1 ]-aufnr ALPHA = OUT }|."order_number.
  ENDIF.
  CONDENSE wa_orderdata-orderid NO-GAPS.

  wa_orderdata-orderrequestid = ''.
  wa_orderdata-plaproductid = ''.

  SELECT SINGLE * INTO @DATA(wa_mara) FROM mara WHERE matnr EQ @lv_matnr.
  SELECT SINGLE * INTO @DATA(wa_marc) FROM marc WHERE matnr EQ @lv_matnr AND werks EQ @lv_werks.
  SELECT SINGLE lgnum INTO wa_orderdata-prefwhid FROM t320 WHERE werks EQ lv_werks AND lgort EQ lv_lgort.
  wa_orderdata-processvalidity = 'restricted'.
  wa_orderdata-productid = it_header[ 1 ]-plnbez."material.
  wa_orderdata-qtlabtestsrequired = ''.
  wa_orderdata-qtspecification = ''.


*** IGNORAR, NO ES NECESARIO EL CAMBIO
***  "JVM - ADD 07/10/2024 - Enviar tolerancia por defecto en pedidos de traslado
***  IF wa_vbap IS INITIAL.
***    IF wa_grafo IS NOT INITIAL.
***      SELECT SINGLE t1~uebto, t1~untto INTO @DATA(wa_tolerancia)
***        FROM knvv AS t1 INNER JOIN vbak AS t2
***          ON t1~kunnr = t2~kunnr AND t1~vkorg = t2~vkorg AND t1~vtweg = t2~vtweg
***        INNER JOIN afpo AS t3 ON t3~kdauf = t2~vbeln
***        WHERE t3~aufnr = @wa_grafo-lead_aufnr
***        AND kdauf <> @space
***        AND xloek = @space.
***    ELSE.
***      SELECT SINGLE t1~uebto, t1~untto INTO @wa_tolerancia
***        FROM knvv AS t1 INNER JOIN vbak AS t2
***          ON t1~kunnr = t2~kunnr AND t1~vkorg = t2~vkorg AND t1~vtweg = t2~vtweg
***        INNER JOIN afpo AS t3 ON t3~kdauf = t2~vbeln
***        WHERE t3~aufnr = @lv_number
***        AND kdauf <> @space
***        AND xloek = @space.
***    ENDIF.
***    IF sy-subrc = 0.
***      wa_vbap-uebto = wa_tolerancia-uebto.
***      wa_vbap-untto = wa_tolerancia-untto.
***    ENDIF.
***  ENDIF.
***  "JVM - ADD 07/10/2024 - Enviar tolerancia por defecto en pedidos de traslado
*** FIN IGNORAR, NO ES NECESARIO EL CAMBIO

  DATA: lv_ebeln TYPE ebeln,
        lv_ebelp TYPE ebelp.
  lv_ebeln = it_header[ 1 ]-zzsubco_ebeln.
  lv_ebelp = it_header[ 1 ]-zzsubco_ebelp.
  PERFORM get_max_min_po USING lv_ebeln lv_ebelp
                         CHANGING wa_vbap-uebto
                                  wa_vbap-untto.


  wa_orderdata-qtymaxperc = 100 + wa_vbap-uebto.
*  IF wa_vbap-uebto < 100 OR wa_vbap-untto IS INITIAL OR wa_vbap-untto EQ 0.
*    "Como mínimo debe ser 100 por exigencia de OMP
*    wa_orderdata-qtymaxperc = 100.
*  ENDIF.
  wa_orderdata-qtyminperc = 100 - wa_vbap-untto.
*  IF wa_vbap-untto > 100 OR wa_vbap-untto IS INITIAL OR wa_vbap-untto EQ 0.
*    "Debe ser menor o igual a 100 por exigencia de OMP
*    wa_orderdata-qtyminperc = 100.
*  ENDIF.
  wa_orderdata-qtytargetperc = '100'.
  wa_orderdata-reservationlabel = ''.
*  Precio de venta. Suma de KONV-KWERT para VBAK-KNUMV = KONV-KNUMV AND KONV-KPOSN = VBAP-POSNR
  SELECT SUM( kwert ) INTO @DATA(lv_precio)
        FROM konv
        WHERE knumv = @wa_vbak-knumv
        AND kposn = @wa_vbap-posnr
        AND kschl = 'ZPRC'.
  wa_orderdata-salesprice = lv_precio.

  "Sheetlineorder en ccorder de orders. No habíamos comentado pero es sencillo. Si sólo una
  "operación = ondulado (no se si hay parámetro en el puesto de trabajo y así funcionará para resto de plantas), enviar YES
  DATA lv_numoper TYPE i.
  CLEAR lv_numoper.
  LOOP AT it_operation INTO DATA(wa_numoper).
    lv_numoper = lv_numoper + 1.
  ENDLOOP.
  IF lv_numoper = 1.
    "Comprobamos si la operación es onduladora
    SELECT SINGLE arbpl INTO @DATA(lv_arbpl) FROM crhd WHERE objid EQ @wa_numoper-arbid AND objty EQ 'A'.
    CONCATENATE lv_werks lv_arbpl INTO DATA(lv_busqueda) .
    CONDENSE lv_busqueda NO-GAPS.
    "Buscamos en tablas AICOMP
    DATA lv_machinetype TYPE /vcxi/vsmc_imtyp.
    CLEAR lv_machinetype.
    PERFORM get_machine_type USING lv_busqueda CHANGING lv_machinetype.
    IF lv_machinetype EQ 'PC_MT_CORR'.
      wa_orderdata-sheetlineorder = 'YES'.
    ELSE.
      wa_orderdata-sheetlineorder = ''.
    ENDIF.

  ENDIF.
  l_edidd-sdata = wa_orderdata.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderdata )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.


  "ADD JVM - Añadir datos de clientepara OFs inferiores de grafo
  IF lv_vbeln IS INITIAL AND wa_grafo IS NOT INITIAL.
    SELECT SINGLE kdauf INTO @DATA(vl_vbeln) FROM afpo WHERE aufnr = @wa_grafo-lead_aufnr AND kdauf <> @space AND xloek = @space.
    IF sy-subrc = 0.
      SELECT * INTO TABLE @it_vbpa FROM vbpa WHERE vbeln EQ @vl_vbeln.
    ENDIF.
  ENDIF.
  "ADD JVM - Añadir datos de clientepara OFs inferiores de grafo

  READ TABLE it_vbpa WITH KEY parvw = 'AG' INTO wa_vbpa.
*  wa_Customerdata    Todos los datos se rescatan de la función de interlocutor AG O VBAK-KUNNR #¡VALOR!
*	wa_Customerdata-AccountMgr = Nombre del responsable de la cuenta. VBPA-LIFNR para VBPA-PARVW = 'Y0' AND VBPA-VBELN = VBAK-VBELN	#¡VALOR!
  READ TABLE it_vbpa INTO DATA(wa_manager) WITH KEY parvw = 'Y0'.
  IF sy-subrc = 0.
    SELECT SINGLE name1, name2 INTO @wa_name FROM lfa1 WHERE lifnr EQ @wa_manager-lifnr.
  ENDIF.
  CONCATENATE wa_manager-lifnr wa_name-name1 wa_name-name2 INTO wa_customerdata-accountmgr SEPARATED BY space.
  CONDENSE wa_customerdata-accountmgr.

  SELECT SINGLE * INTO @DATA(wa_adrc) FROM adrc WHERE addrnumber = @wa_vbpa-adrnr.
  wa_customerdata-address = |{ wa_adrc-street }|."calle y numero KNA1-STRAS entrando por VBAK-KUNNR
****  wa_Customerdata-Comments  Comentarios a nivel de pedido para el material
  IF wa_vbpa-kunnr IS NOT INITIAL.
    SELECT SINGLE * INTO @DATA(wa_knvk) FROM knvk WHERE kunnr = @wa_vbpa-kunnr.
    SELECT SINGLE * INTO @DATA(wa_kna1) FROM kna1 WHERE kunnr EQ @wa_vbpa-kunnr.
  ENDIF.
  wa_customerdata-contactname	= wa_knvk-name1."Persona de contacto del cliente. KNVK-NAME1 (O NAMEV si está vacío) para KNVK-KUNNR = VBAK-KUNNR
  IF wa_customerdata-contactname IS INITIAL.
    wa_customerdata-contactname = wa_knvk-namev.
    REPLACE ALL OCCURRENCES OF '"' IN wa_customerdata-contactname WITH ''.
  ENDIF.
  wa_customerdata-contacttel  = wa_knvk-telf1."KNVK-TELF1 para KNVK-KUNNR = VBAK-KUNNR
  wa_customerdata-country	= wa_kna1-land1."KNA1-LAND1 para KNA1-KUNNR = VBAK-KUNNR
  wa_customerdata-customergroup = wa_kna1-ktokd." KNA1-KTOKD para KNA1-KUNNR = VBAK-KUNNR
  wa_customerdata-customerid  = wa_kna1-kunnr."Numero de cliente en SAP. AFPO-KUNNR

  "ADD JVM - 03/10/2024 - No se recibe el customerid en OMP si falta en segmento ORDERDATA
  IF wa_grafo IS NOT INITIAL AND vl_vbeln IS NOT INITIAL.
    READ TABLE t_edidd ASSIGNING FIELD-SYMBOL(<modif>) WITH KEY segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderdata )->get_relative_name( ).
    IF sy-subrc = 0.
      DATA(modif) = wa_orderdata.
      modif = <modif>-sdata.
      modif-customerid = wa_customerdata-customerid.
      "ADD 18/10/2024 - Lo del delivery es para que no nos genere falsos negativos ya que el devlivery en traslados, subcos o grafos nos da igual. Como si quitas el segmento entero. O como si coges el customerid
      modif-deliveryid = wa_customerdata-customerid.

      <modif>-sdata = modif.
    ENDIF.
  ENDIF.
  "FIN ADD JVM - 03/10/2024 - No se recibe el customerid en OMP si falta en segmento ORDERDATA

  SELECT SINGLE t1~* INTO @DATA(wa_adr6) FROM adr6 AS t1 INNER JOIN kna1 AS t2 ON t1~addrnumber EQ t2~adrnr AND flgdefault = 'X' AND kunnr EQ @wa_vbpa-kunnr.
  wa_customerdata-email = wa_adr6-smtp_addr."adr6-smtp_addr para adr6-addrnumber = kna1-adrnr and adr6-flgdefault = 'X' and kna1-kunnr = vbak-kunnr
  IF wa_kna1-stcd1 IS NOT INITIAL.
    wa_customerdata-enterprisenr  = wa_kna1-stcd1.
  ELSEIF wa_kna1-stcd2 IS NOT INITIAL.
    wa_customerdata-enterprisenr  = wa_kna1-stcd2.
  ELSE.
    wa_customerdata-enterprisenr  = wa_kna1-stceg.
  ENDIF."KNA1-STCD1 <> SPACE OR KNA1-STCD2 <> SPACE OR KNA1-STCEG <> SPACE
  wa_customerdata-fax = wa_kna1-telfx."KNA1-TELFX para KNA1-KUNNR = VBAK-KUNNR
  wa_customerdata-name  = wa_kna1-name1."Nombre del cliente. KNA1-NAME1 PARA VBAK-KUNNR = KNA1-KUNNR
  REPLACE ALL OCCURRENCES OF '"' IN wa_customerdata-name WITH ''.
  wa_customerdata-postzip = wa_kna1-pstlz."codigo postal KNA1-PSTLZ
  wa_customerdata-tel = wa_kna1-telf1."Telefono cliente KNA1-TELF1
  SELECT SINGLE t1~bezei INTO @DATA(lv_comunidad)
        FROM t005u AS t1 INNER JOIN kna1 AS t2 ON t1~land1 EQ t2~land1
        AND t1~bland EQ t2~regio AND t1~spras EQ 'S'
        WHERE t2~kunnr EQ @wa_vbpa-kunnr."T005U-BEZEI cuando T005U-SPRAS = 'S' AND T005U-LAND1 = KNA1-LAND1 AND T005U-BLAND = KNA1-REGIO AND KNA1-KUNNR = VBAK-KUNNR
  wa_customerdata-town = lv_comunidad."Comunidad autónoma. T005U-BEZEI cuando T005U-SPRAS = 'S' AND T005U-LAND1 = KNA1-LAND1 AND T005U-BLAND = KNA1-REGIO AND KNA1-KUNNR = VBAK-KUNNR
  wa_customerdata-vat = wa_customerdata-enterprisenr."KNA1-STCD1 <> SPACE OR KNA1-STCD2 <> SPACE OR KNA1-STCEG <> SPACE


  "ADD JVM - 11/11/2024 - añadir datos almacen y cliente en imputados
  SELECT SINGLE bsart FROM ekko INTO @DATA(lv_bsart) WHERE ebeln = @lv_ebeln.
  "FIN JVM - 11/11/2024 - añadir datos almacen y cliente en imputados

  "ADD JVM - 03/10/2024 - Enviar nombre del centro de montaje cuando viene de pedido de traslado
  IF wa_customerdata IS INITIAL OR lv_bsart = 'ZPE2'.
    SELECT SINGLE lgobe, t1~lgort, t2~zzcliente, t6~name1
    FROM t001l AS t1
      INNER JOIN ekpo AS t2 ON t1~lgort = t2~lgort
      INNER JOIN aufk AS t3 ON t2~ebeln = t3~zzsubco_ebeln AND t2~ebelp = t3~zzsubco_ebelp
      INNER JOIN afpo AS t4 ON t3~aufnr = t4~aufnr
      LEFT OUTER JOIN vbak AS t5 ON t4~kdauf = t5~vbeln
      LEFT OUTER JOIN kna1 AS t6 ON t5~kunnr = t6~kunnr
    INTO @DATA(wa_almacen)
    WHERE t3~aufnr = @lv_aufnr
    AND zzsubco_ebeln <> @space
    AND zzsubco_ebelp <> @space.
    IF sy-subrc <> 0.
      "JVM - Incidencia con envío de nombre de cliente
      SELECT SINGLE lgobe, t1~lgort, t2~zzcliente
          FROM t001l AS t1
          INNER JOIN ekpo AS t2 ON t1~lgort = t2~lgort
          INNER JOIN zsppt_ofpedsubco AS t3 ON t2~ebeln = t3~ebeln AND t2~ebelp = t3~ebeln
          INTO CORRESPONDING FIELDS OF @wa_almacen
          WHERE t3~aufnr = @lv_aufnr.
      IF sy-subrc = 0.
        SELECT SINGLE t6~name1
          FROM aufk AS t3
          INNER JOIN afpo AS t4 ON t3~aufnr = t4~aufnr
          LEFT OUTER JOIN vbak AS t5 ON t4~kdauf = t5~vbeln
          LEFT OUTER JOIN kna1 AS t6 ON t5~kunnr = t6~kunnr
          INTO @DATA(wa_al_aux)
          WHERE t3~aufnr = @lv_aufnr.
        IF sy-subrc = 0 AND wa_al_aux IS NOT INITIAL.
          wa_almacen-name1 = wa_al_aux.
        ENDIF.
      ENDIF.
      "FIN JVM - Incidencia con envío de nombre de cliente
    ENDIF.
    IF sy-subrc = 0.
      IF lv_bsart = 'ZPE2'.
        wa_almacen-zzcliente = wa_customerdata-customerid.
      ENDIF.
      IF wa_almacen-name1 IS INITIAL AND wa_almacen-zzcliente IS NOT INITIAL.
        SELECT SINGLE name1 FROM kna1 WHERE kunnr = @wa_almacen-zzcliente INTO @wa_almacen-name1.
      ENDIF.
      IF wa_almacen-zzcliente IS NOT INITIAL.
        wa_almacen-zzcliente = |{ wa_almacen-zzcliente ALPHA = OUT }|.
        CONDENSE wa_almacen-zzcliente.
        wa_customerdata-customerid  = |{ wa_almacen-lgort }{ wa_almacen-zzcliente }|.
        wa_customerdata-name = |{ wa_almacen-lgobe } { wa_almacen-name1 }|.
      ELSE.
        wa_customerdata-customerid  = wa_almacen-lgort.
        wa_customerdata-name = wa_almacen-lgobe.
      ENDIF.


      "ADD JVM - 03/10/2024 - No se recibe el customerid en OMP si falta en segmento ORDERDATA
      READ TABLE t_edidd ASSIGNING <modif> WITH KEY segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderdata )->get_relative_name( ).
      IF sy-subrc = 0.
        modif = wa_orderdata.
        modif = <modif>-sdata.
        modif-customerid = wa_customerdata-customerid.

        "ADD 18/10/2024 - Lo del delivery es para que no nos genere falsos negativos ya que el devlivery en traslados, subcos o grafos nos da igual. Como si quitas el segmento entero. O como si coges el customerid
        modif-deliveryid = wa_customerdata-customerid.

        <modif>-sdata = modif.
      ENDIF.
      "FIN ADD JVM - 03/10/2024 - No se recibe el customerid en OMP si falta en segmento ORDERDATA

    ENDIF.
  ENDIF.
  "FIN JVM - 03/10/2024 - Enviar nombre del centro de montaje cuando viene de pedido de traslado

  IF wa_customerdata IS NOT INITIAL.

    CLEAR l_edidd.

    wa_customer-operation	= c_replace.
    l_edidd-sdata = wa_customer.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_customer )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.

    l_edidd-sdata = wa_customerdata.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_customerdata )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.
  ENDIF.
**  CcDelivery      #¡VALOR!
**  Operation REPLACE #¡VALOR!


**  CcDeliverydata    Todos los datos se rescatan de la función de interlocutor WE  #¡VALOR!
  CLEAR: wa_adrc, wa_knvk, wa_kna1, wa_vbpa.
  READ TABLE it_vbpa WITH KEY parvw = 'WE' INTO wa_vbpa.
  IF sy-subrc = 0.
    CLEAR l_edidd.
    wa_delivery-operation = c_replace.
    l_edidd-sdata = wa_delivery.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_delivery )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.

    SELECT SINGLE * INTO @wa_adrc FROM adrc WHERE addrnumber = @wa_vbpa-adrnr.
    SELECT SINGLE * INTO @wa_knvk FROM knvk WHERE kunnr = @wa_vbpa-kunnr.
    SELECT SINGLE * INTO @wa_kna1 FROM kna1 WHERE kunnr EQ @wa_vbpa-kunnr.
    wa_deliverydata-deliveryid = wa_orderdata-deliveryid."Mismo delivery ID indicado en el segmento anterior CCORDERDATA-DELIVERYID #¡VALOR!
    IF <modif> IS ASSIGNED."ADD JVM - 10/12/2024 - No se está enviando deliveryId en los grafos inferiores
      IF modif-deliveryid IS NOT INITIAL."ADD JVM - 10/12/2024 - No se está enviando deliveryId en los grafos inferiores
        wa_deliverydata-deliveryid = modif-deliveryid."ADD JVM - 10/12/2024 - No se está enviando deliveryId en los grafos inferiores
      ENDIF."ADD JVM - 10/12/2024 - No se está enviando deliveryId en los grafos inferiores
    ENDIF."ADD JVM - 10/12/2024 - No se está enviando deliveryId en los grafos inferiores
    wa_deliverydata-name = wa_kna1-name1."Mismos datos que en customer pero para interlocutor WE  #¡VALOR!
    wa_deliverydata-address = wa_adrc-street. "Mismos datos que en customer pero para interlocutor WE  #¡VALOR!
    wa_deliverydata-postzip = wa_kna1-pstlz. "Mismos datos que en customer pero para interlocutor WE  #¡VALOR!
    CLEAR lv_comunidad.
    SELECT SINGLE t1~bezei INTO @lv_comunidad
    FROM t005u AS t1 INNER JOIN kna1 AS t2 ON t1~land1 EQ t2~land1
    AND t1~bland EQ t2~regio AND t1~spras EQ 'S'
    WHERE t2~kunnr EQ @wa_vbpa-kunnr.
    wa_deliverydata-town  = lv_comunidad. "Mismos datos que en customer pero para interlocutor WE  #¡VALOR!
    wa_deliverydata-contactname = wa_knvk-name1."mismos datos que en customer pero para interlocutor we  #¡valor!
    IF wa_deliverydata-contactname IS INITIAL.
      wa_deliverydata-contactname = wa_knvk-namev.
    ENDIF.
    SELECT SINGLE name1 INTO @DATA(lv_planta_name) FROM t001w WHERE werks EQ @lv_werks.
    wa_deliverydata-sender  = lv_planta_name. "nombre de la planta donde se fabrica t001w-name1 cuando aufk-werks = t001w-werks  #¡valor!
    wa_deliverydata-country = wa_kna1-land1. "mismos datos que en customer pero para interlocutor we  #¡valor!
*  wa_deliverydata-comments  comentarios en pedido de ventas para la entrega #¡valor!
    wa_deliverydata-condition = |{ wa_vbkd-inco1 } { wa_vbkd-inco2 } { wa_vbkd-inco2_l }|."incoterms si hay. preguntar a hinojosa  x ahora no lo pasamos pero es identificar el campo del incoterm.
    wa_deliverydata-contacttel  = wa_knvk-telf1." mismos datos que en customer pero para interlocutor we  #¡valor!
    CLEAR wa_adr6.
    SELECT SINGLE t1~* INTO @wa_adr6 FROM adr6 AS t1 INNER JOIN kna1 AS t2 ON t1~addrnumber EQ t2~adrnr AND flgdefault = 'X' AND kunnr EQ @wa_vbpa-kunnr.
    wa_deliverydata-email = wa_adr6-smtp_addr. "mismos datos que en customer pero para interlocutor we  #¡valor!
    wa_deliverydata-fax = wa_kna1-telfx." mismos datos que en customer pero para interlocutor we  #¡valor!
    wa_deliverydata-specopening = space."indica si hay horas especiales de entrega. por defecto no o vacío. preguntar a hinojosa  x no relevante
    wa_deliverydata-tel = wa_kna1-telf1."mismos datos que en customer pero para interlocutor we  #¡valor!

    CLEAR l_edidd.
    l_edidd-sdata = wa_deliverydata.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_deliverydata )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.

  ENDIF.


  "ADD JVM - 18/10/2024 - Si no se envía un DELIVERY no hay que enviar un DELIVERYID o fallará
  READ TABLE t_edidd ASSIGNING FIELD-SYMBOL(<f_deliv>) WITH KEY segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_deliverydata )->get_relative_name( ).
  IF sy-subrc <> 0.
    READ TABLE t_edidd ASSIGNING <modif> WITH KEY segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderdata )->get_relative_name( ).
    IF sy-subrc = 0.
      modif = wa_orderdata.
      modif = <modif>-sdata.
      modif-deliveryid = space.
      <modif>-sdata = modif.
    ENDIF.
  ENDIF.
  "FIN ADD JVM - 18/10/2024 - Si no se envía un DELIVERY no hay que enviar un DELIVERYID o fallará


  CLEAR: l_edidd, wa_product.
  wa_product-operation = c_replace.
  l_edidd-sdata = wa_product.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_product )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.
**  cCProduct     #¡VALOR!
**  Operation REPLACE #¡VALOR!
**  cCProductdata     #¡VALOR!
  CLEAR: l_edidd, wa_productdata1, wa_productdata2.
  wa_productdata1-articleref  = it_header[ 1 ]-plnbez."material. "Material de a producir en la orden de fabricación. AUFK-PLNBEZ  #¡VALOR!
  REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-articleref WITH ''.
*wa_productdata1-Atphorizon  Preguntar a Hinojosa  X NO relevante
*wa_productdata1-Bind  Preguntar a Hinojosa  X NO relevante



  READ TABLE et_td100 INTO DATA(wa_td100) INDEX 1.
  "En la versión del VC anterior era un campo que podíamos leer de tabla, pero en la actual no.
  "Podemos leer esto de la jerarquía, del grupo de articulos o del propio código de material. Corresponde al tercer y cuarto digito: IN, TP, TR, PL
  wa_productdata1-ccproducttype = it_header[ 1 ]-plnbez+2(2)."lv_cus_mat+2(2). "Tipo de material en MARA-MTART. Preguntar a hinojosa  X Tipo de producto; Inliner, diecuted. PTYPE de la tabla TD100
  wa_productdata1-closure = wa_td100-joity. " Preguntar a Hinojosa  X JOITY de tabla TD100
*wa_productdata1-COLOR Preguntar a Hinojosa  X NO relevante
  wa_productdata1-comments = wa_td100-obser. " Comentarios de cliente en pedido de ventas O en el registro info para el material. MAX 60 char. Preguntar a hinojosa  X Es el campo de comentarios de producto del VC, preguntar a AICOMP
  SELECT SINGLE stprs, verpr, vprsv, peinh, bwtty INTO @DATA(wa_precio) FROM mbew WHERE matnr EQ @lv_matnr AND bwkey EQ @lv_werks.
  TRY.
      IF wa_precio-vprsv EQ 'S' OR wa_precio-bwtty EQ 'X'.
        TRY.
            wa_productdata1-cost = wa_precio-stprs / wa_precio-peinh. " MBEW-STPRS O MBEW-VERPR según si es estándar O variable MBEW-VPRSV - S O V  #¡VALOR!
          CATCH cx_root.
        ENDTRY.
      ELSE.
        TRY.
            wa_productdata1-cost = wa_precio-verpr / wa_precio-peinh.
          CATCH cx_root.
        ENDTRY.
      ENDIF.

      DATA: "lv_in TYPE meins,
            "lv_out TYPE meins,
            lv_menge TYPE menge_d.

      CLEAR lv_menge.

      CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
        EXPORTING
          i_matnr              = lv_matnr
          i_in_me              = wa_mara-meins
          i_out_me             = 'M2'
          i_menge              = 1
        IMPORTING
          e_menge              = lv_menge
        EXCEPTIONS
          error_in_application = 1
          error                = 2
          OTHERS               = 3.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ELSE.

        TRY.
            wa_productdata1-cost = wa_productdata1-cost / lv_menge.
          CATCH cx_root.
        ENDTRY.
      ENDIF.


    CATCH cx_root.
  ENDTRY.
*wa_productdata1-Dangerousgooddescription  informacion sobre productos peligrosos. N/A preguntar a Hinojosa  X NO relevante
  DATA lv_charmat TYPE char40.
  lv_charmat = |{ lv_matnr ALPHA = OUT }|.
  CONDENSE lv_charmat.
  "INI JVM - 28/05/2024 - pasar documentos de la OF
*  wa_productdata1-drawingref = |{ lv_charmat }.pdf|. " ¿Documentos anexos?¿De donde se recupera esta información? Preguntar a Hinojosa X Numero de material SAP. Pdf
  LOOP AT it_documentos_of ASSIGNING FIELD-SYMBOL(<draw>).
    IF wa_productdata1-drawingref IS INITIAL.
      wa_productdata1-drawingref = |{ <draw>-doknr ALPHA = OUT }|.
    ELSE.
      wa_productdata1-drawingref = wa_productdata1-drawingref && |; { <draw>-doknr ALPHA = OUT }|.
    ENDIF.
  ENDLOOP.
  "FJVM - 28/05/2024 - pasar documentos de la of
  wa_productdata1-erparticletlm = |{ wa_mara-laeda+6(2) }/{ wa_mara-laeda+4(2) }/{ wa_mara-laeda(4) },00:00:00|. "Fecha y hora de la ultima actualización del material en el ERP. 01/01/1980,00:00:00. Preguntar a hinojosa X Lo que indica el campo
  wa_productdata1-erpmaterialid = lv_matnr. "VBAP-MATNR OR AFKO-PLNBEZ  #¡VALOR!
  "JVM - 07/10/2024 Eliminar los ceros para los materiales
  DATA lv_mat_auxi TYPE matnr.
  lv_mat_auxi = wa_productdata1-erpmaterialid.
  wa_productdata1-erpmaterialid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
  "FJVM - 07/10/2024 Eliminar los ceros para los materiales
*wa_productdata1-Fibredirection  Preguntar a Hinojosa  X NO relevante
  wa_productdata1-fsccertificateinfo = wa_td100-fscty. "Preguntar a Hinojosa  X Campo del configurador. NO lo encontramos en el excel pero debe estar en TD100
  REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-fsccertificateinfo WITH ''.
  CASE wa_td100-joipo.
    WHEN 'I'.
      wa_productdata1-glue = 'INTERNAL'. "Información de GLUE, valores NONE, INTERNAL O EXTERNAL preguntar a hinojosa X JOIPO en TD100
    WHEN 'E'.
      wa_productdata1-glue = 'EXTERNAL'.
    WHEN OTHERS.
      wa_productdata1-glue = 'NONE'.
  ENDCASE.

*  LOOP AT et_td110 INTO DATA(wa_semi).
*    SELECT SINGLE mtart INTO @DATA(lv_check_mtart)
*      FROM mara
*        WHERE matnr EQ @wa_semi-board.
*    IF sy-subrc = 0 AND lv_check_mtart EQ 'ZPSE'.
*      SELECT SINGLE cuobj INTO @DATA(lv_obj_sem)
*        FROM marc
*        WHERE matnr EQ @wa_semi-board
*        AND cuobj <> @space.
*      IF sy-subrc = 0.
*
*        DATA: et_td100_aux TYPE  yhp_omp_tt_td100,
*              et_td101_aux TYPE  yhp_omp_tt_td101,
*              et_td110_aux TYPE  yhp_omp_tt_td110,
*              et_td111_aux TYPE  yhp_omp_tt_td111,
*              et_td130_aux TYPE  yhp_omp_tt_td130,
*              et_td131_aux TYPE  yhp_omp_tt_td131,
*              et_td140_aux TYPE  yhp_omp_tt_td140,
*              et_td150_aux TYPE  yhp_omp_tt_td150,
*              et_td151_aux TYPE  yhp_omp_tt_td151,
*              et_td310_aux TYPE  yhp_omp_tt_td310,
*              et_td400_aux TYPE  yhp_omp_tt_td400,
*              et_bom_aux   TYPE  yhp_omp_tt_bom,
*              et_rte_aux   TYPE  yhp_omp_tt_rte.
*        CLEAR: et_td100_aux, et_td101_aux, et_td110_aux, et_td111_aux, et_td130_aux, et_td131_aux, et_td140_aux, et_td150_aux, et_td151_aux, et_td310_aux, et_td400_aux, et_bom_aux, et_rte_aux.
*        REFRESH: et_td100_aux, et_td101_aux, et_td110_aux, et_td111_aux, et_td130_aux, et_td131_aux, et_td140_aux, et_td150_aux, et_td151_aux, et_td310_aux, et_td400_aux, et_bom_aux, et_rte_aux.
*
*        CALL FUNCTION 'YHP_OMP_INTERFACE'
*          EXPORTING
*            if_cuobj = lv_obj_sem
*          IMPORTING
*            et_td100 = et_td100_aux
*            et_td101 = et_td101_aux
*            et_td110 = et_td110_aux
*            et_td111 = et_td111_aux
*            et_td130 = et_td130_aux
*            et_td131 = et_td131_aux
*            et_td140 = et_td140_aux
*            et_td150 = et_td150_aux
*            et_td151 = et_td151_aux
*            et_td310 = et_td310_aux
*            et_td400 = et_td400_aux
*            et_bom   = et_bom_aux
*            et_rte   = et_rte_aux.
*
*        READ TABLE et_td110_aux WITH KEY mboar = 'P' INTO DATA(wa_td110_aux).
*        IF sy-subrc = 0.
*          DATA(lv_grade_sem) = wa_td110_aux-board.
*        ELSE.
*          SELECT SINGLE prboa, calip
*            FROM zvcxi_p1e_td100
*            WHERE matnr = @wa_semi-board
*            AND prboa <> @space
*            INTO ( @lv_grade_sem, @wa_td110_aux-caliper ).
*        ENDIF.
*      ELSE.
*        SELECT SINGLE prboa, calip
*          FROM zvcxi_p1e_td100
*          WHERE matnr = @wa_semi-board
*          AND prboa <> @space
*          INTO ( @lv_grade_sem, @wa_td110_aux-caliper ).
*      ENDIF.
*    ENDIF.
*  ENDLOOP.

*    Si hay info en la TD110 del producto terminado se recupera toda la info de esa tabla
*    Si la TD110 trae el semi como calidad vamos a la YHP_IDX_TD110 a recuperar la info del
*     semi y la tomamos como info del producto terminado
*    Si la TD110 NO trae nada de info vamos a la ZVCXI_P1E_TD100 y pintamos en blanco el ECT
  LOOP AT et_td110 ASSIGNING FIELD-SYMBOL(<fs_110>).
    SELECT SINGLE mtart INTO @DATA(lv_cal_sem)
          FROM mara
          WHERE matnr EQ @<fs_110>-board.
    IF lv_cal_sem EQ 'ZPSE'.
      DATA(lv_hay_semi) = 'X'.
    ENDIF.
    CLEAR lv_cal_sem.
  ENDLOOP.
  IF lv_hay_semi IS NOT INITIAL.
    READ TABLE et_td110 WITH KEY mboar = 'P' INTO DATA(wa_td110).
    SELECT SINGLE prboa, calip
      FROM zvcxi_p1e_td100
      WHERE matnr = @lv_matnr
      AND prboa <> @space
      INTO ( @wa_td110-board, @wa_td110-caliper ).
    CLEAR wa_td110-ect.
  ELSE.
    READ TABLE et_td110 WITH KEY mboar = 'P' INTO wa_td110.
    IF wa_td110-board IS INITIAL OR sy-subrc <> 0.
      SELECT SINGLE prboa, calip
      FROM zvcxi_p1e_td100
      WHERE matnr = @lv_matnr
      AND prboa <> @space
      INTO ( @wa_td110-board, @wa_td110-caliper ).
      CLEAR wa_td110-ect.
    ELSE.
      "Si lo que recupera es un semi
      CLEAR lv_cal_sem.
      SELECT SINGLE mtart INTO @lv_cal_sem
        FROM mara
        WHERE matnr EQ @wa_td110-board.
      IF sy-subrc = 0 AND lv_cal_sem EQ 'ZPSE'.
        SELECT SINGLE cuobj INTO @DATA(lv_obj_sem)
          FROM marc
          WHERE matnr EQ @wa_td110-board
          AND cuobj <> @space.
        IF sy-subrc = 0.

          DATA: et_td100_aux TYPE  yhp_omp_tt_td100,
                et_td101_aux TYPE  yhp_omp_tt_td101,
                et_td110_aux TYPE  yhp_omp_tt_td110,
                et_td111_aux TYPE  yhp_omp_tt_td111,
                et_td130_aux TYPE  yhp_omp_tt_td130,
                et_td131_aux TYPE  yhp_omp_tt_td131,
                et_td140_aux TYPE  yhp_omp_tt_td140,
                et_td150_aux TYPE  yhp_omp_tt_td150,
                et_td151_aux TYPE  yhp_omp_tt_td151,
                et_td310_aux TYPE  yhp_omp_tt_td310,
*                et_td400_aux TYPE  yhp_omp_tt_td400,
                et_bom_aux   TYPE  yhp_omp_tt_bom,
                et_rte_aux   TYPE  yhp_omp_tt_rte.
          CLEAR: et_td100_aux, et_td101_aux, et_td110_aux, et_td111_aux, et_td130_aux, et_td131_aux, et_td140_aux, et_td150_aux, et_td151_aux, et_td310_aux, et_bom_aux, et_rte_aux.
          REFRESH: et_td100_aux, et_td101_aux, et_td110_aux, et_td111_aux, et_td130_aux, et_td131_aux, et_td140_aux, et_td150_aux, et_td151_aux, et_td310_aux, et_bom_aux, et_rte_aux.

          CALL FUNCTION 'YHP_OMP_INTERFACE'
            EXPORTING
              if_cuobj = lv_obj_sem
            IMPORTING
              et_td100 = et_td100_aux
              et_td101 = et_td101_aux
              et_td110 = et_td110_aux
              et_td111 = et_td111_aux
              et_td130 = et_td130_aux
              et_td131 = et_td131_aux
              et_td140 = et_td140_aux
              et_td150 = et_td150_aux
              et_td151 = et_td151_aux
              et_td310 = et_td310_aux
*             et_td400 = et_td400_aux
              et_bom   = et_bom_aux
              et_rte   = et_rte_aux.

          READ TABLE et_td110_aux WITH KEY mboar = 'P' INTO DATA(wa_td110_aux).
          IF sy-subrc = 0.
            wa_td110-board = wa_td110_aux-board.
            wa_td110-caliper = wa_td110_aux-caliper.
            wa_td110-ect = wa_td110_aux-ect.
          ELSE.
            SELECT SINGLE prboa, calip
            FROM zvcxi_p1e_td100
            WHERE matnr = @wa_td110-board
            AND prboa <> @space
            INTO ( @wa_td110-board, @wa_td110-caliper ).
*          CLEAR wa_td110-ect.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.
  ENDIF.



*  IF lv_grade_sem IS INITIAL AND sy-subrc = 0.
*    wa_productdata1-gradeid = wa_td110-board. "Calidad, recuperar con la función de AICOMP #¡VALOR!
*    wa_productdata1-grammage = wa_td110-caliper. " Preguntar a Hinojosa  X Es el gramaje de la calidad de carton del material. Es el CALIPER de la TD110
*  ELSEIF lv_grade_sem IS INITIAL AND sy-subrc <> 0.
  wa_productdata1-gradeid = wa_td110-board.
  wa_productdata1-grammage = wa_td110-caliper.
*  ELSEIF lv_grade_sem IS NOT INITIAL AND sy-subrc <> 0.
*    wa_productdata1-gradeid = lv_grade_sem. "Calidad, recuperar con la función de AICOMP #¡VALOR!
*    wa_productdata1-grammage = wa_td110_aux-caliper. " Preguntar a Hinojosa  X Es el gramaje de la calidad de carton del material. Es el CALIPER de la TD110
*  ENDIF.

  "Hay 4 campos que son obligatorios y que el material cabecera no dispone en su configuración:
*Calidad -> Usamos la tabla de parámetros TVARVC para fijar aquí el código del dummy y generar el
*mismo código en OMP. Y así, nosotros rescatarlo de esa tabla sin necesidad de hardcodear el código.
*Ancho y largo de plancha -> lo mismo que el anterior no tiene utilidad, pero es obligatorio. El
*único uso es a nivel de reporting por conocer en m2 la producción.
*Buscar en un uno de los componentes estas medidas: buscamos en la YHP_IDX_TD100.
*YHP_IDX_TD100 -shtgl
*YHP_IDX_TD100-shtgw
*Grammage -> podemos asumir un valor que está en configuración que se aproxima bastante
*dividiéndolo entre dos. El campo a rescatar es YHP_IDX_TD110 -caliper.
  IF lv_esgrafo_cab EQ abap_true.
    SELECT SINGLE low FROM tvarvc WHERE name EQ 'ZSPP_CALIDAD_MAT_CAB' INTO @DATA(lv_valor_dummy).
    IF sy-subrc = 0.
      wa_productdata1-gradeid = lv_valor_dummy.
    ELSE.
      wa_productdata1-gradeid = 'DUMMY'.
    ENDIF.
    wa_productdata1-grammage = wa_td110-caliper / 2.
  ENDIF.

  READ TABLE et_td150 INTO DATA(wa_td150) INDEX 1.
  IF sy-subrc = 0.
    wa_productdata1-internalarticlenr = wa_td150-bcean."Numero de artículo interno ¿Enviar MATNR de cabecera de la orden? Preguntar a hinojosa  X Necesitamos llevar el campo BCEAN de la TD150
  ELSE.
    wa_productdata1-internalarticlenr = ''.
  ENDIF.
  REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-internalarticlenr WITH ''.

  DATA: lv_prolechar TYPE char6,
        lv_prowichar TYPE char6,
        lv_prohechar TYPE char6.
  WRITE wa_td100-prole TO lv_prolechar LEFT-JUSTIFIED DECIMALS 0.
  WRITE wa_td100-prowi TO lv_prowichar LEFT-JUSTIFIED DECIMALS 0.
  WRITE wa_td100-prohe TO lv_prohechar LEFT-JUSTIFIED DECIMALS 0.
  REPLACE ALL OCCURRENCES OF '.' IN lv_prohechar WITH ''.
  REPLACE ALL OCCURRENCES OF '.' IN lv_prowichar WITH ''.
  REPLACE ALL OCCURRENCES OF '.' IN lv_prolechar WITH ''.
  CONDENSE: lv_prohechar, lv_prowichar, lv_prolechar.

*  wa_productdata1-internaldimensions = |{ wa_td100-prole }X{ wa_td100-prowi }X{ wa_td100-prohe }|. "Con la función YHP_OMP_INTERFACE utilizando AFKO-CUOBJ. Recuperar READ TABLE  ET_TD100 INDEX 1 . -> WRITE PROLE PROWI PROHE SEPARATED BY 'x'. #¡VALOR!
  wa_productdata1-internaldimensions = |{ lv_prolechar }X{ lv_prowichar }X{ lv_prohechar }|. "Con la función YHP_OMP_INTERFACE utilizando AFKO-CUOBJ. Recuperar READ TABLE  ET_TD100 INDEX 1 . -> WRITE PROLE PROWI PROHE SEPARATED BY 'x'. #¡VALOR!
  REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-internaldimensions WITH ''.
  CONDENSE wa_productdata1-internaldimensions NO-GAPS.

*wa_productdata1-Leadtime  Depende de cómo se modele el sistema OMP. Preguntar a Hinojosa  X Carlos consulta con OMP
*wa_productdata1-MarketDesc  En SAP sería correspondería a la descripción VBAk-SPART preguntar a hinojosa  X NO relevante
*wa_productdata1-MarketId  En SAP sería correspondería a VBAk-SPART preguntar a hinojosa X NO relevante
**  MaterialDensity	Densidad del material. Preguntar a Hinojosa	X	NO relevante
*wa_productdata1-MaterialLength  Longitud. Preguntar a Hinojosa  X NO relevante
  wa_productdata1-materialmanagement = 'MTO'. "Preguntar a hinojosa X OK
*  CASE wa_mara-mtart.
*    WHEN 'ZPRT' OR 'ZPTC' OR 'ZPTF' OR 'ZPTK' OR 'ZPTL' OR 'ZPTO'.
*      wa_productdata1-materialtype = 'FIN'." Tipo de material MARA-MTART. Según la especificación están reservados los siguientes. Reserved TYPE : PAL FOR a pallet, BAS FOR a base board,
*      "TOP FOR a top board, INK FOR an ink, PAP FOR paper, FIN FOR a
*      "finished product, SEM FOR a
***semi-finished product, PLA FOR a planning product (only used BY OMP ORDER Promiser).  #¡VALOR!
*    WHEN 'ZPSE' OR 'ZSEM'.
*      wa_productdata1-materialtype = 'SEM'.
*
*  ENDCASE.
  DATA lv_es_tinta TYPE xfeld.
  DATA it_mat_tinta TYPE tty_mat_tinta.
  CASE wa_mara-mtart.
    WHEN 'ZAUX'.

      "ADD JVM - 10/05/2024
      PERFORM check_tinta USING wa_mara-matnr CHANGING lv_es_tinta.
      "FVJM 10/05/2024

      "Nuevo chequeo, debemos comprobar que el material además
*          Tenemos que cambiar la lógica que usamos para enviar a OMP el materialtype  de las tintas (INK) del segmento ZCCPRODUCT- ZCCPRODUCDATA1. Para que un material le
*          pasemos materialtype = INK tiene que  estar incluido en la tabla de custo ZVCXI_PXS_VM121 en el campo MATNR entrando por WERKS de la OF y que
*          en la RESB de la OF el campo POSNR empiece por un valor distinto a 0.
      SELECT SINGLE matnr INTO @DATA(var1) FROM zvcxi_pxs_td121 WHERE matnr EQ @wa_mara-matnr AND werks EQ @lv_werks.
      IF ( wa_mara-matkl BETWEEN '35000' AND '39999' AND sy-subrc = 0 )
        OR ( wa_mara-matkl BETWEEN '35000' AND '39999' AND lv_es_tinta = abap_true ) ."ADD JVM - 10/05/2024
        wa_productdata1-materialtype  = 'INK'.
      ELSE.
        wa_productdata1-materialtype = 'AUX'.
      ENDIF.
      CASE wa_mara-meins.
        WHEN 'KG'.
          wa_productdata2-unitid = 'kg'.
        WHEN 'G'.
          wa_productdata2-unitid = 'gr'.
        WHEN OTHERS.
      ENDCASE.
    WHEN 'ZTIN'.
      wa_productdata1-materialtype = 'INK'.
      CASE wa_mara-meins.
        WHEN 'KG'.
          wa_productdata2-unitid = 'kg'.
        WHEN 'G'.
          wa_productdata2-unitid = 'gr'.
        WHEN OTHERS.
      ENDCASE.
    WHEN 'ZCLI'.
      wa_productdata1-materialtype = 'STE'.
      wa_productdata2-unitid = 'blank'.
    WHEN 'ZTRO'.
      wa_productdata1-materialtype = 'DIE'.
      wa_productdata2-unitid = 'blank'.
    WHEN 'ZPSE' OR 'ZSEM'.
      wa_productdata1-materialtype = 'SEM'.
      wa_productdata2-unitid = 'blank'.
    WHEN 'ZPTO' OR 'ZPRT' OR 'ZPTC' OR
        'ZPTF' OR 'ZPTK' OR 'ZPTL'.
      wa_productdata1-materialtype = 'FIN'.
      wa_productdata2-unitid = 'blank'.
    WHEN 'ZPAP' OR 'ZCAB'.
      wa_productdata1-materialtype = 'PAP'.
      wa_productdata2-unitid = 'm2'.
    WHEN 'ZCAR' OR 'ZCAH'.
      wa_productdata1-materialtype = 'COM'.
      wa_productdata2-unitid = 'm2'.
    WHEN 'ZPAL'.
      wa_productdata1-materialtype = 'PAL'.
      wa_productdata2-unitid = 'pallet'.
    WHEN 'ZMAP'.
      wa_productdata1-materialtype = 'MAP'.
      CASE wa_mara-meins.
        WHEN 'KG'.
          wa_productdata2-unitid = 'kg'.
        WHEN 'G'.
          wa_productdata2-unitid = 'gr'.
        WHEN OTHERS.
      ENDCASE.
    WHEN OTHERS.
*      wa_productdata1-materialtype = 'INK'.
  ENDCASE.
  IF wa_productdata1-materialtype EQ 'INK'.
    APPEND INITIAL LINE TO it_mat_tinta ASSIGNING FIELD-SYMBOL(<tinta>).
    <tinta>-matnr = wa_mara-matnr.
    <tinta>-ink = 'X'.
  ENDIF.
*wa_productdata1-MaterialViscosity Viscosidad. Preguntar a Hinojosa  X NO relevante
*wa_productdata1-MaterialWidth  Ancho. Preguntar a Hinojosa X NO relevante
  wa_productdata1-maxstockquantity = wa_marc-mabst. " Stock maximo. MARC-MABST entrando por centro de la OF y material  #¡VALOR!
*  wa_productdata1-minstockquantity = wa_marc-eisbe. " Stock de seguridad MARC-EISBE entrando por centro de la OF y material #¡VALOR!
*  wa_productdata1-minstockquantity = wa_marc-eislo. " Stock de seguridad MARC-EISBE entrando por centro de la OF y material #¡VALOR!
*  wa_productdata2-targetstockquantity = wa_marc-eisbe.
*  wa_productdata1-netsurface = ( ( wa_td100-shtnl * wa_td100-shtnw ) / wa_td100-noupt ) / 1000000. " M2 vendidos/fabricados. AFKO-GAMNG si NO viene en M2 convertir. La ocnversión estará en AICOMP  #¡VALOR!
  DATA(cantidad_of) = it_header[ 1 ]-gamng.
  DATA(unidad_of) = it_header[ 1 ]-gmein.
  CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
    EXPORTING
      i_matnr              = lv_matnr
      i_in_me              = unidad_of
      i_out_me             = 'M2'
*     i_menge              = cantidad_of
      i_menge              = 1
    IMPORTING
      e_menge              = cantidad_of
    EXCEPTIONS
      error_in_application = 1
      error                = 2
      OTHERS               = 3.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.
  WRITE cantidad_of TO wa_productdata1-netsurface LEFT-JUSTIFIED NO-GAP.
  REPLACE ALL OCCURRENCES OF '.' IN wa_productdata1-netsurface WITH ''.
  REPLACE ALL OCCURRENCES OF ',' IN wa_productdata1-netsurface WITH '.'.

  "Es un calculo: SHTNL * SHTNW / NOUPT / 1000000. Campos en TD100
*wa_productdata1-PaperId Preguntar a hinojosa  X NO relevante
*wa_productdata1-Ppexternalpaper Depende del modelado. N/A preguntar a hinojosa  X NO relevante
*wa_productdata1-Ppinternalpaper Depende del modelado. N/A preguntar a hinojosa  X NO relevante
*wa_productdata1-Ppmarkspecification Depende del modelado. N/A preguntar a hinojosa  X NO relevante
*wa_productdata1-Ppsideofmark  Depende del modelado. N/A preguntar a hinojosa  X NO relevante
*wa_productdata1-Ppwidth Depende del modelado. N/A preguntar a hinojosa  X NO relevante
*wa_productdata1-Premium N/A preguntar a hinojosa  X NO relevante

*wa_productdata1-preprint = wa_td100-fprpr. "Indica si es papel preimpreso. N/A preguntar a hinojosa X FPRPR en TD100 No aplica en HPP
  READ TABLE et_td150 INTO wa_td150 INDEX 1.
  IF sy-subrc = 0.
*    wa_productdata2-printdescription = wa_td150-rfbox." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)
    wa_productdata2-printdescription = wa_td150-lapos_descr." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)
  ENDIF.
  READ TABLE et_td130 INTO DATA(wa_printref) INDEX 1.
  IF sy-subrc = 0.
    wa_productdata2-printref = wa_printref-bccqm.
  ENDIF.
*wa_productdata1-Printref  Referencia de impresión. N/A preguntar a hinojosa X NO relevante
*wa_productdata1-Productclassification MARA-MATKL  #¡VALOR!  NO relevante - NO crear
*wa_productdata1-Productcomplexity Complejidad del producto. N/A preguntar a hinojosa  X NO relevante
  "JVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
  TRY.
      wa_productdata2-productcomplexity = et_td100[ 1 ]-lifnr.
    CATCH cx_root.
  ENDTRY.
  "FJVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
  wa_productdata2-productgroup = wa_td100-prsty. "  MARA-MATKL  #¡VALOR!  Es el FEFCO del VC, consultar aicomp Es el campo PRSTY de la tabla TD100


  wa_productdata2-productid = lv_matnr. "AUFK-PLNBEZ material a fabricar #¡VALOR!  Material
  "JVM - 07/10/2024 Eliminar los ceros para los materiales
  lv_mat_auxi = wa_productdata2-productid.
  wa_productdata2-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
  "FJVM - 07/10/2024 Eliminar los ceros para los materiales
  wa_productdata2-productname = it_header[ 1 ]-matxt."material_text."Descripción del material a producir. MAKT-MAKTX entrando por AFPO-PLNBEZ y SPRAS = 'S'  #¡VALOR!  Descripcion del material


  REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
  SELECT SINGLE mtart INTO @DATA(lv_mtart_prodname) FROM mara WHERE matnr EQ @lv_matnr.
  IF lv_mtart_prodname EQ 'ZPSE'.
    CONCATENATE wa_productdata2-productid wa_productdata2-productname INTO wa_productdata2-productname SEPARATED BY space.
    REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
  ENDIF.


*wa_productdata2-Qtspecification  Especificacion de calidad. Preguntar a Hinojosa X NO relevante
  LOOP AT et_td140 INTO DATA(wa_td140).
    "Pasamos el valor en M no en MM
    IF wa_td140-scorp <> 0.
      wa_td140-scorp = wa_td140-scorp / 1000.
    ENDIF.
    CASE wa_td140-iscor.
*      WHEN 'C01'.
      WHEN 'L01'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo0 LEFT-JUSTIFIED." DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo0 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo0 WITH '.'.
*      WHEN 'C02'.
      WHEN 'L02'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo1 LEFT-JUSTIFIED." DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo1 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo1 WITH '.'.
*      WHEN 'C03'.
      WHEN 'L03'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo2 LEFT-JUSTIFIED." DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo2 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo2 WITH '.'.
*      WHEN 'C04'.
      WHEN 'L04'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo3 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo3 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo3 WITH '.'.
*      WHEN 'C05'.
      WHEN 'L05'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo4 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo4 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo4 WITH '.'.
*      WHEN 'C06'.
      WHEN 'L06'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo5 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo5 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo5 WITH '.'.
*      WHEN 'C07'.
      WHEN 'L07'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo6 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo6 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo6 WITH '.'.
*      WHEN 'C08'.
      WHEN 'L08'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo7 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo7 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo7 WITH '.'.
*      WHEN 'C09'.
      WHEN 'L09'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo8 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo8 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo8 WITH '.'.
*      WHEN 'C10'.
      WHEN 'L10'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfo9 LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo9 WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo9 WITH '.'.
      WHEN 'L01'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfobackwardlength LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfobackwardlength WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfobackwardlength WITH '.'.
      WHEN 'L02'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfobackwardwidth LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfobackwardwidth WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfobackwardwidth WITH '.'.
      WHEN 'L03'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfoforwardlength LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfoforwardlength WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfoforwardlength WITH '.'.
      WHEN 'L04'.
        WRITE wa_td140-scorp TO wa_productdata2-slitinfoforwardwidth LEFT-JUSTIFIED."DECIMALS 0.
        REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfoforwardwidth WITH ''.
        REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfoforwardwidth WITH '.'.
    ENDCASE.

*        productdata2-Slitinfo0                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C01
*        productdata2-Slitinfo1                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C02
*        productdata2-Slitinfo2                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C03
*        productdata2-Slitinfo3                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C04
*        productdata2-Slitinfo4                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C05
*        productdata2-Slitinfo5                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C06
*        productdata2-Slitinfo6                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C07
*        productdata2-Slitinfo7                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C08
*        productdata2-Slitinfo8                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C09
*        productdata2-Slitinfo9                                                  Tabla TD140, es el campo SCORP cuando  campo ISCOR es C10
*
*
*
*        productdata2-Slitinfobackwardlength                   Tabla TD140, es el campo SCORP cuando  campo ISCOR es L01
*        productdata2-Slitinfobackwardwidth                    Tabla TD140, es el campo SCORP cuando  campo ISCOR es L02
*        productdata2-Slitinfoforwardlength                       Tabla TD140, es el campo SCORP cuando  campo ISCOR es L03
*        productdata2-Slitinfoforwardwidth                        Tabla TD140, es el campo SCORP cuando  campo ISCOR es L04

  ENDLOOP.
*      wa_productdata2-Standardlength  Longitud estándar. Preguntar a hinojosa X NO relevante
*wa_productdata2-SubMarketDesc En SAP sería correspondería a la descripción VBAk-SPART preguntar a hinojosa  X Carlos ve con Edu en cliente No relevante

  wa_productdata2-submarketid = wa_knvv-zzbrsch."En SAP sería correspondería a VBAk-SPART preguntar a hinojosa X Carlos ve con Edu en clienteKNVV-ZZBRSCH del cliente
*wa_productdata2-Supernetsurface Preguntar a Hinojosa  X NO relevante
*wa_productdata2-Targetstockquantity Stock objetivo. Cantidad de la orden. Preguntar a hinojosa  X NO relevante
  wa_productdata2-thickness100 = wa_td100-pcali * 100. " Con la función YHP_OMP_INTERFACE utilizando AFKO-CUOBJ. Recuperar READ TABLE  ET_TD100 INDEX 1 . ->  Caliper X 100. PCALI X 100.  #¡VALOR!  Como descrito
*  wa_productdata2-unitid = 'board'."'blank'. "unidad de medida de la orden?. preguntar a hinojosa x no en la actualidad. unidad de medida de la orden (unidades)
*  IF lv_grade_sem IS INITIAL.
  wa_productdata2-vertcompression = wa_td110-ect." N/A preguntar a hinojosa  X Ver campo con Aicomp, tabla TD110. Es el ECT
*  ELSE.
*    wa_productdata2-vertcompression = wa_td110_aux-ect." N/A preguntar a hinojosa  X Ver campo con Aicomp, tabla TD110. Es el ECT
*  ENDIF.
*wa_productdata2-Whitetop  N/A indica si el papel esta arriba O NO. Valor por defecto NO.  Preguntar a hinojosa  X Indica si el papel es blanco O NO. NO relevante
  CLEAR: l_edidd.

  l_edidd-sdata = wa_productdata1.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata1 )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.

  CLEAR: l_edidd.

  l_edidd-sdata = wa_productdata2.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata2 )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.


  DATA(wp2) = wa_productdata2.
  DATA(wp1) = wa_productdata1.
  LOOP AT it_operation INTO DATA(wa_operation_compo).
    LOOP AT it_component INTO DATA(wa_compo) WHERE vornr EQ wa_operation_compo-vornr.
      CLEAR: wa_productdata1, wa_productdata2.

      IF wa_compo-matnr IS INITIAL.
        CONTINUE.
      ENDIF.
      SELECT SINGLE mtart INTO @DATA(lv_mtart_compo) FROM mara WHERE matnr EQ @wa_compo-matnr.
      IF lv_mtart_compo EQ 'ZPAP' OR lv_mtart_compo EQ 'ZPTK'.
        CONTINUE.
      ENDIF.
      IF lv_mtart_compo EQ 'ZBOM'.
        CONTINUE.
      ENDIF.
      IF wa_compo-baugr <> it_header[ 1 ]-plnbez.

        "INI JVM - 26/03/2024 - Chequeamos si el origen de la necesidad es un dummy, ya que las colas se enviarán así ahora para enviar la cola real
        READ TABLE it_component WITH KEY matnr = wa_compo-baugr dumps = abap_true TRANSPORTING NO FIELDS."ADD JVM - 26/03/2024
        IF sy-subrc <> 0."ADD JVM - 26/03/2024
          CONTINUE.
        ELSE.
          SELECT SINGLE mtart FROM mara WHERE matnr = @wa_compo-baugr INTO @DATA(lv_mtart_baugr).
          IF lv_mtart_baugr = 'ZTIN'.
            CONTINUE.
          ENDIF.
        ENDIF."ADD JVM - 26/03/2024
        "FIN JVM - 26/03/2024 - Chequeamos si el origen de la necesidad es un dummy, ya que las colas se enviarán así ahora para enviar la cola real
      ENDIF.

      CLEAR: l_edidd, wa_product.
      wa_product-operation = c_replace.
      l_edidd-sdata = wa_product.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_product )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.

      CLEAR: l_edidd.

      wa_productdata2-productid = wa_compo-matnr.
      "JVM - 07/10/2024 Eliminar los ceros para los materiales
      lv_mat_auxi = wa_productdata2-productid.
      wa_productdata2-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
      "FJVM - 07/10/2024 Eliminar los ceros para los materiales
      SELECT SINGLE maktx INTO @wa_productdata2-productname FROM makt WHERE matnr EQ @wa_compo-matnr AND spras EQ 'S'.
      REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
      SELECT SINGLE mtart INTO @lv_mtart_prodname FROM mara WHERE matnr EQ @wa_compo-matnr.
      IF lv_mtart_prodname EQ 'ZPSE'.
        CONCATENATE wa_compo-matnr wa_productdata2-productname INTO wa_productdata2-productname SEPARATED BY space.
        REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
      ENDIF.
*    wa_productdata1-
      SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
      CASE lv_mtart_compo.
        WHEN 'ZAUX'.
          "ADD JVM - 10/05/2024
          PERFORM check_tinta USING wa_mara-matnr CHANGING lv_es_tinta.
          "FVJM 10/05/2024

          "Nuevo chequeo, debemos comprobar que el material además
*          Tenemos que cambiar la lógica que usamos para enviar a OMP el materialtype  de las tintas (INK) del segmento ZCCPRODUCT- ZCCPRODUCDATA1. Para que un material le
*          pasemos materialtype = INK tiene que  estar incluido en la tabla de custo ZVCXI_PXS_VM121 en el campo MATNR entrando por WERKS de la OF y que
*          en la RESB de la OF el campo POSNR empiece por un valor distinto a 0.
          SELECT SINGLE matnr INTO @DATA(lv_material_tinta) FROM zvcxi_pxs_td121 WHERE matnr EQ @wa_compo-matnr AND werks EQ @lv_werks.
          IF ( wa_compo-matkl BETWEEN '35000' AND '39999' AND sy-subrc = 0 )
            OR ( wa_mara-matkl BETWEEN '35000' AND '39999' AND lv_es_tinta = abap_true )."ADD JVM - 10/05/2024
            wa_productdata1-materialtype  = 'INK'.
            CASE wa_compo-meins.
              WHEN 'KG'.
                wa_productdata2-unitid = 'kg'.
              WHEN 'G'.
                wa_productdata2-unitid = 'gr'.
              WHEN OTHERS.
            ENDCASE.
          ELSE.
            wa_productdata1-materialtype = 'AUX'.
            CASE wa_compo-meins.
              WHEN 'KG'.
                wa_productdata2-unitid = 'kg'.
              WHEN 'G'.
                wa_productdata2-unitid = 'gr'.
              WHEN OTHERS.
            ENDCASE.
          ENDIF.
        WHEN 'ZTIN'.
          wa_productdata1-materialtype = 'INK'.
          CASE wa_compo-meins.
            WHEN 'KG'.
              wa_productdata2-unitid = 'kg'.
            WHEN 'G'.
              wa_productdata2-unitid = 'gr'.
            WHEN OTHERS.
          ENDCASE.
        WHEN 'ZCLI'.
          wa_productdata1-materialtype = 'STE'.
          wa_productdata2-unitid = 'blank'.
        WHEN 'ZTRO'.
          wa_productdata1-materialtype = 'DIE'.
          wa_productdata2-unitid = 'blank'.
        WHEN 'ZPSE' OR 'ZSEM'.
          wa_productdata1-materialtype = 'SEM'.
          wa_productdata2-unitid = 'blank'.
          wa_productdata1-materialmanagement = 'MTO'.
        WHEN 'ZPTO' OR 'ZPRT' OR 'ZPTC' OR
          'ZPTF' OR 'ZPTK' OR 'ZPTL'.
          wa_productdata1-materialtype = 'FIN'.
          wa_productdata2-unitid = 'blank'.
        WHEN 'ZPAP' OR 'ZCAB'.
          wa_productdata1-materialtype = 'PAP'.
          wa_productdata2-unitid = 'm2'.
        WHEN 'ZCAR' OR 'ZCAH'.
          wa_productdata1-materialtype = 'COM'.
          wa_productdata2-unitid = 'm2'.
        WHEN 'ZPAL'.
          wa_productdata1-materialtype = 'PAL'.
          wa_productdata2-unitid = 'pallet'.
        WHEN 'ZMAP'.
          wa_productdata1-materialtype = 'MAP'.
          CASE wa_compo-meins.
            WHEN 'KG'.
              wa_productdata2-unitid = 'kg'.
            WHEN 'G'.
              wa_productdata2-unitid = 'gr'.
            WHEN OTHERS.
          ENDCASE.
*      WHEN OTHERS.
*        wa_productdata1-materialtype = 'INK'.
      ENDCASE.
      IF wa_productdata1-materialtype EQ 'INK'.
        APPEND INITIAL LINE TO it_mat_tinta ASSIGNING <tinta>.
        <tinta>-matnr = wa_compo-matnr.
        <tinta>-ink = 'X'.
      ENDIF.
      READ TABLE et_td150 INTO wa_td150 INDEX 1.
      IF sy-subrc = 0.
*        wa_productdata2-printdescription = wa_td150-rfbox." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)
        "SOLO LO PASAMOS PARA EL PRODUCTO DE CABECERA -> Comentamos
*        wa_productdata2-printdescription = wa_td150-lapos_descr." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)
      ENDIF.
      READ TABLE et_td130 INTO wa_printref INDEX 1.
      IF sy-subrc = 0.
        wa_productdata2-printref = wa_printref-bccqm.
      ENDIF.
      IF wa_productdata1-materialtype EQ 'SEM'.

        DATA: et_td100_sem TYPE  yhp_omp_tt_td100,
              et_td101_sem TYPE  yhp_omp_tt_td101,
              et_td110_sem TYPE  yhp_omp_tt_td110,
              et_td111_sem TYPE  yhp_omp_tt_td111,
              et_td130_sem TYPE  yhp_omp_tt_td130,
              et_td131_sem TYPE  yhp_omp_tt_td131,
              et_td140_sem TYPE  yhp_omp_tt_td140,
              et_td150_sem TYPE  yhp_omp_tt_td150,
              et_td151_sem TYPE  yhp_omp_tt_td151,
              et_td310_sem TYPE  yhp_omp_tt_td310,
*              et_td400_sem TYPE  yhp_omp_tt_td400,
              et_bom_sem   TYPE  yhp_omp_tt_bom,
              et_rte_sem   TYPE  yhp_omp_tt_rte.
        CLEAR: et_td100_sem, et_td101_sem, et_td110_sem, et_td111_sem, et_td130_sem, et_td131_sem, et_td140_sem, et_td150_sem, et_td151_sem, et_td310_sem, et_bom_sem, et_rte_sem.
        REFRESH: et_td100_sem, et_td101_sem, et_td110_sem, et_td111_sem, et_td130_sem, et_td131_sem, et_td140_sem, et_td150_sem, et_td151_sem, et_td310_sem, et_bom_sem, et_rte_sem.

        "Comprobamos si el SEM se fabrica en este u otro centro
        SELECT SINGLE sobsl INTO @DATA(lv_sobsl_sem) FROM marc WHERE matnr EQ @wa_compo-matnr AND werks EQ @wa_compo-werks.
        IF lv_sobsl_sem EQ '40'.
          SELECT SINGLE wrk02 INTO @DATA(lv_werks_sem) FROM t460a WHERE werks EQ @wa_compo-werks AND sobsl EQ '40'.
          IF sy-subrc = 0.
            SELECT SINGLE cuobj INTO @DATA(lv_cuobj_sem) FROM marc WHERE matnr EQ @wa_compo-matnr AND werks EQ @lv_werks_sem.
          ENDIF.
        ELSE.
          SELECT SINGLE cuobj INTO @lv_cuobj_sem FROM marc WHERE matnr EQ @wa_compo-matnr AND werks EQ @wa_compo-werks.
        ENDIF.

        CALL FUNCTION 'YHP_OMP_INTERFACE'
          EXPORTING
            if_cuobj = lv_cuobj_sem
          IMPORTING
            et_td100 = et_td100_sem
            et_td101 = et_td101_sem
            et_td110 = et_td110_sem
            et_td111 = et_td111_sem
            et_td130 = et_td130_sem
            et_td131 = et_td131_sem
            et_td140 = et_td140_sem
            et_td150 = et_td150_sem
            et_td151 = et_td151_sem
            et_td310 = et_td310_sem
*           et_td400 = et_td400_sem
            et_bom   = et_bom_sem
            et_rte   = et_rte_sem.

        SELECT SINGLE * INTO @DATA(wa_mara_sem) FROM mara WHERE matnr EQ @wa_compo-matnr.

        "Enviamos toda la información del material, no sólo la info básica
        READ TABLE et_td100_sem INTO DATA(wa_td100_sem) INDEX 1.
        wa_productdata1-ccproducttype = wa_compo-matnr+2(2)."lv_cus_mat+2(2). "Tipo de material en MARA-MTART. Preguntar a hinojosa  X Tipo de producto; Inliner, diecuted. PTYPE de la tabla TD100
        wa_productdata1-closure = wa_td100_sem-joity. " Preguntar a Hinojosa  X JOITY de tabla TD100
        wa_productdata1-comments = wa_td100_sem-obser. " Comentarios de cliente en pedido de ventas O en el registro info para el material. MAX 60 char. Preguntar a hinojosa  X Es el campo de comentarios de producto del VC, preguntar a AICOMP
        SELECT SINGLE stprs, verpr, vprsv, peinh INTO @DATA(wa_precio_sem) FROM mbew WHERE matnr EQ @wa_compo-matnr AND bwkey EQ @wa_compo-werks.
        TRY.
            IF wa_precio_sem-vprsv EQ 'S'.
              TRY.
                  wa_productdata1-cost = wa_precio_sem-stprs / wa_precio_sem-peinh . " MBEW-STPRS O MBEW-VERPR según si es estándar O variable MBEW-VPRSV - S O V  #¡VALOR!
                CATCH cx_root.
              ENDTRY.
            ELSE.
              TRY.
                  wa_productdata1-cost = wa_precio_sem-verpr / wa_precio_sem-peinh.
                CATCH cx_root.
              ENDTRY.
            ENDIF.

            CLEAR lv_menge.

            CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
              EXPORTING
                i_matnr              = wa_compo-matnr
                i_in_me              = wa_mara_sem-meins
                i_out_me             = 'M2'
                i_menge              = 1
              IMPORTING
                e_menge              = lv_menge
              EXCEPTIONS
                error_in_application = 1
                error                = 2
                OTHERS               = 3.
            IF sy-subrc <> 0.
* Implement suitable error handling here
            ELSE.
              TRY.
                  wa_productdata1-cost = wa_productdata1-cost / lv_menge.
                CATCH cx_root.
              ENDTRY.
            ENDIF.

          CATCH cx_root.
        ENDTRY.
*        DATA lv_charmat TYPE char40.
        lv_charmat = |{ wa_compo-matnr ALPHA = OUT }|.
        CONDENSE lv_charmat.
        "INI JVM - 28/05/2024 - pasar documentos de la OF
*        wa_productdata1-drawingref = |{ lv_charmat }.pdf|. " ¿Documentos anexos?¿De donde se recupera esta información? Preguntar a Hinojosa X Numero de material SAP. Pdf
        CLEAR wa_productdata1-drawingref.
        LOOP AT it_documentos_of ASSIGNING <draw>.
          IF wa_productdata1-drawingref IS INITIAL.
            wa_productdata1-drawingref = |{ <draw>-doknr ALPHA = OUT }|.
          ELSE.
            wa_productdata1-drawingref = wa_productdata1-drawingref && |; { <draw>-doknr ALPHA = OUT }|.
          ENDIF.
        ENDLOOP.
        "FJVM - 28/05/2024 - pasar documentos de la of
*        SELECT SINGLE * INTO @DATA(wa_mara_sem) FROM mara WHERE matnr EQ @wa_compo-matnr.
        wa_productdata1-erparticletlm = |{ wa_mara_sem-laeda+6(2) }/{ wa_mara_sem-laeda+4(2) }/{ wa_mara_sem-laeda(4) },00:00:00|. "Fecha y hora de la ultima actualización del material en el ERP. 01/01/1980,
        wa_productdata1-erpmaterialid = wa_compo-matnr. "VBAP-MATNR OR AFKO-PLNBEZ  #¡VALOR!
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
*        DATA lv_mat_auxi TYPE matnr.
        lv_mat_auxi = wa_productdata1-erpmaterialid.
        wa_productdata1-erpmaterialid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        wa_productdata1-fsccertificateinfo = wa_td100_sem-fscty. "Preguntar a Hinojosa  X Campo del configurador. NO lo encontramos en el excel pero debe estar en TD100
        REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-fsccertificateinfo WITH ''.
        CASE wa_td100_sem-joipo.
          WHEN 'I'.
            wa_productdata1-glue = 'INTERNAL'. "Información de GLUE, valores NONE, INTERNAL O EXTERNAL preguntar a hinojosa X JOIPO en TD100
          WHEN 'E'.
            wa_productdata1-glue = 'EXTERNAL'.
          WHEN OTHERS.
            wa_productdata1-glue = 'NONE'.
        ENDCASE.

        READ TABLE et_td110_sem WITH KEY mboar = 'P' INTO DATA(wa_td110_sem).
*        IF sy-subrc = 0 AND wa_td110_sem-board IS NOT INITIAL.
*          wa_productdata1-gradeid = wa_td110_sem-board. "Calidad, recuperar con la función de AICOMP #¡VALOR!
*          wa_productdata1-grammage = wa_td110_sem-caliper. " Preguntar a Hinojosa  X Es el gramaje de la calidad de carton del material. Es el CALIPER de la TD110
*        ELSE.
        SELECT SINGLE prboa, calip
        FROM zvcxi_p1e_td100
        WHERE matnr = @wa_compo-matnr
        AND prboa <> @space
        INTO ( @wa_productdata1-gradeid, @DATA(lv_gram) ).

        wa_productdata1-grammage = lv_gram.

*        ENDIF.

        READ TABLE et_td150_sem INTO DATA(wa_td150_sem) INDEX 1.
        IF sy-subrc = 0.
          wa_productdata1-internalarticlenr = wa_td150_sem-bcean."Numero de artículo interno ¿Enviar MATNR de cabecera de la orden? Preguntar a hinojosa  X Necesitamos llevar el campo BCEAN de la TD150
        ELSE.
          wa_productdata1-internalarticlenr = ''.
        ENDIF.
        REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-internalarticlenr WITH ''.
        wa_productdata1-internaldimensions = |{ wa_td100_sem-prole }X{ wa_td100_sem-prowi }X{ wa_td100_sem-prohe }|. "Con la función YHP_OMP_INTERFACE utilizando AFKO-CUOBJ. Recuperar READ TABLE  ET_TD100 INDEX 1 . -> WRITE
        REPLACE ALL OCCURRENCES OF '"' IN wa_productdata1-internaldimensions WITH ''.
        SELECT SINGLE * INTO @DATA(wa_marc_sem) FROM marc WHERE matnr EQ @wa_compo-matnr AND werks EQ @wa_compo-werks.
        wa_productdata1-maxstockquantity = wa_marc_sem-mabst. " Stock maximo. MARC-MABST entrando por centro de la OF y material  #¡VALOR!
*        wa_productdata1-minstockquantity = wa_marc_sem-eisbe. " Stock de seguridad MARC-EISBE entrando por centro de la OF y material #¡VALOR!
*        wa_productdata1-minstockquantity = wa_marc_sem-eislo. " Stock de seguridad MARC-EISBE entrando por centro de la OF y material #¡VALOR!
*        wa_productdata2-targetstockquantity = wa_marc_sem-eisbe."
        TRY.
*            wa_productdata1-netsurface = ( ( wa_td100_sem-shtnl * wa_td100_sem-shtnw ) / wa_td100_sem-noupt ) / 1000000. " M2 vendidos/fabricados. AFKO-GAMNG si NO viene en M2 convertir. La ocnversión estará en AICOMP  #¡VALOR!
            wa_productdata1-netsurface = wa_td100-ablag. "
          CATCH cx_root.
        ENDTRY.
        wa_productdata2-productgroup = wa_td100_sem-prsty. "  MARA-MATKL  #¡VALOR!  Es el FEFCO del VC, consultar aicomp Es el campo PRSTY de la tabla TD100
        wa_productdata2-productid = wa_compo-matnr. "AUFK-PLNBEZ material a fabricar #¡VALOR!  Material
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
        lv_mat_auxi = wa_productdata2-productid.
        wa_productdata2-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        SELECT SINGLE maktx INTO @DATA(lv_maktx_sem) FROM makt WHERE matnr EQ @wa_compo-matnr AND spras EQ 'S'.
        wa_productdata2-productname = lv_maktx_sem."material_text."Descripción del material a producir. MAKT-MAKTX entrando por AFPO-PLNBEZ y SPRAS = 'S'  #¡VALOR!  Descripcion del material
        REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
        SELECT SINGLE mtart INTO @lv_mtart_prodname FROM mara WHERE matnr EQ @wa_compo-matnr.
        IF lv_mtart_prodname EQ 'ZPSE'.
          CONCATENATE wa_compo-matnr wa_productdata2-productname INTO wa_productdata2-productname SEPARATED BY space.
          REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
        ENDIF.

        LOOP AT et_td140_sem INTO DATA(wa_td140_sem).
          IF wa_td140_sem-scorp <> 0.
            wa_td140_sem-scorp = wa_td140_sem-scorp / 1000.
          ENDIF.
          CASE wa_td140_sem-iscor.
            WHEN 'C01'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo0 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo0 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo0 WITH '.'.
            WHEN 'C02'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo1 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo1 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo1 WITH '.'.
            WHEN 'C03'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo2 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo2 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo2 WITH '.'.
            WHEN 'C04'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo3 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo3 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo3 WITH '.'.
            WHEN 'C05'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo4 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo4 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo4 WITH '.'.
            WHEN 'C06'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo5 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo5 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo5 WITH '.'.
            WHEN 'C07'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo6 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo6 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo6 WITH '.'.
            WHEN 'C08'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo7 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo7 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo7 WITH '.'.
            WHEN 'C09'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo8 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo8 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo8 WITH '.'.
            WHEN 'C10'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfo9 LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfo9 WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfo9 WITH '.'.
            WHEN 'L01'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfobackwardlength LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfobackwardlength WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfobackwardlength WITH '.'.
            WHEN 'L02'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfobackwardwidth LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfobackwardwidth WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfobackwardwidth WITH '.'.
            WHEN 'L03'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfoforwardlength LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfoforwardlength WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfoforwardlength WITH '.'.
            WHEN 'L04'.
              WRITE wa_td140_sem-scorp TO wa_productdata2-slitinfoforwardwidth LEFT-JUSTIFIED."DECIMALS 0.
              REPLACE ALL OCCURRENCES OF '.' IN wa_productdata2-slitinfoforwardwidth WITH ''.
              REPLACE ALL OCCURRENCES OF ',' IN wa_productdata2-slitinfoforwardwidth WITH '.'.
          ENDCASE.

        ENDLOOP.
        wa_productdata2-submarketid = wa_knvv-zzbrsch."En SAP sería correspondería a VBAk-SPART preguntar a hinojosa X Carlos ve con Edu en clienteKNVV-ZZBRSCH del cliente
        wa_productdata2-thickness100 = wa_td100_sem-pcali * 100. " Con la función YHP_OMP_INTERFACE utilizando AFKO-CUOBJ. Recuperar
        wa_productdata2-vertcompression = wa_td110_sem-ect." N/A preguntar a hinojosa  X Ver campo con Aicomp, tabla TD110. Es el ECT


        READ TABLE et_td150_sem INTO wa_td150_sem INDEX 1.
        IF sy-subrc = 0.
*          wa_productdata2-printdescription = wa_td150_sem-rfbox." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)
          " SMT - INI - 07.09.2022 10:17:00 - 	Función ZSPP_IDOC_ORDERS: En el campo PRINTDESCRPTION  del segmento ZZPRODUCT-ZZPRODUCTDATA1
          " sólo hay que enviar ese campo con valor para los segmentos del material cabecera de la OF. AFPO-MATNR no para los componentes de la RESB.
**          wa_productdata2-printdescription = wa_td150_sem-lapos_descr." Depende del modelado. N/A preguntar a hinojosa  X NO relevante en HPP (cambiará en HPX)

          " SMT - FIN - 07.09.2022 10:17:15 -
        ENDIF.
        READ TABLE et_td130_sem INTO wa_printref INDEX 1.
        IF sy-subrc = 0.
          wa_productdata2-printref = wa_printref-bccqm.
        ENDIF.
      ENDIF.

      l_edidd-sdata = wa_productdata1.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata1 )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.

      CLEAR: l_edidd.

      l_edidd-sdata = wa_productdata2.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata2 )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.


    ENDLOOP.
  ENDLOOP.

  "INI JVM - 26/03/2024 - Añadir componentes que no están vinculados a operaciones PP03
  DATA(it_operaux) = it_operation_all[]."ADD JVM - 26/03/2024
  DELETE it_operaux WHERE steus <> 'PP02' AND steus <> 'PP03'."ADD JVM - 26/03/2024
  "FIN JVM - 26/03/2024 - Añadir componentes que no están vinculados a operaciones PP03
  "Añadimos el pallet también
  LOOP AT it_component INTO wa_compo.
    CLEAR: wa_productdata1, wa_productdata2.

    IF wa_compo-matnr IS INITIAL.
      CONTINUE.
    ENDIF.
    SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
    IF lv_mtart_compo NE 'ZPAL'.
      READ TABLE it_operaux WITH KEY vornr = wa_compo-vornr TRANSPORTING NO FIELDS. "ADD JVM - 26/03/2024
      IF sy-subrc <> 0."ADD JVM - 26/03/2024

        CONTINUE.

      ENDIF."ADD JVM - 26/03/2024

    ENDIF.
    IF wa_compo-baugr <> it_header[ 1 ]-plnbez.
      CONTINUE.
    ENDIF.

    CLEAR: l_edidd, wa_product.
    wa_product-operation = c_replace.
    l_edidd-sdata = wa_product.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_product )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.

    CLEAR: l_edidd.

    wa_productdata2-productid = wa_compo-matnr.
    "JVM - 07/10/2024 Eliminar los ceros para los materiales
    lv_mat_auxi = wa_productdata2-productid.
    wa_productdata2-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
    "FJVM - 07/10/2024 Eliminar los ceros para los materiales
    SELECT SINGLE maktx INTO @wa_productdata2-productname FROM makt WHERE matnr EQ @wa_compo-matnr AND spras EQ 'S'.
    REPLACE ALL OCCURRENCES OF '"' IN wa_productdata2-productname WITH ''.
    wa_productdata1-materialtype = 'PAL'.
    wa_productdata2-unitid = 'pallet'.

    l_edidd-sdata = wa_productdata1.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata1 )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.

    CLEAR: l_edidd.

    l_edidd-sdata = wa_productdata2.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productdata2 )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.


  ENDLOOP.

  READ TABLE it_rutas WITH KEY ruta_alt = 'X' TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    DATA(lv_rutas_alt) = 'X'.
  ENDIF.

**  cCProcess     #¡VALOR!
**  Operation REPLACE #¡VALOR!
  wa_process-operation = c_replace.
  CLEAR l_edidd.
  l_edidd-sdata = wa_process.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_process )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.
**  cCProcessdata     #¡VALOR!  NO está este segmento, los campos son del ccprocess
  wa_processdata-processid = |{ wa_orderdata-orderid ALPHA = OUT }|. "concatenar "_1" a CCORDERDATA-ORDERID #¡VALOR!  Este concepto no existe en AS400, por eso lo hacemos así. No existe este concepto en SAP?
  CONDENSE wa_processdata-processid NO-GAPS.
*  CONCATENATE wa_processdata-processid '_1' INTO wa_processdata-processid.
  DATA lv_numruta TYPE char2.
  lv_numruta = |{ ruta_ppal ALPHA = OUT }|.
  CONDENSE lv_numruta.
  CONCATENATE wa_processdata-processid '_'  lv_numruta INTO wa_processdata-processid.
  wa_processdata-productid = wp2-productid. "Mismo campo que CCPRODUCTDATA-PRODUCTID #¡VALOR!  Material
  "JVM - 07/10/2024 Eliminar los ceros para los materiales
  lv_mat_auxi = wa_processdata-productid.
  wa_processdata-productid =  zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
  "FJVM - 07/10/2024 Eliminar los ceros para los materiales
  wa_processdata-orderid = wa_orderdata-orderid. "mismo campo que CCORDERDATA-ORDERID #¡VALOR!  Orden
*wa_processdata-Overallloss	¿A qué se refiere este campo? ¿viene de aicomp? ¿Es la merma/rechazo en la orden?
  "¿Es siempre 0? Se indica en %. Preguntar a hinojosa  X Aicomp da merma por cada operación.No es necesario si estamos pasando el de la merma esperada en cada operación
*      Si la indicamos por operación este campo NO es relevante
*wa_processdata-Comments  Comentarios si hubiera en la orden. Preguntar a hinojosa  X NO relevante
*wa_processdata-Erpprocessid  Preguntar a hinojosa  X NO relevante
*wa_processdata-Incproductionqty  N/A NO se usa en V5 #¡VALOR!  NO relevante
*wa_processdata-Minproductionqty  N/A NO se usa en V5 #¡VALOR!  NO relevante
*wa_processdata-PlannedOrderId  NO se utiliza en Hinojosa. Preguntar a Hinojosa X NO relevante
  DATA lv_preference TYPE i.
  lv_preference = 1.
  wa_processdata-preference = lv_preference. "preferencia. preguntar a hinojosa x no relevante
*wa_processdata-Processextracharge  Coste extra. Preguntar a hinojosa X NO relevante
*wa_processdata-Processextrachargeper1000 Coste extra x100. Preguntar a hinojosa  X NO relevante
  CLEAR: l_edidd.
  l_edidd-sdata = wa_processdata.
  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_processdata )->get_relative_name( ).
  l_edidd-segnum = lv_auxlevel.
  lv_auxlevel = lv_auxlevel + 1.
  APPEND l_edidd TO t_edidd.

  IF lv_rutas_alt EQ 'X'.
    "No queremos modificar el WA_PROCESSDATA ya que se usa posteriormente
    DATA wa_processdata_alt TYPE zccprocessdata.
    "Añadimos segmentos process para los alternativos
    LOOP AT it_rutas INTO DATA(wa_rutas) WHERE ruta_alt = 'X' GROUP BY ( route = wa_rutas-route ).
      wa_process-operation = c_replace.
      CLEAR l_edidd.
      l_edidd-sdata = wa_process.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_process )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.
      CLEAR wa_processdata_alt.
**  cCProcessdata     #¡VALOR!  NO está este segmento, los campos son del ccprocess
      wa_processdata_alt-processid = |{ wa_orderdata-orderid ALPHA = OUT }|.
      CONDENSE wa_processdata_alt-processid NO-GAPS.
*      DATA lv_numruta TYPE char2.
      lv_numruta = |{ wa_rutas-route ALPHA = OUT }|.
      CONDENSE lv_numruta.
      CONCATENATE wa_processdata_alt-processid '_' lv_numruta INTO wa_processdata_alt-processid.
      wa_processdata_alt-productid = wp2-productid.
      "JVM - 07/10/2024 Eliminar los ceros para los materiales
      lv_mat_auxi = wa_processdata_alt-productid.
      wa_processdata_alt-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
      "FJVM - 07/10/2024 Eliminar los ceros para los materiales
      wa_processdata_alt-orderid = wa_orderdata-orderid.
      wa_processdata_alt-preference = lv_preference = lv_preference + 1.
      CLEAR: l_edidd.
      l_edidd-sdata = wa_processdata_alt.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_processdata_alt )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.
    ENDLOOP.
  ENDIF.

  "Cálculo del RATIO OUT IN
  "Finalmente lo que vamos a hacer para pasar el ratiooutin en cada operación es:
  "Dividir el UMREZ de la operación antecesora al UMREZ de la operación predecesora, y tomar la última operación como UMREZ = 1.
  DATA it_ratio TYPE TABLE OF ty_ratio.
  SORT it_operation_all BY vornr ASCENDING.
  DESCRIBE TABLE it_operation_all LINES DATA(operaciones).
  "  En el caso de manipulado manual ARBPL 2001_413 o 2003_414 se debe enviar a OMP ratiooutin = 1 si la operación siguiente
  "a esta es paletizado , es decir, cuando la operación manual es la penúltima. Es decir, si tiene una operación previa que
  "tenga un UMREZ de 4, el resultado de la pose en esa operación previa será 4 porque dividirá por 1 de la operación manual.
  "Si la operación manual no es la penúltima, hay que tratarla como una operación más.
  DATA puesto TYPE tty_puesto.
  CLEAR puesto[].
  DATA ruta_auxiliar TYPE tty_ruta.
  CLEAR ruta_auxiliar.
  PERFORM calculo_ratio TABLES it_operation_all
                               it_ratio
                               puesto
                               ruta_auxiliar.
  "Movido a PERFORM CALCULO_RATIO.
*  SELECT arbpl, objid
*  INTO TABLE @DATA(it_puestos)
*        FROM crhd
*    FOR ALL ENTRIES IN @it_operation_all
*    WHERE objid EQ @it_operation_all-arbid
*        AND objty EQ 'A'
*        AND werks EQ @it_operation_all-werks.
*  LOOP AT it_operation_all ASSIGNING FIELD-SYMBOL(<all>).
*    READ TABLE it_puestos WITH KEY objid = <all>-arbid ASSIGNING FIELD-SYMBOL(<puesto>).
*    IF sy-subrc = 0 AND ( <puesto>-arbpl EQ c_operman_1 OR <puesto>-arbpl EQ c_operman_2 ).
*      DATA lv_oper TYPE i.
*      lv_oper = 0.
*      LOOP AT it_operation_all TRANSPORTING NO FIELDS WHERE vornr > <all>-vornr.
*        lv_oper = lv_oper + 1.
*      ENDLOOP.
*      IF lv_oper = 1.
*        <all>-umrez = 1.
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
*
*  "Ya no necesitamos los cálculos del resto de puestos
*  DELETE it_operation_all WHERE steus EQ 'PP02' OR steus EQ 'PP03'.
*  LOOP AT it_operation_all INTO DATA(wa_oper).
*    APPEND INITIAL LINE TO it_ratio ASSIGNING FIELD-SYMBOL(<ratio>).
*    <ratio>-vornr = wa_oper-vornr.
*    LOOP AT it_operation_all INTO DATA(wa_oper2) WHERE vornr > wa_oper-vornr.
*      <ratio>-ratio = wa_oper-umrez / wa_oper2-umrez.
*      EXIT.
*    ENDLOOP.
*    IF sy-subrc <> 0.
*      <ratio>-ratio = wa_oper-umrez / 1.
*    ENDIF.
*  ENDLOOP.
  "Movido a PERFORM CALCULO_RATIO.



*  lv_auxlevel = 4.
  DATA: wa_oper_anterior TYPE afvgb,
        lv_primera type abap_bool,
        lv_ultima  type abap_bool.
  clear wa_oper_anterior.
  LOOP AT it_operation INTO DATA(wa_oper).
    clear: lv_primera, lv_ultima.
    AT first.
      lv_primera = 'X'.
    ENDAT.

    AT LAST.
      lv_ultima = 'X'.
    ENDAT.
**  cCoperation   Se repite por operaciones en la OF  #¡VALOR!9
    wa_operation-operation = c_replace." #¡VALOR!
    CLEAR: l_edidd.
    l_edidd-sdata = wa_operation.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operation )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.
**  cCoperationdata     #¡VALOR!
    wa_operationdata1-automaticsetupkey = 0."0" Preguntar a hinojosa  X CODIGO DE MOSAICO (PLEGADORAS SOLO RHX) -  No relevante para HPP - Identificar como hacemos esto en SAP
*wa_operationdata1-Baseassembly  Preguntar a hinojosa  X NO relavante
*wa_operationdata1-Boardcoating  Preguntar a hinojosa  X NO relavante


    "Solo enviar en operación de tren ondular
*    IF wa_oper-vornr EQ 10.

    "INICIO REPLACE - 31/10/2024 - nueva lógica, buscar por puesto de trabajo
****    "JVM - Ancho plancha
****    IF lv_ultima EQ abap_true AND wa_td100-joity <> space.
****
****      WRITE wa_td100-shtnl LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardlength. "Preguntar a Hinojosa  X SHTGL en tabla TD100
****      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardlength WITH ''.
****      CONDENSE wa_operationdata1-boardlength.
****      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardlength WITH '.'.
****      WRITE wa_td100-shtnw LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardwidth. "Preguntar a Hinojosa  X SHTGW en tabla TD100
****      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardwidth WITH ''.
****      CONDENSE wa_operationdata1-boardwidth.
****      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardwidth WITH '.'.
****
****    ELSE.
****
****      WRITE wa_td100-shtgl LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardlength. "Preguntar a Hinojosa  X SHTGL en tabla TD100
****      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardlength WITH ''.
****      CONDENSE wa_operationdata1-boardlength.
****      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardlength WITH '.'.
****      WRITE wa_td100-shtgw LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardwidth. "Preguntar a Hinojosa  X SHTGW en tabla TD100
****      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardwidth WITH ''.
****      CONDENSE wa_operationdata1-boardwidth.
****      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardwidth WITH '.'.
****
****    ENDIF.
****    "FJVM - Ancho plancha
****
    IF lv_esgrafo_cab EQ abap_true.

      "Debenmos obtener esta inforamción de uno de los semis que componen el assemble
      DATA ti_100 TYPE yhp_omp_tt_td100.
      FREE ti_100.
      LOOP AT it_component INTO wa_compo.
        IF wa_compo-matnr IS INITIAL.
          CONTINUE.
        ENDIF.
        SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
        IF lv_mtart_compo EQ 'ZPSE'.
          SELECT SINGLE cuobj FROM marc WHERE matnr EQ @wa_compo-matnr AND cuobj <> @space INTO @DATA(lv_objete).
          IF lv_objete IS NOT INITIAL.
            CALL FUNCTION 'YHP_OMP_INTERFACE'
              EXPORTING
                if_cuobj = lv_objete
              IMPORTING
                et_td100 = ti_100
*               et_td101 =
*               et_td110 =
*               et_td111 =
*               et_td130 =
*               et_td131 =
*               et_td140 =
*               et_td150 =
*               et_td151 =
*               et_td310 =
*               et_td400 =
*               et_bom   =
*               et_rte   =
              .
            EXIT.
          ENDIF.
        ENDIF.
      ENDLOOP.

      READ TABLE ti_100 INTO DATA(wi_100) INDEX 1.
****      DIVIDE wi_100-shtgl BY 2.
***      WRITE wi_100-shtgl LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardlength. "Preguntar a Hinojosa  X SHTGL en tabla TD100
***      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardlength WITH ''.
***      CONDENSE wa_operationdata1-boardlength.
***      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardlength WITH '.'.
***
****      DIVIDE wi_100-shtgw BY 2.
***      WRITE wi_100-shtgw LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-boardwidth. "Preguntar a Hinojosa  X SHTGW en tabla TD100
***      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-boardwidth WITH ''.
***      CONDENSE wa_operationdata1-boardwidth.
***      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-boardwidth WITH '.'.
    ELSE.
      wi_100 = wa_td100.
    ENDIF.
    "Nueva lógica 31/10/2024

    PERFORM boardwidth_length USING wi_100
                                    wa_oper
                                    lv_ultima
                                    lv_primera
                                    wa_oper_anterior
                              CHANGING wa_operationdata1-boardwidth
                                       wa_operationdata1-boardlength.
    "Fin Nueva logica 31/10/2024

    "FIN REPLACE - 31/10/2024 - nueva lógica, buscar por puesto de trabajo

*  ENDIF.
*wa_operationdata1-Bundlenofbehind Preguntar a hinojosa  X Ver campo con aicomp, tabla 151 No relevante
    READ TABLE et_td151 WITH KEY shuty = 'GROUP' INTO DATA(wa_td151).
    IF sy-subrc = 0.
      WRITE wa_td151-prqty LEFT-JUSTIFIED DECIMALS 0 TO wa_operationdata1-bundlenofblanks."Preguntar a hinojosa  X Ver campo con aicomp, tabla 151
      WRITE wa_td151-shunt LEFT-JUSTIFIED TO wa_operationdata1-bundlestrappinginfo. "Preguntar a hinojosa  X Consultar campo a aicomp, es el tipo de material embalaje en shipping y unitizing A partir del COBJ, buscar campo SHUTY = group, es el campo SHUNT
      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-bundlenofblanks WITH ''.
      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-bundlestrappinginfo WITH ''.
      CONDENSE: wa_operationdata1-bundlestrappinginfo, wa_operationdata1-bundlenofblanks.
    ENDIF.
    READ TABLE et_td151 WITH KEY shuty = 'UNIT' INTO wa_td151.
    IF sy-subrc = 0.
      wa_operationdata1-bundlenofnext = wa_td151-prqty.
      WRITE wa_td151-prqty LEFT-JUSTIFIED  DECIMALS 0 TO wa_operationdata1-bundlenofnext. "Preguntar a hinojosa  X Ver campo con aicomp, tabla 151
      "A partir del COBJ, buscar campo SHUTY = UNIT , es el campo PACKP. Tabla TD151
      WRITE wa_td151-packp LEFT-JUSTIFIED TO wa_operationdata1-bundlehorizontalpattern ."Preguntar a hinojosa  X Imagen del mosaico de paletizado en HPX - Patron de manipulado, tabla TD151, ver campo con aicomp

      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-bundlenofnext WITH ''.
      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-bundlehorizontalpattern  WITH ''.
      CONDENSE: wa_operationdata1-bundlehorizontalpattern , wa_operationdata1-bundlenofnext.
    ENDIF.
*wa_operationdata1-Bundleprotection  Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Bundlerulenext  Preguntar a hinojosa  X NO relevante

    "JVM -modif 26/09/2022 -   Para todas las operaciones en el campo comments, de momento tenemos que pasarle el descriptivo del producto
    "del VC que ya lo estamos pasando en la  wa_td100-obser. Y para otras fases ya veremos de cambiarlo según Asenjo
    wa_operationdata1-comments = wa_td100-obser." wa_oper-ltxa1."description." Comentarios a nivel de operación de la OF. Con la función de AICOMP recuperar el campo LTXA1 de la tabla ET_RTE para la operación tratada #¡VALOR!  ok
    "NO ESTA ESTÁ
******************************wa_operationdata1-Complexity = wa_td100-diecw / wa_td100-diecl. "Preguntar a hinojosa  X DIECW / DIECL en TD100 concatenado PENDIENTE DE SACAR CAMPO A TABLA
*wa_operationdata1-Corediameter  "Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Defaultoffset "N/A en  V5  #¡VALOR!  NO relevante
*wa_operationdata1-Delayendstart "Retraso entre fin de operación anterior y esta. Preguntar a hinojosa  X Campo tiempo de espera de Aicomp, deberia estar en tabla TD110. Depende de la calidad NO PASAR
*wa_operationdata1-Delaystartstart Retraso entre comienzo de operación anterior y esta.Preguntar a hinojosa  X NO relevante

    "Comprobamos si la operación es Diecuttechnology sólo en la operación donde se troquela.
    CLEAR lv_arbpl.
    SELECT SINGLE arbpl INTO @lv_arbpl FROM crhd WHERE objid EQ @wa_oper-arbid AND objty EQ 'A'.
    CLEAR lv_busqueda.
    CONCATENATE lv_werks lv_arbpl INTO lv_busqueda.
    CONDENSE lv_busqueda NO-GAPS.
    "Buscamos en tablas AICOMP
    CLEAR lv_machinetype.
    PERFORM get_machine_type USING lv_busqueda CHANGING lv_machinetype.
    IF lv_machinetype EQ 'PC_MT_DC'.
      CASE wa_td100-tdcut.
        WHEN 'FBD'.
          wa_operationdata1-diecuttechnology = 'Flatbed'."wa_td100-tdcut."Preguntar a hinojosa  X TDCUT en TD100
        WHEN 'RTY' OR 'INT'.
          wa_operationdata1-diecuttechnology = 'Rotary'."
        WHEN OTHERS.
          wa_operationdata1-diecuttechnology = ''."
      ENDCASE.
    ENDIF.
    "INI JVM - 29/07/2024 - Nuevo campo BOARDGLUE
    "Parafina o Cera. Que es un componente que se añade en la fabricación de cajas que son
    "para fruta y verdura para que no penetre humedad. Este componente queda a nivel de LdM
    "pero evidentemente el numero de material puede variar con el tiempo o con el centro.
    "El campo en OMP es Boardglue, segmento ZZOperation ZZoperationdata1 o 2, solo para
    "operación de ondulado o que sea puesto de trabajo 2*_1*
    "El valor no baja a tablas idx, pero en propias de aicomp queda:
    "Con el campo de la calidad (GRADEID) que sacamos previamente en el segmento zzproduct,
    "Tabla ZVCXI_PCS_TD100, donde por gradeid, sacamos BoardVersion GUID
    "Con este valor vamos a Tabla ZVCXI_PCS_TD102:
    "Si la Board Version GUID lleva algún valor en el campo WAXCO/PARAFINA: marcar a yes.
    "Si está vacío, dejar vacío
    "Nota para OMP: este valor viaja a BHS en el campo SteamingGap
    IF lv_arbpl(1) = '2' AND lv_arbpl CS '_1'.


      DATA(lv_board) = wa_td110-board.
      IF lv_board CS '_P'.
        REPLACE ALL OCCURRENCES OF '_P' IN lv_board WITH ''.
        CONDENSE lv_board.
      ENDIF.

      SELECT SINGLE waxco FROM zvcxi_pcs_td100 AS t1 INNER JOIN zvcxi_pcs_td102 AS t2 ON t1~gbogv = t2~gbogv
        WHERE t1~board = @lv_board
        AND waxco <> @space
        INTO @DATA(lv_bglue).
      IF lv_bglue IS NOT INITIAL.
        wa_operationdata1-boardglue = 'yes'.
      ELSE.
        wa_operationdata1-boardglue = ''. "JVM - 02/10/2024 Cambio arranque pedido por CASENJO no enviar no, sino Vacío
      ENDIF.
    ENDIF.
    "INI JVM - 29/07/2024 - Nuevo campo BOARDGLUE



*wa_operationdata1-Documentname  Preguntar a Hinojosa  X NO relevante
    wa_operationdata1-erpoperationid = wa_oper-vornr."operation_number. "Numero de operación. Con la función de AICOMP recuperar el campo VORNR de la tabla ET_RTE para la operación tratada #¡VALOR!  ok
*wa_operationdata1-Fixedstep Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Foldlength  Preguntar a hinojosa  X NO relevante
*    wa_operationdata1-footprintlength = wa_mara-zzpalletlar. "Preguntar a hinojosa  X Corresponde al largo del componente palet que lleva la orden. Está en la vista Z hinojosa general
*    wa_operationdata1-footprintwidth  = wa_mara-zzpalletanc. "Preguntar a hinojosa  X Corresponde al ancho del componente palet que lleva la orden. Está en la vista Z hinojosa general
*wa_operationdata1-Forcedprogramlayout Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Forcedprogrammultiplicity Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Forcedprogramtrimleftside Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Forcedprogramwidth  Preguntar a hinojosa  X NO relevante

    "Campos Glueing y Folding en ccoperation de orders. Tenemos que leer campo JOIPO en
    "YHP_IDX_TD100 y si es distinto a N, marcar yes en ambos campos en la operación.
    "El caso es que debería ir solo en la operación de pegado igual que las que comentábamos
    "el otro día que iban a impresión.
    "Si veis lógica igual que el otro día comentadme, si NO, estamos viendo que NO
    "hay un caso donde se existe un JOIPO distinto de N, NO sea en la última operación ( quitando paletizado)
*    CLEAR lv_machinetype.
*    PERFORM get_machine_type USING lv_busqueda CHANGING lv_machinetype.
    "UPDATE: 22/09/2022 Con el material cabecera de la OF vamos a la YHP_IDX_TD100 entrando por CUOBJ y cogemos el campo JOITY y JOIPO.
    "  Campo folding:
    "Si JOIPO = I hay que poner Yes, si JOIPO = N ponemos No.
    "  Y para saber qué pasar en el campo glueing:
    "Ahora en la tabla de custo  ZVCXI_P0S_TD342 entramos por JOITY y si existe registro, entonces ponemos Yes en el campo glueing si no existe ponemos No.

    SELECT SINGLE * INTO @DATA(wa_td342) FROM zvcxi_p0s_td342
          WHERE joity = @wa_td100-joity
*          AND matnr = @lv_matnr_head
          AND valfr <= @sy-datum.
    IF ( lv_machinetype EQ 'PC_MT_CLOS' OR lv_machinetype EQ 'PC_MT_CM' ) AND wa_td100-joipo <> 'N'.
      IF wa_td342 IS NOT INITIAL.
        wa_operationdata1-glueing = 'yes'.
      ELSE.
        wa_operationdata1-glueing = 'no'.
      ENDIF.
      wa_operationdata1-folding = 'yes'.
    ELSEIF ( lv_machinetype EQ 'PC_MT_CLOS' OR lv_machinetype EQ 'PC_MT_CM' ) AND wa_td100-joipo = 'N'.
      IF wa_td342 IS NOT INITIAL.
        wa_operationdata1-glueing = 'no'.
      ELSE.
        wa_operationdata1-glueing = 'yes'.
      ENDIF.
      wa_operationdata1-folding = 'no'.
    ENDIF.
    CLEAR wa_td342.
*wa_operationdata1-Interpolatedsheet Preguntar a hinojosa  X NO relevante
*wa_operationdata1-IncompatibleKnifeId Preguntar a hinojosa  X NO relevante
*wa_operationdata1-Inliner Preguntar a hinojosa  X NO relevante
    READ TABLE et_td150 INTO wa_td150 INDEX 1.
    SELECT SINGLE nolab INTO wa_operationdata1-labelnofperpallet
    FROM zvcxi_xcs_tc102
    WHERE lapos EQ wa_td150-lapos. "¿Número de etiquetas por pallet? ¿Viene de AICOMP? En principio 1. Preguntar a hinojosa X Tenemos esta indicacion en el fichero de tablas indexadas: Se saca con lógica
*    nolab. zvcxi_xcs_tc102-nolab
    REPLACE ALL OCCURRENCES OF '"' IN wa_operationdata1-labelnofperpallet WITH ''.

    wa_operationdata1-labeltype = wa_td150-lapos."Preguntar a Hinojosa  X Distribución de las etiqueta muestra. Campo caja de referencia en el VC Tabla TD150, campo LAPOS
    READ TABLE et_td151 WITH KEY shuty = 'STACK' INTO wa_td151.
    IF sy-subrc = 0.
      wa_operationdata1-layernof = wa_td151-prqty." Preguntar a Hinojosa  X Ver campo con aicomp, tabla 151
      WRITE wa_td151-prqty LEFT-JUSTIFIED  DECIMALS 0 TO wa_operationdata1-layernof.
      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-layernof WITH ''.
      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-layernof WITH ''.
      CONDENSE wa_operationdata1-layernof NO-GAPS.
    ENDIF.
*wa_operationdata1-Layerstrappinginfo  Preguntar a Hinojosa  X NO relevante
    READ TABLE et_td151 WITH KEY shuty = 'STACK' INTO wa_td151.
    IF sy-subrc = 0.
      wa_operationdata1-layerverticalpattern = wa_td151-packp. "Preguntar a Hinojosa  X Ver campo con aicomp, tabla 151 - Patron de pila
    ENDIF.
*    wa_operationdata1-localloss = wa_oper-asvrg ."scrap."Rechazo a nivel de operación de la orden de fabricación.  #¡VALOR!  Merma prevista. Campo calculado en Aicomp que se explota en la creacion de la orden.
    WRITE wa_oper-aufak TO wa_operationdata1-localloss LEFT-JUSTIFIED DECIMALS 3."asvrg ."scrap."Rechazo a nivel de operación de la orden de fabricación.  #¡VALOR!  Merma prevista. Campo calculado en Aicomp que se explota en la creacion de la orden.
    REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-localloss WITH ''.
    REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata1-localloss WITH '.'.
    CONDENSE wa_operationdata1-localloss  NO-GAPS.
*wa_operationdata1-Materiallossper1000boards N/A en V5 #¡VALOR!  NO relevante
*wa_operationdata1-Materiallosssetup  rechazo durante Setup. Preguntar a hinojosa X NO relevante
*wa_operationdata1-Maxheightgross  = wa_td100-folhe."Preguntar a Hinojosa  X FGHEI en TD100 NO relevante
*wa_operationdata1-Maxheightnet  Preguntar a Hinojosa  X NO relevante
*wa_operationdata1-Maxmultiplicity Preguntar a Hinojosa  X NO relevante
*wa_operationdata1-Maxnofparts Preguntar a Hinojosa  X NO relevante
*wa_operationdata1-Maxoffset N/A en V5 #¡VALOR!  NO relevante
*wa_operationdata1-Maxsmuggling  Preguntar a Hinojosa  X NO relevante
*    SELECT SINGLE t1~* INTO @DATA(wa_afvv) FROM afvv AS t1 INNER JOIN afvc AS t2 ON t1~aufpl EQ t2~aufpl AND t1~aplzl EQ t2~aplzl
*          INNER JOIN afko AS t3 ON t2~aufpl EQ t3~aufpl
*          WHERE aufnr EQ @lv_number
*          AND vornr EQ @wa_oper-vornr."operation_number.
*    IF sy-subrc <> 0.
*
*    ENDIF.
    READ TABLE it_operation WITH KEY vornr = wa_oper-vornr INTO DATA(wa_tiempos).
    IF sy-subrc = 0.
      DATA wa_afvv TYPE afvv.
      MOVE-CORRESPONDING wa_tiempos TO wa_afvv.
    ELSE.
      SELECT SINGLE t1~* INTO @wa_afvv FROM afvv AS t1 INNER JOIN afvc AS t2 ON t1~aufpl EQ t2~aufpl AND t1~aplzl EQ t2~aplzl
            INNER JOIN afko AS t3 ON t2~aufpl EQ t3~aufpl
            WHERE aufnr EQ @lv_number
            AND vornr EQ @wa_oper-vornr."operation_number.
    ENDIF.

    DATA tiempo TYPE p DECIMALS 3.
    DATA tiempo_segundos TYPE i.

    CLEAR: tiempo, tiempo_segundos.

*    tiempo = wa_afvv-vgw02.
    tiempo = wa_afvv-bearz.
*      RUEST
*      RSTZE
*      BEARZ
*      BEAZE

    CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
      EXPORTING
        input                = tiempo
*       NO_TYPE_CHECK        = 'X'
*       ROUND_SIGN           = ' '
*       unit_in              = wa_afvv-vge02
        unit_in              = wa_afvv-beaze
        unit_out             = 'S'
      IMPORTING
*       ADD_CONST            =
*       DECIMALS             =
*       DENOMINATOR          =
*       NUMERATOR            =
        output               = tiempo_segundos
      EXCEPTIONS
        conversion_not_found = 1
        division_by_zero     = 2
        input_invalid        = 3
        output_invalid       = 4
        overflow             = 5
        type_invalid         = 6
        units_missing        = 7
        unit_in_not_found    = 8
        unit_out_not_found   = 9
        OTHERS               = 10.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.

*   cambiar jtm 01.11.2022
    IF gamng_aux > 0.
      READ TABLE it_ratio WITH KEY vornr = wa_oper-vornr ASSIGNING FIELD-SYMBOL(<ratiocalc>).
      IF sy-subrc = 0.
        TRY.
            wa_operationdata2-mfgtime = ( tiempo_segundos * 1000 / gamng_aux ) * <ratiocalc>-ratio.
          CATCH cx_root.
        ENDTRY.
      ELSE.
        TRY.
            wa_operationdata2-mfgtime = tiempo_segundos * 1000 / gamng_aux .
          CATCH cx_root.
        ENDTRY.
      ENDIF.
    ELSE.
      wa_operationdata2-mfgtime = tiempo_segundos. " valor original
    ENDIF.
*   fin de cambiar jtm 01.11.202
*    "wa_afvv-vgw02 ."Tiempo de maquina de la operación.   Formato -> + 0w 0d 0h 0m 1s. Con la función de AICOMP recuperar el campo VGW02 de la tabla ET_RTE para la operación tratada"
*   fin de cambiar jtm 01.11.2022
    CONDENSE wa_operationdata2-mfgtime NO-GAPS.
    "#¡valor!  de igual modo que la merma, es el tiempo previsto de produccion para la orden
*wa_operationdata2-Minmultiplicity Preguntar a Hinojosa  X NO relevante
*wa_operationdata2-Minoffset N/A en V5 #¡VALOR!  NO relevante
*wa_operationdata2-Nofgluepoints Preguntar a Hinojosa  X NO relevante
*wa_operationdata2-Nofstitchingpoints  Preguntar a Hinojosa  X NO relevante
    wa_operationdata2-operationnr = wa_oper-vornr."operation_number. "operación. Con la función de AICOMP recuperar el campo VORNR de la tabla ET_RTE para la operación tratada #¡VALOR!  Numero de operación de la orden
*wa_operationdata2-Palletassembly  Preguntar a hinojosa  X NO relevante

    wa_operationdata2-palletizationcomments = wa_td100-obser."Preguntar a hinojosa si son los comentarios en la operación de paletizado X Comentarios de paletizado. Revisar Carlos si es necesario
*wa_operationdata2-Palletlength = wa_td100-folle. "Preguntar a hinojosa  X FGLEN en TD100 NO relevante
    READ TABLE et_td151 WITH KEY shuty = 'UNIT' INTO wa_td151.
    IF sy-subrc = 0.
      WRITE wa_td151-tbqty LEFT-JUSTIFIED  DECIMALS 0 TO wa_operationdata2-palletnofproducts."Preguntar a hinojosa  X Ver campo con aicomp, tabla 151. Si NO es directo es multiplicacion
      REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata2-palletnofproducts WITH ''.
      REPLACE ALL OCCURRENCES OF ',' IN wa_operationdata2-palletnofproducts WITH ''.

      "JVM - 29/10/2024 - INCIDENCIA EN PRODUCTIVO
*      Campo palletnofproducts. Esto es el problema gordo que tuvimos hace dos semanas donde pasamos en lugar
*      de 1200 unidades por palet 1.200, de manera que OMP calculaba 40.000 UAs para una OF y colapsó. Esto
*      JV si recuerdas ya quitaste el separador de miles y no tendría que volver a pasar. Pero si por lo que
*      sea un usuario se equivoca y pone que un material paletiza a 1 caja tendremos el mismo efecto. Juanvi
*      está viendo en origen como caparlo, pero yo me quedo mas tranquilo si añadimos también en el interface
*      una condición, que si el valor recuperado es inferior a 10 ( el paletizado mínimo que tenemos es de 75
*      cajas), sobrescribirlo a un valor genérico que impida lo que nos sucedió hace dos semanas, 999 uds.
      IF wa_td151-tbqty < 10.
        wa_operationdata2-palletnofproducts = '999'.
      ENDIF.
    ENDIF.
    "FJVM
    "de las filas 211*212*213
*wa_operationdata2-Palletstrappingduration Preguntar a hinojosa  X NO relevante
    wa_operationdata2-palletstrappinginfo = wa_td150-pbcod."preguntar a hinojosa  x ver campo con aicomp, tabla 150. codigo de barras para paletizar/flejar, etc
*wa_operationdata2-Palletstrappingmachine  Preguntar a hinojosa  X NO relevante
*wa_operationdata2-palletwidth = wa_td100-folwi. "wa preguntar a hinojosa  X fgwid en td100 NO RELEVANTE
*wa_operationdata2-Palletwrappingduration  Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Palletwrappinginfo  Preguntar a hinojosa si es el numero de material Pallet X NO relevante
*wa_operationdata2-Palletwrappingmachine Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Perforationlength Preguntar a hinojosa  X NO relevante

    SELECT SINGLE arbpl
    INTO @DATA(lv_puesto)
          FROM crhd
          WHERE objid EQ @wa_oper-arbid
          AND objty EQ 'A'
          AND werks EQ @wa_oper-werks.
    IF sy-subrc <> 0.
      READ TABLE et_rte WITH KEY vornr = wa_oper-vornr plnnr = wa_oper-plnnr INTO DATA(wa_rte).
      IF sy-subrc = 0.
        wa_operationdata2-prefmachineid = lv_puesto = wa_rte-arbpl."wa_oper-work_center.
        "Puesto de trabajo ARBPL. Con la función de AICOMP recuperar el campo ARBPL de la tabla ET_RTE para la operación tratada #¡VALOR!  Maquina de la hoja de ruta de la  operación
      ENDIF.
    ELSE.
      wa_operationdata2-prefmachineid = lv_puesto.
    ENDIF.
    "pendiente
*    WERKS
*    ARBPL
*    PCDIR
    READ TABLE et_td310 WITH KEY werks = wa_oper-werks arbpl = lv_puesto INTO DATA(wa_310).
    "Preguntar a hinojosa  X Direccion de plancha, ver Carlos campo en aicomp
    CASE wa_310-pcdir.
      WHEN 'A'.
        wa_operationdata1-boardinput = 'lying'.
      WHEN 'B'.
        wa_operationdata1-boardinput = 'standing'.
      WHEN OTHERS.
    ENDCASE.



    READ TABLE et_td130 INTO DATA(wa_td130) INDEX 1.
    "PENDIENTE
*    CLEAR lv_arbpl.
*    SELECT SINGLE arbpl INTO @lv_arbpl FROM crhd WHERE objid EQ @wa_oper-arbid AND objty EQ 'A'.
*    CLEAR lv_busqueda.
*    CONCATENATE lv_werks lv_arbpl INTO lv_busqueda.
*    CONDENSE lv_busqueda NO-GAPS.
    "Buscamos en tablas AICOMP
*    CLEAR lv_machinetype.
*    PERFORM get_machine_type USING lv_busqueda CHANGING lv_machinetype.
*    IF lv_machinetype EQ 'P0_MT_PRINT'.
    IF lv_machinetype EQ 'P0_MT_PRINT' OR lv_machinetype EQ 'PC_MT_DC' OR lv_machinetype EQ 'PC_MT_CM'.
      IF wa_td130-prtyp IS NOT INITIAL.
        wa_operationdata2-printingtechnology  = 'FLEXO'."wa_td130-prtyp. "Preguntar a hinojosa  X PRTYP en TD130
      ENDIF.

      CASE wa_td130-prsid.
        WHEN 'I'.
          wa_operationdata2-printside = 'inside'.
        WHEN 'O'.
          wa_operationdata2-printside = 'outside'.
        WHEN OTHERS.
          wa_operationdata2-printside = 'none'.
      ENDCASE.

    ENDIF.
*wa_operationdata2-Printinguptotheedge Preguntar a hinojosa  X NO relevante

*    wa_operationdata2-printside = wa_td130-prsid. "Preguntar a hinojosa  X PRSID en TD130
    wa_operationdata2-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!  Este concepto NO existe en AS400, por eso lo hacemos así. NO existe este concepto en SAP?
    wa_operationdata2-producingtrpgoods = 'no'. " Preguntar a hinojosa  X Cuando es ultima operación (produce stock) = yes
    AT LAST.
      wa_operationdata2-producingtrpgoods = 'yes'. " Preguntar a hinojosa  X Cuando es ultima operación (produce stock) = yes
    ENDAT.
    "ADD JVM - Segun mail Carlos asenjo para grafos solo enviar YES en el grafo de cabecera
    IF lv_es_grafo EQ abap_true AND lv_esgrafo_cab IS INITIAL AND wa_operationdata2-producingtrpgoods = 'yes'.
      wa_operationdata2-producingtrpgoods = 'no'.
    ENDIF.
    "ADD JVM - Segun mail Carlos asenjo para grafos solo enviar YES en el grafo de cabecera
*wa_operationdata2-QTSpecification Preguntar a hinojosa  X NO relevante
    READ TABLE it_ratio WITH KEY vornr = wa_oper-vornr ASSIGNING FIELD-SYMBOL(<ratio>).
    IF sy-subrc = 0.
      wa_operationdata2-ratiooutin  = <ratio>-ratio."wa_oper-umrez."wa_td100-noupt. " ¿A que se refiere este campo? ¿Viene de AICOMP? #¡VALOR!  NOUPT en TD100 (de la operación)
    ENDIF.
*wa_operationdata2-Relativecrushdepth  Preguntar a hinojosa  X NO  relevante
*wa_operationdata2-Relativescoregap  Preguntar a hinojosa  X NO relevante
    wa_operationdata2-rfidlabeltype = wa_td150-tlabl. "Preguntar a hinojosa  X Ver campo con aicomp, tabla 150. Tipo de etiqueta unidad
*wa_operationdata2-Rotateflute Preguntar a hinojosa  X NO relevante
    IF wa_oper-vornr EQ 10.
      SORT et_td140 BY iscor ASCENDING.

      DATA(it_aux140) = et_td140[].
      DELETE it_aux140 WHERE iscor(1) <> 'C'.
      DESCRIBE TABLE it_aux140 LINES DATA(numscores).
      IF numscores > 1.

        LOOP AT et_td140 INTO wa_td140 WHERE iscor(1) EQ 'C' .
*        Concatenado de posición de hendido y tipo de hendido.
*    En tabla TD140 es SCORP TSCORP para tantos hendidos Tipo C (campo ISCOR) como existan
          DATA lv_aux TYPE char10.
          WRITE wa_td140-scorp TO lv_aux DECIMALS 0 LEFT-JUSTIFIED.
          DATA lv_aux2 TYPE char10.
          IF wa_td140-tscor NE 'X'.
            WRITE wa_td140-tscor DECIMALS 0 TO lv_aux2 LEFT-JUSTIFIED .
          ELSE.
            CLEAR lv_aux2.
          ENDIF.
*      CONCATENATE wa_operationdata2-scores wa_td140-scorp wa_td140-tscor INTO wa_operationdata2-scores."Preguntar a hinojosa  X Distancia hendidos separados por '/' O '-' (dependiendo del tipo). Campo muy importante, ver en TD140 como viene
          CONCATENATE wa_operationdata2-scores lv_aux lv_aux2 INTO wa_operationdata2-scores."Preguntar a hinojosa  X Distancia hendidos separados por '/' O '-' (dependiendo del tipo). Campo muy importante, ver en TD140 como viene
          REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata2-scores WITH ''.
        ENDLOOP.

      ENDIF.
    ENDIF.


    CLEAR: tiempo, tiempo_segundos.

*    tiempo = wa_afvv-vgw01.
    tiempo = wa_afvv-ruest.
*            RUEST
*            RSTZE
*            BEARZ
*            BEAZE
    CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
      EXPORTING
        input                = tiempo
*       NO_TYPE_CHECK        = 'X'
*       ROUND_SIGN           = ' '
*       unit_in              = wa_afvv-vge01
        unit_in              = wa_afvv-rstze
        unit_out             = 'S'
      IMPORTING
*       ADD_CONST            =
*       DECIMALS             =
*       DENOMINATOR          =
*       NUMERATOR            =
        output               = tiempo_segundos
      EXCEPTIONS
        conversion_not_found = 1
        division_by_zero     = 2
        input_invalid        = 3
        output_invalid       = 4
        overflow             = 5
        type_invalid         = 6
        units_missing        = 7
        unit_in_not_found    = 8
        unit_out_not_found   = 9
        OTHERS               = 10.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.


*    WRITE wa_afvv-vgw01 LEFT-JUSTIFIED  DECIMALS 0 TO wa_operationdata2-setuptime. "Tiempo de preparación. Con la función de AICOMP recuperar el campo VGW01 de la tabla ET_RTE para la operación tratada #¡VALOR!  Tiempo previsto de preparacion. Se
    wa_operationdata2-setuptime = tiempo_segundos. "Tiempo de preparación. Con la función de AICOMP recuperar el campo VGW01 de la tabla ET_RTE para la operación tratada #¡VALOR!  Tiempo previsto de preparacion. Se
    "explota al generar la orden
    CONDENSE wa_operationdata2-setuptime NO-GAPS.
*wa_operationdata2-Smugglingpenalty  Preguntar a hinojosa  X NO relevante

    wa_operationdata2-specialgluelap = wa_td100-joity. "Preguntar a hinojosa  X Campo para pestaña prolongada. Revisar Carlos Campo JOITY en la TD100


*  El inicio es como en el resto de casos para recuperar el CUOBJ, con esto entrar a la tabla YHP_IDX_TD100 y
*  si el campo PRSTY es igual a 110 # coger el campo de altura de producto YHP_IDX_TD100-PROHE y multiplicarlo
*  por el campo cantidad (TBQTY) de la tabla YHP_IDX_TD151 cuando el campo SHUTY es igual a STACK.
    IF wa_td100-prsty EQ '110'.
      READ TABLE et_td151 INTO DATA(td151_aux) WITH KEY shuty = 'STACK'.
      IF sy-subrc = 0.
        wa_operationdata2-stackheight = wa_td100-prohe * td151_aux-tbqty. "Preguntar a hinojosa  X Cuando tipo de producto = SHEET, debemos llevar la altura del palet FGHEI en TD100
      ELSE.
        wa_operationdata2-stackheight = '0'.
      ENDIF.
    ELSE.
      wa_operationdata2-stackheight = '0'.
    ENDIF.
*wa_operationdata2-Stitching Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Taping  Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Targetspeedgroup  Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Topassembly Preguntar a hinojosa  X NO relevante
*wa_operationdata2-Volumegross Preguntar a hinojosa  X NO relevante

*wa_operationdata2-Weightgross Preguntar a hinojosa  X FGWEI en TD100No relevante
*wa_operationdata2-Weightnet Preguntar a hinojosa  X FGWEI en TD100No relevante

    "JVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
    IF lv_ultima EQ abap_true AND lv_aplica_pp11 EQ abap_true.
      READ TABLE et_td151 WITH KEY shuty = 'UNIT' INTO DATA(wa_151_gap11).
      IF sy-subrc = 0.
        " En el último segmento de ccoperation:
        "FootPrintWidth -> ancho de la base del palet con la mercancía. Se utiliza para cubicar el palet. YHP_IDX_TD151-WIDTH
        "FootPrintLength -> largo de la base del palet con la mercancía. Se utiliza para cubicar el palet. YHP_IDX_TD151-LENGTH
        "MaxHeightGroos -> alto del palet con la mercancía. Se utiliza para cubicar el palet. YHP_IDX_TD151-HEIGHT
        wa_td151-width = wa_td151-width / 1000.
        WRITE wa_td151-width LEFT-JUSTIFIED  DECIMALS 3 TO wa_operationdata1-footprintwidth.
        REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-footprintwidth WITH ''.
        CONDENSE wa_operationdata1-footprintwidth NO-GAPS.
        REPLACE ALL OCCURRENCES OF ',' IN  wa_operationdata1-footprintwidth WITH '.'.

        wa_td151-length = wa_td151-length / 1000.
        WRITE wa_td151-length LEFT-JUSTIFIED DECIMALS 3 TO wa_operationdata1-footprintlength.
        REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-footprintlength WITH ''.
        CONDENSE wa_operationdata1-footprintlength NO-GAPS.
        REPLACE ALL OCCURRENCES OF ',' IN  wa_operationdata1-footprintlength WITH '.'.

        wa_td151-height = wa_td151-height / 1000.
        WRITE wa_td151-height LEFT-JUSTIFIED DECIMALS 3 TO wa_operationdata1-maxheightgross.
        wa_td151-height = wa_td151-height * 1000.
        REPLACE ALL OCCURRENCES OF '.' IN wa_operationdata1-maxheightgross WITH ''.
        CONDENSE wa_operationdata1-maxheightgross NO-GAPS.
        REPLACE ALL OCCURRENCES OF ',' IN  wa_operationdata1-maxheightgross WITH '.'.

        IF ( wa_td151-width IS INITIAL OR wa_td151-width <= 0 ) AND
           ( wa_td151-length IS INITIAL OR wa_td151-length <= 0 ) AND
           ( wa_td151-height IS INITIAL OR wa_td151-height <= 0 ).
          CLEAR: wa_operationdata1-footprintwidth, wa_operationdata1-footprintlength, wa_operationdata1-maxheightgross.
        ENDIF.

      ENDIF.
    ENDIF.
    "FJVM - 19/09/2023 - GAPPP011 - Ajustes en el mensaje ORDERS derivados de documento de Cambios
    CLEAR: l_edidd.
    l_edidd-sdata = wa_operationdata1.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operationdata1 )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.


    CLEAR: l_edidd.
    l_edidd-sdata = wa_operationdata2.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operationdata2 )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.


*    LOOP AT it_component INTO DATA(wa_compo) WHERE operation EQ wa_oper-operation_number.


**  CCORDERALTGRADE   Calidades alternativas  #¡VALOR!
**  operation REPLACE #¡VALOR!
**  CCORDERALTGRADEDATA     #¡VALOR!
**  GradeName GradeId alternativo. Preguntar a hinojosa X TD110, ver campo con aicomp
**  OrderId AFKO-AUFNR  #¡VALOR!
****    CLEAR: l_edidd.
****    l_edidd-sdata = wa_orderaltgrade.
****    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderaltgrade )->get_relative_name( ).
****    APPEND l_edidd TO t_edidd.
****    CLEAR: l_edidd.
****    l_edidd-sdata = wa_orderaltgradedata.
****    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_orderaltgradedata )->get_relative_name( ).
****    APPEND l_edidd TO t_edidd.



**  CcStopcode      #¡VALOR!
**  operation REPLACE #¡VALOR!  Se genera cuando un recurso (troquel O cliche) NO está en stock O tiene un estado NO disponible
**  CcStopcodedata      #¡VALOR!
**  Activeflag  Preguntar a hinojosa  X NO relevante
**  CcStopcodeid  N/A en V5 #¡VALOR!
**  Comments  Preguntar a hinojosa  X NO relevante
**  Erplocked Preguntar a hinojosa  X NO relevante
**  Fromoperationnr Preguntar a hinojosa  X Operación en la que se utiliza el recurso
**  Label Preguntar a hinojosa  X Descripcion a convenir
**  Orderid AFKO-AUFNR  #¡VALOR!
**  Processid mismo que CCPROCESSDATA-PROCESSID #¡VALOR!
**  Removaldate Preguntar a hinojosa  X Fecha del pedido de compra, del pedido de subcontratacion, fecha indicada en el material (falta nombre del campo en VC)
**  StopcodeId  Preguntar a hinojosa  X Codificacion a convenir, es valor unico
****    CLEAR: l_edidd.
****    l_edidd-sdata = wa_stopcode.
****    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_stopcode )->get_relative_name( ).
****    APPEND l_edidd TO t_edidd.
****    CLEAR: l_edidd.
****    l_edidd-sdata = wa_stopcodedata.
****    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_stopcodedata )->get_relative_name( ).
****    APPEND l_edidd TO t_edidd.

    CLEAR:         wa_operationdata1, wa_operationdata2.

    wa_oper_anterior = wa_oper.
  ENDLOOP.

  IF lv_rutas_alt IS NOT INITIAL.
    DATA: it_oper_alt  TYPE cobai_t_operation,
          it_ratio_alt TYPE tty_ratio.

*    route    TYPE yhp_omp_route,
*    vornr    TYPE vornr,
*    arbpl    TYPE arbpl,
*    werks    TYPE werks_d,
*    steus    TYPE steus,
*    vgw01    TYPE vgwrt,
*    vge01    TYPE vgwrteh,
*    vgw02    TYPE vgwrt,
*    vge02    TYPE vgwrteh,
*    vgw03    TYPE vgwrt,
*    vge03    TYPE vgwrteh,
*    umren    TYPE cp_umren,
*    umrez    TYPE cp_umrez,
*    ruta_alt TYPE xfeld,
*    maq_alt  TYPE xfeld,
    LOOP AT it_rutas INTO DATA(wa_ruta_alt) WHERE ruta_alt EQ 'X' GROUP BY ( route = wa_ruta_alt-route ).
      LOOP AT et_rte INTO DATA(wa_rte_alt) WHERE route = wa_ruta_alt-route.

        APPEND INITIAL LINE TO it_oper_alt ASSIGNING FIELD-SYMBOL(<fs_alt>).
        MOVE-CORRESPONDING wa_rte_alt TO <fs_alt>.
        APPEND INITIAL LINE TO puesto  ASSIGNING FIELD-SYMBOL(<puesto>).
        <puesto>-arbpl = wa_rte_alt-arbpl.
      ENDLOOP.
      IF sy-subrc = 0.
*        DATA ruta_auxiliar TYPE tty_ruta.
        CLEAR ruta_auxiliar[].
        LOOP AT GROUP wa_ruta_alt INTO DATA(ruta).
          APPEND ruta TO ruta_auxiliar.
        ENDLOOP.
        PERFORM calculo_ratio TABLES it_oper_alt
                                     it_ratio_alt
                                     puesto
                                     ruta_auxiliar.
        DATA lv_cant_orden TYPE afko-gamng.
        lv_cant_orden = it_header[ 1 ]-gamng.
        PERFORM add_segm_rout_alt TABLES it_oper_alt
                                         it_ratio_alt
*                                         puesto
                                         ruta_auxiliar
                                         et_td151
                                         t_edidd
                                         et_td140
                                         et_td130
                                         et_td310
                                         et_td150
                                   USING wa_td100
                                         wa_mara
                                         lv_number
                                         lv_cant_orden
                                CHANGING l_edidd
                                         lv_auxlevel.

      ENDIF.
      CLEAR: it_oper_alt[], it_ratio_alt[], puesto[].
    ENDLOOP.

  ENDIF.

*  IF it_component[] IS INITIAL.
*
*    SELECT * INTO TABLE @DATA(it_resbd) FROM resb WHERE aufnr EQ @i_aufnr AND xloek EQ @space.
*    it_component[] = CORRESPONDING #( it_resbd[] ).
*
**    LOOP AT it_resbd INTO DATA(wa_resbd).
**      APPEND INITIAL LINE TO it_component ASSIGNING FIELD-SYMBOL(<fs_compo>).
**      <fs_compo>-posnr = wa_resbd-posnr.
**      <fs_compo>-matnr = wa_resbd-matnr.
**      <fs_compo>-bdmng  = wa_resbd-bdmng.
***      a_oper-vornr."mismo que CCOPERATIONDATA-OPERATIONNR #¡VALOR!  Numero de operación
***      wa_opermatdata-opermatnr = wa_compo-posnr."item_number."Secuencia del componente en la operación  #¡VALOR!  Secuencia del componente en la operación
***      wa_opermatdata-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!  Concepto en SAP?
***      wa_opermatdata-productid = wa_compo-matnr."material. "mismo que CCPRODUCTDATA-PRODUCTID #¡VALOR!  Codigo SAP del componente de la BOM
***      wa_opermatdata-quantity = wa_compo-bdmng."req
**    ENDLOOP.
*
*  ENDIF.

  LOOP AT it_operation INTO wa_oper.
    LOOP AT it_component INTO wa_compo WHERE vornr EQ wa_oper-vornr."operation_number.
      "JVM - Replace - 26/03/2024 -
*      IF wa_compo-matnr IS INITIAL.
*        CONTINUE.
*      ENDIF.
*      SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
*      IF lv_mtart_compo EQ 'ZPAP'.
*        CONTINUE.
*      ENDIF.
*      IF wa_compo-baugr <> it_header[ 1 ]-plnbez.
*        CONTINUE.
*      ENDIF.


      IF wa_compo-matnr IS INITIAL.
        CONTINUE.
      ENDIF.
      SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
      IF lv_mtart_compo EQ 'ZPAP' OR lv_mtart_compo EQ 'ZPTK'.
        CONTINUE.
      ENDIF.
      IF lv_mtart_compo EQ 'ZBOM'.
        CONTINUE.
      ENDIF.
      IF wa_compo-baugr <> it_header[ 1 ]-plnbez.

        "INI JVM - 26/03/2024 - Chequeamos si el origen de la necesidad es un dummy, ya que las colas se enviarán así ahora para enviar la cola real
        READ TABLE it_component WITH KEY matnr = wa_compo-baugr dumps = abap_true TRANSPORTING NO FIELDS."ADD JVM - 26/03/2024
        IF sy-subrc <> 0."ADD JVM - 26/03/2024
          CONTINUE.
        ELSE.
          SELECT SINGLE mtart FROM mara WHERE matnr = @wa_compo-baugr INTO @lv_mtart_baugr.
          IF lv_mtart_baugr = 'ZTIN'.
            CONTINUE.
          ENDIF.
        ENDIF."ADD JVM - 26/03/2024
        "FIN JVM - 26/03/2024 - Chequeamos si el origen de la necesidad es un dummy, ya que las colas se enviarán así ahora para enviar la cola real
      ENDIF.

      "FIN JVM REPLACE - 26/03/2024 -

**  cCopermat   Información relativa a los materiales asignados a las operaciones #¡VALOR!
      wa_opermat-operation = c_replace. "#¡VALOR!
      CLEAR: l_edidd.
      l_edidd-sdata = wa_opermat.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_opermat )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.
**  cCopermatdata     #¡VALOR!
*wa_opermatdata-Comments  Preguntar a hinojosa  X NO relevante
*wa_opermatdata-Density N/A en V5 #¡VALOR!  NO relevante
*wa_opermatdata-Includeratio  Preguntar a hinojosa  X NO relevante
*wa_opermatdata-Includewaste  Preguntar a hinojosa  X NO relevante
*wa_opermatdata-Length  N/A en V5 #¡VALOR!  NO relevante
*wa_opermatdata-Materialname  N/A en V5 #¡VALOR!  NO relevante
*      SELECT SINGLE mtart INTO @DATA(lv_mtart_compo) FROM mara WHERE matnr EQ @wa_compo-matnr.
*      CASE lv_mtart_compo.
*        WHEN 'ZAUX'.
*          IF wa_mara-matkl BETWEEN '35000' AND '38630'.
*            wa_opermatdata-materialtype  = 'INK'."N/A en V5 #¡VALOR!  NO relevante
*          ENDIF.
*        WHEN 'ZTIN'.
*          wa_opermatdata-materialtype = 'INK'.
*        WHEN 'ZCLI'.
*          wa_opermatdata-materialtype = 'STE'.
*        WHEN 'ZTRO'.
*          wa_opermatdata-materialtype = 'DIE'.
*      ENDCASE.
*wa_opermatdata-Needsfeedback Preguntar a hinojosa  X NO relevante
*wa_opermatdata-Offset  Preguntar a hinojosa  X NO relevante
      wa_opermatdata-operationnr = wa_oper-vornr."mismo que CCOPERATIONDATA-OPERATIONNR #¡VALOR!  Numero de operación
      wa_opermatdata-opermatnr = wa_compo-rspos && wa_compo-posnr."item_number."Secuencia del componente en la operación  #¡VALOR!  Secuencia del componente en la operación "ADD JVM - 17/04/2024 añadir nº resreva para no colisionar en OMP
      wa_opermatdata-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!  Concepto en SAP?
      wa_opermatdata-productid = wa_compo-matnr."material. "mismo que CCPRODUCTDATA-PRODUCTID #¡VALOR!  Codigo SAP del componente de la BOM
      "JVM - 07/10/2024 Eliminar los ceros para los materiales
      lv_mat_auxi = wa_opermatdata-productid.
      wa_opermatdata-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
      "FJVM - 07/10/2024 Eliminar los ceros para los materiales
*      wa_opermatdata-quantity = wa_compo-bdmng."req_quan. "Cantidad del componente en la operacion #¡VALOR!  Cantidad del componente en la operacion

*      SELECT SINGLE sortf INTO @DATA(lv_station) FROM stpo AS t1 INNER JOIN afko AS t2 ON t1~stlnr EQ t2~stlnr WHERE aufnr EQ @lv_number AND posnr EQ @wa_compo-item_number.
*        TVARVC
      "NO ESTÁ ESTA

      " SMT - INI - 07.09.2022 10:04:23 - 	Función ZSPP_IDOC_ORDERS: CCOPERMAT CAMPO QUANTITY DE LAS TINTAS (material type = INK)
      " HAY QUE ENVIAR LA CANTIDAD POR UNIDAD A FABRICAR NO POR EL TOTAL DE LA ORDEN, es decir, cantidad de la
      " RESB del componente tinta RESB- BDMNG / cantidad de la cabecera de la OF CAUFV- GAMNG.
*      READ TABLE it_mat_tinta TRANSPORTING NO FIELDS WITH KEY matnr = wa_compo-matnr.
*      IF sy-subrc = 0.
      TRY.
          wa_opermatdata-quantity = wa_compo-bdmng / it_header[ 1 ]-gamng. "JVM - 09/01/2025 incidencia cantidad OF
        CATCH cx_root.
      ENDTRY.
*      ELSE.
*        wa_opermatdata-quantity = wa_compo-bdmng.
*      ENDIF.

      " SMT - FIN - 07.09.2022 10:04:56 -

      "[12:39] José Luis Riera Esteve
      "opermat
      "[12:39] José Luis Riera Esteve
      "para los ZMAP
      "[12:39] José Luis Riera Esteve
      "hay que apsar el quantity unitario
      "[12:40] José Luis Riera Esteve
      "estamos pasando cantidad total que viene en la resb
      "[12:40] José Luis Riera Esteve
      "pero el de omp nos dice que dividamos esa cantidad por la cantidad total de la orden
      "[12:40] José Luis Riera Esteve
      "de la cantidad del header
*      IF lv_mtart_compo EQ 'ZMAP' OR lv_mtart_compo EQ 'ZPAL' OR lv_mtart_compo EQ 'ZAUX'.
      TRY.
          wa_opermatdata-quantity = wa_compo-bdmng / it_header[ 1 ]-gamng. "JVM - 09/01/2025 incidencia cantidad OF


          "INI JVM - 21/11/2024
          IF lv_mtart_compo = 'ZPAL'.
            PERFORM cantidad_palet_new TABLES et_td151 CHANGING wa_opermatdata.
          ENDIF.
          "FIN JVM - 21/11/2024

        CATCH cx_root.
      ENDTRY.
*      ENDIF.


*De la TD131 obtenemos el campo    COLCO y vamos a la  ZVCXI_PXS_TD121 y obtenemos el MATNR de cada uno d ellos teniendo en cuenta la fecha de validez.
*Con este MATNR ya podemos identificar en qué segmento del idoc va cada stationnr.
      IF et_td131 IS NOT INITIAL.
        SELECT * INTO TABLE @DATA(it_td121)
          FROM zvcxi_pxs_td121
          FOR ALL ENTRIES IN @et_td131
          WHERE colco EQ @et_td131-colco
          AND matnr EQ @wa_compo-matnr
          AND valfr <= @sy-datum.
        IF sy-subrc = 0.
          SORT it_td121 BY valfr matnr ASCENDING.
        ENDIF.
      ENDIF.

      IF et_td131_sem IS NOT INITIAL.
        SELECT * INTO TABLE @DATA(it_td121_sem)
          FROM zvcxi_pxs_td121
          FOR ALL ENTRIES IN @et_td131_sem
          WHERE colco EQ @et_td131_sem-colco
          AND matnr EQ @wa_compo-matnr
          AND valfr <= @sy-datum.
        IF sy-subrc = 0.
          SORT it_td121_sem BY valfr matnr ASCENDING.
        ENDIF.
      ENDIF.

      READ TABLE it_td121 INTO DATA(wa_td121) WITH KEY matnr = wa_compo-matnr.
      IF sy-subrc = 0.
*      READ TABLE et_td131 INTO DATA(wa_td131) WITH KEY inkno = wa_compo-posnr.
        READ TABLE et_td131 INTO DATA(wa_td131) WITH KEY colco = wa_td121-colco. "inkno = wa_compo-vornr.
*            CUOBJ
*            CSELF
*            PRSID
*            INKNO
        IF sy-subrc = 0.
          DATA(lv_found) = 'X'.
        ELSE.
          lv_found = space.
        ENDIF.
      ELSE.
        lv_found = space.
      ENDIF.
      IF lv_found = space.
*        READ TABLE et_td131_sem INTO wa_td131 WITH KEY inkno = wa_compo-posnr.
        READ TABLE it_td121_sem INTO wa_td121 WITH KEY matnr = wa_compo-matnr.
        IF sy-subrc = 0.
          READ TABLE et_td131_sem INTO wa_td131 WITH KEY colco = wa_td121-colco."inkno = wa_compo-vornr.
          IF sy-subrc = 0.
            lv_found = 'X'.
          ELSE.
            lv_found = space.
          ENDIF.
        ELSE.
          lv_found = space.
        ENDIF.
      ENDIF.
      IF lv_found = 'X'.
*          ZSPP_IDOC_ORDERS: En el campo CCOPERMAT-STATIONNUMBER se tiene que enviar, únicamente, para los componentes
*        con  MATERIALTYPE = INK.  Y en el idoc del pantallazo estamos enviando ese campo para mateirales que tienen MATERIALTYPE <> INK.
        READ TABLE it_mat_tinta TRANSPORTING NO FIELDS WITH KEY matnr = wa_compo-matnr.
        IF sy-subrc = 0.
          wa_opermatdata-stationnr = wa_td131-inkst. "Preguntar a hinojosa  X Consultar aicomp, es numero de bateria codificado en la configuracion

          "JVM - ADD - Campo ANILOX 10/09/2024
*        Seria como el campo stationnr: entrar por cuobj y por posición de la tinta a la YHP_IDX_TD131 y
*        en este caso recuperar el campo ANITN. El campo no está creado, hasta el lunes no lo tendremos.
*        Si no es complicado, me piden mejor ver el descriptivo del material que el propio código de material del anilox..
          SELECT SINGLE maktx INTO @DATA(lv_descrip_anilox)
            FROM makt
            WHERE spras EQ 'S'
            AND matnr = @wa_td131-anitn.
          IF sy-subrc <> 0.
            SELECT SINGLE maktx INTO @lv_descrip_anilox
            FROM makt
            WHERE matnr = @wa_td131-anitn
              AND maktx <> @space.
          ENDIF.
          IF sy-subrc = 0.
            WRITE lv_descrip_anilox TO wa_opermatdata-comments LEFT-JUSTIFIED.
            CONDENSE wa_opermatdata-comments.
          ENDIF.
          CLEAR lv_descrip_anilox.
          "FJVM - Campo ANILOX

        ELSE.
          wa_opermatdata-stationnr = '0'.
        ENDIF.
      ELSE.
        wa_opermatdata-stationnr = '0'.
      ENDIF.

      READ TABLE et_td130 INTO wa_td130 INDEX 1.
      IF sy-subrc = 0.
        wa_opermatdata-surface = wa_td130-prare."Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión       PRARE de la TD130
      ELSE.
        wa_opermatdata-surface = '0'.
      ENDIF.
*wa_opermatdata-UNIT  N/A en V5 #¡VALOR!  NO relevante
*wa_opermatdata-Viscosity N/A en V5 #¡VALOR!  NO relevante
*wa_opermatdata-Width N/A en V5 #¡VALOR!  NO relevante
      CLEAR: l_edidd.
      l_edidd-sdata = wa_opermatdata.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_opermatdata )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.
      CLEAR wa_opermatdata.
    ENDLOOP.
    DATA(lv_ultima_operacion) = wa_oper-vornr.
  ENDLOOP.
  IF sy-subrc = 0.
    LOOP AT it_component INTO wa_compo.
      "JVM - Replace - 26/03/2024 -
*      IF wa_compo-matnr IS INITIAL.
*        CONTINUE.
*      ENDIF.
*      SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
*      IF lv_mtart_compo NE 'ZPAL'.
*        CONTINUE.
*      ENDIF.
*      IF wa_compo-baugr <> it_header[ 1 ]-plnbez.
*        CONTINUE.
*      ENDIF.


      IF wa_compo-matnr IS INITIAL.
        CONTINUE.
      ENDIF.
      SELECT SINGLE mtart INTO @lv_mtart_compo FROM mara WHERE matnr EQ @wa_compo-matnr.
      IF lv_mtart_compo NE 'ZPAL'.
        READ TABLE it_operaux WITH KEY vornr = wa_compo-vornr TRANSPORTING NO FIELDS. "ADD JVM - 26/03/2024
        IF sy-subrc <> 0."ADD JVM - 26/03/2024

          CONTINUE.

        ENDIF."ADD JVM - 26/03/2024

      ENDIF.
      IF wa_compo-baugr <> it_header[ 1 ]-plnbez.
        CONTINUE.
      ENDIF.
      "FIN JVM - Replace - 26/03/2024 -
      wa_opermat-operation = c_replace. "#¡VALOR!
      CLEAR: l_edidd.
      l_edidd-sdata = wa_opermat.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_opermat )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.

      wa_opermatdata-operationnr = lv_ultima_operacion.
      wa_opermatdata-opermatnr = wa_compo-rspos && wa_compo-posnr."item_number."Secuencia del componente en la operación  #¡VALOR!  Secuencia del componente en la operación"ADD JVM - 17/04/2024 añadir nº resreva para no colisionar en OMP
      wa_opermatdata-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!  Concepto en SAP?
      wa_opermatdata-productid = wa_compo-matnr."material. "mismo que CCPRODUCTDATA-PRODUCTID #¡VALOR!  Codigo SAP del componente de la BOM
      "JVM - 07/10/2024 Eliminar los ceros para los materiales
      lv_mat_auxi = wa_opermatdata-productid.
      wa_opermatdata-productid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
      "FJVM - 07/10/2024 Eliminar los ceros para los materiales
      "JVM - 24/11/2022 - Pasar la cantidad de palets necesarios para 1 caja
*      wa_opermatdata-quantity = wa_compo-bdmng."req_quan. "Cantidad del componente en la operacion #¡VALOR!  Cantidad del componente en la operacion
      TRY.
          wa_opermatdata-quantity = wa_compo-bdmng / it_header[ 1 ]-gamng. "JVM - 09/01/2025 incidencia cantidad OF
          "INI JVM - 21/11/2024
          IF lv_mtart_compo = 'ZPAL'.
            PERFORM cantidad_palet_new TABLES et_td151 CHANGING wa_opermatdata.
          ENDIF.
          "FIN JVM - 21/11/2024

        CATCH cx_root.
      ENDTRY.
      "FJVM - 24/11/2022 - Pasar la cantidad de palets necesarios para 1 caja
*      SELECT SINGLE sortf INTO @DATA(lv_station) FROM stpo AS t1 INNER JOIN afko AS t2 ON t1~stlnr EQ t2~stlnr WHERE aufnr EQ @lv_number AND posnr EQ @wa_compo-item_number.
*        TVARVC
      "NO ESTÁ ESTA
*      READ TABLE et_td131 INTO wa_td131 WITH KEY inkno = wa_compo-posnr.
      READ TABLE et_td131 INTO wa_td131 WITH KEY inkno = wa_compo-vornr.
*            CUOBJ
*            CSELF
*            PRSID
*            INKNO
      IF sy-subrc <> 0.
*        READ TABLE et_td131_sem INTO wa_td131 WITH KEY inkno = wa_compo-posnr.
        READ TABLE et_td131_sem INTO wa_td131 WITH KEY inkno = wa_compo-vornr.
      ENDIF.
      IF sy-subrc = 0.
        READ TABLE it_mat_tinta TRANSPORTING NO FIELDS WITH KEY matnr = wa_compo-matnr.
        IF sy-subrc = 0.
          wa_opermatdata-stationnr = wa_td131-inkst. "Preguntar a hinojosa  X Consultar aicomp, es numero de bateria codificado en la configuracion

          "JVM - ADD - Campo ANILOX 10/09/2024
*        Seria como el campo stationnr: entrar por cuobj y por posición de la tinta a la YHP_IDX_TD131 y
*        en este caso recuperar el campo ANITN. El campo no está creado, hasta el lunes no lo tendremos.
*        Si no es complicado, me piden mejor ver el descriptivo del material que el propio código de material del anilox..
          SELECT SINGLE maktx INTO @DATA(lv_descrip_anilox2)
            FROM yhp_idx_td131 AS t1 INNER JOIN marc AS t2 ON t1~cuobj = t2~cuobj
            INNER JOIN makt AS t3 ON t1~anitn = t3~matnr AND t3~spras EQ 'S'
            WHERE t2~matnr = @wa_compo-matnr
            AND t2~cuobj <> @space.
          IF sy-subrc = 0.
            WRITE lv_descrip_anilox2 TO wa_opermatdata-comments LEFT-JUSTIFIED.
            CONDENSE wa_opermatdata-comments.
          ENDIF.
          "FJVM - Campo ANILOX

        ELSE.
          wa_opermatdata-stationnr = '0'.
        ENDIF.
      ELSE.
        wa_opermatdata-stationnr = '0'.
      ENDIF.

      READ TABLE et_td130 INTO wa_td130 INDEX 1.
      IF sy-subrc = 0.
        wa_opermatdata-surface = wa_td130-prare."Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión       PRARE de la TD130
      ELSE.
        wa_opermatdata-surface = '0'.
      ENDIF.

      CLEAR: l_edidd.
      l_edidd-sdata = wa_opermatdata.
      l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_opermatdata )->get_relative_name( ).
      l_edidd-segnum = lv_auxlevel.
      lv_auxlevel = lv_auxlevel + 1.
      APPEND l_edidd TO t_edidd.
      CLEAR wa_opermatdata.
    ENDLOOP.
  ENDIF.

  IF lv_rutas_alt IS NOT INITIAL.

    LOOP AT it_rutas INTO wa_ruta_alt WHERE ruta_alt EQ 'X' GROUP BY ( route = wa_ruta_alt-route ).

      CLEAR ruta_auxiliar[].
      LOOP AT GROUP wa_ruta_alt INTO ruta.
        IF ruta-steus EQ 'PP02' OR ruta-steus EQ 'PP03'.
          CONTINUE.
        ENDIF.
        APPEND ruta TO ruta_auxiliar.
      ENDLOOP.

      PERFORM add_compo_ruta_alt TABLES ruta_auxiliar
                                        it_component
                                        it_header
                                        t_edidd
                                        et_td130
                                        et_td131
                                        et_td151
                               CHANGING lv_auxlevel.

    ENDLOOP.

  ENDIF.


  "Leemos de BBDD y lo que nos llega, ya que si estamos en creación de OF, no existirá nada en BBDD
  "en creación si que llega la tabla IT_MAFS llena, pero cuando se modifica porque se añade o borra un MAF
  "sólo llega lo que se ha modificado, no todo
  DATA it_util TYPE tty_util.
  CLEAR it_util[].
  PERFORM get_utils TABLES it_util it_operation it_prt_allocation USING lv_number.

  "Añadiremos útiles alternativos y duplicados pasándoles como letra en MODKZ = 'Ñ' (alternativos) y 'P' (duplicados)
  "para posteriormente después de añadir el segmento, eliminarlos de la tabla
  "utilizando este campo
  PERFORM get_utiles_alter TABLES it_prt_allocation it_operation.

  SELECT SINGLE low INTO @DATA(lv_flag) FROM tvarvc WHERE name EQ 'Z_ACTIVA_UTIL_Z_ORDERS'.

*    LOOP AT it_prod_rel_tool INTO DATA(wa_res) WHERE routing_no EQ wa_oper-routing_no AND counter EQ wa_oper-counter.
  LOOP AT it_operation INTO wa_oper.
    IF it_prt_allocation[] IS NOT INITIAL OR lv_flag IS INITIAL.
      LOOP AT it_prt_allocation INTO DATA(wa_res) WHERE aufpl EQ wa_oper-aufpl AND aplzl EQ wa_oper-aplzl AND modkz NE 'D'.
**  Ccresource    Información relativa a los recursos asignados a las operaciones #¡VALOR!  ESTE SEGMENTO QUEDA TODO EN CCOPERRES
        wa_resource-operation = c_replace.
        CLEAR: l_edidd.
        l_edidd-sdata = wa_resource.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_resource )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
**  operation REPLACE #¡VALOR!
**  Ccresourcedata      #¡VALOR!

*wa_resourcedata-COLOR N/A en V5 #¡VALOR!  NO relevante
        SELECT SINGLE matnr INTO @DATA(lv_matnr_util) FROM crvm_b WHERE objid EQ @wa_res-objid AND objty EQ @wa_res-objty AND werks EQ @lv_werks.
        wa_resourcedata-resourceid  = lv_matnr_util."wa_res-matnr."material. "Codigo de material del util.  #¡VALOR!
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
        lv_mat_auxi = wa_resourcedata-resourceid.
        wa_resourcedata-resourceid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        IF strlen( wa_resourcedata-resourceid ) EQ 14.
          wa_resourcedata-resourceid = wa_resourcedata-resourceid(13).
        ENDIF.
        SELECT SINGLE mtart INTO @DATA(lv_mtart_util) FROM mara WHERE matnr EQ @lv_matnr_util."wa_res-material.
        IF sy-subrc = 0.
          CASE lv_mtart_util.
            WHEN 'ZCLI'.
              wa_resourcedata-resourcetype = 'STE'.
            WHEN 'ZTRO'.
              wa_resourcedata-resourcetype = 'DIE'.
          ENDCASE.
        ENDIF.
        SELECT SINGLE txtz1 FROM affh INTO @DATA(lv_nombreutil) WHERE aufpl EQ @wa_oper-aufpl "routing_no
              AND aplzl EQ @wa_res-pzlfh."wa_res-counter.
        IF sy-subrc <> 0 OR lv_nombreutil IS INITIAL.
          SELECT SINGLE maktx INTO @lv_nombreutil FROM makt WHERE matnr EQ @lv_matnr_util "wa_res-material
          AND spras EQ 'S'.
        ENDIF.
        wa_resourcedata-resourcename = lv_nombreutil. " Descripción del material útil. AFFH #¡VALOR!
*    Ubicación donde estará almacenado el útil. MLGT-LGPLA entrando por MATNR, LGTYP = "800"
*      SELECT SINGLE lgpla INTO @wa_resourcedata-storageposition FROM mlgt WHERE lgtyp EQ '800' AND matnr EQ @lv_matnr_util."wa_res-material.
        TRY.
            DATA(ubicaciones) = NEW zcl_wm_tools_location_manager(
                i_matnr          = lv_matnr_util
                i_werks          = lv_werks
                i_lgort          = lv_lgort
*    i_mkapv          =
            ).

            DATA(ubic) = ubicaciones->_tp_location.

          CATCH zcx_wm_exception INTO DATA(lv_ex).
          CATCH cx_root INTO DATA(lv_exc2).
        ENDTRY.



        SPLIT ubic AT '/' INTO TABLE DATA(lt_ubicaciones).

        LOOP AT lt_ubicaciones INTO DATA(wa_ubicaciones) FROM 2.
          CONCATENATE wa_ubicaciones wa_resourcedata-storageposition INTO wa_resourcedata-storageposition SEPARATED BY '//'.
        ENDLOOP.
        CONDENSE wa_resourcedata-storageposition.

*  CATCH zcx_wm_exception.  "
**  Storageposition Ubicación.  #¡VALOR!
        CLEAR: l_edidd.
        l_edidd-sdata = wa_resourcedata.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_resourcedata )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
        CLEAR wa_resourcedata.
      ENDLOOP.
    ELSE.
      LOOP AT it_util INTO DATA(wa_res2) WHERE vornr EQ wa_oper-vornr.
**  Ccresource    Información relativa a los recursos asignados a las operaciones #¡VALOR!  ESTE SEGMENTO QUEDA TODO EN CCOPERRES
        wa_resource-operation = c_replace.
        CLEAR: l_edidd.
        l_edidd-sdata = wa_resource.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_resource )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
**  operation REPLACE #¡VALOR!
**  Ccresourcedata      #¡VALOR!

*wa_resourcedata-COLOR N/A en V5 #¡VALOR!  NO relevante
*        SELECT SINGLE matnr INTO @DATA(lv_matnr_util) FROM crvm_b WHERE objid EQ @wa_res2-objid AND objty EQ @wa_res2-objty AND werks EQ @lv_werks.
        lv_matnr_util = wa_res2-matnr.
        wa_resourcedata-resourceid  = lv_matnr_util."wa_Res2-matnr."material. "Codigo de material del util.  #¡VALOR!
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
        lv_mat_auxi = wa_resourcedata-resourceid.
        wa_resourcedata-resourceid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        IF strlen( wa_resourcedata-resourceid ) EQ 14.
          wa_resourcedata-resourceid = wa_resourcedata-resourceid(13).
        ENDIF.
        CLEAR lv_mtart_util.
        SELECT SINGLE mtart INTO @lv_mtart_util FROM mara WHERE matnr EQ @lv_matnr_util."wa_Res2-material.
        IF sy-subrc = 0.
          CASE lv_mtart_util.
            WHEN 'ZCLI'.
              wa_resourcedata-resourcetype = 'STE'.
            WHEN 'ZTRO'.
              wa_resourcedata-resourcetype = 'DIE'.
          ENDCASE.
        ENDIF.
        CLEAR lv_nombreutil.
        SELECT SINGLE txtz1 FROM affh INTO @lv_nombreutil WHERE aufpl EQ @wa_oper-aufpl "routing_no
              AND aplzl EQ @wa_res2-pzlfh."wa_Res2-counter.
        IF sy-subrc <> 0 OR lv_nombreutil IS INITIAL.
          SELECT SINGLE maktx INTO @lv_nombreutil FROM makt WHERE matnr EQ @lv_matnr_util "wa_Res2-material
          AND spras EQ 'S'.
        ENDIF.
        wa_resourcedata-resourcename = lv_nombreutil. " Descripción del material útil. AFFH #¡VALOR!
*    Ubicación donde estará almacenado el útil. MLGT-LGPLA entrando por MATNR, LGTYP = "800"
*      SELECT SINGLE lgpla INTO @wa_resourcedata-storageposition FROM mlgt WHERE lgtyp EQ '800' AND matnr EQ @lv_matnr_util."wa_Res2-material.
        TRY.
            DATA(ubicaciones2) = NEW zcl_wm_tools_location_manager(
                i_matnr          = lv_matnr_util
                i_werks          = lv_werks
                i_lgort          = lv_lgort
*    i_mkapv          =
            ).

            DATA(ubic2) = ubicaciones2->_tp_location.

          CATCH zcx_wm_exception INTO DATA(lv_ex2).
        ENDTRY.



        SPLIT ubic2 AT '/' INTO TABLE DATA(lt_ubicaciones2).

        LOOP AT lt_ubicaciones2 INTO DATA(wa_ubicaciones2) FROM 2.
          CONCATENATE wa_ubicaciones2 wa_resourcedata-storageposition INTO wa_resourcedata-storageposition SEPARATED BY '//'.
        ENDLOOP.
        CONDENSE wa_resourcedata-storageposition.

*  CATCH zcx_wm_exception.  "
**  Storageposition Ubicación.  #¡VALOR!
        CLEAR: l_edidd.
        l_edidd-sdata = wa_resourcedata.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_resourcedata )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
        CLEAR wa_resourcedata.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

  DATA lv_contador_duplalt TYPE i.
  lv_contador_duplalt = 1.

  LOOP AT it_operation INTO wa_oper.
    IF it_prt_allocation[] IS NOT INITIAL OR lv_flag IS INITIAL.
      LOOP AT it_prt_allocation INTO wa_res WHERE aufpl EQ wa_oper-aufpl AND aplzl EQ wa_oper-aplzl AND modkz NE 'D'.

**  Ccoperres   Información adicional al recurso asignado a la operación  #¡VALOR!
        wa_operres-operation = c_replace." #¡VALOR!
        CLEAR: l_edidd.
        l_edidd-sdata = wa_operres.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operres )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
**  Ccoperresdata     #¡VALOR!
        wa_operresdata-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!
        SELECT SINGLE matnr
          INTO @lv_matnr_util
          FROM crvm_b
          WHERE objid EQ @wa_res-objid
          AND objty EQ @wa_res-objty
          AND werks EQ @lv_werks.
        wa_operresdata-resourceid  = lv_matnr_util."wa_res-matnr."material. "Codigo de material del util.  #¡VALOR!
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
        lv_mat_auxi = wa_operresdata-resourceid.
        wa_operresdata-resourceid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        IF strlen( wa_operresdata-resourceid ) EQ 14.
          wa_operresdata-resourceid = wa_operresdata-resourceid(13).
        ENDIF."mismo que CCRESOURCEDATA-RESOURCEID #¡VALOR!  Codigo de material del cliche O troquel
        wa_operresdata-operationnr = wa_oper-vornr."operation_number. "mismo que CCOPERATIONDATA-OPERATIONNR #¡VALOR!  Numero de operación
        wa_operresdata-operresnr = wa_res-pzlfh * 10."prt_item_count * 10. "Secuencia del util en la operación, tiene que ir aumentando en relación al CCOPERMAT tambien, es decir si el anterior es 10, este será 20, etc  #¡VALOR!  Correcto
        "MODKZ = 'Ñ' (alternativos) y 'P' (duplicados)
        IF wa_res-modkz EQ 'Ñ' OR wa_res-modkz EQ 'P'.
          wa_operresdata-operresnr = wa_res-pzlfh * 10 + lv_contador_duplalt.
          ADD 1 TO lv_contador_duplalt.
        ENDIF.
        wa_operresdata-quantity = wa_res-mgvgw."total_quantity. " Cantidad del util en la operación #¡VALOR!  Correcto
*wa_operresdata-Comments  Comentarios adicionales.    #¡VALOR!  NO relevante
*wa_operresdata-Drum  preguntar a hinojosa. X NO relevante
*wa_operresdata-Durationvalue Preguntar a hinojosa  X NO relevante
*wa_operresdata-Enddateoffset Preguntar a hinojosa  X NO relevante
*wa_operresdata-Incquantity Preguntar a hinojosa  X NO relevante
*wa_operresdata-MachineId Preguntar a hinojosa  X Número de máquina alternativa de la operación
*wa_operresdata-Minquantity Preguntar a hinojosa  X NO relevante
*wa_operresdata-Positioning Preguntar a hinojosa  X NO relevante
*wa_operresdata-Pressure  Preguntar a hinojosa  X NO relevante
*wa_operresdata-Startdateoffset Preguntar a hinojosa  X NO relevante
*wa_operresdata-Stationnr Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión
        wa_operresdata-timemeaning = 'production'." Preguntar a hinojosa  X NO relevante
*wa_operresdata-Useduringdowns  Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión
        CLEAR: l_edidd.
        l_edidd-sdata = wa_operresdata.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operresdata )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
        CLEAR wa_operresdata.CLEAR wa_resourcedata.

      ENDLOOP.
    ELSE.
      LOOP AT it_util INTO wa_res2 WHERE vornr EQ wa_oper-vornr.

**  Ccoperres   Información adicional al recurso asignado a la operación  #¡VALOR!
        wa_operres-operation = c_replace." #¡VALOR!
        CLEAR: l_edidd.
        l_edidd-sdata = wa_operres.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operres )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
**  Ccoperresdata     #¡VALOR!
        wa_operresdata-processid = wa_processdata-processid. "mismo que CCPROCESSDATA-PROCESSID #¡VALOR!
*        SELECT SINGLE matnr
*          INTO @lv_matnr_util
*          FROM crvm_b
*          WHERE objid EQ @wa_Res2-objid
*          AND objty EQ @wa_Res2-objty
*          AND werks EQ @lv_werks.
        lv_matnr_util = wa_res2-matnr.
        wa_operresdata-resourceid  = lv_matnr_util. "wa_Res2-matnr."material. "Codigo de material del util.  #¡VALOR!
        "JVM - 07/10/2024 Eliminar los ceros para los materiales
        lv_mat_auxi = wa_operresdata-resourceid.
        wa_operresdata-resourceid = zcl_ap_material=>formato_externo( matnr = lv_mat_auxi ).
        "FJVM - 07/10/2024 Eliminar los ceros para los materiales
        IF strlen( wa_operresdata-resourceid ) EQ 14.
          wa_operresdata-resourceid = wa_operresdata-resourceid(13).
        ENDIF."mismo que CCRESOURCEDATA-RESOURCEID #¡VALOR!  Codigo de material del cliche O troquel
        wa_operresdata-operationnr = wa_oper-vornr."operation_number. "mismo que CCOPERATIONDATA-OPERATIONNR #¡VALOR!  Numero de operación
        wa_operresdata-operresnr = wa_res2-pzlfh * 10."prt_item_count * 10. "Secuencia del util en la operación, tiene que ir aumentando en relación al CCOPERMAT tambien, es decir si el anterior es 10, este será 20, etc  #¡VALOR!  Correcto
        "MODKZ = 'Ñ' (alternativos) y 'P' (duplicados)
*        IF wa_Res2-modkz EQ 'Ñ' OR wa_Res2-modkz EQ 'P'.
*          wa_operresdata-operresnr = wa_Res2-pzlfh * 10 + lv_contador_duplalt.
*          ADD 1 TO lv_contador_duplalt.
*        ENDIF.
        wa_operresdata-quantity = 1."wa_Res2-mgvgw."total_quantity. " Cantidad del util en la operación #¡VALOR!  Correcto
*wa_operresdata-Comments  Comentarios adicionales.    #¡VALOR!  NO relevante
*wa_operresdata-Drum  preguntar a hinojosa. X NO relevante
*wa_operresdata-Durationvalue Preguntar a hinojosa  X NO relevante
*wa_operresdata-Enddateoffset Preguntar a hinojosa  X NO relevante
*wa_operresdata-Incquantity Preguntar a hinojosa  X NO relevante
*wa_operresdata-MachineId Preguntar a hinojosa  X Número de máquina alternativa de la operación
*wa_operresdata-Minquantity Preguntar a hinojosa  X NO relevante
*wa_operresdata-Positioning Preguntar a hinojosa  X NO relevante
*wa_operresdata-Pressure  Preguntar a hinojosa  X NO relevante
*wa_operresdata-Startdateoffset Preguntar a hinojosa  X NO relevante
*wa_operresdata-Stationnr Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión
        wa_operresdata-timemeaning = 'production'." Preguntar a hinojosa  X NO relevante
*wa_operresdata-Useduringdowns  Preguntar a hinojosa  X Ver campo con aicomp, superficie de impresión
        CLEAR: l_edidd.
        l_edidd-sdata = wa_operresdata.
        l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operresdata )->get_relative_name( ).
        l_edidd-segnum = lv_auxlevel.
        lv_auxlevel = lv_auxlevel + 1.
        APPEND l_edidd TO t_edidd.
        CLEAR wa_operresdata.CLEAR wa_resourcedata.

      ENDLOOP.
    ENDIF.
  ENDLOOP.

  DELETE it_prt_allocation WHERE modkz EQ 'P' OR modkz EQ 'Ñ'.


  IF lv_rutas_alt IS NOT INITIAL.

    LOOP AT it_rutas INTO wa_ruta_alt WHERE ruta_alt EQ 'X' GROUP BY ( route = wa_ruta_alt-route ).

      CLEAR ruta_auxiliar[].
      LOOP AT GROUP wa_ruta_alt INTO ruta.
        IF ruta-steus EQ 'PP02' OR ruta-steus EQ 'PP03'.
          CONTINUE.
        ENDIF.
        APPEND ruta TO ruta_auxiliar.
      ENDLOOP.

      PERFORM add_util_ruta_alt TABLES ruta_auxiliar
                                        it_header
                                        t_edidd
                                        it_prt_allocation
                               CHANGING lv_auxlevel.

    ENDLOOP.

  ENDIF.


  LOOP AT it_rutas ASSIGNING FIELD-SYMBOL(<fs_ruta>) GROUP BY ( arbpl = <fs_ruta>-arbpl
                                                                vornr = <fs_ruta>-vornr
                                                                processid = <fs_ruta>-processid
                                                                maq_alt = 'X' )." WHERE maq_alt EQ abap_true.
    CHECK <fs_ruta>-maq_alt = 'X'.

**  Ccoperaltmach   Maquinas alternativas
    CLEAR: wa_operaltmach, wa_operaltmachdata.
    wa_operaltmach-operation = c_replace.
    CLEAR l_edidd.
    l_edidd-sdata = wa_operaltmach.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operaltmach )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.
**  operation REPLACE #¡VALOR!
**  Ccoperaltmachdata     #¡VALOR!
    wa_operaltmachdata-machineid = <fs_ruta>-arbpl."Puesto de trabajo ARBPL. Con la función de AICOMP recuperar el campo ARBPL de la tabla ET_RTE para la operación tratada #¡VALOR!  Que puesto de trabajo
    wa_operaltmachdata-operationnr = <fs_ruta>-vornr."operación. Con la función de AICOMP recuperar el campo VORNR de la tabla ET_RTE para la operación tratada #¡VALOR!  Numero de operación
*  wa_operaltmachdata-PREFNR  Preguntar a hinojosa  X NO relevante
    "JVM - REPL
*    wa_operaltmachdata-processid = wa_processdata-processid."mismo que CCPROCESSDATA-PROCESSID #¡VALOR!
    wa_operaltmachdata-processid = |{ wa_orderdata-orderid ALPHA = OUT }|. "concatenar "_1" a CCORDERDATA-ORDERID #¡VALOR!  Este concepto no existe en AS400, por eso lo hacemos así. No existe este concepto en SAP?
    CONDENSE wa_operaltmachdata-processid NO-GAPS.
*  CONCATENATE wa_processdata-processid '_1' INTO wa_processdata-processid.
*    DATA lv_numruta TYPE char2.
    lv_numruta = |{ <fs_ruta>-processid ALPHA = OUT }|.
    CONDENSE lv_numruta.
    CONCATENATE wa_operaltmachdata-processid '_'  lv_numruta INTO wa_operaltmachdata-processid.
    "FJVM - REPL

    "Tiempo de máquina. Con la función de AICOMP recuperar el campo VGW02 de la tabla ET_RTE para la operación tratada #¡VALOR!  Tiempos de cambio y produccion de las HdR alternativas
    READ TABLE it_operation WITH KEY vornr = wa_oper-vornr INTO wa_tiempos.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING wa_tiempos TO wa_afvv.
    ELSE.
      SELECT SINGLE t1~* INTO @wa_afvv FROM afvv AS t1 INNER JOIN afvc AS t2 ON t1~aufpl EQ t2~aufpl AND t1~aplzl EQ t2~aplzl
            INNER JOIN afko AS t3 ON t2~aufpl EQ t3~aufpl
            WHERE aufnr EQ @lv_number
            AND vornr EQ @<fs_ruta>-vornr.
    ENDIF.

    CLEAR: tiempo, tiempo_segundos.

    tiempo = wa_afvv-bearz.

    CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
      EXPORTING
        input                = tiempo
*       NO_TYPE_CHECK        = 'X'
*       ROUND_SIGN           = ' '
*       unit_in              = wa_afvv-vge02
        unit_in              = wa_afvv-beaze
        unit_out             = 'S'
      IMPORTING
*       ADD_CONST            =
*       DECIMALS             =
*       DENOMINATOR          =
*       NUMERATOR            =
        output               = tiempo_segundos
      EXCEPTIONS
        conversion_not_found = 1
        division_by_zero     = 2
        input_invalid        = 3
        output_invalid       = 4
        overflow             = 5
        type_invalid         = 6
        units_missing        = 7
        unit_in_not_found    = 8
        unit_out_not_found   = 9
        OTHERS               = 10.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.

    IF gamng_aux > 0.
      READ TABLE it_ratio WITH KEY vornr = wa_oper-vornr ASSIGNING <ratiocalc>.
      IF sy-subrc = 0.
        TRY.
            wa_operaltmachdata-runduration = ( tiempo_segundos * 1000 / gamng_aux ) * <ratiocalc>-ratio.
          CATCH cx_root.
        ENDTRY.
      ELSE.
        TRY.
            wa_operaltmachdata-runduration = tiempo_segundos * 1000 / gamng_aux .
          CATCH cx_root.
        ENDTRY.
      ENDIF.
    ELSE.
      wa_operaltmachdata-runduration = tiempo_segundos. " valor original
    ENDIF.

*    WRITE <fs_ruta>-vgw02 TO wa_operaltmachdata-runduration  DECIMALS 0 LEFT-JUSTIFIED.
*    REPLACE ALL OCCURRENCES OF '.' IN wa_operaltmachdata-runduration WITH ''. "JVM - 01/07/2024 - Incidencia segmento operaltmach mail Carlos Asenjo
    CONDENSE wa_operaltmachdata-runduration NO-GAPS. "JVM - 01/07/2024 - Incidencia segmento operaltmach mail Carlos Asenjo
    "Tiempo de preparación. Con la función de AICOMP recuperar el campo VGW01 de la tabla ET_RTE para la operación tratada #¡VALOR!  Tiempos de cambio y produccion de las HdR alternativas
    CLEAR: tiempo, tiempo_segundos.

    tiempo = wa_afvv-ruest.

    CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
      EXPORTING
        input                = tiempo
*       NO_TYPE_CHECK        = 'X'
*       ROUND_SIGN           = ' '
*       unit_in              = wa_afvv-vge01
        unit_in              = wa_afvv-rstze
        unit_out             = 'S'
      IMPORTING
*       ADD_CONST            =
*       DECIMALS             =
*       DENOMINATOR          =
*       NUMERATOR            =
        output               = tiempo_segundos
      EXCEPTIONS
        conversion_not_found = 1
        division_by_zero     = 2
        input_invalid        = 3
        output_invalid       = 4
        overflow             = 5
        type_invalid         = 6
        units_missing        = 7
        unit_in_not_found    = 8
        unit_out_not_found   = 9
        OTHERS               = 10.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.

    wa_operaltmachdata-setupduration = tiempo_segundos.

    WRITE <fs_ruta>-vgw01 TO wa_operaltmachdata-setupduration  DECIMALS 0 LEFT-JUSTIFIED.
    REPLACE ALL OCCURRENCES OF '.' IN wa_operaltmachdata-setupduration WITH ''.
    CLEAR: l_edidd.
    l_edidd-sdata = wa_operaltmachdata.
    l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_operaltmachdata )->get_relative_name( ).
    l_edidd-segnum = lv_auxlevel.
    lv_auxlevel = lv_auxlevel + 1.
    APPEND l_edidd TO t_edidd.
  ENDLOOP.



**  CcPlannedOrder      #¡VALOR!  NO aplica
**  Operation REPLACE #¡VALOR!  NO aplica
**  CcPlannedOrderData      #¡VALOR!  NO aplica
**  DUEDATE Preguntar a hinojosa  X NO aplica
**  ERPCOMMENTS Preguntar a hinojosa  X NO aplica
**  ERPORDERID  Preguntar a hinojosa  X NO aplica
**  ORDERID AFKO-AUFNR  #¡VALOR!  NO aplica
**  PLANNEDORDERID  Preguntar a hinojosa  X NO aplica
**  PREFWHID  Preguntar a hinojosa  X NO aplica
**  PROCESSVALIDITY Preguntar a hinojosa  X NO aplica
**  PRODUCTID Preguntar a hinojosa  X NO aplica
**  QUANTITY  Preguntar a hinojosa  X NO aplica
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_plannedorder.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_plannedorder )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_plannedorderdata.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_plannedorderdata )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.

**  CcPlannedOrderConfirmation      #¡VALOR!  NO aplica
**  Operation REPLACE #¡VALOR!  NO aplica
**  CcPlannedOrderConfirmationData      #¡VALOR!  NO aplica
**  COMMENTS  Preguntar a hinojosa  X NO aplica
**  CONFIRMEDDUEDATE  Preguntar a hinojosa  X NO aplica
**  CONFIRMEDQUANTITY Preguntar a hinojosa  X NO aplica
**  ERPORDERID  AFKO-AUFNR  #¡VALOR!  NO aplica
**  PLANNEDORDERCONFIRMATIONID  Preguntar a hinojosa  X NO aplica
**  PLANNEDORDERREQUESTID Preguntar a hinojosa  X NO aplica
**  STATUS  Preguntar a hinojosa  X NO aplica
**  TYPE  Preguntar a hinojosa  X NO aplica
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_plannedorderconfirmation.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_plannedorderconfirmation )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_plannedorderconfdata.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_plannedorderconfdata )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.

**  CcProductionOrderInfo     #¡VALOR!  NO aplica
**  Operation   REPLACE #¡VALOR!  NO aplica
**  CcProductionOrderInfoData     #¡VALOR!  NO aplica
**  ERPCOMMENTS Preguntar a hinojosa  X NO aplica
**  ERPORDERID  AFKO-AUFNR  #¡VALOR!  NO aplica
**  PRODUCTIONORDERID AFKO-AUFNR  #¡VALOR!  NO aplica
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_productionorderinfo.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productionorderinfo )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.
****  CLEAR: l_edidd.
****  l_edidd-sdata = wa_productionorderinfodata.
****  l_edidd-segnam = cl_abap_typedescr=>describe_by_data( p_data = wa_productionorderinfodata )->get_relative_name( ).
****  APPEND l_edidd TO t_edidd.
********************
********************  LOOP AT t_edidd ASSIGNING FIELD-SYMBOL(<edi>) WHERE segnum EQ '99'.
********************    <edi>-segnum = lv_auxlevel.
********************    lv_auxlevel = lv_auxlevel + 1.
********************  ENDLOOP.
  IF no_genera_idoc EQ ' '.
    ls_idoc_header-mandt  = sy-mandt.
    ls_idoc_header-direct = '1'.
    ls_idoc_header-rcvpor = c_edi_extern.
    ls_idoc_header-rcvprt = c_ls_d.
    ls_idoc_header-rcvprn = c_rcvprn.
    ls_idoc_header-sndprt = c_ls_r.
    ls_idoc_header-sndprn = sy-uname.
    ls_idoc_header-mestyp = c_zmsg_order.
    ls_idoc_header-idoctp = c_zstpm_order.

    SORT t_edidd BY segnum ASCENDING.


    CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE' "IN UPDATE TASK
      EXPORTING
        master_idoc_control            = ls_idoc_header
      TABLES
        communication_idoc_control     = lt_idoc_comm_control
        master_idoc_data               = t_edidd
      EXCEPTIONS
        error_in_idoc_control          = 1
        error_writing_idoc_status      = 2
        error_in_idoc_data             = 3
        sending_logical_system_unknown = 4
        OTHERS                         = 5.
    IF sy-subrc <> 0.
      "KO
      ls_return-type        = sy-msgty.
      ls_return-number      = sy-msgno.
      ls_return-id          = sy-msgid.
      ls_return-message_v1  = sy-msgv1.
      ls_return-message_v2  = sy-msgv2.
      ls_return-message_v3  = sy-msgv3.
      ls_return-message_v4  = sy-msgv4.
      APPEND ls_return TO lt_return.
    ELSE.
      "OK
      READ TABLE lt_idoc_comm_control INTO DATA(ls_control_record_out) INDEX 1.
      CHECK sy-subrc = 0.
      DATA(docnum) = ls_control_record_out-docnum.
      ls_return-type        = 'S'.
      ls_return-number      = '398'.
      ls_return-id          = '00'.
      ls_return-message_v1  = docnum.
      APPEND ls_return TO lt_return.
    ENDIF.

* Hacemos un COMMIT para el Idoc
*  CALL FUNCTION 'DEQUEUE_ALL'.
*  COMMIT WORK AND WAIT.
    CALL FUNCTION 'DB_COMMIT'.
    CALL FUNCTION 'DEQUEUE_ALL'.
*  COMMIT WORK.
  ELSE.
    ot_idoc[] = t_edidd[].
  ENDIF.


ENDFUNCTION.
