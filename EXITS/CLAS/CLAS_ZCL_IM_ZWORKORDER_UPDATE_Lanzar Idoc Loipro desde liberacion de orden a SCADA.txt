
class ZCL_IM_ZWORKORDER_UPDATE definition
  public
  final
  create public .

public section.

  interfaces IF_BADI_INTERFACE .
  interfaces IF_EX_WORKORDER_UPDATE .

  class-data GT_ZTTPM0007 type ZTTPM0007 .
  class-data GT_ZTPP0013 type ZTTPP0013 .
  class-data GV_PLNTY type PLNTY .
  class-data GV_PLNNR type PLNNR .
  class-data GV_RELEASE type FLAG .
  class-data GV_STLAN type STLAN .
  class-data GV_STLAL type STLAL .

  class-methods ADD_TABLE_TO_REMOVE
    importing
      !IS_CAUFVDB type CAUFVDB
      !IT_TABLE type ZTTPM0007
    exporting
      !ET_BORRADAS type ZTTPP0013 .
  class-methods INIT_VERS_ALV
    importing
      !IV_DDMM type FLAG optional
      !IS_CAUFVDB type CAUFVDB .
  class-methods MODIFY_ALV_COR2_3
    importing
      !IS_CAUFVDB type CAUFVDB
    exporting
      !ES_COPIATRO type ZSPM0009 .
  class-methods CHECK_EQUNR
    importing
      !IT_ZTPP0013 type ZTTPP0013
    returning
      value(EV_NO_VALID) type FLAG .
  class-methods CREATE_TABLE_ALV
    importing
      !IT_PLPO type PLPO_T
      !IS_COPIATRO type ZSPM0009
    exporting
      !ET_ALV type ZTTPM0007 .
  class-methods DISPLAY_POPUP_COPIATRO
    importing
      !IT_ZTTPM0009 type ZTTPM0009
    exporting
      !ES_COPIATRO type ZSPM0009 .
  class-methods FILL_ROW_ALV
    importing
      !IS_PLPO type PLPO
      !IV_EQUNR type EQUNR
    exporting
      !ES_ALV type ZSPM0007 .
  class-methods GET_CTRO_JCLI
    importing
      !IS_CAUFVDB type CAUFVDB
      !IV_TROQUELADO type FLAG
      !IV_IMPRESION type FLAG
      !IV_ZPLP type MATNR
      !IT_COPRODUCTS type TDT_MATNR
    exporting
      !ET_ZTTPM0009 type ZTTPM0009 .
  class-methods GET_ZPLP_COPRODUCTS
    importing
      !IS_CAUFVDB type CAUFVDB
    exporting
      !EV_ZPLP type MATNR
      !ET_COPRODUCTS type TDT_MATNR .
protected section.
private section.
endclass. "ZCL_IM_ZWORKORDER_UPDATE definition
class ZCL_IM_ZWORKORDER_UPDATE implementation.
  METHOD add_table_to_remove.
    DATA: ls_del TYPE ztpp0013.

    FIELD-SYMBOLS: <fs_zttpm0007> TYPE zspm0007.

*   Iteramos sobre todas las líneas a borrar
    LOOP AT it_table ASSIGNING <fs_zttpm0007>.
*     Informamos petición de borrado, fecha y hora
      MOVE-CORRESPONDING is_caufvdb      TO ls_del.
      MOVE-CORRESPONDING <fs_zttpm0007> TO ls_del.
      ls_del-zzptbo       = 'X'.
      ls_del-zzfechaptbo  = sy-datum.
      ls_del-zzhoraptbo   = sy-uzeit.

*     Si la fecha de creación esta vacia la rellenamos
      IF ls_del-zzfechas IS INITIAL.
        ls_del-zzfechas  = sy-datum.
        ls_del-zzhoraas  = sy-uzeit.
      ENDIF.

*     Añadimos a tabla de borrados
      APPEND ls_del TO et_borradas.
    ENDLOOP.
  ENDMETHOD.
  METHOD check_equnr.
    DATA: gr_table TYPE REF TO cl_salv_table,
          ispfli   TYPE TABLE OF spfli.

    DATA: lv_no_valid TYPE flag,
          lv_row      TYPE ztpp0013.

*   Iteramos sobre todas los equipos comprobando cuales están activos
    LOOP AT it_ztpp0013 INTO lv_row."DATA(lv_row).
*     Limpiamos variable
      CLEAR lv_no_valid.

*     Comprobamos si el equipo está activo
      CALL FUNCTION 'ZPP_CHECK_EQUNR_ACTIVE'
        EXPORTING
          e_equnr    = lv_row-equnr
        IMPORTING
          e_no_valid = ev_no_valid.

*     Si hay alguna que no es initial salimos
      IF ev_no_valid IS NOT INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD create_table_alv.
    DATA: ls_alv     TYPE zspm0007,
          lv_equnr   TYPE equnr,
          lt_cliches TYPE STANDARD TABLE OF equnr,
          ls_plpo    TYPE plpo.

*   Inicializamos tabla antes de montarla
    CLEAR: et_alv.

*   Informamos si hay troquelado
*    READ TABLE it_plpo INTO DATA(ls_plpo) WITH KEY phseq = 'Z4'.
    READ TABLE it_plpo INTO ls_plpo WITH KEY phseq = 'Z4'.
    IF sy-subrc EQ 0.
*     Buscamos equipo principal de troquelado
      SELECT SINGLE equnr FROM ztpm0002 INTO ls_alv-equnr
        WHERE copiatro = is_copiatro-copiatro
          AND equnrs   = 'P'.

*     Añadimos linea troquel a la tabla ALV
      zcl_im_zworkorder_update=>fill_row_alv(
        EXPORTING
          is_plpo  =  ls_plpo   " Copia de troqueles
          iv_equnr =  ls_alv-equnr   " Copia de troqueles
        IMPORTING
          es_alv   =  ls_alv
      ).

*     Añadimos linea a la tabla
      APPEND ls_alv TO et_alv.
    ENDIF.

*   Informamos si hay impresión
    READ TABLE it_plpo INTO ls_plpo WITH KEY phseq = 'Z5'.
    IF sy-subrc EQ 0.
*     Buscamos los cliches del juego
*      SELECT equnr FROM ztpm0004 INTO TABLE @DATA(lt_cliches)
*        WHERE juegocli = @is_copiatro-juegocli.

      SELECT equnr FROM ztpm0004 INTO TABLE lt_cliches
        WHERE juegocli = is_copiatro-juegocli.

*     Iteramos sobre los cliches encontrados en el juego de cliches
      LOOP AT lt_cliches INTO lv_equnr.
*       Añadimos linea cliche a la tabla ALV
        zcl_im_zworkorder_update=>fill_row_alv(
          EXPORTING
            is_plpo  =  ls_plpo   " Copia de troqueles
            iv_equnr =  lv_equnr   " Copia de troqueles
          IMPORTING
            es_alv   =  ls_alv
        ).

*       Añadimos linea a la tabla
        APPEND ls_alv TO et_alv.
      ENDLOOP.
    ENDIF.

*   Ordenamos tabla por vornr
    SORT et_alv BY vornr.
  ENDMETHOD.
  METHOD display_popup_copiatro.
    CALL FUNCTION 'ZPP_DISPLAY_POPUP_COPIATRO'
      EXPORTING
        et_zttpm0009 = it_zttpm0009
      IMPORTING
        es_zspm0009  = es_copiatro.
  ENDMETHOD.
  METHOD fill_row_alv.
    DATA: lt_system	TYPE TABLE OF bapi_itob_status,
          lt_user	  TYPE TABLE OF bapi_itob_status.

    DATA: lv_datbi    TYPE datbi_bi,
          lv_no_valid TYPE flag.

*   Informamos operación
    es_alv-vornr = is_plpo-vornr.

*   Informamos equipo
    es_alv-equnr = iv_equnr.

*   Informamos si hay subcontratación
    IF is_plpo-steus EQ 'ZP05'.
      es_alv-subcontra = 'Sí'.
    ELSE.
      es_alv-subcontra = 'No'.
    ENDIF.

*   Informamos datos
    SELECT SINGLE a~eqtyp, b~eqktx, d~tplnr, f~maqtx, h~trotx, a~zzcolor, a~zzrefantig
                                    FROM  equi      AS a
                         LEFT OUTER JOIN  eqkt      AS b  ON b~equnr  = a~equnr
                         LEFT OUTER JOIN  equz      AS c  ON c~equnr  = b~equnr
                         LEFT OUTER JOIN  iloa      AS d  ON d~iloan  = c~iloan
                         LEFT OUTER JOIN  ztpm0007  AS e  ON e~maq    = a~zzmaq
                         LEFT OUTER JOIN  ztpm0012  AS f  ON f~maq    = e~maq and
                                                             f~spras  = 'S'
                         LEFT OUTER JOIN  ztpm0006  AS g  ON g~tipo   = a~zztipo
                         LEFT OUTER JOIN  ztpm0011  AS h  ON h~tipo   = g~tipo and
                                                             h~spras  = 'S'
      INTO (@es_alv-eqtyp, @es_alv-eqktx, @es_alv-tplnr, @es_alv-maqtx, @es_alv-trotx,
            @es_alv-color, @es_alv-refantig )
      WHERE a~equnr = @iv_equnr
        AND b~spras = 'S'
        AND c~datbi > @sy-datum.
*        AND h~spras = 'S'.

*   Informamos status equipo
    CALL FUNCTION 'BAPI_EQUI_GETSTATUS'
      EXPORTING
        equipment     = iv_equnr
        language      = sy-langu
      TABLES
        system_status = lt_system
        user_status   = lt_user.

*   Limpiamos estatus de usuario para concatenar después
    CLEAR es_alv-estatus.

*   Añadimos estatus de usuario
    LOOP AT lt_user INTO DATA(ls_user).
      CONCATENATE es_alv-estatus ls_user-text INTO es_alv-estatus SEPARATED BY space.
    ENDLOOP.

*   Añadimos estatus de sistema
    LOOP AT lt_system INTO DATA(ls_system).
      CONCATENATE es_alv-estatus ls_system-text INTO es_alv-estatus SEPARATED BY space.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_ctro_jcli.
    DATA: ls_zttpm0009 TYPE zspm0009,
*          lt_ztpm0008 type STANDARD TABLE OF ztpm0008,
*          ls_ztpm0008 type ztpm0008,
          lv_cad       TYPE string.

*   Limpiamos
    CLEAR et_zttpm0009.

*   Si no hay copropductos nos quedamos solo con las entradas del material padre
    IF lines( it_coproducts ) EQ 0.
*      CONCATENATE lv_cad 'MATNRZPMP eq @is_caufvdb-plnbez and' INTO DATA(lv_cad).
      CONCATENATE lv_cad 'MATNRZPMP eq @is_caufvdb-plnbez and' INTO lv_cad.
    ENDIF.

*   Montamos cadena para select copiatro
    IF iv_troquelado IS INITIAL.
      CONCATENATE lv_cad 'COPIATRO eq `` and' INTO lv_cad SEPARATED BY space.
    ELSE.
      CONCATENATE lv_cad 'COPIATRO ne `` and' INTO lv_cad SEPARATED BY space.
    ENDIF.

*   Montamos cadena para select juegocli
    IF iv_impresion IS INITIAL.
      CONCATENATE lv_cad 'JUEGOCLI eq ``' INTO lv_cad SEPARATED BY space.
    ELSE.
      CONCATENATE lv_cad 'JUEGOCLI ne ``' INTO lv_cad SEPARATED BY space.
    ENDIF.

*   Obtenemos todos los registros de la ZTPM0008 para el mat ZPLP
    SELECT * FROM ztpm0008 INTO TABLE @DATA(lt_ztpm0008)
      WHERE matnrzplp = @iv_zplp
        AND (lv_cad).

*    SELECT * FROM ztpm0008 INTO TABLE lt_ztpm0008
*      WHERE matnrzplp = iv_zplp
*        AND (lv_cad).

*   Si no hay coproductos cogemos material encontrado
    IF lines( it_coproducts ) EQ 0.
*     Iteramos sobre todas las entradas encontradas
      LOOP AT lt_ztpm0008 INTO DATA(ls_ztpm0008).
*       LOOP AT lt_ztpm0008 INTO ls_ztpm0008.
*       Comprobamos que esa combinación no tiene coproductos
        SELECT SINGLE * FROM ztpm0008 INTO ls_ztpm0008
          WHERE matnrzpmp NE is_caufvdb-plnbez
            AND copiatro  = ls_ztpm0008-copiatro
            AND matnrzplp = iv_zplp
            AND juegocli  = ls_ztpm0008-juegocli
            and agru      = ls_ztpm0008-agru.

        CHECK sy-subrc NE 0.

*       Informamos campos y añadimos a la tabla de salida
        ls_zttpm0009-copiatro = ls_ztpm0008-copiatro.
        ls_zttpm0009-juegocli = ls_ztpm0008-juegocli.
        APPEND ls_zttpm0009 TO et_zttpm0009.
      ENDLOOP.

*     Salimos del método
      EXIT.
    ENDIF.

*   Iteramos sobre todas las entras del material padre
    LOOP AT lt_ztpm0008 INTO ls_ztpm0008 WHERE matnrzpmp EQ is_caufvdb-plnbez.
*     Inicializamos contador de coincidencias entre mat padre y coproductos
      DATA(lv_cont) = 0.

*     Iteramos sobre los coproductos
      LOOP AT it_coproducts INTO DATA(ls_coproducts).
*       Ponemos ceros a la izquierda
        ls_coproducts = |{ ls_coproducts ALPHA = IN }|.

*       Miramos a ver si hay entrada en la tabla de asignación de materiales
        READ TABLE lt_ztpm0008 TRANSPORTING NO FIELDS WITH KEY matnrzpmp  = ls_coproducts
                                                               copiatro   = ls_ztpm0008-copiatro
                                                               juegocli   = ls_ztpm0008-juegocli.

        IF sy-subrc EQ 0.
*         Contamos
          ADD 1 TO lv_cont.
        ENDIF.
      ENDLOOP.

*     Si hemos encontrado mismas entradas que coproductos añadimos a la tabla
      IF lv_cont EQ lines( it_coproducts ).
        ls_zttpm0009-copiatro = ls_ztpm0008-copiatro.
        ls_zttpm0009-juegocli = ls_ztpm0008-juegocli.
        APPEND ls_zttpm0009 TO et_zttpm0009.

*       Salimos del bucle
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_zplp_coproducts.
    DATA: lt_stpo TYPE tt_tstpo,
          ls_stpo TYPE stpo_api02,
          lv_stlan  TYPE stlan,
          lv_stlal  TYPE stlal,
          lv_dat  TYPE datuv_bi.
*   Limpiamos
    CLEAR et_coproducts.

*   Montamos fecha
    CONCATENATE sy-datum+6(2) '.' sy-datum+4(2) '.' sy-datum(4) INTO lv_dat.

*   Comprobamos si esta relleno STLAN y STLAL
    lv_stlan = is_caufvdb-stlan.
    lv_stlal = is_caufvdb-stlal.

*   Como no sabemos la versión informamos directamente 'V001'
    IF lv_stlan is  INITIAL or lv_stlal is INITIAL.
      SELECT SINGLE stlan stlal FROM mkal INTO ( lv_stlan, lv_stlal )
        WHERE MATNR = is_caufvdb-plnbez
          and werks = is_caufvdb-werks
          and VERID = 'V001'.
    ENDIF.

*   Obtenemos la lista de materiales
    CALL FUNCTION 'CSAP_MAT_BOM_READ'
      EXPORTING
        material    = is_caufvdb-plnbez
        plant       = is_caufvdb-werks
        bom_usage   = lv_stlan
        alternative = lv_stlal
        valid_from  = lv_dat
      TABLES
        t_stpo      = lt_stpo
      EXCEPTIONS
        error       = 1
        OTHERS      = 2.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.

*   Encontramos materiales coproducto
    LOOP AT lt_stpo INTO ls_stpo WHERE co_product EQ 'X'.
      APPEND ls_stpo-component TO et_coproducts.
    ENDLOOP.

*   Encontramos material ZPLP
    LOOP AT lt_stpo INTO ls_stpo WHERE co_product NE 'X'.
*     Informamos ceros a la izquierda
      ls_stpo-component = |{ ls_stpo-component ALPHA = IN }|.

*     Miramos si es ZPLP
      SELECT SINGLE matnr FROM mara INTO ev_zplp
        WHERE matnr = ls_stpo-component
          AND mtart = 'ZPLP'.
      IF sy-subrc EQ 0.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  method IF_EX_WORKORDER_UPDATE~ARCHIVE_OBJECTS.
  endmethod.
  method IF_EX_WORKORDER_UPDATE~AT_DELETION_FROM_DATABASE.
  endmethod.
  METHOD if_ex_workorder_update~at_release.
*---------------------------------------------------------------------
*  I_AKTYP  Importing RC27S-AKTYP
*  I_NO_DIALOG  Importing C
*  I_FLG_COL_RELEASE  Importing C
*  IS_HEADER_DIALOG	Importing	COBAI_S_HEADER_DIALOG
*---------------------------------------------------------------------

    DATA:  lv_error TYPE xflag,
           lv_code  LIKE sy-subrc.

*    DATA: ls_ztpp0005 TYPE ztpp0005.

    DATA: wa_jest TYPE jest.

*   Comprobar si el material tiene el calculo de costes realizado:
    IF ( sy-tcode = 'COR1' OR sy-tcode = 'COR2' OR sy-tcode = 'COHVPI' )
      AND ( is_header_dialog-werks = '3000' OR is_header_dialog-werks = '3020'  or
            is_header_dialog-werks = '4000').

      IF is_header_dialog-auart = 'ZI01' OR is_header_dialog-auart = 'ZI02'
        OR is_header_dialog-auart = 'ZI03' OR is_header_dialog-auart = 'ZI04'
        OR is_header_dialog-auart = 'ZI05' OR is_header_dialog-auart = 'ZI06'
        OR is_header_dialog-auart = 'ZC01' OR is_header_dialog-auart = 'ZC02'
        OR is_header_dialog-auart = 'ZC03' OR is_header_dialog-auart = 'ZC04'.

        CALL FUNCTION 'COPC_CHECK_MBEW_KEKO'
          EXPORTING
            material = is_header_dialog-plnbez
            bwkey    = is_header_dialog-werks
            status   = 'FR'
          IMPORTING
            rcode    = lv_code.

        IF lv_code <> 0. "  NO se ha hecho el calculo de costes
          MESSAGE e041(zpp).
        ENDIF.
      ENDIF.

*     CGIJON - INI 07.02.17
*     Cuando una OF esté en status ABIE (I0045) y EDET (I0115) y
*     se pretenda pasar a status LIB (I0002), que no deje liberar.
      SELECT SINGLE * INTO wa_jest
        FROM jest
        WHERE objnr = is_header_dialog-objnr AND
        ( stat = 'I0045' OR stat = 'I0115) ' ) AND
        inact = ' '.
      IF sy-subrc = 0.
        MESSAGE e121(zpp).
      ENDIF.
*     CGIJON - FIN 07.02.17
    ENDIF.

*---------------------------------------------------------------------
*   CUANDO SE LIBERE UNA ORDEN DE PAPELERA ENVIA EL IDOC LOIPRO A PI/SCADA
*---------------------------------------------------------------------
*    IF is_header_dialog-werks = '3000'.
*      CLEAR lv_error.
*      CALL FUNCTION 'ZMFPP_PEDIDOS_BLOQUEADOS'
*        EXPORTING
*          is_header_dialog = is_header_dialog
*        IMPORTING
*          o_error          = lv_error.
*
*      CHECK lv_error <> 'X'.
*
**     Chequear liberación IDOC:
*      CLEAR ls_ztpp0005.
*      SELECT SINGLE * INTO ls_ztpp0005
*        FROM ztpp0005
*        WHERE werks = is_header_dialog-werks
*        AND auart = is_header_dialog-auart.
*
*      IF ls_ztpp0005 IS NOT INITIAL.
*        CASE sy-sysid.
*          WHEN 'HED' OR 'HEQ'.
*            SUBMIT rcclord WITH s_aufnr EQ is_header_dialog-aufnr
*                           WITH s_matnr EQ is_header_dialog-matnr
*                           WITH p_autyp EQ '40'
*                           WITH opt_sys EQ 'HPDCLNT001'
*                           WITH mestyp EQ  'LOIPRO'
*                           AND RETURN.
*          WHEN 'HEP'.
*            SUBMIT rcclord WITH s_aufnr EQ is_header_dialog-aufnr
*                           WITH s_matnr EQ is_header_dialog-matnr
*                           WITH p_autyp EQ '40'
*                           WITH opt_sys EQ 'HPPCLNT001'
*                           WITH mestyp EQ  'LOIPRO'
*                           AND RETURN.
*          WHEN OTHERS.
*        ENDCASE.
*
*      ENDIF.
*    ENDIF.


*---------------------------------------------------------------------
*   PROYECTO CIPASI: Cambio de MAF por status inactivo o de borrado en
*   la liberación de la orden
*---------------------------------------------------------------------
    DATA: ls_alv      TYPE zspm0007,
          ls_hdr      TYPE zspm0009,
          lv_tcd      TYPE flag,
          is_caufvdb  TYPE caufvdb,
          lt_borradas TYPE zttpp0013.

    IF is_header_dialog-werks = '4000'.
*     Controlamos si se ha cambiado de versión
      IF ( is_header_dialog-plnty NE zcl_im_zworkorder_update=>gv_plnty OR
              is_header_dialog-plnnr NE zcl_im_zworkorder_update=>gv_plnnr ).

*       Controlamos desde que transacción estamos liberando para poner las antiguas entradas como borradas(COR2) o no(COR1)
        IF sy-tcode EQ 'COR2'.
          lv_tcd = 'X'.
        ENDIF.

*       Informamos datos del campo
        MOVE-CORRESPONDING is_header_dialog TO is_caufvdb.

*       Calculamos tabla de nuevo
        zcl_im_zworkorder_update=>init_vers_alv(  iv_ddmm    = lv_tcd
                                                  is_caufvdb = is_caufvdb ).
      ENDIF.

*     Controlamos si el ALV está vacio
      CHECK gt_zttpm0007 IS NOT INITIAL.

*     Limpiamos tabla con solo posnr
      DELETE gt_zttpm0007 WHERE equnr IS INITIAL.

*     Exportamos header a memoria para poder leerla desde el report
      EXPORT header FROM is_header_dialog TO SHARED BUFFER indx(st) ID 'HEADER'.

*     Exportamos tabla a memoria para poder leerla desde el report
      EXPORT utillajes FROM gt_zttpm0007 TO SHARED BUFFER indx(st) ID 'UTILLAJES'.

*     Obtenemos copiatro y juegocli
      CALL FUNCTION 'ZPP_GET_UTILLAJES'
        IMPORTING
          ev_copiatro = ls_hdr-copiatro
          ev_juegocli = ls_hdr-juegocli
          et_borrados = lt_borradas. " Estas son las líneas borradas por cambio de Vers Fab desde COR2

*     Llamamos a report zrpp0031. Este report mira si hay equipos inactivos
      SUBMIT zrpp0031 WITH p_werks EQ is_header_dialog-werks
                      WITH p_aufnr EQ is_header_dialog-aufnr
                      WITH p_dynpr EQ '0100'
                      WITH p_ctroq EQ ls_hdr-copiatro
                      WITH p_jclic EQ ls_hdr-juegocli
                      AND RETURN.

*     Importamos si hay que liberar
      IMPORT release TO gv_release FROM SHARED BUFFER indx(st) ID 'RELEASE'.

*     Miramos si no se quiere liberar
      IF gv_release IS INITIAL.
*       Lanzamos error
        RAISE free_failed_error.
      ELSE.
*       Importamos tabla a memoria para poder leerla desde el report
        IMPORT utillajes TO gt_ztpp0013 FROM SHARED BUFFER indx(st) ID 'UTILLAJES'.

*       Añadimos lineas borradas si ha habido cambio de Vers Fab desde la COR2
        APPEND LINES OF lt_borradas TO gt_ztpp0013.

*       Montamos ALV que viene del programa zrpp0031
        CLEAR gt_zttpm0007.

        LOOP AT gt_ztpp0013 INTO DATA(ls_dato).
          MOVE-CORRESPONDING ls_dato TO ls_alv.
*         Controlamos si están borrados
          IF ls_dato-zzptbo IS INITIAL.
            APPEND ls_alv TO gt_zttpm0007.
          ENDIF.
        ENDLOOP.

*       Exportamos ALV
        CALL FUNCTION 'ZPP_SET_UTILLAJES'
          EXPORTING
            it_zttpm0007 = gt_zttpm0007
*           IT_BORRADOS  =
          .
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD if_ex_workorder_update~at_save.
*---------------------------------------------------------
* IS_HEADER_DIALOG  Importing Type  COBAI_S_HEADER_DIALOG
*---------------------------------------------------------

    DATA lv_code LIKE sy-subrc.

*   Comprobar si el material tiene el calculo de costes realizado:
    IF ( sy-tcode = 'COR1' OR sy-tcode = 'COR2' OR sy-tcode = 'COHVPI' )
      AND is_header_dialog-werks = '3000'.

      IF is_header_dialog-auart = 'ZI01' OR is_header_dialog-auart = 'ZI02'
        OR is_header_dialog-auart = 'ZI03' OR is_header_dialog-auart = 'ZI04'
        OR is_header_dialog-auart = 'ZI05' OR is_header_dialog-auart = 'ZI06'.

        CALL FUNCTION 'COPC_CHECK_MBEW_KEKO'
          EXPORTING
            material = is_header_dialog-plnbez
            bwkey    = is_header_dialog-werks
            status   = 'FR'
          IMPORTING
            rcode    = lv_code.

        IF lv_code <> 0. "  NO se ha hecho el calculo de costes
          IF is_header_dialog-sttxt CP '*ABIE*'.  "-> Aviso
            MESSAGE i041(zpp).
          ENDIF.
          IF is_header_dialog-sttxt CP '*LIB*'.   "-> Error
            MESSAGE e041(zpp).
          ENDIF.
        ENDIF.

**       CGIJON - INI 13.02.17
*        IF is_header_dialog-sttxt CP '*EDET*'.  "-> Aviso
*         raise ERROR_WITH_MESSAGE.
*        ENDIF.
**       FIN CGIJON - INI 13.02.17

      ENDIF.
    ELSEIF is_header_dialog-werks = '4000'.
*      DATA:  lv_copiatro TYPE zcopiatro,
*             lv_juegocli TYPE zjuegocli.
*
**     Obtenemos tabla utillajes
*      CALL FUNCTION 'ZPP_GET_UTILLAJES'
*        IMPORTING
*          ev_copiatro  = lv_copiatro
*          ev_juegocli  = lv_juegocli
*          et_zttpm0007 = gt_zttpm0007
*          et_borrados  = gt_ztpp0013.
**     Borramos todas las entradas de la tabla de borrados solo con vornr
*      delete gt_ztpp0013 WHERE vornr is NOT INITIAL and equnr IS INITIAL.
*
**     Comprobamos si hay una posición solo con el vornr
*      LOOP AT gt_zttpm0007 INTO DATA(ls_row) WHERE vornr is NOT INITIAL and equnr IS INITIAL.
*        MESSAGE e251(zpp).
**       Hay posiciones en la tabla de utillajes sin rellenar.
*      ENDLOOP.
    ENDIF.

* ini 23.02.2018 - cvivo - 46461 Validación material con PMV en orden
    DATA: campo(40) VALUE '(SAPLCOZV)AFPOD-BWTAR'.
    FIELD-SYMBOLS: <bwtar> TYPE bwtar_d.

    SELECT COUNT(*) FROM tvarvc
      WHERE name EQ 'ZMATERIAL_PMV_ORDEN'
        AND low  EQ is_header_dialog-auart
        AND high EQ is_header_dialog-werks.

    IF sy-subrc EQ 0. " validación activada
      ASSIGN (campo) TO <bwtar>.
      IF sy-subrc EQ 0.
        SELECT COUNT(*) FROM mbew
          WHERE matnr EQ is_header_dialog-matnr
            AND bwkey EQ is_header_dialog-werks
            AND bwtar EQ <bwtar>
            AND vprsv EQ 'V'.

        IF sy-subrc EQ 0.
          MESSAGE e289(zpp).
        ENDIF.
      ELSE.
        SELECT COUNT(*) FROM mbew
          WHERE matnr EQ is_header_dialog-matnr
            AND bwkey EQ is_header_dialog-werks
            AND vprsv EQ 'V'.

        IF sy-subrc EQ 0.
          MESSAGE e289(zpp).
        ENDIF.
      ENDIF.
    ENDIF.
* fin 23.02.2018 - cvivo - 46461
    DATA: lv_centro TYPE werks.
    SELECT valor INTO @lv_centro FROM zparametros
      WHERE clave = 'AVISO_MERM'
      AND campo = 'CENTRO'
      AND valor = @is_header_dialog-werks.
    ENDSELECT.
    IF lv_centro IS NOT INITIAL.
      IF is_header_dialog-sttxt CP '*CTEC*' OR is_header_dialog-sttxt CP '*TECO*' OR is_header_dialog-sttxt CP  '*TABG*'. "HMO añadimos condición de que solo aplique en el cierre técnico
        "INI ARA GAPQM007-HPX Modificación proceso No Conform. 19.12.23 - Mermas
*Traemos el código directamente de IF_EX_WORKORDER_CONFIRM~AT_SAVE para que aplique aquí y lo adecuamos.
        DATA: lw_notifheader        TYPE bapi2078_nothdri,
              lw_notifheader_export TYPE bapi2078_nothdre,
              lt_return             TYPE bapiret2_t,
              lt_afvc               TYPE TABLE OF afvc,
              lv_maxvornr           TYPE vornr,
              lv_minvornr           TYPE vornr,
              lw_notitem            TYPE bapi2078_notitemi,
              lt_notitem            TYPE TABLE OF bapi2078_notitemi.

        SELECT SINGLE *
              INTO @DATA(lw_afpo)
              FROM afpo
              WHERE aufnr = @is_header_dialog-aufnr.
*    HMO INI- 05.04.2023 Ajuste GAP

        SELECT SINGLE * INTO @DATA(lt_afko) FROM afko
          WHERE aufnr = @is_header_dialog-aufnr.

        SELECT * INTO TABLE lt_afvc FROM afvc
          WHERE aufpl = lt_afko-aufpl.
*INI 26.01.2024 HMO Nuevo funcionamiento poses
        TYPES: BEGIN OF ty_afvc2,
                 vornr     TYPE afvc-vornr,
                 aplzl     TYPE afvc-aplzl,
                 arbpl     TYPE crhd-arbpl,
                 arbid     TYPE afvc-arbid,
                 umrez     TYPE afvv-umrez,
                 convertir TYPE flag.
        TYPES: END OF ty_afvc2.
        DATA: lt_afvc2 TYPE TABLE OF ty_afvc2.
        DATA: valor_pose TYPE afvv-umrez.
        DATA: lv_arbpl2   TYPE rgsmv-from.
        valor_pose = 1.

        SELECT  vornr,aplzl, arbid
          FROM afvc
          INTO CORRESPONDING FIELDS OF TABLE @lt_afvc2
          WHERE aufpl = @lt_afko-aufpl.
        SORT lt_afvc2 BY vornr ASCENDING.
        LOOP AT lt_afvc2 INTO DATA(lw_afvc2).
          SELECT SINGLE arbpl FROM crhd
            INTO @DATA(lv_arbpl)
            WHERE objid = @lw_afvc2-arbid.
          lw_afvc2-arbpl = lv_arbpl.
          lv_arbpl2 = lv_arbpl.
          CALL FUNCTION 'G_SET_SEARCH_FOR_INTERVAL'
            EXPORTING
              set             = '0000ZSQMREPROCESOS'
              from            = lv_arbpl2
              to              = lv_arbpl2
              include_subsets = space
*	      TABLES
*	        vallist         = lt_vallist
            EXCEPTIONS
              value_not_found = 1
              set_not_found   = 2
              OTHERS          = 3.

          IF sy-subrc = 0.
            lw_afvc2-umrez = 1.
          ELSE.
            SELECT SINGLE umrez
              INTO lw_afvc2-umrez
              FROM afvv
              WHERE aufpl = lt_afko-aufpl
              AND aplzl = lw_afvc2-aplzl.
            valor_pose = valor_pose * lw_afvc2-umrez.
          ENDIF.

          MODIFY lt_afvc2 FROM lw_afvc2.
          CLEAR lv_arbpl.
        ENDLOOP.

        LOOP AT lt_afvc2 INTO DATA(lw_afvc3).
          DATA: valor_pose2 TYPE afvv-umrez.
          valor_pose2 = 1.
          LOOP AT lt_afvc2 INTO DATA(lw_afvc4).
            IF lw_afvc4-vornr >= lw_afvc3-vornr.
              valor_pose2 = valor_pose2 * lw_afvc4-umrez.
            ENDIF.
            IF valor_pose2 > 1.
              lw_afvc3-convertir = 'X'.
            ENDIF.
          ENDLOOP.
          CLEAR valor_pose2.
          MODIFY lt_afvc2 FROM lw_afvc3.
        ENDLOOP.
*FIN 26.01.2024 HMO Nuevo funcionamiento poses

        SORT lt_afvc BY vornr DESCENDING.


        READ TABLE lt_afvc INTO DATA(wa_vornr) INDEX 1.
        IF sy-subrc EQ 0.
          lv_maxvornr = wa_vornr-vornr.
        ENDIF.

        SELECT SINGLE * INTO @DATA(wa_viqmel) FROM viqmel
          WHERE qmtxt = 'Merma'
          AND fertaufnr = @is_header_dialog-aufnr.
        IF wa_viqmel IS INITIAL.

*    HMO FIN- 05.04.2023 Ajuste GAP
          SELECT SINGLE porc,cant_rech INTO @DATA(l_punto_merma) FROM zsqmt000_merma.

          SELECT SINGLE b~* INTO @DATA(l_yhp_idx_td100)
            FROM marc AS a
            INNER JOIN yhp_idx_td100 AS b ON a~cuobj = b~cuobj
             WHERE a~matnr = @lw_afpo-matnr
               AND a~werks = @is_header_dialog-werks.

**HMO INI- 05.04.2023 Ajuste GAP
          SORT lt_afvc BY vornr ASCENDING.
          READ TABLE lt_afvc INTO DATA(wa_minvornr) INDEX 1.
          IF sy-subrc EQ 0.
            lv_minvornr = wa_minvornr-vornr.
          ENDIF.
**HMO FIN- 05.04.2023 Ajuste GAP
*    SELECT SUM( lmnga ) AS cant_buena, SUM( xmnga ) AS cant_merma
*      INTO @DATA(lw_afru)
*      FROM afru
*      WHERE aufnr = @is_header_dialog-aufnr
*        AND stokz = ''
*        AND stzhl = ''.
          SELECT a~lmnga AS cant_buena, a~xmnga AS cant_merma, a~grund, a~vornr, c~umrez "añado a~vornr para realizar después la consulta a lt_afvc2.
            FROM afru AS a
            INNER JOIN afvc AS b ON a~aufpl = b~aufpl AND a~vornr = b~vornr
            INNER JOIN afvv AS c ON b~aufpl = c~aufpl AND b~aplzl = c~aplzl
            WHERE a~aufnr = @is_header_dialog-aufnr
              AND a~stokz = ''
              AND a~stzhl = ''
            INTO TABLE @DATA(lt_afru_pose).

          LOOP AT lt_afru_pose INTO DATA(lw_afru_pose).
            DATA: lv_cant_buena TYPE lmnga, lv_cant_merma TYPE xmnga.
*INI 26.01.2024 HMO Nuevo funcionamiento poses
            DATA: lv_convertir TYPE flag.
            READ TABLE lt_afvc2
            WITH KEY vornr = lw_afru_pose-vornr
            INTO DATA(wa_convertir).
            lv_convertir = wa_convertir-convertir.
            IF lv_convertir IS NOT INITIAL.
              lv_cant_buena = ( lw_afru_pose-cant_buena * valor_pose ) + lv_cant_buena.
              lv_cant_merma = ( lw_afru_pose-cant_merma * valor_pose ) + lv_cant_merma.
            ELSE.
              lv_cant_buena = lw_afru_pose-cant_buena + lv_cant_buena.
              lv_cant_merma = lw_afru_pose-cant_merma + lv_cant_merma.
            ENDIF.
*          lv_cant_buena = ( lw_afru_pose-cant_buena * lw_afru_pose-umrez ) + lv_cant_buena.
*          lv_cant_merma = ( lw_afru_pose-cant_merma * lw_afru_pose-umrez ) + lv_cant_merma.
*FIN 26.01.2024 HMO Nuevo funcionamiento poses
          ENDLOOP.

***HMO INI- 05.04.2023 Ajuste GAP
          SELECT a~lmnga AS cant_buena, a~vornr, c~umrez "Seleccionamos la cantidad buena que no pertenece a la primera operación. Esta cantidad está duplicada en la primera consulta. HMO: añado a~vornr para realizar después la consulta a lt_afvc2.
            INTO TABLE @DATA(lt_afru_pose2)
            FROM afru AS a
            INNER JOIN afvc AS b ON a~aufpl = b~aufpl AND a~vornr = b~vornr
            INNER JOIN afvv AS c ON b~aufpl = c~aufpl AND b~aplzl = c~aplzl
            WHERE a~aufnr = @is_header_dialog-aufnr
              AND a~stokz = ''
              AND a~stzhl = ''
              AND a~vornr NE @lv_minvornr.
*INI 26.01.2024 HMO Nuevo funcionamiento poses
          CLEAR lv_convertir.
          LOOP AT lt_afru_pose2 INTO DATA(lw_afru_pose2).
            READ TABLE lt_afvc2
            WITH KEY vornr = lw_afru_pose2-vornr
            INTO DATA(wa_convertir2).
            lv_convertir = wa_convertir2-convertir.
            IF lv_convertir IS NOT INITIAL.
              lv_cant_buena = lv_cant_buena - ( lw_afru_pose2-cant_buena * valor_pose ).
            ELSE.
              lv_cant_buena = lv_cant_buena - lw_afru_pose2-cant_buena.
            ENDIF.
*            lv_cant_buena = lv_cant_buena - ( lw_afru_pose2-cant_buena * lw_afru_pose2-umrez ).
          ENDLOOP.
*FIN 26.01.2024 HMO Nuevo funcionamiento poses
***HMO FIN- 05.04.2023 Ajuste GAP

*    ADD is_confirmation-lmnga TO lw_afru-cant_buena. " HMO Comentamos en ajuste GAP 05.04.2023
*    SUBTRACT lw_afru2 FROM lw_afru-cant_buena. " HMO Quitamos las cantidades buena duplicadas ya que con la de la primera operación bastará (ajuste GAP 05.04.2023).
*    DATA: lv_afru_um TYPE afru-xmnga.
*    IF lw_afpo-umrez IS NOT INITIAL.
*      lv_afru_um = lw_afpo-umrez * lw_afru-cant_merma.
*    ELSE.
*      lv_afru_um = lw_afru-cant_merma.
*    ENDIF.

*    IF lw_afru-cant_buena IS NOT INITIAL AND lv_afru_um IS NOT INITIAL.
*      DATA(l_cant_total) = lw_afru-cant_buena + lv_afru_um.
*      "ASC >>> 18.02.2022 Cambiamos la forma de calcular
**      DATA(l_porc) = lw_afru-cant_merma * 100 / l_cant_total.
*      DATA l_porc TYPE ru_lmnga.
*      l_porc = lv_afru_um * 100 / lw_afru-cant_buena.
*      "ASC <<< 18.02.2022 Cambiamos la forma de calcular

          IF lv_cant_buena IS NOT INITIAL AND lv_cant_merma IS NOT INITIAL.
            DATA(l_cant_total) = lv_cant_buena + lv_cant_merma.
            "ASC >>> 18.02.2022 Cambiamos la forma de calcular
*      DATA(l_porc) = lw_afru-cant_merma * 100 / l_cant_total.
            DATA l_porc TYPE ru_lmnga.
            l_porc = lv_cant_merma * 100 / lv_cant_buena.
            "ASC <<< 18.02.2022 Cambiamos la forma de calcular

            IF l_porc > l_punto_merma-porc OR ( l_yhp_idx_td100-nblar * lv_cant_merma ) > l_punto_merma-cant_rech.
              CLEAR: lw_notifheader_export, lt_return[].

*Los campos a completar en el aviso son:
*-Material: con AFRU-AUFNR obtener AFPO-MATNR y copiar a QMEL-MATNR
*-Lote: con AFRU-AUFNR obtener AFPO-CHARG y copiar a QMEL-CHARG
*-Orden de fabricación: AFRU-AUFNR copiar a QMEL-FERTAUFNR
*-Cantidad afectada: AFRU-XMNGA copiar a QMEL-RKMNG
*-Descripción: Merma copiar texto en QMEL-QMTXT
*-Campo costes: campo Z a crear en el aviso (pestaña estado-cantidades).
              "Se obtiene de la cantidad NOOK multiplicada por el coste unitario (venta)?.




              lw_notifheader-material = lw_afpo-matnr.
              lw_notifheader-batch = lw_afpo-charg.
              lw_notifheader-prod_order = is_header_dialog-aufnr.
              lw_notifheader-material_plant = is_header_dialog-werks. "HMO Añado centro
              lw_notifheader-quant_complaint = lv_cant_merma.
              lw_notifheader-short_text = 'Merma'.

              "Aquí dentro hay un commit
              "Pendiende de pruebas para ver como se deja la llamada
              DATA: l_qmart  TYPE qmart,
                    l_costes TYPE zsqm_costes.
              l_qmart = 'Z2'.

              DATA: lv_xmnga TYPE xmnga.
              CLEAR lv_xmnga.
              lv_xmnga = lv_cant_merma.

              "ARA Incluimos tantas posiciones en el aviso como notificaciones parciales con merma existen con la información asociada de causa de desviación

*            TYPES: BEGIN OF lt_afru,
*                     cant_merma TYPE afru-xmnga,
*                     grund_afru TYPE afru-grund,
*                     umrez_afru TYPE afvv-umrez,
*                   END OF lt_afru.
*
*            LOOP AT lt_afru_pose INTO DATA(lw_afru).
*              IF lw_afru-cant_merma > 0.
*                lw_afru-cant_merma = lw_afru-cant_merma * lw_afru-umrez.
*
**                APPEND lw_afru TO lt_afru.
*              ENDIF.
*            ENDLOOP.

              IF lv_cant_merma IS NOT INITIAL.
                lw_notitem-item_key = 1.
                lw_notitem-item_sort_no = 1.
                LOOP AT lt_afru_pose INTO DATA(lw_afru_grund)
                  WHERE cant_merma > 0.
                  SELECT SINGLE grdtx INTO @DATA(lv_grund)
                    FROM trugt
                    WHERE werks = @is_header_dialog-werks
                    AND grund = @lw_afru_grund-grund
                    AND spras = @sy-langu.
                  lw_notitem-descript = lv_grund.
*INI 26.01.2024 HMO Nuevo funcionamiento poses
                  CLEAR lv_convertir.
                  READ TABLE lt_afvc2
                  WITH KEY vornr = lw_afru_grund-vornr
                  INTO DATA(wa_convertir3).
                  lv_convertir = wa_convertir3-convertir.
                  IF lv_convertir IS NOT INITIAL.
                    lw_notitem-quant_defects = lw_afru_grund-cant_merma * valor_pose.
                  ELSE.
                    lw_notitem-quant_defects = lw_afru_grund-cant_merma.
                  ENDIF.

*                lw_notitem-quant_defects = lw_afru_grund-cant_merma * lw_afru_grund-umrez.
*FIN 26.01.2024 HMO Nuevo funcionamiento poses
                  APPEND lw_notitem TO lt_notitem.

                  ADD 1 TO lw_notitem-item_key.
                  ADD 1 TO lw_notitem-item_sort_no.
                ENDLOOP.
              ENDIF.

              CALL FUNCTION 'ZSQM_CREAR_AVISO' STARTING NEW TASK 'ZAVISO'
                EXPORTING
                  notif_type  = l_qmart
                  notifheader = lw_notifheader
                  zzcostes    = l_costes
                  kdauf       = lw_afpo-kdauf
                  kdpos       = lw_afpo-kdpos
                  matnr       = lw_afpo-matnr
                  xmnga       = lv_xmnga
                  tcode       = sy-tcode
                TABLES
                  notitem     = lt_notitem.
*          importing
*           return      = lt_return.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.




  ENDMETHOD.
  METHOD if_ex_workorder_update~before_update.
    DATA: ls_ztpp0012 TYPE ztpp0012,
          ls_header   TYPE cobai_s_header,
          ls_ztpp0013 TYPE ztpp0013,
          lt_ztpp0013 TYPE TABLE OF ztpp0013,
          ls_bbdd     TYPE ztpp0013,
          lv_copiatro TYPE zcopiatro,
          lv_juegocli TYPE zjuegocli.

    IF ( sy-tcode = 'COR1' OR sy-tcode = 'COR2' OR sy-tcode = 'COHVPI' OR sy-tcode = 'ZPP0041' ).

      READ TABLE it_header INTO ls_header WITH KEY werks = '4000'.

      CHECK sy-subrc = 0.
      SELECT SINGLE * FROM ztpp0012
        INTO ls_ztpp0012
        WHERE werks = ls_header-werks AND
              auart = ls_header-auart.

      CHECK sy-subrc = 0.

*     Comprobamos si ya tenemos informada gt_ztpp0013. Si está informada es porque se libero antes de grabar
      IF gt_ztpp0013 IS INITIAL.
*       Obtenemos tabla utillajes
        CALL FUNCTION 'ZPP_GET_UTILLAJES'
          IMPORTING
            ev_copiatro  = lv_copiatro
            ev_juegocli  = lv_juegocli
            et_zttpm0007 = gt_zttpm0007
            et_borrados  = gt_ztpp0013.

*       Borramos posiciones vacias
        DELETE gt_zttpm0007 WHERE equnr IS INITIAL OR vornr IS INITIAL.
        DELETE gt_ztpp0013  WHERE equnr IS INITIAL OR vornr IS INITIAL.

*       Cambiamos orden en tabla de borrados
        LOOP AT gt_ztpp0013 ASSIGNING FIELD-SYMBOL(<fs_borrados>) WHERE aufnr CA '%'.
          <fs_borrados>-aufnr = ls_header-aufnr.
        ENDLOOP.

*       Montamos tabla para pasar a BBDD juntando con líneas borradas
        LOOP AT gt_zttpm0007 INTO DATA(ls_dato).
          MOVE-CORRESPONDING ls_header TO ls_ztpp0013.
          MOVE-CORRESPONDING ls_dato   TO ls_ztpp0013.
          ls_ztpp0013-zzfechas  = sy-datum.
          ls_ztpp0013-zzhoraas  = sy-uzeit.

*         No queremos guardar la CT y JC en las entradas nuevas ya que no les corresponden esos datos
**         Informamos copia de troqueles y juego de cliches
*          ls_ztpp0013-copiatro = lv_copiatro.
*          ls_ztpp0013-juegocli = lv_juegocli.

*         Añadimos a tabla de borrados
          APPEND ls_ztpp0013 TO gt_ztpp0013.
        ENDLOOP.

*       Ordenamos lineas duplicadas para luego borrar
        SORT gt_ztpp0013 BY aufnr werks vornr equnr zzptbo ASCENDING.

*       Borramos duplicados
        DELETE ADJACENT DUPLICATES FROM gt_ztpp0013 COMPARING aufnr werks vornr equnr.
      ELSE.
*       Cogemos las borradas cuando venimos de ZRPP0031 y las añadimos a las borradas de la XCO1
        CALL FUNCTION 'ZPP_GET_UTILLAJES'
          IMPORTING
            et_borrados = lt_ztpp0013.
        APPEND LINES OF lt_ztpp0013 TO gt_ztpp0013.
      ENDIF.

*     Borramos vacios
      DELETE gt_ztpp0013 WHERE equnr IS INITIAL.

*     Iteramos sobre la tabla comprobando si hay diferencias con la BBDD para updatear
      LOOP AT gt_ztpp0013 INTO ls_ztpp0013.
*       Informamos aufnr por si es initial
        ls_ztpp0013-aufnr = ls_header-aufnr.

*       Miramos en la BBDD a ver si hay un registro igual
        SELECT SINGLE * FROM ztpp0013 INTO ls_bbdd
          WHERE aufnr   = ls_ztpp0013-aufnr
            AND werks   = ls_ztpp0013-werks
            AND vornr   = ls_ztpp0013-vornr
            AND equnr   = ls_ztpp0013-equnr.
*            AND zzptbo  = ls_ztpp0013-zzptbo.
        IF sy-subrc NE 0.
*         Insertamos lineas en tabla Z
          INSERT ztpp0013 FROM ls_ztpp0013.
        ELSE.
*         Modificamos lineas en tabla Z
          MODIFY ztpp0013 FROM ls_ztpp0013.
        ENDIF.
      ENDLOOP.
    ENDIF.

    "ASC >>> 22.12.2021 - GAPSD002 Condición envío confirmación pedido
    DATA: lt_mdrq    TYPE TABLE OF mdrq,
          ls_zpp0002 TYPE zpp0002.

    CLEAR: ls_header, lt_mdrq[], ls_zpp0002.
    LOOP AT it_header INTO ls_header WHERE kdauf_aufk IS INITIAL AND ( werks = '2001' OR werks = '2003' ).

      READ TABLE it_item INTO DATA(ls_item) WITH KEY aufnr = ls_header-aufnr.
      IF sy-subrc = 0.
        DATA: lv_edelnr TYPE del12.
        CLEAR lv_edelnr.
        lv_edelnr = ls_item-plnum.
        CALL FUNCTION 'MD_PEGGING_NODIALOG'
          EXPORTING
            edelet                = '0000'
            edelkz                = 'PA'
            edelnr                = lv_edelnr
            edelps                = '000000'
            eplscn                = '000'
            ematnr                = ls_item-matnr
            ewerks                = ls_header-werks
            eplaab                = '00'
          TABLES
            imdrqx                = lt_mdrq[]
          EXCEPTIONS
            error                 = 1
            no_requirements_found = 2
            order_not_found       = 3
            OTHERS                = 4.
        IF sy-subrc <> 0.
* Implement suitable error handling here
        ENDIF.

        "MTS: Solo añadimos la última orden creada.
        SORT lt_mdrq BY dat00 ASCENDING.
*        LOOP AT lt_mdrq INTO DATA(ls_mdrq) WHERE delkz = 'VC'.
        READ TABLE lt_mdrq INTO DATA(ls_mdrq) WITH KEY delkz = 'VC'.
        IF sy-subrc = 0.
          ls_zpp0002-werks = ls_header-werks.
          ls_zpp0002-aufnr = ls_header-aufnr.
          ls_zpp0002-kdauf = ls_mdrq-delnr.
          ls_zpp0002-kdpos = ls_mdrq-delps.
          ls_zpp0002-gstrp = ls_header-gstrp.

          MODIFY zpp0002 FROM ls_zpp0002.

        ELSE.
          READ TABLE lt_mdrq INTO ls_mdrq WITH KEY delkz = 'BB'.
          IF sy-subrc = 0.
            "Con eel HEADAR-MATNR vamos a la RESB entrando por resb-matnr = header-matnr Y RESB-BDTER = HEADER-GLTRP y cogemos el RESB-AUFNR,
            "Vamos a la AUFK entrando por AUFNR y cogemos el KDAUF y KDPOS y le pasamos a la ZPP002 el WERKS= HEADER-WERKS, KDAUF, KDPOS y AUFNR
            SELECT SINGLE b~aufnr, b~kdauf, b~kdpos
              FROM resb AS a
              INNER JOIN aufk AS b ON b~aufnr = a~aufnr
              INTO @DATA(ls_ordenes)
              WHERE a~matnr = @ls_header-matnr
              AND a~bdter = @ls_header-gltrp.
            IF sy-subrc = 0.
              ls_zpp0002-werks = ls_header-werks.
              ls_zpp0002-aufnr = ls_header-aufnr.
              ls_zpp0002-kdauf = ls_ordenes-kdauf.
              ls_zpp0002-kdpos = ls_ordenes-kdpos.
              ls_zpp0002-gstrp = ls_header-gstrp.

              MODIFY zpp0002 FROM ls_zpp0002.
            ENDIF.
          ELSE.
            " Si el material de la cabecera de la orden es MTART = "ZPSE", entonces hay que ir a la
            "RESB del WERKS contrario (si el werks de la orden es 2001, vamos al 2003 y viceversa)
            "entrando por ese MATNR y cogemos EL AUFNR y vamos a la AFKO entrando por AUFNR y cogemos
            "el PLNBEZ (material). Ahora con ese material y con la fecha fin de la orden que estamos
            "tratando entramos a la VBEP por la fecha de entrega EDATU ( y cogemos el VBELN y POSNR

            DATA lv_werks_contrario TYPE werks_d.
            SELECT SINGLE mtart
              INTO @DATA(lv_mtart)
              FROM mara
              WHERE matnr = @ls_header-matnr
              AND mtart = 'ZPSE'.
            IF sy-subrc = 0.
              IF ls_header-werks = '2001'.
                lv_werks_contrario = '2003'.
              ELSE.
                lv_werks_contrario = '2001'.
              ENDIF.
              SELECT a~aufnr, c~vbeln, c~posnr
                FROM resb AS a
                INNER JOIN afko AS b ON b~aufnr = a~aufnr
                INNER JOIN vbap AS c ON c~matnr = b~plnbez
                INNER JOIN vbep AS e ON e~vbeln = c~vbeln AND e~posnr = c~posnr AND e~mbdat =  @ls_header-gltrp
                INTO TABLE @DATA(lt_resb)
                WHERE a~werks = @lv_werks_contrario
                AND a~matnr = @ls_header-matnr.
              IF sy-subrc = 0.
                READ TABLE lt_resb INTO DATA(ls_resb) INDEX 1.
                ls_zpp0002-werks = ls_header-werks.
                ls_zpp0002-aufnr = ls_header-aufnr.
                ls_zpp0002-kdauf = ls_resb-vbeln.
                ls_zpp0002-kdpos = ls_resb-posnr.
                ls_zpp0002-gstrp = ls_header-gstrp.
*          ls_zpp0002-stat
                MODIFY zpp0002 FROM ls_zpp0002.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
*        ENDLOOP.



      ENDIF.
    ENDLOOP.
    "ASC <<< 22.12.2021 - GAPSD002 Condición envío confirmación pedido

    DATA: lt_return     TYPE bapiret2_t,
          lv_sched_type TYPE ettyp.

    LOOP AT it_header INTO ls_header WHERE  ( werks = '2001' OR werks = '2003' ).
      "MTS: Modificamos el tipo de posición de Reparto al pedido relacionado con la orden
      SELECT mtart
        FROM mara
        INTO TABLE @DATA(lt_mtart)
        WHERE matnr = @ls_header-plnbez
        AND mtart = 'ZPTO'.
      IF sy-subrc = 0.
        CLEAR: lv_sched_type, lt_return.
        IF ls_header-kdauf_aufk IS INITIAL.
          SELECT SINGLE kdauf kdpos INTO ( ls_header-kdauf_aufk, ls_header-kdpos_aufk ) FROM aufk WHERE aufnr EQ ls_header-aufnr.
          IF sy-subrc <> 0.
            SELECT SINGLE kdauf kdpos INTO ( ls_header-kdauf_aufk, ls_header-kdpos_aufk ) FROM zpp0002 WHERE aufnr EQ ls_header-aufnr.
          ENDIF.
        ENDIF.
        SELECT SINGLE bedae INTO @DATA(lv_bedae) FROM vbap WHERE vbeln EQ @ls_header-kdauf_aufk AND posnr EQ @ls_header-kdpos_aufk.
        IF NOT ( lv_bedae = 'ZZZ' OR lv_bedae = 'ZPAC' OR lv_bedae = 'ZSAR' OR lv_bedae = 'ZRS' OR lv_bedae = 'ZRP' )."ZZZ ZPAC o ZSAR no se modifica
          READ TABLE it_status INTO DATA(ls_new) WITH KEY objnr = ls_header-objnr stat = 'I0002' inact = space.
          IF sy-subrc = 0.
            READ TABLE it_status_old INTO DATA(ls_old) WITH KEY objnr = ls_header-objnr stat = 'I0001' inact = space.
            IF sy-subrc = 0.
              CASE lv_bedae.
                WHEN 'ZKB'.
                  lv_sched_type = 'ZY'.
                WHEN OTHERS.
                  lv_sched_type = 'ZZ'.
              ENDCASE.
            ENDIF.
          ELSE.
            READ TABLE it_status INTO ls_new WITH KEY objnr = ls_header-objnr stat = 'I0001' inact = space.
            IF sy-subrc = 0.
              READ TABLE it_status_old INTO ls_old WITH KEY objnr = ls_header-objnr stat = 'I0002' inact = space.
              IF sy-subrc = 0.
                CASE lv_bedae.
                  WHEN 'ZKB'.
                    lv_sched_type = 'E1'.
                  WHEN OTHERS.
                    lv_sched_type = 'CP'.
                ENDCASE.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
        IF lv_sched_type IS NOT INITIAL.
          CALL FUNCTION 'ZSSDPP_CHANGE_BEDAE' IN UPDATE TASK
            EXPORTING
              i_aufnr      = ls_header-aufnr
              i_sched_type = lv_sched_type
*             i_commit     = 'X'
            IMPORTING
              et_return    = lt_return.
        ENDIF.
      ENDIF.
    ENDLOOP.
    "FIN MTS: Modificamos el tipo de posición de Reparto al pedido relacionado con la orden

  ENDMETHOD.
  method IF_EX_WORKORDER_UPDATE~CMTS_CHECK.
  endmethod.
  METHOD if_ex_workorder_update~in_update.
*----------------------------------------------------------------------
*  IT_HEADER              Importing Type  COBAI_T_HEADER
*  IT_HEADER_OLD          Importing Type  COBAI_T_HEADER_OLD
*  IT_ITEM                Importing Type  COBAI_T_ITEM
*  IT_ITEM_OLD            Importing Type  COBAI_T_ITEM_OLD
*  IT_SEQUENCE            Importing Type  COBAI_T_SEQUENCE
*  IT_SEQUENCE_OLD        Importing Type  COBAI_T_SEQUENCE_OLD
*  IT_OPERATION           Importing Type  COBAI_T_OPERATION
*  IT_OPERATION_OLD       Importing Type  COBAI_T_OPERATION_OLD
*  IT_COMPONENT           Importing Type  COBAI_T_COMPONENT
*  IT_COMPONENT_OLD       Importing Type  COBAI_T_COMPONENT_OLD
*  IT_DOCLINK             Importing Type  COBAI_T_DOCLINK
*  IT_DOCLINK_OLD         Importing Type  COBAI_T_DOCLINK_OLD
*  IT_PRT_ALLOCATION      Importing Type  COBAI_T_PRT_ALLOCATION
*  IT_PRT_ALLOCATION_OLD  Importing Type  COBAI_T_PRT_ALLOCATION_OLD
*  IT_MILESTONE           Importing Type  COBAI_T_MILESTONE
*  IT_MILESTONE_OLD       Importing Type  COBAI_T_MILESTONE_OLD
*  IT_HEADER              Importing Type  COBAI_T_HEADER
*  IT_HEADER_OLD          Importing Type  COBAI_T_HEADER_OLD
*  IT_ITEM                Importing Type  COBAI_T_ITEM
*  IT_ITEM_OLD            Importing Type  COBAI_T_ITEM_OLD
*  IT_SEQUENCE            Importing Type  COBAI_T_SEQUENCE
*  IT_SEQUENCE_OLD        Importing Type  COBAI_T_SEQUENCE_OLD
*  IT_OPERATION           Importing Type  COBAI_T_OPERATION
*  IT_OPERATION_OLD       Importing Type  COBAI_T_OPERATION_OLD
*  IT_COMPONENT           Importing Type  COBAI_T_COMPONENT
*  IT_COMPONENT_OLD       Importing Type  COBAI_T_COMPONENT_OLD
*  IT_DOCLINK             Importing Type  COBAI_T_DOCLINK
*  IT_DOCLINK_OLD         Importing Type  COBAI_T_DOCLINK_OLD
*  IT_PRT_ALLOCATION      Importing Type  COBAI_T_PRT_ALLOCATION
*  IT_PRT_ALLOCATION_OLD  Importing Type  COBAI_T_PRT_ALLOCATION_OLD
*  IT_MILESTONE           Importing Type  COBAI_T_MILESTONE
*  IT_MILESTONE_OLD       Importing Type  COBAI_T_MILESTONE_OLD
*----------------------------------------------------------------------

    LOOP AT it_header ASSIGNING FIELD-SYMBOL(<header>).
      IF NOT line_exists( it_header_old[ aufnr = <header>-aufnr ] ).
        DATA(l_evento) = 'CREATED'.
      ELSE.
        l_evento = 'CHANGED'.
      ENDIF.
      zcl_ap_wf=>lanzar_evento( objeto      = 'ZORDEN'
                                clave       = <header>-aufnr
                                evento      = l_evento
                                update_task = 'X' ).
    ENDLOOP.

  ENDMETHOD.
  METHOD if_ex_workorder_update~initialize.

*---------------------------------------------------------------------
*   PROYECTO CIPASI
*---------------------------------------------------------------------
*   Controlamos sociedad CIPASI
    IF is_caufvdb-werks = '4000'.
*     Inicializamos variables.
      CLEAR: gt_zttpm0007, gt_ztpp0013, gv_plnnr, gv_plnty, gv_release, gv_stlal, gv_stlan.

*     Llamamos método estático de inicialización de datos. Se utiliza también en exit
      zcl_im_zworkorder_update=>init_vers_alv( is_caufvdb = is_caufvdb ).
    ENDIF.
  ENDMETHOD.
  method IF_EX_WORKORDER_UPDATE~NUMBER_SWITCH.
  endmethod.
  method IF_EX_WORKORDER_UPDATE~REORG_STATUS_ACT_CHECK.

  endmethod.
  method IF_EX_WORKORDER_UPDATE~REORG_STATUS_ACTIVATE.
  endmethod.
  method IF_EX_WORKORDER_UPDATE~REORG_STATUS_REVOKE.
  endmethod.
  METHOD init_vers_alv.
    DATA: lt_plpo     TYPE plpo_t,
          lt_borradas TYPE zttpp0013,
          ls_ztpp0013 TYPE ztpp0013.

    DATA: lv_zztratos TYPE mara-zztratos,
          lt_text_tab TYPE STANDARD TABLE OF char2,
          lv_char2    TYPE char2,
          lv_zzaditiv TYPE mara-zzaditiv.

    FIELD-SYMBOLS: <fs_zttpm0007> TYPE zspm0007.


*   Controlamos si estamos en cor2 y cambiamos de versión de fab debemos poner las entradas BBDD como borradas
    IF sy-tcode EQ 'COR2' AND iv_ddmm IS NOT INITIAL.
      zcl_im_zworkorder_update=>add_table_to_remove(
        EXPORTING
          is_caufvdb  = is_caufvdb
          it_table    = gt_zttpm0007
        IMPORTING
          et_borradas = lt_borradas ).

      CLEAR: gt_zttpm0007.
    ENDIF.

*   Limpiamos todas la variables globales
    CLEAR: gv_plnty, gv_plnnr, gv_stlal, gv_stlan, gt_ztpp0013.

*   Guardamos la versión por si se cambia desde Orden de proceso-> funciones-> Releer datos maestros
    gv_plnty = is_caufvdb-plnty.
    gv_plnnr = is_caufvdb-plnnr.
    gv_stlan = is_caufvdb-stlan.
    gv_stlal = is_caufvdb-stlal.

*   Controlamos si estamos en la COR2 o COR3
    IF ( sy-tcode EQ 'COR2' OR sy-tcode EQ 'COR3' or sy-tcode eq 'COHVPI') AND iv_ddmm IS INITIAL.
      zcl_im_zworkorder_update=>modify_alv_cor2_3(
        EXPORTING
          is_caufvdb  = is_caufvdb
        IMPORTING
          es_copiatro = DATA(ls_zspm0009)   " Pareja Copia troqules y Juego de cliches
      ).

    ELSE.
*     Miramos la clase de orden
      SELECT SINGLE auart FROM ztpp0012
        INTO @DATA(wa_ztpp0012)
        WHERE werks = @is_caufvdb-werks AND
              auart = @is_caufvdb-auart.

      IF sy-subrc = 0.
*       Obtenemos operaciones del material
        SELECT b~vornr, b~phseq, b~steus FROM   plas AS a
                                   INNER JOIN   plpo AS b ON  a~plnty = b~plnty AND
                                                              a~plnnr = b~plnnr AND
                                                              a~plnkn = b~plnkn AND
                                                              a~zaehl = b~zaehl
          INTO CORRESPONDING FIELDS OF TABLE @lt_plpo
          WHERE a~plnty = @is_caufvdb-plnty
            AND a~plnnr = @is_caufvdb-plnnr
            AND a~plnal = @is_caufvdb-plnal
            AND b~phseq NE ''.
        CHECK sy-subrc EQ 0.

*       Informamos si hay troquelado
        READ TABLE lt_plpo TRANSPORTING NO FIELDS WITH KEY phseq = 'Z4'.
        IF sy-subrc EQ 0.
          DATA(lv_troquelado) = 'X'.
        ENDIF.

*       Informamos si hay impresión
        READ TABLE lt_plpo TRANSPORTING NO FIELDS WITH KEY phseq = 'Z5'.
        IF sy-subrc EQ 0.
          DATA(lv_impresion) = 'X'.
        ENDIF.

*       Obtenemos material ZPLP y Coproductos
        zcl_im_zworkorder_update=>get_zplp_coproducts(
          EXPORTING
            is_caufvdb    = is_caufvdb    " Document table structure of the order header
          IMPORTING
            ev_zplp       = DATA(lv_zplp) " Material ZPLP
            et_coproducts = DATA(lt_copr) " Materiales Co-productos
        ).

*       Obtenemos copia de troqueles y juego de cliches
        zcl_im_zworkorder_update=>get_ctro_jcli(
          EXPORTING
            is_caufvdb    = is_caufvdb
            iv_troquelado = lv_troquelado
            iv_impresion  = lv_impresion
            iv_zplp       = lv_zplp
            it_coproducts = lt_copr
          IMPORTING
            et_zttpm0009   = DATA(lt_zttpm0009)    " Copia de troqueles y juego cliches
        ).
      ENDIF.

*     Controlamos si tenemos varías copias de troqueles
      IF lines( lt_zttpm0009 ) > 1 AND ( sy-tcode EQ 'COR1'  OR sy-tcode = 'ZPP0049' OR sy-tcode = 'COR2' )
                                   AND is_caufvdb-auart EQ 'ZC02'.
*       Lanzamos POPUP para elección de copia de troquel
        zcl_im_zworkorder_update=>display_popup_copiatro(
          EXPORTING
            it_zttpm0009 =  lt_zttpm0009   " Copia de troqueles
          IMPORTING
            es_copiatro  =  ls_zspm0009  " Copia de troqueles
        ).
      ELSEIF lines( lt_zttpm0009 ) EQ 0 AND ( sy-tcode EQ 'COR1'  OR sy-tcode = 'ZPP0049' )
                                   AND is_caufvdb-auart EQ 'ZC02'.
        MESSAGE i249(zpp).
*       No se han encontrado utillajes válidos.
      ELSE.
        READ TABLE lt_zttpm0009 INTO ls_zspm0009 INDEX 1.
      ENDIF.

*     Creamos tabla ALV
      zcl_im_zworkorder_update=>create_table_alv(
        EXPORTING
          it_plpo     = lt_plpo
          is_copiatro = ls_zspm0009
        IMPORTING
          et_alv      = zcl_im_zworkorder_update=>gt_zttpm0007
      ).

*     Informamos copia troqueles y juego cli
      LOOP AT gt_zttpm0007 ASSIGNING <fs_zttpm0007>.
        MOVE-CORRESPONDING ls_zspm0009 TO <fs_zttpm0007>.
      ENDLOOP.
    ENDIF.

*   Informamos tabla en memorida compartida de GF ZPP_CIPASI para informar dynpro
    CALL FUNCTION 'ZPP_SET_UTILLAJES'
      EXPORTING
        it_zttpm0007 = zcl_im_zworkorder_update=>gt_zttpm0007
        it_borrados  = lt_borradas.

*   Informamos cabecera
    CALL FUNCTION 'ZPP_SET_HD_UTILLAJES'
      EXPORTING
        iv_copiatro = ls_zspm0009-copiatro
        iv_juegocli = ls_zspm0009-juegocli
        is_caufvdb  = is_caufvdb.
* Estamos creando una orden nueva.
*    IF is_caufvdb-aufnr IS INITIAL OR is_caufvdb-aufnr = '%00000000001'.
*      IF is_caufvdb-matnr IS NOT INITIAL.
*        SELECT SINGLE zztratos zzaditiv
*          INTO (lv_zztratos, lv_zzaditiv)
*          FROM mara
*          WHERE matnr = is_caufvdb-matnr.
*        IF sy-subrc = 0.
*          CLEAR: lt_text_tab.
*          CALL FUNCTION 'SOTR_SERV_STRING_TO_TABLE'
*            EXPORTING
*              text        = lv_zztratos
*              line_length = 2
*            TABLES
*              text_tab    = lt_text_tab.
*
**          IF lt_text_tab is not INITIAL.
*          LOOP AT lt_text_tab INTO lv_char2.
*            CASE lv_char2.
*              WHEN 'CO'.
*
*              WHEN 'EX'.
*              WHEN 'IM'.
*              WHEN 'TE'.
*            ENDCASE.
*          ENDLOOP.
**          ENDIF.
*
*        ENDIF.
**        is_caufvdb-
*      ENDIF.
**      is_caufvdb-matnr
*    ENDIF.


  ENDMETHOD.
  METHOD modify_alv_cor2_3.
*   Obtenemos datos de la BBDD
    SELECT * FROM ztpp0013 INTO CORRESPONDING FIELDS OF TABLE zcl_im_zworkorder_update=>gt_zttpm0007
      WHERE aufnr = is_caufvdb-aufnr
        AND zzptbo EQ ''.

*   Informamos copia de troqueles y juego de cliches de una entrada que los tenga informado
    SELECT SINGLE copiatro juegocli FROM ztpp0013 INTO es_copiatro
      WHERE aufnr = is_caufvdb-aufnr
        and ( copiatro ne '' or juegocli ne '' )
        AND zzptbo EQ ''.

*   Informamos tabla en memorida compartida de GF ZPP_CIPASI para informar dynpro
    CALL FUNCTION 'ZPP_SET_UTILLAJES'
      EXPORTING
        it_zttpm0007 = zcl_im_zworkorder_update=>gt_zttpm0007.

*   Informamos cabecera
    CALL FUNCTION 'ZPP_SET_HD_UTILLAJES'
      EXPORTING
        iv_copiatro = es_copiatro-copiatro
        iv_juegocli = es_copiatro-juegocli
        is_caufvdb  = is_caufvdb.
  ENDMETHOD.
