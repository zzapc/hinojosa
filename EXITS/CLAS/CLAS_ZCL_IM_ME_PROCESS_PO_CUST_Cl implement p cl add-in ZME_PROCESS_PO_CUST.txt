
CLASS zcl_im_me_process_po_cust DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    TYPE-POOLS mmmfd .

    INTERFACES if_badi_interface .
    INTERFACES if_ex_me_process_po_cust .

    CLASS-DATA c_bsart_zpe1 TYPE bsart VALUE 'ZPE1' ##NO_TEXT.
    CLASS-DATA c_bsart_zpe2 TYPE bsart VALUE 'ZPE2' ##NO_TEXT.
protected section.
PRIVATE SECTION.

  DATA gt_items TYPE tab_mepoitem .
  DATA gv_trtyp TYPE trtyp .
  DATA gv_ebeln TYPE ebeln .
  DATA gt_mepoitem TYPE tab_mepoitem .
  DATA gt_meposched TYPE tab_meposchedule .
  DATA gv_lifnr TYPE lifnr .
  DATA gv_fsc TYPE xflag .
  DATA gv_texto_cabecera TYPE xflag .
  DATA _bstae_last_value TYPE bstae .
  DATA _bstae_user_value TYPE bstae VALUE '9999' ##NO_TEXT.
  DATA _knttp_last_value TYPE knttp .
  DATA _bstae_first_run TYPE boolean .

  DATA gt_pos_modif TYPE RANGE OF ebelp.

  METHODS _determine_bstae_value
    IMPORTING
      !i_mepoheader  TYPE mepoheader
      !i_mepoitem    TYPE mepoitem
    RETURNING
      VALUE(r_bstae) TYPE bstae .
  METHODS __check_if_bstae_must_clear
    IMPORTING
      !i_mepoitem    TYPE mepoitem
    RETURNING
      VALUE(r_clear) TYPE boolean .
  METHODS __get_bstae_knttp_range
    RETURNING
      VALUE(r_t_range_knttp) TYPE fip_t_knttp_range .
  METHODS __get_bstae_mtart_range
    RETURNING
      VALUE(r_t_range_mtart) TYPE md_range_t_mtart .
  METHODS __get_t163lv_bstae_value
    IMPORTING
      !i_bstyp       TYPE bstyp
      !i_bsart       TYPE bsart
      !i_werks       TYPE werks_d
      !i_lgort       TYPE lgort_d
    RETURNING
      VALUE(r_bstae) TYPE bstae .
endclass. "ZCL_IM_ME_PROCESS_PO_CUST definition
class ZCL_IM_ME_PROCESS_PO_CUST implementation.
METHOD __CHECK_IF_BSTAE_MUST_CLEAR.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** CHECK 1 MTART TVARVC

  IF ( i_mepoitem-mtart NOT IN me->__get_bstae_mtart_range( ) ).
    MOVE abap_true TO r_clear.
    EXIT.
  ENDIF.

****** CHECK 2 KNTTP

  IF ( i_mepoitem-knttp IS NOT INITIAL AND i_mepoitem-knttp NOT IN me->__get_bstae_knttp_range( ) ).
    MOVE abap_true TO r_clear.
    EXIT.
  ENDIF.

ENDMETHOD.
METHOD __GET_BSTAE_KNTTP_RANGE.

**********************************************************************
* Parámetros locales
**********************************************************************

****** CONSTANTS

  CONSTANTS: lc_tvarvc_bstae_knttp TYPE rvari_vnam VALUE 'ZMM_PO_BSTAE_KNTTP'.

****** STRUCTURES

  DATA: ls_tvarvc  TYPE tvarvc,
        ls_r_knttp TYPE fip_s_knttp_range.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET RANGE

  "Obtengo parámetros BSTAE para MTART
  SELECT *
    FROM tvarvc
    INTO CORRESPONDING FIELDS OF @ls_tvarvc
   WHERE name EQ @lc_tvarvc_bstae_knttp.

    CLEAR: ls_r_knttp.
    MOVE: ls_tvarvc-sign TO ls_r_knttp-sign,
          ls_tvarvc-opti TO ls_r_knttp-option,
          ls_tvarvc-low  TO ls_r_knttp-low,
          ls_tvarvc-high TO ls_r_knttp-high.
    APPEND ls_r_knttp TO r_t_range_knttp.

  ENDSELECT.

ENDMETHOD.
METHOD __GET_BSTAE_MTART_RANGE.

**********************************************************************
* Parámetros locales
**********************************************************************

****** CONSTANTS

  CONSTANTS: lc_tvarvc_bstae_mtart TYPE rvari_vnam VALUE 'ZMM_PO_BSTAE_MTART'.

****** STRUCTURES

  DATA: ls_tvarvc  TYPE tvarvc,
        ls_r_mtart TYPE range_s_mtart.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET RANGE

  "Obtengo parámetros BSTAE para MTART
  SELECT *
    FROM tvarvc
    INTO CORRESPONDING FIELDS OF @ls_tvarvc
   WHERE name EQ @lc_tvarvc_bstae_mtart.

    CLEAR: ls_r_mtart.
    MOVE: ls_tvarvc-sign TO ls_r_mtart-sign,
          ls_tvarvc-opti TO ls_r_mtart-option,
          ls_tvarvc-low  TO ls_r_mtart-low,
          ls_tvarvc-high TO ls_r_mtart-high.
    APPEND ls_r_mtart TO r_t_range_mtart.

  ENDSELECT.

ENDMETHOD.
METHOD __GET_T163LV_BSTAE_VALUE.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  SELECT SINGLE bstae
    FROM t163lv
    INTO @r_bstae
   WHERE bstyp EQ @i_bstyp
     AND bsart EQ @i_bsart
     AND werks EQ @i_werks
     AND lgort EQ @i_lgort.

ENDMETHOD.
METHOD _determine_bstae_value.

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_expected_bstae TYPE bstae,
        lv_must_clear     TYPE boolean,
        lv_has_changed    TYPE boolean,
        lv_bstae          TYPE bstae.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** MOVE BSTAE 2 WORK VARIABLE

  MOVE i_mepoitem-bstae TO lv_bstae.

***** GET STANDARD BSTAE VALUE

  "Obtenemos valor esperado de BSTAE según parametrización
  lv_expected_bstae = me->__get_t163lv_bstae_value( i_bstyp = i_mepoheader-bstyp i_bsart = i_mepoheader-bsart i_werks = i_mepoitem-werks i_lgort = i_mepoitem-lgort ).

***** CHECK MUST CLEAR BSTAE

  "Si hay que borrarlo, modificamos el valor esperado de BSTAE
  IF ( me->__check_if_bstae_must_clear( i_mepoitem = i_mepoitem ) EQ abap_true ).
    CLEAR: lv_expected_bstae.
  ENDIF.

***** HAS CHANGED?

**** BSTAE VALUE

  IF ( me->gv_trtyp EQ 'V' ). "Solo podemos tener la seguridad con trtyp modificación

    "Vemos si cambia BSTAE
    IF ( lv_bstae NE me->_bstae_last_value ).
      MOVE lv_bstae   TO me->_bstae_last_value.
      MOVE abap_true  TO lv_has_changed.
    ENDIF.

**** KNTTP VALUE

    "Vemos si cambia el tipo de imputación
    IF ( i_mepoitem-knttp NE me->_knttp_last_value ).
      MOVE i_mepoitem-knttp   TO me->_knttp_last_value.
      MOVE lv_expected_bstae  TO lv_bstae.
      MOVE abap_true          TO lv_has_changed.
    ENDIF.

****** SET VALUE

    "Comprobamos si ha cambiado BSTAE o KNTTP
    IF ( lv_has_changed EQ abap_true ). "Ha cambiado

      "Compruebo si ha cambiado al valor esperado
      IF ( lv_bstae EQ lv_expected_bstae ). "Ha cambiado a valor esperado

        "Reseteo valores a esperados
        MOVE: lv_expected_bstae TO r_bstae,
              lv_expected_bstae TO me->_bstae_last_value,
              '9999'            TO me->_bstae_user_value.
        EXIT.

      ELSE. "No ha cambiado a valor esperado

        "Es un cambio de usuario
        MOVE: lv_bstae TO r_bstae,
              lv_bstae TO me->_bstae_last_value,
              lv_bstae TO me->_bstae_user_value.

      ENDIF.

    ELSE. "No ha cambiado

      "Compruebo si se ha mantenido el valor esperado respecto al actual
      IF ( lv_bstae EQ lv_expected_bstae ).

        "Reseteo valores a esperados
        MOVE: lv_expected_bstae TO r_bstae,
              lv_expected_bstae TO me->_bstae_last_value,
              '9999'   TO me->_bstae_user_value.

      ELSE. "No se ha mantenido, se hizo una modificación manual

        "Movemos valores de usuario
        MOVE: lv_bstae TO r_bstae,
              lv_bstae TO me->_bstae_last_value,
              lv_bstae TO me->_bstae_user_value.

      ENDIF.

    ENDIF.

  ELSE. "Con creación siempre asignamos el esperado.

    MOVE: lv_expected_bstae TO r_bstae,
          lv_expected_bstae TO me->_bstae_last_value.

  ENDIF.


ENDMETHOD.
  METHOD if_ex_me_process_po_cust~check.

    DATA: ls_mepoheader TYPE mepoheader,
          lt_items      TYPE purchase_order_items,
          ls_item       TYPE purchase_order_item,
          lr_item       TYPE REF TO if_purchase_order_item_mm,
          ls_item_data  TYPE mepoitem,
          ls_item_inic  TYPE mepoitem,
          ls_mepo_eipo  TYPE mepo_eipo,
          lv_dummy      TYPE c LENGTH 128,
          lv_week01     TYPE scal-week,
          lv_week02     TYPE scal-week,
          lv_knttp      TYPE knttp.

    INCLUDE mm_messages_mac. "useful macros for message handling


*--> GAP MM013 - Obligar en Pedido Interco causa de retraso
    ls_mepoheader = im_header->get_data( ).

* EDIEGO 20/02/2017 -->
* Control segunda calidad
    IF  ls_mepoheader-bsart EQ 'ZINT'.
*     Controlamos que esté en la tabla o que sea blanco
      SELECT SINGLE * FROM ztsd0004 INTO @DATA(ls_ztsd0004)
        WHERE zzsegal = @ls_mepoheader-zzsegcal.
      IF ls_mepoheader-zzsegcal NE '' AND sy-subrc NE 0.
        ch_failed = 'X'.
*       El Cod.Calidad solo puede ser Primera/Blanco o Segunda/2.
        MESSAGE e135(zmm).
        mmpur_message_forced sy-msgty sy-msgid sy-msgno
                             sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        EXIT.
      ENDIF.
    ENDIF.
* EDIEGO 20/02/2017 <--

* >>>  7000010344 indicadores iva pedidos de activos fijo
*
    lt_items = im_header->get_items( ).
*
    LOOP AT lt_items INTO ls_item.
      ls_item_data = ls_item-item->get_data( ).

* ini 16.07.2018 - cvivo - Proyecto WM - Papel pre-impreso (se pone aquí y no en PROCESS_ITEM porque la modificación de este campo Z no llama a ese método)
      lr_item ?= ls_item-item.

*APC20250212 Error si material bloqueado
      IF ls_item_data-zzcrear_of = 'X' AND
        ( ls_mepoheader-bsart EQ 'ZPT4' OR ls_mepoheader-bsart EQ 'ZPE1' ).

        "Recuperamos el custo de la tabla ZZTMM0050
        DATA(util) = NEW zsmm_utils( ).
        DATA: l_ekko TYPE ekko,
              l_ekpo TYPE ekpo.

        MOVE-CORRESPONDING ls_mepoheader TO l_ekko.
        MOVE-CORRESPONDING ls_item_data TO l_ekpo.
        util->cumple_criterios_subco(
          EXPORTING
            i_ebeln          =  ls_item_data-ebeln
            i_ebelp          =  ls_item_data-ebelp
            i_structure_ekpo =  l_ekpo
            i_structure_ekko =  l_ekko
          IMPORTING
            o_aplica         = DATA(aplica)
        ).
        IF aplica = 'X'.
          SELECT SINGLE matnr FROM marc
            INTO ls_item_data-matnr
           WHERE matnr = ls_item_data-matnr
             AND werks = ls_item_data-werks
             AND mmsta = 'Z4'.
          IF sy-subrc = 0.
            ch_failed = 'X'.
            MESSAGE e190(zmm) WITH ls_item_data-matnr INTO lv_dummy. "Material bloqueado para fabricar'
            mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

            zcl_ap_popup=>informar( titulo = 'Aviso material bloqueado'
                                    texto1 = condense( |El material { ls_item_data-matnr alpha = out } está bloqueado para fabricar| )
                                    texto2 = 'Quítelo del pedido o desmarque la creación de OF' ).

          ENDIF.
        ENDIF.
      ENDIF.

*APC20241214 Validamos que informe pedido de cliente si flag de crear OT marcado
      IF ls_item_data-zzcrear_of = 'X' AND ls_item_data-zzcliente IS INITIAL
        AND ls_item_data-loekz IS INITIAL AND ls_item_data-zzaufnr IS INITIAL
        AND ls_mepoheader-bsart NE 'ZPE2'.
        DATA(l_validar) = ''.
        IF NOT ls_mepoheader-ebeln IS INITIAL.
          SELECT SINGLE ebeln FROM ekpo
            INTO ls_mepoheader-ebeln
           WHERE ebeln = ls_mepoheader-ebeln
             AND ebelp = ls_item_data-ebelp.
          IF sy-subrc = 0.
            l_validar = 'X'.
          ENDIF.
        ENDIF.
        IF l_validar = 'X' . "Sólo en creación de posicion
          IF zcl_ap_exits=>exit_activa( 'ME21_PED_SUBCO_CLIENTE_OBLIGATORIO' ).
            ch_failed = 'X'.
            MESSAGE e191(zmm) WITH ls_item_data-matnr INTO lv_dummy. "Ha marcado crear OF en posición &. Informe cliente.
            mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.
      ENDIF.


      SELECT SINGLE @abap_true FROM tvarvc
        WHERE name EQ 'ZMM_ORDEN_IMP'
          AND low EQ @ls_item_data-werks
          AND high EQ @ls_item_data-mtart
        INTO @DATA(result).

      IF sy-subrc EQ 0. " en pre-impreso, hay que indicar la orden de impresión, para integrarla
        IF ls_item_data-zzorden_imp IS INITIAL.
          ch_failed = 'X'.
          mmpur_context 901.
          mmpur_business_obj_id ls_item_data-id.
          MESSAGE e149(zmm) WITH ls_item_data-ebelp
                            INTO lv_dummy.
          mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSE.
          mmpur_remove_msg_by_context ls_item_data-id 901.
        ENDIF.
      ENDIF.
* fin 16.07.2018 - cvivo - Proyecto WM

      CHECK ls_item_data-loekz IS INITIAL
        AND ls_item_data-mwskz IS NOT INITIAL.

      SELECT SINGLE knttp INTO lv_knttp FROM ztmm0014
                          WHERE knttp = ls_item_data-knttp.
      CASE sy-subrc.
        WHEN 0.
          SELECT SINGLE knttp INTO lv_knttp FROM ztmm0014
                              WHERE knttp = ls_item_data-knttp
                                AND mwskz = ls_item_data-mwskz.
          IF sy-subrc NE 0.
            ch_failed = 'X'.
* La posición de pedido &/& tiene un indicador de impuestos & no permitido
            MESSAGE e113(zmm) WITH ls_item_data-ebelp
                                   ls_item_data-ebelp
                                   ls_item_data-mwskz INTO lv_dummy.
            mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        WHEN OTHERS.
          SELECT SINGLE knttp INTO lv_knttp FROM ztmm0014
                              WHERE mwskz = ls_item_data-mwskz.
          IF sy-subrc EQ 0.
            ch_failed = 'X'.
* La posición de pedido &/& tiene un indicador de impuestos & no permitido
            MESSAGE e113(zmm) WITH ls_item_data-ebelp
                                      ls_item_data-ebelp
                                      ls_item_data-mwskz INTO lv_dummy.
            mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.

      ENDCASE.
    ENDLOOP.
*
    IF ls_mepoheader-bsart = 'ZINT'.
* <<<  7000010344 indicadores iva pedidos de activos fijo

      LOOP AT lt_items INTO ls_item.
        ls_item_data = ls_item-item->get_data( ).
* motivo de devoucion
        IF ls_item_data-retpo = 'X'.
          IF ls_item_data-zzaugru IS INITIAL.
            ch_failed = 'X'.
            MESSAGE e021(zmm) WITH ls_item_data-ebelp INTO lv_dummy.
            mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.
* causa de retraso si la fecha de entrega pasa a la semana siguiente
        CLEAR ls_item_inic.
        READ TABLE gt_items INTO ls_item_inic WITH KEY ebelp = ls_item_data-ebelp.
        IF sy-subrc = 0 AND ls_item_data-eindt GT ls_item_inic-eindt.
          CALL FUNCTION 'GET_WEEK_INFO_BASED_ON_DATE'
            EXPORTING
              date = ls_item_data-eindt
            IMPORTING
              week = lv_week02.
          CALL FUNCTION 'GET_WEEK_INFO_BASED_ON_DATE'
            EXPORTING
              date = ls_item_inic-eindt
            IMPORTING
              week = lv_week01.
          IF lv_week01 NE lv_week02.
            IF ls_item_data-zzcausa_retraso IS INITIAL OR
               ls_item_data-zzcausa_retraso EQ ls_item_inic-zzcausa_retraso.
              ch_failed = 'X'.
              MESSAGE e020(zmm) WITH ls_item_data-ebelp INTO lv_dummy.
              mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                   sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
          ENDIF.

        ENDIF.

* CMS 01/04/2020 Recuperamos los repartos modificados y comprobaremos si ya existe orden creada asociada a ese Pedido/Posición/Reparto.
        DATA: lw_cambio_reparto TYPE flag.
        IF ls_mepoheader-lifnr(3) = 'P30'. " Esta validación aplicará solo a proveedores Hinojosa Paper

          DATA(lo_repartos) = ls_item-item->get_schedules( ).

          LOOP AT lo_repartos INTO DATA(ls_reparto).

            CLEAR: lw_cambio_reparto.
            DATA(ls_datos_reparto) = ls_reparto-schedule->get_data( ).

* Se valida si han habido modificaciones.
            TRY.
                CALL METHOD ls_reparto-schedule->get_persistent_data
                  IMPORTING
                    ex_data = DATA(ls_datos_rep_old)
                  EXCEPTIONS
                    no_data = 1
                    OTHERS  = 2.
                IF sy-subrc <> 0.
                  CONTINUE.
                ENDIF.
                IF  ls_datos_rep_old-menge <> ls_datos_reparto-menge OR
                    ls_datos_rep_old-eeind <> ls_datos_reparto-eeind.
                  lw_cambio_reparto = 'X'.
                ELSE.
                  lw_cambio_reparto = ' '.
                  CONTINUE.
                ENDIF.
              CATCH cx_root .
                lw_cambio_reparto = ' '.
                CONTINUE.
            ENDTRY.

            CHECK lw_cambio_reparto = 'X'.

            SELECT SINGLE  a~aufnr    INTO @DATA(l_of)
              FROM aufk AS a
              INNER JOIN jest AS b ON b~objnr = a~objnr
              INNER JOIN afpo AS c ON a~aufnr = c~aufnr
              WHERE a~auart     = 'ZI02'                              AND
                    (
                       (  a~zzebeln1  = @ls_datos_reparto-ebeln       AND
                          a~zzebelp1  = @ls_datos_reparto-ebelp       AND
                          a~zzurgt1   = @ls_datos_reparto-etenr ) OR
                       (  a~zzebeln2  = @ls_datos_reparto-ebeln       AND
                          a~zzebelp2  = @ls_datos_reparto-ebelp       AND
                          a~zzurgt2   = @ls_datos_reparto-etenr ) OR
                       (  a~zzebeln3  = @ls_datos_reparto-ebeln       AND
                          a~zzebelp3  = @ls_datos_reparto-ebelp       AND
                          a~zzurgt3   = @ls_datos_reparto-etenr )
                     )
                      AND
                    ( ( b~stat = 'I0001' AND b~inact = @space ) OR       "Abierta
                      ( b~stat = 'I0002' AND b~inact = @space ) OR       " Liberada
                      ( b~stat = 'I0045' AND b~inact = @space AND c~wemng <> 0 ) " CTEC y KG <>0
                    ).
            IF sy-subrc = 0.
              MESSAGE w176(zmm) WITH ls_datos_reparto-ebelp ls_datos_reparto-etenr l_of .
              mmpur_message_forced sy-msgty sy-msgid sy-msgno
                                   sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.

          ENDLOOP.

        ENDIF.

      ENDLOOP.
    ENDIF.
*<-- GAP MM013

**---------------------------------------------------------------------- " cvivo 56053- Se desactiva pues ya no es editable en pedido
**   INI CGIJON - 05.12.18 - SAT 7000022889 Ticket51984
**    DATA: lv_zterm1 TYPE dzterm.
*    DATA: lv_zterm2 TYPE dzterm.
*
*    SELECT SINGLE zterm FROM lfm1
*      INTO lv_zterm2
*      WHERE lifnr = ls_mepoheader-lifnr AND
*            ekorg = ls_mepoheader-ekorg.
*
*    IF lv_zterm2 <> ls_mepoheader-zterm.
**      ch_failed = 'X'. " corregido, no debe marcarse, si no no deja grabar - CVIVO
**     La clave de condiciones de pago debería ser &
*      MESSAGE w166(zmm) WITH ls_mepoheader-zterm lv_zterm2 INTO lv_dummy.
**      MESSAGE w166(zmm) WITH lv_zterm  DISPLAY LIKE 'I' .
*      mmpur_message_forced sy-msgty sy-msgid sy-msgno
*                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*    ENDIF.
**   FIN CGIJON - 05.12.18 - SAT 7000022889 Ticket51984
**----------------------------------------------------------------------

** ini 2.12.2019 - cvivo - 53744 FSC - > descartado, se deja en PROCESS_ITEM; el SET DATA aquí no funciona ni el método POST
*    LOOP AT lt_items INTO ls_item.
*      ls_item_data = ls_item-item->get_data( ).
*      lr_item ?= ls_item-item.
*
** Recuperamos valores de certificación del proveedor
*      CALL FUNCTION 'ZMM_CERTIFICACION_FSC_MATERIAL'
*        EXPORTING
*          lifnr              = ls_mepoheader-lifnr
*          matnr              = ls_item_data-matnr
*        IMPORTING
*          fsc                = ls_item_data-zzfsc
*          codigo_certificado = ls_item_data-zzcod_fsc
*          declaracion_fsc    = ls_item_data-zzdecla_fsc
*          porcentaje_fsc     = ls_item_data-zzporcent_fsc.
*
*      CALL METHOD lr_item->set_data
*        EXPORTING
*          im_data = ls_item_data.
*    ENDLOOP.
** fin 2.12.2019 - cvivo - 53744 FSC

* ini cvivo - 04.03.2020 - 59678 validar cond.pago actual
    " mod - cvivo - 60703 Validar condición de pago
    DATA: objeto(11).

    IF gv_trtyp EQ 'H' OR gv_trtyp EQ 'V'. " si creando o modificando

      " 61507 - cvivo - Excepciones a la validación
      SELECT SINGLE @abap_true FROM tvarvc
        WHERE name EQ 'ZMM_ZTERM_EXCEPT'
          AND low EQ @sy-uname
        INTO @DATA(exclude).

      IF ls_mepoheader-lifnr IS NOT INITIAL AND ls_mepoheader-zterm IS NOT INITIAL AND ls_mepoheader-ekorg IS NOT INITIAL
        AND exclude IS INITIAL.
        CLEAR ls_item_data.
        LOOP AT lt_items INTO ls_item.
          ls_item_data = ls_item-item->get_data( ).
          IF ls_item_data-knttp EQ 'A'.
            DATA(lv_check) = 'X'.
          ENDIF.
          IF ls_item_data-werks IS INITIAL.
            CLEAR ls_item_data.
          ENDIF.
        ENDLOOP.

        IF lv_check IS INITIAL." en activos no validamos cond.pago.
          IF ls_item_data IS NOT INITIAL. " cond.del centro
            SELECT SINGLE zterm FROM lfm2
            INTO @DATA(l_zterm)
                  WHERE lifnr EQ @ls_mepoheader-lifnr
                  AND werks EQ @ls_item_data-werks
                  AND ekorg EQ @ls_mepoheader-ekorg.

            objeto = 'centro'.
          ENDIF.
          IF l_zterm IS INITIAL. " no hay de centro, cogemos org.compras
            SELECT SINGLE zterm FROM lfm1
            INTO l_zterm
            WHERE lifnr EQ ls_mepoheader-lifnr
            AND ekorg EQ ls_mepoheader-ekorg.

            objeto = 'org.compras'.
          ENDIF.
          IF l_zterm NE ls_mepoheader-zterm
          AND l_zterm IS NOT INITIAL. " por si acaso está mal el código
            CALL METHOD im_header->invalidate( ).

            mmpur_metafield mmmfd_pmnttrms.
            mmpur_message_forced 'E' 'ZMM' '175' l_zterm objeto space space.
          ELSE.
            mmpur_remove_msg_by_context ls_mepoheader-id mmmfd_pmnttrms.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    IF 1 = 2.
    ENDIF.
* fin cvivo - 04.03.2020 - 59678 validar cond.pago actual


  ENDMETHOD.
  METHOD if_ex_me_process_po_cust~close.

    DATA lw_mepoheader TYPE mepoheader.
    DATA lt_mepoitems_r TYPE purchase_order_items. "Tabla de referencias OO a posiciones
    DATA lw_mepoitem_r TYPE purchase_order_item.  "Referencia OO a posición
    DATA lt_mepoitems TYPE tab_mepoitem.         "Tabla de posiciones
    DATA lw_mepoitem TYPE mepoitem.             "Datos de posición
    DATA: ex_data       TYPE mepoheader,
          re_persistent TYPE mmpur_bool.

    lw_mepoheader   = im_header->get_data( ).
    lt_mepoitems_r  = im_header->get_items( ).
    re_persistent = im_header->is_persistent( ).
    im_header->get_persistent_data( IMPORTING ex_data = ex_data
                                    EXCEPTIONS no_data = 1 ).

** ini 6.03.2020 - cvivo - 53744 FSC ---> DEL 16.0.2020 cvivo - Se migra a Enhancement ZMM_FSC_PEDIDOS
*    " Los datos FSC se calculan en PROCESS_ITEM porque es info de posición de pedido y en el método POST no permite modificar y tampoco tenemos
*    " el no. de pedido para lanzar el JOB
*    IF gv_fsc IS INITIAL AND lw_mepoheader-ebeln NE space AND gv_trtyp EQ 'H' AND
*      ( lw_mepoheader-bsart EQ 'ZINT' OR lw_mepoheader-bsart EQ 'ZPE1' ).
*      DATA: number           TYPE tbtcjob-jobcount,
*            name             TYPE tbtcjob-jobname,
*            print_parameters TYPE pri_params.
*      DATA: lt_seltab TYPE TABLE OF rsparams,
*            ls_seltab LIKE LINE OF lt_seltab.
*
*      ls_seltab-selname = 'S_EBELN'.
*      ls_seltab-kind    = 'S'.
*      ls_seltab-sign    = 'I'.
*      ls_seltab-option  = 'EQ'.
*      ls_seltab-low     = lw_mepoheader-ebeln.
*      APPEND ls_seltab TO lt_seltab.
*
*      IF lw_mepoheader-ebeln NA '123456789'.
*        MESSAGE 'Error en FSC' TYPE 'X'.
*      ENDIF.
*
*      CONCATENATE 'FSC_' lw_mepoheader-ebeln INTO name. " lo hacemo en JOB porque la documentación prohíbe hacer COMMITS
*
*      CALL FUNCTION 'JOB_OPEN'
*        EXPORTING
*          jobname          = name
*        IMPORTING
*          jobcount         = number
*        EXCEPTIONS
*          cant_create_job  = 1
*          invalid_job_data = 2
*          jobname_missing  = 3
*          OTHERS           = 4.
*
*      IF sy-subrc = 0.
*        SUBMIT zrmm0026 TO SAP-SPOOL
*        SPOOL PARAMETERS print_parameters
*        WITHOUT SPOOL DYNPRO
*        WITH SELECTION-TABLE lt_seltab
*        VIA JOB name NUMBER number
*        AND RETURN.
*
*        IF sy-subrc = 0.
*          CALL FUNCTION 'JOB_CLOSE'
*            EXPORTING
*              jobcount             = number
*              jobname              = name
*              strtimmed            = 'X'
*            EXCEPTIONS
*              cant_start_immediate = 1
*              invalid_startdate    = 2
*              jobname_missing      = 3
*              job_close_failed     = 4
*              job_nosteps          = 5
*              job_notex            = 6
*              lock_failed          = 7
*              OTHERS               = 8.
*        ENDIF.
*      ENDIF.
*    ENDIF.
*
** fini 6.03.2020 - cvivo - 53744 FSC

  ENDMETHOD.
  METHOD if_ex_me_process_po_cust~fieldselection_header.
    DATA: l_persistent  TYPE mmpur_bool,
          lv_changeable TYPE mmpur_bool.

    FIELD-SYMBOLS: <fs> LIKE LINE OF ch_fieldselection.

    DATA: ls_mepoheader     TYPE mepoheader,
          ls_fieldselection LIKE LINE OF ch_fieldselection.

* ATENCIÓN: la BAdI sólo funciona para campos Z, los estándar no aparecen nunca en CH_fielselection,
    " y de nada sirve añadirlo a la tabla interna

*   Obtenemos datos de cabecera
    ls_mepoheader = im_header->get_data( ).

*   Is PO changeable?
    lv_changeable = im_header->is_changeable( ).

    READ TABLE ch_fieldselection ASSIGNING <fs> WITH TABLE KEY metafield = mmmfd_cust_01.
    IF sy-subrc IS INITIAL.
*      IF ls_mepoheader-bsart NE 'ZINT'.
*        CLEAR <fs>-fieldstatus.
*      ELSE
*      Informamos siempre que no se puede editar
      <fs>-fieldstatus = '*'.
      " Input 
      "'*' Field is purely a display field
      "'.' INPUT FIELD


      IF ls_mepoheader-bsart EQ 'ZINT' AND lv_changeable IS NOT INITIAL.
        <fs>-fieldstatus = '+'. " Input
      ENDIF.
    ENDIF.

    " cvivo - 57924
    READ TABLE ch_fieldselection ASSIGNING <fs> WITH TABLE KEY metafield = mmmfd_cust_02. " no imprimir repartos
    IF sy-subrc IS INITIAL.
      IF lv_changeable IS INITIAL.
        <fs>-fieldstatus = '*'. " display
      ELSE.
        <fs>-fieldstatus = '+'. " Input
      ENDIF.
    ENDIF.


*    DATA lv_changeable TYPE mmpur_bool.
*    DATA ls_mepoitem TYPE mepoitem.
*    DATA ls_mepoheader TYPE mepoheader.
*    DATA lv_status(1).
*    FIELD-SYMBOLS: <fs> LIKE LINE OF ch_fieldselection.
*
** Is PO changeable?
*    lv_changeable = im_header->is_changeable( ).
*
** Obtenemos los datos de la posición
*    ls_mepoitem  = im_item->get_data( ).
*
*    IF lv_changeable IS INITIAL.
*      lv_status = '*'. " Display
*    ELSE.
*      lv_status = '+'. " Input
*    ENDIF.
  ENDMETHOD.
  method IF_EX_ME_PROCESS_PO_CUST~FIELDSELECTION_HEADER_REFKEYS.
  endmethod.
  METHOD if_ex_me_process_po_cust~fieldselection_item.

    DATA lv_changeable TYPE mmpur_bool.
    DATA ls_mepoitem TYPE mepoitem.
    DATA ls_mepoheader TYPE mepoheader.
    DATA lv_status(1).
    FIELD-SYMBOLS: <fs> LIKE LINE OF ch_fieldselection.

* Is PO changeable?
    lv_changeable = im_header->is_changeable( ).

* Obtenemos los datos de la posición
    ls_mepoitem  = im_item->get_data( ).

    IF lv_changeable IS INITIAL.
      lv_status = '*'. " Display
    ELSE.
      lv_status = '+'. " Input
    ENDIF.

*---------------------------------------------------------------------*
* read customer data
*---------------------------------------------------------------------*
    ls_mepoheader = im_header->get_data( ).

    IF ls_mepoheader-bsart = 'ZINT'.
      LOOP AT ch_fieldselection ASSIGNING <fs>
        WHERE metafield BETWEEN mmmfd_cust_01 AND mmmfd_cust_03.
        CASE <fs>-metafield.
* Motivo de rechazo no sale en alta
          WHEN mmmfd_cust_02.
            IF gv_trtyp = 'H'.
              <fs>-fieldstatus = '-'.  " Invisible
            ELSE.
              <fs>-fieldstatus = lv_status.
            ENDIF.
          WHEN mmmfd_cust_03.
            IF ls_mepoitem-retpo = 'X'.
* Devolucion solo en devolucion
              <fs>-fieldstatus = lv_status.
            ELSE.
              <fs>-fieldstatus = '-'.  " Invisible
            ENDIF.
* Bloqueo Planificación
          WHEN mmmfd_cust_04.
            IF gv_trtyp = 'H'.
              <fs>-fieldstatus = '-'.  " Invisible
            ELSE.
              <fs>-fieldstatus = lv_status.
            ENDIF.

          WHEN OTHERS.
            <fs>-fieldstatus = lv_status.
        ENDCASE.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  method IF_EX_ME_PROCESS_PO_CUST~FIELDSELECTION_ITEM_REFKEYS.
  endmethod.
  METHOD if_ex_me_process_po_cust~initialize.

    FREE gt_pos_modif.

  ENDMETHOD.
  METHOD if_ex_me_process_po_cust~open.

    DATA: ls_mepoheader TYPE mepoheader,
          lt_items      TYPE purchase_order_items,
          ls_item       TYPE purchase_order_item,
          ls_item_data  TYPE mepoitem.

    CLEAR gt_items.
    free gt_pos_modif.
    gv_trtyp = im_trtyp.

    CLEAR gv_fsc.

* this has to be done when we open a persistent object
    CHECK im_trtyp EQ 'V' OR im_trtyp EQ 'A'.

*--> GAP MM013 - Obligar en Pedido Interco causa de retraso
    ls_mepoheader = im_header->get_data( ).

    gv_lifnr = ls_mepoheader-lifnr.

    CHECK ls_mepoheader-bsart = 'ZINT'.

    lt_items = im_header->get_items( ).

    LOOP AT lt_items INTO ls_item.
      ls_item_data = ls_item-item->get_data( ).
      APPEND ls_item_data TO gt_items.
    ENDLOOP.
*<-- GAP MM013

  ENDMETHOD.
  METHOD if_ex_me_process_po_cust~post.

    INCLUDE mm_messages_mac. "useful macros for message handling

    DATA: rg_semis TYPE RANGE OF mtart.
    CONSTANTS c_semi TYPE rvari_vnam VALUE 'ZSPP_UPD_MTART_SEM'.

    DATA return TYPE bapiret2.
    DATA e_subrc TYPE sysubrc.
    DATA lw_mepoheader TYPE mepoheader.
    DATA lt_mepoitems_r TYPE purchase_order_items. "Tabla de referencias OO a posiciones
    DATA lw_mepoitem_r TYPE purchase_order_item.  "Referencia OO a posición
    DATA lt_mepoitems TYPE tab_mepoitem.         "Tabla de posiciones
    DATA lw_mepoitem TYPE mepoitem.             "Datos de posición
    DATA lt_meposched TYPE tab_meposchedule.
    DATA lw_meposched TYPE meposchedule.
    DATA lt_meposched_r TYPE purchase_order_schedules.
    DATA lw_meposched_r TYPE purchase_order_schedule.

* ini fcardona - 26.10.2020 - 63553 Aviso en creación de pedidos via de pago en desuso (Pagaré)
    CONSTANTS: lc_dzwels_p TYPE dzwels VALUE 'P'. "Vía de pago (P --> Pagaré)

    DATA: lo_bcs          TYPE REF TO cl_bcs,
          lo_document_bcs TYPE REF TO cl_document_bcs,
          lx_document_bcs TYPE REF TO cx_document_bcs,
          lo_sender       TYPE REF TO if_sender_bcs VALUE IS INITIAL,
          lx_address_bcs  TYPE REF TO cx_address_bcs,
          lo_recipient    TYPE REF TO if_recipient_bcs,
          lx_send_req_bcs TYPE REF TO cx_send_req_bcs,
          lt_body_text    TYPE bcsy_text,
          ls_body_text    LIKE LINE OF lt_body_text,
          lv_mail_subject TYPE  so_obj_des,
          lv_listadistrib TYPE so_obj_nam,
          lv_lifnr(10)    TYPE c,
          lv_ebeln(10)    TYPE c.
* fin fcardona - 26.10.2020 - 63553

    lw_mepoheader   = im_header->get_data( ).
    lt_mepoitems_r  = im_header->get_items( ).

* Para pasar a la función una tabla con las posiciones, debemos tratar la estructura LW_MEPOITEMS.
    LOOP AT lt_mepoitems_r INTO lw_mepoitem_r.
      lw_mepoitem = lw_mepoitem_r-item->get_data( ).
      APPEND lw_mepoitem TO lt_mepoitems.

      CLEAR lw_mepoitem.

* Obtenemos también los repartos.
      lt_meposched_r = lw_mepoitem_r-item->get_schedules( ).

      LOOP AT lt_meposched_r INTO lw_meposched_r.
        lw_meposched = lw_meposched_r-schedule->get_data( ).
        APPEND lw_meposched TO lt_meposched.
        CLEAR lw_meposched.
      ENDLOOP.
    ENDLOOP.

    CALL FUNCTION 'Z_MM_AVISO_MOD_PED_INTERC'
      EXPORTING
        mepoheader    = lw_mepoheader
        mepoitems     = lt_mepoitems
        meposchedules = lt_meposched
*     IMPORTING
*       RETURN        = RETURN
*       E_SUBRC       = E_SUBRC
      .

* ini fcardona - 26.10.2020 - 63553 Aviso en creación de pedidos via de pago en desuso (Pagaré)

    "Comprobamos:
    " - Tipo de modificación es: 'H' --> Creación o 'V' --> Modificación
    " - Proveedor se ha informado
    " - Sociedad se ha informado
    IF ( ( gv_trtyp EQ 'H' OR gv_trtyp EQ 'V' )
      AND lw_mepoheader-lifnr IS NOT INITIAL
      AND lw_mepoheader-bukrs IS NOT INITIAL ).

      "Seleccionamos sí vía de pago = 'P' --> Pagaré
      SELECT SINGLE @abap_true
        FROM lfb1
        WHERE lifnr EQ @lw_mepoheader-lifnr
          AND loevm EQ @space
          AND bukrs EQ @lw_mepoheader-bukrs
          AND zwels EQ @lc_dzwels_p
        INTO @DATA(check).

      "Se cumple selección
      IF sy-subrc EQ 0. "Enviamos correo

        ""Correo
        "" - Asunto
        "" - Cuerpo
        "" - Remitente
        "" - Destinatario
        "" - Envío
        TRY .

            "Creamos el objeto para manejar el correo
            lo_bcs = cl_bcs=>create_persistent( ).

            "Asunto
            lv_mail_subject = 'Mensaje automático: Proveedor con vía pago Pagaré'.

            WRITE lw_mepoheader-lifnr TO lv_lifnr NO-ZERO.
            WRITE im_ebeln TO lv_ebeln NO-ZERO.

            "Cuerpo
            CLEAR: ls_body_text.
            CONCATENATE 'En el pedido' lv_ebeln 'se ha utilizado el proveedor' lv_lifnr 'con vía de pago P (Pagaré).'
            'Se ha mostrado mensaje de aviso solicitando certificado bancario y su envío a Administración Grupo.' INTO ls_body_text-line SEPARATED BY space.
            APPEND ls_body_text TO lt_body_text.

            "Creamos el documento
            lo_document_bcs = cl_document_bcs=>create_document(
              i_type          = 'HTM'
              i_subject       = lv_mail_subject
*            i_importance    = '1' "Comentamos por no recibirlos con importancia alta. Posteriormente podemos ajustar en lista de distribución.
              i_text          = lt_body_text ).

            "Lo insertamos en el correo
            lo_bcs->set_document( lo_document_bcs ).

            "Remitente
            lo_sender = cl_sapuser_bcs=>create( sy-uname ). "remitente --> usuario que crea el pedido
            lo_bcs->set_sender( EXPORTING i_sender = lo_sender ).

            "Destinatario
            SELECT SINGLE *
              FROM tvarvc
              WHERE name EQ 'ZLISTA_DISTRIBUCION_PAGARE'
              INTO @DATA(tvarvc).

            MOVE tvarvc-low TO lv_listadistrib.

            lo_recipient = cl_distributionlist_bcs=>getu_persistent(
              i_dliname = lv_listadistrib
              i_private = abap_false ).

            lo_bcs->add_recipient(
              EXPORTING
              i_recipient = lo_recipient
              i_express = 'X' ).

            "Envío
            CALL METHOD lo_bcs->set_send_immediately
              EXPORTING
                i_send_immediately = abap_true.

            lo_bcs->send(
              EXPORTING
              i_with_error_screen = 'X' ).

          CATCH cx_document_bcs INTO lx_document_bcs.
            "Error creando email.
            "lx_document_bcs->error_text.
          CATCH cx_address_bcs INTO lx_address_bcs.
            "Error en dirección
          CATCH cx_send_req_bcs INTO lx_send_req_bcs.
            "Error en envío
        ENDTRY.

      ENDIF.

    ENDIF.
*   fin fcardona - 26.10.2020 - 63553




    "JVM - Creación de OF desde pedido subco
    lt_mepoitems_r  = im_header->get_items( ).

    "Optimización

    "Agrupamos las posiciones del pedido y comprobamos si hay posiciones que cumplan el criterio, si no hay, no habrá que hacer nada
    DATA(wa_util) = NEW zsmm_utils( ).
    TYPES: BEGIN OF ty_ebeln_ebelp,
             ebeln TYPE ebeln,
             ebelp TYPE ebelp,
           END OF ty_ebeln_ebelp,
           tty_ebeln_ebelp TYPE SORTED TABLE OF ty_ebeln_ebelp WITH NON-UNIQUE KEY ebeln ebelp.
    DATA it_ebeln_ebelp TYPE tty_ebeln_ebelp.
    DATA wa_ebeln_ebelp TYPE ty_ebeln_ebelp.
    DATA: wa_ekpo_check TYPE ekpo,
          wa_ekko_check TYPE ekko.

    lt_mepoitems_r  = im_header->get_items( ).

    LOOP AT lt_mepoitems_r ASSIGNING FIELD-SYMBOL(<optim>).

      DATA(p_check) = <optim>-item->get_data( ).
      CLEAR: wa_ekpo_check, wa_ekko_check.

      DATA(wa_header_check) = im_header->get_data( ).
      MOVE-CORRESPONDING wa_header_check TO wa_ekko_check.
      MOVE-CORRESPONDING p_check TO wa_ekpo_check.

      IF wa_ekpo_check-ebeln IS INITIAL AND im_ebeln IS NOT INITIAL.
        wa_ekpo_check-ebeln = p_check-ebeln = wa_ekko_check-ebeln = im_ebeln.
      ENDIF.

      wa_util->cumple_criterios_subco(
        EXPORTING
          i_ebeln          = p_check-ebeln
          i_ebelp          = p_check-ebelp
          i_structure_ekpo = wa_ekpo_check
          i_structure_ekko = wa_ekko_check
        IMPORTING
*                o_caso           =     " Caso subco
          o_aplica         = DATA(aplica)
      ).

      "Si alguna posicion no cumple, la excluimos, si cumple la guardamos
      IF aplica IS NOT INITIAL.
        wa_ebeln_ebelp-ebeln = p_check-ebeln.
        wa_ebeln_ebelp-ebelp = p_check-ebelp.
        INSERT wa_ebeln_ebelp INTO TABLE it_ebeln_ebelp.
      ENDIF.
    ENDLOOP.

    IF it_ebeln_ebelp[] IS NOT INITIAL."Si ningún registro cumple, no enrtará por aquí

      DATA wa_pedipos TYPE zsppt_ofpedsubco.

      LOOP AT lt_mepoitems_r ASSIGNING FIELD-SYMBOL(<fs_pos>).
        DATA(p) = <fs_pos>-item->get_data( ).

        DATA: wa_ekpo TYPE ekpo,
              wa_ekko TYPE ekko.
        CLEAR aplica.

        DATA(wa_header) = im_header->get_data( ).
        MOVE-CORRESPONDING wa_header TO wa_ekko.
        MOVE-CORRESPONDING p TO wa_ekpo.

        "si no está marcada la creación de OF ignoramos
        IF p-zzcrear_of IS INITIAL.
          CONTINUE.
        ENDIF.

        IF p-ebeln IS INITIAL AND im_ebeln IS NOT INITIAL.
          p-ebeln = wa_ekko-ebeln = wa_ekpo-ebeln = im_ebeln.
        ENDIF.
        "Chequeamos si en las busquedas anteriores hemos encontrado aplicación del criterio
        READ TABLE it_ebeln_ebelp WITH KEY ebeln = wa_ekpo-ebeln ebelp = wa_ekpo-ebelp TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CONTINUE.
        ELSE.
          aplica = abap_true.
        ENDIF.


        DATA(rep) = <fs_pos>-item->get_schedules( ).
        LOOP AT rep INTO DATA(reparto).
          DATA(w_reparto) = reparto-schedule->get_data( ).
          EXIT.
        ENDLOOP.


        "Obtenemos los componentes de subco si corresponde
        DATA lt_bom_pos TYPE mmpur_t_mdpm.
        FREE lt_bom_pos.
        DATA(scd) = <fs_pos>-item->get_schedules( ).
        LOOP AT scd ASSIGNING FIELD-SYMBOL(<scd>).
          IF <scd>-schedule->get_data( )-loekz = 'L' OR <scd>-schedule->get_data( )-loekz = 'X'.
            CONTINUE.
          ENDIF.
          <scd>-schedule->get_bom(
            IMPORTING
              et_bom = DATA(it_bom)
          ).

          LOOP AT it_bom ASSIGNING FIELD-SYMBOL(<n>).
            DATA(lv_id) = sy-tabix.
            SELECT SINGLE mtart INTO @DATA(lv_mtart) FROM mara WHERE matnr = @<n>-matnr.
            IF lv_mtart NOT IN rg_semis.
              DELETE it_bom INDEX lv_id.
            ENDIF.
          ENDLOOP.

          APPEND LINES OF it_bom TO lt_bom_pos.
        ENDLOOP.
        IF sy-subrc <> 0 OR lt_bom_pos[] IS INITIAL.

          SELECT sign, opti, low, high INTO TABLE @rg_semis FROM tvarvc WHERE name EQ @c_semi.

          SELECT t1~matnr, werks, bdmng, bdter INTO TABLE @DATA(it_semis)
                  FROM resb AS t1 INNER JOIN mara AS t2 ON t1~matnr EQ t2~matnr
                  WHERE ebeln = @p-ebeln
                  AND ebelp = @p-ebelp
                  AND kzear = @space
                  AND t2~mtart IN @rg_semis.

          IF sy-subrc = 0.
            LOOP AT it_semis ASSIGNING FIELD-SYMBOL(<f>).
              APPEND INITIAL LINE TO lt_bom_pos ASSIGNING FIELD-SYMBOL(<bm>).
              <bm>-matnr = <f>-matnr.
              <bm>-bdmng = <f>-bdmng.
              <bm>-werks = <f>-werks.
              <bm>-bdter = <f>-bdter.
              <bm>-postp = 'L'.
            ENDLOOP.
          ENDIF.

        ENDIF.

        "Si tiene OF asignada, vemos si hay cambios para reflejarlos en la OF
        SELECT SINGLE t1~menge, CASE t3~mbdat WHEN '00000000' THEN t3~eindt ELSE t3~mbdat END AS bdter, t1~loekz
          FROM ekpo AS t1 INNER JOIN ekko AS t2
          ON t1~ebeln EQ t2~ebeln
          INNER JOIN eket AS t3 ON t1~ebeln EQ t3~ebeln AND t1~ebelp EQ t3~ebelp
          WHERE t1~ebeln = @wa_ekpo-ebeln
          AND t1~ebelp = @wa_ekpo-ebelp
          AND t1~loekz NOT IN ( 'L', 'X' ) "Borrado, si está bloqueado si que lo tomamos¿? Según nuria parece que si ya que no borra OF
          AND t3~etenr = ( SELECT MIN( etenr ) FROM eket WHERE eket~ebeln = t1~ebeln AND eket~ebelp = t1~ebelp )
          INTO @DATA(wa_bbdd).

        IF p-zzcrear_of IS INITIAL.
          CONTINUE.
        ENDIF.

        "Es de subcontratación, podría tener más de una OF
        IF lt_bom_pos[] IS INITIAL AND p-knttp = space."AND it_mdpmx[] IS INITIAL."Si no recupera no es de SUBCO, se crea por la línea, añadimos líena ficticia
          APPEND INITIAL LINE TO lt_bom_pos ASSIGNING FIELD-SYMBOL(<bom_pos>).
          <bom_pos>-matnr = p-matnr.
          <bom_pos>-bdmng = p-menge.
          <bom_pos>-werks = p-werks.
        ELSE.
          DELETE lt_bom_pos WHERE postp <> 'L'.
        ENDIF.

        DATA: i_ekpo_assembly TYPE TABLE OF ekpo.

        LOOP AT lt_bom_pos ASSIGNING <bom_pos>.

          IF ( p-loekz = 'L' OR p-loekz = 'X' ) AND ( wa_bbdd-loekz IS INITIAL OR wa_bbdd-loekz = 'S' ).
            "Borramos la OF
            "El borrado se realizará en el propio JOB
*            wa_util->borrar_of(
*              EXPORTING
*                i_aufnr = wa_util->get_of_subco( i_ebeln = p-ebeln i_ebelp = p-ebelp i_matnr = <bom_pos>-matnr )
*                IMPORTING
*                  o_ok    = DATA(lv_borrado)
*            ).
*            IF lv_borrado EQ abap_true.
*              DELETE FROM zsppt_ofpedsubco WHERE ebeln = p-ebeln AND ebelp = p-ebelp AND matnr = <bom_pos>-matnr.

            SELECT SINGLE * FROM zsppt_ofpedsubco WHERE ebeln = @p-ebeln AND ebelp = @p-ebelp AND matnr = @<bom_pos>-matnr INTO @DATA(chec).
            IF sy-subrc = 0 AND chec-paso = '99'.
              "Si ya está marcada como borrada en BBDD no es necesario reprocesarlo
              CONTINUE.
            ENDIF.

            SELECT SINGLE ddtext
              INTO @DATA(texto_paso)
              FROM dd07t
              WHERE domname = 'ZSPP_PASO'
              AND domvalue_l = '99'
              AND ddlanguage = @sy-langu.

            UPDATE zsppt_ofpedsubco SET paso = '99'
                                        texto_paso = texto_paso
                                        texto_return = text-002 "'Marcada para borrado desde pedido. esperando procesado'
                                        aedat = sy-datum
                                        aetim = sy-uzeit
            WHERE ebeln = p-ebeln AND ebelp = p-ebelp AND matnr = <bom_pos>-matnr.
*            ENDIF.
            DATA(lanza_job) = abap_true.
            APPEND VALUE #( ebeln = p-ebeln ebelp = p-ebelp matnr = <bom_pos>-matnr ) TO i_ekpo_assembly.
          ELSE.

            wa_util->get_of_tabla(
              EXPORTING
                i_ebeln = p-ebeln
                i_ebelp = p-ebelp
                i_matnr = <bom_pos>-matnr
              RECEIVING
                o_aufnr = DATA(lv_aufnr)
            ).
            IF lv_aufnr IS NOT INITIAL AND ( wa_ekpo-menge <> wa_bbdd-menge
              OR ( ( w_reparto-mbdat IS NOT INITIAL AND w_reparto-mbdat <> wa_bbdd-bdter )
              OR ( w_reparto-mbdat IS INITIAL AND w_reparto-eindt <> wa_bbdd-bdter ) ) ).

              "Lo movemos al JOB para reprocesar desde ahí
              "La orden deberá crearse con fecha = necesidad
*              IF <bom_pos>-bdter IS NOT INITIAL.
*                w_reparto-mbdat = w_reparto-eindt = <bom_pos>-bdter.
*              ENDIF.
*
*              "Si hay modificaciones, modificamos las OFs
*              wa_util->modifica_of_subco(
*                EXPORTING
*                  i_ebeln = p-ebeln
*                  i_ebelp = p-ebelp
*                  i_matnr = <bom_pos>-matnr
*                  i_mbdat = w_reparto-mbdat
*                  i_eindt = w_reparto-eindt
*                  i_menge = <bom_pos>-bdmng
*                IMPORTING
*                  o_ok    = DATA(ok)
*              ).
              SELECT SINGLE * INTO wa_pedipos FROM zsppt_ofpedsubco WHERE ebeln = p-ebeln AND ebelp = p-ebelp AND matnr = <bom_pos>-matnr.
              IF sy-subrc = 0.
                wa_pedipos-paso = '10'.
                SELECT SINGLE ddtext
                  INTO @wa_pedipos-texto_paso
                  FROM dd07t
                  WHERE domname = 'ZSPP_PASO'
                  AND domvalue_l = '10'
                  AND ddlanguage = @sy-langu.
                wa_pedipos-reintento = 1.
                wa_pedipos-texto_return = text-001. "'Pedido modificado. Esperando reproceso'.
                wa_pedipos-aedat = sy-datum.
                wa_pedipos-aetim = sy-uzeit.
                MODIFY zsppt_ofpedsubco FROM wa_pedipos.
                lanza_job = abap_true.
                APPEND VALUE #( ebeln = p-ebeln ebelp = p-ebelp matnr = <bom_pos>-matnr  ) TO i_ekpo_assembly.
              ENDIF.

            ELSEIF lv_aufnr IS INITIAL.

              "Si no hay cambios y/o no existe OF, creamos la OF
              CLEAR wa_pedipos.
              wa_pedipos-ebeln = p-ebeln.
              wa_pedipos-ebelp = p-ebelp.
              wa_pedipos-matnr = <bom_pos>-matnr.
              wa_pedipos-paso = '10'.
              SELECT SINGLE ddtext
                    INTO @wa_pedipos-texto_paso
                    FROM dd07t
                    WHERE domname = 'ZSPP_PASO'
                    AND domvalue_l = '10'
                    AND ddlanguage = @sy-langu.
              wa_pedipos-aedat = sy-datum.
              wa_pedipos-aetim = sy-uzeit.
              wa_pedipos-uname = sy-uname.
              wa_pedipos-reintento = 1.
              MODIFY zsppt_ofpedsubco FROM wa_pedipos.
              lanza_job = 'X'.
              APPEND VALUE #( ebeln = p-ebeln ebelp = p-ebelp matnr = <bom_pos>-matnr ) TO i_ekpo_assembly.

            ENDIF.

          ENDIF.

        ENDLOOP.

        CLEAR wa_pedipos.
      ENDLOOP.

      IF lanza_job = abap_true.
        IF zcl_ap_exits=>exit_activa( 'ASB_OFT_CREACION_OF_PEDIDO' ).
* APC20250211 En lugar de lanzar un job con todos los pedidos pendiente creamos mensajes individuales por posición.
          LOOP AT i_ekpo_assembly ASSIGNING FIELD-SYMBOL(<ekpo_assembly>).
            zcl_ap_wf=>lanzar_evento( objeto      = 'ZWHS'
                                      clave       = |OFT{ <ekpo_assembly>-ebeln }-{ <ekpo_assembly>-ebelp }-{ <ekpo_assembly>-matnr }|
                                      evento      = 'GENERAR_MENSAJE'
                                      update_task = 'X' ).
          ENDLOOP.
        ELSE.
          wa_util->creation_prod_ord(
            EXPORTING
              i_ebeln       = im_ebeln
              it_posiciones = lt_mepoitems_r
          ).
        ENDIF.
      ENDIF.
    ENDIF.
    "FJVM - creacion de OF desde pedido subco



    "
    " SEIS 25.10.2023. Envío a OMP.
    "
    DATA(rl_if_omp_po) = NEW zssd_if_omp_po( ).
    CALL METHOD rl_if_omp_po->save_document
      EXPORTING
        wp_mepoheader    = lw_mepoheader
        tp_mepoitems     = lt_mepoitems
        tp_meposchedules = lt_meposched
        im_header        = im_header.
  ENDMETHOD.
  method IF_EX_ME_PROCESS_PO_CUST~PROCESS_ACCOUNT.
  endmethod.
METHOD if_ex_me_process_po_cust~process_header.
  DATA lw_mepoheader TYPE mepoheader.
  DATA lt_mepoitems_r TYPE purchase_order_items. "Tabla de referencias OO a posiciones
  DATA lw_mepoitem_r TYPE purchase_order_item.  "Referencia OO a posición
  DATA lt_mepoitems TYPE tab_mepoitem.         "Tabla de posiciones
  DATA lw_mepoitem TYPE mepoitem.             "Datos de posición
  DATA lt_accounts_r TYPE purchase_order_accountings.
  DATA lw_accounts_r TYPE purchase_order_accounting.
  DATA lw_account TYPE mepoaccounting.
  DATA lt_accounts TYPE tab_mepoaccounting.
  DATA: fsc TYPE zzfsc.
  DATA: lv_name   TYPE tdobname,
        lt_lines  TYPE TABLE OF tline,
        ls_lines  LIKE LINE OF lt_lines,
        ls_header TYPE thead.

  INCLUDE mm_messages_mac. "useful macros for message handling

**** VALIDACION DE DATOS DE PEDIDO.
  lw_mepoheader   = im_header->get_data( ).
  lt_mepoitems_r  = im_header->get_items( ).

* Para pasar a la función una tabla con las posiciones, debemos tratar la estructura LW_MEPOITEMS.
  LOOP AT lt_mepoitems_r INTO lw_mepoitem_r.
    lw_mepoitem = lw_mepoitem_r-item->get_data( ).
    APPEND lw_mepoitem TO lt_mepoitems.
    CLEAR lw_mepoitem.

* Obtenemos también las cuentas de mayor.
    lt_accounts_r = lw_mepoitem_r-item->get_accountings( ).
    LOOP AT lt_accounts_r INTO lw_accounts_r.
      CLEAR lw_account.
      lw_account = lw_accounts_r-accounting->get_data( ).

      IF lw_account-ebeln IS INITIAL AND lw_mepoheader-ebeln IS NOT INITIAL.
        lw_account-ebeln = lw_mepoheader-ebeln.
      ENDIF.

      APPEND lw_account TO lt_accounts.
    ENDLOOP.

  ENDLOOP.


  CALL FUNCTION 'Z_MM_CHECK_MEPO_BADI'
    EXPORTING
      mepoheader   = lw_mepoheader
      mepoitems    = lt_mepoitems
      mepoaccounts = lt_accounts
      i_dialog     = 'X'
*   IMPORTING
*     RETURN       = RETURN
*     E_SUBRC      = E_SUBRC
    .

* uDefine - PMC Cabos segunda calidad -
*
*  LOOP AT im_header->get_items( ) into DATA(ls_item).
*
*   ls_item-item->get_conditions( IMPORTING ex_conditions = DATA(lt_conditions) ).
*
*   IF line_exists( lt_conditions[ kschl = 'ZDTP' ] ).
*
*   ELSE.
*
*   ENDIf.
*
*  ENDLOOP.

* ini 2.12.2019 - cvivo - 53744 FSC
  DATA: r_ekgrp  TYPE RANGE OF ekko-ekgrp,
        lr_ekgrp LIKE LINE OF r_ekgrp.


  SELECT * FROM tvarvc
    WHERE name EQ 'ZMM_FSC_RECORDATORIO'
    INTO @DATA(tvarvc).

    lr_ekgrp-option = tvarvc-opti.
    lr_ekgrp-sign = tvarvc-sign.
    lr_ekgrp-low = tvarvc-low.
    lr_ekgrp-high = tvarvc-high.
    APPEND lr_ekgrp TO r_ekgrp.
  ENDSELECT.

  IF lw_mepoheader-ekgrp IN r_ekgrp.
    IF gv_lifnr NE lw_mepoheader-lifnr. " ha cambiado el proveedor, o se acaba de introducir
      CALL FUNCTION 'ZMM_CERTIFICACION_FSC'
        EXPORTING
          lifnr = lw_mepoheader-lifnr
        IMPORTING
          fsc   = fsc.

      IF fsc EQ 'S'. " Sí
* Añadimos texto de recordatorio FSC
        MOVE lw_mepoheader-ebeln TO lv_name.
        ls_lines-tdformat = '*'.
        ls_lines-tdline = 'Se requiere material con certificado FSC'.
        APPEND ls_lines TO lt_lines.

        ls_header-tdobject = 'EKKO'.
        ls_header-tdname = lv_name.
        ls_header-tdid = 'F01'.
        ls_header-tdspras = sy-langu.

        CALL FUNCTION 'SAVE_TEXT'
          EXPORTING
            header   = ls_header
          TABLES
            lines    = lt_lines
          EXCEPTIONS
            id       = 1
            language = 2
            name     = 3
            object   = 4
            OTHERS   = 5.

        REFRESH: lt_lines[].
      ENDIF.
    ENDIF.
  ENDIF.

  gv_lifnr = lw_mepoheader-lifnr. " almacenamos proveedor anterior
* fin 2.12.2019 - cvivo - 53744 FSC

* ini - cvivo - 64986 Texto cabecera por defecto
  SELECT sign, opti AS option, low, high FROM tvarvc
    WHERE name EQ 'ZMM_TEXTO_CABECERA_PEDIDO'
      INTO TABLE @DATA(r_texto_cabecera).

  IF sy-subrc EQ 0 AND gv_trtyp EQ 'H' " sólo al crear pedido
    AND lw_mepoheader-ekgrp IS NOT INITIAL " se ha introducido grupo de compras
    AND gv_texto_cabecera IS INITIAL. " si no se ha hecho ya
    gv_texto_cabecera = abap_true. " lo marcamos para no volver a procesarlo

    LOOP AT r_texto_cabecera INTO DATA(texto).
      IF lw_mepoheader-ekgrp CP texto-low OR lw_mepoheader-ekgrp EQ texto-low. " en HIGH ponemos un patrón para grupo de compras o valor exacto
        CLEAR: lt_lines[], ls_lines, ls_header.

        MOVE lw_mepoheader-ebeln TO lv_name.
        ls_lines-tdformat = '*'.
        ls_lines-tdline = texto-high.
        APPEND ls_lines TO lt_lines.
        CLEAR ls_lines-tdline. " salto de línea
        APPEND ls_lines TO lt_lines.

        ls_header-tdobject = 'EKKO'.
        ls_header-tdname = lv_name.
        ls_header-tdid = 'F01'.
        ls_header-tdspras = sy-langu.

        CALL FUNCTION 'SAVE_TEXT'
          EXPORTING
            header   = ls_header
          TABLES
            lines    = lt_lines
          EXCEPTIONS
            id       = 1
            language = 2
            name     = 3
            object   = 4
            OTHERS   = 5.

        REFRESH: lt_lines[].
      ENDIF.
    ENDLOOP.
  ENDIF.
* fin - cvivo - 64986 Texto cabecera por defecto


  " mod - cvivo - 60703 Validar condición de pago -> Se migra a CHECK
** ini cvivo - 04.03.2020 - 59678 validar cond.pago actual
*
*  IF gv_trtyp EQ 'H' OR gv_trtyp EQ 'V'. " si creando o modificando
*    IF lw_mepoheader-lifnr IS NOT INITIAL AND lw_mepoheader-zterm IS NOT INITIAL AND lw_mepoheader-ekorg IS NOT INITIAL.
*      CLEAR lw_mepoitem.
*      LOOP AT lt_mepoitems INTO lw_mepoitem WHERE werks IS NOT INITIAL.
*        EXIT.
*      ENDLOOP.
*      IF lw_mepoitem IS NOT INITIAL. " cond.del centro
*        SELECT SINGLE zterm FROM lfm2
*          INTO @DATA(l_zterm)
*          WHERE lifnr EQ @lw_mepoheader-lifnr
*            AND werks EQ @lw_mepoitem-werks
*            AND ekorg EQ @lw_mepoheader-ekorg.
*      ENDIF.
*      IF l_zterm IS INITIAL. " no hay de centro, cogemos org.compras
*        SELECT SINGLE zterm FROM lfm1
*          INTO l_zterm
*          WHERE lifnr EQ lw_mepoheader-lifnr
*          AND ekorg EQ lw_mepoheader-ekorg.
*      ENDIF.
*      IF l_zterm NE lw_mepoheader-zterm
*        AND l_zterm IS NOT INITIAL. " por si acaso está mal el código
*        CALL METHOD im_header->invalidate( ).
*
*        mmpur_metafield mmmfd_pmnttrms.
*        mmpur_message_forced 'E' 'ZMM' '175' space space space space.
*      ELSE.
*        mmpur_remove_msg_by_context lw_mepoheader-id mmmfd_pmnttrms.
*      ENDIF.
*    ENDIF.
*  ENDIF.
** fin cvivo - 04.03.2020 - 59678 validar cond.pago actual

* ini cvivo - 04.03.2020 - 60678 validar proveedor creado en sociedad
  IF gv_trtyp EQ 'H' AND lw_mepoheader-lifnr IS NOT INITIAL AND lw_mepoheader-bukrs IS NOT INITIAL.
    SELECT SINGLE @abap_true
      FROM lfb1
      WHERE lifnr EQ @lw_mepoheader-lifnr
        AND loevm EQ @space
        AND bukrs EQ @lw_mepoheader-bukrs
      INTO @DATA(check).

    IF sy-subrc NE 0.
      DATA: zztext1(10), zztext2(10).

      WRITE lw_mepoheader-lifnr TO zztext1 NO-ZERO.
      WRITE lw_mepoheader-bukrs TO zztext2.

      mmpur_metafield mmmfd_vendor.
      mmpur_message_forced 'E' 'ZMM' '177' zztext1 zztext2 space space.
      CALL METHOD im_header->invalidate( ).
    ELSE.
      mmpur_remove_msg_by_context lw_mepoheader-id mmmfd_vendor.
    ENDIF.
  ENDIF.
* fin cvivo - 04.03.2020 - 60678

* ini fcardona - 26.10.2020 - 63553 Aviso en creación de pedidos via de pago en desuso (Pagaré)
  IF ( ( gv_trtyp EQ 'H' OR gv_trtyp EQ 'V' ) AND lw_mepoheader-lifnr IS NOT INITIAL AND lw_mepoheader-bukrs IS NOT INITIAL ).

    CONSTANTS: lc_zwels_p TYPE dzwels VALUE 'P'.

    SELECT SINGLE @abap_true
      FROM lfb1
      WHERE lifnr EQ @lw_mepoheader-lifnr
        AND loevm EQ @space
        AND bukrs EQ @lw_mepoheader-bukrs
        AND zwels EQ @lc_zwels_p
      INTO @check.

    IF sy-subrc EQ 0.
      mmpur_metafield mmmfd_vendor.
      mmpur_message_forced 'W' 'ZMM' '000' text-f01 text-f02 text-f03 text-f04.
    ELSE.
      mmpur_remove_msg_by_context lw_mepoheader-id mmmfd_vendor.
    ENDIF.

  ENDIF.
* fin fcardona - 26.10.2020 - 63553

ENDMETHOD.
METHOD if_ex_me_process_po_cust~process_item.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_mepoitem     TYPE mepoitem,
        ls_mepoheader   TYPE mepoheader,
        ls_mepoitem_aux TYPE mepoitem,
        memory(40),
*        bstae           TYPE bstae,      "FCC 30.11.2023 GAPCM014
        lv_bstae_memory TYPE bstae,       "FCC 30.11.2023 GAPCM014
        lv_bstae_new    TYPE bstae,       "FCC 30.11.2023 GAPCM014
        lv_persistent   TYPE mmpur_bool,  "FCC 30.11.2023 GAPCM014
        check(1),
        change(1),
        bstae_new       TYPE bstae,
        l_success       TYPE mmpur_bool VALUE mmpur_no,
*        ls_customer   TYPE        mepo_badi_exampl,
*        ls_tbsg       TYPE        tbsg,
        lv_dummy        TYPE        c LENGTH 128.
*

  INCLUDE mm_messages_mac. "useful macros for message handling
**---------------------------------------------------------------------*
** here we check customers data
**---------------------------------------------------------------------*
**Al crear los pedidos de compra intercompany las posiciones se marcan un bloqueo
  ls_mepoheader = im_item->get_header( )->get_data( ).
  ls_mepoitem   = im_item->get_data( ).

**********************************************************************
* INI FCC - 15.12.2022 | 67255 - Pedido traslado cartoneras
**********************************************************************

  CONSTANTS: lc_tvarvc_route(18) TYPE c VALUE 'ZME21N_BADI_ROUTE_'.

  DATA: ls_ekpv             TYPE ekpv,
        lv_tvarvc_route(22) TYPE c.

**********************************************************************
* FIN FCC - 15.12.2022 | 67255 - Pedido traslado cartoneras
**********************************************************************

*   add jtm 24/11/2022 saltar método en caso de crear STO desde MF
  DATA: saltar_metodo TYPE flag.
  DATA: ex_object_cx_root TYPE REF TO cx_root,
        ex_text           TYPE string,
        ex_text_long      TYPE string.
  TRY.
      CALL FUNCTION 'ZSWMPPMONSTO_CHECK_BADI'
        EXPORTING
          name          = 'ZSWMPPMONSTO_CREATE_STO'
          ebeln         = ls_mepoheader-ebeln
        IMPORTING
          saltar_metodo = saltar_metodo.
    CATCH cx_root INTO ex_object_cx_root.
      ex_text = ex_object_cx_root->get_text( ).
      ex_text_long = ex_object_cx_root->get_longtext( ).
  ENDTRY.
*    if saltar_metodo eq abap_true.
*      if ls_mepoitem-EPSTP ne 'V'.
*         ls_mepoitem-epstp = 'V'.
*         CALL METHOD im_item->set_data
*           EXPORTING
*            im_data = ls_mepoitem.
*
*      endif.
*    endif.
*   fin de add jtm 24.11.2022


  " --------- DEL - 67829 - Lo migro al enhancement ZMM_CREAR_REG_INFO_PEDIDO porque si lo que hacemos es marcar el control
  " de precio en el pedido como sin control, si hay tarifa y el tipo de fecha de proveedor es 5, al haberlo blanqueado, las EM
  " no recalcularán la tarifa para este primer pedido; con lo cual, mejor blanquear directamente sólo el registro info que se crea
*    " cvivo - 65149 - Para evitar que el usuario introduzca el precio manualmente y, al tratarse del primer pedido, el registro
*    " info que se crea arrastre el control de fecha de precio "4 - manualmente", si la posición va a generar registro info,
*    " (porque aún no lo tiene) forzamos que el control de precio sea "Sin control". De esta forma el registro info se crea con
*    " este valor y en adelante manda el valor especificado a nivel de proveedor
*    IF ls_mepoitem-infnr IS INITIAL.
*      DATA: flag(1), zzmemory(40).
*      zzmemory = |{ ls_mepoitem-ebelp }{ ls_mepoitem-matnr } infnr creacion|.
*
*      IMPORT p1 = flag FROM MEMORY ID zzmemory.
*
*      IF flag EQ space.
*        CLEAR ls_mepoitem-meprf.
*        EXPORT p1 = abap_true TO MEMORY ID zzmemory.
*
*        CALL METHOD im_item->set_data
*          EXPORTING
*            im_data = ls_mepoitem.
*      ENDIF.
*    ENDIF.



  " cvivo - 61615 - si ponemos proveedor en entrega, quitar confirmaciones
  IF ls_mepoitem-lblkz IS NOT INITIAL.
    CLEAR: ls_mepoitem-lgort, ls_mepoitem-bstae.

    CALL METHOD im_item->set_data
      EXPORTING
        im_data = ls_mepoitem.
  ENDIF.

* se comprueba que el pedido sea intercompany Y SEA CREACION CON Nº PEDIDO BLANCO
  IF ls_mepoheader-bsart = 'ZINT' AND ls_mepoheader-ebeln IS INITIAL.
    ls_mepoitem-zzbloq_plan = 'X'.
*
    CALL METHOD im_item->set_data
      EXPORTING
        im_data = ls_mepoitem.
  ENDIF.

* ini 26/02/2019 - cvivo - 53649 Papel siempre ctd base = 1000
  SELECT SINGLE @abap_true FROM tvarvc
    WHERE name EQ 'ZMM_PO_CTD_BASE_1000'
      AND low  EQ @ls_mepoitem-mtart
    INTO @DATA(check4).

  IF sy-subrc EQ 0.

*--> FCC 22.06.2022 INI - 72520 - Posiciones gratuitas sin validación.

    IF ( ls_mepoitem-umson IS INITIAL ). "Si posición gratuita no validar

      IF ls_mepoitem-peinh EQ space.
        ls_mepoitem-peinh = 1000.

        CALL METHOD im_item->set_data
          EXPORTING
            im_data = ls_mepoitem.
      ELSEIF ls_mepoitem-peinh NE 1000.
        MESSAGE e169(zmm) INTO lv_dummy.
        mmpur_message_forced sy-msgty sy-msgid sy-msgno
                               sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*   invalidate the object
        CALL METHOD im_item->invalidate( ).
      ENDIF.

    ENDIF.

*<-- FCC 22.06.2022 INI - Posiciones gratuitas sin validación.

  ENDIF.

**********************************************************************
* FCC INI 30.11.2023 GAPCM014 - Control de confirmación en ped. subco
**********************************************************************

****** --> 30.11.2023 Nueva lógica

  lv_bstae_new = me->_determine_bstae_value( i_mepoheader = ls_mepoheader i_mepoitem = ls_mepoitem ).

  IF ( im_item->is_persistent( ) EQ abap_false ). "Se está creando

    MOVE lv_bstae_new TO ls_mepoitem-bstae.

    im_item->set_data( im_data = ls_mepoitem ).

  ENDIF.


*  "Traemos de memoria el valor anterior para ver si ha cambiado
*  CONCATENATE 'ZWM_PO_BSTAE' ls_mepoitem-ebelp INTO memory.
*  IMPORT p1 = lv_bstae_memory FROM MEMORY ID memory.
*
*  "Se chequea si control confirmación está activo
**  IF ( ls_mepoitem-bstae IS NOT INITIAL ). "Está activo.
*
*    "Comprobamos si ha cambiado.
*    IF ( lv_bstae_memory NE ls_mepoitem-bstae ). "Ha cambiado
*
*      lv_bstae_new = me->_get_bstae( i_mepoheader = ls_mepoheader i_mepoitem = ls_mepoitem ).
*
*      IF ( im_item->is_persistent( ) EQ abap_false ). "Se está creando
*
*        MOVE lv_bstae_new TO ls_mepoitem-bstae.
*
*        im_item->set_data( im_data = ls_mepoitem ).
*
*
*
*      ENDIF.
*
*    ENDIF.
*
*  EXPORT p1 = bstae_new TO MEMORY ID memory. " si antes de grabar lo cambian manualmente, manda el usuario

*  ENDIF.

****** <-- 30.11.2023 Nueva lógica

****** --> 30.11.2023 Lógica anterior
*
** fin 26/02/2019 - cvivo - 53649 Papel siempre ctd base = 1000
** ini 07.11.2018 - cvivo - Proyecto WM - Compras de auxiliares por defecto sin entrega
*    IF ls_mepoitem-bstae IS NOT INITIAL. " si tiene control de confirmación
*      CONCATENATE 'ZWM_PO_BSTAE' ls_mepoitem-ebelp INTO memory.
*
*      IMPORT p1 = bstae FROM MEMORY ID memory.
*
*      IF bstae NE ls_mepoitem-bstae. " si ha cambiado
*        SELECT SINGLE @abap_true
*          FROM t320
*          WHERE lgort EQ @ls_mepoitem-lgort
*            AND werks EQ @ls_mepoitem-werks
*            AND lgnum NE @space
*          INTO @DATA(result). " vemos si es WM
*
*        IF sy-subrc EQ 0.
*          IF ls_mepoheader-bsart EQ 'ZPE2'. " cvivo - 59807 - sin conf. en pedido imputado
*
**--> INI FCARDONA 16.01.2022 - Controlo de confirmación en pedidos imputados.
*
** Comento por cambio de lógica
**            change = 'X'. " limpiar clave
**            CLEAR bstae_new.
*
*            "Para materiales ZPTO los imputados con este tipo de material si deben llevar el control de confirmación.
*            SELECT SINGLE mtart
*              FROM mara
*              INTO @DATA(lv_mtart)
*             WHERE matnr EQ @ls_mepoitem-matnr.
*
*            TRY .
*
*              IF ( lv_mtart NOT IN zcl_mm_material_zpt=>zintf_mm_material_master~s_get_mtart_compatibles( i_setname = zcl_mm_material_zpt=>_c_setname_value ) ).
*
*                change = 'X'. " limpiar clave
*                CLEAR bstae_new.
*
*              ENDIF.
*
*            CATCH zcx_mm_exception.
*
*            ENDTRY.
*
**<-- FIN FCARDONA 16.01.2022 - Controlo de confirmación en pedidos imputados.
*
*          ELSE.
*            SELECT SINGLE *
*              FROM tvarvc
*              WHERE name EQ 'ZWM_PO_BSTAE'
*                AND low EQ @ls_mepoitem-mtart
*              INTO @DATA(ls_tvarvc).
*
*            IF sy-subrc EQ 0.
*              change = 'X'. " modificar clave
*              MOVE ls_tvarvc-high TO bstae_new.
*            ENDIF.
*          ENDIF.
*        ELSE.
*          IF ls_mepoheader-bsart EQ 'ZPE2'. " cvivo - 59807 - sin conf. en pedido imputado
*            change = 'X'. " limpiar clave
*            CLEAR bstae_new.
*          ELSE.
*            SELECT * FROM tvarvc
*              INTO ls_tvarvc
*              WHERE name EQ 'ZWM_ALMACENES_PUERTO'
*               AND low   EQ ls_mepoitem-werks.
*
*              IF ls_mepoitem-lgort CP ls_tvarvc-high.
*                change = 'X'. " limpiar clave
*                CLEAR bstae_new.
*              ENDIF.
*            ENDSELECT.
*          ENDIF.
*        ENDIF.
*
*        IF change IS NOT INITIAL.
*          DATA(persistent) = im_item->is_persistent( ).
*
*          IF persistent IS INITIAL. " si se está creando
*            MOVE bstae_new TO ls_mepoitem-bstae.
*
*            CALL METHOD im_item->set_data
*              EXPORTING
*                im_data = ls_mepoitem.
*
*            EXPORT p1 = bstae_new TO MEMORY ID memory. " si antes de grabar lo cambian manualmente, manda el usuario
*          ENDIF.
*        ENDIF.
*      ENDIF.
*    ENDIF.
** fin 07.11.2018 - cvivo - Proyecto WM - Compras de auxiliares por defecto sin entrega
*
****** <-- 30.11.2023 Lógica anterior


**********************************************************************
* FCC FIN 30.11.2023 GAPCM014 - Control de confirmación en ped. subco
**********************************************************************

* ini 18/12/2018 - cvivo - Proyecto WM - Almacén obligatorio
  IF ( ls_mepoheader-bsart = 'ZINT' OR ls_mepoheader-bsart = 'ZPE1' ) AND ls_mepoitem-lblkz IS INITIAL. " cvivo - y no se entrega a proveedor
    SELECT SINGLE @abap_true
     FROM t320
     WHERE werks EQ @ls_mepoitem-werks
       AND lgnum NE @space
     INTO @DATA(check2). " vemos si es WM

    IF sy-subrc EQ 0 AND ls_mepoitem-lgort IS INITIAL AND ls_mepoitem-lblkz IS INITIAL. " almacén obligatorio
      mmpur_metafield mmmfd_store_loc.
*          mmpur_context 902.
*          mmpur_business_obj_id ls_item_data-id.
      MESSAGE e168(zmm) INTO lv_dummy.
      mmpur_message_forced sy-msgty sy-msgid sy-msgno
                             sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
* invalidate the object
      CALL METHOD im_item->invalidate( ).
    ELSEIF sy-subrc EQ 0 AND ls_mepoitem-lgort IS NOT INITIAL AND ls_mepoitem-lblkz IS NOT INITIAL. " almacén debe ir vacío
      mmpur_metafield mmmfd_store_loc.
*          mmpur_context 902.
*          mmpur_business_obj_id ls_item_data-id.
      MESSAGE e173(zmm) INTO lv_dummy.
      mmpur_message_forced sy-msgty sy-msgid sy-msgno
                             sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
* invalidate the object
      CALL METHOD im_item->invalidate( ).
    ENDIF.
  ENDIF.
* fin 18/12/2018 - cvivo - Proyecto WM - Almacén obligatorio

**********************************************************************
* INI FCC - 30.05.2022 | 67255 - Pedido traslado cartoneras
**********************************************************************

  "Al activar valoración por lotes, nos pide categoria de valoración para el pedido.
  "Al crearse automaticamente, da error en la creación pq espera que se le indique lote.
  "Rellenamos categoria de valoración en este punto para permitir creación automatica de pedidos.

  IF ( ls_mepoheader-bsart = 'ZPT1' OR ls_mepoheader-bsart = 'ZPT4' )  "Si pedido de traslado cartoneras
  AND  saltar_metodo NE abap_true.     " add jtm 24.11.2022

    """ VALORACIÓN POR LOTES

    SELECT SINGLE @abap_true
      FROM mbew
      INTO @DATA(lv_check)
     WHERE matnr EQ @ls_mepoitem-matnr
       AND bwkey EQ @ls_mepoitem-werks
       AND bwtty EQ @abap_true.

    IF ( sy-subrc = 0 AND lv_check = abap_true ) .

      ls_mepoitem-wabwe = abap_true.
      CALL METHOD im_item->set_data EXPORTING im_data = ls_mepoitem.

    ENDIF.

  ENDIF.

  """ RUTA AUTOMATICA - por param no la trae cuando arreglemos comentar todo esto.

  IF ( ( sy-tcode EQ 'ME21N' OR sy-tcode EQ 'ME22N' )
    AND ( ls_mepoheader-bsart EQ 'ZPT4' ) ).

    ls_ekpv = im_item->get_shipping_data( ).

    IF ( ls_ekpv-kunnr IS NOT INITIAL ).

      IF ( ls_ekpv-route IS INITIAL ).

        CLEAR: lv_tvarvc_route.

        CONCATENATE lc_tvarvc_route ls_mepoitem-werks INTO lv_tvarvc_route.

        SELECT SINGLE low
          FROM tvarvc
          INTO @DATA(lv_low)
         WHERE name EQ @lv_tvarvc_route
           AND type EQ 'P'.

        IF ( sy-subrc EQ 0 ).

          SELECT SINGLE route
            FROM tvro
            INTO ls_ekpv-route
           WHERE route EQ lv_low.

          IF ( sy-subrc EQ 0 AND ls_ekpv IS NOT INITIAL ).

            im_item->set_shipping_data( im_ekpv = ls_ekpv ).

          ENDIF.

        ENDIF.

      ENDIF.

    ENDIF.

  ENDIF.

**********************************************************************
* FIN FCC - 30.05.2022 | 67255 - Pedido traslado cartoneras
**********************************************************************

** ini 2.12.2019 - cvivo - 53744 FSC ---> DEL 16.0.2020 cvivo - Se migra a Enhancement ZMM_FSC_PEDIDOS
*    IF ls_mepoitem-zzfsc IS INITIAL. " se está creando, no tiene "Sí" ni "No" en FSC
*      IF ls_mepoheader-lifnr IS NOT INITIAL AND ls_mepoheader-lifnr NE gv_lifnr. " tiene que haber proveedor o ser diferente
*
*        gv_fsc = 'X'.
** Recuperamos valores de certificación del proveedor
*        CALL FUNCTION 'ZMM_CERTIFICACION_FSC_MATERIAL'
*          EXPORTING
*            lifnr              = ls_mepoheader-lifnr
*            matnr              = ls_mepoitem-matnr
*          IMPORTING
*            fsc                = ls_mepoitem-zzfsc
*            codigo_certificado = ls_mepoitem-zzcod_fsc
*            declaracion_fsc    = ls_mepoitem-zzdecla_fsc
*            porcentaje_fsc     = ls_mepoitem-zzporcent_fsc.
*
*        CALL METHOD im_item->set_data
*          EXPORTING
*            im_data = ls_mepoitem.
*      ENDIF.
*    ELSE.
*      gv_fsc = 'X'. " hay datos FSC
*    ENDIF.
** fin 2.12.2019 - cvivo - 53744 FSC


* ini cvivo - 14.05.2020 - 61060 Límite en desviaciones en pedidos
  DATA: messages TYPE mepo_t_messages_bapi,
        limite   TYPE i,
        precio   TYPE kwert,
        actual   TYPE kwert.

  SELECT SINGLE @abap_true FROM tvarvc
    WHERE name EQ 'ZMM_LIM_SUP_PRECIO_EXCEP'
      AND low EQ @sy-tcode
    INTO @DATA(check3).

  IF sy-subrc NE 0.
    CALL METHOD cl_message_handler_mm=>get_handler
      IMPORTING
        ex_handler = gl_message_handler.

    messages = gl_message_handler->get_list_for_bapi( ).

    IF messages IS NOT INITIAL AND ls_mepoitem-loekz IS INITIAL.
      READ TABLE messages INTO DATA(l_message) WITH KEY msgid = '06' " la validación tiene lugar cuando ya se ha sobrepasado la tolerancia estándar
                                                        msgno = '207'
                                                        ebelp = ls_mepoitem-ebelp.

      IF sy-subrc EQ 0.
        SELECT SINGLE low FROM tvarvc
        INTO @DATA(low)
              WHERE name EQ 'ZMM_LIM_SUP_PRECIO_PEDIDO'.

        IF sy-subrc EQ 0.
          " cvivo - 63931 verificar que el tipo de material gestiona cambio de valor
          SELECT SINGLE @abap_true FROM t134m
            WHERE mtart EQ @ls_mepoitem-mtart
              AND bwkey EQ @ls_mepoitem-werks
              AND wertu NE @space " act.valor en MM
            INTO @DATA(ok).

          IF sy-subrc EQ 0.
            " cvivo - 64644 - Verificar que el material se ha utilizado ya
            SELECT SINGLE @abap_true FROM ekpo
              WHERE matnr EQ @ls_mepoitem-matnr
                AND werks EQ @ls_mepoitem-werks
              INTO @DATA(exists).

            IF sy-subrc EQ 0.
              MOVE: low TO limite.

              CALL FUNCTION 'MOVE_CHAR_TO_NUM'
                EXPORTING
                  chr             = l_message-msgv1
                IMPORTING
                  num             = precio
                EXCEPTIONS
                  convt_no_number = 1
                  convt_overflow  = 2
                  OTHERS          = 3.

              CALL FUNCTION 'MOVE_CHAR_TO_NUM'
                EXPORTING
                  chr             = l_message-msgv3
                IMPORTING
                  num             = actual
                EXCEPTIONS
                  convt_no_number = 1
                  convt_overflow  = 2
                  OTHERS          = 3.

              IF ( ( 100 * precio / actual ) - 100 ) GE limite. " limite sobrepasado
                mmpur_context 903.
                mmpur_business_obj_id ls_mepoitem-id.
                mmpur_metafield l_message-metafield.
                mmpur_message_forced 'E' 'ZMM' '178' limite space space space.

                CALL METHOD im_item->invalidate( ).
              ELSE.
                mmpur_remove_msg_by_context ls_mepoitem-id 903.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        mmpur_remove_msg_by_context ls_mepoitem-id 903.
      ENDIF.
    ENDIF.
  ENDIF.
* fin cvivo 61060

* ini - cvivo - 63713 Si el reg.info lleva procedimiento de import, verificar que está en el pedido
  lv_persistent = im_item->is_persistent( ).

  IF lv_persistent IS INITIAL AND NOT line_exists( gt_mepoitem[ ebelp = ls_mepoitem-ebelp werks = ls_mepoitem-werks ] ).
    SELECT SINGLE exprf FROM eine
      WHERE infnr EQ @ls_mepoitem-infnr
        AND exprf NE @space
        AND werks EQ @ls_mepoitem-werks
      INTO @DATA(import).

    IF sy-subrc EQ 0. " hay proced. import en registro info
      DATA(eipo) = im_item->get_foreign_trade( ).

      IF eipo-exprf NE import.
        eipo-exprf = import.

        im_item->set_foreign_trade( im_data = eipo ).
      ENDIF.
    ENDIF.
  ENDIF.

  APPEND ls_mepoitem TO gt_mepoitem. " aquí controlamos que esta posición no es nueva aunque no esté grabada
  "GET_FOREIGN_TRADE
* fin - cvivo - 63713

  "MTS Monitor de Traslados, Asignar Clase de entrega a la posición del pedido de Traslados
  DATA: lfart_cm TYPE lfret,
        vsbed_cm TYPE vsbed,
        route_cm TYPE route.
  CALL FUNCTION 'ZUI5_CM_GET_LFART'
    IMPORTING
      e_lfart = lfart_cm
      e_vsbed = vsbed_cm
      e_route = route_cm.

  IF lfart_cm IS NOT INITIAL.
    ls_mepoitem-lfret = lfart_cm.
    CALL METHOD im_item->set_data
      EXPORTING
        im_data = ls_mepoitem.
  ENDIF.
  IF vsbed_cm IS NOT INITIAL OR route_cm IS NOT INITIAL.
    DATA(lv_ship) =  im_item->get_shipping_data( ).

    IF vsbed_cm IS NOT INITIAL.
      lv_ship-vsbed = vsbed_cm.
    ENDIF.

    IF route_cm IS NOT INITIAL AND lv_ship-route IS INITIAL.
      lv_ship-route = route_cm.
    ENDIF.

    CALL METHOD im_item->set_shipping_data
      EXPORTING
        im_ekpv = lv_ship.
  ENDIF.
  "MTS FIN Monitor de Traslados, Asignar Clase de entrega a la posición del pedido de Traslados

  "JVM - ADD funcionalidad GAPCM015
  DATA(util) = NEW zsmm_utils( ).
  DATA: gv_ekpo TYPE ekpo,
        gv_ekko TYPE ekko.
  MOVE-CORRESPONDING ls_mepoheader TO gv_ekko.
  MOVE-CORRESPONDING ls_mepoitem TO gv_ekpo.
  util->cumple_criterios_subco(
    EXPORTING
      i_ebeln          =  ls_mepoheader-ebeln
      i_ebelp          =  ls_mepoitem-ebelp
      i_structure_ekpo =  gv_ekpo
      i_structure_ekko =  gv_ekko
    IMPORTING
*        o_caso           =     " Caso subco
      o_aplica         = DATA(aplica)
  ).

*--> INI JGM 12.07.2024 GAPCM042 Desvíos: No generar OF si se crea Pedido de Traslado desde´ZSCM042 Monitor Desvíos.
  DATA: et_callstack TYPE sys_callst,
        lv_saltar_of TYPE flag.

  FREE et_callstack.
  CALL FUNCTION 'SYSTEM_CALLSTACK'
    IMPORTING
      et_callstack = et_callstack.

  CLEAR lv_saltar_of.
  IF line_exists( et_callstack[ progname = 'ZSCM042' eventname = 'PROCESAR_DESVIOS' ] ) AND
     line_exists( et_callstack[ eventname = 'Z_SCM042_CREAR_PEDIDO_TRASLADO' ] ).
    lv_saltar_of = abap_true.
  ENDIF.
*<-- FIN JGM 12.07.2024.

  IF lv_saltar_of EQ abap_false. "JGM 12.07.2024 GAPCM042 Desvíos: No generar OF (if-endif).

    IF aplica EQ abap_true AND im_item->is_persistent( ) EQ abap_false . "Se está creando

      READ TABLE gt_pos_modif WITH KEY low = ls_mepoitem-ebelp TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        MOVE abap_true TO ls_mepoitem-zzcrear_of.

        im_item->set_data( im_data = ls_mepoitem ).

        APPEND INITIAL LINE TO gt_pos_modif ASSIGNING FIELD-SYMBOL(<ebelp>).
        <ebelp>-low = ls_mepoitem-ebelp.

      ENDIF.
    ENDIF.

  ENDIF.  "JGM 12.07.2024 GAPCM042 Desvíos: No generar OF (if-endif).

  IF aplica EQ abap_true.

    SELECT aufnr INTO TABLE @DATA(it_aufnr) FROM zsppt_ofpedsubco
      WHERE ebeln = @gv_ekko-ebeln
      AND ebelp = @ls_mepoitem-ebelp
      AND aufnr <> @space.

*    DATA lt_stat TYPE tttjo2t.


    LOOP AT it_aufnr ASSIGNING FIELD-SYMBOL(<aufn>).
      zspp_utils=>get_of_status(
        EXPORTING
          i_aufnr    = <aufn>-aufnr
        IMPORTING
          ot_status  = DATA(lt_stat)
*        ot_return  =
*      CHANGING
*        co_obj_log =
      ).
*      APPEND LINES OF it_stat TO lt_stat.

      IF NOT ( line_exists( lt_stat[ istat = 'I0001' ] ) AND NOT line_exists( lt_stat[ istat = 'I0046' ] ) ).
        mmpur_message_forced 'W' 'ZPP' '408' '' '' '' ''.
      ENDIF.
      FREE lt_stat.
    ENDLOOP.



  ENDIF.
  "FJVM


*APC20240612 Determinamos lote de subcontratación
  IF ls_mepoitem-charg IS INITIAL.
    SELECT SINGLE epstp FROM t163y  "El tipo de posición en la EKPO es interno, buscamos el externo para que quede mas claro
      INTO @DATA(l_tipo_posicion)
     WHERE pstyp = @ls_mepoitem-pstyp.

    IF zcl_ap_exits=>exit_activa( 'LOTES_PO_SUBCONTRACION' ).
*APC20241107 Cambiamos el criterio para determinar lotes
*      IF  l_tipo_posicion = 'L'. "Posición de subcontratación
*        IF ls_mepoitem-werks IN o_core_mm->get_rango_centros( zhcl_mm_core=>c_set_centros_folding ) AND
*           ( ls_mepoitem-mtart IN o_core_mm->get_rango_tipos_mat( zhcl_mm_core=>c_set_tipo_mat_pt_packaging )
*          OR ls_mepoitem-mtart IN o_core_mm->get_rango_tipos_mat( zhcl_mm_core=>c_set_tipo_mat_semi_packaging ) ).
*          o_core_mm->get_lote( EXPORTING bncom = VALUE bncom( matnr = ls_mepoitem-matnr
*                                                              werks = ls_mepoitem-werks )
*                                         tipo_forzado = 'SUBCONTRATACION_FOLDING'
*                                         exit = 'LOTES_PO_SUBCONTRACION'
*                               IMPORTING charg = ls_mepoitem-charg
*                                         message = DATA(l_msg_lote) ).
*          IF NOT l_message IS INITIAL.
*            mmpur_message_forced 'W' '00' '398' l_msg_lote(40) l_msg_lote+40(40) l_msg_lote+80(40) l_msg_lote+120(40).
*          ELSEIF NOT ls_mepoitem-charg IS INITIAL.
*            im_item->set_data( EXPORTING im_data = ls_mepoitem ).
*          ENDIF.
*        ENDIF.
*      ENDIF.
      DATA(l_lifnr_sc) = ls_mepoheader-lifnr.
      __quitar_ceros l_lifnr_sc.
      DATA(l_par) = zcl_ap_parametros=>get_parametro( clave  = 'ZMEPOCRLOT'
                                                      campo  = ls_mepoheader-bsart
                                                      valor  = l_lifnr_sc
                                                      valor2 = ls_mepoitem-werks
                                                      valor3 = ls_mepoitem-lgort
                                                      valor4 = l_tipo_posicion ).
      IF l_par-atributo1 = 'X' AND "Crear lote
         l_par-atributo2 NE ''. "Rango
        DATA(o_core_mm) = NEW zhcl_mm_core( ).
        o_core_mm->get_lote( EXPORTING bncom = VALUE bncom( matnr = ls_mepoitem-matnr
                                                            werks = ls_mepoitem-werks )
                                       tipo_forzado = CONV #( l_par-atributo2 )
                                       exit = 'LOTES_PO_SUBCONTRACION'
                             IMPORTING charg = ls_mepoitem-charg
                                       message = DATA(l_msg_lote) ).
        IF NOT l_message IS INITIAL.
          mmpur_message_forced 'W' '00' '398' l_msg_lote(40) l_msg_lote+40(40) l_msg_lote+80(40) l_msg_lote+120(40).
        ELSEIF NOT ls_mepoitem-charg IS INITIAL.
          im_item->set_data( EXPORTING im_data = ls_mepoitem ).
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

*T163Y-EPSTP

ENDMETHOD.
  method IF_EX_ME_PROCESS_PO_CUST~PROCESS_SCHEDULE.
  endmethod.
