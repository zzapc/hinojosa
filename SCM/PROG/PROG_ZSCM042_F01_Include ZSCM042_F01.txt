*&---------------------------------------------------------------------*
*&  Include           ZSCM042_F01
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  GET_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_GT_OUTTAB  text
*----------------------------------------------------------------------*
FORM get_data  CHANGING p_gt_outtab.

  TYPES: BEGIN OF ty_ua_cantxpal,
           vbeln TYPE lips-vbeln,
           posnr TYPE lips-posnr,
           charg TYPE lips-charg,
           ccant TYPE char15,     "Cantidad en char, para distinguir unas de otras al contar.
           cant  TYPE vepo-vemng,
           count TYPE i,
           vemng TYPE vepo-vemng, "Sumatoria.
         END OF ty_ua_cantxpal,
         ty_tab_ua_cantxpal TYPE TABLE OF ty_ua_cantxpal.

  CONSTANTS:
    lc_wbstk_c TYPE wbstk VALUE 'C',
    lc_fkstk_c TYPE fkstk VALUE 'C'.

  DATA: ls_outtab      TYPE ty_outtab,
        ls_ua_cantxpal TYPE ty_ua_cantxpal.
  DATA: lt_ua_cantxpal  TYPE ty_tab_ua_cantxpal.
  DATA: lv_vbelv     TYPE vbfa-vbelv, "Dummy vacío.
        lv_lgort_we  TYPE lgort_d,
        lv_lfimg_tot TYPE lips-lfimg.
  DATA: lr_mtart_pallet TYPE RANGE OF mtart,
        lr_lfart_desvio TYPE RANGE OF lfart.


  lr_mtart_pallet = VALUE #( ( sign = 'I' option = 'EQ' low = 'ZPAL' ) ).

  lr_lfart_desvio = VALUE #(   sign = 'I' option = 'EQ' ( low = 'ZLF4' )
                                                        ( low = 'ZNL1' )
                                                        ( low = 'ZTD1' ) ).

  "1-Búsqueda entregas:
  "DESVIO DE TRANSPORTE CON DESTINATARIO CLIENTE FINAL A CM.
  SELECT a~vbeln, c~posnr, a~vkorg, a~wadat, a~kunnr AS kunwe,
         c~pstyv, c~matnr, c~werks, c~lgort, c~charg, c~lfimg, c~vrkme, c~mtart, c~vgbel, c~vgpos, c~uecha,
         d~tknum,
         e~tdlnr, e~signi, e~zzconductor,
         f~venum, f~vepos, f~vbeln AS vbeln_vepo, f~posnr AS posnr_vepo, f~vemng,
         g~exidv, g~vbeln_gen, g~posnr_gen, g~vhilm,
         @lv_vbelv AS vbelv
    INTO TABLE @DATA(lt_data)
    FROM likp AS a
    INNER JOIN vbuk AS b
      ON b~vbeln EQ a~vbeln
    INNER JOIN lips AS c
      ON c~vbeln EQ b~vbeln
    INNER JOIN vttp AS d
      ON d~vbeln EQ c~vbeln
    INNER JOIN vttk AS e
      ON e~tknum EQ d~tknum
    INNER JOIN vepo AS f
      ON  f~vbeln EQ c~vbeln
      AND f~posnr EQ c~posnr
    INNER JOIN vekp AS g
      ON g~venum EQ f~venum
    WHERE a~vbeln       IN @so_vbeln
      AND a~vkorg       IN @so_vkorg
      AND a~lfart       IN @lr_lfart_desvio
      AND a~kunnr       IN @so_kunwe
      AND a~wadat_ist   IN @so_wadat
      AND b~wbstk       EQ @lc_wbstk_c  "Entregas con SM contabilizada.
      AND b~fkstk       NE @lc_fkstk_c  "Entregas pendientes de facturar.
      AND c~werks       IN @so_werks
      AND c~lgort       IN @so_lgort
      AND c~vgbel       NOT IN ( SELECT ebeln FROM ekko WHERE ebeln EQ c~vgbel )  "Excluir casos puntuales entregas de POs que no tocan aquí.
      AND d~tknum       IN @so_tknum
      AND e~tdlnr       IN @so_tdlnr
      AND e~signi       IN @so_signi
      AND e~zzconductor IN @so_condu.

  "2-Búsqueda entregas:
  "DESVIO DE TRANSPORTE CON DESTINATARIO CM A CLIENTE FINAL.
  SELECT a~vbeln, c~posnr, a~vkorg, a~wadat, a~kunnr AS kunwe,
         c~pstyv, c~matnr, c~werks, c~lgort, c~charg, c~lfimg, c~vrkme, c~mtart, c~vgbel, c~vgpos, c~uecha,
         d~tknum,
         e~tdlnr, e~signi, e~zzconductor,
         f~venum, f~vepos,  f~vbeln AS vbeln_vepo, f~posnr AS posnr_vepo, f~vemng,
         g~exidv, g~vbeln_gen, g~posnr_gen, g~vhilm,
         h~vbelv
    APPENDING TABLE @lt_data
    FROM likp AS a
    INNER JOIN vbuk AS b
      ON b~vbeln EQ a~vbeln
    INNER JOIN lips AS c
      ON c~vbeln EQ b~vbeln
    INNER JOIN vttp AS d
      ON d~vbeln EQ c~vbeln
    INNER JOIN vttk AS e
      ON e~tknum EQ d~tknum
    INNER JOIN vbfa AS h      ">Flujo VBFA en lugar de entrega original.
      ON  h~vbelv EQ a~vbeln   ">
    INNER JOIN vbuk AS i
      ON i~vbeln EQ h~vbeln   "+Estatus SM de Entrega Entrante
    INNER JOIN vepo AS f
      ON  f~vbeln EQ h~vbeln   "VBFA-VBELN Entrega Entrante
*      AND f~posnr EQ c~posnr  "*pos debería ser de entrega entrante -> ajuste where con subquery lips entrega entrante.
    INNER JOIN vekp AS g
      ON g~venum EQ f~venum
    WHERE a~vbeln       IN @so_vbeln
      AND a~vkorg       IN @so_vkorg
      AND a~lfart       IN @lr_lfart_desvio
      AND a~kunnr       IN @so_kunwe
      AND a~wadat_ist   IN @so_wadat
      AND b~wbstk       EQ @lc_wbstk_c  "Entregas con SM contabilizada.
      AND b~fkstk       NE @lc_fkstk_c  "Entregas pendientes de facturar.
      AND c~werks       IN @so_werks
      AND c~lgort       IN @so_lgort
      AND c~lfimg       NE 0            "Ajuste partición lote: no mostrar pos con lfimg 0 por efecto de la partición.
      AND d~tknum       IN @so_tknum
      AND e~tdlnr       IN @so_tdlnr
      AND e~signi       IN @so_signi
      AND e~zzconductor IN @so_condu
      AND h~vbtyp_n     EQ '7' ">Flujo VBFA.
      AND f~posnr       IN ( SELECT posnr FROM lips WHERE vbeln EQ h~vbeln AND vgbel EQ c~vgbel AND vgpos EQ c~vgpos ) "*
      AND i~wbstk       NE @lc_wbstk_c.  "+Entrega Entrante sin SM contabilizada.

  IF lt_data IS NOT INITIAL.
    SORT lt_data BY tknum vbeln posnr.

    DATA(lt_data_aux) = lt_data.

    "Nota: Pueden aparecer duplicadas las posiciones de entrega por la búsqueda en vepo - ajustar.
    "Lo importante es tener los vbeln_gen y posnr_gen de cada lips-posnr.
    DELETE ADJACENT DUPLICATES FROM lt_data COMPARING vbeln posnr.

    "Posiciones de embalaje pallets por separado, no se mostrarán en listado pero se consultarán sus campos.
    SELECT vbeln, posnr, pstyv, matnr, lfimg, meins, vrkme, arktx, mtart
      INTO TABLE @DATA(lt_pallets)
      FROM lips
      FOR ALL ENTRIES IN @lt_data
      WHERE vbeln EQ @lt_data-vbeln
        AND mtart IN @lr_mtart_pallet.


    LOOP AT lt_data INTO DATA(ls_data).
      ls_outtab = CORRESPONDING #( ls_data ).

      "Nombre Destinatario:
      PERFORM read_name1_kunnr USING ls_data-kunwe
                               CHANGING ls_outtab-name1_we.

      "Cliente:
      PERFORM read_knvp USING ls_data-kunwe ls_data-vkorg 'WE'
                        CHANGING ls_outtab-kunnr.

      "Nombre Cliente:
      PERFORM read_name1_kunnr USING ls_outtab-kunnr
                               CHANGING ls_outtab-name1.

      "Descripción material:
      PERFORM read_makt USING ls_data-matnr
                        CHANGING ls_outtab-maktx.

      "Cantidad de desvío (por defecto, misma cant.de entrega).
      ls_outtab-cant_desvio = ls_data-lfimg.


      "Datos de subposición de embalaje -pallets-.
      IF ls_data-vbelv IS INITIAL.
        "Viene del flujo Ventas, el nro de entrega VBELN_GEN de posiciones de embalaje COINCIDE con VBELN -> VBELN_GEN es Entrega de Salida.
        IF line_exists( lt_pallets[ vbeln = ls_data-vbeln_gen  posnr = ls_data-posnr_gen ] ).
          DATA(ls_pallets) = lt_pallets[ vbeln = ls_data-vbeln_gen  posnr = ls_data-posnr_gen ].
        ENDIF.
      ELSE.
        "Viene del flujo Compras, el nro de entrega VBELN_GEN de posiciones de embalaje DIFIERE de VBELN -> VBELN_GEN es Entrega Entrante.
        IF line_exists( lt_pallets[ vbeln = ls_data-vbeln  posnr = ls_data-posnr_gen ] ).
          ls_pallets = lt_pallets[ vbeln = ls_data-vbeln  posnr = ls_data-posnr_gen ].
        ENDIF.
      ENDIF.

      IF ls_pallets IS NOT INITIAL.
        "Tipo pallet:
        ls_outtab-tipo_pallet = ls_pallets-matnr.

        "Descriptivo pallet:
        PERFORM read_makt USING ls_outtab-tipo_pallet
                          CHANGING ls_outtab-text_pallet.

        "Cantidad pallet:
*        ls_outtab-cant_pallet = ls_pallets-lfimg.
        ls_outtab-meins_pallet = ls_pallets-vrkme.

        "-->Lógica cantidades pallets:
        "Cantidad total de pallets, cantidad de cada pallet y cantidades x pallet:
        CLEAR lv_lfimg_tot.
        CLEAR ls_ua_cantxpal.
        FREE lt_ua_cantxpal.

        IF ls_data-uecha IS INITIAL.
          DATA(lv_posnr) = ls_data-posnr.
        ELSE.
          lv_posnr = ls_data-uecha.
        ENDIF.

        "En lt_data_aux están los datos originales exidv pero duplicados por las entradas en vepo.
        "Mejor leer datos en limpio.
        SELECT b~vbeln AS vbeln_vepo, b~posnr AS posnr_vepo,
               z~vbeln, z~posnr, z~exidv, z~matnr, z~charg, menge,
               a~venum
          INTO TABLE @DATA(lt_zpick)
          FROM zswm_ui5_pick AS z
          INNER JOIN vekp AS a ON a~exidv EQ z~exidv
          INNER JOIN vepo AS b ON b~venum EQ a~venum
          FOR ALL ENTRIES IN @lt_data_aux
          WHERE z~vbeln EQ @lt_data_aux-vbeln
            AND z~vbeln EQ @ls_data-vbeln
            AND z~posnr EQ @lv_posnr
            AND z~exidv EQ @lt_data_aux-exidv
            AND z~lvorm NE @abap_true.

        LOOP AT lt_zpick INTO DATA(ls_zpick) WHERE vbeln_vepo EQ ls_data-vbeln_vepo
                                               AND posnr_vepo EQ ls_data-posnr.   "forzar con posnr, no posnr_vepo.

          "Cantidad x pallet (según UAs de embalaje): Identificar y contar cada cantidad que haya de las UAs.
          ls_ua_cantxpal-vbeln = ls_zpick-vbeln.
          ls_ua_cantxpal-posnr = ls_data-posnr.   "Agrupar con el posnr real.
          ls_ua_cantxpal-charg = ls_zpick-charg.
          ls_ua_cantxpal-ccant = ls_zpick-menge.  "Guardado en char, para identificar cada cantidad diferente.
          CONDENSE ls_ua_cantxpal-ccant.
          ls_ua_cantxpal-count = 1.
          ls_ua_cantxpal-vemng = ls_zpick-menge.
          COLLECT ls_ua_cantxpal INTO lt_ua_cantxpal.
        ENDLOOP.

        IF sy-subrc EQ 0 AND lt_ua_cantxpal IS NOT INITIAL.

          "Cantidad x pallet (según UAs de embalaje): Recuperar valor númérico para ordenar.
          LOOP AT lt_ua_cantxpal ASSIGNING FIELD-SYMBOL(<fs_ua_cantxpal>).
            <fs_ua_cantxpal>-cant = CONV #( <fs_ua_cantxpal>-ccant ).
            lv_lfimg_tot = lv_lfimg_tot + <fs_ua_cantxpal>-count.
          ENDLOOP.
          "Contar los pallets total por posición, según cuántas veces aparece ésta en VEPO.
          ls_outtab-cant_pallet_tot = lv_lfimg_tot.

          SORT lt_ua_cantxpal BY cant DESCENDING.

          "Cantidad x pallet (según UAs de embalaje): Cantidad mayor, sea pallet completo o pico, da igual.
          ls_outtab-cant_pallet1  = lt_ua_cantxpal[ 1 ]-count.
          ls_outtab-cant_xpallet1 = lt_ua_cantxpal[ 1 ]-cant.
          ls_outtab-meins_xpallet = ls_outtab-vrkme.

          "Cantidad x pallet (según UAs de embalaje): Cantidad picos (se asume mostrar picos hasta 2 columnas).
          IF lines( lt_ua_cantxpal ) GT 1.
            ls_outtab-cant_pallet2  = lt_ua_cantxpal[ 2 ]-count.
            ls_outtab-cant_xpallet2 = lt_ua_cantxpal[ 2 ]-cant.
          ENDIF.

        ENDIF.
        FREE lt_zpick.
        "<--Lógica cantidades pallets.
      ENDIF.
      CLEAR ls_pallets.

**      "Cantidad x pallet (del maestro de materiales):
*      PERFORM read_xpallet USING ls_outtab-matnr ls_outtab-vrkme
*                           CHANGING ls_outtab-cant_xpallet ls_outtab-meins_xpallet.

      ">Ajuste: Chequear si destinatario es CM en alv inicial.
      CLEAR lv_lgort_we.
      CALL FUNCTION 'Z_SCM042_CLIENTE_CM'
        EXPORTING
          i_kunnr = ls_data-kunwe
          i_vkorg = ls_data-vkorg
        IMPORTING
          e_lgort = lv_lgort_we.
*           e_werks =

      IF lv_lgort_we IS NOT INITIAL.
        ls_outtab-flagcm = abap_true.
      ENDIF.
      "<

      APPEND ls_outtab TO gt_outtab.
      CLEAR ls_outtab.
    ENDLOOP.

  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  READ_NAME1_KUNNR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATA_KUNWE  text
*      <--P_LS_OUTTAB_NAME1_WE  text
*----------------------------------------------------------------------*
FORM read_name1_kunnr  USING    p_kunnr TYPE kna1-kunnr
                       CHANGING p_name1 TYPE kna1-name1.

  IF p_kunnr IS NOT INITIAL.
    SELECT SINGLE name1
      INTO p_name1
      FROM kna1
      WHERE kunnr EQ p_kunnr.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  READ_KNVP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATA_KUNWE  text
*      -->P_LS_DATA_VKORG  text
*      -->P_PARVW
*      <--P_LS_OUTTAB_KUNNR  text
*----------------------------------------------------------------------*
FORM read_knvp  USING p_kunn2 TYPE knvp-kunn2
                      p_vkorg TYPE knvp-vkorg
                      p_parvw TYPE knvp-parvw
                CHANGING p_kunnr TYPE knvp-kunnr.

  IF p_kunn2 IS NOT INITIAL AND p_vkorg IS NOT INITIAL AND p_parvw IS NOT INITIAL.
    SELECT SINGLE kunnr
      INTO p_kunnr
      FROM knvp
      WHERE vkorg EQ p_vkorg
        AND parvw EQ p_parvw
        AND kunn2 EQ p_kunn2.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  READ_MAKT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATA_MATNR  text
*      <--P_LS_OUTTAB_MAKTX  text
*----------------------------------------------------------------------*
FORM read_makt  USING    p_matnr TYPE matnr
                CHANGING p_maktx TYPE maktx.

  CHECK p_matnr IS NOT INITIAL.

  SELECT SINGLE maktx
    INTO p_maktx
    FROM makt
    WHERE matnr EQ p_matnr
      AND spras EQ sy-langu.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  PROCESAR_DESVIOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM procesar_desvios CHANGING pt_outtab TYPE ty_tab_outtab
                               pref_alv  TYPE REF TO cl_gui_alv_grid.
  CONSTANTS:
    lc_object    TYPE bal_s_log-object     VALUE 'ZSCM042',
    lc_subobject TYPE bal_s_log-subobject  VALUE 'ZSCM042'.

  DATA: BEGIN OF ls_stable,
          row TYPE c VALUE 'X',
          col TYPE c VALUE 'X',
        END OF ls_stable.

*  DATA: lt_row         TYPE lvc_t_roid.
  DATA: lt_dest TYPE ty_tab_outtab2100. "Nuevos Destinatarios.
  DATA: lt_return      TYPE bapiret2_tt,
        lt_ret_aux     TYPE bapiret2_tt,
        lt_exidv       TYPE hum_exidv_t,
        lt_ua_entrega  TYPE ty_tab_ua_ent,
        lt_ped_pos     TYPE tdt_vbeln_posnr,
        lt_ent_pos     TYPE tdt_vbeln_posnr,
        lt_ent_pos_mod TYPE /spe/delivery_quant_red_t, "LEDLV_IT_GEN
        lt_ped_pos_mod TYPE /spe/delivery_quant_red_t,
        lt_item_po     TYPE bapimepoitem_tp,
        lt_item_so     TYPE bapisditm_tt,
        lt_ent_new     TYPE ty_tab_ent_new,
        lt_ent_mod     TYPE ty_tab_ent_mod,
        lt_sel_desvios TYPE ty_tab_outtab,
        lt_po_pos      TYPE sel_ebeln_ebelp_tty,
        lt_po_pos_mod  TYPE fre_ekpo_tty.

  DATA: ls_dest      TYPE ty_outtab2100,
        ls_header_po TYPE bapimepoheader,
        ls_header_so TYPE bapisdhd1.

  DATA: lv_error_pos TYPE flag,
        lv_caso      TYPE zscm_de_casodesvio,
        lv_ebeln     TYPE ekko-ebeln,
        lv_vbeln_new TYPE vbeln_vl,
        lv_error_ua  TYPE flag,
        lv_vbeln_va  TYPE vbeln_va.

  DATA: lr_type_error TYPE RANGE OF bapi_mtype.


  lr_type_error = VALUE #( sign = 'I' option = 'EQ' ( low = 'E' ) ( low = 'A' ) ).

*  CALL METHOD pref_alv->get_selected_rows
*    IMPORTING
*      et_row_no = lt_row.

  IF line_exists( pt_outtab[ sel = 'X' ] ).
    SORT pt_outtab BY tknum vbeln posnr.

    "Agrupar entregas de cada camión e identificar si destinatario actual es CM o no.
    "(aunque ya se sabe de qué flujo viene por valor/sin valor en outtab-vbelv).
    LOOP AT pt_outtab ASSIGNING FIELD-SYMBOL(<fs_outtab>) WHERE sel EQ 'X'.

      AT NEW vbeln ##LOOP_AT_OK.
        ls_dest = CORRESPONDING #( <fs_outtab> ).

        "Ajuste: Chequear si destinatario es CM en alv inicial, llegará aquí ya informado su flagcm.
*        CALL FUNCTION 'Z_SCM042_CLIENTE_CM'
*          EXPORTING
*            i_kunnr = ls_dest-kunwe
*            i_vkorg = ls_dest-vkorg
*          IMPORTING
*            e_lgort = ls_dest-lgort_we.
**           e_werks =
*
*        IF ls_dest-lgort_we IS NOT INITIAL.
*          ls_dest-flagcm = abap_true.
*        ENDIF.

        IF ls_dest-flagcm EQ abap_false.
          "Si destinatario actual es cliente y no CM (flagcm = space), entonces el nuevo destinatario
          "deberá ser CM -> permitir selección de CM por almacén y no por cliente.
          PERFORM set_col_noedit USING 'KUNWE_DEST' CHANGING ls_dest-styletab.
          PERFORM set_col_edit   USING 'LGORT_DEST' CHANGING ls_dest-styletab.
        ELSE.
          "Destinatario actual es CM -> deshabilitar campo Almacén CM.
          PERFORM set_col_nof4 USING 'LGORT_DEST' CHANGING ls_dest-styletab.

          CALL FUNCTION 'Z_SCM042_CLIENTE_CM'
            EXPORTING
              i_kunnr = ls_dest-kunwe
              i_vkorg = ls_dest-vkorg
            IMPORTING
              e_lgort = ls_dest-lgort_we.
*           e_werks =
        ENDIF.

        APPEND ls_dest TO lt_dest.
      ENDAT.
    ENDLOOP.

    gt_outtab2100 = lt_dest.
    FREE lt_dest.
    CLEAR ls_dest.

    "Introducir nuevos destinatarios:
    CALL SCREEN 2100 STARTING AT 5 4.


    IF g_okcode2100 EQ 'OK_2100'.

*--------------------------------------------------------------------*
*     1. DESVIO DE TRANSPORTE CON DESTINATARIO CLIENTE FINAL A CM:
*     Cliente->CM
*--------------------------------------------------------------------*
      LOOP AT gt_outtab2100 ASSIGNING FIELD-SYMBOL(<fs_dest>) WHERE flagcm EQ space AND flagcm_dest EQ 'X'. "De Cliente a CM.
        AT NEW tknum.
          FREE: lt_ua_entrega,  "Guarda UAs de entregas originales.
                lt_ent_new,     "Relación entrega nueva y entrega original.
                lt_ent_mod.     "Guarda entregas cuyos pedidos se han modificado/reducido.

          "Desvío Cliente->CM: transporte".
          PERFORM fill_return USING 'S' 'ZSCM042' '003' <fs_dest>-tknum space space space CHANGING lt_return.
        ENDAT.

        "Inicio-entrega".
        PERFORM fill_return USING 'S' 'ZSCM042' '007' <fs_dest>-vbeln space space space CHANGING lt_return.

        "Evaluar casos de desvío para Entrega:
        lt_sel_desvios = VALUE #( FOR wa_out IN gt_outtab WHERE ( tknum = <fs_dest>-tknum ) ( wa_out ) ).

        CALL FUNCTION 'Z_SCM042_CASO_DESVIO_TRANSP'
          EXPORTING
            i_tknum        = <fs_dest>-tknum
            i_vbeln        = <fs_dest>-vbeln
            it_sel_desvios = lt_sel_desvios
          IMPORTING
            e_caso         = lv_caso.

        "*************************************************************
        PERFORM fill_return USING 'I' 'ZSCM042' '000' lv_caso space space space CHANGING lt_return.
        "*************************************************************

        ">-Anular Salida Mercancías (SM):
        "(todos los casos).

        "NOTA: Llamada en una pila nueva con rfc destination none, evita errores
        "en las llamadas posteriores a funciones SD en las funciones ZWM.
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ANULAR_SM_ENTREGA' DESTINATION 'NONE'
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">Ajuste: Desasignar entrega del transporte antes de Anular Picking, la entrega puede tener
        "posiciones de partición de lotes, que se han de eliminar en el último paso (botón) de Anular Picking.
        "Se reinician estados del transporte en la misma acción.
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
            i_tknum   = <fs_dest>-tknum
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">-Anular picking WM de la entrega igual que tcode ZSWMSDLT0G:
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ANULAR_PICKING_WM'
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">-Con pistola, devolución de stock a ubicación de posiciones afectadas:
        "(todos los casos, por POSICIÓN).

        "Inicio devolución stock".
        PERFORM fill_return USING 'S' 'ZSCM042' '034' <fs_dest>-vbeln space space space CHANGING lt_return.

        CLEAR lv_error_pos.
        LOOP AT pt_outtab INTO DATA(wa_outtab) WHERE vbeln EQ <fs_dest>-vbeln AND sel EQ 'X'.
          FREE: lt_ret_aux.
          FREE lt_exidv.

          CALL FUNCTION 'Z_SCM042_DEVOLUCION_STOCK_WM'
            EXPORTING
              i_tknum       = wa_outtab-tknum
*             I_LGPLA       = 'DESVIOS'
              i_vbeln       = wa_outtab-vbeln
              i_posnr       = wa_outtab-posnr
              i_uecha       = wa_outtab-uecha
              i_matnr       = wa_outtab-matnr
              i_charg       = wa_outtab-charg
              i_cant_desvio = wa_outtab-cant_desvio  "*
            IMPORTING
              et_return     = lt_ret_aux
              et_exidv      = lt_exidv.

          IF lt_exidv IS NOT INITIAL.
            "Guardar UAs de cada entrega del mismo transporte.
            lt_ua_entrega = VALUE #( BASE lt_ua_entrega FOR wa_exidv IN lt_exidv ( CORRESPONDING #(
                                     BASE ( VALUE #( tknum = wa_outtab-tknum  vbeln = wa_outtab-vbeln  posnr = wa_outtab-posnr ) )
                                     wa_exidv ) ) ).
          ENDIF.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            lv_error_pos = 'X'.
            EXIT.
          ENDLOOP.
        ENDLOOP.

        IF lv_error_pos EQ 'X'.
          CLEAR lv_error_pos.
          EXIT. "Siguiente transporte.
        ENDIF.

        "Chequeo adicional:
        IF lt_ua_entrega IS INITIAL.
          "No se han podido recuperar UAs durante devolución stock entrega".
          PERFORM fill_return USING 'E' 'ZSCM042' '050' <fs_dest>-vbeln space space space CHANGING lt_return.
          EXIT. "Siguiente transporte.
        ENDIF.

        "Fin devolución stock".
        PERFORM fill_return USING 'S' 'ZSCM042' '035' <fs_dest>-vbeln space space space CHANGING lt_return.
**        SORT lt_ua_entrega BY vbeln posnr.
        "<-fin devolución stock WM.


        ">--Eliminar posiciones de entrega (Caso 3) / Reducir cantidad posición pedido (Caso 4) y Contabilizar SM entrega original.
        "(El paso Contabilizar SM entrega original lo hará la acción posterior "Dar Salida").

        "Los casos 3 y 4 pueden darse mezclados en posiciones dentro de una misma entrega, tratar cada una según corresponda.
        IF lv_caso EQ '3' OR lv_caso EQ '4'.

*          "a-Para ELIMINAR posiciones de entrega / REDUCIR cant.pos.pedido, primero DESASIGNAR la entrega del transporte.
*          "Se reinician estados del transporte en la misma acción.
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*              i_tknum   = <fs_dest>-tknum
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*            EXIT. "Siguiente transporte.
*          ENDIF.

          "b-Después de desasignar la entrega, entonces tratar las posiciones:

          ">b.1 -Eliminar posiciones de entrega (Caso 3):
          FREE: lt_ret_aux, lt_ent_pos.

          lt_ent_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                                AND wa_out-posnr(1) NE '9'  "En Anular Picking ya se han eliminado particiones lote.
                                THEN VALUE #( ( vbeln = wa_out-vbeln  posnr = wa_out-posnr ) )
                                ) ) ).

          IF lt_ent_pos IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_ELIMINAR_POS_ENTREGA'
              EXPORTING
                it_ent_pos = lt_ent_pos
              IMPORTING
                et_return  = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
          "<b.1

          ">b.2 -Reducir cantidad posiciones del pedido venta a cliente afectadas (Caso 4):
          FREE: lt_ret_aux,
                lt_ped_pos_mod.

          lt_ped_pos_mod = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                    WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio NE wa_out-lfimg "<>
                                     AND wa_out-uecha IS INITIAL
                                    THEN VALUE #( ( document_number = wa_out-vgbel
                                                    document_item   = wa_out-vgpos
                                                    delivery_number = wa_out-vbeln
                                                    delivery_item   = wa_out-posnr
                                                    quantity_chg    = wa_out-cant_desvio
                                                    base_uom        = wa_out-vrkme ) )
                                    "Caso partición lotes: Se reduce la cantidad de cada partición individual seleccionada.
                                    WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-uecha IS NOT INITIAL
                                    THEN VALUE #( ( document_number = wa_out-vgbel
                                                    document_item   = wa_out-vgpos
                                                    delivery_number = wa_out-vbeln
                                                    delivery_item   = wa_out-posnr
                                                    quantity_chg    = wa_out-cant_desvio
                                                    base_uom        = wa_out-vrkme ) )
                                                    ) ) ).

          "IMPORTANTE: La actualización de la cantidad de la posición de la ENTREGA afectada se actualiza "automáticamente"
          "al reducir la cantidad de PICKING (paso posterior con las funciones ZWM, aqui solo modificar el pedido).

          IF lt_ped_pos_mod IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_MODIFICAR_POS_PEDIDO'
              EXPORTING
                it_ped_pos_mod = lt_ped_pos_mod
              IMPORTING
                et_return      = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.

            "Guardar entregas cuyos pedidos se han modificado/reducido, para luego asignar UAs restantes.
            lt_ent_mod = VALUE #( BASE lt_ent_mod ( VALUE #( tknum = <fs_dest>-tknum
                                                             vbeln = <fs_dest>-vbeln )  ) ).
          ENDIF.
          "<b.2

          "c-Tratadas las posiciones, volver a asignar la entrega al transporte.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_ASIGNAR_ENT_TRANSP'
            EXPORTING
              i_vbeln   = <fs_dest>-vbeln
              i_tknum   = <fs_dest>-tknum
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
        ENDIF.
        "<--fin Eliminar/Reducir


*        ">-Desasignar entregas del transporte.
*        "(solo Casos 1 y 2)
*        IF lv_caso EQ '1' OR lv_caso EQ '2'.
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*              i_tknum   = <fs_dest>-tknum
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*            EXIT. "Siguiente transporte.
*          ENDIF.
*          "<

        "Eliminar entrega original solo después de haberse creado correctamente la entrega nueva, si aplica el caso.
*          ">-Eliminar/anular entrega con Destinatario Cliente.
*          "(solo casos 1 y 2)
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_ELIMINAR_ENTREGA'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*          exit. "Siguiente transporte.
*          ENDIF.
*          "<
*        ENDIF.  "casos: Desasignar y Eliminar entregas.


        ">-Rechazar las posiciones del pedido de venta a cliente.
        "El caso 4 puede incluir posiciones caso 3 en la misma entrega -> rechazar solo esas del 3  = cantidades desvío iguales).
        IF lv_caso EQ '3' OR lv_caso EQ '4'.

          FREE: lt_ret_aux,
                lt_ped_pos.

          lt_ped_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                                 AND wa_out-posnr(1) NE '9'  "No bloquear/rechazar en partición lotes porque la pos-ped está repartida en las particiones.
                                THEN VALUE #( ( vbeln = wa_out-vgbel  posnr = wa_out-vgpos ) )  ) ) ).

          "Bloq+Rech2
          IF lt_ped_pos IS NOT INITIAL.

            CALL FUNCTION 'Z_SCM042_BLOQUEAR_POS_PEDIDO'
              EXPORTING
                it_ped_pos = lt_ped_pos
*               I_LIFSP    = 'ZC'
              IMPORTING
                et_return  = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.

            "MTS: 10.10.2024 Se define el Martes 08.10.2024 para que no se rechace ninguna posición. Comentamos esta parte de código.
*            FREE: lt_ret_aux.
*            CALL FUNCTION 'Z_SCM042_RECHAZAR_POS_PEDIDO'
*              EXPORTING
*                it_ped_pos = lt_ped_pos
**               I_ABGRU    = 'Z5'
*              IMPORTING
*                et_return  = lt_ret_aux.
*
*            APPEND LINES OF lt_ret_aux TO lt_return.
*            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*              EXIT.
*            ENDLOOP.
*            IF sy-subrc EQ 0.
*              EXIT. "Siguiente transporte.
*            ENDIF.
            "MTS: FIN 10.10.2024 Se define el Martes 08.10.2024 para que no se rechace ninguna posición. Comentamos esta parte de código.
          ENDIF.
        ENDIF.  "casos Rechazar posiciones pedido ventas.
        "<


        ">-Creación de pedido de traslado de planta a CM.
        "(para todos los casos, teniendo en cuenta cant.parciales Caso 4).
        FREE lt_ret_aux.
        CLEAR lv_ebeln.

        CLEAR ls_header_po.
        FREE lt_item_po.

        "Pasar datos de antigua entrega ventas a nuevo pedido compras:
        "Cabecera: no es necesario, se derivan datos de kunwe y de vkorg, pero se pueden pasar parámetros si es requerido.
        "Posiciones: pasar datos mínimos: material, cantidad, etc.
        lt_item_po = VALUE #( FOR wa_out IN pt_outtab WHERE ( vbeln EQ <fs_dest>-vbeln AND sel = 'X' )
                            ( VALUE #( material    = wa_out-matnr        "Material entrega.
                                       quantity    = COND #( WHEN wa_out-cant_desvio EQ wa_out-lfimg THEN wa_out-lfimg
                                                             WHEN wa_out-cant_desvio NE wa_out-lfimg THEN wa_out-cant_desvio ) "Cant.parcial.
                                       po_unit     = wa_out-vrkme        "UM.
                                       plant       = wa_out-werks        "Centro entrega.
                                       batch       = wa_out-charg        "Lote entrega
                                       suppl_stloc = wa_out-lgort        "Almacén entrega
                                       ) ) ).

        ">**********************************************************************
        "Ajuste: Liberar stock pedido cliente del pedido venta/entrega original antes de crear nuevo pedido y su entrega.
        FREE lt_exidv.
        lt_exidv = VALUE #( FOR wa_ua IN lt_ua_entrega WHERE ( tknum EQ <fs_dest>-tknum AND vbeln EQ <fs_dest>-vbeln )
                              ( CORRESPONDING #( wa_ua ) ) ).

        CALL FUNCTION 'Z_SCM042_LIBERAR_STOCK'
          EXPORTING
            it_item   = lt_item_po
            it_exidv  = lt_exidv
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<**********************************************************************

        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_CREAR_PEDIDO_TRASLADO'
          EXPORTING
            i_kunnr_cm = <fs_dest>-kunwe_dest
            i_vkorg    = <fs_dest>-vkorg
*           IS_HEADER  =
            it_item    = lt_item_po
          IMPORTING
            et_return  = lt_ret_aux
            e_ebeln    = lv_ebeln.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<-fin pedido traslado.

        ">-Creación entrega de salida de traslado.
        "(todos los casos)
        FREE lt_ret_aux.
        CLEAR lv_vbeln_new.

        CALL FUNCTION 'Z_SCM042_CREAR_ENT_TRASLADO'
          EXPORTING
            i_ebeln    = lv_ebeln
          IMPORTING
            et_return  = lt_ret_aux
            e_vbeln_vl = lv_vbeln_new.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "Guardar nueva entrega con referencia a la entrega original, para luego recuperar sus correspondientes UAs.
        lt_ent_new = VALUE #( BASE lt_ent_new ( tknum = <fs_dest>-tknum  vbeln = lv_vbeln_new  vbeln_ref = <fs_dest>-vbeln
                                                ebeln = lv_ebeln ) ).
        "<-fin entrega traslado.


        "**********************************************************************
        ">-Eliminar entrega con Destinatario Cliente.
        "(solo casos 1 y 2, después de haberse creado la entrega nueva).
        IF lv_caso EQ '1' OR lv_caso EQ '2'.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_ELIMINAR_ENTREGA'
            EXPORTING
              i_vbeln   = <fs_dest>-vbeln
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          ">-Bloquear + Rechazar las posiciones del pedido de venta a cliente.
          "Bloq+Rech1
          FREE: lt_ret_aux,
                lt_ped_pos.

          lt_ped_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                                THEN VALUE #( ( vbeln = wa_out-vgbel  posnr = wa_out-vgpos ) )  ) ) ).

          IF lt_ped_pos IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_BLOQUEAR_POS_PEDIDO'
              EXPORTING
                it_ped_pos = lt_ped_pos
*               I_LIFSP    = 'ZC'
              IMPORTING
                et_return  = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.

            "MTS: 10.10.2024 Se define el Martes 08.10.2024 para que no se rechace ninguna posición. Comentamos esta parte de código.
*            FREE lt_ret_aux.
*            CALL FUNCTION 'Z_SCM042_RECHAZAR_POS_PEDIDO'
*              EXPORTING
*                it_ped_pos = lt_ped_pos
**               I_ABGRU    = 'Z5'
*              IMPORTING
*                et_return  = lt_ret_aux.
*
*            APPEND LINES OF lt_ret_aux TO lt_return.
*            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*              EXIT.
*            ENDLOOP.
*            IF sy-subrc EQ 0.
*              EXIT. "Siguiente transporte.
*            ENDIF.
            "MTS: FIN 10.10.2024 Se define el Martes 08.10.2024 para que no se rechace ninguna posición. Comentamos esta parte de código.

          ENDIF.
          "<
        ENDIF.  "casos: Eliminar entregas y Bloquear + Rechazar pos.pedido vtas.
        "**********************************************************************


        ">-Asignar NUEVA entrega al documento de transporte.
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ASIGNAR_ENT_TRANSP'
          EXPORTING
            i_vbeln   = lv_vbeln_new    "Nueva entrega.
            i_tknum   = <fs_dest>-tknum
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<-fin asignar entrega.

*        "Fin-entrega".
*        PERFORM fill_return USING 'S' 'ZSCM042' '008' <fs_dest>-vbeln space space space CHANGING lt_return.

*--------------------------------------------------------------------*
        AT END OF tknum.  "1.
*--------------------------------------------------------------------*
          "Después de asignar todas las entregas NUEVAS en el transporte actual:
          ">Reiniciar estados del transporte con "Inicio Carga".
          FREE lt_ret_aux.

          CALL FUNCTION 'Z_SCM042_INICIAR_CARGA_WM'
            EXPORTING
              i_tknum   = <fs_dest>-tknum
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          ">-Hacer "Lectura de bulto" de las UAs guardadas de todas las entregas-posiciones tratadas en este transporte.
          "(Picking con aplicativo WM con mismas UAS utilizadas en la expedición REAL)
          FREE lt_exidv.
          CLEAR lv_error_ua.

          "(todos los casos, para cada entrega-pos NUEVOS).
          LOOP AT lt_ent_new INTO DATA(ls_ent_new).
            FREE: lt_ret_aux.

            lt_exidv = VALUE #( FOR wa_ua IN lt_ua_entrega WHERE ( tknum EQ <fs_dest>-tknum AND vbeln EQ ls_ent_new-vbeln_ref )
                              ( CORRESPONDING #( wa_ua ) ) ).

            CALL FUNCTION 'Z_SCM042_LEER_BULTO_PICKING_WM'
              EXPORTING
                i_tknum   = <fs_dest>-tknum
                i_vbeln   = ls_ent_new-vbeln
                it_exidv  = lt_exidv
              IMPORTING
                et_return = lt_ret_aux
                et_exidv  = lt_exidv.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              lv_error_ua = 'X'.
              EXIT.
            ENDLOOP.

            "Marcar si ha sobrado alguna UA en la entrega nueva, significa que se ha modificado la entrega original,
            "tener en cuenta estas UAs para el picking en la entrega original.
            LOOP AT lt_exidv INTO DATA(ls_exidv).
              LOOP AT lt_ua_entrega ASSIGNING FIELD-SYMBOL(<fs_ua_entrega>) WHERE exidv EQ ls_exidv.
                <fs_ua_entrega>-libre = 'X'.
              ENDLOOP.
            ENDLOOP.

            "--->>Ajuste1: problemas de bloqueo en POs nuevas por Leer Bulto en WM:
            FREE lt_ret_aux.
            CALL FUNCTION 'Z_SCM042_CHEQUEO_BLOQUEO_PO'
              EXPORTING
                i_ebeln   = ls_ent_new-ebeln
*               I_UNAME   = SY-UNAME
*               I_MODE    = 1
*               I_TIMES   = 10
*               I_SECONDS = 1
              IMPORTING
                et_return = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            "---<<
          ENDLOOP.

          IF lv_error_ua EQ 'X'.
            CLEAR lv_error_ua.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<-

          ">--Lectura bulto UAs entregas con pedido modificado-reducido
          CLEAR lv_error_ua.

          "(todos los casos, para cada entrega-pos pedido REDUCIDO).
          LOOP AT lt_ent_mod INTO DATA(ls_ent_mod).
            FREE lt_ret_aux.

            lt_exidv = VALUE #( FOR wa_ua IN lt_ua_entrega
                                WHERE ( tknum EQ <fs_dest>-tknum AND vbeln EQ ls_ent_mod-vbeln AND libre EQ 'X' )
                              ( CORRESPONDING #( wa_ua ) ) ).

            "En caso de partición lotes, puede que no queden UAs "libres" porque en realidad solo se han repartido algunas UAs
            "de particiones en las entregas nuevas, y el resto puede haberse quedado asignado en las entregas originales.
            IF lt_exidv IS NOT INITIAL.
              CALL FUNCTION 'Z_SCM042_LEER_BULTO_PICKING_WM'
                EXPORTING
                  i_tknum   = <fs_dest>-tknum
                  i_vbeln   = ls_ent_mod-vbeln
                  it_exidv  = lt_exidv
                IMPORTING
                  et_return = lt_ret_aux
                  et_exidv  = lt_exidv.

              APPEND LINES OF lt_ret_aux TO lt_return.
              LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
                lv_error_ua = 'X'.
                EXIT.
              ENDLOOP.
            ENDIF.  "lt_exidv not initial.
          ENDLOOP.

          IF lv_error_ua EQ 'X'.
            CLEAR lv_error_ua.
            EXIT. "Siguiente transporte.
          ENDIF.
          "Nota: No haría falta desmarcar las últimas UAs usadas por cada entrega original.
          "<--

          "--->>Ajuste3: problemas de bloqueo en POs nuevas por Cerrar Transporte WM:
          LOOP AT lt_ent_new INTO ls_ent_new.
            FREE lt_ret_aux.
            CALL FUNCTION 'Z_SCM042_CHEQUEO_BLOQUEO_PO'
              EXPORTING
                i_ebeln   = ls_ent_new-ebeln
*               I_UNAME   = SY-UNAME
*               I_MODE    = 1
*               I_TIMES   = 10
*               I_SECONDS = 1
              IMPORTING
                et_return = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
          ENDLOOP.
          "---<<

          ">Por si acaso (solo ha ocurrido en Cerrar Transporte de la pistola): chequeo bloqueo entregas modificadas.
          LOOP AT lt_ent_mod INTO ls_ent_mod.
            FREE lt_ret_aux.
            CALL FUNCTION 'Z_SCM042_CHEQUEO_BLOQ_ENTREGA'
              EXPORTING
                i_vbeln_vl = ls_ent_mod-vbeln
*               I_UNAME    = SY-UNAME
*               I_TIMES    = 10
*               I_SECONDS  = 1
              IMPORTING
                et_return  = lt_ret_aux.
            APPEND LINES OF lt_ret_aux TO lt_return.
          ENDLOOP.
          "<


          ">Cerrar transporte: Se crean posiciones de pallets.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_CERRAR_TRANSP_WM'
            EXPORTING
              i_tknum      = <fs_dest>-tknum
              i_cierra     = 'X'
              i_dar_salida = ' '
            IMPORTING
              et_return    = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          "--->>Ajuste2: problemas de bloqueo en POs nuevas por Cerrar Transporte WM:
          LOOP AT lt_ent_new INTO ls_ent_new.
            FREE lt_ret_aux.
            CALL FUNCTION 'Z_SCM042_CHEQUEO_BLOQUEO_PO'
              EXPORTING
                i_ebeln   = ls_ent_new-ebeln
*               I_UNAME   = SY-UNAME
*               I_MODE    = 1
*               I_TIMES   = 10
*               I_SECONDS = 1
              IMPORTING
                et_return = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
          ENDLOOP.
          "---<<


          ">Dar salida: Se contabilizan las SM de entregas.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_CERRAR_TRANSP_WM'
            EXPORTING
              i_tknum      = <fs_dest>-tknum
              i_cierra     = ' '
              i_dar_salida = 'X'
            IMPORTING
              et_return    = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          "Fin Desvío transporte".
          PERFORM fill_return USING 'S' 'ZSCM042' '016' <fs_dest>-tknum space space space CHANGING lt_return.
        ENDAT.
      ENDLOOP.  "1.recorrer desvíos Cliente a CM.

*--------------------------------------------------------------------*
*     2. DESVIO DE TRANSPORTE CON DESTINATARIO CM A CLIENTE FINAL:
*     CM->Cliente
*--------------------------------------------------------------------*
      LOOP AT gt_outtab2100 ASSIGNING <fs_dest> WHERE flagcm EQ 'X' AND flagcm_dest EQ space. "De CM a Cliente.
        AT NEW tknum.
          FREE: lt_ua_entrega,  "Guarda UAs de entregas originales.
                lt_ent_new,     "Relación entrega nueva y entrega original.
                lt_ent_mod.     "Guarda entregas cuyos pedidos se han modificado/reducido.

          "Desvío CM->Cliente: transporte".
          PERFORM fill_return USING 'S' 'ZSCM042' '006' <fs_dest>-tknum space space space CHANGING lt_return.
        ENDAT.

        "Inicio-entrega".
        PERFORM fill_return USING 'S' 'ZSCM042' '007' <fs_dest>-vbeln space space space CHANGING lt_return.

        "Evaluar casos de desvío para Entrega:
        lt_sel_desvios = VALUE #( FOR wa_out IN gt_outtab WHERE ( tknum = <fs_dest>-tknum ) ( wa_out ) ).

        CALL FUNCTION 'Z_SCM042_CASO_DESVIO_TRANSP'
          EXPORTING
            i_tknum        = <fs_dest>-tknum
            i_vbeln        = <fs_dest>-vbeln
            it_sel_desvios = lt_sel_desvios
          IMPORTING
            e_caso         = lv_caso.

        "*************************************************************
        PERFORM fill_return USING 'I' 'ZSCM042' '000' lv_caso space space space CHANGING lt_return.
        "*************************************************************

        ">ELIMINAR Entrega entrante.
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ELIMINAR_ENTREGA_ENT'
          EXPORTING
            i_vbeln_v = <fs_dest>-vbeln
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">-Anular Salida Mercancías (SM):
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ANULAR_SM_ENTREGA' DESTINATION 'NONE' "*
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">Ajuste: Desasignar entrega del transporte antes de Anular Picking, la entrega puede tener
        "posiciones de partición de lotes, que se han de eliminar en el último paso (botón) de Anular Picking.
        "Se reinician estados del transporte en la misma acción.
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
            i_tknum   = <fs_dest>-tknum
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">-Anular picking WM de la entrega igual que tcode ZSWMSDLT0G:
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ANULAR_PICKING_WM'
          EXPORTING
            i_vbeln   = <fs_dest>-vbeln
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<

        ">-Con pistola, devolución de stock a ubicación de posiciones afectadas:
        "(todos los casos, por POSICIÓN).

        "Inicio devolución stock".
        PERFORM fill_return USING 'S' 'ZSCM042' '034' <fs_dest>-vbeln space space space CHANGING lt_return.

        CLEAR lv_error_pos.
        LOOP AT pt_outtab INTO wa_outtab WHERE vbeln EQ <fs_dest>-vbeln AND sel EQ 'X'.
          FREE: lt_ret_aux.
          FREE lt_exidv.

          CALL FUNCTION 'Z_SCM042_DEVOLUCION_STOCK_WM'
            EXPORTING
              i_tknum       = wa_outtab-tknum
*             I_LGPLA       = 'DESVIOS'
              i_vbeln       = wa_outtab-vbeln
              i_posnr       = wa_outtab-posnr
              i_uecha       = wa_outtab-uecha
              i_matnr       = wa_outtab-matnr
              i_charg       = wa_outtab-charg
              i_cant_desvio = wa_outtab-cant_desvio  "*
            IMPORTING
              et_return     = lt_ret_aux
              et_exidv      = lt_exidv.

          IF lt_exidv IS NOT INITIAL.
            "Guardar UAs de cada entrega del mismo transporte.
            lt_ua_entrega = VALUE #( BASE lt_ua_entrega FOR wa_exidv IN lt_exidv ( CORRESPONDING #(
                                     BASE ( VALUE #( tknum = wa_outtab-tknum  vbeln = wa_outtab-vbeln  posnr = wa_outtab-posnr ) )
                                     wa_exidv ) ) ).
          ENDIF.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            lv_error_pos = 'X'.
            EXIT.
          ENDLOOP.
        ENDLOOP.

        IF lv_error_pos EQ 'X'.
          CLEAR lv_error_pos.
          EXIT. "Siguiente transporte.
        ENDIF.

        "Chequeo adicional:
        IF lt_ua_entrega IS INITIAL.
          "No se han podido recuperar UAs durante devolución stock entrega".
          PERFORM fill_return USING 'E' 'ZSCM042' '050' <fs_dest>-vbeln space space space CHANGING lt_return.
          EXIT. "Siguiente transporte.
        ENDIF.

        "Fin devolución stock".
        PERFORM fill_return USING 'S' 'ZSCM042' '035' <fs_dest>-vbeln space space space CHANGING lt_return.
        "<-fin devolución stock WM.


        ">--Eliminar posiciones de entrega (Caso 3) / Reducir cantidad posición pedido (Caso 4) y Contabilizar SM entrega original.
        "(El paso Contabilizar SM entrega original lo hará la acción posterior "Dar Salida").

        "Los casos 3 y 4 pueden darse mezclados en posiciones dentro de una misma entrega, tratar cada una según corresponda.
        IF lv_caso EQ '3' OR lv_caso EQ '4'.

*          "a-Para ELIMINAR posiciones de entrega / REDUCIR cant.pos.ENTREGA y PO, primero DESASIGNAR la entrega del transporte.
*          "Se reinician estados del transporte en la misma acción.
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*              i_tknum   = <fs_dest>-tknum
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*            EXIT. "Siguiente transporte.
*          ENDIF.

          "**********************************************************************
          ">>Ajuste posterior a "Anular picking" (ZSWM_LT0G_UNPACK) en caso de entregas de salida de POs (Desvío CM->Cliente):
          "Revisar si ZSWM_LT0G_UNPACK no borró las posiciones de embalaje -> borrarlas, durante entrega desasignada del transporte.
          DATA: lr_mtart_pallet TYPE RANGE OF mtart.

          FREE: lt_ret_aux, lt_ent_pos.
          lr_mtart_pallet = VALUE #( sign = 'I' option = 'EQ' ( low = 'ZPAL' ) ).

          SELECT vbeln posnr
            INTO TABLE lt_ent_pos
            FROM lips
            WHERE vbeln EQ <fs_dest>-vbeln
              AND mtart IN lr_mtart_pallet.

          IF sy-subrc EQ 0.
            CALL FUNCTION 'Z_SCM042_ELIMINAR_POS_ENTREGA'
              EXPORTING
                it_ent_pos = lt_ent_pos
              IMPORTING
                et_return  = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
          "<<ajuste borrado posiciones embalaje.
          "**********************************************************************

          "b-Después de desasignar la entrega, entonces tratar las posiciones:

          ">b.1 -Eliminar posiciones de entrega (Caso 3):
          FREE: lt_ret_aux, lt_ent_pos.

          lt_ent_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                                AND wa_out-posnr(1) NE '9'  "En Anular Picking ya se han eliminado particiones lote.
                                THEN VALUE #( ( vbeln = wa_out-vbeln  posnr = wa_out-posnr ) )
                                ) ) ).

          IF lt_ent_pos IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_ELIMINAR_POS_ENTREGA'
              EXPORTING
                it_ent_pos = lt_ent_pos
              IMPORTING
                et_return  = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
          "<b.1

          ">b.2a -Reducir las cantidades parciales de las posiciones de entregas de traslado (Caso 4):
          FREE: lt_ret_aux, lt_ent_pos_mod.

          lt_ent_pos_mod = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                    WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio NE wa_out-lfimg  "<>
                                     AND wa_out-uecha IS INITIAL
                                    THEN VALUE #( ( delivery_number = wa_out-vbeln
                                                    delivery_item   = wa_out-posnr
                                                    quantity_chg    = wa_out-cant_desvio
                                                    base_uom        = wa_out-vrkme ) )

"Con partición de lotes, la entrega original debería tener en este punto solo cada posición superior normal con la cant.total
"de sus particiones correspondientes, dichas posiciones de particiones ya se han "eliminado" en el paso "Anular picking".
"Entonces: ajustar cantidades de esas posiciones originales.
                                    WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-uecha IS NOT INITIAL
                                    THEN VALUE #( ( delivery_number = wa_out-vbeln
                                                    delivery_item   = wa_out-uecha    "*Pos.superior de la partición.
                                                    quantity_chg    = wa_out-cant_desvio
                                                    base_uom        = wa_out-vrkme ) )
                                                    ) ) ).
          IF lt_ent_pos_mod IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_MODIFICAR_POS_ENTREGA'
              EXPORTING
                it_ent_pos_mod = lt_ent_pos_mod
              IMPORTING
                et_return      = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.

            "Guardar entregas que se han modificado/reducido (lt_ENT_pos_mod), para luego asignar UAs restantes.
            lt_ent_mod = VALUE #( BASE lt_ent_mod ( VALUE #( tknum = <fs_dest>-tknum
                                                             vbeln = <fs_dest>-vbeln )  ) ).
          ENDIF.
          "<b.2a


          ">b.2b -Modificar posiciones del pedido de traslado (PO) a centro de montaje (Caso 4):
          FREE: lt_ret_aux,
                lt_po_pos_mod.

          lt_po_pos_mod = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                                   WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio NE wa_out-lfimg  "<>
                                    AND wa_out-uecha IS INITIAL
                                   THEN VALUE #( ( ebeln = wa_out-vgbel
                                                   ebelp = wa_out-vgpos
                                                   menge = wa_out-cant_desvio
                                                   meins = wa_out-vrkme ) )
                                    "Caso partición lotes: Se reduce la cantidad de cada partición individual seleccionada.
                                   WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-uecha IS NOT INITIAL
                                   THEN VALUE #( ( ebeln = wa_out-vgbel
                                                   ebelp = wa_out-vgpos
                                                   menge = wa_out-cant_desvio
                                                   meins = wa_out-vrkme ) )
                                                   ) ) ).
          IF lt_po_pos_mod IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_MODIFICAR_POS_PO'
              EXPORTING
                it_po_pos_mod = lt_po_pos_mod
              IMPORTING
                et_return     = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
          "<b.2b

          "c-Tratadas las posiciones, volver a asignar la entrega al transporte.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_ASIGNAR_ENT_TRANSP'
            EXPORTING
              i_vbeln   = <fs_dest>-vbeln
              i_tknum   = <fs_dest>-tknum
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
        ENDIF.
*        "<--fin Eliminar/Reducir


*        ">-Desasignar entregas del transporte.
*        "(solo Casos 1 y 2)
*        IF lv_caso EQ '1' OR lv_caso EQ '2'.
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_DESASIGNAR_ENT_TRANSP'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*              i_tknum   = <fs_dest>-tknum
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*            EXIT. "Siguiente transporte.
*          ENDIF.
*          "<

        "Eliminar entrega original solo después de haberse creado correctamente la entrega nueva, si aplica el caso.
*          ">-Eliminar entrega con ***destinatario CM***
*          "(solo casos 1 y 2)
*          FREE lt_ret_aux.
*          CALL FUNCTION 'Z_SCM042_ELIMINAR_ENTREGA'
*            EXPORTING
*              i_vbeln   = <fs_dest>-vbeln
*            IMPORTING
*              et_return = lt_ret_aux.
*
*          APPEND LINES OF lt_ret_aux TO lt_return.
*          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
*            EXIT.
*          ENDLOOP.
*          IF sy-subrc EQ 0.
*          exit. "Siguiente transporte.
*          ENDIF.
*          "<
*        ENDIF. "casos: Desasignar y Eliminar entregas.


        ">-Rechazar (marcar para borrado) posiciones del pedido de Traslado (PO) a CM
*       "El caso 4 puede incluir posiciones caso 3 en la misma entrega -> tratar solo esas del 3  = cantidades desvío iguales).
        IF lv_caso EQ '3' OR lv_caso EQ '4'.

          FREE: lt_ret_aux,
                lt_po_pos.

          lt_po_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                               WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                                AND wa_out-posnr(1) NE '9'  "No marcar borrado en partición lotes porque la pos-PO está repartida en las particiones.
                               THEN VALUE #( ( ebeln = wa_out-vgbel  ebelp = wa_out-vgpos ) )  ) ) ).

          IF lt_po_pos IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_BORRAR_POS_PO'
              EXPORTING
                it_po_pos = lt_po_pos
              IMPORTING
                et_return = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
        ENDIF.  "casos Rechazar (marcar para borrado) posiciones de pedido compras.
        "<

        ">-Creación de pedido de CLIENTE.
        "(para todos los casos, teniendo en cuenta cant.parciales Caso 4).
        FREE lt_ret_aux.
        CLEAR lv_vbeln_va.

        CLEAR ls_header_so.
        FREE lt_item_so.

        "Pasar datos de antigua entrega compras a nuevo pedido de ventas:
        "Cabecera: no es necesario, se derivan datos de kunwe y de vkorg, pero se pueden pasar parámetros si es requerido.
        "Posiciones: pasar datos mínimos: material, cantidad, etc.
        lt_item_so = VALUE #( FOR wa_out IN pt_outtab WHERE ( vbeln EQ <fs_dest>-vbeln AND sel = 'X' )
                            ( VALUE #( material    = wa_out-matnr     "Material entrega.
                                       target_qty  = COND #( WHEN wa_out-cant_desvio EQ wa_out-lfimg THEN wa_out-lfimg
                                                             WHEN wa_out-cant_desvio NE wa_out-lfimg THEN wa_out-cant_desvio ) "Cant.parcial.
                                       target_qu   = wa_out-vrkme     "UM.
                                       plant       = wa_out-werks     "Centro entrega.
                                       batch       = wa_out-charg     "Lote entrega
                                       store_loc   = wa_out-lgort     "Almacén entrega
                                    ) ) ).

        CALL FUNCTION 'Z_SCM042_CREAR_PEDIDO_CLIENTE'
          EXPORTING
            i_kunnr         = <fs_dest>-kunwe_dest
            i_vkorg         = <fs_dest>-vkorg
*           IS_HEADER       =
            it_item         = lt_item_so
          IMPORTING
            et_return       = lt_ret_aux
            e_salesdocument = lv_vbeln_va.   "Nuevo pedido Cliente.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<-fin pedido cliente.

        ">-Creación entrega de salida a CLIENTE:
        "(todos los casos)
        FREE lt_ret_aux.
        CLEAR lv_vbeln_new.

        CALL FUNCTION 'Z_SCM042_CREAR_ENT_CLIENTE'
          EXPORTING
            i_vbeln_va = lv_vbeln_va
          IMPORTING
            et_return  = lt_ret_aux
            e_vbeln_vl = lv_vbeln_new.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "Guardar nueva entrega con referencia a la entrega original, para luego recuperar sus correspondientes UAs.
        lt_ent_new = VALUE #( BASE lt_ent_new ( tknum = <fs_dest>-tknum  vbeln = lv_vbeln_new  vbeln_ref = <fs_dest>-vbeln ) ).
        "<-fin entrega CLIENTE.


        "**********************************************************************
        ">-Eliminar entrega con *destinatario CM*
        "(solo casos 1 y 2)
        IF lv_caso EQ '1' OR lv_caso EQ '2'.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_ELIMINAR_ENTREGA'
            EXPORTING
              i_vbeln   = <fs_dest>-vbeln
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          ">-Rechazar (marcar para borrado) posiciones del pedido de Traslado (PO) a CM
          "(Casos: 1, 2 despues de eliminar la entrega original, todo al final.
          FREE: lt_ret_aux,
                lt_po_pos.

          lt_po_pos = VALUE #( FOR wa_out IN pt_outtab ( LINES OF COND #(
                               WHEN wa_out-vbeln EQ <fs_dest>-vbeln AND wa_out-sel = 'X' AND wa_out-cant_desvio EQ wa_out-lfimg
                               THEN VALUE #( ( ebeln = wa_out-vgbel  ebelp = wa_out-vgpos ) )  ) ) ).

          IF lt_po_pos IS NOT INITIAL.
            CALL FUNCTION 'Z_SCM042_BORRAR_POS_PO'
              EXPORTING
                it_po_pos = lt_po_pos
              IMPORTING
                et_return = lt_ret_aux.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              EXIT.
            ENDLOOP.
            IF sy-subrc EQ 0.
              EXIT. "Siguiente transporte.
            ENDIF.
          ENDIF.
          "<
        ENDIF. "Eliminar entregas, borrar pos.PO.
        "**********************************************************************


        ">-Asignar NUEVA entrega al documento de transporte.
        "(todos los casos).
        FREE lt_ret_aux.
        CALL FUNCTION 'Z_SCM042_ASIGNAR_ENT_TRANSP'
          EXPORTING
            i_vbeln   = lv_vbeln_new    "Nueva entrega.
            i_tknum   = <fs_dest>-tknum
          IMPORTING
            et_return = lt_ret_aux.

        APPEND LINES OF lt_ret_aux TO lt_return.
        LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          EXIT. "Siguiente transporte.
        ENDIF.
        "<-fin asignar entrega.

*        "Fin-entrega".
*        PERFORM fill_return USING 'S' 'ZSCM042' '008' <fs_dest>-vbeln space space space CHANGING lt_return.

*--------------------------------------------------------------------*
        AT END OF tknum.  "2.
*--------------------------------------------------------------------*
          "Después de asignar todas las entregas NUEVAS en el transporte actual:
          ">Reiniciar estados del transporte con "Inicio Carga".
          FREE lt_ret_aux.

          CALL FUNCTION 'Z_SCM042_INICIAR_CARGA_WM'
            EXPORTING
              i_tknum   = <fs_dest>-tknum
            IMPORTING
              et_return = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          ">-Hacer "Lectura de bulto" de las UAs guardadas de todas las entregas-posiciones tratadas en este transporte.
          "(Picking con aplicativo WM con mismas UAS utilizadas en la expedición REAL)
          FREE lt_exidv.
          CLEAR lv_error_ua.

          "(todos los casos, para cada entrega-pos NUEVOS).
          LOOP AT lt_ent_new INTO ls_ent_new.
            FREE: lt_ret_aux.

            lt_exidv = VALUE #( FOR wa_ua IN lt_ua_entrega WHERE ( tknum EQ <fs_dest>-tknum AND vbeln EQ ls_ent_new-vbeln_ref )
                              ( CORRESPONDING #( wa_ua ) ) ).

            CALL FUNCTION 'Z_SCM042_LEER_BULTO_PICKING_WM'
              EXPORTING
                i_tknum   = <fs_dest>-tknum
                i_vbeln   = ls_ent_new-vbeln
                it_exidv  = lt_exidv
              IMPORTING
                et_return = lt_ret_aux
                et_exidv  = lt_exidv.

            APPEND LINES OF lt_ret_aux TO lt_return.
            LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
              lv_error_ua = 'X'.
              EXIT.
            ENDLOOP.

            "Marcar si ha sobrado alguna UA en la entrega nueva, significa que se ha modificado la entrega original,
            "tener en cuenta estas UAs para el picking en la entrega original.
            LOOP AT lt_exidv INTO ls_exidv.
              LOOP AT lt_ua_entrega ASSIGNING <fs_ua_entrega> WHERE exidv EQ ls_exidv.
                <fs_ua_entrega>-libre = 'X'.
              ENDLOOP.
            ENDLOOP.
          ENDLOOP.

          IF lv_error_ua EQ 'X'.
            CLEAR lv_error_ua.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<-

          ">--Lectura bulto UAs entregas con pedido modificado-reducido
          CLEAR lv_error_ua.

          "(todos los casos, para cada entrega-pos pedido REDUCIDO).
          LOOP AT lt_ent_mod INTO ls_ent_mod.
            FREE lt_ret_aux.

            lt_exidv = VALUE #( FOR wa_ua IN lt_ua_entrega
                                WHERE ( tknum EQ <fs_dest>-tknum AND vbeln EQ ls_ent_mod-vbeln AND libre EQ 'X' )
                              ( CORRESPONDING #( wa_ua ) ) ).

            "En caso de partición lotes, puede que no queden UAs "libres" porque en realidad solo se han repartido algunas UAs
            "de particiones en las entregas nuevas, y el resto puede haberse quedado asignado en las entregas originales.
            IF lt_exidv IS NOT INITIAL.
              CALL FUNCTION 'Z_SCM042_LEER_BULTO_PICKING_WM'
                EXPORTING
                  i_tknum   = <fs_dest>-tknum
                  i_vbeln   = ls_ent_mod-vbeln
                  it_exidv  = lt_exidv
                IMPORTING
                  et_return = lt_ret_aux
                  et_exidv  = lt_exidv.

              APPEND LINES OF lt_ret_aux TO lt_return.
              LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
                lv_error_ua = 'X'.
                EXIT.
              ENDLOOP.
            ENDIF.  "lt_exidv not initial.
          ENDLOOP.

          IF lv_error_ua EQ 'X'.
            CLEAR lv_error_ua.
            EXIT. "Siguiente transporte.
          ENDIF.
          "Nota: No haría falta desmarcar las últimas UAs usadas por cada entrega original.
          "<--

          ">Cerrar transporte: Se crean posiciones de pallets.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_CERRAR_TRANSP_WM'
            EXPORTING
              i_tknum      = <fs_dest>-tknum
              i_cierra     = 'X'
              i_dar_salida = ' '
            IMPORTING
              et_return    = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          ">Dar salida: Se contabilizan las SM de entregas.
          FREE lt_ret_aux.
          CALL FUNCTION 'Z_SCM042_CERRAR_TRANSP_WM'
            EXPORTING
              i_tknum      = <fs_dest>-tknum
              i_cierra     = ' '
              i_dar_salida = 'X'
            IMPORTING
              et_return    = lt_ret_aux.

          APPEND LINES OF lt_ret_aux TO lt_return.
          LOOP AT lt_ret_aux TRANSPORTING NO FIELDS WHERE type IN lr_type_error.
            EXIT.
          ENDLOOP.
          IF sy-subrc EQ 0.
            EXIT. "Siguiente transporte.
          ENDIF.
          "<

          "Fin Desvío transporte".
          PERFORM fill_return USING 'S' 'ZSCM042' '016' <fs_dest>-tknum space space space CHANGING lt_return.
        ENDAT.
      ENDLOOP.  "2.recorrer desvíos CM a Cliente.

    ENDIF.
  ELSE.
    "No se han seleccionado registros.
    MESSAGE i002 DISPLAY LIKE 'E'.
  ENDIF.


  IF lt_return IS NOT INITIAL.
    PERFORM display_log USING lt_return lc_object lc_subobject.
  ENDIF.

  PERFORM alv_fix_cwidth CHANGING pref_alv.

  CALL METHOD pref_alv->refresh_table_display
    EXPORTING
      is_stable = ls_stable.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  DISPLAY_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_RETURN  text
*----------------------------------------------------------------------*
FORM display_log  USING pt_return   TYPE bapiret2_tt
                        p_object    TYPE bal_s_log-object
                        p_subobject TYPE bal_s_log-subobject.

  DATA:
    l_log_handle        TYPE balloghndl,
    l_s_log             TYPE bal_s_log,
    l_s_msg             TYPE bal_s_msg,
    l_s_display_profile TYPE bal_s_prof,
*    ls_messages         TYPE bal_s_msg.
    ls_return           TYPE bapiret2.
  DATA: lt_log_handle  TYPE  bal_t_logh.

* create an initial log file
  l_s_log-extnumber   = text-000.  "Application Log.

  IF p_object IS NOT INITIAL AND p_subobject IS NOT INITIAL.
    l_s_log-object      = p_object.
    l_s_log-subobject   = p_subobject.
  ENDIF.

  CALL FUNCTION 'BAL_LOG_CREATE'
    EXPORTING
      i_s_log      = l_s_log
    IMPORTING
      e_log_handle = l_log_handle
    EXCEPTIONS
      OTHERS       = 1.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

* Añadir mensajes al log.
  LOOP AT pt_return INTO ls_return.

    CLEAR l_s_msg.
    l_s_msg-msgid     = ls_return-id.
    l_s_msg-msgno     = ls_return-number.
    l_s_msg-msgty     = ls_return-type.
    l_s_msg-msgv1     = ls_return-message_v1.
    l_s_msg-msgv2     = ls_return-message_v2.
    l_s_msg-msgv3     = ls_return-message_v3.
    l_s_msg-msgv4     = ls_return-message_v4.
    l_s_msg-probclass = '3'.  "Default medium.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = l_log_handle
        i_s_msg      = l_s_msg
      EXCEPTIONS
        OTHERS       = 1.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDLOOP.

  ">Grabar log con objeto y subobjeto para consulta SLG1.
  IF l_s_log-object IS NOT INITIAL AND l_s_log-subobject IS NOT INITIAL.
    APPEND l_log_handle TO lt_log_handle.
    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
*       I_CLIENT         = SY-MANDT
*       I_IN_UPDATE_TASK = ' '
*       I_SAVE_ALL       = ' '
        i_t_log_handle   = lt_log_handle
*       I_2TH_CONNECTION = ' '
*       I_2TH_CONNECT_COMMIT       = ' '
*       I_LINK2JOB       = 'X'
*   IMPORTING
*       E_NEW_LOGNUMBERS =
*       E_SECOND_CONNECTION        =
      EXCEPTIONS
        log_not_found    = 1
        save_not_allowed = 2
        numbering_error  = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
  "<

* get a prepared profile
  CALL FUNCTION 'BAL_DSP_PROFILE_POPUP_GET'
    IMPORTING
      e_s_display_profile = l_s_display_profile
    EXCEPTIONS
      OTHERS              = 1.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  l_s_display_profile-use_grid = 'X'.
* set report to allow saving of variants
  l_s_display_profile-disvariant-report = sy-repid.
  l_s_display_profile-disvariant-handle = 'LOG'.

* call display function module
  CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'
    EXPORTING
      i_s_display_profile = l_s_display_profile
    EXCEPTIONS
      OTHERS              = 1.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  CALL FUNCTION 'BAL_LOG_REFRESH'
    EXPORTING
      i_log_handle  = l_log_handle
    EXCEPTIONS
      log_not_found = 1
      OTHERS        = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CHECK_PALLET_COMPLETO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_OUTTAB  text
*----------------------------------------------------------------------*
FORM check_pallet_completo  USING p_matnr TYPE matnr
                                  p_menge TYPE lfimg
                                  p_meins TYPE mara-meins
                            CHANGING p_ret TYPE i
                                     p_menge_pal TYPE lfimg.
  CONSTANTS:
    lc_pal TYPE mara-meins VALUE 'PAL'.

  DATA: lv_matnr     TYPE mara-matnr,
        lv_in_me     TYPE mara-meins,
        lv_out_me    TYPE mara-meins,
        lv_menge     TYPE ekpo-menge,
        lv_menge_pal TYPE ekpo-menge.


  lv_matnr  = p_matnr.
  lv_in_me  = lc_pal.
  lv_out_me = p_meins.
  lv_menge  = 1.

  CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
    EXPORTING
      i_matnr              = lv_matnr
      i_in_me              = lv_in_me
      i_out_me             = lv_out_me
      i_menge              = lv_menge
    IMPORTING
      e_menge              = lv_menge_pal
    EXCEPTIONS
      error_in_application = 1
      error                = 2
      OTHERS               = 3.

  IF sy-subrc EQ 0 AND lv_menge_pal NE 0.
    lv_menge = p_menge. "Cantidad modificada (desvío).

    DATA(lv_res_mod) = lv_menge MOD lv_menge_pal.

    IF lv_res_mod NE 0.
      p_ret = 1.
    ENDIF.

    p_menge_pal = lv_menge_pal.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  READ_XPALLET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MATNR  text
*      -->P_VRKME  text
*      <--P_CANT_XPALLET  text
*      <--P_MEINS_XPALLET  text
*----------------------------------------------------------------------*
FORM read_xpallet  USING p_matnr TYPE matnr
                         p_meins TYPE mara-meins
                   CHANGING p_menge_pal TYPE lfimg
                            p_meins_out TYPE mara-meins.
  CONSTANTS:
    lc_pal TYPE mara-meins VALUE 'PAL'.

  DATA: lv_matnr     TYPE mara-matnr,
        lv_in_me     TYPE mara-meins,
        lv_out_me    TYPE mara-meins,
        lv_menge_in  TYPE ekpo-menge,
        lv_menge_pal TYPE ekpo-menge.

  "Leer cantidad del material p_matnr y UM p_meins por pallet.
  lv_matnr    = p_matnr.
  lv_out_me   = p_meins.
  lv_in_me    = lc_pal.
  lv_menge_in = 1.

  CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
    EXPORTING
      i_matnr              = lv_matnr
      i_in_me              = lv_in_me
      i_out_me             = lv_out_me
      i_menge              = lv_menge_in
    IMPORTING
      e_menge              = lv_menge_pal
    EXCEPTIONS
      error_in_application = 1
      error                = 2
      OTHERS               = 3.

  IF sy-subrc EQ 0.
    p_menge_pal = lv_menge_pal.
    p_meins_out = lv_out_me.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CLICK_SELECTION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MARK   text
*----------------------------------------------------------------------*
FORM click_selection  USING p_mark TYPE flag
                      CHANGING pt_outtab TYPE ty_tab_outtab
                               pref_alv  TYPE REF TO cl_gui_alv_grid.
  DATA: BEGIN OF ls_stable,
          row TYPE c VALUE 'X',
          col TYPE c VALUE 'X',
        END OF ls_stable.


  LOOP AT pt_outtab ASSIGNING FIELD-SYMBOL(<fs_outtab>).
    <fs_outtab>-sel = p_mark.
  ENDLOOP.

  PERFORM alv_fix_cwidth CHANGING pref_alv.

  CALL METHOD pref_alv->refresh_table_display
    EXPORTING
      is_stable = ls_stable.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form FILL_RETURN
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> TYPE
*&      --> ID
*&      --> NUMBER
*&      --> PAR1
*&      --> PAR2
*&      --> PAR3
*&      --> PAR4
*&      <-- T_RETURN
*&---------------------------------------------------------------------*
FORM fill_return  USING p_type   TYPE bapiret2-type
                        p_id     TYPE bapiret2-id
                        p_number TYPE bapiret2-number
                        p_par1   TYPE any
                        p_par2   TYPE any
                        p_par3   TYPE any
                        p_par4   TYPE any
               CHANGING pt_return TYPE bapiret2_tt.

  DATA: ls_return TYPE bapiret2.
  DATA: lv_par1 TYPE sy-msgv1,
        lv_par2 TYPE sy-msgv2,
        lv_par3 TYPE sy-msgv3,
        lv_par4 TYPE sy-msgv4.

  lv_par1 = |{ p_par1 ALPHA = OUT }|.
  lv_par2 = |{ p_par2 ALPHA = OUT }|.
  lv_par3 = |{ p_par3 ALPHA = OUT }|.
  lv_par4 = |{ p_par4 ALPHA = OUT }|.

  CLEAR ls_return.

*  MESSAGE ID p_id TYPE p_type NUMBER p_number
*          WITH ls_return-message_v1 ls_return-message_v2
*               ls_return-message_v3 ls_return-message_v4
*          INTO ls_return-message.

  CALL FUNCTION 'BALW_BAPIRETURN_GET2'
    EXPORTING
      type   = p_type
      cl     = p_id
      number = p_number
      par1   = lv_par1
      par2   = lv_par2
      par3   = lv_par3
      par4   = lv_par4
    IMPORTING
      return = ls_return.

  IF ls_return IS NOT INITIAL.
    APPEND ls_return TO pt_return.
  ENDIF.

ENDFORM.
