
class ZCL_WM_NT_GENERIC definition
  public
  final
  create protected .

public section.

  types:
    gtty_ltbc TYPE STANDARD TABLE OF ltbc WITH DEFAULT KEY .
  types:
    BEGIN  OF   gty_resb_key,
        rspos TYPE resb-rspos,
        rsart TYPE resb-rsart,
      END OF gty_resb_key .
  types:
    gtty_res_itm_chg  TYPE TABLE OF bapi2093_res_item_change WITH DEFAULT KEY .
  types:
    gtty_res_itm_chgx TYPE TABLE OF bapi2093_res_item_changex WITH DEFAULT KEY .
  types:
    gtty_res_itm_new  TYPE TABLE OF bapi2093_res_item_new WITH DEFAULT KEY .

  constants GC_MEINS_KG type MEINS value 'KG' ##NO_TEXT.
  constants GC_MEINS_DIA type MEINS value 'DIA' ##NO_TEXT.
  constants GC_MEINS_UNIDAD type MEINS value 'ST' ##NO_TEXT.
  constants GC_MEINS_M type MEINS value 'M' ##NO_TEXT.
  constants GC_HTTP_HEAD_MACHINE_ID type STRING value 'machine_id' ##NO_TEXT.
  constants GC_HTTP_HEAD_WERKS type STRING value 'werks' ##NO_TEXT.
  constants GC_HTTP_HEAD_CURRENTID type STRING value 'currentid' ##NO_TEXT.
  constants GC_HTTP_HEAD_NLPLA type STRING value 'nlpla' ##NO_TEXT.
  constants GC_HTTP_HEAD_MATNR type STRING value 'matnr' ##NO_TEXT.
  constants GC_HTTP_HEAD_NLPLAID type STRING value 'nlplaid' ##NO_TEXT.
  constants GC_EST_PREFIX type CHAR3 value 'EST' ##NO_TEXT.
  constants GC_MOVE_TYPE_919 type LTAK-BWLVS value '919' ##NO_TEXT.
  constants GC_MOVE_TYPE_918 type LTAK-BWLVS value '918' ##NO_TEXT.
  constants GC_MOVE_TYPE_853 type LTAK-BWLVS value '853' ##NO_TEXT.
  constants GC_MOVE_TYPE_998 type LTAK-BWLVS value '998' ##NO_TEXT.
  constants GC_TIPO_MOV_BOBINA_ORDEN_TRANS type ZWM_MOVEBOBINE_TIPO value '1' ##NO_TEXT.
  constants GC_TIPO_MOV_BOBINA_TRANS_STOCK type ZWM_MOVEBOBINE_TIPO value '2' ##NO_TEXT.
  constants GC_TIPO_MOV_BOBINA_REUBICAR type ZWM_MOVEBOBINE_TIPO value '3' ##NO_TEXT.
  constants GC_TIPO_MOV_BOBINA_COMPLETO type ZWM_MOVEBOBINE_TIPO value '0' ##NO_TEXT.

  class-methods CONVERT_BENUM_OMP_INTERNAL
    importing
      value(VP_GJAHR) type GJAHR
      value(VP_INPUT) type LVS_BENUM
    returning
      value(VP_OUTPUT) type LVS_BENUM .
  class-methods CONVERT_BENUM_OMP_EXTERNAL
    importing
      value(VP_INPUT) type LVS_BENUM
    exporting
      !VP_OUTPUT type LVS_BENUM
      !VP_GJAHR type GJAHR .
*        iv_qty_cons type zwm_ecm_bobine-assigned_qty
*        iv_qty_rem type
  methods BOBECM_CREATE_CONSUMPTION
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IS_ORIG_LQUA type LQUA
      !IS_ORIG_LTBK type LTBK
      !IV_CONS_QTY type LTBP-MENGE
      !IV_MEINS type MEINS
      !IV_CALIDAD type ZWM_CALIDAD
      !IV_DIAMETRO type ZWM_INTF_BHS-DIAMETRO_REST optional
      !IV_RESTANTE type ZWM_CANTIDAD_RESTANTE
      !IV_CREATE_ENTRY_ONLY type BOOLEAN default ABAP_FALSE
      !IS_ENTRY type ZWM_INTF_BHS optional
      !IV_OPERARIO type ZLNUM_OPER optional
    returning
      value(RS_ENTRY) type ZWM_INTF_BHS .
  methods BUILD_ALIST_BOBINE_UI5
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_ID_APROV_LIST type ZWM_NT_UI5_APLIST_BOBINE_STR-ID_APROV_LIST optional
    returning
      value(RT_DATA) type ZWM_NT_UI5_APLIST_BOBINE_TAB .
  methods BUILD_ALIST_BOBINE_UI5_V2
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_MATNR type MARA-MATNR
      !IV_ID_APROV_LIST type ZWM_NT_UI5_APLIST_BOBINE_STR-ID_APROV_LIST
      !IV_NLPLA_NR type I
    returning
      value(RT_DATA) type ZWM_NT_UI5_APLIST_BOBINE_TAB .
  methods BUILD_ALIST_BOBINE_UI5_V3
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_MACHINE_ID type ZWM_NT_UI5_MAQUINAS_STR-ID optional
      !IV_ID_APROV_LIST type ZWM_NT_UI5_APLIST_BOBINE_STR-ID_APROV_LIST
      !IV_ONLY_LTAP type XFELD optional
    returning
      value(RT_DATA) type ZWM_NT_UI5_APLIST_BOBINE_TAB .
  methods BUILD_APROVIS_LIST_UI5
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_ID type ZWM_ID optional
    returning
      value(RT_DATA) type ZWM_NT_UI5_APROV_LIST_TAB .
  methods BUILD_APROVIS_LIST_UI5_V2
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_ID type ZWM_ID optional
      !IV_EXCLUDE_NO_SHOW type BOOLEAN default ABAP_TRUE
      !IV_ALL_STAT type BOOLEAN default ABAP_FALSE
    returning
      value(RT_DATA) type ZWM_NT_UI5_APROV_LIST_TAB .
  methods BUILD_APROVIS_LIST_UI5_V3
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_MACHINE_ID type ZWM_NT_UI5_MAQUINAS_STR-ID optional
      !IV_ID type ZWM_ID optional
      !IV_EXCLUDE_NO_SHOW type BOOLEAN default ABAP_TRUE
      !IV_ALL_STAT type BOOLEAN default ABAP_FALSE
      !IV_CAL_STATUS_ESTACIONES type BOOLEAN default ABAP_TRUE
    returning
      value(RT_DATA) type ZWM_NT_UI5_APROV_LIST_TAB .
  methods BUILD_BOBECM_BOB_UI5
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_ID type ZWM_ID
    returning
      value(RT_DATA) type ZWM_NT_UI5_BOB_MD_TAB .
  methods BUILD_BOBECM_LIST_UI5
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_NLPLA type LTBK-NLPLA optional
      !IV_ID type ZWM_ID optional
      !IV_ALL_STAT type BOOLEAN default ABAP_FALSE
    returning
      value(RT_DATA) type ZWM_NT_UI5_BOB_ECM_TAB .
  methods BUILD_BOBECM_LIST_UI5_V2
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IV_NLPLA type LTBK-NLPLA optional
      !IV_ID type ZWM_ID optional
      !IV_CURRENT_ID type ZWM_ID optional
    exporting
      value(ET_HUERFANAS) type ZWM_NT_UI5_BOB_ECM_TAB
    returning
      value(RT_DATA) type ZWM_NT_UI5_BOB_ECM_TAB .
  class-methods CALC_BASE_DIAMETRO
    importing
      !IV_MATNR type MARA-MATNR
      !IV_WERKS type WERKS_D
      !IV_DIAM type BSTMG optional
    exporting
      !EV_KG type BSTMG
      !EV_DIA type BSTMG
      !EV_M type BSTMG
    exceptions
      UM_NO_VALID
      MISSING_CONSTANTS
      MISSING_MATNR
      OVERFLOW .
  class-methods CALC_DIAM_CON_KG
    importing
      !IV_MATNR type MARA-MATNR
      !IV_WERKS type WERKS_D
      !IV_KG type BSTMG
    exporting
      !EV_DIA type BSTMG
    exceptions
      UM_NO_VALID
      MISSING_CONSTANTS
      MISSING_MATNR .
  class-methods CALL_UI5 .
  methods CENTROS_GETDETAIL
    importing
      value(VP_WERKS) type ZWM_NT_UI5_CENTROS_STR-WERKS
    returning
      value(WP_CENTRO) type ZWM_NT_UI5_CENTROS_STR
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  class-methods CHANGE_NT
    importing
      !IT_LTBC type GTTY_LTBC
    exporting
      !EV_SUBRC type SY-SUBRC .
  class-methods CHANGE_RESERV
    importing
      !IV_RESERV type BAPI2093_RES_KEY-RESERV_NO
      !IT_ITM_CHG type GTTY_RES_ITM_CHG
      !IT_ITM_CHGX type GTTY_RES_ITM_CHGX
      !IT_ITM_NEW type GTTY_RES_ITM_NEW
      !IV_COMMIT type BOOLEAN default ABAP_TRUE
    returning
      value(RT_RET) type BAPIRET2_TAB .
  class-methods CHANGE_RESERV_4_CONS
    importing
      !IV_BOBINE type ZWM_BOBINE optional
      !IS_LTBK type LTBK optional
      !IV_QTY type LTBP-MENGA optional
      !IV_MEINS type LTBP-MEINS optional
      !IV_RSNUM type RESB-RSNUM optional
      !IV_CLOSE type BOOLEAN default ABAP_FALSE
    exporting
      !ET_RET type BAPIRET2_TAB .
  class-methods CLOSE_RSNUM
    importing
      !IV_RSNUM type RESB-RSNUM optional
      !IV_LAST type BOOLEAN default ABAP_FALSE
      !IV_NLPLA type ZWM_INTF_BHS-PORTA_BOBINAS optional
      !IV_LGNUM type ZWM_INTF_BHS-LGNUM optional
    returning
      value(RS_RET) type BAPIRET2 .
  class-methods CODE_LINE_ID
    importing
      !IS_DATA type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST
      !IV_TBNUM_MODE type BOOLEAN default ABAP_FALSE
      !IV_RSNUM_MODE type BOOLEAN default ABAP_FALSE
    returning
      value(RV_ID) type ZWM_NT_UI5_APROV_LIST_STR-ID .
  class-methods CONV_MATNR
    importing
      !IV_MATNR type MARA-MATNR
      !IV_MEINS_ORIG type MARA-MEINS
      !IV_MEINS_DEST type MARA-MEINS
      !IV_QTY type EKPO-MENGE
    returning
      value(RV_QTY) type EKPO-MENGE .
  class-methods CONV_MAT_DIAMETRO
    importing
      !IV_MATNR type MARA-MATNR
      !IV_QTY type BSTMG
      !IV_MEINS type MEINS
      !IV_DEST_MEINS type MEINS
      !IV_WERKS type WERKS_D
    returning
      value(RV_QTY) type BSTMG
    exceptions
      UM_NO_VALID
      MISSING_CONSTANTS
      MISSING_MATNR
      NO_BASE_CALC
      OVERFLOW .
  class-methods CREATE_OT_4_NT
    importing
      !IV_BOBINE type ZWM_BOBINE
      !IV_DEST_NLPLA type LTBK-NLPLA
      !IV_BWLVS type BWLVS
      !IS_LTBK type LTBK
      !IV_QTY type LTBP-MENGA
      !IV_MEINS type LTBP-MEINS
    exporting
      !ES_LTAK type LTAK
      !EV_SUBRC type SY-SUBRC .
  class-methods CREATE_OT_4_NT_SC
    importing
      !IV_BOBINE type ZWM_BOBINE
      !IV_DEST_NLPLA type LTBK-NLPLA
      !IV_BWLVS type BWLVS
      !IS_LTBK type LTBK
      !IV_QTY type LTBP-MENGA
      !IV_MEINS type LTBP-MEINS
    exporting
      !ES_LTAK type LTAK
      !EV_SUBRC type SY-SUBRC
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  class-methods CREATE_RESERV
    importing
      !IS_HEADER type BAPI2093_RES_HEAD
      !IT_ITEM type ZCL_WM_CONSTANTS=>GTTY_RES_ITEM
      !IV_COMMIT type BOOLEAN default ABAP_TRUE
    exporting
      !ES_RSNUM type BAPI2093_RES_KEY-RESERV_NO
      !ET_RET type BAPIRET2_TAB .
  methods CREATE_TO_4_DIAMET_RET
    importing
      !IV_LGNUM type T320-LGNUM default ZCL_WM_CONSTANTS=>GC_DEFAULT_LGNUM
      !IS_DATA type ZCL_ZUI5_WM_BOBINE_ECM_MPC=>TS_BOBINE
    returning
      value(RV_SUCC) type BOOLEAN .
  class-methods DECODE_LINE_ID
    importing
      !IV_ID type ZWM_NT_UI5_APROV_LIST_STR-ID
      !IV_TBNUM_MODE type BOOLEAN default ABAP_FALSE
      !IV_RSNUM_MODE type BOOLEAN default ABAP_FALSE
    returning
      value(RS_DATA) type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST .
  class-methods DELETE_RESERV
    importing
      !IV_RSNUM type BAPI2093_RES_KEY-RESERV_NO
      !IV_COMMIT type BOOLEAN default ABAP_TRUE
    returning
      value(RT_RET) type BAPIRET2_TAB .
  methods GET_APROVIS_LIST
    importing
      !IV_LGNUM type T320-LGNUM
      !IV_TBNUM type LTBK-TBNUM optional
      !IV_MACHINE_ID type ZWM_NT_UI5_MAQUINAS_STR-ID optional
      !IV_NLPLA type LTBK-NLPLA optional
      !IV_RESTRICT_ROWS type BOOLEAN default ABAP_FALSE
      !IV_ALL_STAT type BOOLEAN default ABAP_FALSE
      !IV_RSNUM type RSNUM optional
    returning
      value(RT_DATA) type ZCL_WM_CONSTANTS=>GTTY_APROVIS_LIST .
  class-methods GET_BOBINE_INFO
    importing
      !IV_LGNUM type LGNUM
      !IV_BOBINE type ZWM_BOBINE optional
      !IV_MATNR type MATNR optional
      !IV_QTY_ONLY type BOOLEAN default ABAP_TRUE
    returning
      value(RT_LQUA) type LQUA_T .
  class-methods GET_INSTANCE
    importing
      !IV_LANGU type SY-LANGU default SY-LANGU
    returning
      value(RR_REF) type ref to ZCL_WM_NT_GENERIC .
  methods GET_LANGU
    returning
      value(RV_LANGU) type SY-LANGU .
  class-methods GET_LGNUM
    importing
      !IV_WERKS type T320-WERKS
      !IV_LGORT type T320-LGORT optional
    returning
      value(RV_LGNUM) type T320-LGNUM .
  class-methods GET_MAT_INFO_LZNUM
    importing
      !IS_DATA type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST
    returning
      value(RS_DATA) type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST_UI5_KEY .
  class-methods GET_MAT_SUBS_COMP
    importing
      !IV_MATNR type MARA-MATNR
      !IV_WERKS type MARC-WERKS
    exporting
      !ET_SUBST type MARA_TT
      !ET_COMPAT type ZTT_COMPAT .
  class-methods GET_MAT_TXT_OMP
    importing
      !IV_WERKS type MARC-WERKS
      !IS_MARA type MARA
      !IV_CAL type CHAR3 optional
      !IV_CAL_ONLY type BOOLEAN default ABAP_FALSE
    returning
      value(RV_MAKTX) type MAKT-MAKTX .
  class-methods GET_NT_FOR_RESB
    importing
      !IS_RESB type RESB
    returning
      value(RT_LTBK) type ZCL_WM_CONSTANTS=>GTTY_LTBK .
  class-methods GET_RESB_FOR_NT
    importing
      !IS_LTBK type LTBK
      !IV_ONLY_OPEN type BOOLEAN default ABAP_TRUE
      !IV_NO_CNS type BOOLEAN default ABAP_FALSE
    returning
      value(RS_RESB) type RESB .
  class-methods GET_RSNUM
    importing
      !IV_INIT type BOOLEAN default ABAP_TRUE
    returning
      value(RV_RSNUM) type RKPF-RSNUM .
  class-methods GET_RSPOS
    importing
      !IV_INIT type BOOLEAN default ABAP_TRUE
    returning
      value(RS_RSPOS) type GTY_RESB_KEY .
  class-methods GET_UBICACION_PROP_UA
    importing
      value(VP_WERKS) type WERKS_D
      value(VP_LENUM) type LENUM
    returning
      value(WP_UBICACION) type ZWM_NT_UI5_UBICACIONES_STR
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  methods GROUP_LTBA
    importing
      !IT_LTBA type ZCL_WM_CONSTANTS=>GTTY_LTBA_IDX
    returning
      value(RT_GRP) type ZCL_WM_CONSTANTS=>GTTY_LTBA_IDX_GRP .
  class-methods IS_RESERV_CLOSABLE
    importing
      !IV_RSNUM type RESB-RSNUM
      !IV_HOURS_TO_CHECK type T
    returning
      value(RV_IS_CLOSABLE) type BOOLEAN .
  methods MAQUINAS_GETDETAIL
    importing
      value(VP_MACHINE_ID) type ZWM_NT_UI5_MAQUINAS_STR-ID
    returning
      value(WP_MAQUINA) type ZWM_NT_UI5_MAQUINAS_STR
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  class-methods MOVEBOBINE
    importing
      !IV_BOBINE type ZWM_BOBINE
      !IV_DEST_NLPLA type LTBK-NLPLA
      !IV_LGNUM type LTBK-LGNUM
      !IV_BWLVS type LTBK-BWLVS default GC_MOVE_TYPE_998
      !IV_TBNUM type LTBK-TBNUM optional
      !IV_TIPO_MOV_BOBINA type ZWM_MOVEBOBINE_TIPO default GC_TIPO_MOV_BOBINA_COMPLETO
      !IV_VALIDAR_FSC_RECYCLED type XFELD default 'X'
    exporting
      !ES_LTAK type LTAK
      !EV_SUBRC type SY-SUBRC
      !EV_RETRO type XFELD
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  class-methods READ_HTTP_HEADER_VAL
    importing
      !IV_NAME type STRING
      !IV_FACADE type ref to /IWBEP/IF_MGW_DP_INT_FACADE
    returning
      value(RV_VAL) type STRING .
  class-methods SET_RSNUM
    importing
      !IV_RSNUM type RKPF-RSNUM .
  class-methods SET_RSPOS
    importing
      !IS_RSPOS type GTY_RESB_KEY .
  class-methods SET_STATUS_NT
    importing
      !IS_LTBK type LTBK
      !IV_STATU type LTBK-STATU
      !IV_COMMIT type BOOLEAN default ABAP_TRUE .
  methods UNIDADES_ALMA_GETDETAIL
    importing
      value(VP_LENUM) type ZWM_NT_UI5_UDS_ALMA_STR-LENUM
      value(VP_LGNUM) type ZWM_NT_UI5_UDS_ALMA_STR-LGNUM
    returning
      value(WP_UNIDAD_ALMA) type ZWM_NT_UI5_UDS_ALMA_STR
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  class-methods VALIDATE_MAT_DIAM
    importing
      !IV_BOBINE type LQUA-LENUM
      !IV_LGNUM type LQUA-LGNUM
      !IV_DIAMETRO type ZWM_ECM_BOBINE-DIAMETRO
    returning
      value(RV_VALID) type BOOLEAN .
protected section.

  class-data GR_REF type ref to ZCL_WM_NT_GENERIC .
  class-data GS_LTAK_RSNUM type RKPF-RSNUM .
  class-data GS_LTAP_RSPOS type GTY_RESB_KEY .
  data GV_LANGU type SY-LANGU .

  methods CONSTRUCTOR
    importing
      !IV_LANGU type SY-LANGU .
  methods CREATE_ITF_ENTRY
    importing
      !IV_LGNUM type LGNUM
      !IV_WERKS type WERKS_D
      !IV_BOBINE type ZWM_BOBINE
      !IV_CONS_QTY type LTBP-MENGE
      !IV_MEINS type MEINS
      !IV_CALIDAD type ZWM_CALIDAD
      !IS_LTBK type LTBK
      !IV_COMMIT type BOOLEAN default ABAP_TRUE
      !IV_RESTANTE type ZWM_CANTIDAD_RESTANTE
      !IV_DIAMETRO type ZWM_INTF_BHS-DIAMETRO_REST optional
      !IV_LAST type BOOLEAN default ABAP_FALSE
      !IV_OPERARIO type ZLNUM_OPER optional
    returning
      value(RS_ENTRY) type ZWM_INTF_BHS .
  methods GET_MAT_INFO
    importing
      !IV_MATNR type MARA-MATNR
      !IV_MAKTX type MAKT-MAKTX optional
      !IV_LZNUM type LTBK-LZNUM
    returning
      value(RS_DATA) type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST_UI5_KEY .
  methods GET_MAT_INFO_V2
    importing
      !IS_DATA type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST
    returning
      value(RS_DATA) type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST_UI5_KEY .
  methods SET_LANGU
    importing
      !IV_LANGU type SY-LANGU .
private section.

  data GT_APROV_LIST type ZWM_NT_UI5_APROV_LIST_TAB .
  data G_LGNUM type LGNUM .

  methods GET_MAX_ROWS_OMP
    importing
      !IV_LGNUM type LGNUM
    returning
      value(RV_MAX_ROWS) type INT4 .
  methods GET_NLPLA_IDX
    importing
      !IV_NLPLA type LTBK-NLPLA
    returning
      value(RV_IDX) type CHAR1 .
  methods SET_NLPLA_IDX_DATA
    importing
      !IS_DATA type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST
      !IS_MAT_DATA type ZCL_WM_CONSTANTS=>GTY_APROVIS_LIST_UI5_KEY
      !IV_GROUP type BOOLEAN
      !IV_WERKS type MARD-WERKS optional
      !IV_GRAMAJE type ZGRAMAJE optional
      !IV_ANCHO type ZANCHO optional
      !IV_LARGO type ZLARGO optional
      !IV_MTART type MTART optional
      !IV_CAL type CHAR3 optional
    changing
      !CS_DATA type ZWM_NT_UI5_APROV_LIST_STR .
endclass. "ZCL_WM_NT_GENERIC definition
class ZCL_WM_NT_GENERIC implementation.
  METHOD bobecm_create_consumption.
    DATA: lt_sel TYPE TABLE OF rsparamsl_255.
    CLEAR rs_entry.

*    DATA(ls_decoded) = decode_line_id( iv_id = is_data-id_pedprog iv_tbnum_mode = abap_true ).
*    SELECT SINGLE benum FROM ltbk
*    INTO @DATA(lv_benum)
*    WHERE lgnum = @ls_decoded-lgnum
*    AND tbnum = @ls_decoded-tbnum.

    IF is_entry IS NOT INITIAL.
      DELETE FROM zwm_intf_bhs WHERE id = is_entry-id
      AND fecha = is_entry-fecha AND hora = is_entry-hora AND pos_fich = is_entry-pos_fich .
      COMMIT WORK.
    ENDIF.


    rs_entry = me->create_itf_entry(
      EXPORTING
        iv_lgnum          = iv_lgnum
        iv_werks          = is_orig_lqua-werks
        iv_bobine         = is_orig_lqua-lenum
        iv_cons_qty       = iv_cons_qty
        iv_meins          = iv_meins
        iv_calidad        = iv_calidad
        is_ltbk           = is_orig_ltbk
        iv_restante       = iv_restante
        iv_diametro       = iv_diametro
        iv_operario       = iv_operario
*        iv_last           = iv_last
    ).

    CHECK iv_create_entry_only = abap_false.


    lt_sel = VALUE #(
    ( selname = 'P_REPRO' kind = 'P' sign = 'I' option = 'EQ' low = abap_true  ) " Reprocess parameter
    ( selname = 'P_PROC' kind = 'P' sign = 'I' option = 'EQ' low = abap_false  )
    ( selname = 'P_NOPROC' kind = 'P' sign = 'I' option = 'EQ' low = abap_true  ) " Only not processed
    ( selname = 'P_ALL' kind = 'P' sign = 'I' option = 'EQ' low = abap_false  )
    ( selname = 'P_RETRY' kind = 'P' sign = 'I' option = 'EQ' low = abap_true  ) " cvivo - Se reintenta 1 vez procesar los pendientes anteriores para evitar que éste se adelante
    ( selname = 'P_LGNUM' kind = 'P' sign = 'I' option = 'EQ' low = iv_lgnum  ) " Whse number
*    ( selname = 'S_FECHA' kind = 'S' sign = 'I' option = 'EQ' low = sy-datum  ) " Date
*    "( selname = 'S_HORA' kind = 'S' sign = 'I' option = 'EQ' low = sy-uzeit  ) " Date
*    ( selname = 'S_ETIQ' kind = 'S' sign = 'I' option = 'EQ' low = is_orig_lqua-lenum  ) " UA
*    ( selname = 'S_ORDEN' kind = 'S' sign = 'I' option = 'EQ' low = lv_benum  ) " UA
    ( selname = 'S_ID' kind = 'S' sign = 'I' option = 'EQ' low = rs_entry-id  ) " ID " cvivo - con el ID sólo se puede seleccionar 1 entrada

    ).

    " 1 - must do a submit to tcode ZWM_CONSUMO
    SUBMIT zrwm_intf_bhs
    WITH SELECTION-TABLE lt_sel
    EXPORTING LIST TO MEMORY
    AND RETURN.


  ENDMETHOD.
  METHOD build_alist_bobine_ui5.
*    DATA lr_aprovid TYPE RANGE OF zwm_nt_ui5_aplist_bobine_str-id_aprov_list.
*    DATA lv_lenum TYPE lqua-lenum.
*    DATA lr_matnr TYPE RANGE OF mara-matnr.
*    CONSTANTS: gc_tolerance TYPE ltbp-menga VALUE '100'.
*    " get all aprov_list nt's needed
*    DO 1 TIMES.
*      CLEAR rt_data.
*      DATA(lt_data) = me->get_aprovis_list( iv_lgnum = iv_lgnum ).
*
*      CHECK lines( lt_data ) > 0.
*
*      IF iv_id_aprov_list IS NOT INITIAL.
*        lr_aprovid = VALUE #( ( sign = 'I' option = 'EQ' low = iv_id_aprov_list ) ).
*      ENDIF.
*
*
*      LOOP AT lt_data INTO DATA(ls_data).
*        DATA(lv_id) = me->code_line_id( is_data = CORRESPONDING #( ls_data ) ).
*        CHECK lv_id IN lr_aprovid.
*
*        "temp....
*        IF sy-sysid = 'HED'.
*          ls_data-lt_tbnum[ 1 ]-matnr = '000001011201402220'.
*        ENDIF.
*
*        " fetch from dao
**        DATA(lt_apl_bobine) = zcl_wm_zwm_apl_bobine_dao=>query_by_aprov_list( iv_id_aprov_list = lv_id ).
**
**        LOOP AT lt_apl_bobine INTO DATA(ls_bobine).
**          APPEND CORRESPONDING #( ls_bobine ) TO rt_data.
**          DATA(ls_data_aux) = rt_data[ 1 ].
**          SELECT SINGLE lgpla FROM lqua
**          INTO ls_data_aux-lgpla
**          WHERE lgnum = iv_lgnum
**          AND matnr = ls_bobine-matnr
**          AND lenum = ls_bobine-bobine
**          AND verme > 0.
**          MODIFY rt_data FROM ls_data_aux TRANSPORTING lgpla
**          WHERE lgpla NE ls_data_aux-lgpla.
**        ENDLOOP.
*
*
*        " first exec - create
*        "        CHECK sy-subrc <> 0.
*        DATA(ls_tbnum) = ls_data-lt_tbnum[ 1 ].
*
*        lr_matnr = VALUE #( ( sign = 'I' option = 'EQ' low = ls_tbnum-matnr ) ).
*
*        " fetch substitutes
*        SELECT SINGLE werks FROM t320
*        INTO @DATA(lv_werks)
*        WHERE lgnum = @iv_lgnum.
*        " 1 - from marc
*        SELECT SINGLE a~nfmat FROM marc AS a
*        INTO @DATA(lv_nfmat)
*        WHERE matnr = @ls_tbnum-matnr
*        AND werks = @lv_werks
*        AND ausdt >= @sy-datum .
*
*        IF lv_nfmat IS NOT INITIAL.
*          APPEND VALUE #( sign = 'I' option = 'EQ' low = lv_nfmat ) TO lr_matnr.
*        ENDIF.
*
*        " 2 - from PGMI
*        SELECT DISTINCT nrmit FROM pgmi
*        INTO TABLE @DATA(lt_nrmit)
*        WHERE prgrp IN ( SELECT prgrp FROM pgmi WHERE nrmit = @ls_tbnum-matnr AND werks = @lv_werks AND wemit = @lv_werks )
*        AND werks = @lv_werks
*        AND wemit = @lv_werks
*        AND nrmit <> @ls_tbnum-matnr
*        AND datum >= @sy-datum
*        .
*
*        LOOP AT lt_nrmit INTO DATA(ls_nrmit) WHERE nrmit IS NOT INITIAL.
*          APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_nrmit-nrmit ) TO lr_matnr.
*        ENDLOOP.
*
*        " akiii - add lgtyp from parameter table
*
*        " find bobines for the same matnr with quantity available
*        SELECT a~lenum, b~zzancho, b~zzlargo, b~matnr, b~meins,
*        a~lgpla, a~verme
*        FROM lqua AS a
*        INNER JOIN mara AS b
*        ON a~matnr = b~matnr
*        INNER JOIN t320 AS c
*        ON c~werks = a~werks
*        AND c~lgort = a~lgort
*        INTO TABLE @DATA(lt_lqua)
*        WHERE a~matnr IN @lr_matnr
*        AND c~lgnum = @iv_lgnum
*        AND a~verme > 0
*        AND a~lenum <> @lv_lenum.
*        "AND NOT EXISTS ( SELECT bobine FROM zwm_apl_bobine WHERE bobine = a~lenum ).
*
*        CHECK sy-subrc = 0.
*
*        LOOP AT lt_lqua INTO DATA(ls_lqua).
*
*          IF ls_tbnum-menga < gc_tolerance.
*            EXIT.
*          ENDIF.
*          ls_tbnum-menga = ls_tbnum-menga - ls_lqua-verme.
*          APPEND VALUE #(
*                id = ls_lqua-lenum id_aprov_list = lv_id matnr = ls_lqua-matnr bobine = ls_lqua-lenum
*                  width = ls_lqua-zzancho length = ls_lqua-zzlargo meins = ls_lqua-meins
*                  substitute = COND #( WHEN ls_lqua-matnr = ls_tbnum-matnr THEN abap_false ELSE abap_true )
*
*          ) TO rt_data.
*        ENDLOOP.
*
*        " disable table
**        LOOP AT rt_data INTO DATA(ls_data_new).
**          TRY.
**              zcl_wm_zwm_apl_bobine_dao=>create_entry( is_data = CORRESPONDING #( ls_data_new ) )->save_data(
***            iv_commit = ABAP_TRUE
**              ).
**            CATCH zcx_wm_exception.    "
**          ENDTRY.
**
**        ENDLOOP.
*
*      ENDLOOP.
*    ENDDO.
*    SORT rt_data BY substitute ASCENDING.
  ENDMETHOD.
  METHOD build_alist_bobine_ui5_v2.
*    CONSTANTS: gc_tolerance TYPE ltbp-menga VALUE '100'.
*    DATA lr_matnr TYPE RANGE OF mara-matnr.
*    DATA lv_lenum TYPE lein-lenum.
*    DATA lv_matnr TYPE mara-matnr.
*    CLEAR rt_data.
*    DATA(lt_data) = me->build_aprovis_list_ui5_v2(
*      EXPORTING
*        iv_lgnum = iv_lgnum
*      iv_id    = iv_id_aprov_list
*    ).
*    CHECK lines( lt_data ) > 0.
*
*    DATA(ls_data) = lt_data[ 1 ].
*
*    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
*      EXPORTING
*        input  = iv_matnr
*      IMPORTING
*        output = lv_matnr
**      EXCEPTIONS
**       length_error = 1
**       others = 2
*      .
*    IF sy-subrc <> 0.
**     MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
**                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*    ENDIF.
*
*    lr_matnr = VALUE #( ( sign = 'I' option = 'EQ' low = lv_matnr ) ).
*
*    " fetch substitutes
*    SELECT SINGLE werks FROM t320
*    INTO @DATA(lv_werks)
*    WHERE lgnum = @iv_lgnum.
*
*    zcl_wm_nt_generic=>get_mat_subs_comp(
*      EXPORTING
*        iv_matnr  = lv_matnr
*        iv_werks  = lv_werks
*      IMPORTING
*        et_subst  = DATA(lt_subst)
*        et_compat = DATA(lt_compat)
*    ).
*    LOOP AT lt_subst INTO DATA(ls_subst).
*      APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_subst-matnr ) TO lr_matnr.
*    ENDLOOP.
*    LOOP AT lt_compat INTO DATA(ls_compat).
*      APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_compat-matnr ) TO lr_matnr.
*    ENDLOOP.
*
*
*    " find bobines for the same matnr with quantity available
*    SELECT a~lenum, b~zzancho, b~zzlargo, b~matnr, b~meins,
*    a~lgpla, a~verme
*    FROM lqua AS a
*    INNER JOIN mara AS b
*    ON a~matnr = b~matnr
*    INNER JOIN t320 AS c
*    ON c~werks = a~werks
*    AND c~lgort = a~lgort
*    INTO TABLE @DATA(lt_lqua)
*    WHERE a~matnr IN @lr_matnr
*    AND c~lgnum = @iv_lgnum
*    AND a~verme > 0
*    AND a~lgtyp = '020'
*    AND a~lenum <> @lv_lenum.
*    "AND NOT EXISTS ( SELECT bobine FROM zwm_apl_bobine WHERE bobine = a~lenum ).
*
*    CHECK sy-subrc = 0.
*
*    DATA(lv_nlpla) = 'NLPLA' && iv_nlpla_nr.
*    DATA(lv_field) = lv_nlpla && '_MENGE'.
*    ASSIGN COMPONENT lv_field OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_menge>).
*    CHECK sy-subrc = 0.
*    DATA(lv_aux_menge) = CONV menge_d( <fs_menge> ).
*    LOOP AT lt_lqua INTO DATA(ls_lqua).
*      IF lv_aux_menge < gc_tolerance.
*        EXIT.
*      ENDIF.
*      lv_aux_menge = lv_aux_menge - ls_lqua-verme.
*      APPEND VALUE #(
*            id = ls_lqua-lenum id_aprov_list = iv_id_aprov_list matnr = ls_lqua-matnr bobine = ls_lqua-lenum
*              width = ls_lqua-zzancho length = ls_lqua-zzlargo meins = ls_lqua-meins
*              substitute = COND #( WHEN ls_lqua-matnr = lv_matnr THEN abap_false ELSE abap_true )
*
*      ) TO rt_data.
*    ENDLOOP.
*
*    SORT rt_data BY substitute ASCENDING.

  ENDMETHOD.
  METHOD build_alist_bobine_ui5_v3.
    CONSTANTS: gc_tolerance                   TYPE ltbp-menga VALUE '100'.
    CONSTANTS: gc_tolerance_alg_prob_bob_ber  TYPE ltbp-menga VALUE '1000'.

    DATA lv_lenum TYPE lein-lenum.
    DATA lr_lenum TYPE RANGE OF lein-lenum.
    DATA lr_matnr TYPE RANGE OF mara-matnr.

    CLEAR rt_data.

    SELECT SINGLE werks FROM t320
      INTO @DATA(lv_werks)
      WHERE lgnum = @iv_lgnum.

    TRY.
        DATA(wl_centro) = centros_getdetail( lv_werks ).
      CATCH /iwbep/cx_mgw_busi_exception.
        "TODO: Lo suyo seria propagar la excepcion...
    ENDTRY.





    IF gt_aprov_list IS INITIAL.
      IF wl_centro-lista_apro_ui5_pp = space.
        DATA(lt_data) = me->build_aprovis_list_ui5_v3(
          EXPORTING
            iv_lgnum = iv_lgnum
            iv_machine_id = iv_machine_id
      "      iv_id    = iv_id_aprov_list
          iv_exclude_no_show        = abap_false
          iv_cal_status_estaciones  = abap_false
        ).

      ELSE.
        DATA(rl_wm_nt) = NEW zcl_zui5_wm_nt_dpc_ext( ).
        TRY.
            DATA(vl_lgpla) = iv_machine_id.
            IF iv_lgnum = '201' AND iv_machine_id IS INITIAL.
              vl_lgpla = 'OND'.
            ENDIF.


            lt_data = rl_wm_nt->lista_aprov_pp_getlist( vp_werks      = lv_werks
                                                        vp_lgpla      = vl_lgpla
                                                        vp_lista_apro = 'X' ).
          CATCH /iwbep/cx_mgw_busi_exception.
            "TODO: Lo suyo seria propagar la excepcion...
        ENDTRY.


      ENDIF.
    ELSE.
      lt_data = gt_aprov_list.
    ENDIF.

    CHECK lines( lt_data ) > 0.




    DATA tl_maquinas TYPE TABLE OF zwm_nt_ui5_maquinas_str.
    DATA(vl_tolerancia) = SWITCH #( wl_centro-algoritmo_prop_bobinas_ber WHEN 'X' THEN gc_tolerance_alg_prob_bob_ber ELSE gc_tolerance ).

*    "FSC RECYCLED: Buscar valores en parámetro " DEL cvivo - 65605 pasamos a control por estación y necesidad
*    DATA: vl_fsc_recycled_lote TYPE ekpo-zzdecla_fsc,
*          vl_fsc_recycled_nec  TYPE zwm_ltbk_fsc.
*
*    SELECT SINGLE low, high
*      INTO (@vl_fsc_recycled_lote, @vl_fsc_recycled_nec)
*      FROM tvarvc
*      WHERE name = 'ZWM_FSC_RECYCLED'.

    LOOP AT lt_data INTO DATA(ls_data)
      WHERE (  ( id = iv_id_aprov_list AND no_show = abap_false ) OR related_id = iv_id_aprov_list ).

*      DATA(vl_fsc_recycled) = COND xfeld( WHEN ls_data-fsc = vl_fsc_recycled_nec THEN 'X' ELSE space ). " DEL cvivo - 65605 pasamos a control por estación y necesidad
      DATA(lv_next_tabix) = sy-tabix + 1. " KYV/RDM - 20200305






      DO 5 TIMES.
        CLEAR lr_matnr.

        DATA(lv_field)       = 'NLPLA' && sy-index && '_MATNR'.
        DATA(lv_field_menge) = 'NLPLA' && sy-index && '_MENGE'.
        DATA(lv_field_meins) = 'NLPLA' && sy-index && '_MEINS'.
        DATA(lv_field_nlpla) = 'NLPLA' && sy-index.
        DATA(lv_field_group) = 'NLPLA' && sy-index && '_GROUP'.
        DATA(lv_field_tbnum) = 'NLPLA' && sy-index && '_TBNUM'.
        DATA(lv_field_rsnum) = 'NLPLA' && sy-index && '_RSNUM'.
        DATA(lv_field_fsc)   = 'NLPLA' && sy-index && '_FSC'.
        ASSIGN COMPONENT lv_field       OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_matnr>).
        ASSIGN COMPONENT lv_field_nlpla OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_nlpla>).
        ASSIGN COMPONENT lv_field_tbnum OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_tbnum>).
        ASSIGN COMPONENT lv_field_rsnum OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_rsnum>).
        ASSIGN COMPONENT lv_field_fsc   OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_fsc>).
        CHECK: sy-subrc = 0, <fs_matnr> IS NOT INITIAL.
        APPEND VALUE #( sign = 'I' option = 'EQ' low = <fs_matnr> ) TO lr_matnr.

        ASSIGN COMPONENT lv_field_menge OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_menge>).
        ASSIGN COMPONENT lv_field_meins OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_meins>).
        CHECK sy-subrc = 0.


        READ TABLE tl_maquinas ASSIGNING FIELD-SYMBOL(<fs_maquina>) WITH KEY id = <fs_nlpla>.
        IF sy-subrc <> 0.
          APPEND INITIAL LINE TO tl_maquinas ASSIGNING <fs_maquina>.
          TRY.
              <fs_maquina> = maquinas_getdetail( <fs_nlpla> ).
            CATCH /iwbep/cx_mgw_busi_exception.
              <fs_maquina>-id = <fs_nlpla>.
          ENDTRY.
        ENDIF.


        "Parte de rebobinado: No hay propuesta, debe ser la bobina con la que se ha creado el parte
        IF <fs_maquina>-parte_rebobinado = 'X'.
          SELECT SINGLE *
            INTO @DATA(wl_parte_rebob_cab)
            FROM zwm_parte_reb_c
            WHERE werks = @lv_werks AND
                  rsnum = @<fs_rsnum>.
          IF sy-subrc = 0.
            SELECT SINGLE lqua~lenum, mara~zzancho, mara~zzlargo, mara~matnr, lqua~meins,
                          lqua~lgpla, lqua~verme, lqua~charg
              INTO @DATA(wl_bobina_cons)
              FROM lqua INNER JOIN mara ON mara~matnr = lqua~matnr
                        INNER JOIN t320 ON t320~werks = lqua~werks AND
                                           t320~lgort = lqua~lgort
              WHERE t320~lgnum = @iv_lgnum
                AND lqua~lenum = @wl_parte_rebob_cab-bobina_cons
                AND lqua~verme > 0.
          ENDIF.
          IF sy-subrc = 0.
            DATA(vl_cantidad_conv) = conv_matnr(  iv_matnr      = wl_bobina_cons-matnr
                                                  iv_meins_orig = wl_bobina_cons-meins
                                                  iv_meins_dest = <fs_meins>
                                                  iv_qty        = wl_bobina_cons-verme ).

            APPEND INITIAL LINE TO rt_data ASSIGNING FIELD-SYMBOL(<fs_rt_data>).
            <fs_rt_data>-id            = wl_bobina_cons-lenum.
            <fs_rt_data>-id_aprov_list = COND #( WHEN ls_data-related_id IS NOT INITIAL THEN ls_data-related_id ELSE ls_data-id ).
            <fs_rt_data>-matnr_lqua    = <fs_rt_data>-matnr         = wl_bobina_cons-matnr.
            <fs_rt_data>-charg         = wl_bobina_cons-charg.
            <fs_rt_data>-bobine        = wl_bobina_cons-lenum.
            <fs_rt_data>-width         = wl_bobina_cons-zzancho.
            <fs_rt_data>-length        = vl_cantidad_conv.
            <fs_rt_data>-meins         = <fs_meins>.
            <fs_rt_data>-lgpla         = wl_bobina_cons-lgpla.
            <fs_rt_data>-estacion      = <fs_nlpla>.


            SELECT SINGLE ltap~lgnum, ltap~tanum, ltap~tapos
              INTO @DATA(wl_ltap)
              FROM ltap INNER JOIN ltak ON  ltak~lgnum = ltap~lgnum AND
                                            ltak~tanum = ltap~tanum
                        INNER JOIN ltbk ON  ltak~benum = ltbk~benum AND
                                            ltak~lgnum = ltbk~lgnum AND
                                            ltap~nlpla = ltbk~nlpla
                    LEFT OUTER JOIN zwm_ltak_adit ON zwm_ltak_adit~tanum EQ ltak~tanum
                                                  AND zwm_ltak_adit~lgnum EQ ltak~lgnum " cvivo -65087- no tener en cuenta si está retrocedida
              WHERE ltak~lgnum = @iv_lgnum AND
                    ltbk~rsnum = @<fs_rsnum> AND
                    ltap~vlenr = @wl_bobina_cons-lenum AND
                    ( zwm_ltak_adit~retro NE @abap_true OR zwm_ltak_adit~retro IS NULL ).
            IF sy-subrc = 0.
              <fs_rt_data>-selected      = 'X'.
            ENDIF.
          ENDIF.
          CONTINUE.
        ENDIF.

        IF wl_centro-algoritmo_prop_bobinas_ber = 'X'.
          IF wl_centro-lista_apro_ui5_pp = space.
            IF <fs_rsnum> IS NOT INITIAL. " cvivo - Cambio lógica de trazar el 918 a BENUM, el RSNUM se pierde en cada fichero nuevo de la interfaz
              SELECT ltap~lgnum, ltap~tanum, ltap~tapos, ltap~vlenr, ltap~nlpla, ltak~benum
                INTO TABLE @DATA(tl_ltap) FROM ltap
                INNER JOIN ltak ON ltak~lgnum = ltap~lgnum AND
                                   ltak~tanum = ltap~tanum
                INNER JOIN ltbk ON ltak~benum = ltbk~benum " ahora cogemos todas las necesidades para la reserva
                               AND ltak~lgnum = ltbk~lgnum
                               AND ltak~rsnum = ltbk~rsnum " cvivo - incidencia
                LEFT OUTER JOIN zwm_ltak_adit ON zwm_ltak_adit~tanum EQ ltak~tanum AND
                                                 zwm_ltak_adit~lgnum EQ ltak~lgnum " cvivo -65087- no tener en cuenta si está retrocedida
                WHERE ltak~lgnum = @iv_lgnum AND
                      ltbk~rsnum = @<fs_rsnum> AND
                      ( zwm_ltak_adit~retro NE @abap_true OR
                        zwm_ltak_adit~retro IS NULL ).
              IF sy-subrc <> 0. CLEAR tl_ltap. ENDIF.
            ENDIF.

          ELSE.
            SELECT ltap~lgnum, ltap~tanum, ltap~tapos, ltap~vlenr, ltap~nlpla, ltak~benum
              INTO TABLE @tl_ltap FROM ltap
              INNER JOIN ltak ON ltak~lgnum = ltap~lgnum AND
                                 ltak~tanum = ltap~tanum
              INNER JOIN ltbk ON ltak~benum = ltbk~benum " ahora cogemos todas las necesidades para la reserva
                             AND ltak~lgnum = ltbk~lgnum
              LEFT OUTER JOIN zwm_ltak_adit ON zwm_ltak_adit~tanum EQ ltak~tanum AND
                                               zwm_ltak_adit~lgnum EQ ltak~lgnum " cvivo -65087- no tener en cuenta si está retrocedida
              WHERE ltak~lgnum = @iv_lgnum    AND
                    ltbk~tbnum = @<fs_tbnum>  AND
                    ltap~nlpla  = @<fs_nlpla> AND
                    ( zwm_ltak_adit~retro NE @abap_true OR
                      zwm_ltak_adit~retro IS NULL ).
            IF sy-subrc <> 0. CLEAR tl_ltap. ENDIF.
          ENDIF.
        ENDIF.

        zcl_wm_nt_generic=>get_mat_subs_comp(
          EXPORTING
            iv_matnr  = <fs_matnr>
            iv_werks  = lv_werks
          IMPORTING
            et_subst  = DATA(lt_subst)
            et_compat = DATA(lt_compat)
        ).
        LOOP AT lt_subst INTO DATA(ls_subst).
          APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_subst-matnr ) TO lr_matnr.
        ENDLOOP.
        LOOP AT lt_compat INTO DATA(ls_compat).
          IF ls_compat-prioridad NE abap_false.
            DATA(prioridad) = abap_true. " marcamos que el en este caso el orden en ZWM_COMPATIBLES es prioritario
          ENDIF.
          APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_compat-matnr ) TO lr_matnr.
        ENDLOOP.
        CHECK lines( lr_matnr ) > 0.

        " fetch also already selected entries
        DATA(lt_sel) = zcl_wm_zwm_apl_bobine_dao=>query_by_aprov_list( iv_id_aprov_list = iv_id_aprov_list iv_nlpla = <fs_nlpla> ).

        "Buscamos dos veces:
        " - La primera es para buscar todos los cuantos (UAs) para el material, almacen WM y tipo 020, que tenga cantidad disponible
        "   Debe tener num. unidad almacen (LENUM)
        " - La segunda buscar las seleccionadas, que salen en la tabla zwm_apl_bobine. La ID es el campo LENUM de LQUA

        DATA: tl_lgtyp_rg TYPE RANGE OF lqua-lgtyp.
        DATA: tl_matnr_rg TYPE RANGE OF lqua-matnr.
        DATA: tl_bestq_rg TYPE RANGE OF lqua-bestq.
        DATA: tl_zeugn_rg TYPE RANGE OF lqua-zeugn.
        DO 2 TIMES.

          CLEAR: tl_lgtyp_rg, tl_bestq_rg, tl_zeugn_rg.
          tl_matnr_rg = lr_matnr.

          IF sy-index = 1.
            DATA(lv_sel) = abap_false.
            IF iv_only_ltap IS INITIAL. " si sólo cargamos las aprovisionadas, al no informar este rango, la primera vuelta no hace el select
              lr_lenum = VALUE #( ( sign = 'E' option = 'EQ' ) ).
            ENDIF.

            DATA(vl_name) = |ZWM_TIPOS_ALMACEN_BOBINAS_{ iv_lgnum }|.
            SELECT sign, opti AS option, low, high
              INTO CORRESPONDING FIELDS OF TABLE @tl_lgtyp_rg
              FROM tvarvc
              WHERE name  = @vl_name.

            IF wl_centro-restringir_propuesta EQ 'X'.
              tl_bestq_rg = VALUE #( ( sign = 'E' option = 'EQ' low = 'S' ) ). " no proponer bloqueadas
              tl_zeugn_rg = VALUE #( ( sign = 'E' option = 'EQ' low = 'SEGUNDA' ) ). " no proponer segundas
            ENDIF.

          ELSE.
            CLEAR lr_lenum.
            lv_sel = abap_true.
            IF wl_centro-algoritmo_prop_bobinas_ber = 'X'.
              CLEAR tl_matnr_rg.
              "Seleccionados de las órdenes de transporte con tipo mov. 918
              LOOP AT tl_ltap ASSIGNING FIELD-SYMBOL(<fs_ltap>) WHERE nlpla = <fs_nlpla>.
                APPEND INITIAL LINE TO lr_lenum ASSIGNING FIELD-SYMBOL(<fs_lenum_rg>).
                <fs_lenum_rg>-sign = 'I'. <fs_lenum_rg>-option = 'EQ'. <fs_lenum_rg>-low = <fs_ltap>-vlenr.
              ENDLOOP.
            ELSE.
              "Seleccionados de la tabla de selección
              lr_lenum = VALUE #( FOR ls_sel IN lt_sel ( sign = 'I' option = 'EQ' low = ls_sel-id ) ).
            ENDIF.
          ENDIF.

          CHECK lines( lr_lenum ) > 0.

          " find bobines for the same matnr with quantity available
          SELECT a~lenum, b~zzancho, b~zzlargo, b~matnr, a~meins,
                 a~lgpla, a~verme, a~charg, @lv_sel AS selected
            FROM lqua AS a INNER JOIN mara AS b ON a~matnr = b~matnr
                           INNER JOIN t320 AS c ON c~werks = a~werks AND
                                                   c~lgort = a~lgort
            APPENDING TABLE @DATA(lt_lqua)
            WHERE a~matnr IN @tl_matnr_rg
              AND c~lgnum = @iv_lgnum
              AND a~verme > 0
              AND a~lgtyp IN @tl_lgtyp_rg   "En la segunda vuelta no se mira...
              AND a~lenum IN @lr_lenum
              AND a~bestq IN @tl_bestq_rg
              AND a~zeugn IN @tl_zeugn_rg.
        ENDDO.


        "Compruebo si es FSC RECYCLED
        "Solo para datos no seleccionados
        DATA: tl_lotes TYPE ztfsc_charg,
              wl_lotes LIKE LINE OF tl_lotes.

        CLEAR tl_lotes.
        IF <fs_fsc> = 'X'.
          SELECT SINGLE low
            INTO @DATA(vl_fsc_recycled_lote)
            FROM tvarvc
            WHERE name = 'ZWM_FSC_RECYCLED'. " todas las entradas tienen el mismo valor en el LOW, el correlativo a FSC RECYCLED en lotes

          LOOP AT lt_lqua ASSIGNING FIELD-SYMBOL(<fs_lqua>) WHERE selected = space.
            wl_lotes-charg = <fs_lqua>-charg.
            COLLECT wl_lotes INTO tl_lotes.
          ENDLOOP.

          IF tl_lotes IS NOT INITIAL.
            CALL FUNCTION 'ZMM_GET_FSC_LOTES'
              CHANGING
                lotes = tl_lotes.
          ENDIF.

          LOOP AT lt_lqua ASSIGNING <fs_lqua> WHERE selected = space.
            READ TABLE tl_lotes ASSIGNING FIELD-SYMBOL(<fs_lotes>) WITH KEY charg = <fs_lqua>-charg.
            IF sy-subrc <> 0 OR <fs_lotes>-zzdecla_fsc(1) <> vl_fsc_recycled_lote(1).
              DELETE lt_lqua.
            ENDIF.
          ENDLOOP.
        ENDIF.



        "Se ordenan las UAs por num. UA y seleccionado descendente. Los que estan seleccionados se quedan arriba
        "Se borran los duplicados, comparando por UA, para quedarnos con el seleccionado si existen los dos
        "Me da que es una forma algo rebuscada...

        "SORT lt_lqua BY selected DESCENDING lenum. " RDM/KYV - 20200729
        SORT lt_lqua BY lenum selected DESCENDING. " RDM/KYV - 20200729
        DELETE ADJACENT DUPLICATES FROM lt_lqua COMPARING lenum.
        "SORT lt_lqua BY verme DESCENDING. " RDM/KYV - 20200303

        "Luego se ordenan las bobinas de menor a mayor
        "El siguente borrado de duplicados no le veo sentido... porque al haberse ordenado por verme los lenum pueden estar
        "desordenados en la tabla...
        SORT lt_lqua BY verme ASCENDING." RDM/KYV - 20200303
        DELETE ADJACENT DUPLICATES FROM lt_lqua COMPARING lenum.

*        ASSIGN COMPONENT lv_field_menge OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_menge>).
*        ASSIGN COMPONENT lv_field_meins OF STRUCTURE ls_data TO FIELD-SYMBOL(<fs_meins>).
*        CHECK sy-subrc = 0.

        "lv_desired_menge: Cantidad deseada. A la que tengo que llegar
        DATA(lv_desired_menge) = CONV menge_d( <fs_menge> ) + vl_tolerancia.

        " KYV/RDM - 20200305 - calc desired qty - BEG
        "JCB: Si no me equivoco, esto es para sumar la cantidad de necesidades para mi mismo material posteriores al que estoy recorriendo.
        "En el informe se ve como que la caja abarca más de una necesidad
        LOOP AT lt_data INTO DATA(ls_aux) FROM lv_next_tabix.
          ASSIGN COMPONENT lv_field OF STRUCTURE ls_aux TO FIELD-SYMBOL(<fs_aux_matnr>).
          ASSIGN COMPONENT lv_field_group OF STRUCTURE ls_aux TO FIELD-SYMBOL(<fs_aux_group>).

          IF <fs_aux_matnr> IS NOT ASSIGNED
            OR <fs_aux_group> IS NOT ASSIGNED
            OR <fs_aux_matnr> NE <fs_matnr>.
            EXIT.
          ENDIF.

          CHECK <fs_aux_group> = abap_false. "KYV/RDM - 20200729

          ASSIGN COMPONENT lv_field_menge OF STRUCTURE ls_aux TO <fs_menge>.
          ADD <fs_menge> TO lv_desired_menge.
          UNASSIGN: <fs_aux_matnr>, <fs_aux_group>.
        ENDLOOP.
        " KYV/RDM - 20200305 - calc desired qty - END


        "lv_curr_menge: Cantidad actual. La que voy comprobando
        DATA(lv_curr_menge) = VALUE menge_d( ).
        " KYV/RDM - 20200807 - use first own material - BEG


        "En la propuesta actual se recorre primero el material y a continuacion los compatibles y sustitutos
        "En la propuesta para Bernabeu no...


        IF wl_centro-algoritmo_prop_bobinas_ber = 'X'.
          "Se propondrán las bobinas más pequeñas hasta superar la cantidad del pedido en 1.000 metros.
          "La última bobina, deberá ser mayor a 1.000 metros.
          "Esto garantiza que el usuario tenga tiempo suficiente para poder reponer bobinas en máquina.
          "Me indican que se tiene que tratar al material y a sus compatibles/sustitutos de la misma manera

          DATA vl_curr_menge_aux LIKE lv_curr_menge.

          "Leemos dos veces, para tratar siempre los seleccionados primero
          DO 2 TIMES.
            DATA(vl_selected) = SWITCH #( sy-index WHEN 1 THEN 'X' ELSE space ).
            LOOP AT lt_lqua INTO DATA(ls_lqua) WHERE selected = vl_selected.
              DATA(vl_tabix) = sy-tabix.
              "Miramos si ya hemos alcanzado la cantidad deseada, si ya hemos recorrido los seleccionados
              IF lv_curr_menge > lv_desired_menge AND ls_lqua-selected = space. EXIT. ENDIF.

              DATA(lv_conv_qty) = conv_matnr( iv_matnr      = ls_lqua-matnr
                                              iv_meins_orig = ls_lqua-meins
                                              iv_meins_dest = <fs_meins>
                                              iv_qty        = ls_lqua-verme ).

              vl_curr_menge_aux = lv_curr_menge + lv_conv_qty.

              DATA(vl_no_compatible) = COND #( WHEN ls_lqua-matnr NOT IN lr_matnr THEN 'X' ELSE space ).
              DATA(wl_bobina) = VALUE zwm_nt_ui5_aplist_bobine_str(
                    id            = ls_lqua-lenum
                    id_aprov_list = COND #( WHEN ls_data-related_id IS NOT INITIAL THEN ls_data-related_id ELSE ls_data-id )
                    matnr         = <fs_matnr>
                    bobine        = ls_lqua-lenum
                    width         = ls_lqua-zzancho
                    length        = lv_conv_qty
                    meins         = <fs_meins>
                    lgpla         = ls_lqua-lgpla
                    no_compatible = vl_no_compatible
                    substitute    = COND #( WHEN vl_no_compatible = 'X' OR ls_lqua-matnr = <fs_matnr> THEN VALUE #( ) ELSE ls_lqua-matnr )
                    estacion      = <fs_nlpla>
                    selected      = ls_lqua-selected
                    charg         = ls_lqua-charg
                    matnr_lqua    = ls_lqua-matnr
                    ).

              IF wl_bobina-matnr IS NOT INITIAL.
                DATA wl_mara TYPE mara.
                SELECT SINGLE matnr, zzgramaje, zzancho, zzlargo, mtart, matkl
                  INTO CORRESPONDING FIELDS OF @wl_mara
                  FROM mara
                  WHERE mara~matnr = @wl_bobina-matnr.
                IF sy-subrc = 0.
                  wl_bobina-maktx = zcl_wm_nt_generic=>get_mat_txt_omp( iv_werks = lv_werks
                                                                        is_mara  = wl_mara ).
                ENDIF.
              ENDIF.


              IF wl_bobina-substitute IS NOT INITIAL.
                DATA wl_mara_substitute TYPE mara.
                SELECT SINGLE matnr, zzgramaje, zzancho, zzlargo, mtart, matkl
                  INTO CORRESPONDING FIELDS OF @wl_mara_substitute
                  FROM mara
                  WHERE mara~matnr = @wl_bobina-substitute.
                IF sy-subrc = 0.
                  wl_bobina-substitute_maktx = zcl_wm_nt_generic=>get_mat_txt_omp( iv_werks = lv_werks
                                                                                   is_mara  = wl_mara_substitute ).
                ENDIF.
              ENDIF.


              "Si alcanzamos la cantidad deseada, la UA debe ser al menos de 1000 metros
              "Entiendo que logicamente, en realidad se refiere a la tolerancia
              IF ls_lqua-selected = space AND vl_curr_menge_aux >= lv_desired_menge AND lv_conv_qty < vl_tolerancia.
                CONTINUE.
              ELSEIF ls_lqua-selected = space AND ( lv_desired_menge - vl_curr_menge_aux ) < 1000. " nunca dejar un cambio a menos de 1000, no se hacen empalmes así
                CONTINUE.
              ELSE.
                lv_curr_menge = vl_curr_menge_aux.
                APPEND wl_bobina TO rt_data.
                CLEAR wl_bobina.
              ENDIF.
            ENDLOOP.
          ENDDO.

          "Si ha quedado rellena la bobina, es que hemos llegado a la ultima sin que sea de 1000 metros
          "Supongo que en este caso tambien la tenemos que coger
          IF wl_bobina IS NOT INITIAL.
            APPEND wl_bobina TO rt_data.
            ADD wl_bobina-length TO lv_curr_menge.  "Aumento la cantidad. Creo que ya no importa, pero por si acaso...
            CLEAR wl_bobina.
          ENDIF.


        ELSE.
          "Este es el algoritmo de propuesta generico
          "Recorre primero el material y luego sustitutos/compatibles -> cvivo - Modificación: debe recorrer indistintamente el material y compatibles

*          DO 2 TIMES.
*            DATA(lv_own) = COND #( WHEN sy-index = 1 THEN abap_true ELSE abap_false ).
          IF lt_lqua[] IS NOT INITIAL.
            DO 50 TIMES.
*            CHECK lv_curr_menge <= lv_desired_menge.
              " KYV/RDM - 20200807 - use first own material - END


              LOOP AT lt_lqua INTO ls_lqua.

*              " KYV/RDM - 20200807 - use first own material - BEG " DEL cvivo - no se verifica ya esto
*              IF lv_own = abap_true.
*                CHECK ls_lqua-matnr = <fs_matnr>.
*              ELSE.
*                CHECK ls_lqua-matnr <> <fs_matnr>.
*              ENDIF.
*              " KYV/RDM - 20200807 - use first own material - END

                " conv qty
                lv_conv_qty = conv_matnr(
                  EXPORTING
                    iv_matnr      = ls_lqua-matnr
                    iv_meins_orig = ls_lqua-meins
                    iv_meins_dest = <fs_meins>
                    iv_qty        = ls_lqua-verme
*             RECEIVING
*               rv_qty        =
                ).


                IF lv_curr_menge > lv_desired_menge.
                  EXIT.
                ENDIF.
                lv_curr_menge = lv_curr_menge + lv_conv_qty.
                APPEND VALUE #(
                      id = ls_lqua-lenum
                      id_aprov_list = COND #( WHEN ls_data-related_id IS NOT INITIAL THEN ls_data-related_id ELSE ls_data-id )
                      matnr = <fs_matnr> bobine = ls_lqua-lenum
                        width = ls_lqua-zzancho length = lv_conv_qty meins = <fs_meins> lgpla = ls_lqua-lgpla
                        substitute = COND #( WHEN ls_lqua-matnr = <fs_matnr> THEN VALUE #( ) ELSE ls_lqua-matnr )
                        estacion = <fs_nlpla> selected = ls_lqua-selected

                ) TO rt_data.
              ENDLOOP.
            ENDDO. " KYV/RDM - 20200807 - use first own material
          ENDIF.
        ENDIF.

        CLEAR lt_lqua.
      ENDDO.
    ENDLOOP.

    " remove duplicates...
    SORT rt_data BY id estacion.
    DELETE ADJACENT DUPLICATES FROM rt_data COMPARING id estacion.
    CHECK rt_data IS NOT INITIAL.

    SELECT mseg~matnr, mseg~werks, mseg~charg, mseg~lifnr, lfa1~name1
      INTO TABLE @DATA(tl_mseg)
      FROM mseg LEFT OUTER JOIN lfa1 ON lfa1~lifnr = mseg~lifnr
      FOR ALL ENTRIES IN @rt_data
      WHERE mseg~werks = @lv_werks      AND
            mseg~matnr = @rt_data-matnr_lqua AND
            mseg~charg = @rt_data-charg and
            mseg~bwart = '101'.

    LOOP AT rt_data ASSIGNING FIELD-SYMBOL(<fs_data>).
      READ TABLE tl_mseg ASSIGNING FIELD-SYMBOL(<fs_mseg>) WITH KEY matnr = <fs_data>-matnr_lqua
                                                                    charg = <fs_data>-charg.
      IF sy-subrc = 0.
        <fs_data>-name1 = <fs_mseg>-name1.
      ENDIF.
    ENDLOOP.


    IF wl_centro-algoritmo_prop_bobinas_ber = 'X'.
      SORT rt_data BY selected estacion length. "KYV/RDM - 20200709
    ELSE.
      SORT rt_data BY estacion length. "KYV/RDM - 20200709
    ENDIF.


  ENDMETHOD.
  METHOD build_aprovis_list_ui5.
    FIELD-SYMBOLS: <fsv> TYPE any.
    CLEAR rt_data.

    DATA(lt_data) = me->get_aprovis_list( iv_lgnum = iv_lgnum ).


    SORT lt_data BY pdatu pzeit.
    LOOP AT lt_data INTO DATA(ls_data).
      DATA(lv_nlpla_idx) = me->get_nlpla_idx( iv_nlpla = ls_data-nlpla  ).
      CHECK lv_nlpla_idx IS NOT INITIAL.

      DATA(lv_group) = abap_false.
      DATA(ls_mat_data) = me->get_mat_info_lznum( is_data = ls_data ).
      DATA(lv_nlpla) = 'NLPLA' && lv_nlpla_idx.
      DATA(lv_field) = lv_nlpla && '_MATNR'.
      DATA(ls_tbnum) = ls_data-lt_tbnum[ 1 ].
      DATA(lv_where) = |{ lv_field } = { ls_tbnum-matnr } AND WIDTH = { ls_mat_data-width } and ztrim = { ls_mat_data-ztrim } and quality = { ls_mat_data-quality }|.


      " sum quantities
      LOOP AT rt_data ASSIGNING FIELD-SYMBOL(<fs_data>)
      WHERE (lv_where).
        lv_field = lv_nlpla && '_MENGE'.
        ASSIGN COMPONENT lv_field OF STRUCTURE <fs_data> TO <fsv>.
        CHECK sy-subrc = 0.
        ADD ls_tbnum-menga TO <fsv>.
        lv_group = abap_true.
        DATA(lv_aux) = VALUE zwm_nt_ui5_aprov_list_str-nlpla1_menge( ).
        lv_aux = <fsv>.
      ENDLOOP.


      "DATA(lv_matid) = me->code_line_id( is_data = ls_mat_data ).
      APPEND CORRESPONDING #( ls_mat_data ) TO rt_data ASSIGNING  <fs_data>.
      <fs_data>-id = me->code_line_id( is_data = ls_data ).
      <fs_data>-pedido = ls_data-benum.

      me->set_nlpla_idx_data(
        EXPORTING
          is_data =  ls_data
          is_mat_data = ls_mat_data
          iv_group = lv_group
        CHANGING
          cs_data = <fs_data>
      ).

      IF lv_group = abap_true.
        <fs_data>-nlpla1_menge = lv_aux.
      ENDIF.


    ENDLOOP.

    " must remove at the end the unwanted rows -> sum quantities...
    CHECK iv_id IS NOT INITIAL.
    DELETE rt_data WHERE id NE iv_id.

  ENDMETHOD.
  METHOD build_aprovis_list_ui5_v2.

    FIELD-SYMBOLS: <fsv> TYPE any.
    FIELD-SYMBOLS: <fs_data> TYPE zwm_nt_ui5_aprov_list_str.
    TYPES: BEGIN OF lty_comp_str,
             width        TYPE zwm_nt_ui5_aprov_list_str-width,
             ztrim        TYPE zwm_nt_ui5_aprov_list_str-ztrim,
             quality      TYPE zwm_nt_ui5_aprov_list_str-quality,
             nlpla1_group TYPE zwm_nt_ui5_aprov_list_str-nlpla1_matnr,
             nlpla2_group TYPE zwm_nt_ui5_aprov_list_str-nlpla2_matnr,
             nlpla3_group TYPE zwm_nt_ui5_aprov_list_str-nlpla3_matnr,
             nlpla4_group TYPE zwm_nt_ui5_aprov_list_str-nlpla4_matnr,
             nlpla5_group TYPE zwm_nt_ui5_aprov_list_str-nlpla5_matnr,
           END OF lty_comp_str.
    DATA lr_statu TYPE RANGE OF ltbk-statu.

    CLEAR rt_data.

    DATA(lt_data) = me->get_aprovis_list( iv_lgnum = iv_lgnum iv_all_stat = abap_true ).
    lr_statu = VALUE #(
    ( sign = 'I' option = 'EQ' )
    ( sign = 'I' option = 'EQ' low = 'T' )
     ).

    DELETE lt_data WHERE nlpla NS '1' AND statu NOT IN lr_statu. " keep only closed estacion 1 and remove remaining closed

    SORT lt_data BY pdatu pzeit benum.
    DATA(lv_old_benum) = VALUE ltbk-benum( ).
    SELECT SINGLE werks FROM t320 INTO @DATA(lv_werks) WHERE lgnum = @iv_lgnum.

    LOOP AT lt_data INTO DATA(ls_data).

      DATA(ls_tbnum) = ls_data-lt_tbnum[ 1 ].
      DATA(ls_mat_data) = me->get_mat_info_lznum( is_data = ls_data ).
      DATA(lv_nlpla_idx) = me->get_nlpla_idx( iv_nlpla = ls_data-nlpla  ).
      DATA(lv_group) = abap_false.

      IF lv_old_benum NE ls_data-benum.
        APPEND CORRESPONDING #(
        ls_mat_data
        ) TO rt_data ASSIGNING <fs_data>.
        <fs_data>-id = code_line_id( ls_data ).
        <fs_data>-pedido = ls_data-benum.
        CLEAR <fs_data>-length.
        <fs_data>-length = zcl_wm_zwm_ltbk_adit_dao=>get_qty_4_benum(
               iv_benum = ls_data-benum
               iv_lgnum = ls_data-lgnum
               iv_lgpla = ls_data-nlpla
           )-menge.

      ENDIF.

      IF ls_data-statu IN lr_statu.

        me->set_nlpla_idx_data(
      EXPORTING
        is_data =  ls_data
        is_mat_data = ls_mat_data
        iv_group = lv_group
        iv_werks = lv_werks
      CHANGING
        cs_data = <fs_data>
    ).


        DATA(lv_nlpla) = 'NLPLA' && lv_nlpla_idx.
        DATA(lv_field) = lv_nlpla && '_MATNR'.

        IF lines( rt_data ) > 1.
          DATA(ls_prev_data) = rt_data[ lines( rt_data ) - 1 ].
          ASSIGN COMPONENT :
          lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_current>),
          lv_field OF STRUCTURE ls_prev_data TO FIELD-SYMBOL(<fs_previous>).          IF <fs_current> IS ASSIGNED AND <fs_previous> IS ASSIGNED
          AND <fs_current> = <fs_previous>
          AND ls_prev_data-width = <fs_data>-width
          AND ls_prev_data-ztrim = <fs_data>-ztrim
          AND ls_prev_data-quality = <fs_data>-quality.

          lv_field = lv_nlpla && '_MENGE'.
          ASSIGN COMPONENT: lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_current_val>),
                            lv_field OF STRUCTURE ls_prev_data TO FIELD-SYMBOL(<fs_prev_val>).

          <fs_current_val> = <fs_current_val> + <fs_prev_val>.
          lv_field = lv_nlpla && '_MEINS'.
          ASSIGN COMPONENT lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_meins>).
          <fs_meins> = ls_tbnum-altme.
          lv_field = lv_nlpla && '_GROUP'.
          ASSIGN COMPONENT lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_group>).
          <fs_group> = abap_true.
        ENDIF.
        UNASSIGN: <fs_current>, <fs_previous>.
      ENDIF.
    ENDIF.
    lv_old_benum = ls_data-benum.
  ENDLOOP.

  " exclude empty lines
  DELETE rt_data WHERE nlpla1 IS INITIAL AND nlpla2 IS INITIAL
  AND nlpla3 IS INITIAL AND nlpla4 IS INITIAL AND nlpla5 IS INITIAL.


  " now must mark all the ones that shouldn't be shown -> same
  DATA(ls_comp_prev) = VALUE lty_comp_str( ).
  DATA(lt_aux) = rt_data.
  DELETE ADJACENT DUPLICATES FROM lt_aux COMPARING
  width
  ztrim
  quality nlpla1_matnr
  nlpla2_matnr
  nlpla3_matnr
  nlpla4_matnr
  nlpla5_matnr.
  DATA(lt_id) = rt_data.
  DELETE ADJACENT DUPLICATES FROM lt_id COMPARING id.
  DATA(lt_fin) = VALUE zwm_nt_ui5_aprov_list_tab( ).

  LOOP AT lt_aux INTO DATA(ls_aux).
    APPEND ls_aux TO lt_fin
    ASSIGNING FIELD-SYMBOL(<fs_fin>).
    DATA(lv_prev_id) = 0.

    LOOP AT rt_data INTO DATA(ls_data_curr)
    WHERE width = ls_aux-width
    AND ztrim = ls_aux-ztrim
    AND quality = ls_aux-quality
    AND nlpla1_matnr = ls_aux-nlpla1_matnr
    AND nlpla2_matnr = ls_aux-nlpla2_matnr
    AND nlpla3_matnr = ls_aux-nlpla3_matnr
    AND nlpla4_matnr = ls_aux-nlpla4_matnr
    AND nlpla5_matnr = ls_aux-nlpla5_matnr
    AND id <> ls_aux-id.

      " only go on if it is next in line for id's
      READ TABLE lt_id TRANSPORTING NO FIELDS WITH KEY id = ls_data_curr-id.
      DATA(lv_curr_id) = sy-tabix.
      READ TABLE lt_id TRANSPORTING NO FIELDS WITH KEY id = ls_aux-id.
      DATA(lv_parent_id) = sy-tabix.
      lv_parent_id = lv_curr_id - lv_parent_id - lv_prev_id.
      CHECK lv_parent_id = 1.
      lv_prev_id = lv_curr_id.
      " must check if estacion 1 is closed for current BENUM
      IF ls_data_curr-length IS INITIAL.
        DATA(lv_est1_nlpla) = gc_est_prefix && '1'.
        SELECT SUM( a~menga ) FROM ltbp AS a
        INNER JOIN ltbk AS b
        ON a~lgnum = b~lgnum
        AND a~tbnum = b~tbnum
        INTO @ls_data_curr-length
        WHERE b~lgnum = @iv_lgnum
        AND b~benum = @ls_data_curr-pedido
        AND b~nlpla = @lv_est1_nlpla.
      ENDIF.
      <fs_fin>-length = <fs_fin>-length + ls_data_curr-length.
      ls_data_curr-no_show = abap_true.
      ls_data_curr-related_id = <fs_fin>-id.
      APPEND ls_data_curr TO lt_fin.
    ENDLOOP.
  ENDLOOP.




  rt_data = lt_fin.
  IF iv_exclude_no_show = abap_true.
    DELETE rt_data WHERE no_show = abap_true.
  ENDIF.

  LOOP AT rt_data ASSIGNING <fs_data>.
    " convert qtys to int
    <fs_data>-length = CONV i( <fs_data>-length ).
  ENDLOOP.

  " must remove at the end the unwanted rows -> sum quantities...
  CHECK iv_id IS NOT INITIAL.

  DELETE rt_data WHERE
   id NE iv_id.


ENDMETHOD.
METHOD build_aprovis_list_ui5_v3.
  DATA: t_matnr TYPE TABLE OF matnr.
  FIELD-SYMBOLS: <fs_data> TYPE zwm_nt_ui5_aprov_list_str.
  CLEAR rt_data.

  DATA(lt_data) = me->get_aprovis_list( iv_lgnum      = iv_lgnum
                                        iv_machine_id = iv_machine_id
                                        iv_all_stat   = abap_false ).
  SORT lt_data BY pdatu pzeit benum nlpla. " cvivo - 65586 también ubicación
  DATA(lv_old_benum) = VALUE ltbk-benum( ).
  SELECT SINGLE werks
    FROM t320
    INTO @DATA(lv_werks)
    WHERE lgnum = @iv_lgnum.

  TRY.
      DATA(wl_centro) = centros_getdetail( lv_werks ).

      IF lt_data IS NOT INITIAL AND lt_data[ 1 ]-nlpla IS NOT INITIAL.
        DATA(wl_maquina_1) = zcl_wm_nt_generic=>get_instance( )->maquinas_getdetail( lt_data[ 1 ]-nlpla ).
      ENDIF.
    CATCH /iwbep/cx_mgw_busi_exception.
  ENDTRY.

  IF iv_machine_id IS NOT INITIAL.
    TRY.
        DATA(wl_maquina) = zcl_wm_nt_generic=>get_instance( )->maquinas_getdetail( iv_machine_id ).
      CATCH /iwbep/cx_mgw_busi_exception.
    ENDTRY.
  ENDIF.



  "JCB. Obtener numeros de pedido
  DATA tl_nums_pedido TYPE TABLE OF zwm_ltbk_adit-upper_orderid.
  IF lt_data IS NOT INITIAL.
    SELECT lgnum, tbnum, upper_orderid, lower_orderid, benum, fsc, menge, nlpla, cliente, cliente2,
      texto " cvivo - 65089
      INTO TABLE @DATA(tl_zwm_ltbk_adit)
      FROM zwm_ltbk_adit
      FOR ALL ENTRIES IN @lt_data
      WHERE lgnum = @lt_data-lgnum AND
            tbnum = @lt_data-tbnum AND
            menge GT 0. "AND " cvivo - rendimiento  " DEL - cvivo - si no viene ordenado tenemos problemas, lo hacemos luego este filtro
*            nlpla LIKE '%1'. " la estación 1 marca el largo del pedido
  ENDIF.

  " cvivo - 58678 - fase 2
  SELECT sign AS sign, opti AS option, low AS low, high AS high FROM tvarvc
    WHERE name EQ 'ZWM_MAQUINAS_GESTION_PALETS'
    INTO TABLE @DATA(r_ubic_palet).

  IF sy-subrc NE 0.
    r_ubic_palet = VALUE #( sign = 'I' option = 'EQ'  ( low = space ) ).
  ENDIF.


  "FSC RECYCLED: Buscar valores en parámetro
*  DATA: vl_fsc_recycled_lote TYPE ekpo-zzdecla_fsc,
*        vl_fsc_recycled_nec  TYPE zwm_ltbk_fsc.

  " cvivo - 65605 FSC
  SELECT 'I' AS sign, 'EQ' AS option, high AS low, high AS high FROM tvarvc
    WHERE name EQ 'ZWM_FSC_RECYCLED'
    INTO TABLE @DATA(t_fsc).

*  SELECT SINGLE low, high " del - cvivo - 65605
*    INTO (@vl_fsc_recycled_lote, @vl_fsc_recycled_nec)
*    FROM tvarvc
*    WHERE name = 'ZWM_FSC_RECYCLED'.

  SELECT SINGLE low
    INTO @DATA(vl_length_max)
    FROM tvarvc
    WHERE name = 'ZUI5_LISTADOAPRV_GRAPH_MAX' AND
          type = 'P'                          AND
          numb = '0000'.

  " cvivo - mejora de rendimiento, consultamos textos de una vez en BBDD
  LOOP AT lt_data INTO DATA(ls_data).
    DATA(lv_matnr) = ls_data-lt_tbnum[ 1 ]-matnr.

    COLLECT lv_matnr INTO t_matnr. " para evitar duplicados
  ENDLOOP.

  SELECT ztpi0013~calidad, mara~matnr, mara~mtart, mara~zzgramaje, mara~zzancho, mara~zzlargo FROM ztpi0013
    INNER JOIN ztpi0003
    ON ztpi0013~valor_externo EQ ztpi0003~zvalor_externo
    INNER JOIN ztpi0001
    ON ztpi0001~zcodigo EQ ztpi0003~zcodigo
    INNER JOIN mara
    ON mara~matkl EQ ztpi0003~zvalor_sap
    FOR ALL ENTRIES IN @t_matnr
    WHERE mara~matnr EQ @t_matnr-table_line
      AND ztpi0003~werks EQ @lv_werks
    INTO TABLE @DATA(lt_calidades).

  IF sy-subrc NE 0. " cvivo - Nueva tabla no dependiente de AS400
    SELECT ztpi0014~calidad, mara~matnr, mara~mtart, mara~zzgramaje, mara~zzancho, mara~zzlargo
      FROM ztpi0014
      INNER JOIN mara
      ON mara~matkl EQ ztpi0014~matkl
      FOR ALL ENTRIES IN @t_matnr
      WHERE mara~matnr EQ @t_matnr-table_line
      AND ztpi0014~lgnum EQ @iv_lgnum
      INTO CORRESPONDING FIELDS OF TABLE @lt_calidades.
  ENDIF.


  IF t_matnr IS NOT INITIAL.
    SELECT matnr, zzmatnr_external
      INTO TABLE @DATA(tl_mlgn)
      FROM mlgn
      FOR ALL ENTRIES IN @t_matnr
      WHERE lgnum = @iv_lgnum AND
            matnr = @t_matnr-table_line.
  ENDIF.


*  DATA vl_fila_vacia_scy TYPE xfeld.
  LOOP AT lt_data INTO ls_data.
*    "JCB: Invento para San Cayetano. Lineas en blanco si no se ha cargado necesidad en la interfaz
*    vl_fila_vacia_scy = space.
*    IF iv_lgnum = '270' AND ls_data-lt_tbnum[ 1 ] IS INITIAL.
*      vl_fila_vacia_scy = 'X'.
*    ENDIF.


    lv_matnr = ls_data-lt_tbnum[ 1 ]-matnr.
    DATA(ls_tbnum) = ls_data-lt_tbnum[ 1 ].

    READ TABLE lt_calidades INTO DATA(lw_calidades) WITH KEY matnr = lv_matnr.
    IF sy-subrc = 0.
      DATA(lv_cal) = lw_calidades-calidad.
      DATA(lv_gramaje) = lw_calidades-zzgramaje.
      DATA(lv_ancho) = lw_calidades-zzancho.
      DATA(lv_largo) = lw_calidades-zzlargo.
      DATA(lv_mtart) = lw_calidades-mtart.
    ELSE.
      CLEAR: lw_calidades, lv_cal, lv_gramaje, lv_ancho, lv_largo.
    ENDIF.


    DATA(ls_mat_data) = me->get_mat_info_lznum( is_data = ls_data ).
    DATA(lv_nlpla_idx) = me->get_nlpla_idx( iv_nlpla = ls_data-nlpla  ).
    DATA(lv_group) = abap_false.

    IF lv_old_benum NE ls_data-benum.
      APPEND CORRESPONDING #( ls_mat_data ) TO rt_data ASSIGNING <fs_data>.
      <fs_data>-id      = code_line_id( ls_data ).
      <fs_data>-tbnum   = ls_data-tbnum.

      IF wl_centro-mostrar_pedido IS INITIAL.
        <fs_data>-pedido  = ls_data-benum.
      ELSE.

        "JCB: Leemos certificación FSC y más datos
        READ TABLE tl_zwm_ltbk_adit ASSIGNING FIELD-SYMBOL(<fs_zwm_ltbk_adit>)
          WITH KEY lgnum = ls_data-lgnum
                   tbnum = ls_data-tbnum.
        IF sy-subrc = 0.
          <fs_data>-cliente      = <fs_zwm_ltbk_adit>-cliente.
          <fs_data>-cliente2     = <fs_zwm_ltbk_adit>-cliente2.
          <fs_data>-fsc          = <fs_zwm_ltbk_adit>-fsc.
*          <fs_data>-fsc_recycled = COND #( WHEN <fs_data>-fsc = vl_fsc_recycled_nec THEN 'X' ELSE space ). " del - cvivo - 65605
          <fs_data>-fsc_recycled = COND #( WHEN <fs_data>-fsc IN t_fsc THEN 'X' ELSE space ).
          <fs_data>-texto = <fs_zwm_ltbk_adit>-texto. " cvivo - 65089
        ENDIF.

        " cvivo - 58678 - fase 2: en litografía el largo lo marcará la estación 3
        LOOP AT tl_zwm_ltbk_adit ASSIGNING <fs_zwm_ltbk_adit> WHERE benum = ls_data-benum AND nlpla CP '*1'.
          DATA(patron_ubic) = |*1|.
        ENDLOOP.

        IF sy-subrc NE 0. " si no hay estación 1 para la necesidad, es litografía
          patron_ubic = |*3|.
        ENDIF.



        "JCB: Miramos los números de pedido para el CI Number (BENUM) y lo ponemos        "
        CLEAR tl_nums_pedido.
        LOOP AT tl_zwm_ltbk_adit ASSIGNING <fs_zwm_ltbk_adit> WHERE benum = ls_data-benum AND nlpla CP patron_ubic. " la estación 1 marca el largo del pedido
          IF <fs_zwm_ltbk_adit>-upper_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-upper_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-upper_orderid INTO tl_nums_pedido. ENDIF.
          IF <fs_zwm_ltbk_adit>-lower_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-lower_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-lower_orderid INTO tl_nums_pedido. ENDIF.
        ENDLOOP.

        "Si no encuentra nada, por lo menos que coja uno si puede.
        IF tl_nums_pedido IS INITIAL.
          READ TABLE tl_zwm_ltbk_adit ASSIGNING <fs_zwm_ltbk_adit> WITH KEY benum = ls_data-benum.
          IF sy-subrc = 0.
            IF <fs_zwm_ltbk_adit>-upper_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-upper_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-upper_orderid INTO tl_nums_pedido. ENDIF.
            IF <fs_zwm_ltbk_adit>-lower_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-lower_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-lower_orderid INTO tl_nums_pedido. ENDIF.
          ENDIF.
        ENDIF.



        READ TABLE tl_nums_pedido ASSIGNING FIELD-SYMBOL(<fs_nums_pedido>) INDEX 1.
        IF sy-subrc = 0.
          <fs_data>-pedido = <fs_nums_pedido>.
          "Si hay más de un pedido ponemos + al final
          IF lines( tl_nums_pedido ) > 1.
            <fs_data>-pedido = |{ <fs_data>-pedido }+|.
          ENDIF.
*        ELSEIF iv_lgnum = '270' AND <fs_data>-pedido IS INITIAL. "Para SCY si no encuentra se pone BENUM: Las lineas en blanco
*          <fs_data>-pedido = ls_data-benum.
        ENDIF.
      ENDIF.

      CLEAR <fs_data>-length.

      IF <fs_zwm_ltbk_adit> IS ASSIGNED.
*      <fs_data>-length = zcl_wm_zwm_ltbk_adit_dao=>get_qty_4_benum( " cvivo - rendimiento
*             iv_benum = ls_data-benum
*             iv_lgnum = ls_data-lgnum
*         )-menge.
        <fs_data>-length = <fs_zwm_ltbk_adit>-menge.
      ELSE.
        LOOP AT tl_zwm_ltbk_adit ASSIGNING <fs_zwm_ltbk_adit> WHERE benum = ls_data-benum AND nlpla CP patron_ubic. " la estación 1 marca el largo del pedido
          <fs_data>-length = <fs_zwm_ltbk_adit>-menge.
        ENDLOOP.
      ENDIF.

*      <fs_data>-tbktx = ls_data-tbktx. " del - cvivo - 65089

      UNASSIGN <fs_zwm_ltbk_adit>.
    ENDIF.

    me->set_nlpla_idx_data(
                              EXPORTING
                              is_data =  ls_data
                              is_mat_data = ls_mat_data
                              iv_group = lv_group
                              iv_werks = lv_werks
                              iv_cal = lv_cal
                              iv_gramaje = lv_gramaje
                              iv_ancho = lv_ancho
                              iv_largo = lv_largo
                              iv_mtart = lv_mtart
                              CHANGING
                              cs_data = <fs_data>
                              ).


    READ TABLE tl_mlgn ASSIGNING FIELD-SYMBOL(<fs_mlgn>) WITH KEY matnr = lv_matnr.
    IF sy-subrc = 0.
      ASSIGN COMPONENT |NLPLA{ lv_nlpla_idx }_MATNR_EXTERNAL| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_matnr_external>).
      IF sy-subrc = 0.
        <fs_matnr_external> = <fs_mlgn>-zzmatnr_external.
      ENDIF.
    ENDIF.



    DATA(lv_nlpla) = 'NLPLA' && lv_nlpla_idx.
    DATA(lv_field) = lv_nlpla && '_MATNR'.

    IF wl_maquina-listado_apro_sin_agrup = space.
      IF lines( rt_data ) > 1.
        ASSIGN rt_data[ lines( rt_data ) - 1 ] TO FIELD-SYMBOL(<fs_prev_data>).
        IF <fs_prev_data>-related_id IS NOT INITIAL.
          ASSIGN rt_data[ id = <fs_prev_data>-related_id ] TO <fs_prev_data>.
        ENDIF.
        CHECK <fs_prev_data> IS ASSIGNED.
        ASSIGN COMPONENT: lv_field OF STRUCTURE <fs_data>       TO FIELD-SYMBOL(<fs_current>),
                          lv_field OF STRUCTURE <fs_prev_data>  TO FIELD-SYMBOL(<fs_previous>).
        IF <fs_current>           IS ASSIGNED         AND
           <fs_previous>          IS ASSIGNED         AND
           <fs_current>           = <fs_previous>     AND
           <fs_prev_data>-width   = <fs_data>-width   AND
           <fs_prev_data>-ztrim   = <fs_data>-ztrim   AND
           <fs_prev_data>-quality = <fs_data>-quality AND
            wl_maquina_1-parte_rebobinado IS INITIAL.

          lv_field = lv_nlpla && '_MENGE'.
          ASSIGN COMPONENT: lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_current_val>),
                            lv_field OF STRUCTURE <fs_prev_data> TO FIELD-SYMBOL(<fs_prev_val>).

          <fs_prev_val> = <fs_current_val> + <fs_prev_val>.
          lv_field = lv_nlpla && '_MEINS'.
          ASSIGN COMPONENT lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_meins>).
          <fs_meins> = ls_tbnum-altme.
          lv_field = lv_nlpla && '_GROUP'.
          ASSIGN COMPONENT lv_field OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_group>).
          <fs_group> = abap_true.
          <fs_data>-related_id = <fs_prev_data>-id.
*          IF vl_fila_vacia_scy = space. "Para lineas vacias de San Cayetano no se elimina
          <fs_data>-no_show = abap_true.
*          ENDIF.
          IF lv_nlpla CP patron_ubic.
            <fs_prev_data>-length = <fs_prev_data>-length +  zcl_wm_zwm_ltbk_adit_dao=>get_qty_4_benum( iv_benum = ls_data-benum
                                                                                                        iv_lgnum = ls_data-lgnum
                                                                                                        iv_lgpla = ls_data-nlpla )-menge.

            "Cuando dos necesidades se agrupan en una única línea, aunque la primera sólo tenga un pedido,
            "en pedido debe aparecer el carácter "+"
            IF <fs_prev_data>-pedido <> <fs_data>-pedido AND <fs_prev_data>-pedido NP '*#+'.
              <fs_prev_data>-pedido = |{ <fs_prev_data>-pedido }+|.
            ENDIF.
          ENDIF.
        ENDIF.
        UNASSIGN: <fs_current>, <fs_previous>.
      ENDIF.
    ENDIF.

    lv_old_benum = ls_data-benum.

  ENDLOOP.

  " exclude empty lines
  DELETE rt_data WHERE nlpla1 IS INITIAL AND nlpla2 IS INITIAL
  AND nlpla3 IS INITIAL AND nlpla4 IS INITIAL AND nlpla5 IS INITIAL.

  "Grabamos la lista de aprovisionamiento para usarla en la lista de bobinas y no tenerla que volver a calcular
  gt_aprov_list = rt_data.



  IF iv_exclude_no_show = abap_true.
    DELETE rt_data WHERE no_show = abap_true.
  ENDIF.

  "Cálculo de cantidades acumuladas para las estaciones (varias necesidades del mismo material para la misma estación)
  DATA vl_tabix_ini     TYPE sy-tabix.
  DATA vl_tabix_fin     TYPE sy-tabix.
  DATA vl_cantidad      TYPE ekpo-menge.
  DATA vl_matnr_actual  TYPE mara-matnr.
  DATA vl_fsc(1). " cvivo - 65348 - Si una tiene FSC, todas tienen FSC

  DO 5 TIMES.
    DATA(vl_index) = sy-index.
    CLEAR: vl_tabix_ini, vl_tabix_fin, vl_cantidad, vl_matnr_actual.

    LOOP AT rt_data ASSIGNING <fs_data>.
      DATA(vl_tabix) = sy-tabix.
      ASSIGN COMPONENT |nlpla{ vl_index }_matnr| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_matnr>).
      ASSIGN COMPONENT |nlpla{ vl_index }_menge| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_menge>).

      IF vl_matnr_actual IS INITIAL.
        vl_tabix_ini = vl_tabix_fin = vl_tabix.

      ELSE.
        IF vl_matnr_actual = <fs_matnr> AND wl_maquina_1-parte_rebobinado = space AND
           wl_maquina-listado_apro_sin_agrup = space AND                 "En partes rebobinado no se acumula
          <fs_matnr> <> zcl_si_prod_replenishment_ui5=>c_material_dummy.  "Material dummy no acumula
          vl_tabix_fin = vl_tabix.

        ELSE.
          WHILE vl_tabix_ini <= vl_tabix_fin.
            READ TABLE rt_data ASSIGNING FIELD-SYMBOL(<fs_data_aux>) INDEX vl_tabix_ini. " al cambiar el material actualizamos el primero del grupo anterior
            " con los datos grupales almacenados
            IF sy-subrc = 0.
              ASSIGN COMPONENT |nlpla{ vl_index }_menge_acum| OF STRUCTURE <fs_data_aux> TO FIELD-SYMBOL(<fs_menge_acum>).
              <fs_menge_acum> = vl_cantidad.
              ASSIGN COMPONENT |nlpla{ vl_index }_fsc| OF STRUCTURE <fs_data_aux> TO FIELD-SYMBOL(<fs_fsc>).
              <fs_fsc> = vl_fsc.
            ENDIF.
            ADD 1 TO vl_tabix_ini.
          ENDWHILE.

          CLEAR: vl_cantidad, vl_tabix_fin, vl_fsc. " al cambiar material reseteamos valores grupales
          vl_tabix_ini = vl_tabix_fin = vl_tabix.
        ENDIF.
      ENDIF.

      ADD <fs_menge> TO vl_cantidad.

      IF <fs_data>-fsc_recycled NE abap_false. " si uno del grupo tiene FSC lo almacenamos para marcarlo sobre
        vl_fsc = <fs_data>-fsc_recycled.      " el primero que es el que cuenta para la pantalla de propuesta
      ENDIF.

      vl_matnr_actual = <fs_matnr>.
    ENDLOOP.

    "Última vuelta
    IF vl_cantidad IS NOT INITIAL.
      WHILE ( vl_tabix_ini <= vl_tabix_fin ).
        READ TABLE rt_data ASSIGNING <fs_data_aux> INDEX vl_tabix_ini.
        IF sy-subrc = 0.
          ASSIGN COMPONENT |nlpla{ vl_index }_menge_acum| OF STRUCTURE <fs_data_aux> TO <fs_menge_acum>.
          <fs_menge_acum> = vl_cantidad.
          ASSIGN COMPONENT |nlpla{ vl_index }_fsc| OF STRUCTURE <fs_data_aux> TO <fs_fsc>.
          <fs_fsc> = vl_fsc.
        ENDIF.
        ADD 1 TO vl_tabix_ini.
      ENDWHILE.
    ENDIF.
  ENDDO.



  "Calculamos status de las estaciones
  CONSTANTS: cl_status_length_rojo     TYPE zwm_aprov_list_status_largo VALUE '1',
             cl_status_length_amarillo TYPE zwm_aprov_list_status_largo VALUE '2',
             cl_status_length_azul     TYPE zwm_aprov_list_status_largo VALUE '3',
             cl_status_length_verde    TYPE zwm_aprov_list_status_largo VALUE '4'.

  " cvivo - optimizar: calculamos aquí lo aprovisionado directamente, sin llamar de nuevo al listado
  CHECK rt_data IS NOT INITIAL.
  IF iv_cal_status_estaciones = abap_true.
    SELECT ltap~lgnum, ltap~tanum, ltap~tapos, ltap~vlenr, ltap~nlpla, ltak~benum, ltbk~rsnum, ltap~meins, ltap~nistm, ltap~matnr
          FROM ltap INNER JOIN ltak ON  ltak~lgnum = ltap~lgnum AND
                                        ltak~tanum = ltap~tanum
          INNER JOIN ltbk ON ltak~benum = ltbk~benum " ahora cogemos todas las necesidades para la reserva
                         AND ltak~lgnum = ltbk~lgnum
                         AND ltap~nlpla = ltbk~nlpla
                         AND ltak~rsnum = ltbk~rsnum " cvivo - incidencia
          LEFT OUTER JOIN zwm_ltak_adit ON zwm_ltak_adit~tanum EQ ltak~tanum
                                       AND zwm_ltak_adit~lgnum EQ ltak~lgnum " cvivo -65087- no tener en cuenta si está retrocedida
      FOR ALL ENTRIES IN @rt_data
      WHERE ltak~lgnum = @iv_lgnum
        AND ( ltbk~rsnum = @rt_data-nlpla1_rsnum OR
              ltbk~rsnum = @rt_data-nlpla2_rsnum OR
              ltbk~rsnum = @rt_data-nlpla3_rsnum OR
              ltbk~rsnum = @rt_data-nlpla4_rsnum OR
              ltbk~rsnum = @rt_data-nlpla5_rsnum )
        AND ltbk~rsnum NE @space
        AND ( zwm_ltak_adit~retro NE @abap_true OR
              zwm_ltak_adit~retro IS NULL )
      INTO TABLE @DATA(tl_ltap).

*      delete rt_data where retro
  ENDIF.

  LOOP AT rt_data ASSIGNING <fs_data>.
    "
    SHIFT <fs_data>-width LEFT DELETING LEADING '0'.

    " convert qtys to int
    <fs_data>-length = CONV i( <fs_data>-length ).

    <fs_data>-length_max = vl_length_max.

    "Calcular status:
    DATA(vl_porcentaje) = <fs_data>-length / <fs_data>-length_max * 100.
    <fs_data>-status_largo = COND #( WHEN vl_porcentaje < 10 THEN cl_status_length_rojo
                                     WHEN vl_porcentaje < 25 THEN cl_status_length_amarillo
                                     WHEN vl_porcentaje < 75 THEN cl_status_length_azul
                                     ELSE cl_status_length_verde ).

    IF iv_cal_status_estaciones = abap_true.
      " DEL - cvivo- optimizar, lo calculamos de una arriba
*      DATA(tl_bobine_list) = build_alist_bobine_ui5_v3( iv_lgnum         = iv_lgnum
*                                                        iv_only_ltap = abap_true " en la lista de aprov sólo coger las ya aprovisionadas - cvivo
*                                                        iv_id_aprov_list = <fs_data>-id ).
      "Estaciones
      DO 5 TIMES.
        ASSIGN COMPONENT |NLPLA{ sy-index }| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_nlpla>).
        CHECK sy-subrc = 0 AND <fs_nlpla> IS NOT INITIAL.
        ASSIGN COMPONENT |NLPLA{ sy-index }_STATUS| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_nlpla_status>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MENGE|  OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_nlpla_menge>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MENGE_SERV| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_nlpla_menge_serv>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MENGE_ACUM| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_nlpla_menge_acum>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_RSNUM| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_rsnum>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MEINS| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_meins_nlpla>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MATNR| OF STRUCTURE <fs_data> TO <fs_matnr>.
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_WGBEZ60| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_wgbez60>).
        CHECK sy-subrc = 0.
        ASSIGN COMPONENT |NLPLA{ sy-index }_MAKTX| OF STRUCTURE <fs_data> TO FIELD-SYMBOL(<fs_maktx>).
        CHECK sy-subrc = 0.

        IF <fs_matnr> = zcl_si_prod_replenishment_ui5=>c_material_dummy.
          <fs_wgbez60> = <fs_maktx> = 'GENERICO'.
        ENDIF.



        LOOP AT tl_ltap ASSIGNING FIELD-SYMBOL(<ltap>) WHERE rsnum = <fs_rsnum>.
          DATA(lv_conv_qty) = conv_matnr( iv_matnr      = <ltap>-matnr
                                          iv_meins_orig = <ltap>-meins
                                          iv_meins_dest = <fs_meins_nlpla>
                                          iv_qty        = <ltap>-nistm ).

          ADD lv_conv_qty TO <fs_nlpla_menge_serv>.
        ENDLOOP.

        IF <fs_nlpla_menge_serv> > 0.
          <fs_nlpla_status> = COND #( WHEN <fs_nlpla_menge_serv> < <fs_nlpla_menge_acum> THEN 'X' ELSE 'A' ).
        ENDIF.
      ENDDO.
    ENDIF.

  ENDLOOP.

  " must remove at the end the unwanted rows -> sum quantities...
  IF iv_id IS NOT INITIAL.
    DELETE rt_data WHERE id NE iv_id.
  ENDIF.


  "Miramos si tienen parte de rebobinado
  CHECK rt_data IS NOT INITIAL.
  IF wl_maquina_1-parte_rebobinado = 'X'.
    SELECT *
      INTO TABLE @DATA(tl_partes_rebob_bp)
      FROM zwm_parte_reb_bp
      FOR ALL ENTRIES IN @rt_data
      WHERE werks       = @wl_maquina_1-werks AND
            id_maquina  = @wl_maquina_1-id    AND
            tbnum       = @rt_data-tbnum.
    LOOP AT rt_data ASSIGNING <fs_data>.
      <fs_data>-cla_parte_rebob = 'X'.
      READ TABLE tl_partes_rebob_bp ASSIGNING FIELD-SYMBOL(<fs_partes_rebob_bp>)
        WITH KEY tbnum = <fs_data>-tbnum.
      IF sy-subrc = 0.
        <fs_data>-cod_parte_rebob = <fs_partes_rebob_bp>-cod_parte_rebob.
        <fs_data>-pedido          = |{ <fs_data>-cod_parte_rebob ALPHA = OUT }|.
      ENDIF.
    ENDLOOP.


    SELECT werks, id_maquina, cod_parte_rebob
      INTO TABLE @DATA(tl_partes_rebob_c)
      FROM zwm_parte_reb_c
      FOR ALL ENTRIES IN @rt_data
      WHERE werks           = @wl_maquina_1-werks       AND
            id_maquina      = @wl_maquina_1-id          AND
            cod_parte_rebob = @rt_data-cod_parte_rebob  AND
            cla_cerrado     = @space.

    LOOP AT rt_data ASSIGNING <fs_data>.
      READ TABLE tl_partes_rebob_c ASSIGNING FIELD-SYMBOL(<fs_partes_rebob_c>)
        WITH KEY cod_parte_rebob = <fs_data>-cod_parte_rebob.
      IF sy-subrc <> 0.
        DELETE rt_data.
      ENDIF.
    ENDLOOP.


  ENDIF.


ENDMETHOD.
METHOD build_bobecm_bob_ui5.
  DATA lr_bobine TYPE RANGE OF zwm_bobine.


  CLEAR rt_data.

  " id will hold the UA -> unique across the system

  lr_bobine = VALUE #( ( sign = 'I' option = 'EQ' low = iv_id ) ).

  SELECT a~matnr, a~lenum AS charg, a~werks, a~lenum AS id
  FROM lqua AS a
  INNER JOIN t320 AS b
  ON a~werks = b~werks
  INTO CORRESPONDING FIELDS OF TABLE @rt_data
  WHERE a~lenum IN @lr_bobine
  AND b~lgnum = @iv_lgnum.



ENDMETHOD.
METHOD build_bobecm_list_ui5.
  DATA lr_id_bob TYPE RANGE OF zwm_ecm_bobine-id_bob_ecm.
  DATA ls_mara TYPE mara.
  DATA l_texto TYPE zwm_ltbk_adit-texto.
  CLEAR rt_data.

  DATA(lt_data) = me->get_aprovis_list( iv_lgnum          = iv_lgnum
                                        iv_restrict_rows  = abap_true
                                        iv_all_stat       = abap_false
                                        iv_nlpla          = iv_nlpla ). " cvivo - acceder sólo para la ubicación
  DELETE lt_data WHERE statu = 'E'.
  DATA lt_data_old LIKE lt_data.
*  DATA(lt_data_old) = me->get_aprovis_list( iv_lgnum          = iv_lgnum
*                                            iv_restrict_rows  = abap_false
*                                            iv_all_stat       = abap_true
*                                            iv_nlpla          = iv_nlpla  ).

  SORT: lt_data BY pdatu pzeit, lt_data_old BY pdatu DESCENDING pzeit DESCENDING.

  SELECT SINGLE werks
    FROM t320
    INTO @DATA(lv_werks)
    WHERE lgnum = @iv_lgnum.

  " cvivo - Optimización rendimiento
  IF lt_data IS NOT INITIAL.
    DATA(lt_tbnum) = lt_data[ 1 ]-lt_tbnum." simplemente para declarar, trampeando
  ENDIF.

  LOOP AT lt_data INTO DATA(ls_data).
    LOOP AT ls_data-lt_tbnum INTO DATA(ls_tbnum).
      COLLECT ls_tbnum INTO lt_tbnum.
    ENDLOOP.
  ENDLOOP.

*  SELECT * FROM mara
*    FOR ALL ENTRIES IN @lt_tbnum
*    WHERE matnr EQ @lt_tbnum-matnr
*    ORDER BY PRIMARY KEY
*      INTO TABLE @DATA(lt_mara).

  SELECT ztpi0013~calidad, mara~matnr, mara~zzgramaje, mara~zzancho, mara~zzlargo,
         mara~mtart, mara~matkl
    FROM ztpi0013  INNER JOIN ztpi0003 ON ztpi0013~valor_externo EQ ztpi0003~zvalor_externo
                   INNER JOIN ztpi0001 ON ztpi0001~zcodigo       EQ ztpi0003~zcodigo
                   INNER JOIN mara     ON mara~matkl             EQ ztpi0003~zvalor_sap
    FOR ALL ENTRIES IN @lt_tbnum
    WHERE mara~matnr      EQ @lt_tbnum-matnr AND
          ztpi0003~werks  EQ @lv_werks
    INTO TABLE @DATA(lt_calidades).

  IF sy-subrc NE 0. " cvivo - Nueva tabla no dependiente de AS400
    SELECT ztpi0014~calidad, mara~matnr, mara~zzgramaje, mara~zzancho, mara~zzlargo,
            mara~mtart, mara~matkl
      FROM ztpi0014 INNER JOIN mara ON mara~matkl EQ ztpi0014~matkl
      FOR ALL ENTRIES IN @lt_tbnum
      WHERE mara~matnr      EQ @lt_tbnum-matnr AND
            ztpi0014~lgnum  EQ @iv_lgnum
      INTO CORRESPONDING FIELDS OF TABLE @lt_calidades.
  ENDIF.

  IF lt_tbnum IS NOT INITIAL.
    SELECT lgnum, tbnum, upper_orderid, lower_orderid, benum, fsc, menge,
      texto " cvivo - 65089
      FROM zwm_ltbk_adit
      FOR ALL ENTRIES IN @lt_tbnum
      WHERE lgnum = @lt_tbnum-lgnum
        AND tbnum = @lt_tbnum-tbnum
      ORDER BY PRIMARY KEY
      INTO TABLE @DATA(tl_zwm_ltbk_adit).
  ENDIF.

  LOOP AT lt_data INTO ls_data.
    CLEAR: ls_mara.
    DATA(ls_mat_data) = me->get_mat_info_lznum( is_data = ls_data ).

    ls_tbnum = ls_data-lt_tbnum[ 1 ].

    READ TABLE lt_calidades INTO DATA(ls_calidades) WITH KEY matnr = ls_tbnum-matnr.
    CHECK sy-subrc EQ 0.

    MOVE-CORRESPONDING ls_calidades TO ls_mara.

    "JCB. Obtener numeros de pedido
    DATA: tl_nums_pedido TYPE TABLE OF zwm_ltbk_adit-upper_orderid,
          vl_pedido2     TYPE zwm_nt_ui5_bob_ecm_str-pedido2.
    CLEAR: tl_nums_pedido, vl_pedido2, l_texto.

    IF ls_data-lt_tbnum IS NOT INITIAL.
      READ TABLE tl_zwm_ltbk_adit ASSIGNING FIELD-SYMBOL(<fs_zwm_ltbk_adit>) WITH KEY benum = ls_data-benum.

      IF sy-subrc = 0.
        "JCB: Miramos los números de pedido para el CI Number (BENUM) y lo ponemos
        IF <fs_zwm_ltbk_adit>-upper_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-upper_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-upper_orderid INTO tl_nums_pedido. ENDIF.
        IF <fs_zwm_ltbk_adit>-lower_orderid IS NOT INITIAL AND <fs_zwm_ltbk_adit>-lower_orderid <> '0'. COLLECT <fs_zwm_ltbk_adit>-lower_orderid INTO tl_nums_pedido. ENDIF.
        l_texto = <fs_zwm_ltbk_adit>-texto. "cvivo - 65089
*
        READ TABLE tl_nums_pedido ASSIGNING FIELD-SYMBOL(<fs_nums_pedido>) INDEX 1.
        IF sy-subrc = 0.
          vl_pedido2 = <fs_nums_pedido>.
          "Si hay más de un pedido ponemos + al final
          IF lines( tl_nums_pedido ) > 1.
            vl_pedido2 = |{ vl_pedido2 }+|.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    APPEND VALUE #( id = code_line_id( is_data = ls_data iv_tbnum_mode = abap_true )
                    mat_id = ls_mat_data-mat_id
                    width = ls_mat_data-width
                    ztrim = ls_mat_data-ztrim
                    quality = ls_mat_data-quality
                    canal = ls_mat_data-canal
                    length = ls_tbnum-menga
                    meins = ls_tbnum-altme
                    pedido = ls_data-benum
                    pedido2 = vl_pedido2
                    nlpla = ls_data-nlpla
                    matnr = ls_tbnum-matnr
                    editable = abap_true
                    maktx =  zcl_wm_nt_generic=>get_mat_txt_omp(
                                    iv_werks = lv_werks
                                    iv_cal   = ls_calidades-calidad
                                    is_mara  = ls_mara )
                    texto = l_texto " cvivo - 65089
    ) TO rt_data.

    DELETE lt_data_old WHERE lgnum = ls_data-lgnum AND tbnum = ls_data-tbnum.

  ENDLOOP.



  " now add first 2 rows of old data
  DELETE lt_data_old WHERE nlpla NE iv_nlpla.

  " fetch history from zwm_Ecm_bobine table
*  IF lines( lt_data_old ) > 0.

  "JCB 26.04.21. Ticket 65951. Incidencia orden de pedidos finalizados
*    lr_id_bob = VALUE #( FOR ls_dold IN lt_data_old ( sign = 'I' option = 'EQ' low = ls_dold-rsnum ) ).
*    SELECT id_bob_ecm, changed_at FROM zwm_ecm_bobine
*      INTO TABLE @DATA(lt_bobine)
*      WHERE id_bob_ecm IN @lr_id_bob
*      ORDER BY changed_at ASCENDING.

  DATA tl_rsnum_rg TYPE RANGE OF rsnum.
  tl_rsnum_rg = VALUE #( FOR ls_dold IN lt_data ( sign = 'I' option = 'EQ' low = ls_dold-rsnum ) ).
  SELECT rsnum, MAX( fecha ) AS fecha, MAX( hora ) AS hora
    INTO TABLE @DATA(lt_bobine)
    FROM zwm_intf_bhs
    UP TO 2 ROWS
    WHERE lgnum          = @iv_lgnum AND
          porta_bobinas  = @iv_nlpla AND
          rsnum          NOT IN @tl_rsnum_rg
    GROUP BY rsnum
    ORDER BY fecha DESCENDING, hora DESCENDING.

  SORT lt_bobine BY fecha hora.


  DATA(lv_cnt) = 0.
  LOOP AT lt_bobine INTO DATA(ls_bobine).
*      LOOP AT lt_data_old INTO ls_data WHERE rsnum = ls_bobine-id_bob_ecm.

    lt_data_old = me->get_aprovis_list( iv_lgnum          = iv_lgnum
                                        iv_restrict_rows  = abap_false
                                        iv_all_stat       = abap_true
                                        iv_nlpla          = iv_nlpla
                                        iv_rsnum          = ls_bobine-rsnum ).



    LOOP AT lt_data_old INTO ls_data WHERE rsnum = ls_bobine-rsnum.
      ls_mat_data = me->get_mat_info_lznum( is_data = ls_data ).

      DATA(lv_id) = code_line_id( is_data = ls_data iv_tbnum_mode = abap_true ).

      CHECK NOT line_exists( rt_data[ id = lv_id ] ).
      ADD 1 TO lv_cnt.
      ls_tbnum = ls_data-lt_tbnum[ 1 ].

      SELECT SINGLE *
        FROM mara
        INTO @ls_mara
        WHERE matnr = @ls_tbnum-matnr.



      "JCB. Obtener numeros de pedido
      CLEAR: tl_nums_pedido, vl_pedido2, l_texto.

      IF ls_data-lt_tbnum IS NOT INITIAL.
        SELECT lgnum, tbnum, upper_orderid, lower_orderid, benum, fsc, menge, texto "cvivo - 65089
          INTO TABLE @tl_zwm_ltbk_adit
          FROM zwm_ltbk_adit
          FOR ALL ENTRIES IN @ls_data-lt_tbnum
          WHERE lgnum = @ls_data-lt_tbnum-lgnum AND
                tbnum = @ls_data-lt_tbnum-tbnum.
        IF sy-subrc = 0.
          "JCB: Miramos los números de pedido para el CI Number (BENUM) y lo ponemos        "
          LOOP AT tl_zwm_ltbk_adit ASSIGNING <fs_zwm_ltbk_adit> WHERE benum = ls_data-benum.
            IF <fs_zwm_ltbk_adit>-upper_orderid IS NOT INITIAL. COLLECT <fs_zwm_ltbk_adit>-upper_orderid INTO tl_nums_pedido. ENDIF.
            IF <fs_zwm_ltbk_adit>-lower_orderid IS NOT INITIAL. COLLECT <fs_zwm_ltbk_adit>-lower_orderid INTO tl_nums_pedido. ENDIF.
            l_texto = <fs_zwm_ltbk_adit>-texto. "cvivo - 65089
          ENDLOOP.

          READ TABLE tl_nums_pedido ASSIGNING <fs_nums_pedido> INDEX 1.
          IF sy-subrc = 0.
            vl_pedido2 = <fs_nums_pedido>.
            "Si hay más de un pedido ponemos + al final
            IF lines( tl_nums_pedido ) > 1.
              vl_pedido2 = |{ vl_pedido2 }+|.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.


      INSERT VALUE #( id = code_line_id( is_data = ls_data iv_tbnum_mode = abap_true )
                      mat_id = ls_mat_data-mat_id
                      width = ls_mat_data-width
                      ztrim = ls_mat_data-ztrim
                      quality = ls_mat_data-quality
                      canal = ls_mat_data-canal
                      length = ls_tbnum-menga
                      meins = ls_tbnum-altme
                      pedido = ls_data-benum
                      pedido2 = vl_pedido2
                      nlpla = ls_data-nlpla
                      matnr = ls_tbnum-matnr
                      editable = abap_false
                      maktx = zcl_wm_nt_generic=>get_mat_txt_omp(
                                  iv_werks = lv_werks
                                  is_mara  = ls_mara )
                      texto = l_texto "cvivo - 65089
      ) INTO rt_data INDEX lv_cnt.



    ENDLOOP.
  ENDLOOP.
*  ENDIF.




  DELETE rt_data WHERE nlpla NE iv_nlpla.

  " must remove at the end the unwanted rows -> sum quantities...
  CHECK iv_id IS NOT INITIAL.
  DELETE rt_data WHERE id NE iv_id.


ENDMETHOD.
METHOD build_bobecm_list_ui5_v2.
  TYPES: BEGIN OF lty_dec_resb,
           lgnum    TYPE ltbk-lgnum,
           tbnum    TYPE ltbk-tbnum,
*           tbktx    TYPE ltbk-tbktx, " del" cvivo - 65089
           texto    TYPE zwm_ltbk_adit-texto, " cvivo - 65089
           rsnum    TYPE rkpf-rsnum,
           editable TYPE boolean,
         END OF lty_dec_resb,
         ltty_dec_resb TYPE STANDARD TABLE OF lty_dec_resb WITH DEFAULT KEY.
  DATA lt_dec_resb TYPE ltty_dec_resb.
  " same as v1, but must group by rsnum
  CLEAR rt_data.
  DATA(lt_data) = me->build_bobecm_list_ui5(
                  iv_lgnum = iv_lgnum
                  iv_nlpla = iv_nlpla
                  iv_id    = iv_id
              ).
  CHECK lines( lt_data ) > 0.


  DATA(wl_maquina) = maquinas_getdetail( iv_nlpla  ).


  " fill range for reading resb
  LOOP AT lt_data INTO DATA(ls_data).
    DATA(ls_dec) = me->decode_line_id(
               iv_id         = ls_data-id
               iv_tbnum_mode = abap_true
           ).

    " cvivo - Optimizar
    APPEND VALUE #( lgnum = ls_dec-lgnum tbnum = ls_dec-tbnum rsnum = space editable = ls_data-editable ) TO lt_dec_resb. " aquí aún falta el rsnum, que lo ponemos después

*    SELECT SINGLE rsnum FROM ltbk
*    INTO @DATA(lv_rsnum)
*    WHERE lgnum = @ls_dec-lgnum
*    AND tbnum = @ls_dec-tbnum.
*    DATA(ls_resb) =
*    zcl_wm_nt_generic=>get_resb_for_nt( is_ltbk = VALUE #( rsnum = lv_rsnum benum = ls_data-pedido ) iv_only_open = abap_false ).
*    APPEND VALUE #( lgnum = ls_dec-lgnum tbnum = ls_dec-tbnum rsnum = ls_resb-rsnum editable = ls_data-editable ) TO lt_dec_resb.
  ENDLOOP.

  " optimizar
  SELECT resb~rsnum, resb~rspos, ltbk~tbnum, zwm_ltbk_adit~texto ", ltbk~TBKTX " del - cvivo - 65089
    INTO TABLE @DATA(lt_resb)
    FROM resb INNER JOIN ltbk ON  ltbk~rsnum EQ resb~rsnum AND
                                  ltbk~benum EQ resb~sgtxt
              INNER JOIN zwm_ltbk_adit ON zwm_ltbk_adit~tbnum EQ ltbk~tbnum AND
                                          zwm_ltbk_adit~lgnum EQ ltbk~lgnum " cvivo - 65089
    FOR ALL ENTRIES IN @lt_dec_resb
    WHERE ltbk~lgnum EQ @lt_dec_resb-lgnum  AND
          ltbk~tbnum EQ @lt_dec_resb-tbnum.

  LOOP AT lt_dec_resb ASSIGNING FIELD-SYMBOL(<line>).
    READ TABLE lt_resb WITH KEY tbnum = <line>-tbnum INTO DATA(ls_resb).
    IF sy-subrc EQ 0.
      MOVE ls_resb-rsnum TO <line>-rsnum.
*      <line>-tbktx = ls_resb-tbktx. " del " cvivo - 65089

    ENDIF.
  ENDLOOP.

  " now group data
  "SORT lt_dec_resb BY rsnum.
  "    DELETE ADJACENT DUPLICATES FROM lt_dec_resb COMPARING rsnum.
*  DATA(lv_cnt) = 0.
  LOOP AT lt_dec_resb INTO DATA(ls_dec_resb).

    DATA(lv_id) = me->code_line_id(
                  is_data       = CORRESPONDING #( ls_dec_resb )
                  iv_tbnum_mode = abap_true
              ).
    DATA(lv_rsnum_id) = me->code_line_id(
    is_data       = VALUE #( rsnum = ls_dec_resb-rsnum )
*                   iv_tbnum_mode = ABAP_FALSE
    iv_rsnum_mode = abap_true      ).

*    IF ls_dec_resb-editable = abap_false AND NOT line_exists( rt_data[ id = lv_rsnum_id ] ) AND lv_rsnum_id NE iv_current_id.
*      lv_cnt = lv_cnt + 1.
*    ENDIF.

    LOOP AT lt_data INTO DATA(ls_data_aux) WHERE id = lv_id.
      DATA(posicion) = sy-tabix.

      IF NOT line_exists( rt_data[ id = lv_rsnum_id ] ) OR wl_maquina-listado_apro_sin_agrup = 'X'. "OR ls_data_aux-matnr = zcl_si_prod_replenishment_ui5=>c_material_dummy.
        APPEND lt_data[ id = lv_id ] TO rt_data ASSIGNING FIELD-SYMBOL(<fs_data>).
        <fs_data>-id    = lv_rsnum_id.
        IF wl_maquina-listado_apro_sin_agrup = 'X'.
          <fs_data>-tbnum = ls_dec_resb-tbnum.
        ENDIF.
*        <fs_data>-tbktx = ls_dec_resb-tbktx. " cvivo - 65089
        IF lv_rsnum_id = iv_current_id.
          <fs_data>-editable = abap_true.
        ENDIF.

      ELSE.
        ASSIGN rt_data[ id = lv_rsnum_id ] TO <fs_data>.
        CHECK sy-subrc = 0.
        <fs_data>-length = <fs_data>-length + ls_data_aux-length.
        IF <fs_data>-quality NE ls_data_aux-quality.
          <fs_data>-quality = 'Varias'.
        ENDIF.

        "Si hay varios pedidos añadir el más
        IF <fs_data>-pedido2 NE ls_data_aux-pedido2 AND <fs_data>-pedido2 NP '*#+'.
          <fs_data>-pedido2 = |{ <fs_data>-pedido2 }+|.
        ENDIF.

      ENDIF.

      IF <fs_data>-matnr = zcl_si_prod_replenishment_ui5=>c_material_dummy.
        <fs_data>-maktx = 'GENERICO'.
      ENDIF.

      " cvivo  62805 - se da la circunstancia de que si una NT pierde la reserva (se ha borrado), el programa es incapaz
      " de borrarla tras consumo posterior debido que está montando el listado a partir de las reservas; devolvemos las
      " que detectamos como huérfanas de reserva para que se pueda proceder a su borrado
      DELETE lt_data INDEX posicion.
    ENDLOOP.
  ENDLOOP.

  " cvivo  62805
  IF lt_data[] IS NOT INITIAL.
    et_huerfanas[] = lt_data[].
  ENDIF.

  " now remove non-editable
*  lv_cnt = lv_cnt - 2.
*  CHECK lv_cnt > 0.
*  DELETE rt_data FROM 1 TO lv_cnt.

  DATA vl_tabix_delete TYPE sy-tabix.
  READ TABLE rt_data TRANSPORTING NO FIELDS WITH KEY editable = 'X'.
  IF sy-subrc = 0.
    vl_tabix_delete = sy-tabix - 1.
  ELSE.
    vl_tabix_delete = lines( rt_data ).
  ENDIF.
  SUBTRACT 2 FROM vl_tabix_delete.
  IF vl_tabix_delete > 0.
    DELETE rt_data FROM 1 TO vl_tabix_delete.
  ENDIF.


ENDMETHOD.
METHOD calc_base_diametro.

**********************************************************************
*-----------------------------V2-------------------------------------*
**********************************************************************

**********************************************************************
* Parámetros locales
**********************************************************************

****** CONSTANTS

  CONSTANTS: lc_base_diam TYPE i VALUE 200.

****** RANGES

  DATA: lr_name TYPE RANGE OF rvari_vnam.

****** VBLES

  DATA: lv_espesor  TYPE umbsz,
        lv_metros   TYPE umbsz,
        lv_kg       TYPE bstmg,
        lv_bstmg    TYPE bstmg.

  DATA: k_low  TYPE p DECIMALS 6,
        k_high TYPE p DECIMALS 6.


**********************************************************************
* Validaciones
**********************************************************************

  CHECK iv_diam IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** RECUPERAMOS CONSTANTES DE TVARVC

" fetch constants
*ZDIAK_2001
*ZDIAMANDRIL_2001

  lr_name = VALUE #( ( sign = 'I' option = 'CP' low = 'ZDIA*_' && iv_werks ) ).

  SELECT *
    FROM tvarvc
    INTO TABLE @DATA(lt_const)
   WHERE name IN @lr_name.

  IF lines( lt_const ) <> 2.
    RAISE missing_constants.
  ENDIF.

****** RECUPERAMOS DATOS DE BOBINA

  " fetch mara data
  SELECT SINGLE zzgramaje, zzancho
    FROM mara
    INTO @DATA(ls_mara)
   WHERE matnr = @iv_matnr.

  IF sy-subrc NE 0.
    RAISE missing_matnr.
  ENDIF.

****** CALCULO DEL ESPESOR

  " cvivo - 64841 - Se intenta mejorar el cálculo en base a una tabla de calibraciones del espesor
  SELECT SINGLE @abap_true
    FROM tvarvc " si el nuevo cálculo está activado
    INTO @DATA(result)
   WHERE name EQ 'ZDIA_WM_CALIBRADO'
     AND low NE @abap_false.

  IF sy-subrc NE 0. " si no está activado, cálculo antiguo, con constante
    " fetch K From constants
    TRY.
      lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAK_' && iv_werks ]-low ).
    CATCH cx_root.
      RAISE missing_constants.
    ENDTRY.

  ELSE. " cogemos el rango inferior y superior y hacemos una media del factor (intentando replicar la progresividad)

    "K INFERIOR
    SELECT SINGLE *
      FROM zwm_espes_calibr
      INTO @DATA(low)
     WHERE gramaje EQ ( SELECT MAX( gramaje ) FROM zwm_espes_calibr WHERE gramaje LE @ls_mara-zzgramaje ).

    IF sy-subrc NE 0.
      RAISE missing_constants.
    ENDIF.

    "K SUPERIOR
    SELECT SINGLE *
      FROM zwm_espes_calibr
      INTO @DATA(high)
     WHERE gramaje EQ ( SELECT MIN( gramaje ) FROM zwm_espes_calibr WHERE gramaje GE @ls_mara-zzgramaje ).

    IF sy-subrc NE 0.
      RAISE missing_constants.
    ENDIF.

    "K MEDIA
    k_low = ( low-espesor / low-gramaje ) * 1000.
    k_high = ( high-espesor / high-gramaje ) * 1000.
    lv_bstmg = ( k_low + k_high ) / 2.

  ENDIF.

  " formula taken from ZXMG0U02
  lv_espesor = ( lv_bstmg * ls_mara-zzgramaje ).   " calculamos primero el espesor
  " fetch Mandril From constants

****** CALCULO DEL MANDRIL

  TRY.
    lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAMANDRIL_' && iv_werks ]-low ). "Se lo trae de la constante TVARVC
  CATCH cx_root.
    RAISE missing_constants.
  ENDTRY.

****** CALCULO DEL DIAMETRO

  DATA(lv_diam_base) = COND #(  WHEN iv_diam IS NOT INITIAL THEN iv_diam ELSE lc_base_diam ).

  TRY.

***** METROS

    "Longitud metros restantes = PI (r+(e/1000)+R) (R-r) / (e/1000) = PI * a * b / c
    " siendo pi
    "        a = (r+(e/1000)+R)
    "        b = (R-r)
    "        c = (e/1000)

    DATA: lv_pi TYPE ATP_DEC_RATE,
          lv_a  TYPE atp_dec_rate,
          lv_b  TYPE atp_dec_rate,
          lv_c  TYPE atp_dec_rate.

    lv_pi = ( 314159 / 100000 ).
    lv_a  = ( lv_bstmg + ( lv_espesor / 1000000 ) +  ( ( lv_diam_base / 2 ) / 100 ) ).
    lv_b  = COND #( WHEN ( ( lv_diam_base / 2 ) / 100 ) < lv_bstmg THEN lv_bstmg ELSE ( ( lv_diam_base / 2 ) / 100 ) - lv_bstmg ).
    lv_c  = ( lv_espesor / 1000000 ).

    lv_metros = ( lv_pi * lv_a * lv_b ) / lv_c.

***** KG

    lv_kg = ( ( ls_mara-zzgramaje / 1000 ) * ( ls_mara-zzancho / 1000 ) * lv_metros ). " convertimos a KG


*      metros = ( ( 314159 / 100000 ) * ( lv_bstmg + ( espesor / 1000000 ) +  ( ( lv_diam_base / 2 ) / 100 ) ) * ( ( ( lv_diam_base / 2 ) / 100 ) - lv_bstmg ) ) / ( espesor / 1000000 ). " calculamos primero en M
**         " Fórmula -> =([@Pi]*([@Mandril]+([@Espesor]/1000000)+(([@[Radio (cm)]])/100))*((([@[Radio (cm)]])/100)-[@Mandril]))/([@Espesor]/1000000)
*      lv_kg = ( ( ls_mara-zzgramaje / 1000 ) * ( ls_mara-zzancho / 1000 ) * metros ). " convertimos a KG
    CATCH cx_sy_arithmetic_overflow.
      RAISE overflow.
  ENDTRY.

****** RESULTADO

  ev_kg = lv_kg.
  ev_dia = lv_diam_base.
  ev_m = lv_metros.


**********************************************************************
*-----------------------------V2-------------------------------------*
**********************************************************************

**********************************************************************
*-----------------------------V1-------------------------------------*
**********************************************************************
*
*  CONSTANTS: gc_base_diam TYPE i VALUE 200.
*  DATA lr_name TYPE RANGE OF rvari_vnam.
*  DATA: espesor  TYPE umbsz,
*        metros   TYPE umbsz
*        lv_kg    TYPE bstmg,
*        lv_bstmg TYPE bstmg.
*
*  CLEAR: ev_kg, ev_dia.
*  " fetch constants
*ZDIAK_2001
*ZDIAMANDRIL_2001
*
*  lr_name = VALUE #( ( sign = 'I' option = 'CP' low = 'ZDIA*_' && iv_werks ) ).
*  SELECT * FROM tvarvc INTO TABLE @DATA(lt_const) WHERE name IN @lr_name.
*  IF lines( lt_const ) <> 2.
*    RAISE missing_constants.
*  ENDIF.
*
*  " fetch mara data
*  SELECT SINGLE zzgramaje, zzancho FROM mara
*    INTO @DATA(ls_mara) WHERE matnr = @iv_matnr.
*  IF sy-subrc NE 0.
*    RAISE missing_matnr.
*  ENDIF.
*
*  " cvivo - 64841 - Se intenta mejorar el cálculo en base a una tabla de calibraciones del espesor
*  SELECT SINGLE @abap_true FROM tvarvc " si el nuevo cálculo está activado
*  INTO @DATA(result)
*        WHERE name EQ 'ZDIA_WM_CALIBRADO'
*        AND low NE @abap_false.
*
*  IF sy-subrc NE 0. " si no está activado, cálculo antiguo, con constante
*    " fetch K From constants
*    TRY.
*        lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAK_' && iv_werks ]-low ).
*      CATCH cx_root.
*        RAISE missing_constants.
*    ENDTRY.
*  ELSE. " cogemos el rango inferior y superior y hacemos una media del factor (intentando replicar la progresividad)
*    SELECT SINGLE * FROM zwm_espes_calibr
*    INTO @DATA(low)
*          WHERE gramaje EQ ( SELECT MAX( gramaje ) FROM zwm_espes_calibr WHERE gramaje LE @ls_mara-zzgramaje ).
*
*    IF sy-subrc NE 0.
*      RAISE missing_constants.
*    ENDIF.
*
*    SELECT SINGLE * FROM zwm_espes_calibr
*    INTO @DATA(high)
*          WHERE gramaje EQ ( SELECT MIN( gramaje ) FROM zwm_espes_calibr WHERE gramaje GE @ls_mara-zzgramaje ).
*
*    IF sy-subrc NE 0.
*      RAISE missing_constants.
*    ENDIF.
*
*    DATA: k_low  TYPE p DECIMALS 6,
*          k_high TYPE p DECIMALS 6.
*
*    k_low = ( low-espesor / low-gramaje ) * 1000.
*    k_high = ( high-espesor / high-gramaje ) * 1000.
*
*    lv_bstmg = ( k_low + k_high ) / 2.
*  ENDIF.
*
*  " formula taken from ZXMG0U02
*  espesor = ( lv_bstmg * ls_mara-zzgramaje ).   " calculamos primero el espesor
*  " fetch Mandril From constants
*  TRY.
*      lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAMANDRIL_' && iv_werks ]-low ).
*    CATCH cx_root.
*      RAISE missing_constants.
*  ENDTRY.
*
*  DATA(lv_diam_base) = COND #(  WHEN iv_diam IS NOT INITIAL THEN iv_diam ELSE gc_base_diam ).
*
*  TRY.
*      metros = ( ( 314159 / 100000 ) * ( lv_bstmg + ( espesor / 1000000 ) +  ( ( lv_diam_base / 2 ) / 100 ) ) * ( ( ( lv_diam_base / 2 ) / 100 ) - lv_bstmg ) ) / ( espesor / 1000000 ). " calculamos primero en M
**         " Fórmula -> =([@Pi]*([@Mandril]+([@Espesor]/1000000)+(([@[Radio (cm)]])/100))*((([@[Radio (cm)]])/100)-[@Mandril]))/([@Espesor]/1000000)
*      lv_kg = ( ( ls_mara-zzgramaje / 1000 ) * ( ls_mara-zzancho / 1000 ) * metros ). " convertimos a KG
*    CATCH cx_sy_arithmetic_overflow.
*      RAISE overflow.
*  ENDTRY.
*
*
*  ev_kg = lv_kg.
*  ev_dia = lv_diam_base.
*  ev_m = metros.
*
**********************************************************************
*-----------------------------V1-------------------------------------*
**********************************************************************

ENDMETHOD.
METHOD calc_diam_con_kg.
  DATA lr_name TYPE RANGE OF rvari_vnam.
  DATA: espesor  TYPE bstmg,
        metros   TYPE bstmg,
        lv_bstmg TYPE bstmg.

  CLEAR: ev_dia.
  " fetch constants
*ZDIAK_2001
*ZDIAMANDRIL_2001



  " fetch mara data
  SELECT SINGLE zzgramaje, zzancho FROM mara
  INTO @DATA(ls_mara) WHERE matnr = @iv_matnr.
  IF sy-subrc NE 0.
    RAISE missing_matnr.
  ENDIF.

  lr_name = VALUE #( ( sign = 'I' option = 'CP' low = 'ZDIA*_' && iv_werks ) ).
  SELECT * FROM tvarvc INTO TABLE @DATA(lt_const) WHERE name IN @lr_name.
  IF lines( lt_const ) <> 2.
    RAISE missing_constants.
  ENDIF.

  " calc base for DIA = 200

  " cvivo - 64841 - Se intenta mejorar el cálculo en base a una tabla de calibraciones del espesor
  SELECT SINGLE @abap_true FROM tvarvc " si el nuevo cálculo está activado
    INTO @DATA(result)
    WHERE name EQ 'ZDIA_WM_CALIBRADO'
      AND low NE @abap_false.

  IF sy-subrc NE 0. " si no está activado, cálculo antiguo, con constante
    " fetch K From constants
    TRY.
        lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAK_' && iv_werks ]-low ).
      CATCH cx_root.
        RAISE missing_constants.
    ENDTRY.
  ELSE. " cogemos el rango inferior y superior y hacemos una media del factor (intentando replicar la progresividad)
    SELECT SINGLE * FROM zwm_espes_calibr
      INTO @DATA(low)
      WHERE gramaje EQ ( SELECT MAX( gramaje ) FROM zwm_espes_calibr WHERE gramaje LE @ls_mara-zzgramaje ).

    IF sy-subrc NE 0.
      RAISE missing_constants.
    ENDIF.

    SELECT SINGLE * FROM zwm_espes_calibr
    INTO @DATA(high)
          WHERE gramaje EQ ( SELECT MIN( gramaje ) FROM zwm_espes_calibr WHERE gramaje GE @ls_mara-zzgramaje ).

    IF sy-subrc NE 0.
      RAISE missing_constants.
    ENDIF.

    DATA: k_low  TYPE p DECIMALS 6,
          k_high TYPE p DECIMALS 6.

    k_low = ( low-espesor / low-gramaje ) * 1000.
    k_high = ( high-espesor / high-gramaje ) * 1000.

    lv_bstmg = ( k_low + k_high ) / 2.
  ENDIF.

  " formula taken from ZXMG0U02
  espesor = ( lv_bstmg * ls_mara-zzgramaje ).   " calculamos primero el espesor
  " fetch Mandril From constants
  TRY.
      lv_bstmg = CONV bstmg( lt_const[ name = 'ZDIAMANDRIL_' && iv_werks ]-low ).
    CATCH cx_root.
      RAISE missing_constants.
  ENDTRY.


  IF ls_mara-zzancho GT 0 AND ls_mara-zzgramaje GT 0.
    metros = iv_kg / ( ( ls_mara-zzancho / 1000 ) * ( ls_mara-zzgramaje / 1000 ) ).

    CHECK metros > 0.

    ev_dia = 2 * ( 100 * ( ( - ( 314159 / 100000 ) * ( espesor / 1000000 ) ) +
              sqrt( ( ( ( 314159 / 100000 ) ** 2 ) * ( ( espesor / 1000000 ) ** 2 ) - ( 4 * ( 314159 / 100000 ) * ( ( - lv_bstmg * ( 314159 / 100000 ) *
              ( espesor / 1000000 ) ) - ( ( lv_bstmg ** 2 ) * ( 314159 / 100000 ) ) - ( ( espesor / 1000000 ) * metros ) ) ) ) )  / ( 2 * 314159 / 100000 ) ) ).
  ENDIF.

ENDMETHOD.
METHOD call_ui5.
  DATA: lv_url TYPE string.

  lv_url = 'http://kiosrv020.hinojosagroup.es:8000/sap/bc/ui5_ui5/sap/zlistaprov/index.html?sap-client=001&werks=2001'.

  CALL FUNCTION 'CALL_BROWSER'
    EXPORTING
      url                    = lv_url
*     window_name            = SPACE
*     new_window             = SPACE
*     browser_type           =
*     contextstring          =
    EXCEPTIONS
      frontend_not_supported = 1
      frontend_error         = 2
      prog_not_found         = 3
      no_batch               = 4
      unspecified_error      = 5
      OTHERS                 = 6.
ENDMETHOD.
  METHOD centros_getdetail.
    "Datos de centro
    SELECT SINGLE werks, name1
      INTO CORRESPONDING FIELDS OF @wp_centro
      FROM t001w
      WHERE werks = @vp_werks.
    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'Centro incorrecto'(002) ).
    ENDIF.

    "Buscamos almacen WM
    SELECT SINGLE werks, lgort, lgnum
      INTO @DATA(wl_t320)
      FROM t320
      WHERE werks = @vp_werks AND
            lgort = '1000'.
    IF sy-subrc = 0.
      wp_centro-lgnum = wl_t320-lgnum.
      wp_centro-lgort = wl_t320-lgort.
      "Buscamos parametros
      DATA(vl_condition) = |LG{ wl_t320-lgnum } = 'X'|.
      SELECT *
        INTO TABLE @DATA(tl_func)
        FROM zwm_rf_func
        WHERE (vl_condition).
    ENDIF.

    "Indicamos datos de parametros leidos
    LOOP AT tl_func ASSIGNING FIELD-SYMBOL(<fs_func>).
      CASE <fs_func>-func.
        WHEN 'LISTA_APRO_UI5_MOSTRAR_PEDIDO'.
          wp_centro-mostrar_pedido = 'X'.
        WHEN 'LISTA_APRO_UI5_LEC_BOBINAS_PRO'.
          wp_centro-lectura_bobinas_propuestas = 'X'.
        WHEN 'LISTA_APRO_UI5_ALG_PROPUES_BER'.
          wp_centro-algoritmo_prop_bobinas_ber = 'X'.
        WHEN 'CONSUMOS_BOBINAS_METROS'.
          wp_centro-consumos_bobinas_metros = 'X'.
*        WHEN 'CONSUMOS_PUEDE_REGISTRAR_ALTAS'.
*          wp_centro-consumos_puede_registrar_altas = 'X'.
        WHEN 'CONSUMOS_PUEDE_REGULARIZAR_UA'.
          wp_centro-consumos_puede_regularizar_ua = 'X'.
        WHEN 'CONSUMOS_ERROR_NO_EXISTE_UA'.
          wp_centro-consumos_error_no_existe_ua = 'X'.
        WHEN 'CONSUMOS_CREAR_OT_DE_NT'.
          wp_centro-consumos_crear_ot_de_nt = 'X'.
        WHEN 'NO_PROPONER_SEGUNDAS_BLOQ_ZROJ'.
          wp_centro-restringir_propuesta = 'X'.
        WHEN 'LISTA_APRO_UI5_PP'.
          wp_centro-lista_apro_ui5_pp = 'X'.
      ENDCASE.
    ENDLOOP.

    "Transacción STVARV
    DATA vl_name TYPE tvarvc-name.
    vl_name = |ZWM_LISTA_APRO_REFRESH_MIN_{ wl_t320-lgnum }|.
    SELECT SINGLE low
      INTO @DATA(vl_low)
      FROM tvarvc
      WHERE name  = @vl_name.
    IF sy-subrc = 0.
      wp_centro-refresh_auto_mins = vl_low.
    ELSE.
      wp_centro-refresh_auto_mins = 30. "30 Minutos por defecto
    ENDIF.

    vl_name = |ZWM_LISTA_APRO_NUM_FILAS_{ wl_t320-lgnum }|.
    SELECT SINGLE low
      INTO @vl_low
      FROM tvarvc
      WHERE name  = @vl_name.
    IF sy-subrc = 0.
      wp_centro-lista_apro_num_filas = vl_low.
    ELSE.
      wp_centro-lista_apro_num_filas = 15. "Filas por defecto
    ENDIF.

    vl_name = |ZUI5_ENTCONS_DIAM_MAX_{ wl_t320-lgnum }|.
    SELECT SINGLE low
      INTO @vl_low
      FROM tvarvc
      WHERE name  = @vl_name.
    IF sy-subrc = 0.
      wp_centro-diametro_maximo = vl_low.
    ENDIF.


    SELECT SINGLE @abap_true
      INTO @wp_centro-regularizar_bobinas_diam
      FROM tvarvc
      WHERE name  = 'ZWM_REGULARIZAR_BOBINAS_DIAM' AND
            low   = @wl_t320-lgnum.

    vl_name = |ZWM_LISTA_APRO_MARGEN_SEL_{ wl_t320-lgnum }|.


    SELECT SINGLE low
      INTO @vl_low
      FROM tvarvc
      WHERE name  = @vl_name.
    IF sy-subrc = 0.
      wp_centro-lista_apro_margen_sel_ordenes = vl_low.
    ENDIF.

    vl_name = |ZWM_CONSUMOS_MARGEN_SEL_{ wl_t320-lgnum }|.
    SELECT SINGLE low
      INTO @vl_low
      FROM tvarvc
      WHERE name  = @vl_name.
    IF sy-subrc = 0.
      wp_centro-consumos_margen_sel_ordenes = vl_low.
    ENDIF.



    "Miramos los datos de intefase Nemesis
    SELECT *
      INTO TABLE @DATA(tl_ztwm001)
      FROM ztwm001
      WHERE cprog  =  'INTF_NEMESIS' AND
            param1 IN ('WERKS', 'REFRESH_INTERFASE').
    READ TABLE tl_ztwm001 ASSIGNING FIELD-SYMBOL(<fs_ztwm001>) WITH KEY param1 = 'WERKS'.
    IF sy-subrc = 0 AND <fs_ztwm001>-valor1 = vp_werks.
      READ TABLE tl_ztwm001 ASSIGNING <fs_ztwm001> WITH KEY param1 = 'REFRESH_INTERFASE'
                                                            param2 = 'URL'.
      IF sy-subrc = 0.
        wp_centro-url_interfase_1 = <fs_ztwm001>-valor1.
        wp_centro-url_interfase_2 = <fs_ztwm001>-valor2.
      ENDIF.
    ENDIF.


    "Miramos datos de la nueva tabla
    SELECT SINGLE cla_reg_ua_ultima_ot
      INTO wp_centro-cla_reg_ua_ultima_ot
      FROM zwm_param_alm
      WHERE lgnum = wp_centro-lgnum.


  ENDMETHOD.
METHOD change_nt.
  DATA lt_ltbc TYPE TABLE OF ltbc.
  lt_ltbc = it_ltbc.
  ev_subrc = 4.
  CHECK lines( lt_ltbc ) > 0.
  CALL FUNCTION 'L_TR_CHANGE'
*      EXPORTING
*        i_save_only_all          = 'X'    " Save only if all items without errors
*        i_update_task            =     " Update in the update task
*        i_commit_work            = 'X'    " Use "Commit Work"
    TABLES
      t_ltbc                   = lt_ltbc     " Table with TR items to be changed
    EXCEPTIONS
      item_error               = 1
      no_update_item_error     = 2
      no_update_no_entry       = 3
      no_update_without_commit = 4
      tr_locked                = 5
      OTHERS                   = 6.
  ev_subrc = sy-subrc.
ENDMETHOD.
METHOD change_reserv.

  CLEAR rt_ret.
  DATA lt_ret TYPE bapiret2_tab.
  DATA(lt_itm_chg) = it_itm_chg.
  DATA(lt_itm_chgx) = it_itm_chgx.
  DATA(lt_itm_new) = it_itm_new.
  DO 2 TIMES.
    IF sy-index = 1.
      " 1st change
      CHECK lines( it_itm_chg ) > 0.
      CLEAR lt_itm_new.
    ELSE.
      " 2nd add
      CHECK lines( it_itm_new ) > 0.
      CLEAR: lt_itm_chg, lt_itm_chgx.
      lt_itm_new = it_itm_new.
    ENDIF.
    CLEAR lt_ret.
    CALL FUNCTION 'BAPI_RESERVATION_CHANGE'
      EXPORTING
        reservation               = iv_reserv
*       testrun                   =
*       atpcheck                  =
      TABLES
        reservationitems_changed  = lt_itm_chg
        reservationitems_changedx = lt_itm_chgx
        reservationitems_new      = lt_itm_new
        return                    = lt_ret
*       extensionin               =
      .

    APPEND LINES OF lt_ret TO rt_ret.
    CHECK iv_commit = abap_true.
    LOOP AT lt_ret TRANSPORTING NO FIELDS WHERE type CA 'XAE'.
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
*          IMPORTING
*            return =     " Return Messages
        .

    ENDLOOP.
    IF sy-subrc NE 0.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = abap_true   " Using the command `COMMIT AND WAIT`
*        IMPORTING
*         return =     " Return Messages
        .
      WAIT UP TO 1 SECONDS.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
ENDMETHOD.
METHOD change_reserv_4_cons.
  DATA lt_resb TYPE TABLE OF resb.
  IF iv_rsnum IS INITIAL.
    DATA(ls_resb) = get_resb_for_nt( is_ltbk = is_ltbk iv_no_cns = abap_true ).
    APPEND ls_resb TO lt_resb.
    SELECT SINGLE * FROM lqua INTO @DATA(ls_lqua)
    WHERE lgnum = @is_ltbk-lgnum AND lenum = @iv_bobine
      AND verme > 0.
    CHECK: sy-subrc = 0, ls_resb-erfme = iv_meins.
  ELSE.
    SELECT * FROM resb INTO CORRESPONDING FIELDS OF TABLE @lt_resb
    WHERE rsnum = @iv_rsnum
    AND kzear = @abap_false.
  ENDIF.

  " 1 - original rspos must be set with original qty - consumed qty
  " 1.1 - if original qty - consumed qty < 0 , then must be original qty + 1
*    DATA(lv_open_qty) = ls_resb-erfmg - ls_resb-enmng.
*    DATA(lv_remain_qty) = lv_open_qty - iv_qty.




  IF iv_qty > 0 AND lines( lt_resb ) > 0.
    ls_resb = lt_resb[ 1 ].
    DATA(lt_itm_new) = VALUE gtty_res_itm_new(
    (
          material = ls_lqua-matnr
          plant = ls_lqua-werks
          stge_loc = ls_resb-lgort
          entry_qnt = iv_qty
          entry_uom = iv_meins
          movement = abap_true
          item_text = ls_resb-sgtxt
    )

    ).
  ENDIF.
  DATA(lt_itm_chg) = VALUE gtty_res_itm_chg( ).
  DATA(lt_itm_chgx) = VALUE gtty_res_itm_chgx( ).

  LOOP AT lt_resb INTO ls_resb.
    DATA(lv_chg_item_qty) = ls_resb-erfmg - iv_qty.
    IF lv_chg_item_qty <= 1.  "JCB: Si la reserva es menor de 1, no menor de 0, es cuando dejamos 1
      lv_chg_item_qty = 1.
    ENDIF.

    APPEND VALUE bapi2093_res_item_change(
   entry_qnt = lv_chg_item_qty
   res_item = ls_resb-rspos
   withdrawn = iv_close
   )  TO lt_itm_chg.

    APPEND VALUE bapi2093_res_item_changex( res_item = ls_resb-rspos entry_qnt = abap_true withdrawn = abap_true )
    TO lt_itm_chgx.
  ENDLOOP.

  et_ret =  zcl_wm_nt_generic=>change_reserv(
     EXPORTING
       iv_reserv   = ls_resb-rsnum
       it_itm_chg  = lt_itm_chg
       it_itm_chgx = lt_itm_chgx
       it_itm_new  = lt_itm_new
      iv_commit   = abap_true
   ).



*    CHECK: sy-subrc = 0, ls_lqua-matnr NE ls_resb-matnr,
*    ls_resb-erfme = iv_meins.
*
*    " change original item's quantity
*    ls_resb-erfmg = ls_resb-erfmg - iv_qty.
*    IF ls_resb-erfmg <= 0.
*      ls_resb-erfmg = 1.
*    ENDIF.
*
*    DATA(lt_itm_chg) = VALUE gtty_res_itm_chg( (
*    entry_qnt = ls_resb-erfmg
*    res_item = ls_resb-rspos
*    withdrawn = abap_true
*    ) ).
*
*    DATA(lt_itm_chgx) = VALUE gtty_res_itm_chgx(
*    ( res_item = ls_resb-rspos entry_qnt = abap_true withdrawn = abap_true
*    )
*    ).
*    DATA(lt_itm_new) = VALUE gtty_res_itm_new(
*    (
*          material = ls_lqua-matnr
*          plant = ls_lqua-werks
*          stge_loc = ls_resb-lgort
*          entry_qnt = iv_qty
*          entry_uom = iv_meins
*          movement = abap_true
*          item_text = ls_resb-sgtxt
*    )
*
*    ).
*
*    " create new item for given matnr with consumption qty
*
*    et_ret =  zcl_wm_nt_generic=>change_reserv(
*       EXPORTING
*         iv_reserv   = ls_resb-rsnum
*         it_itm_chg  = lt_itm_chg
*         it_itm_chgx = lt_itm_chgx
*         it_itm_new  = lt_itm_new
*        iv_commit   = abap_true
*     ).
*



ENDMETHOD.
METHOD close_rsnum.
  CLEAR rs_ret.

  DATA tl_rsnum     LIKE TABLE OF iv_rsnum.
  DATA tl_rsnum_rg  LIKE RANGE OF iv_rsnum.
  DATA lt_ltbc_all TYPE STANDARD TABLE OF ltbc.
*  DATA tl_rsnum_a_mantener_rg  LIKE RANGE OF iv_rsnum.

  IF iv_last = abap_false.
    COLLECT iv_rsnum INTO tl_rsnum.
*    DATA(lv_rsnum) = iv_rsnum.
  ELSE.

    CHECK iv_rsnum IS NOT INITIAL. " cvivo - a partir de ahora hace falta porque vamos a cerrar en orden

    DATA(lv_cnt) = 0.
    DATA(lv_old_rsnum) = VALUE resb-rsnum( ).

    DATA(tl_lista_pedidos) = zcl_wm_nt_generic=>get_instance( )->build_bobecm_list_ui5_v2( iv_lgnum = iv_lgnum
                                                                                           iv_nlpla = CONV #( iv_nlpla ) ).

    READ TABLE tl_lista_pedidos WITH KEY id = iv_rsnum TRANSPORTING NO FIELDS.
    DATA(posicion) = sy-tabix.

    LOOP AT tl_lista_pedidos ASSIGNING FIELD-SYMBOL(<fs_lista_pedidos>) WHERE id IS NOT INITIAL.
      IF sy-tabix GE posicion - 1. " no tocamos ni la actual ni la anterior a ésta
        EXIT.
      ENDIF.
      APPEND INITIAL LINE TO tl_rsnum_rg ASSIGNING FIELD-SYMBOL(<fs_rsnum_rg>).
      <fs_rsnum_rg>-sign = 'I'. <fs_rsnum_rg>-option = 'EQ'.  <fs_rsnum_rg>-low = <fs_lista_pedidos>-id.
    ENDLOOP.

    IF tl_rsnum_rg IS NOT INITIAL.
      SELECT rsnum, fecha, hora
        INTO TABLE @DATA(tl_zwm_intf_bhs)
        FROM zwm_intf_bhs
        WHERE porta_bobinas = @iv_nlpla AND
              lgnum         = @iv_lgnum AND
              rsnum         IN @tl_rsnum_rg
        ORDER BY fecha DESCENDING, hora DESCENDING.
    ENDIF.


    LOOP AT tl_zwm_intf_bhs ASSIGNING FIELD-SYMBOL(<fs_zwm_intf_bhs>).
      COLLECT <fs_zwm_intf_bhs>-rsnum INTO tl_rsnum.
    ENDLOOP.

*    "JCB: El último consumo no lo tenemos que borrar " DEL - CVIVO - con la selección que he puesto ahora, no hace falta quitar aquí
*    DELETE tl_rsnum INDEX 1.


*    SELECT rsnum
*      FROM zwm_intf_bhs
*      INTO lv_rsnum
*      WHERE porta_bobinas = iv_nlpla
*        AND lgnum = iv_lgnum
*      ORDER BY  fecha DESCENDING
*                hora DESCENDING.
*
*      IF lv_old_rsnum NE lv_rsnum.
*        lv_cnt = lv_cnt + 1.
*      ENDIF.
*      lv_old_rsnum = lv_rsnum.
*      CHECK lv_cnt = 2.
*      EXIT.
*    ENDSELECT.
  ENDIF.

  IF tl_rsnum IS INITIAL.
    rs_ret = VALUE #( type = 'I' message = 'Sin reserva para cerrar' ).
    RETURN.
  ENDIF.


  LOOP AT tl_rsnum ASSIGNING FIELD-SYMBOL(<fs_rsnum>).

    " 1 - close nt's
    DATA(lt_ltbk) = get_nt_for_resb( is_resb = VALUE #( rsnum = <fs_rsnum> ) ).
    DELETE lt_ltbk WHERE statu = 'E'. "JCB 21.01.21. Ignorar NTs ya cerradas

    " fetch all open items
    IF lines( lt_ltbk ) > 0.
      SELECT * FROM ltbp
        INTO TABLE @DATA(lt_ltbp)
        FOR ALL ENTRIES IN @lt_ltbk
        WHERE lgnum = @lt_ltbk-lgnum AND
              tbnum = @lt_ltbk-tbnum.

      LOOP AT lt_ltbk INTO DATA(ls_ltbk).
        DATA(lt_ltbp_aux) = lt_ltbp.
        DELETE lt_ltbp_aux
          WHERE tbnum NE ls_ltbk-tbnum OR
                lgnum NE ls_ltbk-lgnum.

        DATA(lt_ltbc) = VALUE zcl_wm_nt_generic=>gtty_ltbc(
          FOR ls_ltbp IN lt_ltbp_aux ( lgnum = ls_ltbp-lgnum
                                       tbnum = ls_ltbp-tbnum
                                       tbpos = ls_ltbp-tbpos
                                       menga = ls_ltbp-menga
                                       altme = ls_ltbp-altme
                                       elikz = abap_true
        ) ).


        APPEND LINES OF lt_ltbc TO lt_ltbc_all. " cvivo, para el log-point

        " requires the consumed value and not the expected value :s
        zcl_wm_nt_generic=>change_nt(
          EXPORTING
            it_ltbc  = lt_ltbc
          IMPORTING
            ev_subrc = DATA(ev_subrc)
        ).

        IF ev_subrc NE 0.
          rs_ret = VALUE #( type = 'E' message = 'Error cerrando la NT' ).
*          RETURN. " cvivo - lo desactivo para no interferir en el log-point
        ENDIF.
      ENDLOOP.
    ENDIF.

    " now close all open reservation items
    change_reserv_4_cons(
      EXPORTING
        iv_rsnum = <fs_rsnum>
        iv_close = abap_true
      IMPORTING
        et_ret    = DATA(lt_ret)
    ).
    LOOP AT lt_ret INTO rs_ret WHERE type CA 'XAE'.
      EXIT.
    ENDLOOP.
  ENDLOOP.

  " cvivo - Punto de verificación: identificar NTs cerradas incorrectamente
  DATA(key) = |Cierre tras consumo: { sy-datum } / { sy-uzeit } / { sy-uname }|.
  LOG-POINT ID zwm_ui5 SUBKEY key FIELDS tl_lista_pedidos iv_rsnum lt_ltbc_all tl_rsnum.


ENDMETHOD.
METHOD code_line_id.
  IF iv_tbnum_mode = abap_true.
    rv_id = is_data-lgnum && zcl_wm_constants=>gc_aprov_list_id_sep && is_data-tbnum.
    RETURN.
  ELSEIF iv_rsnum_mode = abap_true.
    rv_id = is_data-rsnum.
    RETURN.
  ELSE.
    rv_id = is_data-lgnum && zcl_wm_constants=>gc_aprov_list_id_sep && is_data-benum.
  ENDIF.
ENDMETHOD.
METHOD constructor.
  me->set_langu( iv_langu = iv_langu ).
ENDMETHOD.
METHOD conv_mat_diametro.
  " Kyvor - 20190926 - RDM - calc diametro
  " only Kg or DIA are allowed as input Units of measure

  CLEAR rv_qty.

  CHECK iv_qty IS NOT INITIAL.

  IF ( iv_meins NE gc_meins_dia AND iv_meins NE gc_meins_kg AND iv_meins NE gc_meins_m )
    OR ( iv_dest_meins NE gc_meins_dia AND iv_dest_meins NE gc_meins_kg AND iv_dest_meins NE gc_meins_m ).
    RAISE um_no_valid.
  ENDIF.

  IF iv_meins = iv_dest_meins.
    rv_qty = iv_qty.
    RETURN.
  ENDIF.


  IF iv_dest_meins = gc_meins_dia.
    DATA(l_qty) = iv_qty.

    IF iv_meins EQ gc_meins_m. " cvivo - si el origen es metros, pasamos a kg
      CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
        EXPORTING
          i_matnr              = iv_matnr
          i_in_me              = iv_meins
          i_out_me             = gc_meins_kg
          i_menge              = iv_qty
        IMPORTING
          e_menge              = l_qty
        EXCEPTIONS
          error_in_application = 1
          error                = 2
          OTHERS               = 3.
    ENDIF.

    calc_diam_con_kg(
                      EXPORTING
                        iv_matnr          = iv_matnr    " Número de material
                        iv_werks          = iv_werks    " Centro
                        iv_kg             = l_qty   " Cantidad en kilogramos
                      IMPORTING
                        ev_dia            =  rv_qty   " Cantidad en diámetro (cm)
                      EXCEPTIONS
                        um_no_valid       = 1
                        missing_constants = 2
                        missing_matnr     = 3
                        OTHERS            = 4
                    ).
    RETURN.
  ENDIF.


  zcl_wm_nt_generic=>calc_base_diametro(
    EXPORTING
      iv_matnr          = iv_matnr
      iv_werks          = iv_werks
      iv_diam = COND #( WHEN iv_meins = gc_meins_dia THEN iv_qty ELSE VALUE #( ) )
    IMPORTING
      ev_kg             = DATA(lv_kg)
      ev_dia            = DATA(lv_dia)
      ev_m              = DATA(lv_m)
    EXCEPTIONS
      um_no_valid       = 1
      missing_constants = 2
      missing_matnr     = 3
      overflow          = 4
      OTHERS            = 5
  ).

  CASE sy-subrc.
    WHEN 1.
      RAISE um_no_valid.
    WHEN 2.
      RAISE missing_constants.
    WHEN 3.
      RAISE missing_matnr.
    WHEN 4.
      RAISE overflow.
    WHEN 5.
      RETURN.
  ENDCASE.

*  IF lv_kg = 0 OR lv_dia = 0.
*    RAISE no_base_calc.
*  ENDIF.

  IF iv_dest_meins = gc_meins_kg .
    rv_qty = lv_kg.
  ELSEIF iv_dest_meins = gc_meins_m.
    rv_qty = lv_m.
  ENDIF.



ENDMETHOD.
METHOD conv_matnr.
  IF iv_qty = 0.
    rv_qty = 0.
    RETURN.
  ENDIF.
  IF iv_meins_orig = iv_meins_dest.
    rv_qty = iv_qty.
    RETURN.
  ENDIF.
  CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
    EXPORTING
      i_matnr              = iv_matnr
      i_in_me              = iv_meins_orig
      i_out_me             = iv_meins_dest
      i_menge              = iv_qty
    IMPORTING
      e_menge              = rv_qty
    EXCEPTIONS
      error_in_application = 1
      error                = 2
      OTHERS               = 3.
ENDMETHOD.
  METHOD convert_benum_omp_external.
    "Formato interno: yyaaaabbc
    "Formato externo: aaaabbc
    "donde:
    " - yy son los dos últimos dígitos del año
    " - aaaa: Primer valor código.
    " - bb: Segundo valor del código. Tiene espacios
    " - c: Tercer valor del código

    vp_input = |{ vp_input ALPHA = OUT }|.


    vp_gjahr = '20' && vp_input(2).
    DATA: vl_aaaa TYPE c LENGTH 4,
          vl_bb   TYPE c LENGTH 2,
          vl_c    TYPE c LENGTH 1.
    vl_aaaa = vp_input+2(4).
    vl_bb   = |{ vp_input+6(2)  ALPHA = OUT }|.
    vl_c    = vp_input+8(1).

    WRITE vl_bb TO vl_bb RIGHT-JUSTIFIED.
    CONCATENATE vl_aaaa vl_bb vl_c INTO vp_output SEPARATED BY space RESPECTING BLANKS.

  ENDMETHOD.
  METHOD convert_benum_omp_internal.

    "Formato externo: aaaabbc
    "Formato interno: yyaaaabbc
    "donde:
    " - yy son los dos últimos dígitos del año
    " - aaaa: Primer valor código.
    " - bb: Segundo valor del código. Tiene espacios
    " - c: Tercer valor del código
    DATA: vl_aaaa TYPE c LENGTH 4,
          vl_bb   TYPE c LENGTH 2,
          vl_c    TYPE c LENGTH 1.
    DATA tl_split TYPE TABLE OF char4.
    DATA vl_contador TYPE i VALUE 1.


    vp_output = vp_input.
    SPLIT vp_output AT space INTO TABLE tl_split.

    "Si no tiene espacios en blanco, entendemos que ya tiene el formato moderno, y por lo tanto no hay que convertir
    IF lines( tl_split ) = 1. RETURN. ENDIF.

    LOOP AT tl_split ASSIGNING FIELD-SYMBOL(<fs_split>) WHERE table_line IS NOT INITIAL.
      CASE vl_contador.
        WHEN 1.
          vl_aaaa = |{ <fs_split> ALPHA = IN }|.
        WHEN 2.
          vl_bb   = |{ <fs_split> ALPHA = IN }|.
        WHEN 3.
          vl_c = <fs_split>.
      ENDCASE.
      ADD 1 TO vl_contador.
    ENDLOOP.

    CONCATENATE vp_gjahr+2(2) vl_aaaa vl_bb vl_c INTO vp_output RESPECTING BLANKS.

    vp_output = |{ vp_output ALPHA = IN }|.
  ENDMETHOD.
METHOD create_itf_entry.
  DATA: ls_entry TYPE zwm_intf_bhs.
  CLEAR rs_entry.
  GET TIME.

  IF is_ltbk-bwlvs NE '919'. " cvivo - no debería pasar, pero por si acaso, estamos teniendo incidencias
    " cvivo - Punto de verificación: identificar NTs seleccionadas incorrectamente
    DATA(key) = |Cl.mov. NT incorrecta: { sy-datum } / { sy-uzeit } / { sy-uname }|.
    LOG-POINT ID zwm_ui5 SUBKEY key FIELDS is_ltbk iv_bobine iv_calidad iv_restante iv_diametro.
  ENDIF.

  SELECT MAX( id ) FROM zwm_intf_bhs INTO ls_entry-id.
  IF sy-subrc <> 0.
    ls_entry-id = '0000000001'.
  ELSE.
    ls_entry-id = ls_entry-id + 1.

    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = ls_entry-id
      IMPORTING
        output = ls_entry-id.
  ENDIF.

  DATA(ls_resb) = get_resb_for_nt( is_ltbk = is_ltbk
                                   iv_only_open = abap_false ). " cvivo - LTBK-RSNUM apunta la reserva, si está cerrada es un error,
  " pero no debe afectar al resto del proceso

  IF ls_resb IS INITIAL.
    " cvivo - Punto de verificación: identificar NTs cerradas incorrectamente
    key = |Selección reserva fallida: { sy-datum } / { sy-uzeit } / { sy-uname }|.
    LOG-POINT ID zwm_ui5 SUBKEY key FIELDS is_ltbk.
  ENDIF.
  ls_entry-rsnum = ls_resb-rsnum.
  ls_entry-rspos = ls_resb-rspos.
  ls_entry-rsart = ls_resb-rsart.
  ls_entry-metros_restantes = iv_restante. " cvivo - debe estar relleno tanto en el modelo DIA como M.rest
  ls_entry-diametro_rest = iv_diametro.

*  "Si aprovisionamiento en metros (o palets), quitamos el diámetro " cvivo - DEL - lo hago compatible desde antes
*  "JCB: Si es un centro con cantidad en kgs o uds no se convierte
*  TRY .
*      DATA(wl_centro) = zcl_wm_nt_generic=>get_instance( )->centros_getdetail( iv_werks ).
*    CATCH /iwbep/cx_mgw_busi_exception.
*      CLEAR wl_centro.
*  ENDTRY.
*  IF wl_centro-lista_bobinas_metros = abap_true.
*    ls_entry-metros_restantes = iv_restante.
*  ELSE.
*    ls_entry-diametro_rest = iv_restante.
*  ENDIF.

  ls_entry-fecha = sy-datum.
  ls_entry-hora = sy-uzeit.
  ls_entry-pos_fich = 1.
  ls_entry-lgnum = iv_lgnum.
  ls_entry-werks = iv_werks.
  ls_entry-cod_consumo = '00'."/02
  ls_entry-porta_bobinas = is_ltbk-nlpla.
  ls_entry-cod_etiqueta = iv_bobine.

*  SELECT SINGLE * FROM lqua -------> DEL - cvivo - Comento todo esto porque en metros_restantes ya viene la cantidad bien convertida, sea M o UN o conv.desde DIA
*  INTO @DATA(ls_lqua) WHERE lgnum = @is_ltbk-lgnum
*  AND lenum = @iv_bobine.
*  IF ls_lqua-verme IS INITIAL.
*    SELECT SINGLE * FROM lqua INTO @ls_lqua
*    WHERE lgnum = @is_ltbk-lgnum
*      AND lenum = @iv_bobine   AND gesme > 0.
*    ls_lqua-verme = ls_lqua-gesme.
*  ENDIF.
*
*
*  IF ls_lqua-letyp EQ 'BB'.
*    DATA(lv_bob_qty) = conv_matnr(
*       EXPORTING
*         iv_matnr      = ls_lqua-matnr
*         iv_meins_orig = ls_lqua-meins
*         iv_meins_dest = 'M'
*         iv_qty        = ls_lqua-verme
*     ).
*  ELSEIF ls_lqua-letyp EQ 'PL'.
*    lv_bob_qty = conv_matnr(
*    EXPORTING
*      iv_matnr      = ls_lqua-matnr
*      iv_meins_orig = ls_lqua-meins
*      iv_meins_dest = 'ST'
*      iv_qty        = ls_lqua-verme
*      ).
*  ENDIF.
*
*  IF iv_last = abap_true AND iv_restante = 0.
*    DATA(lv_qty) = lv_bob_qty.
*  ELSE.
*
*    lv_qty = conv_matnr(
*       EXPORTING
*         iv_matnr      = ls_lqua-matnr"ls_resb-matnr
*         iv_meins_orig = iv_meins
*         iv_meins_dest = 'M'
*         iv_qty        = iv_cons_qty
*     ).
*
*  ENDIF.
*  DATA(lv_rest) = lv_bob_qty - lv_qty.
*  IF lv_rest < 0 .
*    ls_entry-metros_restantes = 0.
*  ELSE.
*    ls_entry-metros_restantes = lv_rest.
*  ENDIF.

  ls_entry-metros_desarrollados = iv_cons_qty.

  ls_entry-orden_bhs    = is_ltbk-benum.
  ls_entry-calidad      = iv_calidad.
  ls_entry-cod_operario = iv_operario.
  "ls_entry-cod_maquina_principal -> vazio

  "Máquina principal: Ubicación sin el ultimo carácter (estación)
  DATA(vl_len) = strlen( is_ltbk-nlpla ) - 1.
  ls_entry-cod_maquina_principal = is_ltbk-nlpla(vl_len).


  MODIFY zwm_intf_bhs FROM ls_entry.
  rs_entry = ls_entry.
  CHECK iv_commit = abap_true.
  COMMIT WORK AND WAIT.

ENDMETHOD.
METHOD create_ot_4_nt.
  DATA: lt_trite TYPE l03b_trite_t,
        ls_trite LIKE LINE OF lt_trite.
  CLEAR: ev_subrc, es_ltak.
  IF iv_bwlvs <> '919'.
    ev_subrc = 4.
    RETURN.
  ENDIF.
  SELECT SINGLE lgtyp FROM lagp
  INTO @DATA(lv_lgtyp)
  WHERE lgpla = @iv_dest_nlpla
  AND lgnum = @is_ltbk-lgnum.

  SELECT SINGLE * FROM lqua INTO
  @DATA(ls_lqua) WHERE lgnum = @is_ltbk-lgnum
  AND lenum = @iv_bobine.

  SELECT * FROM ltbp
  INTO TABLE @DATA(lt_ltbp)
  WHERE lgnum = @is_ltbk-lgnum
  AND tbnum = @is_ltbk-tbnum.

  LOOP AT lt_ltbp INTO DATA(ls_ltbp).

    ls_trite-tbpos = ls_ltbp-tbpos.
    ls_trite-altme = iv_meins.
    IF iv_qty > ls_ltbp-menge.
      ls_trite-anfme = ls_ltbp-menge.
    ELSE.
      ls_trite-anfme = iv_qty.
    ENDIF.
    ls_trite-charg = ls_lqua-charg.
    ls_trite-nltyp = ls_lqua-lgtyp.
    ls_trite-nlpla = ls_lqua-lgpla.
    ls_trite-nlenr = iv_bobine.
    ls_trite-vlpla = ls_lqua-lgpla.
    ls_trite-vltyp = ls_lqua-lgtyp.
    ls_trite-letyp = ls_lqua-letyp.
    ls_trite-vlenr = iv_bobine.
    APPEND ls_trite TO lt_trite.
  ENDLOOP.

  CALL FUNCTION 'L_TO_CREATE_TR'
    EXPORTING
      i_lgnum                        = is_ltbk-lgnum
      i_tbnum                        = is_ltbk-tbnum
*     i_bname                        = gst_zwm005-bname
      i_squit                        = abap_true
      i_tbeli                        = abap_true
      it_trite                       = lt_trite
    IMPORTING
      e_tanum                        = es_ltak-tanum
    EXCEPTIONS
      foreign_lock                   = 1
      qm_relevant                    = 2
      tr_completed                   = 3
      xfeld_wrong                    = 4
      ldest_wrong                    = 5
      drukz_wrong                    = 6
      tr_wrong                       = 7
      squit_forbidden                = 8
      no_to_created                  = 9
      update_without_commit          = 10
      no_authority                   = 11
      preallocated_stock             = 12
      partial_transfer_req_forbidden = 13
      input_error                    = 14
      error_message                  = 16
      OTHERS                         = 15.

  ev_subrc = sy-subrc.
  IF es_ltak-tanum IS NOT INITIAL.
    es_ltak-lgnum = is_ltbk-lgnum.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
  ENDIF.


ENDMETHOD.
METHOD create_ot_4_nt_sc.

*    IF iv_bwlvs EQ '919'.
*      ev_subrc = 4.
*      RETURN.
*    ENDIF.

  SELECT SINGLE lgtyp FROM lagp
    INTO @DATA(lv_lgtyp)
    WHERE lgpla = @iv_dest_nlpla
      AND lgnum = @is_ltbk-lgnum.

  SELECT SINGLE * FROM lqua
    INTO @DATA(ls_lqua)
    WHERE lgnum = @is_ltbk-lgnum
      AND lenum = @iv_bobine
      AND verme > 0.

  " must fetch rsnum/rspos/rsart data
  DATA(ls_resb) = get_resb_for_nt( is_ltbk = is_ltbk ).
  CHECK sy-subrc = 0.
  " set data for enh ZWM_OMP_RSNUM_FIELDS to pick
  zcl_wm_nt_generic=>set_rsnum( ls_resb-rsnum ).
  zcl_wm_nt_generic=>set_rspos( CORRESPONDING #( ls_resb ) ).



  DATA(wl_centro) = zcl_wm_nt_generic=>get_instance( )->centros_getdetail( ls_lqua-werks ).



  IF wl_centro-consumos_crear_ot_de_nt = 'X'.
    "Miramos dónde está la bobina y si el origen y destino no coinciden movemos a destino
    IF ls_lqua-lgpla <> iv_dest_nlpla.
*    TRY.
      zcl_wm_nt_generic=>movebobine(
        EXPORTING
          iv_bobine           = iv_bobine
          iv_dest_nlpla       = iv_dest_nlpla
          iv_lgnum            = is_ltbk-lgnum
          iv_bwlvs            = zcl_wm_nt_generic=>gc_move_type_918
          iv_tipo_mov_bobina  = zcl_wm_nt_generic=>gc_tipo_mov_bobina_orden_trans
          iv_validar_fsc_recycled = space "Validación FSC Recycled sólo para el carretillero
        IMPORTING
          es_ltak       = DATA(ls_ltak)
          ev_subrc      = DATA(lv_subrc)
      ).
*      CATCH /iwbep/cx_mgw_busi_exception.
*
*    ENDTRY.
    ENDIF.

    CALL FUNCTION 'L_TO_CREATE_SINGLE'
      EXPORTING
        i_lgnum               = is_ltbk-lgnum   " Número de almacén
        i_bwlvs               = iv_bwlvs   " Clase movimiento
        i_betyp               = 'O'    " Tipo de necesidades
        i_benum               = is_ltbk-benum    " Número de necesidades
        i_matnr               = ls_lqua-matnr    " Número de material
        i_werks               = ls_lqua-werks    " Centro
*       i_lgort               = SPACE
*       i_charg               = SPACE    " Lote
        i_bestq               = ls_lqua-bestq    " Diferenciación de stock
*       i_sobkz               = SPACE    " Indicador de stock especial
*       i_sonum               = SPACE    " Número de stock especial
        i_letyp               = ls_lqua-letyp    " Tipo de unidad de almacén
        i_anfme               = iv_qty    " Ctd. solicitada
        i_altme               = iv_meins    " Unidad de medida
*       i_wdatu               = INIT_DATUM    " Fecha de entrada mcías.
*       i_vfdat               = INIT_DATUM
*       i_zeugn               = SPACE    " Número de certificado
        i_lznum               = is_ltbk-lznum    " Número adicional de ref.
        i_squit               = abap_true    " Confirm. inmed.
*       i_nidru               = SPACE    " No imprimir
*       i_drukz               = SPACE    " Ind. de impresión
*       i_ldest               = SPACE    " Impresora
*       i_wempf               = SPACE    " Receptor mercancías
*       i_ablad               = SPACE    " Lugar de descarga
*       i_vltyp               = ls_lqua-lgtyp    " Tipo de almacén 'desde'       """JCB: Al pasarle la UA no hará falta pasar ubicación origen
        "i_vlber               = ls_lqua-l    " Area de almacenamiento 'desde'
*       i_vlpla               = ls_lqua-lgpla    " Ubic. 'desde'                 """JCB: Al pasarle la UA no hará falta pasar ubicación origen
*       i_vppos               = SPACE    " Posición en la ubicación 'desde'
        i_vlenr               = iv_bobine    " Uni-alm procedencia
*       i_vlqnr               = SPACE    " Cuanto 'desde'
***      i_nltyp               = ls_lqua-lgtyp    " Tipo de almacén 'hacia'
        i_nltyp               = lv_lgtyp    " Tipo de almacén 'hacia'    JCB: Cambiado por ubicacion destino
*       i_nlber               = SPACE    " Area de almacenamiento 'hacia'
***      i_nlpla               = ls_lqua-lgpla    " Ubic. 'hacia'
        i_nlpla               = iv_dest_nlpla   " Ubic. 'hacia'    JCB: Cambiado por ubicacion destino
*       i_nppos               = SPACE    " Posición en la ubicación 'hacia'
        i_nlenr               = iv_bobine    " Uni.almacén destino
*       i_nlqnr               = SPACE    " Cuanto 'hacia'
*       i_rltyp               = SPACE    " Tipo de almacén de retorno
*       i_rlber               = SPACE    " Area de almacenamiento de retorno
*       i_rlpla               = SPACE    " Ubicación de retorno
*       i_rlqnr               = SPACE    " Cuanto retorno
*       i_update_task         = SPACE
*       i_commit_work         = 'X'
*       i_bname               = SY-UNAME    " Usuario que crea la OT
        i_kompl               = space    " Crear OT aun si no se cubre la cantidad total -> cvivo - Es necesario desmarcarlo porque si se lanza para UMA, si la conversión
        " no cuadra 100%, falla. Es decir, si se pide la OT para 10,012 metros, esa ctd en KG es p.e. 4,5645; como no hay 4 decimales en SAP,
        " hace la OT para la cantidad que sí cuadra, es decir 10,011m p.e.; si no está este parámetro desactivado, no deja descuadrar cantidades
*       i_solex               = 0
*       i_pernr               = 0
*       i_ausfb               = SPACE
*       i_sgt_scat            = SPACE
      IMPORTING
        e_tanum               = es_ltak-tanum   " Número de orden de transporte
*       e_ltap                =     " Posición de orden de transporte
*      TABLES
*       t_ltak                =
*       t_ltap_vb             =
      EXCEPTIONS
        no_to_created         = 1
        bwlvs_wrong           = 2
        betyp_wrong           = 3
        benum_missing         = 4
        betyp_missing         = 5
        foreign_lock          = 6
        vltyp_wrong           = 7
        vlpla_wrong           = 8
        vltyp_missing         = 9
        nltyp_wrong           = 10
        nlpla_wrong           = 11
        nltyp_missing         = 12
        rltyp_wrong           = 13
        rlpla_wrong           = 14
        rltyp_missing         = 15
        squit_forbidden       = 16
        manual_to_forbidden   = 17
        letyp_wrong           = 18
        vlpla_missing         = 19
        nlpla_missing         = 20
        sobkz_wrong           = 21
        sobkz_missing         = 22
        sonum_missing         = 23
        bestq_wrong           = 24
        lgber_wrong           = 25
        xfeld_wrong           = 26
        date_wrong            = 27
        drukz_wrong           = 28
        ldest_wrong           = 29
        update_without_commit = 30
        no_authority          = 31
        material_not_found    = 32
        lenum_wrong           = 33
        error_message         = 34
        OTHERS                = 35.
    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( ).
    ENDIF.

    COMMIT WORK.
  ENDIF.

  es_ltak-lgnum = is_ltbk-lgnum.

  SELECT SINGLE menga, altme, matnr,tbpos
  FROM ltbp INTO @DATA(ls_ltbp)
  WHERE lgnum = @is_ltbk-lgnum
  AND tbnum = @is_ltbk-tbnum.
  CHECK sy-subrc = 0.

  " must now change nt

  DATA(lv_dest_qty) = conv_matnr(
    EXPORTING
      iv_matnr      = ls_ltbp-matnr
      iv_meins_orig = iv_meins
      iv_meins_dest = ls_ltbp-altme
      iv_qty        = iv_qty
 ).

  "JCB: Si la diferencia entre cantidad disponible y cantidad a consumir es menor de 1, dejamos al menos 1
  DATA(vl_diferencia) = ls_ltbp-menga - lv_dest_qty.
  IF vl_diferencia < 1.
    lv_dest_qty = ls_ltbp-menga - 1.
  ENDIF.

*  IF lv_dest_qty >= ls_ltbp-menga.
*    lv_dest_qty = ls_ltbp-menga - 1.
*  ENDIF.



  DATA(lt_ltbc) = VALUE zcl_wm_nt_generic=>gtty_ltbc(
  ( lgnum = is_ltbk-lgnum
    tbnum = is_ltbk-tbnum
    tbpos = ls_ltbp-tbpos
    menga = lv_dest_qty
    altme = ls_ltbp-altme
  )
  ).
  " requires the consumed value and not the expected value :s
  zcl_wm_nt_generic=>change_nt(
    EXPORTING
      it_ltbc  = lt_ltbc
    IMPORTING
      ev_subrc = ev_subrc
  ).

  " cvivo - Punto de verificación: identificar NTs cerradas incorrectamente
  DATA(key) = |Cambio ctd.tras OT: { sy-datum } / { sy-uzeit } / { sy-uname }|.
  LOG-POINT ID zwm_ui5 SUBKEY key FIELDS lt_ltbc ls_ltbp.

  " set nt status

  zcl_wm_nt_generic=>set_status_nt(
    EXPORTING
      is_ltbk   = is_ltbk
      iv_statu  = 'T'
*        iv_commit = ABAP_TRUE
  ).


ENDMETHOD.
METHOD create_reserv.
  DATA lt_profit TYPE TABLE OF bapi_profitability_segment.

  CLEAR: es_rsnum, et_ret.

  CALL FUNCTION 'BAPI_RESERVATION_CREATE1'
    EXPORTING
      reservationheader    = is_header    " BAPI Communication Structure: Reservation Header Fields
*     testrun              =     " Switch to Simulation Mode for Write BAPIs
*     atpcheck             =     " BAPI Communication Structure: Reservation ATP Check
*     calcheck             =     " BAPI Communication Structure: Reservation Factory Calendar
*     reservation_external =     " Number of Reservation/Dependent Requirement
    IMPORTING
      reservation          = es_rsnum     " BAPI Communication Structure: Delete Reservation
    TABLES
      reservationitems     = it_item    " BAPI Communication Structure: Reservation Item Fields
      profitabilitysegment = lt_profit     " BAPI Communication Structure: Reservation for Profitability
      return               = et_ret    " Return Messages
*     extensionin          =     " Customer Enhancements of Import Interface
    .

  CHECK iv_commit = abap_true.
  LOOP AT et_ret TRANSPORTING NO FIELDS WHERE type CA 'XAE'.
    EXIT.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
*          IMPORTING
*            return =     " Return Messages
      .
  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*          EXPORTING
*            wait   =     " Using the command `COMMIT AND WAIT`
*          IMPORTING
*            return =     " Return Messages
      .
  ENDIF.

ENDMETHOD.
METHOD create_to_4_diamet_ret.
  rv_succ = abap_false.

  CHECK is_data-update_diam = abap_true.

  " call to_create

  rv_succ = abap_true.

ENDMETHOD.
METHOD decode_line_id.
  CLEAR rs_data.
  IF iv_tbnum_mode = abap_true.
    SPLIT iv_id AT zcl_wm_constants=>gc_aprov_list_id_sep INTO rs_data-lgnum rs_data-tbnum.
    RETURN.
  ELSEIF iv_rsnum_mode = abap_true.
    rs_data-rsnum = iv_id.
    RETURN.
  ELSE.
    SPLIT iv_id AT zcl_wm_constants=>gc_aprov_list_id_sep INTO rs_data-lgnum rs_data-benum.
  ENDIF.

ENDMETHOD.
METHOD delete_reserv.

  "KYV/RDM - 20200710 - BEG

  " check existence of reservation
  SELECT SINGLE @abap_true
    INTO @DATA(lv_dumm)
    FROM resb
    WHERE rsnum = @iv_rsnum.
  IF sy-subrc NE 0.
    rt_ret = VALUE #( ( type = 'S' ) ).
    RETURN.
  ENDIF.

  "KYV/RDM - 20200710 - END


  CALL FUNCTION 'BAPI_RESERVATION_DELETE'
    EXPORTING
      reservation = iv_rsnum
*     testrun     =
    TABLES
      return      = rt_ret.

  CHECK iv_commit = abap_true.
  LOOP AT rt_ret TRANSPORTING NO FIELDS WHERE type CA 'XAE'.
    EXIT.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
*          IMPORTING
*            return =     " Return Messages
      .
  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*          EXPORTING
*            wait   =     " Using the command `COMMIT AND WAIT`
*          IMPORTING
*            return =     " Return Messages
      .
  ENDIF.

ENDMETHOD.
METHOD get_aprovis_list.
  DATA(lv_dumm_nlpla) = VALUE ltbk-nlpla( ).
  DATA lr_tbnum       TYPE RANGE OF ltbk-tbnum.
  DATA lr_nlpla       TYPE RANGE OF ltbk-nlpla.
  DATA lr_statu       TYPE RANGE OF ltbk-statu.
  DATA lr_open_statu  TYPE RANGE OF ltbk-statu.
  DATA lr_menga       TYPE RANGE OF ltbp-menga.
  DATA lr_elikz       TYPE RANGE OF ltbp-elikz.
  DATA lv_rsnum       TYPE ltbk-rsnum.
  CLEAR rt_data.

  IF iv_tbnum IS NOT INITIAL.
    lr_tbnum = VALUE #( ( sign = 'I' option = 'EQ' low = iv_tbnum ) ).
  ENDIF.


  IF iv_machine_id IS NOT INITIAL.
    APPEND INITIAL LINE TO lr_nlpla ASSIGNING FIELD-SYMBOL(<fs_nlpla_rg>).
    <fs_nlpla_rg>-sign   = 'I'.
    <fs_nlpla_rg>-option = 'CP'.
    <fs_nlpla_rg>-low    = |{ iv_machine_id }+|.
  ENDIF.


  IF iv_nlpla IS NOT INITIAL.
    APPEND INITIAL LINE TO lr_nlpla ASSIGNING <fs_nlpla_rg>.
    <fs_nlpla_rg>-sign   = 'I'.
    <fs_nlpla_rg>-option = 'EQ'.
    <fs_nlpla_rg>-low    = iv_nlpla.
  ENDIF.

  IF iv_all_stat = abap_false.
    lr_statu = VALUE #(
    ( sign = 'I' option = 'EQ' )
    ( sign = 'I' option = 'EQ' low = 'T' ) ).

    IF iv_nlpla IS INITIAL. " cvivo - Si se carga para onduladora, no se restringe, si se carga para carretilla, sí
      DATA(name) = |ZWM_LISTA_APRO_CTD_MIN_{ iv_lgnum }|.

      SELECT SINGLE low FROM tvarvc
        WHERE name EQ @name
        INTO @DATA(ctd_min).
    ENDIF.

    lr_menga = VALUE #( ( sign = 'I' option = 'GT' low = ctd_min ) ). " cvivo - Hacemos que no salgan residuos en tablet
    lr_elikz = VALUE #( ( sign = 'I' option = 'EQ' ) ).
  ENDIF.

  lr_open_statu = VALUE #(
  ( sign = 'I' option = 'EQ' )
  ( sign = 'I' option = 'EQ' low = 'T' )
   ).



  DATA: tl_rsnum_rg TYPE RANGE OF rsnum.
  IF iv_rsnum IS NOT INITIAL.
    APPEND INITIAL LINE TO tl_rsnum_rg ASSIGNING FIELD-SYMBOL(<fs_rsnum_rg>).
    <fs_rsnum_rg>-sign = 'I'. <fs_rsnum_rg>-option = 'EQ'. <fs_rsnum_rg>-low = iv_rsnum.
  ENDIF.


  " fetch max rows
  DATA(lv_max_rows) = COND #( WHEN iv_restrict_rows = abap_true THEN me->get_max_rows_omp( iv_lgnum = iv_lgnum ) ELSE 0 ).

  DATA lv_date TYPE sy-datum.
  lv_date = sy-datum - 90. "JCB 21.09.22. No saco necesidades anteriores a 90 días

  SELECT a~pdatu, a~pzeit, " a~tbktx, " cvivo - 65089
        a~lznum,  b~matnr,  c~maktx,
        ( b~menga - b~tamea ) AS full_menge,
        b~altme, a~nlpla, a~lgnum, a~tbnum, b~tbpos,
        d~zzancho, a~benum, d~zzgramaje, a~statu,
        b~menga AS init_menge , a~rsnum, b~werks,
        d~mtart
    FROM ltbk AS a  INNER JOIN ltbp AS b ON a~lgnum = b~lgnum AND
                                            a~tbnum = b~tbnum
                    INNER JOIN mara AS d ON d~matnr = b~matnr
                    LEFT JOIN makt AS c  ON c~matnr = b~matnr AND
                                            c~spras = @me->gv_langu
    INTO TABLE @DATA(lt_main)
      UP TO @lv_max_rows ROWS
      WHERE
      "( statu IN @lr_open_statu OR ( bdatu GE @lv_date AND statu IN @lr_statu ) )
          ( statu IN @lr_open_statu OR statu IN @lr_statu ) AND
           bdatu GE @lv_date          AND
           betyp = 'O'                AND "error -> valores: E  Entrega final , T Entrega parcial
           a~lgnum EQ @iv_lgnum       AND
           a~tbnum IN @lr_tbnum       AND
            "AND b~menga > 0
           b~elikz IN @lr_elikz       AND "JCB 29.01.21 -> Sin entrega final en linea
           b~menga IN @lr_menga       AND
           a~rsnum <> @lv_rsnum       AND
           a~nlpla <> @lv_dumm_nlpla  AND
           a~nlpla IN @lr_nlpla       AND
           a~rsnum IN @tl_rsnum_rg    AND
           a~bwlvs = @zcl_wm_constants=>gc_open_nt_bwlvs.
  CHECK sy-subrc = 0.


  "JCB. Comprobar si el material se gestiona mediante palets
  DATA tl_mtart_pal_rg TYPE RANGE OF mara-mtart.

  SELECT sign, opti AS option, low, high
    INTO CORRESPONDING FIELDS OF TABLE @tl_mtart_pal_rg
    FROM tvarvc
    WHERE name = 'ZWM_TIPO_MAT_PALLET'.

  LOOP AT lt_main INTO DATA(ls_main).
    ASSIGN rt_data[ lgnum = ls_main-lgnum tbnum = ls_main-tbnum ] TO FIELD-SYMBOL(<fs_data>).
    IF <fs_data> IS NOT ASSIGNED.
      APPEND CORRESPONDING #( ls_main ) TO rt_data
      ASSIGNING <fs_data>.
    ENDIF.
    APPEND CORRESPONDING #( ls_main MAPPING menga = full_menge ) TO <fs_data>-lt_tbnum
    ASSIGNING FIELD-SYMBOL(<fs_tbnum>).
    IF ls_main-statu = 'E'.
      <fs_tbnum>-menga = ls_main-init_menge.
    ENDIF.
    DATA(ls_mat_info) = me->get_mat_info_lznum( is_data = <fs_data> ). " fill remaining values
    <fs_tbnum>-zzcalidad = ls_mat_info-quality.
    <fs_tbnum>-zzcanal = ls_mat_info-canal.

    "JCB. Material gestionado por palets
    IF <fs_tbnum>-matnr IS NOT INITIAL AND ls_main-mtart IN tl_mtart_pal_rg.
      CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
        EXPORTING
          i_matnr              = <fs_tbnum>-matnr
          i_in_me              = <fs_tbnum>-altme
          i_out_me             = gc_meins_unidad
          i_menge              = <fs_tbnum>-menga
        IMPORTING
          e_menge              = <fs_tbnum>-menga
        EXCEPTIONS
          error_in_application = 1
          error                = 2
          OTHERS               = 3.
      IF sy-subrc <> 0.
        CLEAR <fs_tbnum>-menga.
      ENDIF.
      <fs_tbnum>-altme = gc_meins_unidad.
    ENDIF.


    UNASSIGN <fs_data>.
  ENDLOOP.

*  "JCB 21.09.23
*  "San Cayetano. Si hay necesidades que han entrado por interfaz pero no se han dibujado,
*  "se pone una linea en blanco
*
*  IF iv_lgnum = '270'.
*    SORT rt_data BY pdatu pzeit.
*    IF rt_data IS NOT INITIAL.
*      DATA(vl_fecha_min) = rt_data[ 1 ]-pdatu.
*      DATA(vl_hora_min)  = rt_data[ 1 ]-pzeit.
*
*      SELECT *
*        INTO TABLE @DATA(tl_zwm_intf_omp_sap)
*        FROM zwm_intf_omp_sap
*        WHERE lgnum     = @iv_lgnum AND
*              inactivo  = @space    AND
*              ( end_date > @vl_fecha_min OR ( end_date = @vl_fecha_min AND end_time > @vl_hora_min ) ).
*
*      DATA wl_data LIKE LINE OF rt_data.
*      LOOP AT tl_zwm_intf_omp_sap ASSIGNING FIELD-SYMBOL(<fs_zwm_intf_omp_sap>).
*        CLEAR wl_data.
*        wl_data-lgnum  = <fs_zwm_intf_omp_sap>-lgnum.
**             WL_DATA-tbnum
*        wl_data-pdatu  = <fs_zwm_intf_omp_sap>-end_date.
*        wl_data-pzeit  = <fs_zwm_intf_omp_sap>-end_time.
**             WL_DATA-tbktx
**             WL_DATA-lznum
*        wl_data-benum  = <fs_zwm_intf_omp_sap>-benum.
**             WL_DATA-rsnum
**             WL_DATA-statu
*        APPEND INITIAL LINE TO wl_data-lt_tbnum.
*
*        READ TABLE rt_data TRANSPORTING NO FIELDS WITH KEY benum = <fs_zwm_intf_omp_sap>-benum.
*        IF sy-subrc <> 0.
*          IF <fs_zwm_intf_omp_sap>-nlpla1 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla1 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla1. APPEND wl_data TO rt_data.
*          ENDIF.
*          IF <fs_zwm_intf_omp_sap>-nlpla2 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla2 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla2. APPEND wl_data TO rt_data.
*          ENDIF.
*          IF <fs_zwm_intf_omp_sap>-nlpla3 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla3 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla3. APPEND wl_data TO rt_data.
*          ENDIF.
*          IF <fs_zwm_intf_omp_sap>-nlpla4 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla4 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla4. APPEND wl_data TO rt_data.
*          ENDIF.
*          IF <fs_zwm_intf_omp_sap>-nlpla5 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla5 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla5. APPEND wl_data TO rt_data.
*          ENDIF.
*          IF <fs_zwm_intf_omp_sap>-nlpla6 IS NOT INITIAL AND <fs_zwm_intf_omp_sap>-nlpla6 IN lr_nlpla.
*            wl_data-nlpla = <fs_zwm_intf_omp_sap>-nlpla6. APPEND wl_data TO rt_data.
*          ENDIF.
*        ENDIF.
*      ENDLOOP.
*    ENDIF.
*  ENDIF.
*
*
*  SORT rt_data BY pdatu DESCENDING pzeit DESCENDING.



ENDMETHOD.
METHOD get_bobine_info.
  DATA: lr_matnr  TYPE RANGE OF mara-matnr,
        lr_bobine TYPE RANGE OF zwm_bobine.
  CLEAR rt_lqua.

  IF iv_bobine IS SUPPLIED AND iv_bobine IS NOT INITIAL.
    lr_bobine = VALUE #( ( sign = 'I' option ='EQ' low = iv_bobine )  ).
  ENDIF.
  IF iv_matnr IS SUPPLIED AND iv_matnr IS NOT INITIAL.
    lr_matnr = VALUE #( ( sign = 'I' option ='EQ' low = iv_matnr )  ).
  ENDIF.

  CHECK lines( lr_matnr ) > 0 OR lines( lr_bobine ) > 0.

  SELECT * FROM lqua
  INTO CORRESPONDING FIELDS OF TABLE rt_lqua
  WHERE lgnum = iv_lgnum
  AND lenum IN lr_bobine
  AND matnr IN lr_matnr.

  CHECK: sy-subrc = 0, iv_qty_only = abap_true.
  DELETE rt_lqua WHERE verme <= 0.
ENDMETHOD.
METHOD get_instance.
  rr_ref = COND #(  WHEN gr_ref IS BOUND THEN gr_ref ELSE NEW #( 'S'  ) ). " default to spanish language
  gr_ref = rr_ref.
ENDMETHOD.
METHOD get_langu.
  rv_langu = me->gv_langu.
ENDMETHOD.
METHOD get_lgnum.
  TYPES: lty_lgort TYPE RANGE OF t320-lgort.
  CLEAR rv_lgnum.
  IF iv_lgort IS SUPPLIED AND iv_lgort IS NOT INITIAL.
    DATA(lr_lgort) = VALUE lty_lgort( ( sign = 'I' option = 'EQ' low = iv_lgort ) ).
  ENDIF.
  SELECT SINGLE lgnum
  FROM t320 INTO rv_lgnum
  WHERE werks = iv_werks
  AND lgort IN lr_lgort.
  IF rv_lgnum IS INITIAL.
    rv_lgnum = zcl_wm_constants=>gc_default_lgnum.
  ENDIF.
ENDMETHOD.
METHOD get_mat_info.
  DATA lt_string TYPE TABLE OF string.
  CLEAR rs_data .
  DATA(lv_maktx) = iv_maktx.
  IF iv_maktx IS INITIAL.
    SELECT SINGLE maktx
    FROM makt
    INTO lv_maktx
    WHERE matnr = iv_matnr AND spras = me->gv_langu.
  ENDIF.
  CHECK lv_maktx IS NOT INITIAL.

  "TL2 140gr 2500mm
  SPLIT lv_maktx AT zcl_wm_constants=>gc_maktx_sep INTO TABLE lt_string.

  " width + width_meins -> last part of maktx -> 2500 mm
  TRY.
      DATA(lv_str) = lt_string[ lines( lt_string ) ].
      DATA(lv_width) = VALUE char20( ).
      DO strlen( lv_str ) TIMES.
        DATA(lv_idx) = sy-index - 1.
        DATA(lv_c) = lv_str+lv_idx(1).
        IF lv_c NA '0987654321'.
          DATA(lv_meins) = lv_str+lv_idx.
          TRANSLATE lv_meins TO UPPER CASE.
          "            rs_data-width_meins = lv_meins.
          EXIT.
        ENDIF.
        lv_width = lv_width && lv_c.
      ENDDO.
      IF lv_width IS NOT INITIAL.
        rs_data-width = lv_width.
      ENDIF.
    CATCH cx_root.
  ENDTRY.

  " MAT_ID - 1st part of maktx
  rs_data-mat_id = lt_string[ 1 ].

  " ztrim + ztrim_meins -> last separator of LZNUM
  " 2500/113/B/87.000
  CLEAR lt_string.
  SPLIT iv_lznum AT zcl_wm_constants=>gc_lznum_sep INTO TABLE lt_string.
  TRY.
      rs_data-ztrim = lt_string[ lines( lt_string ) ].
      "       rs_data-ztrim_meins = rs_data-width_meins. " check akiiiii
    CATCH cx_root.
  ENDTRY.

  "quality - 2nd and 3rd part of lznum
  TRY.
      rs_data-quality = lt_string[ 2 ] && lt_string[ 3 ].
    CATCH cx_root.
  ENDTRY.

  " largo - 1st part of lznum
  TRY.
      rs_data-length = lt_string[ 1 ].
      "      rs_data-length_meins = rs_data-width_meins.
    CATCH cx_root.
  ENDTRY.







ENDMETHOD.
METHOD get_mat_info_lznum.
  DATA lt_string TYPE TABLE OF string.
  CLEAR rs_data.
  CHECK lines( is_data-lt_tbnum ) = 1.
  DATA(ls_tbnum) = is_data-lt_tbnum[ 1 ].
  SPLIT ls_tbnum-maktx AT space INTO TABLE lt_string.
  TRY.
      rs_data-mat_id = |{ lt_string[ 1 ] } { ls_tbnum-zzancho }|.

    CATCH cx_root.
  ENDTRY.
  SPLIT is_data-lznum AT zcl_wm_constants=>gc_lznum_sep INTO TABLE lt_string.
  rs_data-width = ls_tbnum-zzancho.
  rs_data-length = ls_tbnum-menga.
  TRY.
      rs_data-canal = lt_string[ 3 ].
    CATCH cx_root.
  ENDTRY.
  TRY.
      rs_data-quality = |{ lt_string[ 2 ] } { rs_data-canal }|.
    CATCH cx_root.
  ENDTRY.
  TRY.
      DATA(lv_i) = CONV int4( lt_string[ 4 ] ).
      rs_data-ztrim = lv_i.
    CATCH cx_root.
  ENDTRY.
ENDMETHOD.
METHOD get_mat_info_v2.

*    DATA lt_string TYPE TABLE OF string.
*
*    CLEAR rs_data.
*    rs_data-width = is_data-zzancho.
*    rs_data-length = is_data-zzlargo.
*    rs_data-quality = is_data-zzcalidad.
*    rs_data-ztrim = is_data-zzgramaje.
*
*    DATA(lv_maktx) = is_data-maktx.
*    IF lv_maktx IS INITIAL.
*      SELECT SINGLE maktx
*      FROM makt
*      INTO lv_maktx
*      WHERE matnr = is_data-matnr AND spras = me->gv_langu.
*    ENDIF.
*    CHECK lv_maktx IS NOT INITIAL.
*
*    SPLIT lv_maktx AT zcl_wm_constants=>gc_maktx_sep INTO TABLE lt_string.
*    CHECK lines( lt_string ) > 0.
*    rs_data-mat_id = lt_string[ 1 ].


ENDMETHOD.
METHOD get_mat_subs_comp.
  CLEAR: et_compat, et_subst.

*  " 1 - from marc
*  SELECT a~nfmat AS matnr FROM marc AS a " DEL - cvivo - 58678 Sólo usaremos compatibles
*  INTO CORRESPONDING FIELDS OF TABLE @et_subst
*  WHERE matnr = @iv_matnr
*  AND werks = @iv_werks
*  AND ausdt >= @sy-datum .

  et_compat = zcl_wm_compatibles=>get_compatibles( iv_werks = iv_werks
                                                   iv_matnr = iv_matnr ).

  CHECK et_compat IS INITIAL.

  " 2 - from PGMI
  SELECT DISTINCT nrmit FROM pgmi
  INTO TABLE @DATA(lt_nrmit)
  WHERE prgrp IN ( SELECT prgrp FROM pgmi WHERE nrmit = @iv_matnr AND werks = @iv_werks AND wemit = @iv_werks )
  AND werks = @iv_werks
  AND wemit = @iv_werks
  AND nrmit <> @iv_matnr
  AND datum >= @sy-datum
  .
  et_compat = VALUE #( FOR ls_nrmit IN lt_nrmit ( matnr = ls_nrmit-nrmit ) ).

ENDMETHOD.
METHOD get_mat_txt_omp.
  DATA lv_cal TYPE char03.
  CLEAR rv_maktx.


  IF iv_cal NE space. " cvivo - 24.10.2020 - rendimiento
    lv_cal = iv_cal.
  ELSE.
    PERFORM f_dame_calidad IN PROGRAM zrwm_intf_omp
        USING   iv_werks is_mara-matkl CHANGING lv_cal.
  ENDIF.


  IF iv_cal_only = abap_true.
    rv_maktx = lv_cal.
    RETURN.
  ENDIF.

  DATA(lv_gram) = |{ is_mara-zzgramaje ALPHA = OUT }|.
  DATA(lv_anch) = |{ is_mara-zzancho ALPHA = OUT }|.
  DATA(lv_largo) = |{ is_mara-zzlargo ALPHA = OUT }|.
  CONDENSE: lv_gram NO-GAPS, lv_anch NO-GAPS, lv_largo NO-GAPS.

  IF is_mara-mtart = 'ZPIH'.
    rv_maktx = |Imp.{ is_mara-matnr+1(5) } { lv_gram }gr { lv_anch }x{ lv_largo }mm|.
  ELSEIF is_mara-mtart = 'ZPIM'.
    "Papel preimpreso
    rv_maktx = |Imp.{ is_mara-matnr+1(5) } { lv_gram }gr { lv_anch }mm|.
  ELSEIF is_mara-mtart = 'ZCAH'. " cvivo 58678 - descriptivo con largo
    rv_maktx = |{ lv_cal } { lv_gram }gr { lv_anch }x{ lv_largo }mm|.
  ELSE.
    rv_maktx = |{ lv_cal } { lv_gram }gr { lv_anch }mm|.
  ENDIF.
ENDMETHOD.
METHOD get_max_rows_omp.
  DATA name TYPE tvarvc-name.

  rv_max_rows = zcl_wm_constants=>gc_max_rows_omp_def.

  name = |ZMAX_ROWS_OMP_{ iv_lgnum }|.
  " read constants
  DATA(lt_const) = zcl_wm_constants=>read_constant(
    EXPORTING
      iv_name = name
  ).
  CHECK lines( lt_const ) > 0.
  rv_max_rows = lt_const[ 1 ]-low.

ENDMETHOD.
METHOD get_nlpla_idx.
  CLEAR rv_idx.
  CHECK iv_nlpla IS NOT INITIAL.

  SELECT SINGLE high
    INTO rv_idx
    FROM tvarvc
    WHERE name = 'ZWM_POS_MAQUINA_LISTADO_APRO'  AND
          low  = iv_nlpla.
    IF sy-subrc <> 0.
      " for now, idx will be last char of nlpla
      DATA(lv_idx) = strlen( iv_nlpla ) - 1.
      rv_idx = iv_nlpla+lv_idx(1).
    ENDIF.
  ENDMETHOD.
METHOD get_nt_for_resb.
  CLEAR rt_ltbk.
  CHECK is_resb-rsnum IS NOT INITIAL.

  SELECT lgnum, tbnum, benum, nlpla, statu FROM ltbk
  INTO CORRESPONDING FIELDS OF TABLE @rt_ltbk
  WHERE rsnum = @is_resb-rsnum
    AND betyp = 'O'
    AND bwlvs = '919'.
ENDMETHOD.
METHOD get_resb_for_nt.
  DATA lr_kzear TYPE RANGE OF resb-kzear.
  DATA lr_enmng TYPE RANGE OF resb-enmng.
  IF iv_only_open = abap_true.
    lr_kzear = VALUE #( ( sign = 'I' option = 'EQ' low = abap_false ) ).
  ENDIF.
  IF iv_no_cns = abap_true.
    lr_enmng = VALUE #( ( sign = 'I' option = 'EQ' low = 0 ) ).
  ENDIF.
  CLEAR rs_resb.
  SELECT  *
  FROM resb AS b
  INTO CORRESPONDING FIELDS OF @rs_resb
  WHERE b~rsnum = @is_ltbk-rsnum
  AND b~sgtxt = @is_ltbk-benum
  AND b~kzear IN @lr_kzear
  AND b~enmng IN @lr_enmng
  ORDER BY rspos DESCENDING.
    EXIT.
  ENDSELECT.


  "JCB 20.09.23. San Cayetano. En la rebobinadora el BENUM y SGTXT pueden no coincidir
  "TODO: Quitar el hardcode
  IF rs_resb IS INITIAL.
    IF is_ltbk-nlpla = 'REBOB1'.
      SELECT  *
      FROM resb AS b
      INTO CORRESPONDING FIELDS OF @rs_resb
      WHERE b~rsnum = @is_ltbk-rsnum
*  AND b~sgtxt = @is_ltbk-benum
      AND b~kzear IN @lr_kzear
      AND b~enmng IN @lr_enmng
      ORDER BY rspos DESCENDING.
        EXIT.
      ENDSELECT.
    ENDIF.
  ENDIF.



ENDMETHOD.
METHOD get_rsnum.
  rv_rsnum = gs_ltak_rsnum.
  CHECK iv_init = abap_true.
  CLEAR gs_ltak_rsnum.
ENDMETHOD.
METHOD get_rspos.
  rs_rspos = gs_ltap_rspos.
  CHECK iv_init = abap_true.
  CLEAR gs_ltap_rspos.

ENDMETHOD.
  METHOD get_ubicacion_prop_ua.



    "TODO: DOCUMENTAR Y CONSULTAR SI ESTÁ BIEN IMPLEMENTADO
    "Rutina  get_ubic_prop del include MZ_WM_RF_F02
    "Para depurarlo, transacción ZWM_RF_003 y ponte en el perfil LRFMD en el número de almacén 240 (aunque creo que es independiente)

    wp_ubicacion-lgnum = zcl_wm_nt_generic=>get_lgnum( vp_werks ).

    SELECT SINGLE *
      INTO @DATA(wl_lqua)
      FROM lqua
      WHERE lgnum = @wp_ubicacion-lgnum  AND
            lenum = @vp_lenum            AND
            verme > 0.
    CHECK sy-subrc = 0.



    CALL FUNCTION 'ZWM_UBICACION_PROPUESTA'
      EXPORTING
        lgnum      = wp_ubicacion-lgnum
        matnr      = wl_lqua-matnr
        verme      = wl_lqua-verme
      IMPORTING
        nltyp_prop = wp_ubicacion-lgtyp
        nlpla_prop = wp_ubicacion-lgpla.

  ENDMETHOD.
METHOD group_ltba.
  FIELD-SYMBOLS: <fs> TYPE zcl_wm_constants=>gty_ltba_idx_grp.

  " 58678 - fase 2, opción de no agrupar
  SELECT sign, opti AS option, low AS low, high AS high FROM tvarvc
    WHERE name EQ 'ZWM_UI5_NO_AGRUP_PAP' " asumimos que no se repiten ubicaciones de consumo entre plantas
      INTO TABLE @DATA(r_no_group_nlpla).

  IF sy-subrc NE 0.
    APPEND VALUE #( sign = 'I' option = 'EQ' low = space ) TO r_no_group_nlpla.
  ENDIF.


  " group logic
  " same -> nlpla, width, and matnr
  " Si el material es el genérico, tiene que tener la misma calidad
  CLEAR rt_grp.
  DATA(lt_ltba) = it_ltba.
  SORT lt_ltba BY nlpla pdatu pzeit.
  LOOP AT lt_ltba INTO DATA(ls_ltba).
    CHECK lines( ls_ltba-it_ltba ) = 1.
    DATA(ls_ltba_val) = ls_ltba-it_ltba[ 1 ].

    SELECT SINGLE zzancho
      FROM mara INTO @DATA(lv_ancho)
      WHERE matnr = @ls_ltba_val-matnr.

    DATA(ls_mat_data) = me->get_mat_info_lznum( is_data   = VALUE #( lznum = ls_ltba_val-lznum
                                                lt_tbnum  = VALUE #( ( zzancho = lv_ancho ) ) )  ).

    IF lines( rt_grp ) > 0.
      READ TABLE rt_grp ASSIGNING <fs> INDEX lines( rt_grp ).
    ENDIF.
    IF <fs> IS NOT ASSIGNED OR <fs>-nlpla   <> ls_ltba_val-nlpla
                            OR <fs>-width   <> ls_mat_data-width
                            OR <fs>-matnr   <> ls_ltba_val-matnr
                            OR ls_ltba-nlpla IN r_no_group_nlpla " 58678 - fase 2: para la vatán es necesario no agrupar para las altas
                            OR ( <fs>-quality <> ls_mat_data-quality AND ls_ltba_val-matnr = zcl_si_prod_replenishment_ui5=>c_material_dummy ).


      APPEND CORRESPONDING #( ls_mat_data ) TO rt_grp ASSIGNING <fs>.
      <fs>-idx = lines( rt_grp ).
      <fs>-matnr    = ls_ltba_val-matnr.
      <fs>-nlpla    = ls_ltba_val-nlpla.
      <fs>-rsnum    = ls_ltba-rsnum. " pintamos la reserva - cvivo
      <fs>-fsc      = ls_ltba-fsc. " cvivo - 65348
      <fs>-quality  = ls_mat_data-quality.
    ENDIF.
    APPEND VALUE #( idx = ls_ltba-idx it_ltba = ls_ltba-it_ltba rsnum = ls_ltba-rsnum fsc = ls_ltba-fsc ) TO <fs>-it_ltba_idx.

    UNASSIGN <fs>.
  ENDLOOP.
ENDMETHOD.
METHOD is_reserv_closable.
  DATA lv_end_date TYPE d.
  DATA lv_end_time TYPE t.
  DATA lv_start_date TYPE d.
  DATA lv_start_time TYPE t.
  DATA lv_uzeit TYPE t.
  rv_is_closable = abap_false.
  CHECK iv_hours_to_check IS NOT INITIAL.
  SELECT MAX( bdatu ) AS last_date, MAX( bzeit ) AS last_time
    FROM ltbk
    INTO @DATA(ls_date)
    WHERE rsnum = @iv_rsnum.
  CHECK sy-subrc = 0.
  DATA(lv_init_time) = iv_hours_to_check.
  DO.
    lv_uzeit = COND #( WHEN lv_init_time > '240000' THEN '240000' ELSE lv_init_time ).
    lv_init_time = lv_init_time - lv_uzeit.
    lv_start_time = COND #( WHEN lv_end_time IS INITIAL THEN ls_date-last_time ELSE lv_end_time ).
    lv_start_date = COND #( WHEN lv_end_date IS INITIAL THEN ls_date-last_date ELSE lv_end_date ).

    CALL FUNCTION 'C14B_ADD_TIME'
      EXPORTING
        i_starttime = lv_start_time
        i_startdate = lv_start_date
        i_addtime   = lv_uzeit
      IMPORTING
        e_endtime   = lv_end_time
        e_enddate   = lv_end_date.

    IF lv_init_time IS INITIAL.
      EXIT.
    ENDIF.

  ENDDO.

  CHECK: lv_end_date > sy-datum OR ( lv_end_date = sy-datum AND lv_end_time >= sy-uzeit ).
  rv_is_closable = abap_true.

ENDMETHOD.
  METHOD maquinas_getdetail.
    wp_maquina-id = vp_machine_id.

    "Mantenimento en transaccion STVARV
    SELECT SINGLE high
      INTO wp_maquina-nombre
      FROM tvarvc
      WHERE name  = 'ZWM_NOMBRE_MAQUINA' AND
            low   = vp_machine_id.
    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha encontrado la máquina'(001) ).
    ENDIF.

    SELECT SINGLE low
      INTO @DATA(vl_low)
      FROM tvarvc
      WHERE name  = 'ZWM_MAQUINAS_GESTION_PALETS' AND
            low   = @vp_machine_id.
    IF sy-subrc = 0.
      wp_maquina-gestiona_palets = 'X'.
    ENDIF.

    SELECT SINGLE @abap_true
      INTO @wp_maquina-parte_rebobinado
      FROM tvarvc
      WHERE name  = 'ZWM_MAQUINAS_PARTE_REBOB' AND
            low   = @vp_machine_id.

    SELECT SINGLE @abap_true
      INTO @wp_maquina-LISTADO_APRO_SIN_AGRUP
      FROM tvarvc
      WHERE name  = 'ZWM_MAQUINAS_APRO_SIN_AGRUP' AND
            low   = @vp_machine_id.


    SELECT SINGLE t320~werks, t320~lgnum, lagp~lgtyp
      INTO (@wp_maquina-werks, @wp_maquina-lgnum, @wp_maquina-lgtyp)
      FROM lagp INNER JOIN t320 ON t320~lgnum = lagp~lgnum
      WHERE lagp~lgpla = @vp_machine_id.


    "Estaciones. Código y descripcion
    DATA(vl_nlpla_rg) = |{ vp_machine_id }_|.
    SELECT low, high
      INTO TABLE @DATA(tl_nombre_maquina)
      FROM tvarvc
      WHERE name  =  'ZWM_NOMBRE_MAQUINA' AND
            low   LIKE  @vl_nlpla_rg.

    SELECT low, high
      INTO TABLE @DATA(tl_nombre_maquina_corto)
      FROM tvarvc
      WHERE name  =  'ZWM_NOMBRE_MAQUINA_CORTO' AND
            low   LIKE  @vl_nlpla_rg.

    SELECT low, high
      INTO TABLE @DATA(tl_pos_maquina)
      FROM tvarvc
      WHERE name  =  'ZWM_POS_MAQUINA_LISTADO_APRO' AND
            low   LIKE  @vl_nlpla_rg.

    DATA vl_pos TYPE c.
    LOOP AT tl_nombre_maquina ASSIGNING FIELD-SYMBOL(<fs_nombre_maquina>).
      READ TABLE tl_pos_maquina ASSIGNING FIELD-SYMBOL(<fs_pos_maquina>) WITH KEY low = <fs_nombre_maquina>-low.
      IF sy-subrc  = 0.
        vl_pos = <fs_pos_maquina>-high.
      ELSE.
        DATA(vl_idx) = strlen( <fs_nombre_maquina>-low ) - 1.
        vl_pos = <fs_nombre_maquina>-low+vl_idx(1).
      ENDIF.

      ASSIGN COMPONENT |ID_ESTACION{ vl_pos }| OF STRUCTURE wp_maquina TO FIELD-SYMBOL(<fs_id_estacion>).
      CHECK sy-subrc = 0.
      <fs_id_estacion> = <fs_nombre_maquina>-low.

      ASSIGN COMPONENT |NOMBRE_ESTACION{ vl_pos }| OF STRUCTURE wp_maquina TO FIELD-SYMBOL(<fs_nombre_estacion>).
      CHECK sy-subrc = 0.

      <fs_nombre_estacion> = <fs_nombre_maquina>-high.
      READ TABLE tl_nombre_maquina_corto ASSIGNING FIELD-SYMBOL(<fs_nombre_maquina_corto>) WITH KEY low = <fs_nombre_maquina>-low.
      IF sy-subrc = 0.
        <fs_nombre_estacion> = <fs_nombre_maquina_corto>-high.
      ENDIF.
    ENDLOOP.

    IF tl_nombre_maquina IS INITIAL.
      DO 5 TIMES.
        vl_pos = sy-index.
        ASSIGN COMPONENT |ID_ESTACION{ vl_pos }| OF STRUCTURE wp_maquina TO <fs_id_estacion>.
        CHECK sy-subrc = 0.
        <fs_id_estacion> = |{ vp_machine_id }{ vl_pos }|.

        ASSIGN COMPONENT |NOMBRE_ESTACION{ vl_pos }| OF STRUCTURE wp_maquina TO <fs_nombre_estacion>.
        CHECK sy-subrc = 0.
        <fs_nombre_estacion> = |Estación { vl_pos }|.
      ENDDO.
    ENDIF.




  ENDMETHOD.
METHOD movebobine.
  CLEAR: ev_subrc, es_ltak, ev_retro.
  SELECT SINGLE lgtyp FROM lagp
    INTO @DATA(lv_lgtyp)
    WHERE lgpla = @iv_dest_nlpla
    AND lgnum   = @iv_lgnum.


  " check destination <> origin
  SELECT SINGLE lgpla, lgtyp, charg, werks
    FROM lqua
    INTO @DATA(wl_lqua)
    WHERE lenum = @iv_bobine
      AND lgnum = @iv_lgnum.

  DATA(wl_centro) = zcl_wm_nt_generic=>get_instance( )->centros_getdetail( wl_lqua-werks ).



  IF iv_tbnum IS NOT INITIAL.
    "Comprobar FSC RECYCLED
    DATA: vl_fsc_recycled_lote TYPE ekpo-zzdecla_fsc,
          vl_fsc_recycled_nec  TYPE zwm_ltbk_fsc.

    SELECT SINGLE *
      INTO @DATA(wl_ltbk)
      FROM ltbk
      WHERE lgnum = @iv_lgnum AND
            tbnum = @iv_tbnum.


    SELECT SINGLE *
      INTO @DATA(wl_zwm_ltbk_adit)
      FROM zwm_ltbk_adit
      WHERE lgnum = @iv_lgnum AND
            tbnum = @iv_tbnum.
    IF sy-subrc <> 0 AND wl_centro-lista_apro_ui5_pp = 'X'.
      wl_zwm_ltbk_adit-benum = wl_ltbk-benum.
    ENDIF.

    IF iv_validar_fsc_recycled = 'X'.
      SELECT SINGLE low, high
        INTO (@vl_fsc_recycled_lote, @vl_fsc_recycled_nec)
        FROM tvarvc
        WHERE name = 'ZWM_FSC_RECYCLED'.

      DATA(vl_fsc_recycled) = COND xfeld( WHEN wl_zwm_ltbk_adit-fsc = vl_fsc_recycled_nec THEN 'X' ELSE space ).

      DATA: tl_lotes TYPE ztfsc_charg,
            wl_lotes LIKE LINE OF tl_lotes.
      IF vl_fsc_recycled = 'X'.
        wl_lotes-charg = wl_lqua-charg.
        COLLECT wl_lotes INTO tl_lotes.
        CALL FUNCTION 'ZMM_GET_FSC_LOTES'
          CHANGING
            lotes = tl_lotes.

        READ TABLE tl_lotes ASSIGNING FIELD-SYMBOL(<fs_lotes>) INDEX 1.
        IF sy-subrc <> 0 OR <fs_lotes>-zzdecla_fsc(1) <> vl_fsc_recycled_lote(1).
          zcl_seis_odata_utils=>lanzar_excepcion( 'Ha introducido una UA sin certificación FSC Recycled./nDebe aprovisionar una UA con esta certificación para el pedido'(002) ).
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.



*  IF lv_source-lgpla = iv_dest_nlpla
*  AND lv_source-lgtyp = lv_lgtyp.
*    ev_subrc = 0.
*    RETURN.
*
*  ENDIF.
  IF iv_tipo_mov_bobina CA gc_tipo_mov_bobina_completo && gc_tipo_mov_bobina_orden_trans && gc_tipo_mov_bobina_reubicar.
    DATA vl_lznum TYPE ltak-lznum.
    vl_lznum = iv_tbnum.
    CALL FUNCTION 'L_TO_CREATE_MOVE_SU'
      EXPORTING
        i_lenum               = iv_bobine   " Número de unidad de almacén
        i_bwlvs               = iv_bwlvs    " Clase movimiento
        i_lznum               = vl_lznum    " Número adicional de ref: Lo utilizamos para pasar la necesidad de transporte
        i_nltyp               = lv_lgtyp    " Tipo de almacén 'hacia'
*       i_nlber               = SPACE    " Area de almacenamiento 'hacia'
        i_nlpla               = iv_dest_nlpla    " Ubic. 'hacia'
*       i_nppos               = SPACE    " Posición en la ubicación 'hacia'
*       i_squit               = SPACE    " Confirm. inmed.
*       i_letyp               = SPACE    " Tipo de unidad de almacén
*       i_nidru               = SPACE    " No imprimir
*       i_drukz               = SPACE    " Ind. de impresión
*       i_ldest               = SPACE    " Impresora
*       i_update_task         = SPACE    " Indicator: update via update task
*       i_commit_work         = 'X'    " Indicator whether COMMIT WORK in function module
*       i_bname               = SY-UNAME    " Usuario que crea la OT
*       i_solex               = 0    " Planned Transfer Order Processing Time from External System
*       i_pernr               = 0    " Personnel Number
        i_betyp               = COND #( WHEN wl_zwm_ltbk_adit-benum IS NOT INITIAL THEN 'O' ELSE space )    " Requirement Type
        i_benum               = wl_zwm_ltbk_adit-benum    " Requirement Number
      IMPORTING
        e_tanum               = es_ltak-tanum   " Número de orden de transporte
*       e_nltyp               =     " Tipo de almacén 'hacia'
*       e_nlber               =     " Area de almacenamiento 'hacia'
*       e_nlpla               =     " Ubic. 'hacia'
*       e_nppos               =     " Posición en la ubicación 'hacia'
*      TABLES
*       t_ltap_move_su        =
*       t_ltak                =
*       t_ltap_vb             =
      EXCEPTIONS
        not_confirmed_to      = 1
        foreign_lock          = 2
        bwlvs_wrong           = 3
        betyp_wrong           = 4
        nltyp_wrong           = 5
        nlpla_wrong           = 6
        nltyp_missing         = 7
        nlpla_missing         = 8
        squit_forbidden       = 9
        lgber_wrong           = 10
        xfeld_wrong           = 11
        drukz_wrong           = 12
        ldest_wrong           = 13
        no_stock_on_su        = 14
        su_not_found          = 15
        update_without_commit = 16
        no_authority          = 17
        benum_required        = 18
        ltap_move_su_wrong    = 19
        lenum_wrong           = 20
        error_message         = 99
        OTHERS                = 22.
    IF sy-subrc = 99.
      zcl_seis_odata_utils=>lanzar_excepcion( ).
    ELSEIF sy-subrc <> 0.
      ev_subrc = sy-subrc.
      RETURN.
    ELSEIF iv_bwlvs EQ zcl_wm_nt_generic=>gc_move_type_998. " cvivo -65087- Si es reubicar resto de UI5 (998) y no se ha leído en máquina, es un retroceso, lo marcamos en
      " la tabla adicional sobre la OT del 918

      SELECT SINGLE * FROM ltak " recuperamos la OT del 918, la útima
        INTO @DATA(l_918)
        WHERE lgnum EQ @iv_lgnum
          AND tanum EQ ( SELECT MAX( ltak~tanum ) FROM ltak " tomamos el último 918 como el bueno
                          INNER JOIN ltap ON ltap~tanum EQ ltak~tanum
                                         AND ltap~lgnum EQ ltak~lgnum
                          WHERE  bwlvs EQ @zcl_wm_nt_generic=>gc_move_type_918
                            AND ltak~lgnum EQ @iv_lgnum
*                            AND ltak~benum EQ @wl_zwm_ltbk_adit-benum " cvivo - no siempre sabemos BENUM, sólo en pantalla de propuesta
                            AND nlenr EQ  @iv_bobine  ).

      IF sy-subrc EQ 0.
        SELECT SINGLE @abap_true FROM zwm_intf_bhs
          WHERE orden_bhs EQ @l_918-benum
            AND cod_etiqueta EQ @iv_bobine
            AND lgnum EQ @iv_lgnum
          INTO @DATA(existe_cons).

        IF sy-subrc NE 0.
          DATA(ltak_adit) = VALUE zwm_ltak_adit( lgnum = iv_lgnum tanum = l_918-tanum retro = abap_true ).
          ev_retro = abap_true.

          MODIFY zwm_ltak_adit FROM ltak_adit.
          COMMIT WORK AND WAIT.
        ENDIF.
      ENDIF.
    ENDIF.

    es_ltak-lgnum = iv_lgnum.
  ENDIF.

  IF iv_tipo_mov_bobina CA gc_tipo_mov_bobina_completo && gc_tipo_mov_bobina_trans_stock.

    CHECK iv_bwlvs = zcl_wm_nt_generic=>gc_move_type_918.
    " must check also if stock is blocked...
    SELECT SINGLE bestq FROM lqua
      INTO @DATA(lv_bestq)
      WHERE lgnum = @iv_lgnum
        AND lenum = @iv_bobine.
    CHECK lv_bestq = 'S'. " blocked stock
    zcl_wm_gestion_stocks=>create_transf_stock(
      EXPORTING
        iv_lgnum            = iv_lgnum    " Núm.almacén/Complejo alm.
        iv_lgtyp            = lv_lgtyp    " Tipo almacén
        iv_bwlvs            = gc_move_type_853    " Cl.movim.gestión almacenes -> 853
        iv_lenum            = iv_bobine    " Número de unidad de almacén
      EXCEPTIONS
        no_authority        = 1
        no_enqueue_possible = 2
        error_wm_posting    = 3
        error_im_posting    = 4
        OTHERS              = 5 ).
    IF sy-subrc <> 0.
      ev_subrc = sy-subrc.
      RETURN.
    ENDIF.
  ENDIF.

*  ev_subrc = sy-subrc.
ENDMETHOD.
METHOD read_http_header_val.
  DATA: lo_facade              TYPE REF TO /iwbep/if_mgw_dp_int_facade,
        lt_request_header      TYPE tihttpnvp,
        ls_request_line_header LIKE LINE OF lt_request_header.

  "lo_facade ?= /iwbep/if_mgw_conv_srv_runtime~get_dp_facade( ).
  CLEAR rv_val.
  CHECK iv_facade IS BOUND.
  lt_request_header = iv_facade->get_request_header( ).
  TRY.
      rv_val = lt_request_header[ name = iv_name ]-value.
    CATCH cx_root.
  ENDTRY.

ENDMETHOD.
METHOD set_langu.
  me->gv_langu = iv_langu.
ENDMETHOD.
METHOD set_nlpla_idx_data.
  FIELD-SYMBOLS: <fsv> TYPE any.

  DATA(lv_idx) = me->get_nlpla_idx( iv_nlpla = is_data-nlpla ).
  CHECK lv_idx IS NOT INITIAL.
  DATA(lv_field) = 'NLPLA' && lv_idx.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_data-nlpla.
  lv_field = 'NLPLA' && lv_idx && '_MATNR'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_data-lt_tbnum[ 1 ]-matnr.

  lv_field = 'NLPLA' && lv_idx && '_TBNUM'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_data-lt_tbnum[ 1 ]-tbnum.

  DATA(lv_matnr) = is_data-lt_tbnum[ 1 ]-matnr.
  lv_field = 'NLPLA' && lv_idx && '_MAT_ID'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_mat_data-mat_id.
  IF iv_group = abap_false.
    lv_field = 'NLPLA' && lv_idx && '_MENGE'.
    ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
    CHECK sy-subrc = 0.
    <fsv> = <fsv> + is_data-lt_tbnum[ 1 ]-menga.
    lv_field = 'NLPLA' && lv_idx && '_MEINS'.
    ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
    CHECK sy-subrc = 0.
    <fsv> = is_data-lt_tbnum[ 1 ]-altme.
  ELSE.
    lv_field = 'NLPLA' && lv_idx && '_GROUP'.
    ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
    CHECK sy-subrc = 0.
    <fsv> = iv_group.

  ENDIF.
  lv_field = 'NLPLA' && lv_idx && '_GRAMAJE'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.

  ASSIGN COMPONENT |NLPLA{ lv_idx }_MAKTX| OF STRUCTURE cs_data TO FIELD-SYMBOL(<fs_maktx>).
  CHECK sy-subrc = 0.

  DATA wl_mara TYPE mara.
  IF iv_gramaje EQ space OR iv_ancho EQ space.
    SELECT SINGLE *
      INTO wl_mara
      FROM mara
      WHERE mara~matnr = lv_matnr.
  ELSE.
    wl_mara-zzgramaje = iv_gramaje.
    wl_mara-zzancho = iv_ancho.
    wl_mara-zzlargo = iv_largo.
    wl_mara-mtart = iv_mtart.
  ENDIF.

  <fsv> = wl_mara-zzgramaje.
  <fs_maktx> = zcl_wm_nt_generic=>get_mat_txt_omp( iv_werks = iv_werks
                                                   is_mara  = wl_mara
                                                   iv_cal = iv_cal ).

  lv_field = 'NLPLA' && lv_idx && '_ANCHO'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_mat_data-width.

  lv_field = 'NLPLA' && lv_idx && '_WGBEZ60'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.

  IF iv_cal NE space.
    <fsv> = iv_cal.
  ELSEIF wl_mara-mtart = 'ZPIH' OR wl_mara-mtart = 'ZPIM'.
    <fsv> = |Imp.{ wl_mara-matnr+1(5) }|.
  ELSE.
    <fsv> = CONV wgbez60( zcl_wm_nt_generic=>get_mat_txt_omp( iv_werks = iv_werks
                                                              is_mara  = wl_mara
                                                              iv_cal_only = abap_true ) ).
  ENDIF.


  lv_field = 'NLPLA' && lv_idx && '_RSNUM'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.
  <fsv> = is_data-rsnum.


  lv_field = 'NLPLA' && lv_idx && '_MATNR_EXTERNAL'.
  ASSIGN COMPONENT lv_field OF STRUCTURE cs_data TO <fsv>.
  CHECK sy-subrc = 0.

ENDMETHOD.
METHOD set_rsnum.
  gs_ltak_rsnum = iv_rsnum.
ENDMETHOD.
METHOD set_rspos.
  gs_ltap_rspos = is_rspos.
ENDMETHOD.
METHOD set_status_nt.
  DATA lt_ltbk TYPE TABLE OF ltbk.
  DATA lt_ltbp TYPE TABLE OF ltbp.

  SELECT SINGLE * FROM ltbk
  INTO  @DATA(ls_ltbk)
  WHERE lgnum = @is_ltbk-lgnum
  AND tbnum = @is_ltbk-tbnum.

  CHECK: sy-subrc = 0, ls_ltbk-statu <> iv_statu.

  ls_ltbk-statu = iv_statu.
  APPEND ls_ltbk TO lt_ltbk.

  CALL FUNCTION 'L_TR_CHANGE_INTERN'
    TABLES
      iltbk = lt_ltbk   " Transfer requirement headers
      iltbp = lt_ltbp.   " Transfer requirement items

  CHECK iv_commit = abap_true.
  COMMIT WORK.
ENDMETHOD.
  METHOD unidades_alma_getdetail.
    SELECT SINGLE lgnum, lenum, verme, meins, matnr, werks
      INTO CORRESPONDING FIELDS OF @wp_unidad_alma
      FROM lqua
      WHERE lenum = @vp_lenum AND
            lgnum = @vp_lgnum.
    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'Unidad de almacén no encontrada' ).
    ENDIF.

    SELECT SINGLE *
      INTO @DATA(wl_mara)
      FROM mara
      WHERE matnr = @wp_unidad_alma-matnr.
    wp_unidad_alma-maktx = zcl_wm_nt_generic=>get_mat_txt_omp( iv_werks = wp_unidad_alma-werks
                                                               is_mara  = wl_mara ).


  ENDMETHOD.
METHOD validate_mat_diam.
  rv_valid = abap_true.

  SELECT SINGLE * FROM lqua
  INTO @DATA(ls_lqua)
  WHERE lenum = @iv_bobine
  AND lgnum = @iv_lgnum.

  CHECK sy-subrc = 0.

  zcl_wm_nt_generic=>calc_diam_con_kg(
    EXPORTING
      iv_matnr          = ls_lqua-matnr    " Número de material
      iv_werks          = ls_lqua-werks    " Centro
      iv_kg             = ls_lqua-verme    " Cantidad en kilogramos
    IMPORTING
      ev_dia            = DATA(lv_dia)    " Cantidad en diámetro (cm)
    EXCEPTIONS
      um_no_valid       = 1
      missing_constants = 2
      missing_matnr     = 3
      OTHERS            = 4
  ).
  IF sy-subrc <> 0.
    rv_valid = abap_false.
    RETURN.
  ENDIF.

  rv_valid = COND #( WHEN iv_diametro < lv_dia THEN abap_true ELSE abap_false ).


ENDMETHOD.
