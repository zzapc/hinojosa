TYPES: BEGIN OF _lty_matnr_tools_data_list,
  matnr TYPE matnr,
  lgpla TYPE lgpla,
  lgini TYPE lgpla,
  lgfin TYPE lgpla,
  mkapv TYPE mlgn_mkapv,
END OF _lty_matnr_tools_data_list.

class ZCL_WM_TOOLS_LOCATION_MANAGER definition
  public
  final
  create public .

public section.

  types:
    ty_t_ztmm0033 TYPE TABLE OF ztmm0033 INITIAL SIZE 1000 WITH EMPTY KEY,
    ty_t_ztlm0003 TYPE TABLE OF ztlm0003 INITIAL SIZE 1000 WITH EMPTY KEY .
  types:
    BEGIN OF ty_s_tlm_params,
        s_ztlm0001 TYPE ztlm0001,
        s_ztlm0002 TYPE ztlm0002,
        s_ztmm0033 TYPE ztmm0033,
        t_ztlm0003 TYPE ty_t_ztlm0003,
      END OF ty_s_tlm_params .
  types:
    BEGIN OF ty_s_lgpla,
        lgnum TYPE lgnum,
        lgtyp TYPE lgtyp,
        lgber TYPE lgber,
        lgpla TYPE lgpla,
        fxbin TYPE bool,
        skzua TYPE lagp_skzua,
        skzue TYPE lagp_skzue,
        skzsi TYPE lagp_skzsi,
      END OF ty_s_lgpla .
  types:
    ty_t_lgpla TYPE TABLE OF ty_s_lgpla INITIAL SIZE 1000 WITH EMPTY KEY .
  types:
    BEGIN OF ty_s_t343_data,
        lgnum TYPE lgnum,
        lgtyp TYPE lgtyp,
        lfdnr TYPE lvs_lfdnr,
        lptyp TYPE lvs_lptyp,
        stawe TYPE t343_stawe,
        endwe TYPE t343_endwe,
        lgber TYPE lgber,
        lkapv TYPE lagp_lkapv,
      END OF ty_s_t343_data .
  types:
    ty_t_t343_data TYPE TABLE OF ty_s_t343_data INITIAL SIZE 1000 WITH DEFAULT KEY .
  types:
    BEGIN OF ty_s_tool_data,
        cuobj       TYPE cuobj,
        maktx       TYPE maktx,
        mtart       TYPE mtart,
        utype       TYPE ztipoutil,
        werks       TYPE werks_d,
        lgort       TYPE lgort_d,
        lgnum       TYPE lgnum,
        lgtyp       TYPE lgtyp,
        lgpbe       TYPE lgpbe,
        mkapv       TYPE mlgn_mkapv,
        arbpl       TYPE arbpl,
        _t_th_lgpla TYPE ty_t_lgpla, "teórica
        _t_re_lgpla TYPE ty_t_lgpla, "real
      END OF ty_s_tool_data .
  types: BEGIN OF ty_s_capacity,
    lkapv TYPE lagp_lkapv,
    rkapv TYPE lagp_rkapv,
  END OF ty_s_capacity.

  data _S_TOOL_DATA type TY_S_TOOL_DATA read-only .
  data _MATNR type MATNR read-only .
  data _TP_LOCATION type CHAR30 read-only .
  data _T_WM_LOCATION_LIST type ZTT_WM_TOOLS_LOCATION_LGPLA read-only .
  class-data _C_MTART_ZCLI type MTART read-only value 'ZCLI' ##NO_TEXT.
  class-data _C_MTART_ZTRO type MTART read-only value 'ZTRO' ##NO_TEXT.
  class-data _C_TYPE_CLICHE type ZTIPOUTIL read-only value 'CLICHÉ' ##NO_TEXT.
  class-data _C_TYPE_TROQUEL type ZTIPOUTIL read-only value 'TROQUEL' ##NO_TEXT.

  methods CLEAR_MATNR_LOCATION
    raising
      ZCX_EXCEPTION .
  methods CONSTRUCTOR
    importing
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
      !I_MKAPV type MLGN_MKAPV optional
    raising
      ZCX_WM_EXCEPTION .
  methods SET_LOCATION_W_DIALOG
    raising
      ZCX_EXCEPTION .
  methods SET_MATNR
    importing
      !I_MATNR type MATNR
      !I_MKAPV type MLGN_MKAPV optional
    raising
      ZCX_WM_EXCEPTION
      ZCX_EXCEPTION .
  methods SET_MKAPV
    importing
      !I_MKAPV type MLGN_MKAPV
    raising
      ZCX_WM_EXCEPTION .
  methods UPDATE_MATNR_LOCATION
    importing
      !I_LGPLA type LGPLA
    raising
      ZCX_WM_EXCEPTION .
  methods UPDATE_MATNR_LOCATION_W_DIALOG
    raising
      ZCX_WM_EXCEPTION .
  PROTECTED SECTION.
private section.

  data _S_TLM_PARAMS type TY_S_TLM_PARAMS .
  data _C_MSG_LABEL type SYST_MSGID value 'ZCL_WM_TLM' ##NO_TEXT.
  data _C_EXTENSION_STR_1 type TE_STRUC value 'ZAPPEND_MLGT_UTILES' ##NO_TEXT.
  data _IO_WM_UTILS type ref to ZCL_UTILS_WM .

  methods _ADJUST_RKAPV_4_LAGP
    changing
      !C_T_LAGP type ZTT_LAGP .
  methods _CHECK_BIN_IS_FREE
    importing
      !I_LGPLA type LGPLA
    returning
      value(R_IS_FREE) type BOOLEAN .
  methods _CHECK_LGPLA_4_TOOL
    importing
      !I_LGPLA type LGPLA
    returning
      value(R_IS_OK) type BOOLEAN
    raising
      ZCX_EXCEPTION .
  methods _CHECK_LGPLA_BREAK
    importing
      !I_LGPLA type LGPLA
      !I_LGPLA_SAMPLE type LGPLA
      !I_BREAK_MASK type ZTLM_BREAK
    returning
      value(R_BREAK) type BOOLEAN .
  methods _CHECK_LGPLA_DATA_4_HELP
    importing
      !I_LAGP type LAGP
    returning
      value(R_ISOK) type BOOLEAN .
  methods _CHECK_MATNR
    importing
      !I_MATNR type MATNR
    returning
      value(R_ISOK) type BOOLEAN .
  methods _CHECK_MKAPV
    importing
      !I_MKAPV type MLGN_MKAPV
    returning
      value(E_IS_OK) type BOOLEAN .
  methods _CHECK_SUBLOCATION
    importing
      !I_LGPLA type LGPLA
      !I_ZSUB_LGPLA type ZZSUBLGPLA_INI
    returning
      value(E_IS_OK) type BOOLEAN .
  methods _CHECK_VERIF
    importing
      !I_VERIF type LAGP_VERIF
    returning
      value(E_IS_OK) type BOOLEAN .
  methods _CREATE_OT_4_TOOL .
  methods _GET_BIN_LIST_NROWS
    importing
      !I_LGPLA type LGPLA
      !I_ROWS type I
      !I_T_R_LGBER type ZTT_R_LGBER optional
    returning
      value(R_T_LAGP) type ZTT_LAGP .
  methods _GET_CURRENT_RE_BINDATA
    returning
      value(R_T_LGPLA) type TY_T_LGPLA .
  methods _GET_CURRENT_TH_BINDATA
    returning
      value(R_T_LGPLA) type TY_T_LGPLA
    raising
      ZCX_EXCEPTION .
  methods _GET_FREE_SUBLOC_4_LGPLA
    importing
      !I_LAGP type LAGP
    exporting
      !E_WM_TOOLS_SUBLOCATION type ZTT_WM_TOOLS_SUBLOCATION
    exceptions
      NO_VALID_IPARAMS
      NO_LAGP_VERIF
      NO_LAGP_LKAPV
      ERROR_VERIF
      ERROR_ZLGPLA .
  methods _GET_LBERT_4_LGBER
    importing
      !I_LGBER type LGBER
    returning
      value(R_LBERT) type LVS_LBERT .
  methods _GET_LGBER_DATA_4_HELP
    returning
      value(R_T_LGBER_4_HELP) type ZTT_WM_TOOLS_LOCATION_LGBER
    raising
      ZCX_EXCEPTION .
  methods _GET_LGBER_DATA_4_HELP_SINGLE
    importing
      !I_LGBER type LGBER
    returning
      value(R_S_LGBER_4_HELP) type ZST_WM_TOOLS_LOCATION_LGBER
    raising
      ZCX_EXCEPTION .
  methods _GET_LGPLA_DATA_4_HELP
    importing
      !I_LGBER type LGBER
    returning
      value(R_T_TOOL_STGBIN_HELP) type ZTT_WM_TOOLS_STGBIN .
  methods _GET_LPTYP_R_4_ZTMM0033_DATA
    importing
      !I_S_ZTMM0033 type ZTMM0033
    returning
      value(R_T_R_LPTYP) type ZTT_R_LPTYP .
  methods _GET_MATNR_MM_DATA
    importing
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    exporting
      !E_CUOBJ type CUOBJ
      value(E_LGPBE) type LGPBE
      value(E_MTART) type MTART
      !E_MAKTX type MAKTX .
  methods _GET_MM_BAPI_DATA
    importing
      !I_ZLGPLAINI type ZLGPLAINI
    returning
      value(E_S_MARD) type MARD
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_MM_WM_BOOKED_BINS
    importing
      !I_MATNR type MATNR optional
      !I_T_R_LGBER type ZTT_R_LGBER optional
      !I_T_R_LGPLA type ZTT_R_LGPLA optional
    returning
      value(R_T_LAGP) type ZTT_LAGP .
  methods _GET_NO_FREE_SUBLOCATION_LIST
    importing
      !I_T_LAGP type ZTT_LAGP
    returning
      value(E_T_TOOLS_SUBLOCATION) type ZTT_WM_TOOLS_SUBLOCATION .
  methods _GET_PARAM_LGBER_RANGE
    returning
      value(R_T_R_LGBER) type ZTT_R_LGBER .
  methods _GET_PARAM_LGTYP_RANGE
    returning
      value(R_T_R_LGTYP) type ZTT_R_LGTYP .
  methods _GET_PARAM_LPTYP_RANGE
    returning
      value(R_T_R_LPTYP) type ZTT_R_LPTYP .
  methods _GET_TLM_OO_WM_UTILS
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    returning
      value(R_OO_WM_UTILS) type ref to ZCL_UTILS_WM
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_TLM_PARAMS
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
      !I_TYPE type ZTIPOUTIL
      !I_CODE type ZCODIGOUTIL
      !I_ARBPL type ARBPL
    returning
      value(R_S_TLM_PARAMS) type TY_S_TLM_PARAMS
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_TOOL_ARBPL
    importing
      !I_CUOBJ type CUOBJ
    returning
      value(R_ARBPL) type ARBPL .
  methods _GET_TOOL_CODE
    importing
      !I_MATNR type MATNR optional
    returning
      value(R_CODE) type ZCODIGOUTIL .
  methods _GET_TOOL_CUOBJ
    importing
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
    returning
      value(R_CUOBJ) type CUOBJ .
  methods _GET_TOOL_LGPBE
    importing
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    returning
      value(R_LGPBE) type LGPBE .
  methods _GET_TOOL_MAKTX
    importing
      !I_MATNR type MATNR
    returning
      value(R_MAKTX) type MAKTX .
  methods _GET_TOOL_MTART
    importing
      !I_MATNR type MATNR
    returning
      value(R_MTART) type MTART .
  methods _GET_TOOL_TYPE
    importing
      !I_MATNR type MATNR optional
    returning
      value(R_TOOLTYPE) type ZTIPOUTIL .
  methods _GET_WM_BAPI_DATA
    importing
      !I_LGPLA type LGPLA
    exporting
      value(E_S_MLGN) type MLGN
      value(E_S_MLGT) type MLGT
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_WM_BAPI_EXTENSIONIN
    importing
      !I_LGPLA type LGPLA
      !I_ZLGPLAINI type ZLGPLAINI
    exporting
      !E_T_EXTENSIONIN type BAPIPAREX_T
      !E_T_EXTENSIONINX type ZBAPIPAREXX_T .
  methods _GET_WM_LGBER_W_DIALOG
    importing
      !I_T_TOOL_LOCATIONS_LGBER type ZTT_WM_TOOLS_LOCATION_LGBER
    returning
      value(R_S_TOOL_LOCATIONS_LGBER) type ZST_WM_TOOLS_LOCATION_LGBER
    raising
      ZCX_EXCEPTION .
  methods _GET_WM_LGPLA_W_DIALOG
    importing
      !I_T_TOOL_STGBIN type ZTT_WM_TOOLS_STGBIN
    returning
      value(R_S_TOOL_STGBIN) type ZST_WM_TOOLS_STGBIN
    raising
      ZCX_EXCEPTION .
  methods _GET_WM_LOCATION_LIST
    importing
      !I_T_R_LGTYP type ZTT_R_LGTYP optional
      !I_T_R_LPTYP type ZTT_R_LPTYP optional
    returning
      value(E_T_TOOLS_LOCATION_LGPLA) type ZTT_WM_TOOLS_LOCATION_LGPLA .
  methods _GET_WM_LOCATION_W_DIALOG
    importing
      !I_T_TOOL_LOCATIONS_LGPLA type ZTT_WM_TOOLS_LOCATION_LGPLA
    returning
      value(E_S_TOOL_LOCATIONS_LGPLA) type ZST_WM_TOOLS_LOCATION_LGPLA
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_WM_SUBLOCATION_W_DIALOG
    importing
      !I_S_TOOL_LOCATIONS type ZST_WM_TOOLS_LOCATION_LGPLA
    returning
      value(E_S_TOOL_SUBLOCATIONS) type ZST_WM_TOOLS_SUBLOCATION
    raising
      ZCX_WM_EXCEPTION .
  methods _GET_ZTLM0001_DATA
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    returning
      value(R_T_ZTLM001) type ZTLM0001 .
  methods _GET_ZTLM0002_DATA
    importing
      !I_WERKS type WERKS_D
      !I_TIPOUTIL type ZTIPOUTIL
      !I_LGNUM type LGNUM
      !I_LGTYP type LGTYP
      !I_CODIGO type ZCODIGOUTIL
    returning
      value(R_T_ZTLM002) type ZTLM0002 .
  methods _GET_PARAM_ZTLM0003_4_LGBER
    importing
      !I_LGBER type LGBER
    returning
      value(R_S_ZTLM0003) type ZTLM0003 .
  methods _GET_ZTLM0003_DATA
    importing
      !I_TYPE type ZTIPOUTIL
      !I_LGNUM type LGNUM
      !I_LGTYP type LGTYP
    returning
      value(R_T_ZTLM0003) type TY_T_ZTLM0003 .
  methods _GET_ZTMM0033_DATA
    importing
      !I_WERKS type WERKS_D
      !I_TIPOUTIL type ZTIPOUTIL
      !I_CODIGO type ZCODIGOUTIL
      !I_ARBPL type ARBPL
    returning
      value(R_S_ZTMM0033) type ZTMM0033 .
  methods _MAP_LAGP_2_LGPLA_RANGE
    importing
      !I_T_LAGP type ZTT_LAGP
    returning
      value(R_T_R_LGPLA) type ZTT_R_LGPLA .
  methods _READ_MATNR_DATA
    exporting
      !E_MARA type MARA
    raising
      ZCX_WM_EXCEPTION
      ZCX_EXCEPTION .
  methods _SET_CURRENT_BINDATA
    raising
      ZCX_EXCEPTION .
  methods _SET_LGTYP_4_TOOLS
    returning
      value(E_LGTYP) type LGTYP
    raising
      ZCX_WM_EXCEPTION .
  methods _SET_LPTYP_RANGE .
  methods _SET_MATNR_MM_DATA .
  methods _SET_MATNR_WM_DATA
    raising
      ZCX_WM_EXCEPTION
      ZCX_EXCEPTION .
  methods _SET_TLM_OO_WM_UTILS
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    raising
      ZCX_WM_EXCEPTION .
  methods _SET_TLM_PARAMS
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
      !I_TYPE type ZTIPOUTIL
      !I_CODE type ZCODIGOUTIL
      !I_ARBPL type ARBPL
    raising
      ZCX_WM_EXCEPTION .
  methods _SET_TOOL_ARBPL .
  methods _SET_TOOL_TYPE
    importing
      !I_MATNR type MATNR .
  methods _SET_TP_LOCATION .
  methods _UPDATE_LAGP_IN_BBDD
    importing
      !I_UPD_VALUE type BOOLEAN
      !I_T_LAGP type ZTT_LAGP .
  methods _UPDATE_LOCATION_CONF .
  methods _GET_LGBER_CAPACITY
    importing
      !I_LGBER type LGBER
    returning
      value(R_S_CAPACITY) type TY_S_CAPACITY .
  methods _CHECK_LGBER_MAX_MKAPV
    importing
      !I_LGBER type LGBER
    returning
      value(R_MAX_MKAPV) type BOOLEAN .
endclass. "ZCL_WM_TOOLS_LOCATION_MANAGER definition
class ZCL_WM_TOOLS_LOCATION_MANAGER implementation.
METHOD _adjust_rkapv_4_lagp.

****** --> V1
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: ls_lagp TYPE lagp.
*
***********************************************************************
** Lógica
***********************************************************************
*
** Para cada ubicación obtengo capacidades comprometidas
*
*    LOOP AT c_t_lagp INTO ls_lagp.
*
*      SELECT SUM( a~mkapv )
*        FROM mlgn AS a INNER JOIN mlgt AS b
*          ON a~lgnum EQ b~lgnum
*         AND a~matnr EQ b~matnr
*        INTO @DATA(lv_mkapv)
*       WHERE b~lgnum EQ @_lgnum
*         AND b~lgtyp EQ @_lgtyp
*         AND b~lgpla EQ @ls_lagp-lgpla
*         AND a~matnr NE @_matnr.
*
*      IF ( sy-subrc = 0 AND lv_mkapv IS NOT INITIAL ).
*
** Modifico capacidad restante
*
*        IF ( ls_lagp-lkapv - ls_lagp-rkapv NE lv_mkapv ).
*          ls_lagp-rkapv = ls_lagp-lkapv - lv_mkapv.
*          MODIFY c_t_lagp FROM ls_lagp.
*        ENDIF.
*
*      ENDIF.
*
*    ENDLOOP.
*
****** <-- V1

ENDMETHOD.
METHOD _check_bin_is_free. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** CHECK

  "Chequeo si ubicación está ocupada
  SELECT COUNT(*) UP TO 1 ROWS
    FROM lqua
   WHERE lgnum EQ me->_s_tool_data-lgnum
     AND lgpla EQ i_lgpla.

  IF ( sy-subrc NE 0 ).
    MOVE abap_true TO r_is_free.
  ENDIF.

ENDMETHOD.
METHOD _check_lgber_max_mkapv.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_lgber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** READ PARAM DATA

  r_max_mkapv = me->_get_param_ztlm0003_4_lgber( i_lgber = i_lgber )-max_mkapv.

ENDMETHOD.
METHOD _check_lgpla_4_tool. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  "Si es inicial devolvemos KO
  CHECK i_lgpla IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE AND GET CHECK DATA

***** CHECK LGPLA DATA EXISTS 4 TOOL LETTER

  SELECT SINGLE *
    FROM lagp
    INTO @DATA(ls_lagp)
   WHERE lgnum EQ @me->_s_tool_data-lgnum
     AND lgtyp EQ @me->_s_tool_data-lgtyp
     AND lgpla EQ @i_lgpla.

  IF ( sy-subrc EQ 0 ).
    r_is_ok = me->_check_lgpla_data_4_help( i_lagp = ls_lagp ).
  ENDIF.

ENDMETHOD.
METHOD _check_lgpla_break.

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_char_position TYPE i VALUE 9.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MASK

  CHECK i_break_mask IS NOT INITIAL.

***** LGPLA

  CHECK i_lgpla IS NOT INITIAL.

***** LGPLA

  CHECK i_lgpla_sample IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** CHECK

***** POS 10

  DO 10 TIMES.

    IF ( i_break_mask+lv_char_position(1) EQ 'B' ).
      IF ( i_lgpla+lv_char_position(1) NE i_lgpla_sample+lv_char_position(1) ).
        MOVE abap_true TO r_break.
        EXIT.
      ENDIF.
    ENDIF.

    lv_char_position = lv_char_position - 1.

  ENDDO.

ENDMETHOD.
METHOD _check_lgpla_data_4_help.

**********************************************************************
* Parámetros locales
**********************************************************************

****** STRUCTURES

  DATA: ls_ztlm0003 TYPE ztlm0003.

****** TABLES

  DATA: lt_r_lgber   TYPE ztt_r_lgber,
        lt_r_lgpla   TYPE ztt_r_lgpla,
        lt_lagp_book TYPE ztt_lagp.


**********************************************************************
* Validaciones
**********************************************************************

***** IMPORT DATA

**** LAGP

  CHECK i_lagp IS NOT INITIAL AND i_lagp-lgber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** GET LGBER PARAMS

  ls_ztlm0003 = me->_get_param_ztlm0003_4_lgber( i_lgber = i_lagp-lgber ).
  CHECK ls_ztlm0003 IS NOT INITIAL AND ls_ztlm0003-lgber IS NOT INITIAL.

****** CHECKS

***** SKZUE - Bloqeuo entradas

  "Chequeo si está bloqueada para entradas
  CHECK i_lagp-skzue EQ abap_false.

***** SKZUA - Bloqeuo salidas

  "Chequeo si está bloqueada para entradas
  CHECK i_lagp-skzua EQ abap_false.

***** KZLER - Ubicación vacía

  "Solo si capacidad no es maxima.
  IF ( ls_ztlm0003-max_mkapv = abap_false ).
    "Chequeo si ubicación está libre
    CHECK i_lagp-kzler EQ abap_true.
  ENDIF.


***** LKAPV

**** HAS CAPACITY

  CHECK i_lagp-rkapv GE me->_s_tool_data-mkapv.

**** ONLY IF MAX_LKAPV

  IF ( ls_ztlm0003-max_mkapv EQ abap_true ).
    CHECK i_lagp-lkapv EQ 99999999.
  ENDIF.

**** LAGP FREE (NOT MAX_MKAPV)

  IF ( ls_ztlm0003-max_mkapv EQ abap_false ).

    CHECK me->_check_bin_is_free( i_lgpla = i_lagp-lgpla ) EQ abap_true.

**** NOT BOOKED

    APPEND VALUE #( sign = 'I' option = 'EQ' stge_bin_low = i_lagp-lgpla ) TO lt_r_lgpla.
    APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = i_lagp-lgber ) TO lt_r_lgber.

    lt_lagp_book = me->_get_mm_wm_booked_bins( i_t_r_lgber = lt_r_lgber i_t_r_lgpla = lt_r_lgpla ).

    READ TABLE lt_lagp_book TRANSPORTING NO FIELDS WITH KEY lgpla = i_lagp-lgpla.
    CHECK sy-subrc NE 0.

  ENDIF.

****** PREPARE RETURN

  MOVE abap_true TO r_isok.

ENDMETHOD.
METHOD _check_matnr. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_mlgn_check TYPE boolean,
        lv_mlgt_check TYPE boolean.

****** TABLES

  DATA: lt_r_lgtyp    TYPE ztt_r_lgtyp.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MATNR

  CHECK i_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** LOGIC CHECKS

***** EXISTS AND IS ZCLI OR ZTRO

  SELECT COUNT(*)
    FROM mara
   WHERE matnr EQ i_matnr
     AND mbrsh IN ('M', 'Z')
     AND mtart IN (zcl_wm_tools_location_manager=>_c_mtart_zcli, zcl_wm_tools_location_manager=>_c_mtart_ztro).

  CHECK sy-subrc EQ 0.

***** IS WM EXTENDED

  APPEND VALUE #( sign = 'I' option = 'EQ' stge_type_low  = me->_s_tool_data-lgtyp ) TO lt_r_lgtyp.

  me->_io_wm_utils->check_matnr_is_extended_4_wm(
    EXPORTING
      i_matnr     = i_matnr    " Número de material
      i_t_r_lgtyp = lt_r_lgtyp " Tabla de rangos para tipo de almacén
    IMPORTING
      e_mlgn_data = lv_mlgn_check    " Variable booleana (X=verdadero, -=falso, space=descon.)
      e_mlgt_data = lv_mlgt_check    " Variable booleana (X=verdadero, -=falso, space=descon.)
  ).

  CHECK lv_mlgn_check IS NOT INITIAL AND lv_mlgt_check IS NOT INITIAL.

****** SET RESULT

  "Si ha llegado hasta aquí es OK.
  MOVE abap_true TO r_isok.

ENDMETHOD.
METHOD _check_mkapv.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lv_string  TYPE string,
        lv_entero  TYPE string,
        lv_decimal TYPE string.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MKAPV

  CHECK i_mkapv IS NOT INITIAL.
  CHECK i_mkapv GT 0.

**********************************************************************
* Lógica
**********************************************************************

****** NUMERIC?

  MOVE i_mkapv TO lv_string.
  REPLACE ',' IN lv_string WITH '.'.
  SPLIT lv_string AT '.' INTO lv_entero lv_decimal.

  IF ( _io_wm_utils->check_if_string_is_numeric( i_value = lv_entero ) = abap_true ).
    e_is_ok = abap_true.
  ELSE.
    e_is_ok = abap_false.
  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lv_string  TYPE string,
*        lv_entero  TYPE string,
*        lv_decimal TYPE string.
*
*
***********************************************************************
** Lógica
***********************************************************************
*
**** CHECKS
*
*  IF ( i_mkapv IS INITIAL OR i_mkapv LE 0 ).
*
*    e_is_ok = abap_false.
*
*  ELSE.
*
*    MOVE i_mkapv TO lv_string.
*    REPLACE ',' IN lv_string WITH '.'.
*    SPLIT lv_string AT '.' INTO lv_entero lv_decimal.
*
*    IF ( _io_wm_utils->check_if_string_is_numeric( i_value = lv_entero ) = abap_true ).
*      e_is_ok = abap_true.
*    ELSE.
*      e_is_ok = abap_false.
*    ENDIF.
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
  METHOD _check_sublocation.

****** --> V1
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: lv_subloc_str  TYPE string,
*          lv_subloc_vini TYPE i,
*          lv_subloc_vfin TYPE i,
*          lv_subloc_ini  TYPE i,
*          lv_subloc_fin  TYPE i.
*
*    DATA: ls_lagp TYPE lagp.
*
*    DATA: lt_subloc_free TYPE ztt_wm_tools_sublocation,
*          ls_subloc_free TYPE zst_wm_tools_sublocation.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*** LGPLA
*
*    IF ( i_lgpla IS INITIAL ).
*      e_is_ok = abap_false.
*      EXIT.
*    ENDIF.
*
*** ZSUBLGPLAINI
*
** NOT INITIAL
*
*    IF ( i_zsub_lgpla IS INITIAL ).
*      e_is_ok = abap_false.
*      EXIT.
*    ENDIF.
*
** NUMERIC
*
*    CLEAR: lv_subloc_str.
*    MOVE i_zsub_lgpla TO lv_subloc_str.
*    CONDENSE lv_subloc_str NO-GAPS.
*    IF ( _io_wm_utils->check_if_string_is_numeric( i_value = lv_subloc_str ) EQ abap_false ).
*      e_is_ok = abap_false.
*    ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** CHECKS
*
*** IN RANGE
*
*    SELECT SINGLE *
*      FROM lagp
*      INTO CORRESPONDING FIELDS OF ls_lagp
*     WHERE lgnum EQ me->_lgnum
*       AND lgtyp EQ me->_lgtyp
*       AND lgpla EQ i_lgpla.
*
*    IF ( sy-subrc EQ 0 AND ls_lagp-verif IS NOT INITIAL ).
*
*      CLEAR: lv_subloc_str.
*      MOVE ls_lagp-verif TO lv_subloc_str.
*      CONDENSE lv_subloc_str NO-GAPS.
*      IF ( _io_wm_utils->check_if_string_is_numeric( i_value = lv_subloc_str ) EQ abap_true ).
*
*        MOVE ls_lagp-verif TO lv_subloc_vini.
*        MOVE i_zsub_lgpla  TO lv_subloc_ini.
*
*        lv_subloc_vfin = lv_subloc_vini + ls_lagp-lkapv - 1.
*        lv_subloc_fin  = lv_subloc_ini + me->_mkapv - 1.
*
*        IF ( lv_subloc_ini GE lv_subloc_vini AND lv_subloc_ini LE lv_subloc_vfin ).
*
*** FREE SUBLOC
*
*          me->_get_free_subloc_4_lgpla(
*            EXPORTING
*              i_lagp                 = ls_lagp    " Ubicaciones
*            IMPORTING
*              e_wm_tools_sublocation = lt_subloc_free    " Tabla para estructura ZST_WM_TOOLS_SUBLOCATION
*            EXCEPTIONS
*              no_valid_iparams       = 1
*              no_lagp_verif          = 2
*              no_lagp_lkapv          = 3
*              error_verif            = 4
*              error_zlgpla           = 5
*              OTHERS                 = 6
*          ).
*          IF ( sy-subrc EQ 0 ).
*
*            CLEAR: lv_subloc_str.
*            MOVE lv_subloc_ini TO lv_subloc_str.
*            CONDENSE lv_subloc_str NO-GAPS.
*            READ TABLE lt_subloc_free INTO ls_subloc_free WITH KEY lgnum = ls_lagp-lgnum lgtyp = ls_lagp-lgtyp lgpla = ls_lagp-lgpla zlgplaini = lv_subloc_str.
*
*            IF ( sy-subrc EQ 0 ).
*
*              CLEAR: lv_subloc_vini, lv_subloc_vfin.
*              MOVE ls_subloc_free-zlgplaini TO lv_subloc_vini.
*              MOVE ls_subloc_free-zlgplafin TO lv_subloc_vfin.
*              IF ( lv_subloc_ini EQ lv_subloc_vini AND lv_subloc_fin EQ lv_subloc_vfin ).
*
*                e_is_ok = abap_true.
*                EXIT.
*
*              ELSE.
*
*                e_is_ok = abap_false.
*                EXIT.
*
*              ENDIF.
*
*            ELSE.
*
*              e_is_ok = abap_false.
*              EXIT.
*
*            ENDIF.
*
*          ELSE.
*
*            e_is_ok = abap_false.
*            EXIT.
*
*          ENDIF.
*
*        ELSE.
*
*          e_is_ok = abap_false.
*          EXIT.
*
*        ENDIF.
*
*      ELSE.
*
*        e_is_ok = abap_false.
*        EXIT.
*
*      ENDIF.
*
*    ELSE.
*
*      e_is_ok = abap_false.
*      EXIT.
*
*    ENDIF.
*
****** <-- V1

ENDMETHOD.
  METHOD _check_verif.

****** --> V1
*
*    DATA: lv_string TYPE string.
*
*    IF ( i_verif IS NOT INITIAL ).
*
*      MOVE i_verif TO lv_string.
*      CONDENSE lv_string NO-GAPS.
*      IF ( _io_wm_utils->check_if_string_is_numeric( i_value = lv_string ) ).
*        e_is_ok = abap_true.
*      ELSE.
*        e_is_ok = abap_false.
*      ENDIF.
*
*    ELSE.
*      e_is_ok = abap_false.
*    ENDIF.
*
****** <-- V1

  ENDMETHOD.
METHOD _CREATE_OT_4_TOOL. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** STRUCTURES

  DATA: ls_ot_data TYPE zst_wm_utils_ot_creation.

****** TABLES

  DATA: lt_r_lgtyp TYPE ztt_r_lgtyp,
        lt_r_lgpla TYPE ztt_r_lgpla,
        lt_r_matnr TYPE ztt_r_matnr,
        lt_lqua    TYPE ztt_lqua,
        lt_ot_data TYPE ztt_wm_utils_ot_creation.

**********************************************************************
* Validaciones
**********************************************************************

******

  CHECK lines( me->_s_tool_data-_t_th_lgpla ) GT 0.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  APPEND VALUE #( sign = 'I' option = 'EQ' stge_type_low = me->_s_tool_data-lgtyp ) TO lt_r_lgtyp.
  APPEND VALUE #( sign = 'I' option = 'EQ' material_low = me->_matnr ) TO lt_r_matnr.

  lt_lqua = me->_io_wm_utils->get_wm_lqua_data( i_t_r_lgtyp = lt_r_lgtyp i_t_r_lgpla = lt_r_lgpla i_t_r_matnr = lt_r_matnr ).

  DELETE lt_lqua WHERE gesme LE 0.

****** CREATE OT

  IF ( lines( lt_lqua ) GT 0 ).

    READ TABLE lt_lqua INTO DATA(ls_lqua) INDEX 1.

    MOVE ls_lqua-lqnum TO ls_ot_data-lqnum_origen.
    MOVE ls_lqua-gesme TO ls_ot_data-anfme.
    MOVE ls_lqua-meins TO ls_ot_data-altme.
    MOVE me->_s_tool_data-lgtyp TO ls_ot_data-nltyp.
    ls_ot_data-nlpla = me->_s_tool_data-_t_th_lgpla[ 1 ]-lgpla.
    ls_ot_data-nlber = me->_s_tool_data-_t_th_lgpla[ 1 ]-lgber.
    APPEND ls_ot_data TO lt_ot_data.

    me->_io_wm_utils->create_to_multiple_4_lqnums( i_bwlvs = '999' i_updtask = abap_true i_t_ot_data = lt_ot_data ).

  ENDIF.

ENDMETHOD.
METHOD _get_bin_list_nrows.

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_lgpla TYPE lgpla,
        lv_rows  TYPE i.

****** TABLES

  DATA: lt_r_lgber TYPE ztt_r_lgber.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** LGPLA

  CHECK i_lgpla IS NOT INITIAL.

***** ROWS

  CHECK i_rows GT 0.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** MOVE DATA TO WORK DATA

**** ROWS

  MOVE i_rows TO lv_rows.

**** LGBER RANGE

  MOVE-CORRESPONDING i_t_r_lgber[] TO lt_r_lgber[].

***** CONVERSION

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = i_lgpla
    IMPORTING
      output = lv_lgpla.

***** GET LGBER

  SELECT SINGLE lgber
    FROM lagp
    INTO @DATA(lv_lgber)
   WHERE lgnum EQ @me->_s_tool_data-lgnum
     AND lgtyp EQ @me->_s_tool_data-lgtyp
     AND lgpla EQ @lv_lgpla.

  CHECK lv_lgber IS NOT INITIAL.

  IF ( lv_lgber NOT IN lt_r_lgber OR lines( lt_r_lgber ) LE 0 ).
    CLEAR lt_r_lgber[].
    APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = lv_lgber ) TO lt_r_lgber.
  ENDIF.

***** TRANSFORM ROWS IF MAX_MKAPV

  IF ( me->_get_param_ztlm0003_4_lgber( i_lgber = lv_lgber )-max_mkapv EQ abap_true ).
    lv_rows = 1. "En MAX_MKAPV solo se devuelve una ubicación
  ENDIF.

****** SELECT DATA

  SELECT *
    FROM lagp
    INTO CORRESPONDING FIELDS OF TABLE r_t_lagp UP TO lv_rows ROWS
   WHERE lgnum EQ me->_s_tool_data-lgnum
     AND lgtyp EQ me->_s_tool_data-lgtyp
     AND lgber IN lt_r_lgber
     AND lgpla GE lv_lgpla
   ORDER BY lgnum lgtyp lgber lgpla ASCENDING.

ENDMETHOD.
METHOD _get_current_re_bindata.

**********************************************************************
* Parámetros locales
**********************************************************************

****** TABLES

  DATA: lt_lagp TYPE ztt_lagp.

****** STRUCTURES

  DATA: ls_lgpla TYPE ty_s_lgpla.

****** VARIABLES

  DATA: lv_rows TYPE i.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

***** THEORIC BIN DATA

**** GET WM DATA

  SELECT SINGLE lgpla
    FROM lqua
    INTO @DATA(lv_lgpla)
   WHERE lgnum EQ @me->_s_tool_data-lgnum
     AND matnr EQ @me->_matnr
     AND werks EQ @me->_s_tool_data-werks.

  IF ( lv_lgpla IS NOT INITIAL AND ( me->_s_tool_data-mkapv IS NOT INITIAL OR me->_s_tool_data-mkapv GT 0 ) ).

    MOVE me->_s_tool_data-mkapv TO lv_rows.

    lt_lagp = me->_get_bin_list_nrows( i_lgpla = lv_lgpla i_rows = lv_rows ).

    LOOP AT lt_lagp INTO DATA(ls_lagp).

      MOVE-CORRESPONDING ls_lagp TO ls_lgpla.

      IF ( ls_lgpla-lgpla EQ lv_lgpla ).
        MOVE abap_true TO ls_lgpla-fxbin.
      ELSE.
        MOVE abap_false TO ls_lgpla-fxbin.
      ENDIF.

      APPEND ls_lgpla TO r_t_lgpla.

    ENDLOOP.

  ENDIF.

ENDMETHOD.
METHOD _get_current_th_bindata.

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

***** EXCEPTIONS

  DATA: lo_exception TYPE REF TO zcx_exception.

****** TABLES

  DATA: lt_lagp TYPE ztt_lagp,
        lt_r_lgber TYPE ztt_r_lgber.

****** STRUCTURES

  DATA: ls_mlgn TYPE mlgn,
        ls_mlgt TYPE mlgt,
        ls_lgpla TYPE ty_s_lgpla.

****** VARIABLES

  DATA: lv_rows TYPE i.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

***** THEORIC BIN DATA

**** GET WM DATA

  TRY .

    _io_wm_utils->read_matnr_wm_data(
      EXPORTING
        i_matnr          = me->_matnr    " Número de material
        i_lgtyp          = me->_s_tool_data-lgtyp    " Tipo almacén
      IMPORTING
        e_mlgn           = ls_mlgn    " Datos de material por número de almacén
        e_mlgt           = ls_mlgt    " Datos de material por tipo de almacén
    ).

  CATCH zcx_wm_exception INTO lo_exception.
    RAISE EXCEPTION TYPE zcx_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
  ENDTRY.


  IF ( ls_mlgt-lgpla IS NOT INITIAL AND ( me->_s_tool_data-mkapv IS NOT INITIAL OR me->_s_tool_data-mkapv GT 0 ) ).

**** GET THEORIC BINS

    SELECT SINGLE lgber
      FROM lagp
      INTO @DATA(lv_lgber)
     WHERE lgnum EQ @me->_s_tool_data-lgnum
       AND lgtyp EQ @me->_s_tool_data-lgtyp
       AND lgpla EQ @ls_mlgt-lgpla.

    APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = lv_lgber ) TO lt_r_lgber.

    MOVE me->_s_tool_data-mkapv TO lv_rows.

    lt_lagp = me->_get_bin_list_nrows( i_lgpla = ls_mlgt-lgpla i_rows = lv_rows i_t_r_lgber = lt_r_lgber ).

    LOOP AT lt_lagp INTO DATA(ls_lagp).

      MOVE-CORRESPONDING ls_lagp TO ls_lgpla.

      IF ( ls_lagp-lgpla EQ ls_mlgt-lgpla ).
        MOVE abap_true TO ls_lgpla-fxbin.
      ELSE.
        MOVE abap_false TO ls_lgpla-fxbin.
      ENDIF.

      APPEND ls_lgpla TO r_t_lgpla.

    ENDLOOP.

  ENDIF.

ENDMETHOD.
  METHOD _get_free_subloc_4_lgpla.

****** --> V1
*
*
***********************************************************************
** Tipos locales
***********************************************************************
*
*    TYPES: BEGIN OF ty_r_subloc,
*             sign       TYPE bapisign,
*             option     TYPE bapioption,
*             lgpla_low  TYPE i,
*             lgpla_high TYPE i,
*           END OF ty_r_subloc.
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: lt_lagp                     TYPE TABLE OF lagp,
*
*          ls_r_subloc                 TYPE ty_r_subloc,
*          lt_r_subloc                 TYPE TABLE OF ty_r_subloc,
*
*          lv_cont_1                   TYPE i,
*          lv_cont_2                   TYPE i,
*
*          lv_zlgpl_min                TYPE i,
*          lv_zlgpl_cal                TYPE i,
*          lv_zlgpl_max                TYPE i,
*          lv_zlgpl_ini                TYPE i,
*          lv_zlgpl_fin                TYPE i,
*          lv_verif_min                TYPE i,
*          lv_verif_max                TYPE i,
*
*          lv_lgpla_min                TYPE lgpla,
*          lv_lgpla_cal                TYPE lgpla,
*          lv_lgpla_max                TYPE lgpla,
*
*          lt_wm_tools_sublocation_in  TYPE ztt_wm_tools_sublocation,
*          ls_wm_tools_sublocation_in  TYPE zst_wm_tools_sublocation,
*          lt_wm_tools_sublocation_out TYPE ztt_wm_tools_sublocation,
*          ls_wm_tools_sublocation_out TYPE zst_wm_tools_sublocation.
*
***********************************************************************
** Chequeos iniciales
***********************************************************************
*
*** Parámetros de entrada rellenos
*
*    IF ( i_lagp-lgnum IS INITIAL OR i_lagp-lgtyp IS INITIAL OR i_lagp-lgpla IS INITIAL ).
*      RAISE no_valid_iparams.
*    ENDIF.
*
**** Gestión de sububicaciones
*
*    IF ( i_lagp-verif IS NOT INITIAL ).
*
*      IF ( me->_check_verif( i_verif = i_lagp-verif ) = abap_false ).
*        RAISE no_lagp_verif.
*      ENDIF.
*
*    ELSE.
*
*      RAISE no_lagp_verif.
*
*    ENDIF.
*
**** Capacidad
*
*    IF ( i_lagp-lkapv IS INITIAL ).
*      RAISE no_lagp_lkapv.
*    ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** Ubicaciones ocupadas
*
*    APPEND i_lagp TO lt_lagp.
*
*    "Obtengo para todas las ubicaciones, todos los datos de sububicación, capacidades, etc.
*    lt_wm_tools_sublocation_in = me->_get_no_free_sublocation_list( i_t_lagp = lt_lagp ).
*
*    "Borro resultados de materiales con ZLGPLAINI vacío (materiales no ubicados con lógica)
*    DELETE lt_wm_tools_sublocation_in WHERE verif_ini IS INITIAL OR zlgplaini IS INITIAL.
*
*    "Ordenamos datos de ubicaciones y materiales para extraer lista de sububicaciones vacías
*    SORT lt_wm_tools_sublocation_in BY lgnum lgtyp lgpla zlgplaini.
*
**** Ubicaciones vacías
*
*    "Rellenamos datos genéricos.
*    MOVE i_lagp-lgnum TO ls_wm_tools_sublocation_out-lgnum.
*    MOVE i_lagp-lgtyp TO ls_wm_tools_sublocation_out-lgtyp.
*    MOVE i_lagp-lgpla TO ls_wm_tools_sublocation_out-lgpla.
*    MOVE i_lagp-lkapv TO ls_wm_tools_sublocation_out-lkapv.
*    MOVE i_lagp-rkapv TO ls_wm_tools_sublocation_out-rkapv.
*    MOVE _mkapv       TO ls_wm_tools_sublocation_out-mkapv.
*
*
*** Sububicación inicial y final de ubicación WM
*
** Sububicación inicial
*
*    MOVE i_lagp-verif TO ls_wm_tools_sublocation_out-verif_ini.
*    CONDENSE ls_wm_tools_sublocation_out-verif_ini NO-GAPS.
*
*    CALL FUNCTION 'CONVERT_STRING_TO_INTEGER'
*      EXPORTING
*        p_string      = ls_wm_tools_sublocation_out-verif_ini
*      IMPORTING
*        p_int         = lv_verif_min
*      EXCEPTIONS
*        overflow      = 1
*        invalid_chars = 2
*        OTHERS        = 3.
*
*    IF ( sy-subrc <> 0 OR lv_verif_min EQ 0 ).
*      RAISE error_verif.
*    ENDIF.
*
** Sububicación final
*
*    TRY.
*
*        ls_wm_tools_sublocation_out-verif_fin = ls_wm_tools_sublocation_out-verif_ini + ls_wm_tools_sublocation_out-lkapv - 1.
*        CONDENSE ls_wm_tools_sublocation_out-verif_fin NO-GAPS.
*
*        CALL FUNCTION 'CONVERT_STRING_TO_INTEGER'
*          EXPORTING
*            p_string      = ls_wm_tools_sublocation_out-verif_fin
*          IMPORTING
*            p_int         = lv_verif_max
*          EXCEPTIONS
*            overflow      = 1
*            invalid_chars = 2
*            OTHERS        = 3.
*
*        IF ( sy-subrc <> 0 OR lv_verif_max EQ 0 ).
*          RAISE error_verif.
*        ENDIF.
*
*      CATCH cx_sy_conversion_no_number.
*        RAISE no_lagp_verif.
*    ENDTRY.
*
*** Sububicación inicial MATNR MLGT-ZLGPLAINI
*
** Sububicación final
*
*    "Rellenamos sububicación inicial = verif
*    CLEAR: lv_zlgpl_min.
*    lv_zlgpl_min = lv_verif_min.
*
** Rango de sububicaciones ocupadas
*
*    "Construimos rango de sububicaciones ocupadas
*    LOOP AT lt_wm_tools_sublocation_in INTO ls_wm_tools_sublocation_in.
*
*      CLEAR: ls_r_subloc.
*      ls_r_subloc-sign        = 'I'.
*      ls_r_subloc-option      = 'BT'.
*
*      CALL FUNCTION 'CONVERT_STRING_TO_INTEGER'
*        EXPORTING
*          p_string      = ls_wm_tools_sublocation_in-zlgplaini
*        IMPORTING
*          p_int         = ls_r_subloc-lgpla_low
*        EXCEPTIONS
*          overflow      = 1
*          invalid_chars = 2
*          OTHERS        = 3.
*
*      IF ( sy-subrc <> 0 OR ls_r_subloc-lgpla_low EQ 0 ).
*        CONTINUE.
*      ENDIF.
*
*      CALL FUNCTION 'CONVERT_STRING_TO_INTEGER'
*        EXPORTING
*          p_string      = ls_wm_tools_sublocation_in-zlgplafin
*        IMPORTING
*          p_int         = ls_r_subloc-lgpla_high
*        EXCEPTIONS
*          overflow      = 1
*          invalid_chars = 2
*          OTHERS        = 3.
*
*      IF ( sy-subrc <> 0 OR ls_r_subloc-lgpla_high EQ 0 ).
*        CONTINUE.
*      ENDIF.
*
*      APPEND ls_r_subloc TO lt_r_subloc.
*
*    ENDLOOP.
*
*    "Si no tenemos sububicaciones ocupadas, excluimos todos los valores fuera de nuestro rango de sububicaciones.
*    IF ( lines( lt_r_subloc ) LE 0 ).
*
*      CLEAR: ls_r_subloc.
*      ls_r_subloc-sign        = 'E'.
*      ls_r_subloc-option      = 'BT'.
*      ls_r_subloc-lgpla_low   = lv_verif_min.
*      ls_r_subloc-lgpla_high  = lv_verif_max.
*      APPEND ls_r_subloc TO lt_r_subloc.
*
*    ENDIF.
*
*    "Calculamos número máximo de ubicaciones a incluir
*    DATA(lv_times) = i_lagp-lkapv.
*    "Chequeamos que no sea mayor de 500 para evitar colapsos de memoria
*    CHECK lv_times GE 0 AND lv_times LE 5000. "FCARDONA Aumentamos ya que ahora no debe darse.
*
*    "Inicio contadores
*    " - Contador 1 --> contador de loop.
*    " - Contador 2 --> contador de sububicaciones libres contínuas
*    lv_cont_1 = lv_cont_2 = 0.
*
*    "Construimos tabla de sububicaciones vacías.
*    DO lv_times TIMES.
*
*      "Calculo sububicación actual
*      lv_zlgpl_cal = lv_verif_min + lv_cont_1.
*
*      "Comprobamos si sububicación actual está en rango de ocupadas
*      IF ( lv_zlgpl_cal IN lt_r_subloc ).  "Está en rango de ocupadas.
*
*        "Reinicio contador de capacidad libre y sububicación inicial
*        lv_cont_2 = 0.
*        CLEAR lv_zlgpl_ini.
*
*      ELSE. "No está en rango de ocupadas
*
*        "Aumento contador de capacidad libre contínua
*        lv_cont_2 = lv_cont_2 + 1.
*
*        "Compruebo si contador de capacidad libre contínua es igual a capacidad a ocupar
*        IF ( lv_cont_2 = ls_wm_tools_sublocation_out-mkapv ). "Son iguales
*
*          "Compruebo si sububicación inicial se ha rellenado ya (caso en que mkapv sea > 0)
*          IF ( lv_zlgpl_ini EQ 0 ). "Es inicial
*
*            "Relleno sububicación inicial con calculada ya que inicial y final es la misma
*            lv_zlgpl_ini = lv_zlgpl_cal.
*
*          ENDIF.
*
*          "Relleno sububicación final
*          lv_zlgpl_fin = lv_zlgpl_cal.
*
*          "Compruebo sububicación final no sea mayor a sububicación máxima
*          IF ( lv_zlgpl_fin LE lv_verif_max ). "menor o igual
*
*            MOVE lv_zlgpl_ini TO ls_wm_tools_sublocation_out-zlgplaini.
*            CONDENSE ls_wm_tools_sublocation_out-zlgplaini NO-GAPS.
*
*            MOVE lv_zlgpl_fin TO ls_wm_tools_sublocation_out-zlgplafin.
*            CONDENSE ls_wm_tools_sublocation_out-zlgplafin NO-GAPS.
*
*            "Añadimos registro a sububicaciones vacías.
*            APPEND ls_wm_tools_sublocation_out TO lt_wm_tools_sublocation_out.
*
*            "modificamos sububicación inicial y contador de capacidades continuas para obtener siguiente sububicación posible.
*            lv_zlgpl_ini = lv_zlgpl_ini + 1.
*
*            lv_cont_2 = lv_cont_2 - 1.
*
*          ELSE. "Es superior
*
*            "Salimos, ya no hay más sububicaciones
*            EXIT.
*
*          ENDIF.
*
*        ELSE. "Son diferentes
*
*          "Comprobamos contador de capacidades contínuas
*          IF ( lv_cont_2 LE 1 ). "Si es cero o 1 seteamos sububicación inicial
*
*            lv_zlgpl_ini = lv_zlgpl_cal.
*
*          ENDIF.
*
*        ENDIF.
*
*      ENDIF.
*
*      "Aumentamos contador de loop
*      lv_cont_1 = lv_cont_1 + 1.
*
*    ENDDO.
*
*    "Movemos los registros a la tabla de salida
*    MOVE-CORRESPONDING lt_wm_tools_sublocation_out TO e_wm_tools_sublocation.
*
*
****** <-- V1

  ENDMETHOD.
METHOD _get_lbert_4_lgber.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** LGBER

  CHECK i_lgber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** SELECT DATA

  SELECT SINGLE lbert
    FROM t302t
    INTO @r_lbert
   WHERE spras EQ 'S'
     AND lgnum EQ @me->_s_tool_data-lgnum
     AND lgtyp EQ @me->_s_tool_data-lgtyp
     AND lgber EQ @i_lgber.

ENDMETHOD.
METHOD _get_lgber_capacity. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_lptyp TYPE lvs_lptyp.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_lgber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  lv_lptyp = me->_get_param_ztlm0003_4_lgber( i_lgber = i_lgber )-lptyp.

  IF ( me->_get_param_ztlm0003_4_lgber( i_lgber = i_lgber )-max_mkapv EQ abap_true ).

****** GET DATA MAX_MKAPV

***** LKAPV AND RKAPV

    SELECT SINGLE lkapv, rkapv
      FROM lagp
      INTO ( @r_s_capacity-lkapv, @r_s_capacity-rkapv )
     WHERE lgnum EQ @me->_s_tool_data-lgnum
       AND lgtyp EQ @me->_s_tool_data-lgtyp
       AND lgber EQ @i_lgber
       AND lptyp EQ @lv_lptyp
       AND lkapv GE 99999999.

  ELSE.

***** LKAPV

    SELECT COUNT(*)
      FROM lagp
      INTO @r_s_capacity-lkapv
     WHERE lgnum EQ @me->_s_tool_data-lgnum
       AND lgtyp EQ @me->_s_tool_data-lgtyp
       AND lgber EQ @i_lgber
       AND lptyp EQ @lv_lptyp.

***** RKAPV

    SELECT COUNT(*)
      FROM lagp
      INTO @r_s_capacity-rkapv
     WHERE lgnum EQ @me->_s_tool_data-lgnum
       AND lgtyp EQ @me->_s_tool_data-lgtyp
       AND lgber EQ @i_lgber
       AND lptyp EQ @lv_lptyp
       AND verif EQ @space
       AND skzue EQ @abap_false
       AND skzua EQ @abap_false
       AND anzqu EQ 0
       AND kzler EQ @abap_true.

  ENDIF.

ENDMETHOD.
METHOD _get_lgber_data_4_help. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_lgber_4_help TYPE zst_wm_tools_location_lgber.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  LOOP AT me->_s_tlm_params-t_ztlm0003 INTO DATA(ls_ztlm0003).

    CLEAR: ls_lgber_4_help.

    ls_lgber_4_help = me->_get_lgber_data_4_help_single( i_lgber = ls_ztlm0003-lgber ).

    IF ( ls_lgber_4_help IS NOT INITIAL ).
      APPEND ls_lgber_4_help TO r_t_lgber_4_help.
    ENDIF.

  ENDLOOP.

ENDMETHOD.
METHOD _get_lgber_data_4_help_single. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_count TYPE i.

****** STRUCTURES

  DATA: ls_capacity TYPE ty_s_capacity.

****** TABLES

  DATA: lt_lagp      TYPE ztt_lagp,
        lt_lagp_book TYPE ztt_lagp,
        lt_r_lgpla   TYPE ztt_r_lgpla,
        lt_r_lgtyp   TYPE ztt_r_lgtyp,
        lt_r_lgber   TYPE ztt_r_lgber,
        lt_r_lptyp   TYPE ztt_r_lptyp.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** LGBER

**** IS NOT INITIAL

  IF ( i_lgber IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = me->_c_msg_label ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** GET LGPLA 4 LGBER

***** PREPARE DATA

**** LGTYP RANGE

  APPEND VALUE #( sign = 'I' option = 'EQ' stge_type_low = me->_s_tool_data-lgtyp ) TO lt_r_lgtyp.

**** LGBER RANGE

  APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = i_lgber ) TO lt_r_lgber.

**** LPTYP RANGE

  lt_r_lptyp = me->_get_param_lptyp_range( ).

***** GET/SET DATA

**** SET LGBER

  r_s_lgber_4_help-lgber = i_lgber.

**** GET/SET LBERT

  r_s_lgber_4_help-lbert = me->_get_lbert_4_lgber( i_lgber = i_lgber ).

**** GET/SET LKAPV

  READ TABLE me->_s_tlm_params-t_ztlm0003 INTO DATA(ls_ztlm0003) WITH KEY ztipoutil = me->_get_tool_type( i_matnr = me->_matnr ) lgnum = me->_s_tool_data-lgnum lgtyp = me->_s_tool_data-lgtyp lgber = i_lgber.

  ls_capacity = me->_get_lgber_capacity( i_lgber = i_lgber ).

  r_s_lgber_4_help-lkapv = ls_capacity-lkapv.
  r_s_lgber_4_help-rkapv = ls_capacity-rkapv.

ENDMETHOD.
METHOD _get_lgpla_data_4_help. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_message TYPE scx_attrname,
        lv_lfdnr   TYPE lfdnr.

****** STRUCTURES

  DATA: "ls_r_lgber  TYPE zst_r_lgber,
*        ls_wm_lgber TYPE zst_wm_tools_location_lgber,
    ls_lagp         TYPE lagp,
    ls_lagp_help    TYPE zst_wm_tools_stgbin,
    ls_lagp_help_i1 TYPE zst_wm_tools_stgbin,
    ls_lagp_help_in TYPE zst_wm_tools_stgbin,
    ls_r_lgpla      TYPE bapi1172_lgpla_range,
    ls_t343_data    TYPE ty_s_t343_data,
    ls_match        TYPE ddshretval.

****** TABLES

  DATA: lt_lagp      TYPE ztt_lagp,
        lt_lagp_book TYPE ztt_lagp,
        lt_lagp_help TYPE ztt_wm_tools_stgbin,
        lt_r_lgtyp   TYPE ztt_r_lgtyp,
        lt_r_lgber   TYPE ztt_r_lgber,
        lt_r_lgpla   TYPE ztt_r_lgpla,
*        lt_wm_lgber TYPE ztt_wm_tools_location_lgber,
        lt_match     TYPE TABLE OF ddshretval,
        lt_t343_data TYPE ty_t_t343_data.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

***** I_LGBER

  IF ( i_lgber IS INITIAL ).
    CLEAR: lv_message.
    MOVE text-005 TO lv_message.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '005' i_msgid = me->_c_msg_label i_message = lv_message ) ).
  ENDIF.

**********************************************************************
* Lógioa
**********************************************************************

****** PREPARE DATA

***** LGTYP RANGE

  APPEND VALUE #( sign = 'I' option = 'EQ' stge_type_low = me->_s_tool_data-lgtyp ) TO lt_r_lgtyp.

***** LGBER RANGE

  APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = i_lgber ) TO lt_r_lgber.

***** GET ZTLM0003 DATA

  READ TABLE me->_s_tlm_params-t_ztlm0003 INTO DATA(ls_ztlm0003) WITH KEY lgber = i_lgber.
  CHECK sy-subrc EQ 0.

***** GET LAGP DATA 4 LGBER

  "Obtengo ubicaciones
  lt_lagp = me->_io_wm_utils->get_wm_lagp_list( i_t_r_lgtyp = lt_r_lgtyp i_t_r_lgber = lt_r_lgber i_t_r_lptyp = me->_get_param_lptyp_range( ) ).

  "Trabajo resultado
  IF ( ls_ztlm0003-max_mkapv EQ abap_true ).
    DELETE lt_lagp WHERE lkapv LT 99999999.
  ELSE.
    DELETE lt_lagp WHERE lkapv GT 100.
  ENDIF.

****** FILL DATA

***** GENERIC DATA

**** LGBER + LBERT DATA

  MOVE i_lgber TO ls_lagp_help-lgber.
  ls_lagp_help-lbert = me->_get_lbert_4_lgber( i_lgber = ls_lagp_help-lgber ).

**** MKAPV

  MOVE me->_s_tool_data-mkapv TO ls_lagp_help-mkapv.

**** MKAPV

  MOVE me->_s_tool_data-mkapv TO ls_lagp_help-mkapv.

**** MATNR

  MOVE me->_matnr TO ls_lagp_help-matnr.

***** DYNAMIC DATA

  LOOP AT lt_lagp INTO ls_lagp.

**** CHECKS

*** CHECK 1 LGPLA

    IF ( me->_check_lgpla_data_4_help( i_lagp = ls_lagp ) EQ abap_false ).
      CLEAR: lt_lagp_help.
      CONTINUE.
    ENDIF.

*** CHECK 2 BREAK

    CLEAR: ls_lagp_help_in.
    READ TABLE lt_lagp_help INTO ls_lagp_help_in INDEX lines( lt_lagp_help ).
    IF ( sy-subrc EQ 0 ). "Existe ya registro y valido si debe haber salto

      IF ( me->_check_lgpla_break( i_lgpla = ls_lagp-lgpla i_lgpla_sample = ls_lagp_help_in-zlgplaini i_break_mask = ls_ztlm0003-mask_break ) EQ abap_true ).
        CLEAR: lt_lagp_help.
      ENDIF.

    ENDIF.

**** LGPLA INI

    MOVE ls_lagp-lgpla TO ls_lagp_help-zlgplaini.

    IF ( ls_ztlm0003-max_mkapv EQ abap_true ).

**** LKAPV + RKAPV (MAX_MKAPV)

      MOVE: ls_lagp-lkapv TO ls_lagp_help-lkapv,
            ls_lagp-rkapv TO ls_lagp_help-rkapv.

    ELSE.

**** LKAPV + RKAPV

      MOVE: me->_s_tool_data-mkapv TO ls_lagp_help-lkapv,
            me->_s_tool_data-mkapv TO ls_lagp_help-rkapv.

    ENDIF.

**** SET NEW LINE

    APPEND ls_lagp_help TO lt_lagp_help.

**** PREPARE RETURN LINE

    "Si no tiene max_mkapv chequemos que hayamos acumulado MKAPV ubicaciones
    IF ( ls_ztlm0003-max_mkapv NE abap_true ).
      CHECK lines( lt_lagp_help ) EQ me->_s_tool_data-mkapv.
    ENDIF.

    CLEAR: ls_lagp_help_i1, ls_lagp_help_in.

    "Obtenemos primera línea
    READ TABLE lt_lagp_help INTO ls_lagp_help_i1 INDEX 1.

    "Obtenemos última línea
    READ TABLE lt_lagp_help INTO ls_lagp_help_in INDEX lines( lt_lagp_help ).

    "Aplicamos factor conversión interna a ubicación inicial
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = ls_lagp_help_i1-zlgplaini
      IMPORTING
        output = ls_lagp_help_i1-zlgplaini.

    "Aplicamos factor conversión interna a ubicación final
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = ls_lagp_help_in-zlgplaini
      IMPORTING
        output = ls_lagp_help_i1-zlgplafin.

    APPEND ls_lagp_help_i1 TO r_t_tool_stgbin_help.

    DELETE lt_lagp_help INDEX 1.

  ENDLOOP.

****** PREPARE RETURN DATA

  SORT r_t_tool_stgbin_help BY lgber zlgplaini.

ENDMETHOD.
METHOD _get_lptyp_r_4_ztmm0033_data.

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

  DATA: lo_ref_descr TYPE REF TO cl_abap_structdescr.

****** FIELD-SYMBOLS

  FIELD-SYMBOLS: <fss_ztmm0033> TYPE any,
                 <fsv_field>    TYPE any,
                 <fsv_value>    TYPE lvs_lptyp.

****** STRUCTURES

  DATA: lt_tbl_descr TYPE abap_compdescr_tab,
        ls_tbl_descr LIKE LINE OF lt_tbl_descr.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_s_ztmm0033 IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** ASSIGN IMPORT DATA TO FIELD SYMBOL

  ASSIGN i_s_ztmm0033 TO <fss_ztmm0033>.
  CHECK <fss_ztmm0033> IS ASSIGNED.

***** INSTANTIATE OO

  TRY .
    lo_ref_descr ?= cl_abap_typedescr=>describe_by_data( <fss_ztmm0033> ).
    IF ( lo_ref_descr IS NOT BOUND ).
      EXIT.
    ENDIF.
  CATCH cx_sy_move_cast_error.
      "no rellenamos
    EXIT.
  ENDTRY.

  lt_tbl_descr[]  = lo_ref_descr->components[].

  LOOP AT lt_tbl_descr INTO ls_tbl_descr.

    ASSIGN ls_tbl_descr-name TO <fsv_field>.

    IF ( <fsv_field> CP 'LPTYP*' ).

      ASSIGN COMPONENT <fsv_field> OF STRUCTURE <fss_ztmm0033> TO <fsv_value>.

      IF ( <fsv_value> IS ASSIGNED AND <fsv_value> IS NOT INITIAL ).

        APPEND VALUE #( sign = 'I' option = 'EQ' lptyp_low = <fsv_value> ) TO r_t_r_lptyp.

      ENDIF.

    ENDIF.

  ENDLOOP.

ENDMETHOD.
METHOD _get_matnr_mm_data.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
**** MARA
*
*    SELECT SINGLE mtart
*      FROM mara
*      INTO e_mtart
*     WHERE matnr EQ i_matnr.
*
**** MAKT
*
*    SELECT SINGLE maktx
*      FROM makt
*      INTO e_maktx
*     WHERE matnr EQ i_matnr
*       AND spras EQ 'S'.
*
**** MARC
*
*    SELECT SINGLE cuobj
*      FROM marc
*      INTO e_cuobj
*     WHERE matnr EQ i_matnr
*       AND werks EQ i_werks.
*
**** MARD
*
*    "Seleccionamos datos de la vista de almacenes IM 1 y 2
*    SELECT SINGLE lgpbe
*      FROM mard
*      INTO e_lgpbe
*     WHERE matnr EQ i_matnr
*       AND werks EQ i_werks
*       AND lgort EQ i_lgort.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
  METHOD _get_mm_bapi_data.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** --> V2

*** MARD

  SELECT SINGLE *
    FROM mard
    INTO CORRESPONDING FIELDS OF e_s_mard
   WHERE matnr EQ me->_matnr
     AND werks EQ me->_s_tool_data-werks
     AND lgort EQ me->_s_tool_data-lgort.

*** UPD DATA

  IF ( i_zlgplaini IS NOT INITIAL ).
    MOVE i_zlgplaini TO e_s_mard-lgpbe.
  ELSE.
    CLEAR: e_s_mard-lgpbe.
  ENDIF.

****** <-- V2

**********************************************************************
* --> V1
**********************************************************************
*
**** MARD
*
*  SELECT SINGLE *
*    FROM mard
*    INTO CORRESPONDING FIELDS OF e_s_mard
*   WHERE matnr EQ me->_matnr
*     AND werks EQ me->_werks
*     AND lgort EQ me->_lgort.
*
**** UPD DATA
*
*  IF ( i_zlgplaini IS NOT INITIAL ).
*    MOVE i_zlgplaini TO e_s_mard-lgpbe.
*  ELSE.
*    CLEAR: e_s_mard-lgpbe.
*  ENDIF.
*
**********************************************************************
* --> V1
**********************************************************************

  ENDMETHOD.
METHOD _get_mm_wm_booked_bins. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_rows TYPE i.

****** TABLES

  DATA: lt_r_lgpla TYPE ztt_r_lgpla,
        lt_lagp    TYPE ztt_lagp.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE WORK TABLE

  MOVE i_t_r_lgpla[] TO lt_r_lgpla[].

  DELETE lt_r_lgpla WHERE stge_bin_low IS INITIAL.

****** GET DATA

  SELECT *
    FROM mlgt
    INTO @DATA(ls_mlgt)
   WHERE lgnum EQ @me->_s_tool_data-lgnum
     AND lgtyp EQ @me->_s_tool_data-lgtyp
     AND lgpla IN @lt_r_lgpla.

    CLEAR: lt_lagp, lv_rows.

    SELECT SINGLE mkapv
      FROM mlgn
      INTO lv_rows
     WHERE lgnum EQ ls_mlgt-lgnum
       AND matnr EQ ls_mlgt-matnr.

    lt_lagp = me->_get_bin_list_nrows( i_lgpla = ls_mlgt-lgpla i_rows = lv_rows i_t_r_lgber = i_t_r_lgber ).

    DELETE lt_lagp WHERE lgber NOT IN i_t_r_lgber.
    DELETE lt_lagp WHERE lptyp NOT IN me->_get_param_lptyp_range( ).

    IF ( lines( lt_lagp ) GT 0 ).
      APPEND LINES OF lt_lagp[] TO r_t_lagp[].
    ENDIF.

  ENDSELECT.

****** PREPARE EXIT

  SORT r_t_lagp BY lgnum lgtyp lgber lgpla.

ENDMETHOD.
  METHOD _get_no_free_sublocation_list.

****** --> V1
*
*    DATA: ls_lagp            TYPE lagp,
*          ls_wm_tools_subloc TYPE zst_wm_tools_sublocation.
*
*    LOOP AT i_t_lagp INTO ls_lagp.
*
*      CLEAR: ls_wm_tools_subloc.
*
*      SELECT n~matnr, n~lgnum, t~lgtyp, t~lgpla, t~zlgplaini, n~mkapv
*        FROM mlgn AS n INNER JOIN mlgt AS t
*          ON n~matnr EQ t~matnr
*         AND n~lgnum EQ n~lgnum
*        INTO (@ls_wm_tools_subloc-matnr, @ls_wm_tools_subloc-lgnum, @ls_wm_tools_subloc-lgtyp, @ls_wm_tools_subloc-lgpla, @ls_wm_tools_subloc-zlgplaini, @ls_wm_tools_subloc-mkapv)
*       WHERE n~lgnum EQ @_lgnum
*         AND t~lgtyp EQ @_lgtyp
*         AND t~lgpla EQ @ls_lagp-lgpla.
*
*        CLEAR: ls_wm_tools_subloc-lkapv, ls_wm_tools_subloc-rkapv, ls_wm_tools_subloc-zlgplafin, ls_wm_tools_subloc-verif_ini, ls_wm_tools_subloc-verif_fin.
*
*        MOVE ls_lagp-verif TO ls_wm_tools_subloc-verif_ini.
*        MOVE ls_lagp-lkapv TO ls_wm_tools_subloc-lkapv.
*        MOVE ls_lagp-rkapv TO ls_wm_tools_subloc-rkapv.
*
*        "Calculamos:
*        " - ubicación final
*        " - sububicación final
*
*        TRY.
*            IF ( ls_wm_tools_subloc-verif_ini IS NOT INITIAL ).
*              ls_wm_tools_subloc-verif_fin      = ls_wm_tools_subloc-verif_ini + ls_lagp-lkapv - 1.
*              CONDENSE ls_wm_tools_subloc-verif_fin NO-GAPS.
*            ENDIF.
*            IF ( ls_wm_tools_subloc-zlgplaini IS NOT INITIAL ).
*              ls_wm_tools_subloc-zlgplafin  = ls_wm_tools_subloc-zlgplaini + ls_wm_tools_subloc-mkapv - 1.
*              CONDENSE ls_wm_tools_subloc-zlgplafin NO-GAPS.
*            ENDIF.
*          CATCH cx_sy_conversion_no_number.
*            CONTINUE.
*        ENDTRY.
*
*        IF ( ls_wm_tools_subloc-verif_ini IS NOT INITIAL ).
*          IF (  ls_wm_tools_subloc-zlgplaini IS NOT INITIAL ).
*            APPEND ls_wm_tools_subloc TO e_t_tools_sublocation.
*          ENDIF.
*
*        ENDIF.
*
*      ENDSELECT.
*
*    ENDLOOP.

****** <-- V1

  ENDMETHOD.
METHOD _GET_PARAM_LGBER_RANGE. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** RETURN DATA

  LOOP AT me->_s_tlm_params-t_ztlm0003 INTO DATA(ls_ztlm0003).

    APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = ls_ztlm0003-lgber ) TO r_t_r_lgber.

  ENDLOOP.

ENDMETHOD.
METHOD _GET_PARAM_LGTYP_RANGE. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

******

  APPEND VALUE #( sign = 'I' option = 'EQ' stge_type_low = me->_s_tool_data-lgtyp ) TO r_t_r_lgtyp.

ENDMETHOD.
METHOD _GET_PARAM_LPTYP_RANGE.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** RETURN DATA

  LOOP AT me->_s_tlm_params-t_ztlm0003 INTO DATA(ls_ztlm0003).

    APPEND VALUE #( sign = 'I' option = 'EQ' lptyp_low = ls_ztlm0003-lptyp ) TO r_t_r_lptyp.

  ENDLOOP.

ENDMETHOD.
METHOD _get_param_ztlm0003_4_lgber.

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_type TYPE ztipoutil.


**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_lgber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  lv_type = me->_get_tool_type( i_matnr = me->_matnr ).

****** GET/SET RETURN DATA

  READ TABLE me->_s_tlm_params-t_ztlm0003 INTO r_s_ztlm0003 WITH KEY ztipoutil = lv_type lgnum = me->_s_tool_data-lgnum lgtyp = me->_s_tool_data-lgtyp lgber = i_lgber.

ENDMETHOD.
METHOD _get_tlm_oo_wm_utils. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  CHECK i_werks IS NOT INITIAL.

***** LGORT

  CHECK i_lgort IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET/SET DATA

  TRY.
    r_oo_wm_utils = NEW zcl_utils_wm( i_werks = i_werks i_lgort = i_lgort ).
  CATCH zcx_exception INTO DATA(lo_exception).
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
  ENDTRY.

ENDMETHOD.
METHOD _get_tlm_params.

**********************************************************************
* Parámetros locales
**********************************************************************

****** TABLES

  DATA: lt_r_lptyp      TYPE ztt_r_lptyp.

****** VARIABLES

  DATA: lv_msg  TYPE scx_attrname,
        lv_ms1  TYPE syst_msgv.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

***** ZTLM0001 DATA

  r_s_tlm_params-s_ztlm0001 = me->_get_ztlm0001_data( i_werks = i_werks i_lgort = i_lgort ).
  IF ( r_s_tlm_params-s_ztlm0001 IS INITIAL OR r_s_tlm_params-s_ztlm0001-lgtyp IS INITIAL ).
    MOVE text-022 TO lv_msg.
    MOVE 'ZTLM0001' TO lv_ms1.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '022' i_msgid = me->_c_msg_label i_msgty = 'E' i_msgv1 = lv_ms1 i_message = lv_msg ).
  ENDIF.

***** ZTLM0002 DATA

  r_s_tlm_params-s_ztlm0002 = me->_get_ztlm0002_data( i_werks = r_s_tlm_params-s_ztlm0001-werks i_tipoutil = i_type i_lgnum = r_s_tlm_params-s_ztlm0001-lgnum i_lgtyp = r_s_tlm_params-s_ztlm0001-lgtyp i_codigo = i_code ).
  IF ( r_s_tlm_params-s_ztlm0002 IS INITIAL OR r_s_tlm_params-s_ztlm0002-codigo IS INITIAL ).
    MOVE text-022 TO lv_msg.
    MOVE 'ZTLM0002' TO lv_ms1.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '022' i_msgid = me->_c_msg_label i_msgty = 'E' i_msgv1 = lv_ms1 i_message = lv_msg ).
  ENDIF.

***** ZTMM0033 DATA

  r_s_tlm_params-s_ztmm0033 = me->_get_ztmm0033_data( i_werks = r_s_tlm_params-s_ztlm0001-werks i_tipoutil = r_s_tlm_params-s_ztlm0002-ztipoutil i_codigo = r_s_tlm_params-s_ztlm0002-codigo i_arbpl = i_arbpl ).
  IF ( r_s_tlm_params-s_ztmm0033 IS INITIAL OR r_s_tlm_params-s_ztmm0033-lptyp01 IS INITIAL ).
    MOVE text-022 TO lv_msg.
    MOVE 'ZTMM0033' TO lv_ms1.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '022' i_msgid = me->_c_msg_label i_msgty = 'E' i_msgv1 = lv_ms1 i_message = lv_msg ).
  ENDIF.

***** ZTLM0003 DATA

  "Obtenemos parámetros ZTLM0003
  r_s_tlm_params-t_ztlm0003 = me->_get_ztlm0003_data( i_type = r_s_tlm_params-s_ztlm0002-ztipoutil i_lgnum = r_s_tlm_params-s_ztlm0001-lgnum i_lgtyp = r_s_tlm_params-s_ztlm0002-lgtyp ).

  "Obtenemos TUs compatibles
  lt_r_lptyp = me->_get_lptyp_r_4_ztmm0033_data( i_s_ztmm0033 = r_s_tlm_params-s_ztmm0033 ).

  "Borramos parámetros ZTLM0003 con TUs no compatibles
  DELETE r_s_tlm_params-t_ztlm0003 WHERE lptyp NOT IN lt_r_lptyp.

  IF ( lines( r_s_tlm_params-t_ztlm0003 ) LE 0 ).
    MOVE text-022 TO lv_msg.
    MOVE 'ZTLM0003' TO lv_ms1.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '022' i_msgid = me->_c_msg_label i_msgty = 'E' i_msgv1 = lv_ms1 i_message = lv_msg ).
  ENDIF.

ENDMETHOD.
METHOD _get_tool_arbpl. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_atinn(10) TYPE c.

****** TABLES

  DATA: lt_configuration TYPE ibco2_instance_tab2.

**********************************************************************
* Validaciones
**********************************************************************

****** CUOBJ

  CHECK i_cuobj IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET CONFIGURATION

  CALL FUNCTION 'CUCB_GET_CONFIGURATION'
    EXPORTING
      instance                     = i_cuobj
    IMPORTING
      configuration                = lt_configuration
    EXCEPTIONS
      invalid_input                = 1
      invalid_instance             = 2
      instance_is_a_classification = 3
      OTHERS                       = 4.

  LOOP AT lt_configuration INTO DATA(ls_configuration).

    LOOP AT ls_configuration-values INTO DATA(ls_values).

      CALL FUNCTION 'CONVERSION_EXIT_ATINN_OUTPUT'
        EXPORTING
          input  = ls_values-atinn
        IMPORTING
          output = lv_atinn.

      IF ( lv_atinn = 'HP_ARBPL' ).
        MOVE ls_values-atwrt TO r_arbpl.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDLOOP.

ENDMETHOD.
METHOD _get_tool_code.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  IF ( i_matnr IS NOT INITIAL ).
    MOVE i_matnr+6(1) TO r_code.
  ELSE.
    MOVE me->_matnr+6(1) TO r_code.
  ENDIF.

ENDMETHOD.
METHOD _get_tool_cuobj.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET MARC-CUOBJ

  SELECT SINGLE cuobj
    FROM marc
    INTO r_cuobj
   WHERE matnr EQ i_matnr
     AND werks EQ i_werks.

ENDMETHOD.
METHOD _get_tool_lgpbe.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET MARD-LGPBE

  SELECT SINGLE lgpbe
    FROM mard
    INTO r_lgpbe
   WHERE matnr EQ i_matnr
     AND werks EQ i_werks
     AND lgort EQ i_lgort.

ENDMETHOD.
METHOD _get_tool_maktx.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET MAKT-MAKTX

  SELECT SINGLE maktx
    FROM makt
    INTO r_maktx
   WHERE matnr EQ i_matnr
     AND spras EQ 'S'.

ENDMETHOD.
METHOD _get_tool_mtart.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  CHECK i_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET MARA-MTART

  SELECT SINGLE mtart
    FROM mara
    INTO r_mtart
   WHERE matnr EQ i_matnr.

ENDMETHOD.
METHOD _get_tool_type.

**********************************************************************
* Parámetros locales
**********************************************************************

****** STRUCTURES

  DATA: ls_mara TYPE mara.

****** VARIABLES

  DATA: lv_matnr TYPE matnr.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MATNR

  CHECK i_matnr IS NOT INITIAL OR me->_matnr IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  IF ( i_matnr IS NOT INITIAL ).
    MOVE i_matnr TO lv_matnr.
  ELSE.
    MOVE me->_matnr TO lv_matnr.
  ENDIF.

****** GET TYPE

  SELECT SINGLE mtart
    FROM mara
    INTO @DATA(lv_mtart)
   WHERE matnr EQ @lv_matnr.

  CASE lv_mtart.
    WHEN me->_c_mtart_zcli.
      MOVE me->_c_type_cliche TO r_tooltype.
    WHEN me->_c_mtart_ztro.
      MOVE me->_c_type_troquel TO r_tooltype.
    WHEN OTHERS.
      CLEAR r_tooltype.
  ENDCASE.

ENDMETHOD.
METHOD _get_wm_bapi_data.

****** --> V2

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_exception TYPE REF TO zcx_wm_exception.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

**********************************************************************º
* Lógica
**********************************************************************

****** MLGN + MLGT

  TRY.

    me->_io_wm_utils->read_matnr_wm_data(
      EXPORTING
        i_matnr          = me->_matnr               " Número de material
        i_lgtyp          = me->_s_tool_data-lgtyp   " Tipo almacén
      IMPORTING
        e_mlgn           = e_s_mlgn    " Datos de material por número de almacén
        e_mlgt           = e_s_mlgt    " Datos de material por tipo de almacén
    ).

  CATCH zcx_wm_exception INTO lo_exception.

    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.

  ENDTRY.

****** UPD MLGN

  IF ( e_s_mlgn IS NOT INITIAL ).

***** MKAPV

    MOVE me->_s_tool_data-mkapv TO e_s_mlgn-mkapv.

***** BSSKZ

    IF ( e_s_mlgn-bsskz IS INITIAL ).
      MOVE 'Y' TO e_s_mlgn-bsskz.
    ENDIF.

  ENDIF.

*** UPD MLGT

  IF ( e_s_mlgt IS NOT INITIAL ).

    MOVE i_lgpla TO e_s_mlgt-lgpla.
    CONDENSE e_s_mlgt-lgpla NO-GAPS.

  ENDIF.

****** <-- V2

****** --> V1
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: lo_exception TYPE REF TO zcx_wm_exception.
*
*    DATA: lv_lgpla  TYPE lgpla,
*          lv_subloc TYPE zlgplaini.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*    IF ( i_lgpla IS INITIAL ).
*
*      CLEAR: lv_lgpla, lv_subloc.
*
*    ELSE.
*
*      IF ( me->_check_sublocation( i_lgpla = i_lgpla i_zsub_lgpla = i_zlgplaini ) EQ abap_true ).
*
*        MOVE i_lgpla TO lv_lgpla.
*        MOVE i_zlgplaini TO lv_subloc.
*
*      ELSE.
*
*        MOVE me->_lgpla TO lv_lgpla.
*        MOVE me->_sub_lgpla TO lv_subloc.
*
*      ENDIF.
*
*    ENDIF.
*
***********************************************************************º
** Lógica
***********************************************************************
*
**** MLGN + MLGT
*
*    TRY.
*
*        me->_io_wm_utils->read_matnr_wm_data(
*          EXPORTING
*            i_matnr          = me->_matnr    " Número de material
*            i_lgtyp          = me->_lgtyp    " Tipo almacén
*          IMPORTING
*            e_mlgn           = e_s_mlgn    " Datos de material por número de almacén
*            e_mlgt           = e_s_mlgt    " Datos de material por tipo de almacén
*        ).
*
*      CATCH zcx_wm_exception INTO lo_exception.
*
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*    ENDTRY.
*
**** UPD MLGN
*
*    IF ( e_s_mlgn IS NOT INITIAL ).
*
*      MOVE me->_mkapv TO e_s_mlgn-mkapv.
*
*    ENDIF.
*
**** UPD MLGT
*
*    IF ( e_s_mlgt IS NOT INITIAL ).
*
*
*      MOVE lv_lgpla TO e_s_mlgt-lgpla.
*      MOVE lv_subloc TO e_s_mlgt-zlgplaini.
*      CONDENSE e_s_mlgt-lgpla NO-GAPS.
*      CONDENSE e_s_mlgt-zlgplaini NO-GAPS.
*
*    ENDIF.
*
****** <-- V1

ENDMETHOD.
  METHOD _get_wm_bapi_extensionin.

****** --> V1
*
***********************************************************************
** Parámetro locales
***********************************************************************
*
*    DATA: ls_extensionin  TYPE bapiparex,
*          ls_extensioninx TYPE bapiparexx,
*          ls_bapi_te_mlgt TYPE bapi_te_mlgt.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*    IF ( i_zlgplaini IS NOT INITIAL ).
*      CHECK me->_check_sublocation( i_lgpla = i_lgpla i_zsub_lgpla = i_zlgplaini ) EQ abap_true.
*    ENDIF.
*
*
***********************************************************************
** Lógica
***********************************************************************
*
**** EXTENSIONIN
*
*** CUSTOM MLGT
*
*    "extensiones WM
*    ls_bapi_te_mlgt-whse_no       = me->_lgnum.
*    ls_bapi_te_mlgt-stge_type     = me->_lgtyp.
*    ls_bapi_te_mlgt-zlgplaini     = i_zlgplaini.
*
*** EXTENSIONIN
*
*    ls_extensionin-structure = 'BAPI_TE_MLGT'.
*    MOVE ls_bapi_te_mlgt TO ls_extensionin-valuepart1.
*
*** EXPORT EXTENSIONIN
*
*    APPEND ls_extensionin TO e_t_extensionin.
*
**** EXTENSIONINX
*
*** EXTENSIONINX
*
*    ls_extensioninx-structure       = 'BAPI_TE_MLGTX'.
*    ls_extensioninx-valuepart1(3)   = me->_lgnum.
*    ls_extensioninx-valuepart1+3(3) = me->_lgtyp.
*    ls_extensioninx-valuepart1+6(1) = 'X'.
*
*** EXPORT EXTENSIONINX
*
*    APPEND ls_extensioninx TO e_t_extensioninx.
*
****** <-- V1

  ENDMETHOD.
METHOD _get_wm_lgber_w_dialog. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_message TYPE scx_attrname.

****** STRUCTURES

  DATA: ls_wm_lgber TYPE zst_wm_tools_location_lgber,
        ls_match    TYPE ddshretval.

****** TABLES

  DATA: lt_wm_lgber TYPE ztt_wm_tools_location_lgber,
        lt_match    TYPE TABLE OF ddshretval.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

***** I_T_TOOL_LOCATIONS_LGBER

  IF ( lines( i_t_tool_locations_lgber ) LE 0 ).
    CLEAR: lv_message.
    MOVE text-005 TO lv_message.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '005' i_msgid = me->_c_msg_label i_message = lv_message ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** WORK DATA

  MOVE-CORRESPONDING i_t_tool_locations_lgber TO lt_wm_lgber.
*  DELETE lt_wm_lgber WHERE rkapv < me->_s_tool_data-mkapv.

***** SHOW DIALOG

  "Muestro ayuda para selección de ubicación
  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'LGBER'
      window_title    = 'Selección de estantería'
      value_org       = 'S'
    TABLES
      value_tab       = lt_wm_lgber
      return_tab      = lt_match
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

***** RESULT

  "Si selecciono valor...vuelco en campo
  IF ( sy-subrc EQ 0 ).

    READ TABLE lt_match INTO ls_match INDEX 1.

    IF ( sy-subrc EQ 0 ).

      READ TABLE lt_wm_lgber INTO r_s_tool_locations_lgber WITH KEY lgber = ls_match-fieldval.

      IF ( sy-subrc NE 0 ).

        CLEAR: lv_message.
        MOVE text-005 TO lv_message.
        zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '005' i_msgid = me->_c_msg_label i_message = lv_message ) ).

      ENDIF.

    ELSE.

      CLEAR: lv_message.
      MOVE text-900 TO lv_message.
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '900' i_msgid = me->_c_msg_label i_message = lv_message ) ).

    ENDIF.

  ELSE. "No selecciona valor -> Acción cancelada por usuario

    CLEAR: lv_message.
    MOVE text-900 TO lv_message.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '900' i_msgid = me->_c_msg_label i_message = lv_message ) ).

  ENDIF.

ENDMETHOD.
METHOD _get_wm_lgpla_w_dialog.

****** VARIABLES

  DATA: lv_message TYPE scx_attrname.

****** STRUCTURES

  DATA: "ls_r_lgber  TYPE zst_r_lgber,
*        ls_wm_lgber TYPE zst_wm_tools_location_lgber,
        ls_match    TYPE ddshretval.

****** TABLES

  DATA: lt_lagp     TYPE ztt_lagp,
        lt_r_lgtyp  TYPE ztt_r_lgtyp,
        lt_r_lgber  TYPE ztt_r_lgber,
        lt_wm_bins  TYPE ztt_wm_tools_stgbin,
*        lt_wm_lgber TYPE ztt_wm_tools_location_lgber,
        lt_match   TYPE TABLE OF ddshretval.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

**** I_T_TOOL_STGBIN

  IF ( lines( i_t_tool_stgbin ) LE 0 ).
    CLEAR: lv_message.
    MOVE text-005 TO lv_message.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '005' i_msgid = me->_c_msg_label i_message = lv_message ) ).
  ENDIF.

**********************************************************************
* Lógioa
**********************************************************************

****** PREPARE DATA

***** WORK DATA

  MOVE-CORRESPONDING i_t_tool_stgbin TO lt_wm_bins.

***** SHOW DIALOG

  "Muestro ayuda para selección de ubicación
  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'ZLGPLAINI'
      window_title    = 'Selección de estantería'
      value_org       = 'S'
    TABLES
      value_tab       = lt_wm_bins
      return_tab      = lt_match
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

***** RESULT

  "Si selecciono valor...vuelco en campo
  IF ( sy-subrc EQ 0 ).

    READ TABLE lt_match INTO ls_match INDEX 1.

    IF ( sy-subrc EQ 0 ).

      READ TABLE lt_wm_bins INTO r_s_tool_stgbin WITH KEY zlgplaini = ls_match-fieldval.

      IF ( sy-subrc NE 0 ).

        CLEAR: lv_message.
        MOVE text-005 TO lv_message.
        zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '005' i_msgid = me->_c_msg_label i_message = lv_message ) ).

      ENDIF.

    ELSE.

      CLEAR: lv_message.
      MOVE text-900 TO lv_message.
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '900' i_msgid = me->_c_msg_label i_message = lv_message ) ).

    ENDIF.

  ELSE. "No selecciona valor -> Acción cancelada por usuario

    CLEAR: lv_message.
    MOVE text-900 TO lv_message.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '900' i_msgid = me->_c_msg_label i_message = lv_message ) ).

  ENDIF.

ENDMETHOD.
METHOD _get_wm_location_list.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
**
**  DATA: lt_lagp     TYPE ztt_lagp,
**        ls_lagp     TYPE lagp,
**        ls_wm_lgpla TYPE zst_wm_tools_location_lgpla.
**
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
**
*** Obtengo lista de ubicaciones WM
**
**    _io_wm_utils->get_wm_lagp_list(
**      EXPORTING
**        i_t_r_lgtyp = i_t_r_lgtyp    " Tabla de rangos para tipo de almacén
***      i_t_r_lgpla =     " Tabla de rangos para ubicaciones
**        i_t_r_lptyp = i_t_r_lptyp    " Tabla de rangos para tipo ubicación
**      RECEIVING
**        e_t_lagp    = lt_lagp[]    " Tabla para estructura LAGP
**    ).
**
*** Ajusto capacidad restante
**
**    me->_adjust_rkapv_4_lagp( CHANGING c_t_lagp = lt_lagp[] ).
**
**    DELETE lt_lagp WHERE rkapv LE 0.
**
*** Relleno ubicaciones WM
**
**    LOOP AT lt_lagp INTO ls_lagp.
**
**      CLEAR: ls_wm_lgpla.
**
*** LGTYP
**
**      MOVE ls_lagp-lgtyp TO ls_wm_lgpla-lgtyp.
**
*** LGPLA
**
**      MOVE ls_lagp-lgpla TO ls_wm_lgpla-lgpla.
**
*** LKAPV
**
**      MOVE ls_lagp-lkapv TO ls_wm_lgpla-lkapv.
**
*** RKAPV
**
**      MOVE ls_lagp-rkapv TO ls_wm_lgpla-rkapv.
**
*** Añado a salida
**
**      APPEND ls_wm_lgpla TO e_t_tools_location_lgpla.
**
**    ENDLOOP.
**
**--------------------------------V1----------------------------------*


ENDMETHOD.
METHOD _get_wm_location_w_dialog.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lv_message TYPE sstring.
*
*  DATA: lt_wm_location TYPE ztt_wm_tools_location_lgpla,
*        ls_wm_location TYPE zst_wm_tools_location_lgpla.
*
*  DATA: lt_match TYPE TABLE OF ddshretval,
*        ls_match LIKE LINE OF lt_match.
**      ,
**        ls_tools_location TYPE zst_wm_tools_location,
**        lt_tools_location TYPE ztt_wm_tools_location.
*
***********************************************************************
** Validaciones
***********************************************************************
*
*  IF ( lines( i_t_tool_locations_lgpla ) LE 0 ).
*    CLEAR: lv_message.
*    MOVE text-005 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*  ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** IMPORT
*
*  MOVE-CORRESPONDING i_t_tool_locations_lgpla TO lt_wm_location.
*
*  DELETE lt_wm_location WHERE rkapv < me->_mkapv.
*
**** Valor de estantería
*
*  "Muestro ayuda para selección de ubicación
*  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
*    EXPORTING
*      retfield        = 'LGPLA'
*      window_title    = 'Selección de estantería'
*      value_org       = 'S'
*    TABLES
*      value_tab       = lt_wm_location
*      return_tab      = lt_match
*    EXCEPTIONS
*      parameter_error = 1
*      no_values_found = 2
*      OTHERS          = 3.
*
*  "Si selecciono valor...vuelco en campo
*  IF ( sy-subrc EQ 0 ).
*
*    READ TABLE lt_match INTO ls_match INDEX 1.
*
*    IF ( sy-subrc EQ 0 ).
*
*      READ TABLE lt_wm_location INTO e_s_tool_locations_lgpla WITH KEY lgtyp = me->_lgtyp lgpla = ls_match-fieldval.
*
*      IF ( sy-subrc NE 0 ).
*
*        CLEAR: lv_message.
*        MOVE text-005 TO lv_message.
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*      ENDIF.
*
*    ELSE.
*
*      CLEAR: lv_message.
*      MOVE text-900 TO lv_message.
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*    ENDIF.
*
*  ELSE. "No selecciona valor -> Acción cancelada por usuario
*
*    CLEAR: lv_message.
*    MOVE text-900 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '900' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _get_wm_sublocation_w_dialog.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lo_exception TYPE REF TO zcx_wm_exception.
*
*  DATA: lv_message TYPE sstring.
*
*  DATA: lt_wm_sublocations TYPE ztt_wm_tools_sublocation,
*        ls_wm_sublocation  TYPE zst_wm_tools_sublocation.
*
*  DATA: lt_wm_subloc_out   TYPE zst_wm_tools_location.
*
*  DATA: lt_r_lgtyp TYPE ztt_r_lgtyp,
*        ls_r_lgtyp LIKE LINE OF lt_r_lgtyp,
*        lt_r_lgpla TYPE ztt_r_lgpla,
*        ls_r_lgpla LIKE LINE OF lt_r_lgpla,
*
*        lt_lagp    TYPE ztt_lagp,
*        ls_lagp    TYPE lagp.
*
*  DATA: lt_match TYPE TABLE OF ddshretval,
*        ls_match LIKE LINE OF lt_match.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*** Estructura
*
*  IF ( i_s_tool_locations IS INITIAL ).
*    CLEAR: lv_message.
*    MOVE text-005 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*  ENDIF.
*
*** Campos específicos
*
*  IF ( i_s_tool_locations-lgpla IS INITIAL ).
*    CLEAR: lv_message.
*    MOVE text-005 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*  ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** LISTA DE SUBUBICACIONES
*
*** Obtengo LAGP
*
*  CLEAR: ls_r_lgtyp, lt_r_lgtyp[].
*  ls_r_lgtyp-sign           = 'I'.
*  ls_r_lgtyp-option         = 'EQ'.
*  ls_r_lgtyp-stge_type_low  = me->_lgtyp.
*  APPEND ls_r_lgtyp TO lt_r_lgtyp.
*
*  CLEAR: ls_r_lgpla, lt_r_lgpla[].
*  ls_r_lgpla-sign         = 'I'.
*  ls_r_lgpla-option       = 'EQ'.
*  ls_r_lgpla-stge_bin_low = i_s_tool_locations-lgpla.
*  APPEND ls_r_lgpla TO lt_r_lgpla.
*
*  TRY .
*
*      lt_lagp = _io_wm_utils->get_wm_lagp_data( i_t_r_lgtyp = lt_r_lgtyp i_t_r_lgpla = lt_r_lgpla ).
*
*    CATCH zcx_wm_exception INTO lo_exception.
*
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*  ENDTRY.
*
*** Obtengo SUBUBICACIONES VACÍAS
*
*  IF ( lines( lt_lagp ) GT 0 ).
*
*    READ TABLE lt_lagp INTO ls_lagp WITH KEY lgnum = me->_lgnum lgtyp = me->_lgtyp lgpla = i_s_tool_locations-lgpla.
*
*    me->_get_free_subloc_4_lgpla(
*      EXPORTING
*        i_lagp                 = ls_lagp    " Ubicaciones
*      IMPORTING
*        e_wm_tools_sublocation = lt_wm_sublocations    " Tabla para estructura ZST_WM_TOOLS_SUBLOCATION
*      EXCEPTIONS
*        no_valid_iparams       = 1
*        no_lagp_verif          = 2
*        no_lagp_lkapv          = 3
*        error_verif            = 4
*        error_zlgpla           = 5
*        OTHERS                 = 6
*    ).
*
*    IF ( sy-subrc NE 0 OR lines( lt_wm_sublocations ) LE 0 ).
*
*      CLEAR: lv_message.
*      MOVE text-005 TO lv_message.
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*    ENDIF.
*
*  ENDIF.
*
*** DIALOG
*
*  "Muestro ayuda para selección de ubicación
*  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
*    EXPORTING
*      retfield        = 'ZLGPLAINI'
*      window_title    = 'Selección de ubicación'
*      value_org       = 'S'
*    TABLES
*      value_tab       = lt_wm_sublocations
*      return_tab      = lt_match
*    EXCEPTIONS
*      parameter_error = 1
*      no_values_found = 2
*      OTHERS          = 3.
*
*  "Si selecciono valor...vuelco en campo
*  IF ( sy-subrc EQ 0 ).
*
*    READ TABLE lt_match INTO ls_match INDEX 1.
*
*    IF ( sy-subrc EQ 0 ).
*
*** Seteamos datos
*
*      READ TABLE lt_wm_sublocations INTO ls_wm_sublocation WITH KEY lgnum = me->_lgnum lgtyp = i_s_tool_locations-lgtyp lgpla = i_s_tool_locations-lgpla zlgplaini = ls_match-fieldval.
*
*      IF ( sy-subrc EQ 0 ).
*
*        MOVE-CORRESPONDING ls_wm_sublocation TO e_s_tool_sublocations.
*
*      ELSE.
*
*        CLEAR: lv_message.
*        MOVE text-005 TO lv_message.
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*      ENDIF.
*
*    ELSE.
*
*      CLEAR: lv_message.
*      MOVE text-900 TO lv_message.
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*    ENDIF.
*
*  ELSE. "No selecciona valor -> Acción cancelada por usuario
*
*    CLEAR: lv_message.
*    MOVE text-900 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '900' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _get_ztlm0001_data. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  CHECK i_werks IS NOT INITIAL.

***** LGORT

  CHECK i_lgort IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  SELECT SINGLE *
    FROM ztlm0001
    INTO CORRESPONDING FIELDS OF r_t_ztlm001
   WHERE werks EQ i_werks
     AND lgort EQ i_lgort.

ENDMETHOD.
METHOD _get_ztlm0002_data. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  CHECK i_werks IS NOT INITIAL.

***** TIPO UTIL

  CHECK i_tipoutil IS NOT INITIAL.

***** CODIGO

  CHECK i_codigo IS NOT INITIAL.

***** LGNUM

  CHECK i_lgnum IS NOT INITIAL.

***** LGTYP

  CHECK i_lgtyp IS NOT INITIAL.


**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  SELECT SINGLE *
    FROM ztlm0002
    INTO CORRESPONDING FIELDS OF @r_t_ztlm002
   WHERE werks      EQ @i_werks
     AND ztipoutil  EQ @i_tipoutil
     AND lgnum      EQ @i_lgnum
     AND lgtyp      EQ @i_lgtyp
     AND codigo     EQ @i_codigo.

ENDMETHOD.
METHOD _get_ztlm0003_data. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** LGNUM

  CHECK i_lgnum IS NOT INITIAL.

***** LGTYP

  CHECK i_lgtyp IS NOT INITIAL.

***** ZTIPOUTIL

  CHECK i_type IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  SELECT *
    FROM ztlm0003
    INTO CORRESPONDING FIELDS OF TABLE @r_t_ztlm0003
   WHERE ztipoutil EQ @i_type
     AND lgnum     EQ @i_lgnum
     AND lgtyp     EQ @i_lgtyp.

ENDMETHOD.
METHOD _get_ztmm0033_data. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  CHECK i_werks IS NOT INITIAL.

***** TIPO UTIL

  CHECK i_tipoutil IS NOT INITIAL.

***** CODIGO

  CHECK i_codigo IS NOT INITIAL.

***** ARBPL

  CHECK i_arbpl IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

  SELECT SINGLE *
    FROM ztmm0033
    INTO CORRESPONDING FIELDS OF @r_s_ztmm0033
   WHERE werks        EQ @i_werks
     AND ztipoutil    EQ @i_tipoutil
     AND work_center  EQ @i_arbpl
     AND codigo       EQ @i_codigo.

ENDMETHOD.
METHOD _map_lagp_2_lgpla_range. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** STRUCTURES

  DATA: ls_r_lgpla LIKE LINE OF r_t_r_lgpla.

****** TABLES

  DATA: lt_lagp TYPE ztt_lagp.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  MOVE i_t_lagp[] TO lt_lagp[].

****** MAP

***** CONSTANT VALUES

  MOVE 'I'  TO ls_r_lgpla-sign.
  MOVE 'EQ' TO ls_r_lgpla-option.

  IF ( lines( i_t_lagp ) GT 0 ).

    LOOP AT lt_lagp INTO DATA(ls_lagp).

      MOVE ls_lagp-lgpla TO ls_r_lgpla-stge_bin_low.
      APPEND ls_r_lgpla TO r_t_r_lgpla.

    ENDLOOP.

  ENDIF.

***** CASE VOID

  IF ( lines( r_t_r_lgpla ) LE 0 ).
    MOVE space TO ls_r_lgpla-stge_bin_low.
    APPEND ls_r_lgpla TO r_t_r_lgpla.
  ENDIF.

ENDMETHOD.
METHOD _read_matnr_data.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** SET MATNR DATA

***** MM DATA

  me->_set_matnr_mm_data( ).

***** WM DATA

  me->_set_matnr_wm_data( ).

***** VC LOCATION

  me->_set_tp_location( ).

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
*  DATA: lo_exception TYPE REF TO zcx_wm_exception.
*
*  TRY.
*
*    "Seteamos datos adicionales del material
*    me->_set_matnr_mm_data( ).
*    me->_set_matnr_wm_data( ).
*
*    me->_set_tp_location( ).
*
*  CATCH zcx_wm_exception INTO lo_exception.
*
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*  ENDTRY.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _set_current_bindata. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** STRUCTURES

  DATA: ls_mlgn TYPE mlgn,
        ls_mlgt TYPE mlgt.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET DATA

***** THEORIC BIN DATA

  me->_s_tool_data-_t_th_lgpla = me->_get_current_th_bindata( ).

***** REAL BIN DATA

  me->_s_tool_data-_t_re_lgpla = me->_get_current_re_bindata( ).

ENDMETHOD.
METHOD _set_lgtyp_4_tools.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lt_set_lines TYPE TABLE OF rgsbv,
*        lv_message   TYPE scx_t100key.
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
*  "Obtenemos los tipos de almacén de útiles de todos los centros
*  CALL FUNCTION 'G_SET_FETCH'
*    EXPORTING
*      langu              = 'S'
*      no_authority_check = abap_true
*      setnr              = '0000ZWM_TOOLS_LOCATION'
*    TABLES
*      set_lines_basic    = lt_set_lines
*    EXCEPTIONS
*      no_authority       = 1
*      set_is_broken      = 2
*      set_not_found      = 3
*      OTHERS             = 4.
*
*  "Si no encuentra datos
*  IF ( sy-subrc NE 0 ).
*
*    "Lanzamos excepción controlada
*    RAISE EXCEPTION TYPE zcx_wm_exception
*      EXPORTING
*        textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message(
*EXPORTING
*i_msgno  = sy-msgno    " Campo de sistema ABAP: Número de mensaje
*i_msgid  = sy-msgid    " Campo de sistema ABAP: Clase de mensaje
*i_msgty  = sy-msgty    " Campo de sistema ABAP: Tipo de mensaje
*i_msgv1  = sy-msgv1    " Campo de sistema ABAP: Variable de mensaje
*i_msgv2  = sy-msgv2    " Campo de sistema ABAP: Variable de mensaje
*i_msgv3  = sy-msgv3    " Campo de sistema ABAP: Variable de mensaje
*i_msgv4  = sy-msgv4    " Campo de sistema ABAP: Variable de mensaje
*        ).
*
*  ENDIF.
*
*  "Recorremos con un loop el set
*  LOOP AT lt_set_lines INTO DATA(ls_set_line).
*
*    "Cuando el registro coincida con el NA de la clase
*    IF ( ls_set_line-from EQ _lgnum ).
*
*      "Obtenemos el valor.
*      e_lgtyp = ls_set_line-lname+3(3).
*
*    ENDIF.
*
*  ENDLOOP.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _set_lptyp_range.

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lo_ref_descr TYPE REF TO cl_abap_structdescr,
*        lt_ztmm0033  TYPE STANDARD TABLE OF ztmm0033,
*        ls_ztmm0033  TYPE ztmm0033,
*        lt_tbl_descr TYPE abap_compdescr_tab,
*        ls_tbl_descr LIKE LINE OF lt_tbl_descr,
*        lv_tipoutil  TYPE ztipoutil,
*        lv_codigo    TYPE zcodigoutil,
*        ls_r_lptyp   TYPE zrange_lptyp.
*
*  FIELD-SYMBOLS: <fst_ztmm0033> TYPE STANDARD TABLE,
*                 <fss_ztmm0033> TYPE any,
*                 <fsv_field>    TYPE any,
*                 <fsv_value>    TYPE lvs_lptyp.
*
**********************************************************************
* Validaciones
**********************************************************************
*
*  "tipo útil
*  CASE _matnr+1(1).
*    WHEN 'T'.
*      lv_tipoutil = zcl_mm_material_tools=>_c_tipoutil_troquel.
*    WHEN 'C'.
*      lv_tipoutil = zcl_mm_material_tools=>_c_tipoutil_cliche.
*    WHEN OTHERS.
*      EXIT.
*  ENDCASE.
*
**********************************************************************
* Lógica
**********************************************************************
*
*  "código asociado a la máquina
*  lv_codigo = _matnr+6(1).
*
*  SELECT *
*    FROM ztmm0033
*    INTO CORRESPONDING FIELDS OF TABLE lt_ztmm0033
*   WHERE ztipoutil EQ lv_tipoutil
*     AND werks     EQ _werks
*     AND codigo    EQ lv_codigo.
*
*  ASSIGN lt_ztmm0033 TO <fst_ztmm0033>.
*  ASSIGN ls_ztmm0033 TO <fss_ztmm0033>.
*
*  IF ( <fst_ztmm0033> IS ASSIGNED AND <fss_ztmm0033> IS ASSIGNED ).
*
*    TRY .
*        lo_ref_descr ?= cl_abap_typedescr=>describe_by_data( <fss_ztmm0033> ).
*      CATCH cx_sy_move_cast_error.
*        "no rellenamos
*    ENDTRY.
*
*    IF ( lo_ref_descr IS BOUND ).
*
*      lt_tbl_descr[] = lo_ref_descr->components[].
*
*      LOOP AT <fst_ztmm0033> INTO <fss_ztmm0033>.
*
*        LOOP AT lt_tbl_descr INTO ls_tbl_descr.
*
*          ASSIGN ls_tbl_descr-name TO <fsv_field>.
*
*          IF ( <fsv_field> CP 'LPTYP*' ).
*
*            ASSIGN COMPONENT <fsv_field> OF STRUCTURE <fss_ztmm0033> TO <fsv_value>.
*
*            IF ( <fsv_value> IS ASSIGNED AND <fsv_value> IS NOT INITIAL ).
*
*              CLEAR: ls_r_lptyp.
*              ls_r_lptyp-sign       = 'I'.
*              ls_r_lptyp-option     = 'EQ'.
*              ls_r_lptyp-lptyp_low  = <fsv_value>.
*              APPEND ls_r_lptyp TO e_t_r_lptyp.
*
*            ENDIF.
*
*          ENDIF.
*
*        ENDLOOP.
*
*      ENDLOOP.
*
*    ENDIF.
*
*  ENDIF.
*
*  DELETE ADJACENT DUPLICATES FROM e_t_r_lptyp.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _set_matnr_mm_data.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

******* GET MM DATA

****** MASTER DATA

  me->_s_tool_data-cuobj = me->_get_tool_cuobj( i_matnr = me->_matnr i_werks = me->_s_tool_data-werks ).
  me->_s_tool_data-mtart = me->_get_tool_mtart( i_matnr = me->_matnr ).
  me->_s_tool_data-maktx = me->_get_tool_maktx( i_matnr = me->_matnr ).

****** OTHER RELATED DATA

***** ARBPL

  me->_set_tool_arbpl( ).
  me->_set_tool_type( i_matnr = me->_matnr ).

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
**    "Seleccionamos datos de la vista de almacenes IM 1 y 2
*    me->_get_matnr_mm_data(
*      EXPORTING
*        i_matnr = me->_matnr    " Número de material
*        i_werks = me->_werks    " Centro
*        i_lgort = me->_lgort    " Vista de maestro-mat para selección de almacén y lotes
*      IMPORTING
*        e_cuobj = me->_cuobj    " Configuración (número de objeto interno)
*        e_lgpbe = me->_lgpbe    " Ubicación
*        e_mtart = me->_mtart    " Tipo de material
*        e_maktx = me->_maktx    " Texto breve de material
*    ).
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _set_matnr_wm_data.

*--------------------------------V2----------------------------------*

***********************************************************************
** Parámetros locales
***********************************************************************

****** STRUCTURES

  DATA: ls_mlgn TYPE mlgn,
        ls_mlgt TYPE mlgt.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET WM DATA

***** WM MASTER DATA

  _io_wm_utils->read_matnr_wm_data(
    EXPORTING
      i_matnr          = me->_matnr              " Número de material
      i_lgtyp          = me->_s_tool_data-lgtyp  " Tipo almacén
    IMPORTING
      e_mlgn           = ls_mlgn    " Datos de material por número de almacén
      e_mlgt           = ls_mlgt    " Datos de material por tipo de almacén
  ).

****** SET WM DATA

***** MLGN

**** MKAPV - Capacidad.

  IF ( ls_mlgn-mkapv IS NOT INITIAL OR ls_mlgn-mkapv GT 0 ).
    me->set_mkapv( i_mkapv = ls_mlgn-mkapv ).
  ENDIF.

***** MLGT

**** LPTYP - Tipos de ubicación compatibles

*  me->_set_lptyp_range( ).

**** T343 - Datos Tabla T343

*  me->_set_t343_data( ).

**** LGBER - Áreas de almacen

*  me->_set_lgber_range( ).

**** LGBER - Excepciones

*  me->_set_lgber_range_mkapv_exc( ).

**** BIN DATA - Ubicaciones ocupadas por útil

  IF ( me->_s_tool_data-mkapv IS NOT INITIAL OR me->_s_tool_data-mkapv GT 0 ).

    me->_set_current_bindata( ).

  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: ls_mlgn   TYPE mlgn,
*        ls_mlgt   TYPE mlgt,
*        lv_check  TYPE boolean.
*
*  DATA: lo_exception TYPE REF TO zcx_wm_exception,
*        lv_message   TYPE sstring.
*
*  DATA: lt_r_lgtyp TYPE ztt_r_lgtyp,
*        ls_r_lgtyp TYPE LINE OF ztt_r_lgtyp,
*        lt_r_lptyp TYPE ztt_r_lptyp.
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
*  TRY .
*
**** 1. Datos de vistas WM de maestro de materiales
*
*    _io_wm_utils->read_matnr_wm_data(
*      EXPORTING
*        i_matnr          = _matnr    " Número de material
*        i_lgtyp          = _lgtyp    " Tipo almacén
*      IMPORTING
*        e_mlgn           = ls_mlgn    " Datos de material por número de almacén
*        e_mlgt           = ls_mlgt    " Datos de material por tipo de almacén
*    ).
*
*** 1.1 Capacidad.
*
*    IF ( ls_mlgn-mkapv IS NOT INITIAL OR ls_mlgn-mkapv GT 0 ).
*
*       me->set_mkapv( i_mkapv = ls_mlgn-mkapv ).
*
*    ENDIF.
*
*
*"""" MLGT
*
*** 1.2 Ubicación fija
*
*    _lgpla = ls_mlgt-lgpla.
*
*** 1.3 Sububicación
*
*    _sub_lgpla = ls_mlgt-zlgplaini.
*
*  CATCH zcx_wm_exception INTO lo_exception.
*
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*  ENDTRY.
*
**** 2. Datos de ubicación
*
*** Tipo de ubicación
*
*  SELECT SINGLE mtart
*    FROM mara
*    INTO @DATA(lv_mtart)
*   WHERE matnr EQ @_matnr.
*
*  IF ( lv_mtart EQ 'ZCLI' OR lv_mtart EQ 'ZTRO' ).
*
*    _t_r_lptyp = me->_set_lptyp_range( ).
*
*  ELSE.
*
*    CLEAR: lv_message.
*    MOVE text-002 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '002' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*  ENDIF.
*
*** Ubicaciones WM
*
*  IF ( lines( _t_r_lptyp ) GT 0 ).
*
*    CLEAR: lt_r_lgtyp[], ls_r_lgtyp.
*    ls_r_lgtyp-sign           = 'I'.
*    ls_r_lgtyp-option         = 'EQ'.
*    ls_r_lgtyp-stge_type_low  = _lgtyp.
*    APPEND ls_r_lgtyp TO lt_r_lgtyp.
*
*    _t_wm_location_list = me->_get_wm_location_list( i_t_r_lgtyp = lt_r_lgtyp i_t_r_lptyp = _t_r_lptyp ).
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _SET_TLM_OO_WM_UTILS.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  CHECK i_werks IS NOT INITIAL.

***** LGORT

  CHECK i_lgort IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** GET/SET DATA

  me->_io_wm_utils ?= me->_get_tlm_oo_wm_utils( i_werks = i_werks i_lgort = i_lgort ).

ENDMETHOD.
METHOD _set_tlm_params. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET/SET

  me->_s_tlm_params = me->_get_tlm_params( i_werks = i_werks i_lgort = i_lgort i_type = i_type i_code = i_code i_arbpl = i_arbpl ).

ENDMETHOD.
METHOD _set_tool_arbpl. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET CONFIGURATION

  me->_s_tool_data-arbpl = me->_get_tool_arbpl( i_cuobj = me->_get_tool_cuobj( i_matnr = me->_matnr i_werks = me->_s_tool_data-werks ) ).

ENDMETHOD.
METHOD _set_tool_type. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** GET/SET

  me->_s_tool_data-utype = me->_get_tool_type( i_matnr = i_matnr ).

ENDMETHOD.
METHOD _set_tp_location.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_lbert  TYPE lvs_lbert,
        lv_lines  TYPE i,
        lv_len_1  TYPE i,
        lv_len_2  TYPE i,
        lv_len_3  TYPE i,
        lv_len_4  TYPE i.

****** STRUCTURES

  DATA: ls_th_data_ini TYPE ty_s_lgpla,
        ls_th_data_end TYPE ty_s_lgpla.


**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  lv_lines = lines( me->_s_tool_data-_t_th_lgpla ).

****** SET

  IF ( lv_lines GT 0 ).

***** PREPARE DATA

**** INITIAL BIN

    READ TABLE me->_s_tool_data-_t_th_lgpla INTO ls_th_data_ini INDEX 1.

    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
      EXPORTING
        input  = ls_th_data_ini-lgpla
      IMPORTING
        output = ls_th_data_ini-lgpla.

**** FINAL BIN

    IF ( lv_lines EQ 1 ).

      MOVE-CORRESPONDING ls_th_data_ini TO ls_th_data_end.

    ELSE.

      READ TABLE me->_s_tool_data-_t_th_lgpla INTO ls_th_data_end INDEX me->_s_tool_data-mkapv.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = ls_th_data_end-lgpla
        IMPORTING
          output = ls_th_data_end-lgpla.

    ENDIF.

**** LBERT

    SELECT SINGLE lbert
      FROM t302t
      INTO lv_lbert
     WHERE spras EQ 'S'
       AND lgnum EQ me->_s_tool_data-lgnum
       AND lgtyp EQ me->_s_tool_data-lgtyp
       AND lgber EQ ls_th_data_ini-lgber.

**** CONCATENATE TP LOCATION

    lv_len_2 = strlen( ls_th_data_ini-lgpla ).
    lv_len_3 = strlen( ls_th_data_end-lgpla ).

    lv_len_1 = 30 - lv_len_2 - lv_len_3 - 2.

    IF ( lv_len_1 GT strlen( lv_lbert ) ).
      lv_len_1 = strlen( lv_lbert ).
    ENDIF.

    CONCATENATE lv_lbert(lv_len_1) '/' ls_th_data_ini-lgpla '/' ls_th_data_end-lgpla INTO me->_tp_location.

  ELSE.

    CLEAR me->_tp_location.

  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
******* VARIABLES
*
*  DATA: lv_lbert  TYPE lvs_lbert,
*        lv_lines  TYPE i.
*
******* STRUCTURES
*
*  DATA: ls_th_data_ini TYPE ty_s_lgpla,
*        ls_th_data_end TYPE ty_s_lgpla.
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
*  DATA: lv_i_lgplaini     TYPE i,
*        lv_c_lgplaini(10) TYPE c,
*        lv_i_lgplafin     TYPE i,
*        lv_c_lgplafin(10) TYPE c,
*        lv_check          TYPE boolean,
*        lv_string         TYPE string,
*        lv_i_mkapv        TYPE i.
*
*  "Se comprueba si están todos los datos necesarios rellenos
*  IF ( _lgpla IS NOT INITIAL AND _sub_lgpla IS NOT INITIAL AND _mkapv IS NOT INITIAL ). "Se han rellenado todos los datos necesarios.
*
*    "Comprobamos si el campo MLGT-ZSUB_LGPLA es numérico
*    CLEAR: lv_string.
*    MOVE _sub_lgpla TO lv_string.
*    lv_check = _io_wm_utils->check_if_string_is_numeric( i_value = lv_string ).
*
*    IF ( lv_check = abap_true ). "Es numérico
*
*      MOVE _mkapv TO lv_i_mkapv.
*      MOVE _sub_lgpla TO lv_i_lgplaini.
*
*      lv_i_lgplafin = lv_i_lgplaini + lv_i_mkapv - 1.
*
*      MOVE lv_i_lgplaini TO lv_c_lgplaini.
*      MOVE lv_i_lgplafin TO lv_c_lgplafin.
*      CONDENSE: _lgpla, lv_c_lgplaini, lv_c_lgplafin NO-GAPS.
*
*      CONCATENATE _lgpla '/' lv_c_lgplaini '/' lv_c_lgplafin INTO _tp_location.
*
*    ENDIF.
*
*  ELSE.
*
*    CLEAR: _tp_location.
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD _update_lagp_in_bbdd. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_verif TYPE lagp_verif,
        lv_sorlf TYPE lagp_sorlp.

****** STRUCTURES

  DATA: ls_lagp TYPE lagp.

****** TABLES

  DATA: lt_lagp TYPE ztt_lagp.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** VERIF

  IF ( i_upd_value EQ abap_true ).
    MOVE me->_matnr+6(7) TO lv_verif.
    CONDENSE lv_verif NO-GAPS.
  ENDIF.

***** SORLP

*  IF ( i_upd_value EQ abap_true ).
*    MOVE me->_matnr+7(6) TO lv_sorlf.
*    CONDENSE lv_sorlf NO-GAPS.
*  ENDIF.

***** MOVE DATA TABLE TO ITAB TABLE

  MOVE-CORRESPONDING i_t_lagp TO lt_lagp.

****** UPDATE

  LOOP AT lt_lagp INTO ls_lagp.

    IF ( sy-tabix = 1 ).
      UPDATE lagp SET verif = lv_verif sorlp = lv_sorlf WHERE lgnum EQ me->_s_tool_data-lgnum AND lgtyp EQ me->_s_tool_data-lgtyp AND lgpla EQ ls_lagp-lgpla.
    ELSE.
      UPDATE lagp SET skzue = i_upd_value verif = lv_verif sorlp = lv_sorlf WHERE lgnum EQ me->_s_tool_data-lgnum AND lgtyp EQ me->_s_tool_data-lgtyp AND lgpla EQ ls_lagp-lgpla.
    ENDIF.

  ENDLOOP.

ENDMETHOD.
METHOD _update_location_conf. "V2

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

  DATA: lo_tp_tool TYPE REF TO ycl_rf_tpm_tool.

****** STRUCTURES

  DATA: ls_td100_new TYPE yrf_tpr_td100,
        ls_td100     TYPE yrf_tpr_s_td100_mtart.


**********************************************************************
* Validaciones
**********************************************************************


**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  ycl_rf_tpm_tool=>get_td100(
    EXPORTING
      if_matnr       = me->_matnr
      if_werks       = me->_s_tool_data-werks
      if_refresh_req = abap_false
    IMPORTING
      es_td100       = ls_td100_new
  ).

  MOVE-CORRESPONDING ls_td100_new TO ls_td100.
  MOVE me->_s_tool_data-mtart TO ls_td100-mtart.
  MOVE me->_s_tool_data-maktx TO ls_td100-maktx.

  lo_tp_tool ?= NEW ycl_rf_tpm_tool( is_td100 = ls_td100 ).

****** SET

  IF ( lo_tp_tool IS BOUND ).
    lo_tp_tool->set_property( if_prop = 'WAHO1' if_value = me->_tp_location ).
    TRY .
      lo_tp_tool->update_material_master( ).
    CATCH /vcxi/cx_ckx.

    ENDTRY.

  ENDIF.

ENDMETHOD.
METHOD clear_matnr_location.

****** --> V2

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** UPDATE

  TRY.
    me->update_matnr_location( i_lgpla = space ).
  CATCH zcx_wm_exception INTO DATA(lo_wm_exception).
    zcl_utils_wm=>zif_msg_utils~s_launch_exception( i_textid = lo_wm_exception->if_t100_message~t100key ).
  ENDTRY.

****** <-- V2

****** --> V1
*
***********************************************************************
** Lógica
***********************************************************************º
*
****  Status del material = Z2.
**
**  SELECT SINGLE @abap_true
**    FROM marc
**    INTO @DATA(lv_check)
**   WHERE matnr EQ @_matnr
**     AND werks EQ @_werks
**     AND mmsta EQ 'Z2'.
*
*** Si status = Z2, borramos ubicación.
*
**  IF ( sy-subrc EQ 0 AND lv_check EQ abap_true ).
*
**    CLEAR: me->_s_tool_data-_t_th_lgpla.
*
*     me->update_matnr_location( i_lgpla = _lgpla i_zlgplaini = _sub_lgpla ). "V1
*
**  ENDIF.
*
****** <-- V1

ENDMETHOD.
METHOD constructor.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

  DATA: lo_exception    TYPE REF TO zcx_exception,
        lo_wm_exception TYPE REF TO zcx_wm_exception.

****** STRUTURES

  DATA: ls_ztlm0001 TYPE ztlm0001.

****** VARIABLES

  DATA: lv_msg TYPE scx_attrname.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** WERKS

  IF ( i_werks IS INITIAL ).
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = me->_c_msg_label i_msgty = 'E' ).
  ENDIF.

***** LGORT

  IF ( i_lgort IS INITIAL ).
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = me->_c_msg_label i_msgty = 'E' ).
  ENDIF.

***** MATNR

  IF ( i_matnr IS INITIAL ).
    CLEAR: lv_msg.
    MOVE text-010 TO lv_msg.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '010' i_msgid = me->_c_msg_label i_msgty = 'E' i_message = lv_msg ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE CLASS DATA

***** SET CLASS PARAMS

  me->_set_tlm_params( i_werks = i_werks i_lgort = i_lgort i_type = me->_get_tool_type( i_matnr = i_matnr ) i_code = me->_get_tool_code( i_matnr = i_matnr ) i_arbpl = me->_get_tool_arbpl( i_cuobj = me->_get_tool_cuobj( i_matnr = i_matnr i_werks =
i_werks ) ) ).

***** ZCL_UTILS_WM OO

  me->_set_tlm_oo_wm_utils( i_werks = me->_s_tlm_params-s_ztlm0001-werks i_lgort = me->_s_tlm_params-s_ztlm0001-lgort ).

****** EEOO -  Si hemos llegado aquí, existe EEOO

**** WERKS

  me->_s_tool_data-werks = me->_s_tlm_params-s_ztlm0001-werks.

**** LGORT

  me->_s_tool_data-lgort = me->_s_tlm_params-s_ztlm0001-lgort.

**** LGNUM

  me->_s_tool_data-lgnum = me->_s_tlm_params-s_ztlm0001-lgnum.

**** LGTYP

  me->_s_tool_data-lgtyp = me->_s_tlm_params-s_ztlm0001-lgtyp.

***** MATNR + MKAPV

  TRY .
    me->set_matnr( i_matnr = i_matnr i_mkapv = i_mkapv ).
  CATCH zcx_exception INTO lo_exception.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
  ENDTRY.



*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lv_msgv1   TYPE syst_msgv,
*        lv_msgv2   TYPE syst_msgv,
*        lv_msgv3   TYPE syst_msgv,
*        lv_msgv4   TYPE syst_msgv,
*        lv_message TYPE sstring.
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
*  TRY.
*
*      "Instanciamos el objeto de utilidades WM
*      _io_wm_utils = NEW zcl_utils_wm( i_werks = i_werks i_lgort = i_lgort ).
*
*      "Comprobamos si se ha instanciado
*      IF ( _io_wm_utils IS BOUND ). "Se ha instanciado
*
*        "Si se ha instanciado la clase, centro y almacén son ok. Nñumero almacén también.
*        "Set centro
*        _werks = i_werks.
*        "Set almacén
*        _lgort = i_lgort.
*        "Set WM almacén
*        _lgnum = _io_wm_utils->_lgnum.
*
*        "Set tipo almacén útiles
*        _lgtyp = me->_set_lgtyp_4_tools( ).
*
*        IF ( i_matnr IS NOT INITIAL ).
*
** Comento por cambio de lógica
**
**          IF ( i_mkapv IS NOT INITIAL ).
**
**            me->set_matnr( i_matnr = i_matnr i_mkapv = i_mkapv ). "TODO
**
**          ELSE.
**
**            CLEAR: lv_message.
**            MOVE text-008 TO lv_message.
**            RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '008' i_msgid = _c_msg_label i_msgty = 'E' i_message = lv_message ).
**
**          ENDIF.
*
*          me->set_matnr( i_matnr = i_matnr i_mkapv = i_mkapv ).
*
*        ELSE.
*
*          CLEAR: lv_message.
*          MOVE text-010 TO lv_message.
*          RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '010' i_msgid = _c_msg_label i_msgty = 'E' i_message = lv_message ).
*
*        ENDIF.
*
*      ELSE. "No se ha instanciado
*
*        CLEAR: lv_msgv1.
*        MOVE 'ZCL_WM_TOOLS_LOCATION_MANAGER' TO lv_msgv1.
*        MOVE text-004 TO lv_message.
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '004' i_msgid = _c_msg_label i_msgty = 'E' i_msgv1 = lv_msgv1 i_message = lv_message ).
*
*      ENDIF. "Fin instanciado
*
*    CATCH zcx_wm_exception INTO DATA(lo_wm_exception).
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_wm_exception->if_t100_message~t100key.
*  ENDTRY.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD set_location_w_dialog.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

***** OO

**** EXCEPTIONS

  DATA: lo_exception TYPE REF TO zcx_exception.

**** VARIABLES

  DATA: lv_rows     TYPE i,
        lv_message  TYPE scx_attrname.

**** STRUCTURES

  DATA: ls_wm_lgber_help TYPE zst_wm_tools_location_lgber,
        ls_wm_lgpla_help TYPE zst_wm_tools_stgbin.

**** TABLES

  DATA: lt_wm_lgber_help TYPE TABLE OF zst_wm_tools_location_lgber,
        lt_r_lgber       TYPE ztt_r_lgber.

**********************************************************************
* Validaciones
**********************************************************************

****** CLASS DATA

  IF ( me->_check_mkapv( i_mkapv = me->_s_tool_data-mkapv ) EQ abap_false ).
    CLEAR: lv_message.
    MOVE text-008 TO lv_message.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '008' i_msgid = me->_c_msg_label i_msgty = 'E' i_message = lv_message ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

  TRY.

****** SELECT LGBER

    ls_wm_lgber_help = me->_get_wm_lgber_w_dialog( i_t_tool_locations_lgber = me->_get_lgber_data_4_help( ) ).

****** SELECT LGPLA

    IF ( ls_wm_lgber_help IS NOT INITIAL AND ls_wm_lgber_help-lgber IN me->_get_param_lgber_range( ) ).

      ls_wm_lgpla_help = me->_get_wm_lgpla_w_dialog( i_t_tool_stgbin = me->_get_lgpla_data_4_help( i_lgber = ls_wm_lgber_help-lgber ) ).

      IF ( ls_wm_lgpla_help-zlgplaini IS NOT INITIAL AND ls_wm_lgpla_help-zlgplafin IS NOT INITIAL ).

        CLEAR: lv_rows.
        MOVE ls_wm_lgpla_help-mkapv TO lv_rows.
        APPEND VALUE #( sign = 'I' option = 'EQ' low_lgber = ls_wm_lgpla_help-lgber ) TO lt_r_lgber.

        DATA(lt_lagp) = me->_get_bin_list_nrows( i_lgpla = ls_wm_lgpla_help-zlgplaini i_rows = lv_rows i_t_r_lgber = lt_r_lgber ).
        MOVE-CORRESPONDING lt_lagp TO me->_s_tool_data-_t_th_lgpla.

        me->_set_tp_location( ).

      ENDIF.

    ENDIF.

  CATCH zcx_exception INTO lo_exception.

    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = lo_exception->if_t100_message~t100key ).

  ENDTRY.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: lo_exception TYPE REF TO zcx_wm_exception.
*
*    DATA: lv_message TYPE sstring.
*
*    DATA: ls_wm_location    TYPE zst_wm_tools_location_lgpla,
*          ls_wm_sublocation TYPE zst_wm_tools_sublocation.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** WM STORAGEBIN LIST
*
*    IF ( lines( _t_wm_location_list ) LE 0 ).
*
*      CLEAR: lv_message.
*      MOVE text-005 TO lv_message.
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*    ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** UBICACIÓN + SUBUBICACIÓN
*
*    TRY .
*
*** UBICACIÓN
*
*        ls_wm_location = me->_get_wm_location_w_dialog( i_t_tool_locations_lgpla = me->_t_wm_location_list ).
*
*** SUBUBICACIÓN
*
*        IF ( ls_wm_location IS NOT INITIAL AND ls_wm_location-lgpla IS NOT INITIAL ).
*
*          ls_wm_sublocation = me->_get_wm_sublocation_w_dialog( i_s_tool_locations = ls_wm_location ).
*
*          IF ( ls_wm_sublocation IS NOT INITIAL AND ls_wm_sublocation-zlgplaini IS NOT INITIAL ).
*
*** SETEO RESULTADO
*
*            _lgpla = ls_wm_sublocation-lgpla.
*            _sub_lgpla = ls_wm_sublocation-zlgplaini.
*            CONDENSE: _lgpla, _sub_lgpla NO-GAPS.
*
*            me->_set_tp_location( ).
*
*          ELSE.
*
*            CLEAR: lv_message.
*            MOVE text-005 TO lv_message.
*            RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*          ENDIF.
*
*        ELSE.
*
*          CLEAR: lv_message.
*          MOVE text-005 TO lv_message.
*          RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '001' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*        ENDIF.
*
*      CATCH zcx_wm_exception INTO lo_exception.
*
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*    ENDTRY.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD set_matnr.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_r_lgtyp    TYPE ztt_r_lgtyp.

  DATA: ls_r_lgtyp    LIKE LINE OF lt_r_lgtyp.

  DATA: lv_msg        TYPE scx_attrname,
        lv_mlgn_check TYPE boolean,
        lv_mlgt_check TYPE boolean.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

***** MATNR

  IF ( me->_check_matnr( i_matnr = i_matnr ) EQ abap_false ).
    CLEAR: lv_msg.
    MOVE: text-023 TO lv_msg.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '023' i_msgid = me->_c_msg_label i_message = lv_msg ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** SET TLM PARAMS

  "En constructor ya se obtiene
  IF ( me->_matnr IS NOT INITIAL AND me->_matnr NE i_matnr ).
    me->_set_tlm_params( i_werks = me->_s_tool_data-werks i_lgort = me->_s_tool_data-lgort i_type = me->_get_tool_type( i_matnr = i_matnr ) i_code = me->_get_tool_code( i_matnr = i_matnr ) i_arbpl = me->_get_tool_arbpl( i_cuobj = me->_get_tool_cuobj(
i_matnr = i_matnr i_werks = me->_s_tool_data-werks ) ) ).
  ENDIF.

**** SET MATNR

  me->_matnr = i_matnr.

  me->_read_matnr_data( ). "TODO

  IF ( i_mkapv IS NOT INITIAL AND i_mkapv NE me->_s_tool_data-mkapv ).

    TRY .

      me->set_mkapv( i_mkapv = i_mkapv ). "TODO

    CATCH zcx_wm_exception INTO DATA(lo_exception).

      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.

    ENDTRY.

  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lv_msgv1    TYPE syst_msgv,
*        lv_msgv2    TYPE syst_msgv,
*        lv_msgv3    TYPE syst_msgv,
*        lv_msgv4    TYPE syst_msgv,
*        lv_message  TYPE sstring.
*
*  DATA: lt_r_lgtyp    TYPE ztt_r_lgtyp,
*        ls_r_lgtyp    LIKE LINE OF lt_r_lgtyp,
*        lv_mlgn_check TYPE boolean,
*        lv_mlgt_check TYPE boolean.
*
***********************************************************************
** Validaciones
***********************************************************************
*
***********************************************************************
** Lógica
***********************************************************************
*
**1. Chequeo material
*
**1.1. Chequeo que existe y es un útil
*
*  SELECT COUNT(*)
*    FROM mara
*   WHERE matnr EQ i_matnr
*     AND mbrsh EQ 'M' OR mbrsh EQ 'Z'
*     AND mtart IN ('ZTRO', 'ZCLI').
*
*  IF ( sy-subrc NE 0 ).
*
*    CLEAR: lv_message.
*    MOVE text-002 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '002' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_message = lv_message ).
*
*  ENDIF.
*
**2. Chequeo material vistas WM
*
*  CLEAR: ls_r_lgtyp.
*  ls_r_lgtyp-sign           = 'I'.
*  ls_r_lgtyp-option         = 'EQ'.
*  ls_r_lgtyp-stge_type_low  = _lgtyp.
*  APPEND ls_r_lgtyp TO lt_r_lgtyp.
*
*  _io_wm_utils->check_matnr_is_extended_4_wm(
*    EXPORTING
*      i_matnr     = i_matnr    " Número de material
*      i_t_r_lgtyp = lt_r_lgtyp " Tabla de rangos para tipo de almacén
*    IMPORTING
*      e_mlgn_data = lv_mlgn_check    " Variable booleana (X=verdadero, -=falso, space=descon.)
*      e_mlgt_data = lv_mlgt_check    " Variable booleana (X=verdadero, -=falso, space=descon.)
*  ).
*
*  IF ( lv_mlgn_check = abap_true AND lv_mlgt_check = abap_true ).
*
*    "seteamos material
*    _matnr = i_matnr.
*
*    me->_read_matnr_data( ).
*
*    IF ( i_mkapv IS NOT INITIAL AND i_mkapv NE _mkapv ).
*
*      TRY .
*
*        me->set_mkapv( i_mkapv = i_mkapv ).
*
*      CATCH zcx_wm_exception INTO DATA(lo_exception).
*
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*      ENDTRY.
*
*    ENDIF.
*
*  ELSE.
*
*    CLEAR: lv_msgv1.
*    MOVE i_matnr TO lv_msgv1.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '004' i_msgid = 'ZCL_WM_TOOLS_L_M' i_msgty = 'E' i_msgv1 = lv_msgv1 ).
*
*  ENDIF.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD set_mkapv.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

****** VARIABLES

  DATA: lv_msg TYPE scx_attrname.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT

***** MKAPV

  IF ( me->_check_mkapv( i_mkapv = i_mkapv ) = abap_false ).
    CLEAR: lv_msg.
    MOVE text-012 TO lv_msg.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '012' i_msgid = me->_c_msg_label i_message = lv_msg ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** SET

  me->_s_tool_data-mkapv = i_mkapv.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lv_message  TYPE sstring,
*        lv_msgv1    TYPE syst_msgv.
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*  IF ( me->_check_mkapv( i_mkapv = i_mkapv ) = abap_false ).
*
*    CLEAR: lv_message.
*    MOVE text-012 TO lv_message.
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = _io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '012' i_msgid = me->_c_msg_label i_msgty = 'E' i_message = lv_message ).
*
*  ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
*** SET
*
*    _mkapv = i_mkapv.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD update_matnr_location.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

***** EXCEEPTIONS

  DATA: lo_exception       TYPE REF TO zcx_exception,
        lo_wm_exception    TYPE REF TO zcx_wm_exception.

****** VARIABLES

  DATA: lv_is_ok TYPE boolean,
        lv_message TYPE scx_attrname,
        lv_msgv1   TYPE syst_msgv,
        lv_nrows   TYPE i.

****** STRUCTURES

  DATA: ls_mlgn TYPE mlgn,
        ls_mlgt TYPE mlgt.

****** TABLES

  DATA: lt_lagp_old TYPE ztt_lagp,
        lt_lagp_new TYPE ztt_lagp.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

  TRY.
    IF ( me->_check_lgpla_4_tool( i_lgpla = i_lgpla ) = abap_false AND i_lgpla IS NOT INITIAL ).
      CLEAR: lv_message.
      MOVE text-015 TO lv_message.
      MOVE i_lgpla TO lv_msgv1.
      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '015' i_msgid = me->_c_msg_label i_msgty = 'E' i_msgv1 = lv_msgv1 i_message = lv_message ).
    ENDIF.
  CATCH zcx_exception INTO lo_exception.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
  ENDTRY.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** MLGN + MLGT

  me->_get_wm_bapi_data(
    EXPORTING
      i_lgpla          = i_lgpla        " Ubicación
    IMPORTING
      e_s_mlgn         = ls_mlgn        " Datos de material por número de almacén
      e_s_mlgt         = ls_mlgt        " Datos de material por tipo de almacén
    ).

***** GET OLD AND NEW BINS

**** OLD

  CLEAR: lv_nrows.

  SELECT SINGLE lgpla
    FROM mlgt
    INTO @DATA(lv_lgpla)
   WHERE lgnum EQ @me->_s_tool_data-lgnum
     AND lgtyp EQ @me->_s_tool_data-lgtyp
     AND matnr EQ @me->_matnr.

  SELECT SINGLE mkapv
    FROM mlgn
    INTO @DATA(lv_mkapv)
   WHERE matnr EQ @me->_matnr
     AND lgnum EQ @me->_s_tool_data-lgnum.

  MOVE lv_mkapv TO lv_nrows.

  IF ( lv_nrows GT 0 ).
    lt_lagp_old = me->_get_bin_list_nrows( i_lgpla = lv_lgpla i_rows = lv_nrows ).
  ENDIF.

**** NEW

  CLEAR: lv_nrows.

  MOVE me->_s_tool_data-mkapv TO lv_nrows.

  IF ( lv_nrows GT 0 ).
    lt_lagp_new = me->_get_bin_list_nrows( i_lgpla = i_lgpla i_rows = lv_nrows ).
  ENDIF.

***** UPDATE MATNR MM

  "Actualizamos el material
  CALL FUNCTION 'ZCL_WM_TOOLS_UPDATE_MATNR_RFC' DESTINATION 'NONE'
    EXPORTING
      iv_matnr        = me->_matnr
*     is_mard         = ls_mard
      is_mlgn         = ls_mlgn
      is_mlgt         = ls_mlgt.
*    TABLES
*      it_extensionin  = lt_extensionin
*      it_extensioninx = lt_extensioninx.

**** UPDATE LAGP

  me->_update_lagp_in_bbdd( i_upd_value = abap_false i_t_lagp = lt_lagp_old ).
  me->_update_lagp_in_bbdd( i_upd_value = abap_true  i_t_lagp = lt_lagp_new ).

  DO 10 TIMES.

    SELECT COUNT(*) UP TO 1 ROWS
      FROM mlgt
     WHERE matnr EQ me->_matnr
       AND lgnum EQ me->_s_tool_data-lgnum
       AND lgtyp EQ me->_s_tool_data-lgtyp
       AND lgpla EQ i_lgpla.

    IF ( sy-subrc EQ 0 ).
      MOVE abap_true TO lv_is_ok.
      EXIT.
    ENDIF.

  ENDDO.

*  WAIT UP TO 3 SECONDS
*** REREAD DATA

  TRY .
    me->_read_matnr_data( ).
*    me->_set_skzue_in_bbdd( i_upd_value = abap_true ).
  CATCH zcx_wm_exception.
    "TODO: Ver si queremos capturar esta excepción
  ENDTRY.

*** UPDATE OTHERS

  IF ( lv_is_ok EQ abap_true ).

    me->_update_location_conf( ).

    IF ( i_lgpla IS NOT INITIAL ).
      me->_create_ot_4_tool( ).
    ENDIF.

  ENDIF.


*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*    DATA: lo_exception    TYPE REF TO zcx_wm_exception,
*          lo_ap_material  TYPE REF TO zcl_ap_material,
*          ls_message      TYPE LINE OF cfx_bi_tt_bapi_matreturn2,
*          lv_message      TYPE sstring,
*          ls_mard         TYPE mard,
*          ls_mlgn         TYPE mlgn,
*          ls_mlgt         TYPE mlgt,
*          ls_bapi_te_mlgt TYPE bapi_te_mlgt,
*          lt_extensionin  TYPE bapiparex_t,
*          ls_extensionin  TYPE bapiparex,
*          lt_extensioninx TYPE zbapiparexx_t,
*          ls_extensioninx TYPE bapiparexx,
*          lv_value        TYPE string.
*
*
*
***********************************************************************
** Validaciones
***********************************************************************
*
**** IMPORT
*
*  IF ( i_lgpla IS INITIAL ). "Ubicación WM no informada
*
*    IF ( i_zlgplaini IS INITIAL ). "Ambos iniciales --> Estamos limpiando datos de ubicación.
*
*      CLEAR: me->_lgpla, me->_lgpbe, me->_sub_lgpla.
*
*    ELSE.
*
*      CLEAR: lv_message.
*      MOVE text-013 TO lv_message.
*      RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = me->_io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '013' i_msgid = _c_msg_label i_msgty = 'E' i_message = lv_message ).
*
*    ENDIF.
*
*  ELSE. "Ubicación WM informada
*
*    IF ( i_zlgplaini IS INITIAL ). "Comprobamos que todos los datos de ubicación.
*
*      IF ( me->_sub_lgpla IS INITIAL ).
*
*        CLEAR: lv_message.
*        MOVE text-013 TO lv_message.
*        RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = me->_io_wm_utils->zif_msg_utils~s_generate_raising_message( i_msgno = '013' i_msgid = _c_msg_label i_msgty = 'E' i_message = lv_message ).
*
*      ENDIF.
*
*    ENDIF.
*
*  ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
**** IM
*
*** MARD
*
**"" Comento, ya no rellenamos campo LGPBE de MARD, ahora lo guardamoz en ZSUBLGPLA
**  ls_mard = me->_get_mm_bapi_data( i_zlgplaini = i_zlgplaini ).
*
**** WM
*
*** MLGN + MLGT
*
*  TRY.
*
*      me->_get_wm_bapi_data(
*        EXPORTING
*          i_lgpla          = i_lgpla        " Ubicación
*          i_zlgplaini      = i_zlgplaini    " Sububicación inicial
*        IMPORTING
*          e_s_mlgn         = ls_mlgn        " Datos de material por número de almacén
*          e_s_mlgt         = ls_mlgt        " Datos de material por tipo de almacén
*      ).
*
*    CATCH zcx_wm_exception INTO lo_exception.
*      "TODO: Ver si queremos capturar esta excepción
*  ENDTRY.
*
*** EXTENSION DATA
*
*  IF ( i_zlgplaini IS NOT INITIAL ).
*
*    me->_get_wm_bapi_extensionin(
*      EXPORTING
*        i_lgpla          = i_lgpla            " Ubicación
*        i_zlgplaini      = i_zlgplaini        " Sububicación inicial
*      IMPORTING
*        e_t_extensionin  = lt_extensionin     " Extensión BAPI
*        e_t_extensioninx = lt_extensioninx    " Tabla con estructura bapiparexx
*    ).
*
*  ELSE.
*
*    me->_get_wm_bapi_extensionin(
*      EXPORTING
*        i_lgpla          = i_lgpla            " Ubicación
*        i_zlgplaini      = me->_sub_lgpla     " Sububicación inicial
*      IMPORTING
*        e_t_extensionin  = lt_extensionin     " Extensión BAPI
*        e_t_extensioninx = lt_extensioninx    " Tabla con estructura bapiparexx
*    ).
*
*  ENDIF.
*
**** UPDATE MATNR MM
*
*  "Actualizamos el material
*  CALL FUNCTION 'ZCL_WM_TOOLS_UPDATE_MATNR_RFC' DESTINATION 'NONE'
*    EXPORTING
*      iv_matnr        = me->_matnr
**     is_mard         = ls_mard
*      is_mlgn         = ls_mlgn
*      is_mlgt         = ls_mlgt
*    TABLES
*      it_extensionin  = lt_extensionin
*      it_extensioninx = lt_extensioninx.
*
*  WAIT UP TO 3 SECONDS.
*
**** REREAD DATA
*
*  TRY .
*      me->_read_matnr_data( ).
*    CATCH zcx_wm_exception.
*      "TODO: Ver si queremos capturar esta excepción
*  ENDTRY.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
METHOD update_matnr_location_w_dialog.

*--------------------------------V2----------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

****** OO

***** EXCEPTIONS

  DATA: lo_exception TYPE REF TO zcx_exception.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

****** SET NEW LOCALTION W DIALOG

  TRY .
    me->set_location_w_dialog( ).
  CATCH zcx_exception INTO lo_exception.
    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
  ENDTRY.

*****^* UPDATE LOCATION

  READ TABLE me->_s_tool_data-_t_th_lgpla INTO DATA(ls_th_lgpla) INDEX 1.
  IF ( sy-subrc EQ 0 ).
    me->update_matnr_location( i_lgpla = ls_th_lgpla-lgpla ).
  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
**********************************************************************
**********************************************************************

**--------------------------------V1----------------------------------*
*
***********************************************************************
** Parámetros locales
***********************************************************************
*
*  DATA: lo_exception TYPE REF TO zcx_wm_exception.
*
*  DATA: lv_lgpla TYPE lgpla,
*        lv_lgpbe TYPE lgpbe.
*
***********************************************************************
** Lógica
***********************************************************************
*
*
*  TRY.
*
**** SET LOCATION
*
*    me->set_location_w_dialog( ).
*
**** UPDATE MATERIAL MASTER
*
*    me->update_matnr_location( i_lgpla = me->_lgpla ).
*
*  CATCH zcx_wm_exception INTO lo_exception.
*
*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.
*
*  ENDTRY.
*
**--------------------------------V1----------------------------------*

ENDMETHOD.
