*TYPES: BEGIN OF ty_matnr_data,
*  productname       TYPE matnr,
**  internalarticlenr TYPE
*  cuobj             TYPE cuobj,
*END OF ty_matnr_data.

class ZCL_WM_BARTENDER_PRINT_MANAGER definition
  public
  final
  create public .

public section.

  types:
*** Tipos
    "Datos material
    BEGIN OF ty_matnr_data,
      productname TYPE maktx,
      cuobj TYPE cuobj,
    END OF ty_matnr_data .
  types:
    "Datos ventas
    BEGIN OF ty_vbeln_data,
      erporderid TYPE vbeln_va,
      posnr      TYPE posnr_va,
      customerid TYPE kunnr,
      vtweg      TYPE vtweg,
      vkorg      TYPE vkorg,
    END OF ty_vbeln_data .
  types:
    "Datos cliente
    BEGIN OF ty_kunnr_data,
      customername      TYPE name1_gp,
      entreprisenr      TYPE stcd1,
      internalarticlenr TYPE kdmat,
    END OF ty_kunnr_data .
  types:
    BEGIN OF ty_vbkd_data,
     bstkd TYPE bstkd,
   END OF ty_vbkd_data .

*** Parámetros
  data _LGNUM type LGNUM read-only .
  data _T_BARTENDER_DATA type ZTT_BARTENDER_LABEL_DATA read-only .
  class-data _C_TIPO_A type CHAR1 read-only value 'A' ##NO_TEXT.
  class-data _C_TIPO_D type CHAR1 read-only value 'D' ##NO_TEXT.
  class-data _C_TIPO_E type CHAR1 read-only value 'E' ##NO_TEXT.
  class-data _C_TIPO_R type CHAR1 read-only value 'R' ##NO_TEXT.
  class-data _C_TIPO_X type CHAR1 read-only value 'X' ##NO_TEXT.
  class-data _C_TIPO_C type CHAR1 read-only value 'C' ##NO_TEXT.
  data O_PAR type ref to ZCL_AP_PARAMETROS .

*** Métodos
  methods CONSTRUCTOR
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
    raising
      ZCX_EXCEPTION .
  methods CREATE_LABEL_DATA
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM
    returning
      value(R_S_BARTENDER_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods GET_NEW_LABEL_DATA_4_LENUM
    importing
      !I_LENUM type LENUM
    returning
      value(E_S_BT_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA .
  methods SEND_LABEL_DATA_2_BARTENDER_FL
    exceptions
      FILE_NO_CREATED .
  methods SET_NEW_LABEL_DATA
    importing
      !I_S_BT_LABEL_DATA type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods SET_NEW_LABEL_DATA_4_LENUM
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM
    raising
      ZCX_EXCEPTION .
  methods SET_NEW_LABEL_DATA_4_OLD_LENUM
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM .
  methods SET_NEW_LABEL_DATA_LIST
    importing
      !I_T_BT_LABEL_DATA type ZTT_BARTENDER_LABEL_DATA
    returning
      value(R_T_RETURN) type BAPIRET2_T .
PROTECTED SECTION.
private section.

  data _WERKS type WERKS_D .
  data _LGORT type LGORT_D .
  constants _C_BT_FOLDER_PART_1 type STRING value '/usr/sap' ##NO_TEXT.
  constants _C_BT_FOLDER_PART_2 type STRING value 'BARTENDER' ##NO_TEXT.
  constants _C_BT_NAME_PART_1 type STRING value 'InternalLabel_OM_SAP_BARTENDER_' ##NO_TEXT.
  constants _C_CLASS_LABEL type CHAR20 value 'ZCL_WM_BT_PRINT_MNGR' ##NO_TEXT.
  data _IO_WM_UTILS type ref to ZCL_UTILS_WM .

  methods _BUILD_FOLDER_PATH
    returning
      value(R_FOLDERPATH) type LOCALFILE .
  methods _CHECK_ARTICLEREF
    importing
      !I_MATNR type MATNR
    exceptions
      NO_VALUE
      NO_MATNR_EXISTS
      NO_WERKS_EXIST
      NO_MATNR_EXISTS_IN_WERKS .
  methods _CHECK_BOARDSPAL
    importing
      !I_GESME type LQUA_GESME
    exceptions
      NO_VALUE
      NO_VALID_VALUE .
  methods _CHECK_BT_DATA
    importing
      !I_S_BT_LABEL_DATA type ZST_BARTENDER_LABEL_DATA
    exporting
      !E_RETURN type BAPIRET2
    exceptions
      NO_VALID_DATA
      NO_VALID_TYPE
      NO_VALID_QUANTITY
      NO_VALID_UA .
  methods _CHECK_CUSTOMERID
    importing
      !I_KUNNR type KUNNR
    exceptions
      NO_VALUE .
  methods _CHECK_CUSTOMERNAME
    importing
      !I_NAME1 type NAME1
    exceptions
      NO_VALUE .
  methods _CHECK_ENTERPRISENR
    importing
      !I_STCD1 type STCD1
    exceptions
      NO_VALUE .
  methods _CHECK_ERPORDERID
    importing
      !I_VBELN type VBELN_VA
    exceptions
      NO_VALUE .
  methods _CHECK_ERPPLANTID
    importing
      !I_ERPPLANTID type WERKS_D
    exceptions
      NO_VALUE
      NO_VALID_PLANT .
  methods _CHECK_FSCCERTIFICATEINFO
    importing
      !I_FSCCERTIFICATEINFO type YHP_SVCS_FSCTY
    exceptions
      NO_VALUE .
  methods _CHECK_INTERNALARTICLENR
    importing
      !I_INTERNALARTICLENR type KDMAT
    exceptions
      NO_VALUE .
  methods _CHECK_MVTTYPE
    importing
      !I_TIPO type CHAR1
    exceptions
      NO_VALUE
      NO_VALID_TYPE .
  methods _CHECK_MYEANNUMBER
    importing
      !I_EAN type YHP_SVCS_BCEAN
    exceptions
      NO_VALUE .
  methods _CHECK_ORDERID
    importing
      !I_AUFNR type AUFNR
    exceptions
      NO_VALUE .
  methods _CHECK_PRODUCTNAME
    importing
      !I_MAKTX type MAKTX
    exceptions
      NO_VALUE .
  methods _CHECK_RFIDLABELTYPE
    importing
      !I_RFIDLABELTYPE type ZVCXI_XCSU_TLABL
    exceptions
      NO_VALUE .
  methods _CHECK_SSCCCODE
    importing
      !I_SSCCCODE type AIN_SSCC
    exceptions
      NO_VALUE .
  methods _CHECK_STRAPPERINSTRUCTIONS
    importing
      !I_STRAPPERINSTRUCTIONS type YHP_SVCS_PBCOD
    exceptions
      NO_VALUE .
  methods _CREATE_BAPIRET2
    importing
      !I_TYPE type BAPI_MTYPE
      !I_NUMBER type SYMSGNO
      !I_MESSAGE type BAPI_MSG
      !I_MESSAGE_V1 type SYMSGV optional
      !I_MESSAGE_V2 type SYMSGV optional
      !I_MESSAGE_V3 type SYMSGV optional
      !I_MESSAGE_V4 type SYMSGV optional
    returning
      value(E_BAPIRET2) type BAPIRET2 .
  methods _CREATE_LABEL_DATA
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM
      !I_MATNR type MATNR
      !I_CHARG type CHARG_D
      !I_MENGE type MENGE_D
      !I_SONUM type LVS_SONUM
    returning
      value(R_S_BARTENDER_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods _CREATE_LABEL_DATA_4_LENUM
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM
    returning
      value(R_S_BT_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods _CREATE_LABEL_DATA_4_OLD_LENUM
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_LENUM type LENUM
    returning
      value(R_S_BARTENDER_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods _CREATE_LABEL_DATA_4_ZLNUM
    importing
      !I_MVTTYPE type ZMVTTYPE
      !I_ZLNUM type ZED_ZLNUM
    returning
      value(R_S_BARTENDER_LABEL_DATA) type ZST_BARTENDER_LABEL_DATA
    raising
      ZCX_EXCEPTION .
  methods _FILL_LABEL_DATA_RETURN
    importing
      !I_TYPE type BAPI_MTYPE
      !I_ID type SYMSGID
      !I_NUMBER type SYMSGNO
      !I_SYMSGV type SYMSGV
    returning
      value(E_BAPIRET) type BAPIRET2 .
  methods _GET_CUOBJ_FROM_CHARG
    importing
      !I_MATNR type MATNR
      !I_CHARG type CHARG_D
    returning
      value(E_CUOBJ) type CUOBJ .
  methods _GET_DATA_KUNNR
    importing
      !I_KUNNR type KUNNR
      !I_VKORG type VKORG
      !I_VTWEG type VTWEG
      !I_MATNR type MATNR
    exporting
      !E_KUNNR_DATA type TY_KUNNR_DATA
    exceptions
      NO_VALID_IPARAMS .
  methods _GET_DATA_MATNR
    importing
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
    exporting
      !E_MATNR_DATA type TY_MATNR_DATA
    exceptions
      NO_VALID_IPARAMS .
  methods _GET_DATA_VBAK
    importing
      !I_VBELN type VBELN_VA
    changing
      !C_VBELN_DATA type TY_VBELN_DATA
    exceptions
      NO_VALID_IPARAMS .
  methods _GET_DATA_VBELN_4_MBLNR
    importing
      !I_MBLNR type MBLNR
      !I_MBLPO type MBLPO
      !I_MJAHR type MJAHR
    exporting
      !E_VBELN_DATA type TY_VBELN_DATA
    exceptions
      NO_VALID_IPARAMS .
  methods _GET_DATA_VBELN_4_SONUM
    importing
      !I_SONUM type LVS_SONUM
    exporting
      !E_VBELN_DATA type TY_VBELN_DATA
    exceptions
      NO_VALID_IPARAMS .
  methods _GET_DATA_VBKD
    importing
      !I_VBELN type VBELN
      !I_POSNR type POSNR
    returning
      value(R_S_VBKD_DATA) type TY_VBKD_DATA .
  methods _MAP_BTDATA_2_FILEDATA
    returning
      value(E_DATA_TABLE) type ZTT_STRING
    exceptions
      NO_DDIC_STRUCTURE .
endclass. "ZCL_WM_BARTENDER_PRINT_MANAGER definition
class ZCL_WM_BARTENDER_PRINT_MANAGER implementation.
METHOD _build_folder_path.

**********************************************************************
* Parámetros locales
**********************************************************************

****** TABLES

  DATA: lt_set_lines TYPE TABLE OF rgsbv,
        lt_r_werks   TYPE range_t_werks.

****** VARIABLES

  DATA: lv_werks_path TYPE setlintext.


**********************************************************************
* Validaciones
**********************************************************************

****** CLASS DATA

  CHECK me->_werks IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

******

  "Obtenemos los tipos de almacén de útiles de todos los centros
  CALL FUNCTION 'G_SET_FETCH'
    EXPORTING
      langu              = 'S'
      no_authority_check = abap_true
      setnr              = '0000ZMM_BARTENDER_FOLDER'
    TABLES
      set_lines_basic    = lt_set_lines
    EXCEPTIONS
      no_authority       = 1
      set_is_broken      = 2
      set_not_found      = 3
      OTHERS             = 4.

  "Chequeamos que haya devuelto registros.
  CHECK lines( lt_set_lines ) GT 0.

  "Recorremos con un loop el set
  LOOP AT lt_set_lines INTO DATA(ls_set_line).

    CLEAR: lt_r_werks.

    CHECK ls_set_line-from IS NOT INITIAL.

    IF ( ls_set_line-to IS INITIAL ).
      APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_set_line-from ) TO lt_r_werks.
    ELSE.
      APPEND VALUE #( sign = 'I' option = 'BT' low = ls_set_line-from high = ls_set_line-to ) TO lt_r_werks.
    ENDIF.

    IF ( me->_werks IN lt_r_werks ).
      "Obtenemos el valor.
      MOVE ls_set_line-title TO lv_werks_path.
      EXIT.
    ENDIF.

  ENDLOOP.

  "Chequeo que se ha obtenido ruta
  CHECK lv_werks_path IS NOT INITIAL.

  "Monto ruta
  CONCATENATE _c_bt_folder_part_1 sy-sysid _c_bt_folder_part_2 lv_werks_path INTO r_folderpath SEPARATED BY '/'.

ENDMETHOD.
METHOD _check_articleref.

**********************************************************************
* Validaciones
**********************************************************************

** No inicial

  IF ( i_matnr IS INITIAL ).
    RAISE no_value.
  ENDIF.

** Material existe para centro

  SELECT COUNT(*) UP TO 1 ROWS
    FROM marc
   WHERE matnr = i_matnr
     AND werks = me->_werks.

  IF sy-subrc <> 0.
    RAISE no_matnr_exists_in_werks.
  ENDIF.

ENDMETHOD.
METHOD _check_boardspal.

**********************************************************************
* Chequeos de cantidad
**********************************************************************

** No inicial

  IF ( i_gesme IS INITIAL OR i_gesme LE 0 ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_bt_data.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lv_gesme TYPE lqua_gesme,
        lv_mtart TYPE mtart.

**********************************************************************
* Validaciones
**********************************************************************

*** BASIC DATA

** ARTICLEREF

  me->_check_articleref(
    EXPORTING
      i_matnr                  = i_s_bt_label_data-articleref    " Número de material
    EXCEPTIONS
      no_value                 = 1
      no_matnr_exists          = 2
      no_werks_exist           = 3
      no_matnr_exists_in_werks = 4
      OTHERS                   = 5
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

** PRODUCTNAME

  me->_check_productname(
    EXPORTING
      i_maktx                  = i_s_bt_label_data-productname    " Texto breve de material
    EXCEPTIONS
      no_value                 = 1
      OTHERS                   = 2
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

** BOARDSPAL (CANTIDAD)

  CLEAR: lv_gesme.
  MOVE i_s_bt_label_data-boardspal TO lv_gesme.

  me->_check_boardspal(
    EXPORTING
      i_gesme  = lv_gesme    " Cantidad total
    EXCEPTIONS
      no_value = 1
      OTHERS   = 2
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_quantity.
  ENDIF.

** SSCCCODE

  me->_check_sscccode(
    EXPORTING
      i_sscccode = i_s_bt_label_data-sscccode    " Serial Shipping Container Code
    EXCEPTIONS
      no_value   = 1
      OTHERS     = 2
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

** ORDERID

  me->_check_orderid(
    EXPORTING
      i_aufnr  = i_s_bt_label_data-orderid    " Número de orden/lote
    EXCEPTIONS
      no_value = 1
      OTHERS   = 2
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

** ERPPLANTID

  me->_check_erpplantid(
    EXPORTING
      i_erpplantid   = i_s_bt_label_data-erpplantid    " Centro
    EXCEPTIONS
      no_value       = 1
      no_valid_plant = 2
      OTHERS         = 3
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

** MVTTYPE

  me->_check_mvttype(
    EXPORTING
      i_tipo   = i_s_bt_label_data-mvttype    " Tipo de acción de etiquetado
    EXCEPTIONS
      no_value      = 1
      no_valid_type = 2
      OTHERS        = 3
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_type.
  ENDIF.

** RFIDLABELTYPE

  me->_check_rfidlabeltype(
    EXPORTING
      i_rfidlabeltype = i_s_bt_label_data-rfidlabeltype    " VCXI-XCS: Formato de Etiqueta (Label Type)
    EXCEPTIONS
      no_value        = 1
      OTHERS          = 2
  ).
  IF ( sy-subrc NE 0 ).
    RAISE no_valid_data.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** Vemos tipo de material

  SELECT SINGLE mtart
    FROM mara
    INTO lv_mtart
   WHERE matnr EQ i_s_bt_label_data-articleref.

  TRY .

    "Comprobamos que sea material compatible
    IF ( lv_mtart IN zcl_mm_material_zpt=>zintf_mm_material_master~s_get_mtart_compatibles( i_setname = zcl_mm_material_zpt=>_c_setname_value ) ).

      "Si es SEMI, no hacemos más validaciones.
      IF ( lv_mtart EQ 'ZPSE' ).
        EXIT.
      ENDIF.

    ELSE.

      RAISE no_valid_data.

    ENDIF.

  CATCH zcx_mm_exception.

    RAISE no_valid_data.

  ENDTRY.

**** CHECKS

*** INFO SD

** ERPORDERID

  me->_check_erporderid(
    EXPORTING
      i_vbeln  = i_s_bt_label_data-erporderid    " Documento de ventas
    EXCEPTIONS
      no_value = 1
      OTHERS   = 2
  ).

  "Comprobamos si existe pedido asociado
  IF ( sy-subrc EQ 0 ). "Existe --> Valido datos de cliente

** CUSTOMERID

    me->_check_customerid(
      EXPORTING
        i_kunnr  = i_s_bt_label_data-customerid    " Número de deudor
      EXCEPTIONS
        no_value = 1
        OTHERS   = 2
    ).
    IF ( sy-subrc NE 0 ).
      RAISE no_valid_data.
    ENDIF.

** CUSTOMERNAME

    me->_check_customername(
      EXPORTING
        i_name1  = i_s_bt_label_data-customername    " Nombre cliente
      EXCEPTIONS
        no_value = 1
        OTHERS   = 2
    ).
    IF ( sy-subrc NE 0 ).
      RAISE no_valid_data.
    ENDIF.

** MYEANNUMBER

    me->_check_myeannumber(
      EXPORTING
        i_ean    = i_s_bt_label_data-myeannumber    " Cód.Barras - (Codificación exclusiva para descarga Clientes)
      EXCEPTIONS
        no_value = 1
        OTHERS   = 2
    ).
    IF ( sy-subrc NE 0 ).
*      RAISE no_valid_data.
    ENDIF.

** STRAPPERINSTRUCTIONS

    me->_check_strapperinstructions(
      EXPORTING
        i_strapperinstructions = i_s_bt_label_data-strapperinstructions    " Código Barras Paletizado
      EXCEPTIONS
        no_value               = 1
        OTHERS                 = 2
    ).
    IF ( sy-subrc NE 0 ).
      RAISE no_valid_data.
    ENDIF.

** ENTERPRISENR

    me->_check_enterprisenr(
      EXPORTING
        i_stcd1      = i_s_bt_label_data-entreprisenr    " Número de identificación fiscal 1
      EXCEPTIONS
        no_value     = 1
        OTHERS       = 2
    ).
    IF ( sy-subrc NE 0 ).
      RAISE no_valid_data.
    ENDIF.

** INTERNALARTICLENR

    me->_check_internalarticlenr(
      EXPORTING
        i_internalarticlenr = i_s_bt_label_data-internalarticlenr    " Material de cliente
      EXCEPTIONS
        no_value            = 1
        OTHERS              = 2
    ).
    IF ( sy-subrc NE 0 ).
*      RAISE no_valid_data.
    ENDIF.

  ENDIF. "Fin chequeo datos SD

*** FSCCERTIFICATEINFO

  me->_check_fsccertificateinfo(
    EXPORTING
      i_fsccertificateinfo = i_s_bt_label_data-fsccertificateinfo    " Tipo FSC
    EXCEPTIONS
      no_value             = 1
      OTHERS               = 2
  ).
  IF ( sy-subrc NE 0 ).
*    RAISE no_valid_data.
  ENDIF.

ENDMETHOD.
METHOD _check_customerid.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_kunnr IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_customername.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_name1 IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_enterprisenr.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_stcd1 IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_erporderid.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_vbeln IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _CHECK_ERPPLANTID.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_erpplantid IS INITIAL ).
    RAISE no_value.
  ENDIF.

** Corresponde con centro objeto

  IF ( me->_werks NE i_erpplantid ).
    RAISE no_valid_plant.
  ENDIF.

ENDMETHOD.
METHOD _CHECK_FSCCERTIFICATEINFO.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

* -- Si puede ser inicial
*  IF ( i_fsccertificateinfo IS INITIAL ).
*    RAISE no_value.
*  ENDIF.

ENDMETHOD.
METHOD _CHECK_INTERNALARTICLENR.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_internalarticlenr IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_mvttype.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_idd07v TYPE TABLE OF  dd07v.

**********************************************************************
* Chequeos
**********************************************************************

** No inicial

  IF ( i_tipo IS INITIAL ).
    RAISE no_value.
  ENDIF.

** Tipo valido

  "Obtenemos valores de dominio para tipo
  CALL FUNCTION 'DD_DOMVALUES_GET'
    EXPORTING
      domname        = 'ZMVTTYPE'
      text           = 'X'
      langu          = sy-langu
    TABLES
      dd07v_tab      = lt_idd07v
    EXCEPTIONS
      wrong_textflag = 1
      OTHERS         = 2.

  IF ( sy-subrc = 0 ).

    "Comprobamos si tipo introducido está en el dominio
    READ TABLE lt_idd07v WITH KEY domvalue_l = i_tipo TRANSPORTING NO FIELDS.

    IF ( sy-subrc NE 0 ).
      RAISE no_valid_type.
    ENDIF.

  ELSE.

    RAISE no_valid_type.

  ENDIF.

ENDMETHOD.
METHOD _CHECK_MYEANNUMBER.

**********************************************************************
* Validaciones
**********************************************************************

** No inicial

  IF ( i_ean IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_orderid.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_aufnr IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_productname.

**********************************************************************
* Validaciones
**********************************************************************

** No inicial

  IF ( i_maktx IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_rfidlabeltype.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_rfidlabeltype IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_sscccode.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_sscccode IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _check_strapperinstructions.

**********************************************************************
* Validaciones
**********************************************************************

** Valor inicial

  IF ( i_strapperinstructions IS INITIAL ).
    RAISE no_value.
  ENDIF.

ENDMETHOD.
METHOD _create_bapiret2.

  e_bapiret2-type       = i_type.
  e_bapiret2-id         = me->_c_class_label.
  e_bapiret2-number     = i_number.
  e_bapiret2-message    = i_message.
  e_bapiret2-message_v1 = i_message_v1.
  e_bapiret2-message_v2 = i_message_v2.
  e_bapiret2-message_v3 = i_message_v3.
  e_bapiret2-message_v4 = i_message_v4.

ENDMETHOD.
METHOD _create_label_data.


**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_idx_manager  TYPE REF TO zcl_hp_vcpp_idx_manager.

  DATA: lt_idx151_data  TYPE yhp_omp_tt_td151.

  DATA: ls_matnr_data        TYPE ty_matnr_data,
        ls_vbeln_data        TYPE ty_vbeln_data,
        ls_kunnr_data        TYPE ty_kunnr_data,
        ls_idx100_data       TYPE yhp_idx_td100,
        ls_idx150_data       TYPE yhp_idx_td150,
        ls_idx151_unit_data  TYPE yhp_idx_td151,
        ls_idx151_stack_data TYPE yhp_idx_td151,
        ls_idx151_group_data TYPE yhp_idx_td151.


  DATA: lv_prole_str(14) TYPE c,
        lv_prowi_str(14) TYPE c,
        lv_prohe_str(14) TYPE c.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MVTTYPE

  me->_check_mvttype(
    EXPORTING
      i_tipo        = i_mvttype    " Tipo de acción de etiquetado
    EXCEPTIONS
      no_value      = 1
      no_valid_type = 2
      OTHERS        = 3
  ).
  IF sy-subrc <> 0.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

***** LENUM/SSCC

  IF ( i_lenum IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

***** MATNR

  IF ( i_matnr IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

***** CHARG

  IF ( i_charg IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  CLEAR: r_s_bartender_label_data.

****** FILL DATA

***** INFO GENERAL DATA

  MOVE i_mvttype TO r_s_bartender_label_data-mvttype.        "Tipo de movimiento BARTENDER

  CALL FUNCTION 'CONVERSION_EXIT_LENUM_INPUT'
    EXPORTING
      input                 = i_lenum
    IMPORTING
      OUTPUT                = r_s_bartender_label_data-sscccode
    EXCEPTIONS
      CHECK_FAILED          = 1
      NOT_NUMERIC           = 2
      T344_GET_FAILED       = 3
      WRONG_LENGTH          = 4
      OTHERS                = 5.

  IF ( sy-subrc <> 0 ).
    MOVE i_lenum TO r_s_bartender_label_data-sscccode.       "Código SSCC/UA
  ENDIF.

  MOVE i_matnr      TO r_s_bartender_label_data-articleref.     "Número de material
  MOVE i_charg      TO r_s_bartender_label_data-orderid.        "OF o lote --> En este caso es pedido de compras pero no se corresponde con lote
  MOVE me->_werks   TO r_s_bartender_label_data-erpplantid.     "Centro
  MOVE i_menge      TO r_s_bartender_label_data-boardspal.      "Cantidad
  MOVE sy-datum     TO r_s_bartender_label_data-datestring.     "Fecha

***** INFO MATNR DATA

  CLEAR: ls_matnr_data.

  me->_get_data_matnr(
    EXPORTING
      i_matnr          = r_s_bartender_label_data-articleref    " Número de material
      i_werks          = r_s_bartender_label_data-erpplantid    " Centro
    IMPORTING
      e_matnr_data     = ls_matnr_data                          " Datos de material
    EXCEPTIONS
      no_valid_iparams = 1
      OTHERS           = 2 ).

  IF ( sy-subrc EQ 0 ).
    MOVE ls_matnr_data-productname TO r_s_bartender_label_data-productname.  "Descrip. de material
  ENDIF.

***** INFO SD DATA

  CLEAR: ls_vbeln_data.

  "Stock especial cliente
  IF ( i_sonum IS NOT INITIAL ). "Si

    me->_get_data_vbeln_4_sonum(
      EXPORTING
        i_sonum          = i_sonum    " Número de stock especial
      IMPORTING
        e_vbeln_data     = ls_vbeln_data          " Datos pedido ventas
      EXCEPTIONS
        no_valid_iparams = 1
        OTHERS           = 2
    ).

    IF ( sy-subrc EQ 0 ).

      MOVE ls_vbeln_data-erporderid TO r_s_bartender_label_data-erporderid.  "Pedido de cliente
      MOVE ls_vbeln_data-customerid TO r_s_bartender_label_data-customerid.  "Número de cliente

    ENDIF.

  ENDIF.

***** INFO CUSTOMER DATA

  CLEAR: ls_kunnr_data.

  "Comprobamos si tenemos número de cliente
  IF ( ls_vbeln_data-customerid IS NOT INITIAL ). "Si.

    me->_get_data_kunnr(
      EXPORTING
        i_kunnr          = ls_vbeln_data-customerid             " Número de deudor
        i_vkorg          = ls_vbeln_data-vkorg                  " Organización de ventas
        i_vtweg          = ls_vbeln_data-vtweg                  " Canal de distribución
        i_matnr          = r_s_bartender_label_data-articleref  " Número de material
      IMPORTING
        e_kunnr_data     = ls_kunnr_data    " Datos de pedido de ventas
      EXCEPTIONS
        no_valid_iparams = 1
        OTHERS           = 2
    ).

    IF ( sy-subrc EQ 0 ).

      MOVE ls_kunnr_data-customername      TO r_s_bartender_label_data-customername.           "Nombre cliente
      MOVE ls_kunnr_data-entreprisenr      TO r_s_bartender_label_data-entreprisenr.           "NIF cliente
      MOVE ls_kunnr_data-internalarticlenr TO r_s_bartender_label_data-internalarticlenr.      "Número material cliente   KNMT

    ENDIF.

  ENDIF.

***** INFO IDX TABLES

  "Comprobamos si tenemos configuración
  CREATE OBJECT lo_idx_manager
    EXPORTING
      i_cuobj          = ls_matnr_data-cuobj    " Configuración (número de objeto interno)
    EXCEPTIONS
      no_valid_iparams = 1
      OTHERS           = 2.


  IF ( lo_idx_manager IS BOUND ).

**** IDX 100

    CLEAR: ls_idx100_data, lv_prole_str, lv_prowi_str, lv_prohe_str.

    lo_idx_manager->get_td100_data(
      RECEIVING
        e_yhp_idx_td100 = ls_idx100_data
      EXCEPTIONS
        no_values       = 1
        OTHERS          = 2
    ).

    IF ( sy-subrc EQ 0 ).

*** FSC

      MOVE ls_idx100_data-fscty TO r_s_bartender_label_data-fsccertificateinfo.   "Tipo de FSC

*** Dimensiones

      lv_prowi_str = trunc( ls_idx100_data-prowi ).
      CONDENSE lv_prowi_str NO-GAPS.
      lv_prole_str = trunc( ls_idx100_data-prole ).
      CONDENSE lv_prole_str NO-GAPS.
      lv_prohe_str = trunc( ls_idx100_data-prohe ).
      CONDENSE lv_prohe_str NO-GAPS.

      CONCATENATE lv_prole_str 'X' lv_prowi_str 'X' lv_prohe_str INTO r_s_bartender_label_data-internaldimensions.   "Dimensiones internas producto

    ENDIF.

**** IDX 150

    CLEAR: ls_idx150_data.

    lo_idx_manager->get_td150_data(
      RECEIVING
        e_yhp_idx_td150 = ls_idx150_data
      EXCEPTIONS
        no_values       = 1
        OTHERS          = 2
    ).

    IF ( sy-subrc EQ 0 ).

      MOVE ls_idx150_data-tlabl TO r_s_bartender_label_data-rfidlabeltype.         "Tipo de etiqueta
      MOVE ls_idx150_data-bcean TO r_s_bartender_label_data-myeannumber.           "Código EAN
      MOVE ls_idx150_data-pbcod TO r_s_bartender_label_data-strapperinstructions.  "Instrucciones paletizado

    ENDIF.

**** IDX 151 -> UNIT y STACK

    CLEAR: lt_idx151_data, ls_idx151_group_data, ls_idx151_stack_data, ls_idx151_unit_data.

    lo_idx_manager->get_td151_data_all(
      RECEIVING
        e_yhp_tt_idx_td151 = lt_idx151_data
      EXCEPTIONS
        no_valid_iparams   = 1
        no_values          = 2
        OTHERS             = 3
    ).

    IF ( sy-subrc EQ 0 ).

*** Paquete

      "Obtengo datos a nivel de paquete
      READ TABLE lt_idx151_data INTO ls_idx151_group_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_group.
      IF ( sy-subrc NE 0 ). "No existe nivel paquete --> Adoptamos pila como paquete
        "Obtengo datos a nivel de paquete
        READ TABLE lt_idx151_data INTO ls_idx151_group_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_stack.
      ENDIF.

*** Pila

      "Obtengo datos a nivel de pila
      READ TABLE lt_idx151_data INTO ls_idx151_stack_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_stack.

*** Palé

      "Obtengo datos a nivel de pila
      READ TABLE lt_idx151_data INTO ls_idx151_unit_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_unit.

*** Obtenemos datos

      MOVE ls_idx151_group_data-prqty TO r_s_bartender_label_data-mybundlenofblanks.               "Cajas en paquete --> GROUP (prev. quant. )
      MOVE ls_idx151_unit_data-prqty  TO r_s_bartender_label_data-bundlenofnext.                   "Paquetes en una capa  --> UNIT (prev. quant. )
      r_s_bartender_label_data-layernof = ls_idx151_stack_data-prqty * ls_idx151_unit_data-prqty.  "Número de paquetes en pallet --> STACK (prev. quant.) x UNIT (prev. quant.)

    ENDIF.

  ENDIF.

****** RETURN

***** PREPARE 4 EXIT

  "Si no tenemos rfidlabeltype (Tipo de etiqueta) lo fijamos a genérica
  IF ( r_s_bartender_label_data-rfidlabeltype IS INITIAL ).
    MOVE '0' TO r_s_bartender_label_data-rfidlabeltype.
  ENDIF.

ENDMETHOD.
METHOD _CREATE_LABEL_DATA_4_LENUM.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lt_lqua TYPE lqua_t.

  DATA: ls_lqua TYPE lqua.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

*** LO_WM_UTILS

  IF ( _io_wm_utils IS NOT BOUND ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno   = '999' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-999 ) i_msgty = 'E' ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** GET UA DATA

  lt_lqua = me->_io_wm_utils->get_wm_lqua_data( i_t_r_lenum = VALUE #( ( sign = 'I' option = 'EQ' lenum_low = i_lenum ) ) ).

  IF ( lines( lt_lqua ) LE 0 ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno   = '103' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-103 ) i_msgty = 'E' ) ).
  ENDIF.

  READ TABLE lt_lqua INTO ls_lqua INDEX 1.

****** FILL DATA

  r_s_bt_label_data = me->_create_label_data( i_mvttype = i_mvttype i_lenum = ls_lqua-lenum i_matnr = ls_lqua-matnr i_charg = ls_lqua-charg i_menge = CONV #( ls_lqua-gesme ) i_sonum = ls_lqua-sonum ).

ENDMETHOD.
METHOD _CREATE_LABEL_DATA_4_OLD_LENUM.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lv_vlpla TYPE lgpla.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** OLD LENUM

  SELECT SINGLE *
    FROM ltap
    INTO @DATA(ls_ltap)
   WHERE lgnum = @me->_lgnum
     AND tanum = ( SELECT MAX( p~tanum ) FROM ltak AS h LEFT JOIN ltap AS p ON h~lgnum = p~lgnum AND h~tanum = p~tanum WHERE h~lgnum = @me->_lgnum AND h~trart = 'A' AND p~vlenr = @i_lenum ).

  IF ( sy-subrc <> 0 ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '105' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-105 ) i_msgty = 'E' i_msgv1 = CONV #(
i_lenum ) ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** SONUM

  lv_vlpla = |{ ls_ltap-charg ALPHA = IN }|.

  "Miro si cuando se creó la UA era para pedido de ventas
  SELECT SINGLE sobkz, sonum
    FROM ltap
    INTO ( @ls_ltap-sobkz, @ls_ltap-sonum )
   WHERE lgnum = @me->_lgnum
     AND vlpla = @lv_vlpla
     AND nlenr = @i_lenum.

****** FILL DATA

  r_s_bartender_label_data = me->_create_label_data( i_mvttype = i_mvttype i_lenum = i_lenum i_matnr = ls_ltap-matnr i_charg = ls_ltap-charg i_menge = CONV #( ls_ltap-vistm ) i_sonum = ls_ltap-sonum ).

ENDMETHOD.
METHOD _create_label_data_4_zlnum.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MVTTYPE


  "JVM - AJUSTE ARRANQUE DESHACER"ADD JVM
  IF me->_lgort = 'P001'."ADD JVM
    IF ( i_mvttype <> zcl_wm_bartender_print_manager=>_c_tipo_c )."ADD JVM
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '102' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-102 ) i_msgty = 'E' ) )."ADD JVM
    ENDIF."ADD JVM
  ELSE."ADD JVM
    "FJVM

    IF ( i_mvttype <> zcl_wm_bartender_print_manager=>_c_tipo_x ).
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '102' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-102 ) i_msgty = 'E' ) ).
    ENDIF.
  ENDIF."ADD JVM

***** ZLNUM

  SELECT SINGLE *
    FROM ztmmim0001
    INTO @DATA(ls_ztmmim0001)
   WHERE zlnum = @i_zlnum
     AND werks = @me->_werks
     AND lgort = @me->_lgort.

  IF sy-subrc <> 0.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '102' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-102 ) i_msgty = 'E' ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** FILL DATA

  r_s_bartender_label_data = me->_create_label_data( i_mvttype = i_mvttype i_lenum = CONV #( i_zlnum ) i_matnr = ls_ztmmim0001-matnr i_charg = ls_ztmmim0001-charg i_menge = CONV #( ls_ztmmim0001-lmen1 ) i_sonum = ls_ztmmim0001-sonum ).

ENDMETHOD.
METHOD _fill_label_data_return.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lv_type TYPE bapi_mtype.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_type IS NOT INITIAL ).
    MOVE i_type TO lv_type.
  ELSE.
    lv_type = 'I'.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

  MOVE lv_type  TO e_bapiret-type.
  MOVE i_id     TO e_bapiret-id.
  MOVE i_number TO e_bapiret-number.
  e_bapiret-message = 'Error en parámetro'.
  MOVE i_symsgv TO e_bapiret-message_v1.

ENDMETHOD.
METHOD _get_cuobj_from_charg.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_vcpp_util TYPE REF TO zcl_utils_vcpp.

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT




**********************************************************************
* Lógica
**********************************************************************

***

  zcl_utils_vcpp=>s_get_cuobj_4_matnr_charg(
    EXPORTING
      i_matnr          = i_matnr    " Número de material
      i_charg          = i_charg    " Número de lote
    RECEIVING
      e_cuobj          = e_cuobj    " Configuración (número de objeto interno)
    EXCEPTIONS
      no_valid_iparams = 1
      no_values        = 2
      OTHERS           = 3
  ).

ENDMETHOD.
METHOD _GET_DATA_KUNNR.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_data_kunnr TYPE ty_kunnr_data.

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT

  IF ( i_kunnr IS INITIAL ).
    RAISE no_valid_iparams.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** KNA1 - Cliente

  SELECT SINGLE name1 stcd1
    FROM kna1
    INTO ( ls_data_kunnr-customername, ls_data_kunnr-entreprisenr )
   WHERE kunnr EQ i_kunnr.

  IF ( sy-subrc EQ 0 ).

*** KNMT - Info material / cliente

    SELECT SINGLE kdmat
      FROM knmt
      INTO ls_data_kunnr-internalarticlenr
     WHERE vkorg EQ i_vkorg
       AND vtweg EQ i_vtweg
       AND kunnr EQ i_kunnr
       AND matnr EQ i_matnr.

  ENDIF.

  "Si NIF no viene relleno, vemos si viene relleno el comunitario.
  IF ( ls_data_kunnr-customername IS NOT INITIAL AND ls_data_kunnr-entreprisenr IS INITIAL ).

    SELECT SINGLE stceg
      FROM kna1
      INTO ( ls_data_kunnr-entreprisenr )
     WHERE kunnr EQ i_kunnr.

  ENDIF.

*** Exportamos datos

  MOVE-CORRESPONDING ls_data_kunnr TO e_kunnr_data.

ENDMETHOD.
METHOD _get_data_matnr.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_matnr_data TYPE ty_matnr_data.

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT

  IF ( i_matnr IS INITIAL ).
    RAISE no_valid_iparams.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** MAKT

  SELECT SINGLE maktx
    FROM makt
    INTO ls_matnr_data-productname
   WHERE matnr EQ i_matnr
     AND spras EQ 'S'.

*** MARC

  SELECT SINGLE cuobj
    FROM marc
    INTO ls_matnr_data-cuobj
   WHERE matnr EQ i_matnr
     AND werks EQ i_werks.

*** Exportamos datos

  MOVE-CORRESPONDING ls_matnr_data TO e_matnr_data.

ENDMETHOD.
METHOD _get_data_vbak.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT

  IF ( i_vbeln IS INITIAL ).
    RAISE no_valid_iparams.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** Recuperamos datos

    SELECT SINGLE vkorg vtweg kunnr
      FROM vbak
      INTO ( c_vbeln_data-vkorg, c_vbeln_data-vtweg, c_vbeln_data-customerid )
     WHERE vbeln EQ i_vbeln.

ENDMETHOD.
METHOD _get_data_vbeln_4_mblnr.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_data_vbeln TYPE ty_vbeln_data.

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT

  IF ( i_mblnr IS INITIAL OR i_mblpo IS INITIAL OR i_mjahr IS INITIAL ).
    RAISE no_valid_iparams.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** Obtenemos pedido y posición

  SELECT SINGLE mat_kdauf mat_kdpos
    FROM mseg
    INTO ( ls_data_vbeln-erporderid, ls_data_vbeln-posnr )
   WHERE mblnr EQ i_mblnr
     AND zeile EQ i_mblpo
     AND mjahr EQ i_mjahr.

*** Validamos

  SELECT COUNT(*)
    FROM vbap
   WHERE vbeln EQ ls_data_vbeln-erporderid
     AND posnr EQ ls_data_vbeln-posnr.

  IF ( sy-subrc EQ 0 ).

*** Recuperamos resto de datos

    me->_get_data_vbak(
      EXPORTING
        i_vbeln          = ls_data_vbeln-erporderid    " Documento de ventas
      CHANGING
        c_vbeln_data     = ls_data_vbeln    " Datos VBELN
      EXCEPTIONS
        no_valid_iparams = 1
        others           = 2
    ).

*** Exportamos datos

    MOVE-CORRESPONDING ls_data_vbeln TO e_vbeln_data.

  ENDIF.

ENDMETHOD.
METHOD _get_data_vbeln_4_sonum.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: ls_data_vbeln TYPE ty_vbeln_data.

  DATA: lv_sonum TYPE lvs_sonum.

**********************************************************************
* Validaciones
**********************************************************************

*** IMPORT

  IF ( i_sonum IS INITIAL ).
    RAISE no_valid_iparams.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

*** Obtenemos pedido y posición

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input         = i_sonum
    IMPORTING
      output        = lv_sonum.

  MOVE lv_sonum(10)   TO ls_data_vbeln-erporderid.
  MOVE lv_sonum+10(6) TO ls_data_vbeln-posnr.

*** Validamos

  SELECT COUNT(*)
    FROM vbap
   WHERE vbeln EQ ls_data_vbeln-erporderid
     AND posnr EQ ls_data_vbeln-posnr.

  IF ( sy-subrc EQ 0 ).

*** Recuperamos resto de datos

    me->_get_data_vbak(
      EXPORTING
        i_vbeln          = ls_data_vbeln-erporderid    " Documento de ventas
      CHANGING
        c_vbeln_data     = ls_data_vbeln    " Datos VBELN
      EXCEPTIONS
        no_valid_iparams = 1
        others           = 2
    ).

*** Exportamos datos

    MOVE-CORRESPONDING ls_data_vbeln TO e_vbeln_data.

  ENDIF.

ENDMETHOD.
METHOD _get_data_vbkd.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

******* GET/SET DATA

  SELECT SINGLE *
    FROM vbkd
    INTO CORRESPONDING FIELDS OF r_s_vbkd_data
   WHERE vbeln EQ i_vbeln
     AND posnr EQ i_posnr.

ENDMETHOD.
METHOD _map_btdata_2_filedata.

**********************************************************************
* Declaraciones locales
**********************************************************************

** Objetos



** Parámetros

  DATA: lt_strings        TYPE ztt_string,
        ls_string         TYPE LINE OF ztt_string,
        lv_string         TYPE string,
        lv_tabix          TYPE sy-tabix,
        ls_bartender_data TYPE zst_bartender_label_data,
        lt_structure_desc TYPE ddfields.

** Fieldsymbols

  FIELD-SYMBOLS: <fs_ddfield> TYPE LINE OF ddfields,
                 <fv_value>   TYPE any.

**********************************************************************
* Lógica
**********************************************************************

** Instancias de las clases

  TRY .
    lt_structure_desc = zcl_utils_tables=>s_get_structure_desc( i_structure = ls_bartender_data ).
  CATCH zcx_exception.
    RAISE no_ddic_structure.
  ENDTRY.

** Montamos cabecera

  CLEAR: ls_string.

  "Recorremos los campos de la estructura
  LOOP AT lt_structure_desc ASSIGNING <fs_ddfield>.

    CLEAR: lv_string.

    IF ( <fs_ddfield>-fieldname IS ASSIGNED ).
      MOVE <fs_ddfield>-fieldname TO lv_string.
    ENDIF.

    CONDENSE lv_string NO-GAPS.
    IF ( ls_string IS INITIAL ).
      MOVE lv_string TO ls_string.
    ELSE.
      CONCATENATE ls_string lv_string INTO ls_string SEPARATED BY ';'.
    ENDIF.

  ENDLOOP.

  APPEND ls_string TO e_data_table.


** Montamos los textos concatenados para construir el fichero

  "Recorremos los datos a imprimir
  LOOP AT _t_bartender_data INTO ls_bartender_data.

    "Borramos la línea a escribir
    CLEAR: ls_string.

    "Recorremos los campos de la estructura
    LOOP AT lt_structure_desc ASSIGNING <fs_ddfield>.

      MOVE sy-tabix TO lv_tabix.

      CLEAR lv_string.

      ASSIGN COMPONENT <fs_ddfield>-fieldname OF STRUCTURE ls_bartender_data TO <fv_value>.

      IF ( <fv_value> IS ASSIGNED ).
        MOVE <fv_value> TO lv_string.
      ENDIF.

      CONDENSE lv_string NO-GAPS.
      IF ( lv_tabix EQ 1 ).
        CONCATENATE ls_string lv_string INTO ls_string.
      ELSE.
        CONCATENATE ls_string lv_string INTO ls_string SEPARATED BY ';'.
      ENDIF.

    ENDLOOP.

    APPEND ls_string TO e_data_table.

  ENDLOOP.

ENDMETHOD.
METHOD constructor.

**********************************************************************
* Parametros locales
**********************************************************************

** Objetos

  DATA: lo_exception TYPE REF TO zcx_exception.

**********************************************************************
* Lógica
**********************************************************************

****** Prepare data

  "Valido centro/almacén
  NEW zcl_utils_mm( i_werks = i_werks i_lgort = i_lgort ).

****** Set Data

***** MM

  me->_werks = i_werks.
  me->_lgort = i_lgort.

***** WM

  TRY.

      "Iniciamos clase de utilidades
      _io_wm_utils = NEW zcl_utils_wm( i_werks = i_werks i_lgort = i_lgort ).

      "Si centro y almacén están bien, podemos obtener número de almacén
      _lgnum = _io_wm_utils->_lgnum.

    CATCH zcx_exception INTO lo_exception.

*    RAISE EXCEPTION TYPE zcx_wm_exception EXPORTING textid = lo_exception->if_t100_message~t100key.

  ENDTRY.

  o_par = NEW #( clave = 'BARTENDER' ).

ENDMETHOD.
METHOD create_label_data.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** MOVTTYPE

  me->_check_mvttype(
    EXPORTING
      i_tipo        = i_mvttype    " Tipo de acción de etiquetado
    EXCEPTIONS
      no_value      = 1
      no_valid_type = 2
      OTHERS        = 3
  ).
  IF sy-subrc <> 0.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno   = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

***** LENUM

  IF ( i_lenum IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno   = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** CHECK CASE

  "2 CASOS: UA con WM, ZUA para externos

  IF ( me->_lgnum IS NOT INITIAL ). "CASO UA

    "Check utils
    IF ( me->_io_wm_utils IS NOT BOUND ).
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '999' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-999 ) i_msgty = 'E' ) ).
    ENDIF.

    r_s_bartender_label_data = me->_create_label_data_4_lenum( i_mvttype = i_mvttype i_lenum = i_lenum ).

  ELSE. "CASO ZUA

    r_s_bartender_label_data = me->_create_label_data_4_zlnum( i_mvttype = i_mvttype i_zlnum = CONV #( i_lenum ) ).

  ENDIF.

ENDMETHOD.
METHOD GET_NEW_LABEL_DATA_4_LENUM.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lv_sscc TYPE ain_sscc.

**********************************************************************
* Validaciones
**********************************************************************

**********************************************************************
* Lógica
**********************************************************************

*** READ DATA

  IF ( me->_lgnum IS NOT INITIAL ).
    MOVE i_lenum TO lv_sscc.
  ELSE.

    ENDIF.

  lv_sscc = CONV #( i_lenum ).


  READ TABLE me->_t_bartender_data INTO e_s_bt_label_data WITH KEY sscccode = lv_sscc.

ENDMETHOD.
METHOD send_label_data_2_bartender_fl.

*-------------------------------V2-----------------------------------*

**********************************************************************
* Declaraciones locales
**********************************************************************

** Objetos

  DATA: lo_file_utils TYPE REF TO zcl_utils_files.

** Parámetros

  DATA: lt_strings   TYPE ztt_string,
        lv_filename  TYPE string,
        lv_localfile TYPE localfile.


**********************************************************************
* Lógica
**********************************************************************

** Instancias de las clases

  lo_file_utils = NEW zcl_utils_files( ).

** Mapeamos datos para crear el fichero

  me->_map_btdata_2_filedata(
    RECEIVING
      e_data_table      = lt_strings    " Tabla de líneas para ficheros
    EXCEPTIONS
      no_ddic_structure = 1
      OTHERS            = 2
  ).
  IF sy-subrc <> 0.
    RAISE file_no_created.
  ENDIF.

** Creamos el fichero

  "Montamos la ruta del fichero
  CONCATENATE _c_bt_name_part_1 sy-datum sy-uzeit '.TXT' INTO lv_filename.

  IF o_par->get_atr1( 'TIPO' ) = 'FTP'.
    DATA(l_directorio) = o_par->get_atr1( 'FTP_DIR_' && me->_werks ).
    IF l_directorio IS INITIAL.
      MESSAGE |Indique valor del directorio en parámetro { l_directorio }| TYPE 'I'.
      RAISE file_no_created.
    ENDIF.
    NEW zcl_ap_ftp( )->grabar_fichero( EXPORTING user     = o_par->get_atr1( 'FTP_USUARIO' )
                                                 password = o_par->get_atr1( 'FTP_PASSWORD' )
                                                 host     = o_par->get_atr1( 'FTP_IP' )
                                                 fichero  = lv_filename
                                                 directorio = l_directorio
                                                 i_tabla = lt_strings
                                       IMPORTING message = DATA(l_msg) ).
    IF NOT l_msg IS INITIAL.
      MESSAGE l_msg TYPE 'I'.
      RAISE file_no_created.
    ENDIF.
  ELSE.
    "Montamos la ruta de la carpeta
    lv_localfile = me->_build_folder_path( ).

    IF ( lv_localfile IS INITIAL ).
      RAISE file_no_created.
    ENDIF.

    "Montamos la ruta completa
    CONCATENATE lv_localfile lv_filename INTO lv_localfile SEPARATED BY '/'.

    "Escribimos el fichero
    lo_file_utils->write_file(
      EXPORTING
        i_filepath      = lv_localfile   " Fichero local para upload/download
        i_datatable     = lt_strings     " Tabla de líneas para ficheros
      EXCEPTIONS
        no_file_created = 1
        OTHERS          = 2
    ).
    IF sy-subrc <> 0.
      RAISE file_no_created.
    ENDIF.
  ENDIF.

*-------------------------------V2-----------------------------------*
**********************************************************************
**********************************************************************
*-------------------------------V1-----------------------------------*
*
***********************************************************************
** Declaraciones locales
***********************************************************************
*
*** Objetos
*
*  DATA: lo_file_utils TYPE REF TO zcl_utils_files.
*
*** Parámetros
*
*  DATA: lt_strings        TYPE ztt_string,
*        lv_filename       TYPE string,
*        lv_localfile      TYPE localfile.
*
*
***********************************************************************
** Lógica
***********************************************************************
*
*** Instancias de las clases
*
*  lo_file_utils = NEW zcl_utils_files( ).
*
*** Mapeamos datos para crear el fichero
*
*  me->_map_btdata_2_filedata(
*    RECEIVING
*      e_data_table      = lt_strings    " Tabla de líneas para ficheros
*    EXCEPTIONS
*      no_ddic_structure = 1
*      OTHERS            = 2
*  ).
*  IF sy-subrc <> 0.
*    RAISE file_no_created.
*  ENDIF.
*
*** Creamos el fichero
*
*  "Montamos la ruta del fichero
*  CONCATENATE _c_bt_name_part_1 sy-datum sy-uzeit '.TXT' INTO lv_filename.
*
*  "Montamos la ruta completa
*  CONCATENATE _c_bt_folder_part_1 sy-sysid _c_bt_folder_part_2 lv_filename INTO lv_localfile SEPARATED BY '/'.
*
*  "Escribimos el fichero
*  lo_file_utils->write_file(
*    EXPORTING
*      i_filepath      = lv_localfile   " Fichero local para upload/download
*      i_datatable     = lt_strings     " Tabla de líneas para ficheros
*    EXCEPTIONS
*      no_file_created = 1
*      OTHERS          = 2
*  ).
*  IF sy-subrc <> 0.
*    RAISE file_no_created.
*  ENDIF.
*
*-------------------------------V1-----------------------------------*

ENDMETHOD.
METHOD set_new_label_data.

**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

*--------------------------------V1----------------------------------*

****** V1 - Comento y cambio lógica para cambiar excepcionaes a clase, además ya no es relevante WM
*
*** Parametro IMPORT
*
*  "Comprobamos si hay datos.
*  IF ( i_s_bt_label_data IS INITIAL ).
*    RAISE no_value.
*  ENDIF.
*
*** Parámetros de la clase
*
*  "Comprobamos si la clase de utilidades está instanciada
*  " con esto comprobamos también que tenemos el centro
*  IF ( me->_io_wm_utils IS NOT BOUND ).
*    RAISE internal_error.
*  ENDIF.
*
*** Datos
*
*  me->_check_bt_data(
*    EXPORTING
*      i_s_bt_label_data = i_s_bt_label_data    " Estructura de datos para imprimir etiquetas BARTENDER
*    EXCEPTIONS
*      no_valid_data     = 1
*      no_valid_type     = 2
*      no_valid_quantity = 3
*      no_valid_ua       = 4
*      OTHERS            = 5
*  ).
*  IF sy-subrc <> 0.
*    RAISE no_data_valid.
*  ENDIF.
*
*--------------------------------V1----------------------------------*

*--------------------------------V2----------------------------------*

****** IMPORT

  "Comprobamos si hay datos.
  IF ( i_s_bt_label_data IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

****** CLASS PARAMS

  IF ( me->_lgnum IS NOT INITIAL ). "Relevante WM

    "Comprobamos si la clase de utilidades está instanciada
    " con esto comprobamos también que tenemos el centro
    IF ( me->_io_wm_utils IS NOT BOUND ).
      zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '999' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_message = CONV #( text-999 ) i_msgty = 'E' ) ).
    ENDIF.

  ENDIF.

****** CHECK DATA

  me->_check_bt_data(
    EXPORTING
      i_s_bt_label_data = i_s_bt_label_data    " Estructura de datos para imprimir etiquetas BARTENDER
    EXCEPTIONS
      no_valid_data     = 1
      no_valid_type     = 2
      no_valid_quantity = 3
      no_valid_ua       = 4
      OTHERS            = 5
  ).
  IF sy-subrc <> 0.
*    RAISE no_data_valid.
  ENDIF.

*--------------------------------V2----------------------------------*

**********************************************************************
* Añadimos registro
**********************************************************************

  APPEND i_s_bt_label_data TO _t_bartender_data.

ENDMETHOD.
METHOD set_new_label_data_4_lenum.

**********************************************************************
* Parámetros locales
**********************************************************************

*  DATA: lo_idx_manager  TYPE REF TO zcl_hp_vcpp_idx_manager,
*        lo_wm_exception TYPE REF TO zcx_wm_exception.
*
  DATA: ls_bartender_data       TYPE zst_bartender_label_data.
*        ls_matnr_data           TYPE ty_matnr_data,
*        ls_vbeln_data           TYPE ty_vbeln_data,
*        ls_kunnr_data           TYPE ty_kunnr_data,
*        lt_idx151_data          TYPE yhp_omp_tt_td151,
*
*        ls_idx100_data          TYPE yhp_idx_td100,
*        ls_idx150_data          TYPE yhp_idx_td150,
*        ls_idx151_unit_data     TYPE yhp_idx_td151,
*        ls_idx151_stack_data    TYPE yhp_idx_td151,
*        ls_idx151_group_data    TYPE yhp_idx_td151.
*
*  DATA: ls_r_lenum  TYPE zst_r_lenum,
*        lt_r_lenum  TYPE ztt_r_lenum,
*        lt_lqua     TYPE ztt_lqua,
*        ls_lqua     TYPE lqua.
*
*  DATA: lv_mjahr          TYPE mjahr,
*        lv_prole_str(14)  TYPE c,
*        lv_prowi_str(14)  TYPE c,
*        lv_prohe_str(14)  TYPE c.

**********************************************************************
* Validaciones
**********************************************************************

**** LENUM
*
*  IF ( i_lenum IS INITIAL ).
*    RAISE no_valid_iparams.
*  ENDIF.
*
**** MOVTTYPE
*
*  me->_check_mvttype(
*    EXPORTING
*      i_tipo        = i_mvttype    " Tipo de acción de etiquetado
*    EXCEPTIONS
*      no_value      = 1
*      no_valid_type = 2
*      others        = 3
*  ).
*  IF sy-subrc <> 0.
*    RAISE no_valid_iparams.
*  ENDIF.
*
**** LO_WM_UTILS
*
*  IF ( _io_wm_utils IS NOT BOUND ).
*    RAISE error_internal.
*  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

**** INFO LQUA
*
*** Montamos parámetros IMPORT
*
** LENUM
*
*  CLEAR: ls_r_lenum, lt_r_lenum.
*  MOVE 'I'          TO ls_r_lenum-sign.
*  MOVE 'EQ'         TO ls_r_lenum-option.
*  MOVE i_lenum      TO ls_r_lenum-lenum_low.
*  APPEND ls_r_lenum TO lt_r_lenum.
*
*** Obtenemos datos
*
*  _io_wm_utils->get_wm_lqua_data(
*    EXPORTING
**      i_t_r_lqnum   =     " Tabla rangos para cuantos
*      i_t_r_lenum   = lt_r_lenum    " Tabla para rangos de unidades de almacén
*    IMPORTING
*      e_s_lqua_data = lt_lqua       " Cuantos
*  ).
*
*  IF ( lines( lt_lqua ) LE 0 ).
*    RAISE no_lqua_data.
*  ENDIF.
*
**** PARA CADA CUANTO DE LA UA obtenemos datos.
*
*  LOOP AT lt_lqua INTO ls_lqua.
*
*    CLEAR: ls_bartender_data.
*
*** INFO LQUA
*
*    MOVE ls_lqua-charg TO ls_bartender_data-orderid.        "OF o lote
*    MOVE ls_lqua-matnr TO ls_bartender_data-articleref.     "Número de material
*    MOVE ls_lqua-werks TO ls_bartender_data-erpplantid.     "Centro
*    MOVE ls_lqua-gesme TO ls_bartender_data-boardspal.      "Cantidad
*
*    MOVE ls_lqua-lenum TO ls_bartender_data-sscccode.       "Código SSCC/UA
*
*** INFO MATERIAL
*
*    CLEAR: ls_matnr_data.
*
*    me->_get_data_matnr(
*      EXPORTING
*        i_matnr          = ls_lqua-matnr    " Número de material
*        i_werks          = ls_lqua-werks    " Centro
*      IMPORTING
*        e_matnr_data     = ls_matnr_data    " Datos de material
*      EXCEPTIONS
*        no_valid_iparams = 1
*        OTHERS           = 2 ).
*
*    IF ( sy-subrc EQ 0 ).
*      MOVE ls_matnr_data-productname TO ls_bartender_data-productname.  "Descrip. de material
*    ENDIF.
*
*** INFO CONFIGURACIÓN
*
*    IF ( ls_matnr_data-cuobj IS INITIAL OR ls_matnr_data-cuobj LE 0 ).
*
*      ls_matnr_data-cuobj = me->_get_cuobj_from_charg( i_matnr = ls_lqua-matnr i_charg = ls_lqua-charg ).
*
*    ENDIF.
*
*** INFO SD
*
*    CLEAR: ls_vbeln_data.
*
*    "Stock especial cliente
*    IF ( ls_lqua-sobkz EQ 'E' AND ls_lqua-sonum IS NOT INITIAL ). "Si
*
*      me->_get_data_vbeln_4_sonum(
*        EXPORTING
*          i_sonum          = ls_lqua-sonum    " Número de stock especial
*        IMPORTING
*          e_vbeln_data     = ls_vbeln_data    " Datos pedido ventas
*        EXCEPTIONS
*          no_valid_iparams = 1
*          OTHERS           = 2
*      ).
*
*      IF ( sy-subrc NE 0 ).
*
*        CLEAR: lv_mjahr.
*        MOVE ls_lqua-wdatu(4) TO lv_mjahr.
*
*        me->_get_data_vbeln_4_mblnr(
*          EXPORTING
*            i_mblnr          = ls_lqua-wenum    " Número de documento de material
*            i_mblpo          = ls_lqua-wepos    " Posición en documento de material
*            i_mjahr          = lv_mjahr         " Ejercicio del documento de material
*          IMPORTING
*            e_vbeln_data     = ls_vbeln_data    " Datos pedido ventas
*          EXCEPTIONS
*            no_valid_iparams = 1
*            OTHERS           = 2
*        ).
*
*      ENDIF.
*
*    ELSE. "No
*
*      CLEAR: lv_mjahr.
*      MOVE ls_lqua-wdatu(4) TO lv_mjahr.
*
*      me->_get_data_vbeln_4_mblnr(
*        EXPORTING
*          i_mblnr          = ls_lqua-wenum    " Número de documento de material
*          i_mblpo          = ls_lqua-wepos    " Posición en documento de material
*          i_mjahr          = lv_mjahr         " Ejercicio del documento de material
*        IMPORTING
*          e_vbeln_data     = ls_vbeln_data    " Datos pedido ventas
*        EXCEPTIONS
*          no_valid_iparams = 1
*          OTHERS           = 2
*      ).
*
*    ENDIF.
*
*    IF ( sy-subrc EQ 0 ).
*
*      MOVE ls_vbeln_data-erporderid TO ls_bartender_data-erporderid.  "Pedido de cliente
*      MOVE ls_vbeln_data-customerid TO ls_bartender_data-customerid.  "Número de cliente
*
*    ENDIF.
*
*** INFO Cliente
*
*    CLEAR: ls_kunnr_data.
*
*    "Comprobamos si tenemos número de cliente
*    IF ( ls_vbeln_data-customerid IS NOT INITIAL ). "Si.
*
*      me->_get_data_kunnr(
*        EXPORTING
*          i_kunnr          = ls_vbeln_data-customerid    " Número de deudor
*          i_vkorg          = ls_vbeln_data-vkorg         " Organización de ventas
*          i_vtweg          = ls_vbeln_data-vtweg         " Canal de distribución
*          i_matnr          = ls_lqua-matnr               " Número de material
*        IMPORTING
*          e_kunnr_data     = ls_kunnr_data    " Datos de pedido de ventas
*        EXCEPTIONS
*          no_valid_iparams = 1
*          OTHERS           = 2
*      ).
*
*      IF ( sy-subrc EQ 0 ).
*
*        MOVE ls_kunnr_data-customername TO ls_bartender_data-customername.           "Nombre cliente
*        MOVE ls_kunnr_data-entreprisenr TO ls_bartender_data-entreprisenr.           "NIF cliente
*        MOVE ls_kunnr_data-internalarticlenr TO ls_bartender_data-internalarticlenr. "Número material cliente   KNMT
*
*      ENDIF.
*
*    ENDIF.
*
*** INFO IDX
*
*  "Comprobamos si tenemos configuración
*  CREATE OBJECT lo_idx_manager
*    EXPORTING
*      i_cuobj          = ls_matnr_data-cuobj    " Configuración (número de objeto interno)
*    EXCEPTIONS
*      no_valid_iparams = 1
*      OTHERS           = 2.
*
*  IF ( lo_idx_manager IS BOUND ).
*
**ls_bartender_data-machineid            "Puesto de trabajo/maquina (no rellenamos)
**ls_bartender_data-pallettype           "Tipo de pallet (no rellenamos)
*
** IDX 100
*
*    CLEAR: ls_idx100_data, lv_prole_str, lv_prowi_str, lv_prohe_str.
*
*    lo_idx_manager->get_td100_data(
*      RECEIVING
*        e_yhp_idx_td100 = ls_idx100_data
*      EXCEPTIONS
*        no_values       = 1
*        OTHERS          = 2
*    ).
*
*    IF ( sy-subrc EQ 0 ).
*
** FSC
*
*      MOVE ls_idx100_data-fscty TO ls_bartender_data-fsccertificateinfo.   "Tipo de FSC
*
** Dimensiones
*
*      lv_prowi_str = trunc( ls_idx100_data-prowi ).
*      CONDENSE lv_prowi_str NO-GAPS.
*      lv_prole_str = trunc( ls_idx100_data-prole ).
*      CONDENSE lv_prole_str NO-GAPS.
*      lv_prohe_str = trunc( ls_idx100_data-prohe ).
*      CONDENSE lv_prohe_str NO-GAPS.
*
*      CONCATENATE lv_prole_str 'X' lv_prowi_str 'X' lv_prohe_str INTO ls_bartender_data-internaldimensions.   "Dimensiones internas producto
*
*    ENDIF.
*
** IDX 150
*
*    CLEAR: ls_idx150_data.
*
*    lo_idx_manager->get_td150_data(
*      RECEIVING
*        e_yhp_idx_td150 = ls_idx150_data
*      EXCEPTIONS
*        no_values       = 1
*        OTHERS          = 2
*    ).
*
*    IF ( sy-subrc EQ 0 ).
*
*      MOVE ls_idx150_data-tlabl TO ls_bartender_data-rfidlabeltype.         "Tipo de etiqueta
*      MOVE ls_idx150_data-bcean TO ls_bartender_data-myeannumber.           "Código EAN
*      MOVE ls_idx150_data-pbcod TO ls_bartender_data-strapperinstructions.  "Instrucciones paletizado
*
*    ENDIF.
*
** IDX 151 -> UNIT y STACK
*
*    CLEAR: lt_idx151_data, ls_idx151_group_data, ls_idx151_stack_data, ls_idx151_unit_data.
*
*    lo_idx_manager->get_td151_data_all(
*      RECEIVING
*        e_yhp_tt_idx_td151 = lt_idx151_data
*      EXCEPTIONS
*        no_valid_iparams   = 1
*        no_values          = 2
*        others             = 3
*    ).
*
*    IF ( sy-subrc EQ 0 ).
*
** Paquete
*
*      "Obtengo datos a nivel de paquete
*      READ TABLE lt_idx151_data INTO ls_idx151_group_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_group.
*
*      IF ( sy-subrc NE 0 ). "No existe nivel paquete --> Adoptamos pila como paquete
*
*        "Obtengo datos a nivel de paquete
*        READ TABLE lt_idx151_data INTO ls_idx151_group_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_stack.
*
*      ENDIF.
*
** Pila
*
*      "Obtengo datos a nivel de pila
*      READ TABLE lt_idx151_data INTO ls_idx151_stack_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_stack.
*
** Palé
*
*      "Obtengo datos a nivel de pila
*      READ TABLE lt_idx151_data INTO ls_idx151_unit_data WITH KEY shuty = zcl_hp_vcpp_idx_manager=>s_c_level_unit.
*
** Obtenemos datos
*
*      MOVE ls_idx151_group_data-prqty TO ls_bartender_data-mybundlenofblanks.               "Cajas en paquete --> GROUP (prev. quant. )
*      MOVE ls_idx151_unit_data-prqty TO ls_bartender_data-bundlenofnext.                    "Paquetes en una capa  --> UNIT (prev. quant. )
*      ls_bartender_data-layernof = ls_idx151_stack_data-prqty * ls_idx151_unit_data-prqty.  "Número de paquetes en pallet --> STACK (prev. quant.) x UNIT (prev. quant.)
*
**     "Comento: cantidad en palé sustituimos por cantidad de la UA
**      MOVE ls_idx151_unit_data-tbqty TO ls_bartender_data-boardspal.                        "Cantidad en pallet --> UNIT (total quant.)
*
*    ENDIF.
*
*  ENDIF.
*
*** OTROS
*
*  MOVE i_mvttype TO ls_bartender_data-mvttype.    "Tipo de movimiento BARTENDER
*  MOVE sy-datum  TO ls_bartender_data-datestring. "Fecha
*
**ls_bartender_data-count                "Contador (no rellenamos)
**ls_bartender_data-lastpallet           "Último pallet (no rellenamos)
**ls_bartender_data-barcodestring        (no rellenamos)
**ls_bartender_data-barcodestring1       (no rellenamos)
**ls_bartender_data-barcodestring1str    (no rellenamos)
**ls_bartender_data-barcodestring2       (no rellenamos)
**ls_bartender_data-barcodestring2str    (no rellenamos)
**ls_bartender_data-barcodestring3       (no rellenamos)
**ls_bartender_data-islastpallet         "Último pallet? (no rellenamos)
**ls_bartender_data-labelnofperpallet    (no rellenamos)
*
*** AJUSTES FINALES
*
*  "Si no tenemos rfidlabeltype (Tipo de etiqueta) lo fijamos a genérica
*  IF ( ls_bartender_data-rfidlabeltype IS INITIAL ).
*    MOVE '0' TO ls_bartender_data-rfidlabeltype.
*  ENDIF.
*
**** Insertamos datos en tabla para imprimir.
*
*    me->set_new_label_data(
*      EXPORTING
*        i_s_bt_label_data = ls_bartender_data    " Estructura de datos para imprimir etiquetas BARTENDER
*      EXCEPTIONS
*        no_value          = 1
*        no_data_valid     = 2
*        no_data_added     = 3
*        internal_error    = 4
*        others            = 5
*    ).
*    IF ( sy-subrc NE 0 ).
*      RAISE no_valid_data.
*    ENDIF.
*
*  ENDLOOP.

****** V2 Comento por cambio de lógica
*
*  me->create_label_data_4_lenum(
*    EXPORTING
*      i_mvttype         = i_mvttype    " Tipo de movimiento para BARTENDER
*      i_lenum           = i_lenum    " Número de unidad de almacén
*    RECEIVING
*      e_s_bt_label_data = ls_bartender_data    " Estructura de datos para imprimir etiquetas BARTENDER
*    EXCEPTIONS
*      no_valid_iparams  = 1
*      no_lqua_data      = 2
*      error_internal    = 3
*      no_valid_data     = 4
*      others            = 5
*  ).
*  IF ( sy-subrc EQ 0 ).
*
**** Insertamos datos en tabla para imprimir.
*
*    me->set_new_label_data( i_s_bt_label_data = ls_bartender_data ).
*
*  ENDIF.
*

  me->set_new_label_data( i_s_bt_label_data = me->create_label_data( i_mvttype = i_mvttype i_lenum = CONV #( i_lenum ) ) ).

ENDMETHOD.
METHOD set_new_label_data_4_old_lenum.

**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_exception TYPE REF TO zcx_exception.


**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

****** MVTTYPE

  me->_check_mvttype(
    EXPORTING
      i_tipo        = i_mvttype    " Tipo de acción de etiquetado
    EXCEPTIONS
      no_value      = 1
      no_valid_type = 2
      OTHERS        = 3
  ).
  IF sy-subrc <> 0.
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

****** LENUM

  IF ( i_lenum IS INITIAL ).
    zcl_utils=>zif_msg_utils~s_launch_exception( i_textid = zcl_utils=>zif_msg_utils~s_create_raising_message( i_msgno = '001' i_msgid = zcl_wm_bartender_print_manager=>_c_class_label i_msgty = 'E' ) ).
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

  TRY.

    "Intento ver si la UA existe...
    "Si existe actualmente la seteo y salgo, no lanzo error

    me->set_new_label_data_4_lenum( i_mvttype = i_mvttype i_lenum = i_lenum ).
    READ TABLE me->_t_bartender_data WITH KEY sscccode = CONV #( |{ i_lenum ALPHA = IN }| ) TRANSPORTING NO FIELDS.
    IF ( sy-subrc = 0 ).
      EXIT.
    ENDIF.

  CATCH zcx_exception.
    "No controlamos, si da excepción es que la UA no existe actualmente y continúo para recuperar de histórico
  ENDTRY.

****** GET HISTORICAL DATA

  me->set_new_label_data( i_s_bt_label_data = me->_create_label_data_4_old_lenum( i_mvttype = i_mvttype i_lenum = i_lenum ) ).

ENDMETHOD.
METHOD SET_NEW_LABEL_DATA_LIST.

  DATA: ls_bartender_data TYPE zst_bartender_label_data,
        ls_bapiret        TYPE bapiret2,
        lv_symsgv1        TYPE symsgv,
        lv_symsgv2        TYPE symsgv.

  LOOP AT i_t_bt_label_data INTO ls_bartender_data.

    CLEAR: ls_bapiret, lv_symsgv1, lv_symsgv2.

    TRY .
      me->set_new_label_data( i_s_bt_label_data = ls_bartender_data ).
      APPEND me->_create_bapiret2( i_type = 'S' i_number = '000' i_message = text-001 i_message_v1 = CONV #( ls_bartender_data-barcodestring3 ) ) TO r_t_return.
    CATCH zcx_exception INTO DATA(lo_exception).
      APPEND me->_create_bapiret2( i_type = 'E' i_number = lo_exception->if_t100_message~t100key-msgno i_message = CONV #( lo_exception->if_t100_message~t100key-attr1 ) ) TO r_t_return.
    ENDTRY.

  ENDLOOP.

ENDMETHOD.
