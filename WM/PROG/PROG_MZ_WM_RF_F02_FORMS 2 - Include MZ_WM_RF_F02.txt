*&---------------------------------------------------------------------*
*&  Include           MZ_WM_RF_F02
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  GET_SU_DATA
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM get_su_data  USING   p_lenum
                CHANGING   e_error.

  CLEAR e_error.
  IF sy-tcode <> gc_tcode_outdeliv_pend.
    REFRESH gt_reubic.
  ENDIF.
  CLEAR gs_reubic.
*
  PERFORM get_lein USING p_lenum
                CHANGING e_error.
  CHECK e_error IS INITIAL.
  PERFORM get_lqua USING gs_lein-lgnum
                         gs_lein-lenum
                CHANGING e_error.
  CHECK e_error IS INITIAL.
  PERFORM get_makt USING gs_lqua-matnr.
ENDFORM.
FORM get_ubic_prop.
  DATA l_tabix LIKE sy-tabix.
  DATA lt_lqua_ub TYPE TABLE OF lqua
          WITH HEADER LINE.
  DATA l_verme_ub LIKE lqua-verme.
  REFRESH gt_prop.
  IF NOT gt_reubic[] IS INITIAL.
    LOOP AT gt_reubic. " INS cvivo - 58678 CB UI5
      l_tabix = sy-tabix.

      CALL FUNCTION 'ZWM_UBICACION_PROPUESTA'
        EXPORTING
          lgnum      = gt_reubic-lgnum
          matnr      = gt_reubic-matnr
          verme      = gt_reubic-verme
        IMPORTING
          nltyp_prop = gt_reubic-nltyp_prop
          nlpla_prop = gt_reubic-nlpla_prop.

      gt_reubic-nlpla = gt_lagp-lgpla.

      CALL FUNCTION 'ZWM_CAPACIDAD_UBICACION'
        EXPORTING
          lgnum      = gt_reubic-lgnum
          lgpla      = gt_reubic-nlpla_prop
        IMPORTING
          disponible = gt_reubic-peso_libre
          gewei      = gt_reubic-peso_um
*         TOTAL      =
        .

      MODIFY gt_reubic
        INDEX l_tabix
        TRANSPORTING nltyp_prop nltyp
                     nlpla_prop nlpla
                     peso_libre peso_um.
    ENDLOOP.


*    SELECT * INTO TABLE gt_prop " DEL cvivo - 58678 CB UI5
*      FROM zwm_rf_ubic_prop
*      FOR ALL ENTRIES IN gt_reubic
*      WHERE lgnum = g_lgnum AND
*            matnr = gt_reubic-matnr.
*    SORT gt_prop BY matnr sequence.
*    LOOP AT gt_reubic.
*      l_tabix = sy-tabix.
*      gt_prop_aux[] = gt_prop[].
*      DELETE gt_prop_aux
*        WHERE matnr <> gt_reubic-matnr.
*      IF NOT gt_prop_aux[] IS INITIAL.
*        SELECT * INTO TABLE gt_lagp
*          FROM lagp
*          FOR ALL ENTRIES IN gt_prop_aux
*          WHERE lgnum = gt_prop_aux-lgnum AND
*                lgtyp = gt_prop_aux-lgtyp AND
*                lgpla = gt_prop_aux-lgpla.
*        SORT gt_lagp
*          BY bdatu DESCENDING.
**          BY wdatu DESCENDING.
**          BY bdatu ASCENDING.
**
*        LOOP AT gt_lagp.
*          SELECT SUM( verme )
*            INTO l_verme_ub
*            FROM lqua
*            WHERE lgnum = gt_lagp-lgnum AND
*                  lgtyp = gt_lagp-lgtyp AND
*                  lgpla = gt_lagp-lgpla.
*          l_verme_ub = l_verme_ub + gt_reubic-verme.
*          IF l_verme_ub > gt_lagp-lgewi AND
*             NOT gt_lagp-lgewi IS INITIAL.
**          IF gt_lagp-anzqu >= gt_lagp-maxqu OR
**             gt_lagp-anzle >= gt_lagp-maxle.
*            CONTINUE.
*          ELSE.
*            gt_reubic-nltyp_prop = gt_lagp-lgtyp.
*            gt_reubic-nlpla_prop = gt_lagp-lgpla.
**            gt_reubic-nltyp = gt_lagp-lgtyp.
*            gt_reubic-nlpla = gt_lagp-lgpla.
*            MODIFY gt_reubic
*              INDEX l_tabix
*              TRANSPORTING nltyp_prop nltyp
*                           nlpla_prop nlpla.
*
*            EXIT.
*          ENDIF.
*        ENDLOOP.
*      ENDIF.
*  ENDLOOP.
  ENDIF.
*gs_reubic-nlpla
  g_lqua_index = 1.
  READ TABLE gt_reubic INTO gs_reubic
    INDEX g_lqua_index.
  CLEAR: gs_reubic-nlpla, gs_lqua. " limpiamos ubicación destino, hay que leerla con pistola
  MOVE-CORRESPONDING gs_reubic TO gs_lqua.
  DESCRIBE TABLE gt_lqua LINES g_lqua_tot.
ENDFORM.
FORM list_ua  USING   gs_lqua STRUCTURE lqua
                      l_org
           CHANGING   e_error.

  DATA ls_makt TYPE makt.
  DATA lt_makt TYPE TABLE OF makt.
  DATA l_ctd TYPE char7.

  CLEAR e_error.
  REFRESH: gt_lqua.
*  por ubicación
  IF NOT gs_lqua-lgpla IS INITIAL.
    SELECT * INTO TABLE gt_lqua
      FROM lqua
      WHERE lgnum = g_lgnum AND
            lgpla = gs_lqua-lgpla.
  ELSEIF NOT gs_lqua-matnr IS INITIAL.
    SELECT * INTO TABLE gt_lqua
      FROM lqua
      WHERE lgnum = g_lgnum AND
            matnr = gs_lqua-matnr.
  ENDIF.

  IF NOT gt_lqua[] IS INITIAL.
    SELECT * INTO TABLE lt_makt
           FROM makt FOR ALL ENTRIES IN gt_lqua
           WHERE matnr = gt_lqua-matnr AND spras = sy-langu.

  ENDIF.

  CLEAR: gt_select_list[],gt_select_list.
* convertimos a unidad del almacen.
  LOOP AT gt_lqua ASSIGNING FIELD-SYMBOL(<stock>).
    PERFORM convertir_uni USING <stock>-matnr CHANGING <stock>-verme <stock>-meins .
  ENDLOOP.

  SORT gt_lqua BY matnr verme ASCENDING. " cvivo - WM CB

  LOOP AT gt_lqua.
    gt_select_list-cod = 'TR'.
    gt_select_list-obj_number = gt_lqua-lenum.
    gt_select_list-obj_numberc = gt_select_list-obj_number.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
      EXPORTING
        input  = gt_select_list-obj_numberc
      IMPORTING
        output = gt_select_list-obj_numberc.
    READ TABLE lt_makt INTO ls_makt WITH KEY matnr = gt_lqua-matnr.

    WRITE gt_lqua-verme TO l_ctd DECIMALS 0.
    IF l_org = 'M'.
* consulta d ematerial
      CONCATENATE gt_lqua-lgpla
                  '-'
                  l_ctd
                  gt_lqua-meins
                  INTO gt_select_list-obj_number_alt SEPARATED BY space.
    ELSE.
* consulta de ubicacion
      CONCATENATE ls_makt-maktx(28)
                  '-'
                  l_ctd
                  gt_lqua-meins
                  INTO gt_select_list-obj_number_alt SEPARATED BY space.
    ENDIF.
*      gt_select_list-obj_numberc = gt_lqua-lenum.
*      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
*        EXPORTING
*          input  = gt_select_list-obj_numberc
*        IMPORTING
*          output = gt_select_list-obj_numberc.
*      gt_select_list-obj_number_alt = gt_select_list-obj_numberc.
    APPEND gt_select_list.
  ENDLOOP.
  IF sy-subrc IS INITIAL.
    g_local_previous_screen = sy-dynnr.
    CALL SCREEN 9997.
  ELSE.
*Rellene una UA
    g_message_number = '016'.
    g_message_type = 'A'.
    CLEAR g_msgv1.
    CLEAR g_msgv2.
    CLEAR g_msgv3.
    CLEAR g_msgv4.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
  ENDIF.
  IF g_lenum IS INITIAL.
    e_error = abap_true.
  ELSE.
    REFRESH gt_reubic.
    CLEAR gs_reubic.
*
    PERFORM get_lein USING g_lenum
                  CHANGING e_error.
    CHECK e_error IS INITIAL.
    PERFORM get_lqua USING gs_lein-lgnum
                           gs_lein-lenum
                  CHANGING e_error.
    CHECK e_error IS INITIAL.
*    PERFORM get_makt USING gs_lqua-matnr.
    READ TABLE lt_makt INTO gs_makt WITH KEY matnr = gs_lqua-matnr.
  ENDIF.
ENDFORM.
FORM get_makt USING p_matnr.
  CLEAR gs_makt.
  SELECT SINGLE * INTO gs_makt
    FROM makt
    WHERE matnr = p_matnr.
ENDFORM.
FORM get_lein USING p_lenum
           CHANGING e_error.
  DATA: text(20).
  CLEAR e_error.
  CLEAR gs_lein.
  SELECT SINGLE * INTO gs_lein
    FROM lein
    WHERE lenum = p_lenum.
  IF sy-subrc IS INITIAL.
    IF g_lgnum <> gs_lein-lgnum.
*   La UA & no existe en el Almacén &
      g_message_number = '006'.
      g_message_type = 'A'.
      g_msgv1 = p_lenum.
      g_msgv2 = g_lgnum.
      CLEAR g_msgv3.
      CLEAR g_msgv4.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      e_error = abap_true.
    ENDIF.
  ELSE.
*    WRITE p_lenum(19) TO text RIGHT-JUSTIFIED.
*    CLEAR p_lenum.
*    text(1) = 0.
*    p_lenum = text.
*
*    SELECT SINGLE * INTO gs_lein
*      FROM lein
*      WHERE lenum = p_lenum.
*
*    IF sy-subrc NE 0.
*   La UA & no existe en el Almacén &
    g_message_number = '006'.
    g_message_type = 'A'.
    g_msgv1 = p_lenum.
    CLEAR g_msgv2.
    CLEAR g_msgv3.
    CLEAR g_msgv4.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    e_error = abap_true.
    CLEAR p_lenum.
*    ENDIF.
  ENDIF.
ENDFORM.
FORM get_lqua USING p_lgnum
                    p_lenum
                CHANGING e_error.
  DATA l_tabix LIKE sy-tabix.
  RANGES: lr_charg FOR lips-charg.
  DATA ls_charg LIKE LINE OF lr_charg.
  CLEAR e_error.
  CLEAR g_lqua_index.
  CLEAR g_lqua_tot.
  REFRESH gt_lqua.
  CLEAR gs_lqua.
  SELECT  * INTO TABLE gt_lqua
    FROM lqua
    WHERE lgnum = p_lgnum AND
          lenum = p_lenum AND
          verme > 0.
  IF NOT gt_lqua[] IS INITIAL.
    IF sy-tcode <> gc_tcode_outdeliv_pend.
      REFRESH gt_reubic.
    ELSE.
      REFRESH gt_reubic_aux.
    ENDIF.

* cvivo - verificamos si ya se ha leído
    READ TABLE gt_reubic WITH KEY lenum = p_lenum TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      MESSAGE 'Ya se había leído esa unidad de almacén' TYPE 'S'.
      CLEAR g_lenum.
      EXIT.
    ENDIF.

    LOOP AT gt_lqua INTO gs_lqua.
      CLEAR gs_reubic.
      MOVE-CORRESPONDING gs_lqua TO gs_reubic.
*      DISPONIBLE
*      gs_reubic-verme
* convertimos a unidad de wm las cantidades
      gs_reubic-verme_wm = gs_reubic-verme.
      gs_reubic-meins_wm = gs_reubic-meins.

      PERFORM convertir_uni USING gs_reubic-matnr CHANGING gs_reubic-verme_wm gs_reubic-meins_wm.
      gs_reubic-ctd_prop = gs_reubic-verme_wm.
      gs_reubic-ctd_conf = gs_reubic-verme_wm.
      gs_reubic-vltyp = gs_reubic-lgtyp.
      gs_reubic-vlpla = gs_reubic-lgpla.
*      TOTAL
*      gs_reubic-VERME
      IF sy-tcode <> gc_tcode_outdeliv_pend.
        APPEND gs_reubic TO gt_reubic.
      ELSE.
        gs_reubic-ctd_conf = gs_reubic-verme.
        CLEAR lr_charg.
        READ TABLE gt_lips WITH KEY charg = gs_lqua-charg.
        IF sy-subrc IS INITIAL.
          ls_charg = 'IEQ'.
          ls_charg-low = gs_lqua-charg.
          APPEND ls_charg TO lr_charg.
        ELSE. " cvivo - 66752 - si no se encuentra posición con lote, debe haber posición SIN lote
          ls_charg = 'IEQ'.
          ls_charg-low = space.
          APPEND ls_charg TO lr_charg.
        ENDIF.
        LOOP AT gt_lips
          WHERE matnr = gs_reubic-matnr AND
                ormng GE gs_reubic-ctd_conf AND " cvivo - 11/07/2019 - Control de cantidad pendiente
                charg IN lr_charg.
          IF gt_lips-ormng < gs_reubic-ctd_conf. " cvivo - 11/07/2019 - Esto no llega a pasar, si no no podría haber > 1 posición por material
            g_message_number = '060'.
            g_message_type = 'A'.
            g_msgv1 = gs_reubic-lenum.
            PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
            e_error = abap_true.
            CLEAR g_lenum.
          ELSE.
            l_tabix = sy-tabix.
            IF gt_lips-ormng > gs_reubic-ctd_conf.
              gt_lips-ormng = gt_lips-ormng
                            - gs_reubic-ctd_conf.
            ELSE.
              gs_reubic-ctd_conf = gt_lips-ormng.
              CLEAR gt_lips-ormng.
            ENDIF.
            MODIFY gt_lips INDEX l_tabix
                TRANSPORTING ormng.
            gs_reubic-posnrv = gt_lips-posnr.
            APPEND gs_reubic TO gt_reubic_aux.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF NOT sy-subrc IS INITIAL.
          LOOP AT gt_lips WHERE matnr = gs_reubic-matnr AND
                                charg IN lr_charg.
            EXIT.
          ENDLOOP.
          IF sy-subrc IS INITIAL.
            g_message_number = '052'.
            g_message_type = 'A'.
            g_msgv1 = gs_reubic-matnr.
*    g_msgv2 = p_lgnum.
            CLEAR g_msgv2.
            CLEAR g_msgv3.
            CLEAR g_msgv4.
            PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
            e_error = abap_true.
            CLEAR g_lenum.
            EXIT.
          ELSE.
            g_message_number = '051'.
            g_message_type = 'A'.
            g_msgv1 = p_lenum.
*    g_msgv2 = p_lgnum.
            CLEAR g_msgv2.
            CLEAR g_msgv3.
            CLEAR g_msgv4.
            PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
            e_error = abap_true.
            CLEAR g_lenum.
            EXIT.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

****
    IF sy-tcode = gc_tcode_outdeliv_pend.
      IF e_error = abap_true.
        EXIT.
      ENDIF.
      APPEND LINES OF gt_reubic_aux TO gt_reubic.
      DESCRIBE TABLE gt_reubic LINES g_lqua_tot.
      g_lqua_index = g_lqua_tot.
      READ TABLE gt_reubic INTO gs_reubic
        INDEX g_lqua_index.
      CLEAR gs_lqua.
      MOVE-CORRESPONDING gs_reubic TO gs_lqua.
    ELSE.
      g_lqua_index = 1.
      READ TABLE gt_reubic INTO gs_reubic
        INDEX g_lqua_index.
      CLEAR gs_lqua.
      MOVE-CORRESPONDING gs_reubic TO gs_lqua.
      DESCRIBE TABLE gt_lqua LINES g_lqua_tot.
    ENDIF.
  ELSE.
*   La UA & no existe en el Almacén &
    g_message_number = '006'.
    g_message_type = 'A'.
    g_msgv1 = p_lenum.
    g_msgv2 = p_lgnum.
    CLEAR g_msgv3.
    CLEAR g_msgv4.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    e_error = abap_true.
    CLEAR g_lenum.
  ENDIF.
ENDFORM.
FORM create_ot_su
          USING i_lgnum
                i_lenum
                i_nltyp
                i_nlpla
                i_nlber
                i_bwlvs
       CHANGING r_tanum
                e_error.
  CLEAR e_error.
  DATA l_bwlvs TYPE bwlvs.

*IF i_bwlvs IS INITIAL.
*  l_bwlvs = gst_zwm_rf0001-bwlvs.
*ELSE.
  l_bwlvs = i_bwlvs.
*ENDIF.
  CALL FUNCTION 'HU_PACKING_REFRESH'.
  CALL FUNCTION 'L_TO_CREATE_MOVE_SU'
    EXPORTING
      i_lenum               = i_lenum
      i_bwlvs               = l_bwlvs
      i_nltyp               = i_nltyp
      i_nlber               = i_nlber
      i_nlpla               = i_nlpla
      i_squit               = abap_true
*     i_squit               = i_squit
      i_commit_work         = abap_true
*     i_commit_work         = i_commit
*     i_bname               = i_bname
    IMPORTING
      e_tanum               = r_tanum
    EXCEPTIONS
      not_confirmed_to      = 1
      foreign_lock          = 2
      bwlvs_wrong           = 3
      betyp_wrong           = 4
      nltyp_wrong           = 5
      nlpla_wrong           = 6
      nltyp_missing         = 7
      nlpla_missing         = 8
      squit_forbidden       = 9
      lgber_wrong           = 10
      xfeld_wrong           = 11
      drukz_wrong           = 12
      ldest_wrong           = 13
      no_stock_on_su        = 14
      su_not_found          = 15
      update_without_commit = 16
      no_authority          = 17
      benum_required        = 18
      ltap_move_su_wrong    = 19
      lenum_wrong           = 20
      OTHERS                = 21.
  IF sy-subrc <> 0.
    e_error = abap_true.

    IF sy-subrc EQ 2.
      SELECT SINGLE * FROM lein
        WHERE lenum EQ @i_lenum
        INTO @DATA(ls_lein).

      IF sy-subrc EQ 0.
        CALL FUNCTION 'L_BIN_LOCATION_DEQUEUE'
          EXPORTING
            i_lgnum = ls_lein-lgnum
            i_lgtyp = ls_lein-lgtyp
            i_lgpla = ls_lein-lgpla
            i_lenum = i_lenum.
      ENDIF.
    ENDIF.
* sy-msgid
*  sy-msgno ).
  ELSE.
    DATA l_uzeit_end TYPE uzeit.
    DATA l_uzeit TYPE uzeit.
    DATA l_tanum TYPE tanum.
* CHECK TANUM
    GET TIME.
    l_uzeit_end = sy-uzeit + 15.
    DO.
      SELECT SINGLE tanum INTO l_tanum
      FROM ltak
      WHERE tanum = r_tanum.
      IF sy-subrc IS INITIAL.
        EXIT.
      ENDIF.
      GET TIME.
      l_uzeit = sy-uzeit.
      IF l_uzeit_end <= l_uzeit.
        EXIT.
      ENDIF.
    ENDDO.
  ENDIF.

ENDFORM.
" DEL - cvivo - 60831 La única diferencia con el MENSAJES es el ancho de línea, nos ajustamos a ése
*FORM mensajes2.
*  DATA ls_msg_text TYPE t100.
*  DATA: l_line_in         LIKE sprot-line,
*        l_line_out        LIKE sprot-line,
*        l_field_name      LIKE dd03d-fieldname,
*        l_message_length  TYPE i,
*        l_line_count      TYPE i VALUE 1,
*        l_line_count_c(2) TYPE c,
*        l_mess_pos        TYPE i VALUE 0,
*        l_line_pos        TYPE i,
*        l_from_pos        TYPE i,
*        l_length          TYPE i,
*        l_test_char(1)    TYPE c,
*        l_line_offset     TYPE i,
*        l_msgid           LIKE t100-arbgb,
*        l_lang            LIKE t100-sprsl,
*        l_msgno           LIKE t100-msgnr,
*        l_msgv1           LIKE sprot_u-var1,
*        l_msgv2           LIKE sprot_u-var2,
*        l_msgv3           LIKE sprot_u-var3,
*        l_msgv4           LIKE sprot_u-var4,
*        l_seperate        LIKE sprot_i-xfeld,
*        l_condense        LIKE sprot_i-xfeld,
*        l_message_screen  LIKE sy-dynnr,
*        l_line_size       TYPE i,
*        l_lines           TYPE i,
*        l_non_lmob_envt   TYPE c,
*        l_modpl           LIKE t3130c-modpl.
*
*  FIELD-SYMBOLS:
*    <mess_field>.
*
*  CLEAR:  g_message1,
*          g_message2,
*          g_message3,
*          g_message4,
*          g_message5,
*          g_message6,
*          g_message7.
*
*  IF g_msgid = space.
*    l_msgid                = 'ZWM_RF'.
*  ELSE.
*    l_msgid = g_msgid.
*  ENDIF.
*  l_lang                 = 'S'.
*  l_msgno                = g_message_number.
*  l_msgv1                = g_msgv1.
*  l_msgv2                = g_msgv2.
*  l_msgv3                = g_msgv3.
*  l_msgv4                = g_msgv4.
*
*
*  l_line_size = 30.
*  l_lines  = 4.
*
**  REFRESH lt_msg_text.
*  SELECT SINGLE * FROM t100 INTO ls_msg_text
*        WHERE  sprsl   =  l_lang
*        AND    arbgb   =  l_msgid
*        AND    msgnr   =  l_msgno.
*
*  MOVE ls_msg_text-text TO l_line_in.
*
** insert message variables
*  CALL FUNCTION 'TRINT_PUT_VARS_INTO_LINE'
*    EXPORTING
*      iv_line          = l_line_in
*      iv_var1          = l_msgv1
*      iv_var2          = l_msgv2
*      iv_var3          = l_msgv3
*      iv_var4          = l_msgv4
*      iv_with_sep      = l_seperate  "to put param in quotes
*      iv_condense_vars = l_condense
*    IMPORTING
*      ev_line          = l_line_out.
*
*  l_message_length  = strlen( l_line_out ).
*
*  IF 1 > 3.
**........Unable to process message ID number...........................*
*  ENDIF.
*
** split message text into lines.........................................
*  l_line_offset = l_line_size - 1.
*
*  WHILE l_line_count <= l_lines AND l_mess_pos < l_message_length.
*
*    l_line_count_c = l_line_count.
*    CONCATENATE 'G_MESSAGE' l_line_count_c INTO l_field_name.
*    ASSIGN (l_field_name) TO <mess_field>.
*    l_line_pos = 0.
*
*    WHILE l_line_pos < l_line_size AND l_mess_pos < l_message_length.
*
*      <mess_field>+l_line_pos(1) = l_line_out+l_mess_pos(1).
*
*      l_line_pos = l_line_pos + 1.
*      l_mess_pos = l_mess_pos + 1.
*
*    ENDWHILE.
*
*    IF  l_mess_pos < l_message_length.
*
*      l_test_char = abap_true.
*
*      WHILE ( NOT ( l_test_char IS INITIAL ) ) AND  ( l_line_pos > 0 ).
*
*        l_line_pos = l_line_pos - 1.
*        l_mess_pos = l_mess_pos - 1.
*        l_test_char = <mess_field>+l_line_pos(1).
*
*      ENDWHILE.
*
*      IF l_line_pos > 0 AND l_line_pos < l_line_offset.
*
*        CLEAR <mess_field>.
*        l_from_pos = l_mess_pos - l_line_pos.
*        l_length   = l_line_pos + 1.
*        <mess_field> =  l_line_out+l_from_pos(l_length).
*
*      ELSEIF l_line_pos = 0.
*        l_mess_pos = l_mess_pos + l_line_offset.
*      ENDIF.
*      l_mess_pos = l_mess_pos + 1.
*
*      IF NOT ( <mess_field> IS INITIAL ).
*        l_line_count = l_line_count + 1.
*      ENDIF.
*    ENDIF.
*  ENDWHILE.
*
*  g_msg-msgty = g_message_type.
*  g_msg-msgid = l_msgid.
*  g_msg-msgno = g_message_number.
*  g_msg-msgv1 = g_msgv1.
*  g_msg-msgv2 = g_msgv2.
*  g_msg-msgv3 = g_msgv3.
*  g_msg-msgv4 = g_msgv4.
*
*  CALL FUNCTION 'BAL_LOG_MSG_ADD'
*    EXPORTING
*      i_log_handle     = g_log_handle
*      i_s_msg          = g_msg
*    EXCEPTIONS
*      log_not_found    = 1
*      msg_inconsistent = 2
*      log_is_full      = 3
*      OTHERS           = 4.
*
*  CLEAR g_msg.
*  APPEND g_log_handle TO gt_log_handle.
*
*  CALL FUNCTION 'BAL_DB_SAVE'
*    EXPORTING
*      i_t_log_handle   = gt_log_handle
*    EXCEPTIONS
*      log_not_found    = 1
*      save_not_allowed = 2
*      numbering_error  = 3
*      OTHERS           = 4.
*
*  REFRESH: gt_log_handle.
*  CLEAR: l_msgv1,
*         l_msgv2,
*         l_msgv3,
*         l_msgv4,
*         g_msgid.
*
*  IF g_message_type = 'E'.
*    CALL SCREEN '9999'.
*  ELSEIF g_message_type = 'W'.
*    CALL SCREEN '9998'.
*  ELSEIF g_message_type = 'S'.
*    CALL SCREEN '9999'.
*  ENDIF.
*
*ENDFORM.                    " MENSAJES2
*&---------------------------------------------------------------------*
*&      Form  GET_LIPS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_lips .
  REFRESH gt_lips.
  SELECT * INTO TABLE gt_lips
    FROM lips
    WHERE vbeln = gs_likp-vbeln.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  GET_DELIVERY_PEND_LIST
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM get_delivery_pend_list.
  DATA l_ebelp LIKE ekpo-ebelp.
  REFRESH gt_lips.
  REFRESH gt_ekpo.

  " cvivo - 55810 corregimos situación en que la EM está pendiente pero WM no
  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_lips
    FROM lips AS a
    INNER JOIN vbup AS c
      ON a~vbeln = c~vbeln AND
         a~posnr = c~posnr
    WHERE a~werks = gs_param-werks AND
          a~lgort = gs_param-lgort AND
          ( c~wbsta = 'A' OR c~wbsta = 'B' ).

  IF gt_lips[] IS INITIAL.
*          el albarán & no existe.
    g_message_number = '045'.
    g_message_type = 'A'.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
  ELSE.
*    IF NOT gt_lips[] IS INITIAL.
    SORT gt_lips.
    DELETE ADJACENT DUPLICATES FROM gt_lips COMPARING vbeln posnr.

    LOOP AT gt_lips.
* chequeamos si es de subcontratacion -> cvivo, no se puede meter en inner join porque VGPOS <> EBELP
      l_ebelp = gt_lips-vgpos.
      SELECT SINGLE ebeln INTO gt_lips-vgbel
        FROM ekpo
        WHERE ebeln = gt_lips-vgbel AND
              ebelp = l_ebelp AND
              pstyp = gc_pstyp_subcont.
      IF NOT sy-subrc IS INITIAL.
*no es de subcontratacion
        DELETE gt_lips.
      ENDIF.
    ENDLOOP.

    REFRESH gt_lips_aux[].
    gt_lips_aux[] = gt_lips[].

    SORT gt_lips_aux.
    DELETE ADJACENT DUPLICATES FROM gt_lips_aux COMPARING vbeln.
    REFRESH gt_likp.
    REFRESH gt_lfa1.
    IF NOT gt_lips_aux[] IS INITIAL.
      SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_likp
        FROM likp
        FOR ALL ENTRIES IN gt_lips_aux
        WHERE vbeln = gt_lips_aux-vbeln.
      SORT gt_likp BY vbeln.
      IF NOT gt_likp[] IS INITIAL.
        SELECT lifnr name1 name2 name3 name4
          INTO CORRESPONDING FIELDS OF TABLE gt_lfa1
          FROM lfa1
          FOR ALL ENTRIES IN gt_likp
          WHERE lifnr = gt_likp-lifnr.
        SORT gt_lfa1 BY lifnr.
      ENDIF.
    ENDIF.

    gt_lips_aux[] = gt_lips[].

    REFRESH gt_select_list.
    LOOP AT gt_likp.
      CLEAR gt_select_list.
      gt_select_list-obj_number = sy-tabix.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = gt_likp-vbeln
        IMPORTING
          output = gt_select_list-obj_numberc.


      CONCATENATE gt_lfa1-name1
                  gt_lfa1-name2
                  gt_lfa1-name3
                  gt_lfa1-name4
        INTO gt_select_list-obj_number_alt
        SEPARATED BY space.

      APPEND gt_select_list.
    ENDLOOP.
* Llamamos la pantalla de confirmacion de bobinas.

    CLEAR g_partial_list.
    CLEAR g_partial_list_0086.
    CLEAR g_partial_list_0091.
    DO.
      g_local_previous_screen = sy-dynnr.
      CALL SCREEN 9997.
      IF ok_code = 'BACK'.
        EXIT.
      ENDIF.
      READ TABLE gt_likp INTO gs_likp INDEX g_select_object.
*      gs_likp-vbeln = gt_lips_aux-vbeln.
      gt_lips[] = gt_lips_aux[].

      "KYV/RDM - 20210208 - Riesgos Laborales - BEG
      PERFORM f_handle_rlab USING gs_likp-vbeln CHANGING gv_ret_bool.
      IF gv_ret_bool = abap_true.
        EXIT.
      ENDIF.
      "KYV/RDM - 20210208 - Riesgos Laborales - END


      PERFORM show_delivery USING gs_likp-vbeln.
    ENDDO.
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CHECK_DELIVERY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GS_LIKP_VBELN  text
*----------------------------------------------------------------------*
FORM check_delivery_pend  USING    p_vbeln.
  SELECT SINGLE * INTO gs_likp
    FROM likp
    WHERE vbeln = p_vbeln.
  IF sy-subrc IS INITIAL.
    REFRESH gt_lips.
    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_lips
      FROM shp_idx_puta AS a
        INNER JOIN
           lips AS b
        ON b~vbeln = a~vbeln
      WHERE a~vbeln = p_vbeln AND
            b~werks = gs_param-werks.
    IF gt_lips[] IS INITIAL.
*          el albarán & no existe.
      g_message_number = '046'.
      g_message_type = 'A'.
      g_msgv1 = gs_likp-vbeln.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      g_error = abap_true.
    ELSE.

    ENDIF.
  ELSE.
*          el albarán & no existe.
    g_message_number = '003'.
    g_message_type = 'A'.
    g_msgv1 = gs_likp-vbeln.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    g_error = abap_true.
  ENDIF.
*gs_likp-
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SHOW_DELIVERY
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM show_delivery  USING    p_vbeln.
  DELETE gt_lips WHERE vbeln <> p_vbeln.
  DELETE gt_lips WHERE lfimg IS INITIAL.
  DESCRIBE TABLE gt_lips LINES g_lineas.
  READ TABLE gt_likp INTO gs_likp
      WITH KEY vbeln = p_vbeln
      BINARY SEARCH.
  IF NOT sy-subrc IS INITIAL.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF gs_likp
      FROM likp
      WHERE vbeln = p_vbeln.
    IF sy-subrc IS INITIAL.
      APPEND gs_likp TO gt_likp.
      SORT gt_likp BY vbeln.
    ENDIF.
  ENDIF.
  READ TABLE gt_lfa1
      WITH KEY lifnr = gs_likp-lifnr
      BINARY SEARCH.
  IF NOT sy-subrc IS INITIAL.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF gt_lfa1
      FROM lfa1
      WHERE lifnr = gs_likp-lifnr.
    APPEND gt_lfa1.
    SORT gt_lfa1 BY lifnr.
  ENDIF.
  CLEAR g_name.
  CONCATENATE gt_lfa1-name1
              gt_lfa1-name2
              gt_lfa1-name3
              gt_lfa1-name4
           INTO g_name SEPARATED BY space.
  g_index = 1.
  PERFORM assign_lips_detail USING g_index.
  CALL SCREEN '0061'.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  ASSIGN_LIPS_DETAIL
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM assign_lips_detail  USING    p_index.
  DATA l_uni TYPE meins.
  CLEAR gs_makt.
  READ TABLE gt_lips INTO gs_lips
    INDEX p_index.
  IF sy-subrc IS INITIAL.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF gs_makt
      FROM makt
      WHERE matnr = gs_lips-matnr AND
            spras = sy-langu.
* Convertimos cantidades a metros.
    l_uni = gs_lips-vrkme. " cvivo - 61195
    PERFORM convertir_uni USING gs_lips-matnr CHANGING gs_lips-lfimg gs_lips-vrkme .

    gs_lips-meins = l_uni .
    PERFORM convertir_uni USING gs_lips-matnr CHANGING gs_lips-ormng gs_lips-meins.

    gs_lips-lfimg = trunc( gs_lips-lfimg ).
    gs_lips-ormng = trunc( gs_lips-ormng ).
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  POST_DELIVERY
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM post_delivery USING p_vbeln.
  DATA ls_vbkok TYPE vbkok .
  DATA ls_mess TYPE prott.
  DATA lt_mess TYPE TABLE OF prott.
*  DATA ls_vbkok TYPE vbkok .
  DATA lt_vbpok TYPE TABLE OF vbpok.
  DATA ls_vbpok TYPE vbpok.
  DATA l_error TYPE flag.
  DATA ls_return TYPE bapiret2.
  DATA lt_return TYPE TABLE OF bapiret2.
  DATA ls_header TYPE bapishipmentheader.
  DATA ls_header_action TYPE bapishipmentheaderaction .

  ls_vbkok-wadat_ist = sy-datum.
  ls_vbkok-vbeln_vl = p_vbeln.
*  Ajuste automático de cantidad entrega a cantidad picking
  ls_vbkok-komue = 'X'.
*  Contabilizar movimiento de mercancías automáticamente
  ls_vbkok-wabuc = 'X'.

  DATA l_tanum LIKE ltak-tanum.
  DATA lt_items TYPE TABLE OF l03b_delit.
  DATA ls_item LIKE LINE OF lt_items.
** posiciones picking
*  CLEAR lt_vbpok.
  REFRESH lt_items.

  LOOP AT gt_lips.
*    CLEAR ls_vbpok.
*    ls_vbpok-vbeln_vl = gs_likp-vbeln.
*    ls_vbpok-posnr_vl = gt_lips-posnr.
*    ls_vbpok-matnr = gt_lips-matnr.
*    ls_vbpok-charg = gt_lips-charg.
*    ls_vbpok-werks = gt_lips-werks.
*    ls_vbpok-lgort = gt_lips-lgort.
*    ls_vbpok-taqui = 'X'.
**    ls_vbpok-pikmg = gt_lips-RFMNG.
*    ls_vbpok-lfimg = gt_lips-lfimg.
*    ls_vbpok-vrkme = gt_lips-vrkme.
*    APPEND ls_vbpok TO lt_vbpok.
    CLEAR ls_item.
    ls_item-posnr = gt_lips-posnr.
    ls_item-anfme = gt_lips-lfimg.
    ls_item-altme = gt_lips-vrkme. " cvivo - 61195
    ls_item-charg = gt_lips-charg.
*    ls_item-letyp = gs_param-letyp." 'BB'.
* ini - cvivo - WM CB Detectar tipo de UA en materia prima
    SELECT SINGLE @abap_true FROM mara
      WHERE matnr EQ @gt_lips-matnr
        AND zzlargo GT 0
        INTO @DATA(check).

    IF sy-subrc EQ 0.
      ls_item-letyp =  'PL'.
    ELSE.
      ls_item-letyp =  'BB'.
    ENDIF.
* ini - cvivo - WM CB Detectar tipo de UA en materia prima
    APPEND ls_item TO lt_items.
  ENDLOOP.
  sy-binpt = abap_true.

  "
  " SEIS. 08.06.22. Esta función se hará posteriormente, cuando se contabilice la EM
  "
*  PERFORM create_ot_dn TABLES lt_items
*                  USING p_vbeln
*                        space
*                  CHANGING l_tanum.
  "
  " SEIS. 08.06.22. Fin cambio
  "
*  IF NOT l_tanum IS INITIAL. " cvivo - 28/06/2019 - 55810
* añadimos la entrega al transporte
  PERFORM add_dlv_to_tr USING gs_vttk-tknum
                              p_vbeln.

*  ENDIF.


  CALL FUNCTION 'HU_PACKING_REFRESH'.
  CALL FUNCTION 'LE_DELIVERY_REFRESH_BUFFER'
    EXCEPTIONS
      no_key_specified = 0
      OTHERS           = 0.
  CALL FUNCTION 'WS_DELIVERY_UPDATE_2'
    EXPORTING
      vbkok_wa       = ls_vbkok
      delivery       = gs_likp-vbeln
      update_picking = 'X'
    IMPORTING
      ef_error_any   = l_error
    TABLES
      vbpok_tab      = lt_vbpok
      prot           = lt_mess.
  READ TABLE lt_mess INTO ls_mess WITH KEY msgty = 'E'.
  IF sy-subrc IS INITIAL.
    PERFORM crear_mensaje_sistema USING ls_mess-msgid
                                        ls_mess-msgno
                                        ls_mess-msgv1
                                        ls_mess-msgv2
                                        ls_mess-msgv3
                                        ls_mess-msgv4
                               CHANGING g_msgv1
                                        g_msgv2
                                        g_msgv3
                                        g_msgv4.

    g_message_type = 'E'.
    g_message_number = '000'.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

    "
    " SEIS. 08.06.22. Ubicar en WM.
    "
    CALL FUNCTION 'Z_WM_RF_EM_UBICAR_SUBCONTRA'
      EXPORTING
        vp_vbeln         = gs_likp-vbeln
      EXCEPTIONS
        error            = 1
        conf_ubic_cancel = 2
        to_not_created   = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.

    IF sy-subrc <> 0.
      PERFORM crear_mensaje_sistema USING sy-msgid
                                          sy-msgno
                                          sy-msgv1
                                          sy-msgv2
                                          sy-msgv3
                                          sy-msgv4
                                 CHANGING g_msgv1
                                          g_msgv2
                                          g_msgv3
                                          g_msgv4.

      g_message_type = 'E'.
      g_message_number = '000'.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    ELSE.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
    ENDIF.
** KYVOR(AG) - 29.07.2019 - INI - So atualiza se tiver transporte asignado
    IF g_no_transporte IS INITIAL.
** KYVOR(AG) - 29.07.2019 - FIM

* modificamos estatus de transporte.
      ls_header-shipment_num = gs_vttk-tknum.
      ls_header-status_plan = 'X'.
      ls_header_action-status_plan = 'C'.
      ls_header-status_load_end = 'X'.
      ls_header_action-status_load_end = 'C'.

* damos fin de transporte
      CALL FUNCTION 'BAPI_SHIPMENT_CHANGE'
        EXPORTING
          headerdata       = ls_header
          headerdataaction = ls_header_action
        TABLES
          return           = lt_return.

      READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
      IF sy-subrc IS INITIAL.
        ROLLBACK WORK.
        PERFORM crear_mensaje_sistema USING ls_return-id
                                          ls_return-number
                                          ls_return-message_v1
                                          ls_return-message_v1
                                          ls_return-message_v1
                                          ls_return-message_v1
                                 CHANGING g_msgv1
                                          g_msgv2
                                          g_msgv3
                                          g_msgv4.

        g_message_type = 'E'.
        g_message_number = '000'.
        PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      ELSE.
* impresion de las etiquetas de las bobinas.
* buscamos en las UAs de la entrega
*        SELECT * INTO TABLE @DATA(lt_lqua)
*                 FROM lqua
*                 WHERE lgnum = @gs_param-lgnum AND
*                       vbeln = @gs_likp-vbeln.
        SELECT DISTINCT vbeln
          FROM vbfa
          INTO TABLE @DATA(tl_vbfa)
          WHERE vbelv = @gs_likp-vbeln AND
                vbtyp_n = 'R'.
        SELECT * INTO TABLE @DATA(lt_lqua)
                 FROM lqua FOR ALL ENTRIES IN @tl_vbfa
                 WHERE lgnum = @gs_param-lgnum AND
                       wenum = @tl_vbfa-vbeln.
        IF sy-subrc IS INITIAL.
          LOOP AT lt_lqua INTO DATA(ls_lqua).
            PERFORM imprimir_etiqueta USING  ls_lqua-lenum.
          ENDLOOP.
        ENDIF.
        g_message_number = '047'.
        g_message_type = 'A'.
        CLEAR: g_msgv1,
               g_msgv2,
               g_msgv3,
               g_msgv4.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
          EXPORTING
            input  = p_vbeln
          IMPORTING
            output = g_msgv1.
        PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
        LEAVE TO TRANSACTION 'LM01'.
      ENDIF.

** KYVOR(AG) - 29.07.2019 - INI - So atualiza se tiver transporte asignado
    ELSE.
*      SELECT * INTO TABLE lt_lqua
*               FROM lqua
*               WHERE lgnum = gs_param-lgnum AND
*                     vbeln = gs_likp-vbeln.
      SELECT DISTINCT vbeln
        FROM vbfa
        INTO TABLE tl_vbfa
        WHERE vbelv = gs_likp-vbeln AND
              vbtyp_n = 'R'.
      SELECT * INTO TABLE lt_lqua
               FROM lqua FOR ALL ENTRIES IN tl_vbfa
               WHERE lgnum = gs_param-lgnum AND
                     wenum = tl_vbfa-vbeln.
      IF sy-subrc IS INITIAL.
        LOOP AT lt_lqua INTO ls_lqua.
          PERFORM imprimir_etiqueta USING  ls_lqua-lenum.
        ENDLOOP.
      ENDIF.
      g_message_number = '047'.
      g_message_type = 'A'.
      CLEAR: g_msgv1,
             g_msgv2,
             g_msgv3,
             g_msgv4.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = p_vbeln
        IMPORTING
          output = g_msgv1.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      LEAVE TO TRANSACTION 'LM01'.
    ENDIF.
** KYVOR(AG) - 29.07.2019 - FIM

  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  GET_DELIVERY_PEND_LIST
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM get_out_delivery_pend_list.
  DATA l_ebelp LIKE ekpo-ebelp.
*  data l_index type i.z

  REFRESH gt_lips.
  REFRESH gt_ekpo.
  REFRESH gt_vbup.
  SELECT a~vbeln a~posnr a~wbsta a~kosta
    INTO CORRESPONDING FIELDS OF TABLE gt_vbup
    FROM vbup AS a
    INNER JOIN vbuk AS b
    ON b~vbeln = a~vbeln
    WHERE b~vbtyp = gc_vbtyp_j AND
      NOT b~wbstk = gc_stat_c AND
      NOT a~wbsta = gc_stat_c.
  IF NOT gt_vbup[] IS INITIAL.
    SORT gt_vbup BY vbeln posnr.
    SELECT * APPENDING CORRESPONDING FIELDS OF TABLE gt_lips
      FROM lips
      FOR ALL ENTRIES IN gt_vbup
      WHERE vbeln = gt_vbup-vbeln AND
            posnr = gt_vbup-posnr AND
            werks = gs_param-werks AND
            lgort = gs_param-lgort.

*  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_lips
*    FROM shp_idx_pick AS a
*      INNER JOIN
*         lips AS b
*      ON b~vbeln = a~vbeln
*    WHERE b~werks = gs_param-werks AND
*          b~lgort = gs_param-lgort.
  ENDIF.
  IF gt_lips[] IS INITIAL.
*          el albarán & no existe.
    g_message_number = '049'.
    g_message_type = 'A'.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
  ELSE.
    IF NOT gt_lips[] IS INITIAL.
      gt_lips_org[] = gt_lips[].
    ENDIF.

    REFRESH gt_lips_aux[].
    gt_lips_aux[] = gt_lips[].

    SORT gt_lips_aux.
    DELETE ADJACENT DUPLICATES FROM gt_lips_aux COMPARING vbeln.
    REFRESH gt_likp.
    REFRESH gt_kna1.
    IF NOT gt_lips_aux[] IS INITIAL.
      SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_likp
        FROM likp
        FOR ALL ENTRIES IN gt_lips_aux
        WHERE vbeln = gt_lips_aux-vbeln.
      SORT gt_likp BY vbeln.
      IF NOT gt_likp[] IS INITIAL.
        SELECT kunnr name1 name2 name3 name4
          INTO CORRESPONDING FIELDS OF TABLE gt_kna1
          FROM kna1
          FOR ALL ENTRIES IN gt_likp
          WHERE kunnr = gt_likp-kunnr.
        SORT gt_kna1 BY kunnr.
      ENDIF.
    ENDIF.

    REFRESH gt_select_list.
    LOOP AT gt_lips_aux.
      CLEAR gt_select_list.
      gt_select_list-obj_number = gt_lips_aux-vbeln.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = gt_lips_aux-vbeln
        IMPORTING
          output = gt_select_list-obj_numberc.
      CLEAR gt_likp.
      READ TABLE gt_likp
        WITH KEY vbeln = gt_lips_aux-vbeln
            BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        READ TABLE gt_kna1
          WITH KEY kunnr = gt_likp-kunnr
            BINARY SEARCH.
        IF sy-subrc IS INITIAL.
          CONCATENATE gt_kna1-name1
                      gt_kna1-name2
                      gt_kna1-name3
                      gt_kna1-name4
            INTO gt_select_list-obj_number_alt
            SEPARATED BY space.
        ENDIF.
      ELSE.
        gt_select_list-obj_number_alt = gt_select_list-obj_numberc.
      ENDIF.
      APPEND gt_select_list.
    ENDLOOP.
* Llamamos la pantalla de confirmacion de bobinas.
    DESCRIBE TABLE gt_lips_aux LINES g_lineas.
    g_index = 1.
    CLEAR g_partial_list.
    CLEAR g_partial_list_0086.
    CLEAR g_partial_list_0091.
    DO.
      g_local_previous_screen = sy-dynnr.
      CALL SCREEN 9997.
      IF ok_code = 'BACK'.
        EXIT.
      ENDIF.
*      l_index = g_select_object.
*      READ TABLE gt_lips_aux INDEX g_select_object.
      gs_likp-vbeln = g_select_object.
      gt_lips[] = gt_lips_org[].
      PERFORM show_out_delivery USING gs_likp-vbeln.
    ENDDO.
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CHECK_DELIVERY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GS_LIKP_VBELN  text
*----------------------------------------------------------------------*
FORM check_out_delivery_pend  USING    p_vbeln.
  SELECT SINGLE * INTO gs_likp
    FROM likp
    WHERE vbeln = p_vbeln.
  IF sy-subrc IS INITIAL.
    REFRESH gt_lips.
    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_lips
      FROM shp_idx_pick AS a
        INNER JOIN
           lips AS b
        ON b~vbeln = a~vbeln
      WHERE a~vbeln = p_vbeln AND
            b~werks = gs_param-werks.
    IF gt_lips[] IS INITIAL.
*          el albarán & no existe.
      g_message_number = '049'.
      g_message_type = 'A'.
      g_msgv1 = gs_likp-vbeln.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      g_error = abap_true.
    ELSE.

    ENDIF.
  ELSE.
*          el albarán & no existe.
    g_message_number = '003'.
    g_message_type = 'A'.
    g_msgv1 = gs_likp-vbeln.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    g_error = abap_true.
  ENDIF.
*gs_likp-
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SHOW_DELIVERY
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM show_out_delivery  USING    p_vbeln.
  DATA l_tabix LIKE sy-tabix.
  REFRESH gt_reubic.
  REFRESH gt_lqua.
  CLEAR gt_lqua.
  CLEAR gs_lqua.
  CLEAR gt_reubic.
  CLEAR gs_reubic.
  CLEAR g_lqua_index.
  CLEAR g_lqua_tot.
  REFRESH gt_reubic_aux.

  DELETE gt_lips WHERE vbeln <> p_vbeln.
  DELETE gt_lips WHERE lfimg IS INITIAL.
  REFRESH gt_vbfa.
  IF NOT gt_lips[] IS INITIAL.
    SELECT * APPENDING CORRESPONDING FIELDS OF TABLE gt_vbfa
      FROM vbfa
      FOR ALL ENTRIES IN gt_lips
      WHERE vbelv = gt_lips-vbeln AND
            posnv = gt_lips-posnr AND
            vbtyp_n = gc_vbtyp_n_q.
  ENDIF.
  LOOP AT gt_lips.
*      utilizamos el campo LGMNG y ORMNG
*      para llevar la cantidad
*      pendiente de picking
    gt_lips-lgmng = gt_lips-lfimg.
    gt_lips-ormng = gt_lips-lfimg.
    LOOP AT gt_vbfa
      WHERE vbelv = gt_lips-vbeln AND
            posnv = gt_lips-posnr.
*      utilizamos el campo LGMNG y ORMNG
*      para llevar la cantidad
*      pendiente de picking
      IF NOT gt_vbfa-plmin IS INITIAL.
        gt_vbfa-rfmng = gt_vbfa-rfmng * -1.
      ENDIF.
      gt_lips-lgmng = gt_lips-lgmng - gt_vbfa-rfmng.
      gt_lips-ormng = gt_lips-ormng - gt_vbfa-rfmng.
    ENDLOOP.
    MODIFY gt_lips.
  ENDLOOP.
  DELETE gt_lips WHERE lfimg IS INITIAL.

  DESCRIBE TABLE gt_lips LINES g_lineas.
  REFRESH gt_lips_aux[].
  REFRESH gt_lips_pick[].
  gt_lips_aux[] = gt_lips[].
  gt_lips_pick[] = gt_lips[].

  READ TABLE gt_likp INTO gs_likp
      WITH KEY vbeln = p_vbeln
      BINARY SEARCH.
  IF NOT sy-subrc IS INITIAL.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF gs_likp
      FROM likp
      WHERE vbeln = p_vbeln.
    IF sy-subrc IS INITIAL.
      APPEND gs_likp TO gt_likp.
      SORT gt_likp BY vbeln.
    ENDIF.
  ENDIF.
  READ TABLE gt_kna1
      WITH KEY kunnr = gs_likp-kunnr
      BINARY SEARCH.
  IF NOT sy-subrc IS INITIAL.
    SELECT SINGLE * INTO CORRESPONDING FIELDS OF gt_kna1
      FROM kna1
      WHERE kunnr = gs_likp-kunnr.
    APPEND gt_kna1.
    SORT gt_kna1 BY kunnr.
  ENDIF.
  CLEAR g_name.
  CONCATENATE gt_kna1-name1
              gt_kna1-name2
              gt_kna1-name3
              gt_kna1-name4
           INTO g_name SEPARATED BY space.
  CALL SCREEN '0072'.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  POST_DELIVERY
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM post_out_delivery USING p_vbeln.
  DATA ls_vbkok TYPE vbkok .
  DATA ls_mess TYPE prott.
  DATA lt_mess TYPE TABLE OF prott.
*  DATA ls_vbkok TYPE vbkok .
  DATA lt_vbpok TYPE TABLE OF vbpok.
  DATA ls_vbpok TYPE vbpok.
  DATA l_error TYPE flag.
  DATA l_ok.
* chequeamos que no haya posiciones pendientes de picking
*o grandes diferencias entre cantidad de picking y cantidad de entrega
  PERFORM check_picking CHANGING l_ok.
  IF l_ok = abap_true.
    ls_vbkok-wadat_ist = sy-datum.
    ls_vbkok-vbeln_vl = p_vbeln.
*  Ajuste automático de cantidad entrega a cantidad picking
    ls_vbkok-komue = 'X'.
*  Contabilizar movimiento de mercancías automáticamente
    ls_vbkok-wabuc = 'X'.

    DATA l_tanum LIKE ltak-tanum.
    DATA lt_items TYPE TABLE OF l03b_delit.
    DATA ls_item LIKE LINE OF lt_items.
** posiciones picking
*  CLEAR lt_vbpok.
    IF NOT gt_reubic[] IS INITIAL.
      REFRESH lt_items.
      LOOP AT gt_reubic.
        LOOP AT gt_lips
          WHERE posnr = gt_reubic-posnrv.
          CLEAR ls_item.
          ls_item-posnr = gt_lips-posnr.
          ls_item-anfme = gt_reubic-ctd_conf.
          ls_item-altme = gt_reubic-meins.
          ls_item-charg = gt_reubic-charg.
* ini - cvivo - WM CB Detectar tipo de UA en materia prima
          SELECT SINGLE @abap_true FROM mara
            WHERE matnr EQ @gt_lips-matnr
              AND zzlargo GT 0
              INTO @DATA(check).

          IF sy-subrc EQ 0.
            ls_item-letyp =  'PL'.
          ELSE.
            ls_item-letyp =  'BB'.
          ENDIF.
* ini - cvivo - WM CB Detectar tipo de UA en materia prima
*          ls_item-letyp = gs_param-letyp." 'BB'.
          ls_item-vltyp = gt_reubic-lgtyp.
          ls_item-vlpla = gt_reubic-lgpla.
          ls_item-vppos = gt_reubic-plpos.
          ls_item-vlenr = gt_reubic-lenum."
          APPEND ls_item TO lt_items.
        ENDLOOP.
      ENDLOOP.

      sy-binpt = abap_true.

      PERFORM create_ot_dn TABLES lt_items
                        USING p_vbeln
                              space
                        CHANGING l_tanum.
    ENDIF.

    WAIT UP TO 1 SECONDS. " desgraciadamente, hay desfases y vale la pena esperar 1 segundo

    LOOP AT gt_lips INTO DATA(ls_lips) WHERE uecha IS INITIAL AND charg IS INITIAL. " de las posiciones superiores y sin lote, vemos cuáles borrar " cvivo - 56153
      READ TABLE gt_lips WITH KEY uecha = ls_lips-posnr. " vemos si tiene inferiores

      IF sy-subrc NE 0. " si no tiene, puede que se acabe de generar ahora, validamos con LT_ITEMS
        READ TABLE lt_items WITH KEY posnr = ls_lips-posnr TRANSPORTING NO FIELDS. " ver si se acaba de confirmar

        IF sy-subrc NE 0.
          SELECT SINGLE @abap_true FROM vbup "vamos a ver si hay picking
            INTO @exist
            WHERE vbeln EQ @ls_lips-vbeln
              AND posnr EQ @ls_lips-posnr
              AND kosta EQ 'A'.

          IF sy-subrc EQ 0. " si no tiene picking confirmado ni subposiciones, se borra
            ls_vbpok-lips_del = abap_true.
            ls_vbpok-vbeln_vl = ls_lips-vbeln.
            ls_vbpok-posnr_vl = ls_lips-posnr.
            APPEND ls_vbpok TO lt_vbpok.
            CLEAR ls_vbpok.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    CALL FUNCTION 'HU_PACKING_REFRESH'.
    CALL FUNCTION 'LE_DELIVERY_REFRESH_BUFFER'
      EXCEPTIONS
        no_key_specified = 0
        OTHERS           = 0.
    CALL FUNCTION 'WS_DELIVERY_UPDATE_2'
      EXPORTING
        vbkok_wa       = ls_vbkok
        delivery       = gs_likp-vbeln
        update_picking = 'X'
      IMPORTING
        ef_error_any   = l_error
      TABLES
        vbpok_tab      = lt_vbpok
        prot           = lt_mess.
    READ TABLE lt_mess INTO ls_mess WITH KEY msgty = 'E'.
    IF sy-subrc IS INITIAL.
      PERFORM crear_mensaje_sistema USING ls_mess-msgid
                                          ls_mess-msgno
                                          ls_mess-msgv1
                                          ls_mess-msgv2
                                          ls_mess-msgv3
                                          ls_mess-msgv4
                                 CHANGING g_msgv1
                                          g_msgv2
                                          g_msgv3
                                          g_msgv4.

      g_message_type = 'E'.
      g_message_number = '000'.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    ELSE.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      g_message_number = '054'.
      g_message_type = 'A'.
      CLEAR: g_msgv1,
             g_msgv2,
             g_msgv3,
             g_msgv4.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
        EXPORTING
          input  = p_vbeln
        IMPORTING
          output = g_msgv1.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      LEAVE TO TRANSACTION 'LM01'.

    ENDIF.
  ENDIF.
*  ELSE.
*    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*      EXPORTING
*        wait = 'X'.
*    g_message_number = '053'.
*    g_message_type = 'S'.
*    CLEAR: g_msgv1,
*           g_msgv2,
*           g_msgv3,
*           g_msgv4.
*    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
*      EXPORTING
*        input  = p_vbeln
*      IMPORTING
*        output = g_msgv1.
*    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
*    LEAVE TO TRANSACTION 'LM01'.
*  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CHECK_PICKING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_picking CHANGING p_ok.
  DATA ls_lips TYPE lips.
* chequeamos si hay posiciones de entrega sin hacer picking
  LOOP AT gt_lips INTO ls_lips  WHERE ormng = gt_lips-lfimg.
    EXIT.
  ENDLOOP.
  IF sy-subrc IS INITIAL.
*Existen posiciones del albaran sin cargar ¿desea continuar?
    g_message_number = '056'.
    g_message_type = 'W'.
    PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
    IF ok_code = 'NEXT'.
      p_ok = abap_true.
    ELSE.
      CLEAR p_ok.
    ENDIF.
  ELSE.
    p_ok = abap_true.
  ENDIF.
  IF p_ok = abap_true.
* chequeamos si hay diferencias mayores de 1000 kg en alguna posicion.
    LOOP AT gt_lips INTO ls_lips WHERE ormng GE 1000.
      EXIT.
    ENDLOOP.
    IF sy-subrc IS INITIAL.
**Existen posiciones del albaran sin cargar ¿desea continuar?
      g_message_number = '057'.
      g_message_type = 'W'.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      IF ok_code = 'NEXT'.
        p_ok = abap_true.
      ELSE.
        CLEAR p_ok.
      ENDIF.
    ELSE.
      p_ok = abap_true.
    ENDIF.
  ENDIF.
ENDFORM.

** KYVOR(AG) - INI - 28.07.2019 - . En el caso de que salga una bobina de zona roja (030),
** hay que hacer posteriormente a la OT, un traspaso mediante LQ02 mov 853, para dejarlo a libre.
*&---------------------------------------------------------------------*
*&      Form  CHECK_PICKING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM transf_stock USING iv_tabix
                        iv_lgnum
                        iv_lgtyp
                        iv_bwlvs
                        iv_lenum.

  zcl_wm_gestion_stocks=>create_transf_stock(
    EXPORTING
      iv_lgnum            = iv_lgnum    " Núm.almacén/Complejo alm.
      iv_lgtyp            = iv_lgtyp    " Tipo almacén
      iv_bwlvs            = iv_bwlvs    " Cl.movim.gestión almacenes
      iv_lenum            = iv_lenum    " Número de unidad de almacén
    EXCEPTIONS
      no_authority        = 1
      no_enqueue_possible = 2
      error_wm_posting    = 3
      error_im_posting    = 4
      OTHERS              = 5 ).

  IF sy-subrc <> 0.
    IF iv_tabix EQ 1.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      FREE g_message_type.
    ENDIF.

    g_msgid          = sy-msgid.
    g_msgv1          = sy-msgv1.
    g_msgv2          = sy-msgv2.
    g_msgv3          = sy-msgv3.
    g_msgv4          = sy-msgv4.
    g_message_number = sy-msgno.
    g_message_type   = 'E'.

  ELSE.
    IF iv_tabix EQ 1.
      PERFORM mensajes USING 'ZWM_RF' g_message_type g_message_number g_msgv1 g_msgv2 g_msgv3 g_msgv4.
      FREE g_message_type.
    ENDIF.

    CHECK g_message_type NE 'E'.
    FREE: g_msgv3, g_msgv4.
    g_msgid = '00'.
    g_msgv1 = COND #( WHEN iv_bwlvs EQ gc_bwlvs-bloq  THEN 'Transf. stock bloqueado'
                      WHEN iv_bwlvs EQ gc_bwlvs-libre THEN 'Transf. stock libre' ).
    g_msgv2 = 'realizada con éxito'.
    g_message_number = '398'.
    g_message_type = 'E'.
  ENDIF.

ENDFORM.
** KYVOR(AG) - FIM - 28.07.2019 - . En el caso de que salga una bobina de zona roja (030),
** hay que hacer posteriormente a la OT, un traspaso mediante LQ02 mov 853, para dejarlo a libre.
*&---------------------------------------------------------------------*
*&      Form  F_HANDLE_RLAB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GS_EKKO_EBELN  text
*----------------------------------------------------------------------*
FORM f_handle_rlab  USING   iv_doc CHANGING cv_ret.
  cv_ret = abap_false.
  IF oo_descarga IS NOT BOUND.
    oo_descarga = NEW #( ).
  ENDIF.
  oo_descarga->check_funcionalidad(
           EXPORTING
             func     = CONV #( gc_func-cuestionario_riesgos )
           EXCEPTIONS
             inactive = 1
             OTHERS   = 2
         ).
  IF sy-subrc = 0.
    TRY.
        zcl_wm_rlab_dao=>init( ).
        GET PARAMETER ID 'ZNUM_OPER' FIELD gs_rlab_log-operario.
        zcl_wm_rlab_dao=>get_instance(
        iv_lgnum = g_lgnum
        iv_vbeln = CONV #( iv_doc )
        iv_usnam = sy-uname
        iv_noper = gs_rlab_log-operario )->start_query( ).
        WHILE zcl_wm_rlab_dao=>get_instance( )->has_next_query( ) = abap_true.
          CALL SCREEN '0090'.
          IF zcl_wm_rlab_dao=>get_instance( )->get_last_log_entry( )-respuesta = zcl_wm_rlab_dao=>gc_n.
            CLEAR: g_msgv1, g_msgv2, g_msgv3, g_msgv4.
            g_msgv1 = text-t08.
            g_msgv2 = text-t09.
            PERFORM mensajes USING
           'ZWM_RF' 'A'
           '000'
           g_msgv1 g_msgv2 g_msgv3 g_msgv4.
            cv_ret = abap_true.
            RETURN.
          ENDIF.
        ENDWHILE.
      CATCH zcx_wm_exception INTO DATA(lr_exc).
        g_message_number = lr_exc->if_t100_message~t100key-msgno.
        g_msgv1 = lr_exc->if_t100_message~t100key-attr1.
        g_msgv2 = lr_exc->if_t100_message~t100key-attr2.
        g_msgv3 = lr_exc->if_t100_message~t100key-attr3.
        g_msgv4 = lr_exc->if_t100_message~t100key-attr4.

        PERFORM mensajes USING
         lr_exc->if_t100_message~t100key-msgid 'E'
         g_message_number
         g_msgv1 g_msgv2 g_msgv3 g_msgv4.

    ENDTRY.

  ENDIF.

ENDFORM.
