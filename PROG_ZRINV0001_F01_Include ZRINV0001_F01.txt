*&---------------------------------------------------------------------*
*&  Include           ZRINV0001_F01
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  CARGA_POPUP_INICIAL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM carga_popup_inicial .

* Inicialización status en pantalla selección
* Excluimos los valores F (Finalizado) y
* B (Borrado)

  REFRESH so_stat.
  so_stat-sign = 'E'.
  so_stat-option = 'EQ'.
  so_stat-low = 'F'.
  APPEND so_stat.

  so_stat-sign = 'E'.
  so_stat-option = 'EQ'.
  so_stat-low = 'B'.
  APPEND so_stat.

* Inicializar el centro:
  REFRESH: so_werks.
  so_werks-sign = 'I'.
  so_werks-option = 'EQ'.
  so_werks-low = c_werks_3000.
  APPEND so_werks.

  CALL SELECTION-SCREEN 0002 STARTING AT 15 5.

  gv_pant_ini = 'X'.

ENDFORM.                    " CARGA_POPUP_INICIAL
*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_ALV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_alv .

  DATA: ls_variant TYPE disvariant.

* Preparamos el catálogo de campos
  PERFORM prepare_fielcat.

* Para que muestre el ancho de las columnas optimizado
  t_layout-cwidth_opt = 'X'.
  t_layout-sel_mode   = 'A'.
  ls_variant-report   = sy-repid.
  ls_variant-handle   = '0100'.

* Mostrar alv
  CALL METHOD g_grid->set_table_for_first_display
    EXPORTING
      is_layout            = t_layout
      i_structure_name     = 'ZSINV0001_GRID'
      it_toolbar_excluding = gti_toolbar_ex
      is_variant           = ls_variant
*     i_save               = 'U'
      i_save               = 'A'
*     i_default            = 'X'
    CHANGING
      it_outtab            = gti_mostrar[]
      it_fieldcatalog      = gti_fieldcat.


ENDFORM.                    " MOSTRAR_ALV
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR_ALV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM refrescar_alv .
  DATA: ls_layout TYPE lvc_s_layo,
        ls_stable TYPE lvc_s_stbl.

* Sacamos el layout del ALV
  CALL METHOD g_grid->get_frontend_layout
    IMPORTING
      es_layout = ls_layout.

* Ponemos de nuevo que optimice las columnas
  ls_layout-cwidth_opt = 'X'.

* Cargamos de nuevo el layout
  CALL METHOD g_grid->set_frontend_layout
    EXPORTING
      is_layout = ls_layout.

* Refrescamos el ALV
  ls_stable-row = 'X'.
  ls_stable-col = 'X'.

  CALL METHOD g_grid->refresh_table_display
    EXPORTING
      is_stable = ls_stable.

ENDFORM.                    " REFRESCAR_ALV
*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM recuperar_datos .

  DATA: t_ci  TYPE STANDARD TABLE OF ztinv_ci,
        wa_ci TYPE                   ztinv_ci.

  TYPES: BEGIN OF tipo_werks,
           werks TYPE werks_d,
           name1 TYPE name1.
  TYPES: END OF tipo_werks.
  TYPES: tty_werks TYPE STANDARD TABLE OF tipo_werks.
  DATA: t_werks  TYPE         tty_werks,
        wa_werks TYPE LINE OF tty_werks.


  TYPES: BEGIN OF tipo_lgort,
           lgort TYPE lgort_d,
           lgobe TYPE lgobe.
  TYPES: END OF tipo_lgort.
  TYPES: tty_lgort TYPE STANDARD TABLE OF tipo_lgort.
  DATA: t_lgort  TYPE         tty_lgort,
        wa_lgort TYPE LINE OF tty_lgort.


  TYPES: BEGIN OF tipo_mtart,
           mtart TYPE mtart,
           mtbez TYPE mtbez.
  TYPES: END OF tipo_mtart.
  TYPES: tty_mtart TYPE STANDARD TABLE OF tipo_mtart.
  DATA: t_mtart  TYPE         tty_mtart,
        wa_mtart TYPE LINE OF tty_mtart.

  DATA: wa_mostrar TYPE zsinv0001_grid.


  CLEAR: t_ci, gti_mostrar.
  REFRESH: t_ci, gti_mostrar.

  SELECT * FROM ztinv_ci
    INTO TABLE t_ci
    WHERE docum IN so_docum AND
          mtart IN so_mtart AND
          werks IN so_werks AND
          lgort IN so_lgort AND
          status IN so_stat.


  CLEAR: t_werks. REFRESH: t_werks.
  SELECT werks name1 FROM t001w
    INTO TABLE t_werks
    WHERE werks IN so_werks.

  CLEAR: t_lgort. REFRESH: t_lgort.
  SELECT lgort lgobe FROM t001l
    INTO TABLE t_lgort
    WHERE lgort IN so_lgort.

  CLEAR: t_mtart. REFRESH: t_mtart.
  SELECT mtart mtbez FROM t134t
    INTO TABLE t_mtart
    WHERE spras = sy-langu AND
          mtart IN so_stat.

  IF t_ci[] IS NOT INITIAL.
    LOOP AT t_ci INTO wa_ci.

      AUTHORITY-CHECK OBJECT 'M_MATE_WRK'
                  ID 'ACTVT' FIELD '03'
                  ID 'WERKS' FIELD wa_ci-werks.

      CHECK sy-subrc = 0.

      MOVE-CORRESPONDING wa_ci TO wa_mostrar.

      READ TABLE t_werks INTO wa_werks WITH KEY werks = wa_mostrar-werks.
      wa_mostrar-name1 = wa_werks-name1.

      READ TABLE t_lgort INTO wa_lgort WITH KEY lgort = wa_mostrar-lgort.
      wa_mostrar-lgobe = wa_lgort-lgobe.

      READ TABLE t_mtart INTO wa_mtart WITH KEY mtart = wa_mostrar-mtart.
      wa_mostrar-mtbez = wa_mtart-mtbez.

      READ TABLE t_dominio_status INTO wa_dominio WITH KEY domvalue_l  = wa_mostrar-status
                                                    ddlanguage = sy-langu.
      IF sy-subrc = 0.
        wa_mostrar-status_txt = wa_dominio-ddtext.
      ENDIF.

      APPEND wa_mostrar TO gti_mostrar.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " RECUPERAR_DATOS
*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat .

* Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZSINV0001_GRID'
    CHANGING
      ct_fieldcat      = gti_fieldcat.

  LOOP AT gti_fieldcat INTO ls_fieldcat.
    CASE ls_fieldcat-fieldname.
      WHEN 'DOCUM'.
        ls_fieldcat-hotspot = 'X'.

      WHEN 'NAME1'.
        ls_fieldcat-scrtext_l = text-000.
        ls_fieldcat-scrtext_m = text-000.
        ls_fieldcat-scrtext_s = text-000.
        ls_fieldcat-reptext   = text-000.

      WHEN 'STATUS_TXT'.
        ls_fieldcat-scrtext_l = text-001.
        ls_fieldcat-scrtext_m = text-001.
        ls_fieldcat-scrtext_s = text-001.
        ls_fieldcat-reptext   = text-001.

      WHEN 'VALIDADO'.
        ls_fieldcat-scrtext_l = text-027.
        ls_fieldcat-scrtext_m = text-027.
        ls_fieldcat-scrtext_s = text-027.
        ls_fieldcat-reptext   = text-027.

      WHEN 'WHO'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'ERDAT'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'ERZEIT'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'ERNAM'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'AEDAT'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'AEZEIT'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'AENAM'.
        ls_fieldcat-no_out = 'X'.

    ENDCASE.

*   Modificamos
    MODIFY gti_fieldcat FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT
*&---------------------------------------------------------------------*
*&      Form  CREAR_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_inventario CHANGING p_werks
                               p_lgort
                               gv_mtart.

  DATA: lv_uname LIKE sy-uname,
        lv_datum LIKE sy-datum,
        lv_uzeit LIKE sy-uzeit,
        lv_error TYPE xflag.

  DATA: ls_mostrar TYPE zsinv0001_grid.

  CLEAR: lv_uname, lv_datum, lv_uzeit, lv_error.

* Crear registro cabecera inventario:
  CLEAR ls_inv_ci.
  lv_uname = sy-uname.
  lv_datum = sy-datum.
  lv_uzeit = sy-uzeit.
  PERFORM registro_cabecera_inventario USING gv_mtart
                                             p_werks
                                             p_lgort
                                             'I'
                                             lv_uname
                                             lv_datum
                                             lv_uzeit
                                       CHANGING ls_inv_ci
                                                lv_error.

  IF lv_error IS INITIAL.
    " Crear registros posiciones inventario:
    PERFORM registro_posiciones_inventario USING ls_inv_ci
                                                 lv_uname
                                                 lv_datum
                                                 lv_uzeit
                                           CHANGING lv_error.

    IF lv_error IS NOT INITIAL.
      DELETE ztinv_ci FROM ls_inv_ci.
      COMMIT WORK AND WAIT.
      MESSAGE e106(zmm).
    ELSE.
      " Añadir registro en el listado:
      CLEAR ls_mostrar.
      MOVE-CORRESPONDING ls_inv_ci TO ls_mostrar.

      SELECT SINGLE mtbez FROM t134t
      INTO ls_mostrar-mtbez
      WHERE spras = sy-langu AND
            mtart = ls_mostrar-mtart.

      SELECT SINGLE name1 FROM t001w
        INTO ls_mostrar-name1
        WHERE werks = ls_mostrar-werks.

      SELECT SINGLE lgobe FROM t001l
        INTO ls_mostrar-lgobe
        WHERE lgort = ls_mostrar-lgort.

      CLEAR wa_dominio.
      READ TABLE t_dominio_status INTO wa_dominio
                 WITH KEY domvalue_l  = ls_mostrar-status
                          ddlanguage = sy-langu.
      IF wa_dominio IS NOT INITIAL.
        ls_mostrar-status_txt = wa_dominio-ddtext.
      ENDIF.

      APPEND ls_mostrar TO gti_mostrar.
*      leave to screen 0100.
    ENDIF.
  ELSE.
    MESSAGE e106(zmm).
  ENDIF.

ENDFORM.                    " CREAR_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  REGISTRO_CABECERA_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_INV_CI  text
*----------------------------------------------------------------------*
FORM registro_cabecera_inventario USING p_mtart
                                        p_werks
                                        p_lgort
                                        p_status
                                        p_uname
                                        p_datum
                                        p_uzeit
                                  CHANGING ps_inv_ci TYPE ztinv_ci
                                           p_error.

  CLEAR ps_inv_ci.

  ps_inv_ci-mandt = sy-mandt.

  PERFORM num_inventario CHANGING ps_inv_ci-docum.

  ps_inv_ci-mtart = p_mtart.
  ps_inv_ci-werks = p_werks.
  ps_inv_ci-lgort = p_lgort.
  ps_inv_ci-status = p_status.
  ps_inv_ci-who = p_uname.
  ps_inv_ci-ernam = p_uname.
  ps_inv_ci-aenam = p_uname.
  ps_inv_ci-erdat = p_datum.
  ps_inv_ci-aedat = p_datum.
  ps_inv_ci-erzeit = p_uzeit.
  ps_inv_ci-aezeit = p_uzeit.
  ps_inv_ci-version = 0.

  INSERT ztinv_ci FROM ps_inv_ci.
  COMMIT WORK AND WAIT.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ENDIF.

ENDFORM.                    " REGISTRO_CABECERA_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  NUM_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_PS_INV_CI_DOCUM  text
*----------------------------------------------------------------------*
FORM num_inventario  CHANGING p_docum.

  CLEAR p_docum.

  SELECT MAX( docum )
    FROM ztinv_ci
    INTO p_docum.

  p_docum = p_docum + 1.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = p_docum
    IMPORTING
      output = p_docum.


ENDFORM.                    " NUM_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  REGISTRO_POSICIONES_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_INV_CI  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM registro_posiciones_inventario  USING    ps_inv_ci TYPE ztinv_ci
                                              p_uname
                                              p_datum
                                              p_uzeit
                                     CHANGING p_error.

  DATA: r_matnr   TYPE RANGE OF matnr,
        lsr_matnr LIKE LINE OF  r_matnr.
  DATA: lt_matnr TYPE tty_material,
        ls_matnr TYPE ty_material.
  DATA: lt_mchb TYPE STANDARD TABLE OF mchb,
        ls_mchb TYPE                   mchb.
  DATA: ls_inv_pi TYPE                   ztinv_pi,
        lt_inv_pi TYPE STANDARD TABLE OF ztinv_pi.
  DATA: lv_posnr TYPE posnr.
  DATA: lv_cretm TYPE xflag.
  DATA: lv_f_stock TYPE xflag.

  DATA: gt_messages LIKE bapiret2 OCCURS 0,
        gs_messages TYPE bapiret2.

  CLEAR: r_matnr, lt_matnr.
  REFRESH: r_matnr, lt_matnr.

* Selección de materiales:
  SELECT a~matnr a~meins INTO TABLE lt_matnr
    FROM mara AS a
    INNER JOIN marc AS b ON b~matnr = a~matnr
    WHERE a~mtart = ps_inv_ci-mtart
    AND a~lvorm <> 'X'
    AND b~lvorm <> 'X'
    AND b~werks = ps_inv_ci-werks
    AND a~matnr IN so_matnr.

  LOOP AT lt_matnr INTO ls_matnr.
    CLEAR lsr_matnr.
    lsr_matnr-sign = 'I'.
    lsr_matnr-option = 'EQ'.
    lsr_matnr-low = ls_matnr-matnr.
    APPEND lsr_matnr TO r_matnr.
  ENDLOOP.

* Seleccionamos los stocks:
  CLEAR lt_mchb.
  REFRESH: lt_mchb.
  SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mchb
    FROM mchb
    WHERE matnr IN r_matnr
    AND werks = ps_inv_ci-werks
*    AND lgort = ps_inv_ci-lgort
    AND lvorm <> 'X'
    AND ( clabs <> 0 OR cinsm <> 0 AND cspem <> 0 AND cretm <> 0 ).
  SORT lt_mchb BY werks lgort matnr charg.
  CLEAR lt_inv_pi.
  REFRESH lt_inv_pi.

  lv_posnr = 1.

  CLEAR gt_messages.
  REFRESH gt_messages.

  LOOP AT lt_mchb INTO ls_mchb.
    CLEAR ls_inv_pi.
    CLEAR lv_f_stock.
    ls_inv_pi-docum = ps_inv_ci-docum.
    ls_inv_pi-werks = ls_mchb-werks.
    ls_inv_pi-lgort = ls_mchb-lgort.
    ls_inv_pi-charg = ls_mchb-charg.
    ls_inv_pi-matnr = ls_mchb-matnr.
    CLEAR ls_matnr.
    READ TABLE lt_matnr INTO ls_matnr
               WITH KEY matnr = ls_mchb-matnr.
    IF ls_matnr-meins IS NOT INITIAL.
      ls_inv_pi-meins = ls_matnr-meins.
    ELSE.
      ls_inv_pi-meins = 'KG'.
    ENDIF.

*    ls_inv_pi-contado = 'X'.
    ls_inv_pi-ernam = p_uname.
    ls_inv_pi-ernam_mod = p_uname.
    ls_inv_pi-erdat = p_datum.
    ls_inv_pi-erdat_mod = p_datum.
    ls_inv_pi-erzeit = p_uzeit.
    ls_inv_pi-erzeit_mod = p_uzeit.
    ls_inv_pi-version = 0.
*
    DATA l_objkey TYPE bapi1003_key-object.
    DATA: lt_allocvaluesnum TYPE STANDARD TABLE OF bapi1003_alloc_values_num,
          rt_allcovaluesnum TYPE                   bapi1003_alloc_values_num.
    DATA lt_allocvalueschar TYPE STANDARD TABLE OF bapi1003_alloc_values_char.
    DATA lw_allocvalueschar TYPE bapi1003_alloc_values_char.
    DATA lt_allocvaluescurr TYPE STANDARD TABLE OF bapi1003_alloc_values_curr.
    DATA lt_return TYPE STANDARD TABLE OF bapiret2.
    IF ps_inv_ci-mtart EQ 'ZPAP'.
      CLEAR l_objkey.
      REFRESH lt_allocvaluesnum.
      CONCATENATE ls_mchb-matnr ls_mchb-charg INTO l_objkey.

      CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
        EXPORTING
          objectkey       = l_objkey
          objecttable     = 'MCH1'
          classnum        = 'Z_BOBINA'
          classtype       = '023'
        TABLES
          allocvaluesnum  = lt_allocvaluesnum
          allocvalueschar = lt_allocvalueschar
          allocvaluescurr = lt_allocvaluescurr
          return          = lt_return.
      READ TABLE lt_allocvaluesnum WITH KEY charact = 'Z_LONGITUD_B' INTO rt_allcovaluesnum.
      IF sy-subrc EQ 0.
        MOVE rt_allcovaluesnum-value_from TO ls_inv_pi-longitud.
      ENDIF.
    ENDIF.
*
    " Stock Calidad:
    CLEAR: ls_inv_pi-posicion, ls_inv_pi-bstar.
    CLEAR: ls_inv_pi-menge, ls_inv_pi-devo.
    IF ls_mchb-cinsm <> 0.
      ls_inv_pi-posicion = lv_posnr.
      ls_inv_pi-bstar = '2'.
      ls_inv_pi-menge = ls_mchb-cinsm.
      lv_posnr = lv_posnr + 1.
      lv_f_stock = 'X'.
      APPEND ls_inv_pi TO lt_inv_pi.
    ENDIF.

    " Stock Bloqueado:
    CLEAR: ls_inv_pi-posicion, ls_inv_pi-bstar.
    CLEAR: ls_inv_pi-menge, ls_inv_pi-devo.
    IF ls_mchb-cspem <> 0 AND lv_f_stock <> 'X'.
      ls_inv_pi-posicion = lv_posnr.
      ls_inv_pi-bstar = '4'.
      ls_inv_pi-menge = ls_mchb-cspem.
      lv_posnr = lv_posnr + 1.
      lv_f_stock = 'X'.
      APPEND ls_inv_pi TO lt_inv_pi.
    ENDIF.

    " Stock Devolución:
    CLEAR: ls_inv_pi-posicion, ls_inv_pi-bstar.
    CLEAR: ls_inv_pi-menge, ls_inv_pi-devo.
    IF ls_mchb-cretm <> 0 AND lv_f_stock <> 'X'.
      ls_inv_pi-posicion = lv_posnr.
      ls_inv_pi-bstar = '3'.
      ls_inv_pi-menge = ls_mchb-cretm.
      ls_inv_pi-devo = 'X'.

      IF lv_cretm <> 'X'.
        CLEAR gs_messages.
        gs_messages-type = 'S'.
        gs_messages-number = '107'.
        gs_messages-id = 'ZMM'.
        APPEND gs_messages TO gt_messages.
        lv_cretm = 'X'.
      ENDIF.

      CLEAR gs_messages.
      gs_messages-type = 'S'.
      gs_messages-number = '108'.
      gs_messages-id = 'ZMM'.
      gs_messages-message_v1 = ls_mchb-charg.
      APPEND gs_messages TO gt_messages.
      lv_posnr = lv_posnr + 1.
      lv_f_stock = 'X'.
      APPEND ls_inv_pi TO lt_inv_pi.
    ENDIF.

    " Stock Libre Disposición:
    CLEAR: ls_inv_pi-posicion, ls_inv_pi-bstar.
    CLEAR: ls_inv_pi-menge, ls_inv_pi-devo.
    IF ls_mchb-clabs <> 0 AND lv_f_stock <> 'X'.
      ls_inv_pi-posicion = lv_posnr.
      ls_inv_pi-bstar = '1'.
      ls_inv_pi-menge = ls_mchb-clabs.
      lv_posnr = lv_posnr + 1.
      lv_f_stock = 'X'.
      APPEND ls_inv_pi TO lt_inv_pi.
    ENDIF.
  ENDLOOP.

  INSERT ztinv_pi FROM TABLE lt_inv_pi.
  COMMIT WORK AND WAIT.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ELSE.
    CLEAR p_error.
    CALL FUNCTION 'C14ALD_BAPIRET2_SHOW'
      TABLES
        i_bapiret2_tab = gt_messages.
*    MESSAGE i105(zmm).
  ENDIF.

ENDFORM.                    " REGISTRO_POSICIONES_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  CAMBIAR_STATUS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_DATOS  text
*----------------------------------------------------------------------*
FORM cambiar_status CHANGING ps_datos TYPE zsinv0001_grid.

  DATA: ps_ci TYPE ztinv_ci.

  DATA: lt_inv_sp TYPE STANDARD TABLE OF ztinv_sp,
        ls_inv_sp TYPE                   ztinv_sp.

  DATA: lt_spopli TYPE rsec_t_spopli,
        ls_spopli TYPE spopli.

  DATA: lt_status TYPE tty_status,
        ls_status TYPE ty_status.

  DATA: lv_index      LIKE sy-tabix,
        lv_selec      LIKE sy-tabix,
        lv_answer(1),
        lv_answer2(1).

  CLEAR: lt_inv_sp, lt_status.
  REFRESH: lt_inv_sp, lt_status.

* Nos guardamos las transiciones posibles de status:
  SELECT * INTO TABLE lt_inv_sp
    FROM ztinv_sp
    WHERE status = ps_datos-status
    AND txper = 'G'.

  IF lt_inv_sp[] IS NOT INITIAL. " Posibles cambio status

    " Preparamos los status posibles a seleccionar:
    LOOP AT lt_inv_sp INTO ls_inv_sp.
      READ TABLE t_dominio_status INTO wa_dominio
                 WITH KEY domvalue_l  = ls_inv_sp-status_new
                          ddlanguage = sy-langu.

      IF wa_dominio IS NOT INITIAL.
        lv_index = lv_index + 1.
        CLEAR ls_spopli.
        ls_spopli-varoption = wa_dominio-ddtext.
        APPEND ls_spopli TO lt_spopli.

        CLEAR ls_status.
        ls_status-domvalue_l = ls_inv_sp-status_new.
        ls_status-ddtext = wa_dominio-ddtext.
        ls_status-index = lv_index.
        ls_status-popup = ls_inv_sp-popup.
        APPEND ls_status TO lt_status.

      ENDIF.
    ENDLOOP.

    " Sacamos pop-up para selección cambio status:
    CLEAR: lv_answer, lv_selec.
    CALL FUNCTION 'POPUP_TO_DECIDE_LIST'
      EXPORTING
*       CURSORLINE               = 1
*       MARK_FLAG = ' '
*       MARK_MAX  = 1
*       START_COL = 0
*       START_ROW = 0
        textline1 = text-009
*       TEXTLINE2 = ' '
*       TEXTLINE3 = ' '
        titel     = text-008
*       DISPLAY_ONLY             = ' '
      IMPORTING
        answer    = lv_answer
      TABLES
        t_spopli  = lt_spopli
*     EXCEPTIONS
*       NOT_ENOUGH_ANSWERS       = 1
*       TOO_MUCH_ANSWERS         = 2
*       TOO_MUCH_MARKS           = 3
*       OTHERS    = 4
      .
*    IF sy-subrc <> 0.
** Implement suitable error handling here
*    ENDIF.

    IF lv_answer IS NOT INITIAL AND lv_answer <> 'A'.
      lv_selec = lv_answer.
      CLEAR ls_status.
      READ TABLE lt_status INTO ls_status WITH KEY index = lv_selec.
      IF ls_status IS NOT INITIAL.
        IF ls_status-popup = 'X'.
          CLEAR lv_answer2.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
*             TITLEBAR      = ' '
*             DIAGNOSE_OBJECT             = ' '
              text_question = text-012
              text_button_1 = text-010
*             ICON_BUTTON_1 = ' '
              text_button_2 = text-011
*             ICON_BUTTON_2 = ' '
*             DEFAULT_BUTTON              = '1'
*             DISPLAY_CANCEL_BUTTON       = 'X'
*             USERDEFINED_F1_HELP         = ' '
              start_column  = 10
              start_row     = 10
*             POPUP_TYPE    =
*             IV_QUICKINFO_BUTTON_1       = ' '
*             IV_QUICKINFO_BUTTON_2       = ' '
            IMPORTING
              answer        = lv_answer2
*         TABLES
*             PARAMETER     =
*         EXCEPTIONS
*             TEXT_NOT_FOUND              = 1
*             OTHERS        = 2
            .
*        IF sy-subrc <> 0.
*          Implement suitable error handling here
*        ENDIF.
          IF lv_answer2 = '1'. " Sí cambio status

            MOVE-CORRESPONDING ps_datos TO ps_ci.

            ps_ci-status = ls_status-domvalue_l.
            ps_ci-aedat = sy-datum.
            ps_ci-aezeit = sy-uzeit.
            ps_ci-aenam = sy-uname.

            UPDATE ztinv_ci FROM ps_ci.
            COMMIT WORK AND WAIT.

            IF sy-subrc = 0.
              zsinv0001_grid-status = ps_ci-status.

              READ TABLE lt_status INTO ls_status WITH KEY domvalue_l = ps_ci-status.
              IF sy-subrc = 0.
                zsinv0001_grid-status_txt = ls_status-ddtext.
              ENDIF.

              zsinv0001_grid-aedat = ps_ci-aedat.
              zsinv0001_grid-aezeit = ps_ci-aezeit.
              zsinv0001_grid-aenam = ps_ci-aenam.

              MOVE-CORRESPONDING ps_ci TO ps_datos.
              ps_datos-status_txt = ls_status-ddtext.

              PERFORM refrescar_alv_200.

            ENDIF.
          ELSE. " No cambio status
          ENDIF.

        ELSE. " Cambio de status automático
          MOVE-CORRESPONDING ps_datos TO ps_ci.

          ps_ci-status = ls_status-domvalue_l.
          ps_ci-aedat = sy-datum.
          ps_ci-aezeit = sy-uzeit.
          ps_ci-aenam = sy-uname.

          UPDATE ztinv_ci FROM ps_ci.
          COMMIT WORK AND WAIT.

          IF sy-subrc EQ 0.
            zsinv0001_grid-status = ps_ci-status.

            READ TABLE lt_status INTO ls_status WITH KEY domvalue_l = ps_ci-status.
            IF sy-subrc = 0.
              zsinv0001_grid-status_txt = ls_status-ddtext.
            ENDIF.

            zsinv0001_grid-aedat = ps_ci-aedat.
            zsinv0001_grid-aezeit = ps_ci-aezeit.
            zsinv0001_grid-aenam  = ps_ci-aenam.

            MOVE-CORRESPONDING ps_ci TO ps_datos.
            ps_datos-status_txt = ls_status-ddtext.

            PERFORM refrescar_alv_200.

          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

  ELSE. " No se puede cambiar de status

  ENDIF.
ENDFORM.                    " CAMBIAR_STATUS

**&---------------------------------------------------------------------*
**&      Form  CHEQUEAR_CENTRO
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_GV_WERKS  text
**----------------------------------------------------------------------*
*FORM chequear_centro  USING    p_werks TYPE werks_d
*                      CHANGING error.
*
*  DATA: lv_werks TYPE werks_d.
*
*  CLEAR lv_werks.
*  SELECT SINGLE werks INTO lv_werks
*    FROM t001w
*    WHERE werks = p_werks.
*
*  IF lv_werks IS INITIAL.
*    CLEAR: gv_okcode4.
*    error = 'X'.
*    MESSAGE i101.
*  ELSE.
*    AUTHORITY-CHECK OBJECT 'M_MATE_WRK'
*                ID 'ACTVT' FIELD '03'
*                ID 'WERKS' FIELD p_werks.
*
*    IF sy-subrc <> 0.
*      CLEAR: gv_okcode4.
*      error = 'X'.
*      MESSAGE i103(zmm) WITH p_werks.
*    ENDIF.
*
*  ENDIF.
*
*ENDFORM.                    " CHEQUEAR_CENTRO
**&---------------------------------------------------------------------*
**&      Form  CHEQUEAR_ALMACEN
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_GV_LGORT  text
**----------------------------------------------------------------------*
*FORM chequear_almacen  USING    p_lgort TYPE lgort_d
*                       CHANGING error.
*  DATA: lv_lgort TYPE lgort_d.
*
*  IF gv_lgort IS INITIAL.
*    error = 'X'.
*    MESSAGE i100(zmm).
*  ELSE.
*    CLEAR lv_lgort.
*    SELECT SINGLE lgort INTO lv_lgort
*      FROM t001l
*      WHERE werks = gv_werks
*      AND lgort = p_lgort.
*
*    IF lv_lgort IS INITIAL.
*      CLEAR: gv_lgort.
*      error = 'X'.
*      MESSAGE i102(zmm).
*    ENDIF.
*  ENDIF.
*ENDFORM.                    " CHEQUEAR_ALMACEN
*&---------------------------------------------------------------------*
*&      Form  F_FILE_OPEN_DIALOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_GV_FRONT  text
*----------------------------------------------------------------------*
FORM f_file_open_dialog  CHANGING gv_front.
  DATA: lt_files TYPE filetable,
        ls_files TYPE file_table,
        lv_rc    LIKE sy-subrc,
        ls_datos TYPE zsinv0001_grid,
        lt_fich  TYPE ztinv0001_pi.
*   READ TABLE gti_mostrar INTO ls_datos WITH KEY docum = zsinv0001_grid-docum.
*
*   if sy-subrc eq 0.
*      ls_files = ls_datos-tdname.
*      append ls_files to lt_files.
*   endif.
  DATA: fv_front_out TYPE string.
  CALL FUNCTION '/SAPDMC/LSM_F4_FRONTEND_FILE'
    EXPORTING
      pathname         = gv_front
    CHANGING
      pathfile         = fv_front_out
    EXCEPTIONS
      canceled_by_user = 1
      system_error     = 2
      OTHERS           = 3.
  IF sy-subrc EQ 0.
    MOVE fv_front_out TO gv_front.
  ENDIF.
*  IF sy-subrc <> 0.
** Implement suitable error handling here
*  ENDIF.
*
*  CALL FUNCTION 'F4_FILEN/SAPDMC/LSM_F4_FRONTEND_FILEAME'
**   EXPORTING
**     PROGRAM_NAME        = SYST-CPROG
**     DYNPRO_NUMBER       = SYST-DYNNR
**     FIELD_NAME          = ' '
*    IMPORTING
*      FILE_NAME           =
*            .
*
*  daTA: url type string.
*  url = gv_front.
*  CALL FUNCTION 'GUI_UPLOAD'
*    EXPORTING
*      filename                      = url
**     FILETYPE                      = 'ASC'
**     HAS_FIELD_SEPARATOR           = ' '
**     HEADER_LENGTH                 = 0
**     READ_BY_LINE                  = 'X'
**     DAT_MODE                      = ' '
**     CODEPAGE                      = ' '
**     IGNORE_CERR                   = ABAP_TRUE
**     REPLACEMENT                   = '#'
**     CHECK_BOM                     = ' '
**     VIRUS_SCAN_PROFILE            =
**     NO_AUTH_CHECK                 = ' '
**   IMPORTING
**     FILELENGTH                    =
**     HEADER                        =
*    tables
*      data_tab                      = lt_fich
**   CHANGING
**     ISSCANPERFORMED               = ' '
*   EXCEPTIONS
*     FILE_OPEN_ERROR               = 1
*     FILE_READ_ERROR               = 2
*     NO_BATCH                      = 3
*     GUI_REFUSE_FILETRANSFER       = 4
*     INVALID_TYPE                  = 5
*     NO_AUTHORITY                  = 6
*     UNKNOWN_ERROR                 = 7
*     BAD_DATA_FORMAT               = 8
*     HEADER_NOT_ALLOWED            = 9
*     SEPARATOR_NOT_ALLOWED         = 10
*     HEADER_TOO_LONG               = 11
*     UNKNOWN_DP_ERROR              = 12
*     ACCESS_DENIED                 = 13
*     DP_OUT_OF_MEMORY              = 14
*     DISK_FULL                     = 15
*     DP_TIMEOUT                    = 16
*     OTHERS                        = 17
*            .
*  IF sy-subrc <> 0.
** Implement suitable error handling here
*  ENDIF.

*  if gv_front is not INITIAL.
*     append gv_front to lt_files.
*  endif.
*
*  CALL METHOD cl_gui_frontend_services=>file_open_dialog
*    CHANGING
*      file_table              = lt_files
*      rc                      = lv_rc
*    EXCEPTIONS
*      file_open_dialog_failed = 1
*      cntl_error              = 2
*      error_no_gui            = 3
*      not_supported_by_gui    = 4
*      OTHERS                  = 5.
*
*  IF sy-subrc <> 0 OR lv_rc < 0.
**    MESSAGE e001.
**   Se ha producido un error al obtener fichero
*  ELSE.
*    CLEAR ls_files.
*    READ TABLE lt_files INDEX 1 INTO ls_files.
*    gv_front = ls_files-filename.
*  ENDIF.

ENDFORM.                    " F_FILE_OPEN_DIALOG
*&---------------------------------------------------------------------*
*&      Form  F_FRONT_PROCESS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_FRONT  text
*      <--P_GV_ERROR  text
*----------------------------------------------------------------------*
FORM f_front_process  USING    lp_front TYPE eseftfront
                      CHANGING lc_error TYPE flag.


  DATA: lt_fich TYPE ztinv0001_pi,
        wa_fich TYPE zsinv0001_pi,
        tt_fich TYPE zsinv0001_pi_m_tt.

  CLEAR lc_error.

  PERFORM f_subir_csv TABLES   lt_fich
                      USING    gv_file
                      CHANGING lc_error
                               tt_fich.

ENDFORM.                    " F_FRONT_PROCESS

*&---------------------------------------------------------------------*
*&      Form  GENERAR_FICHERO_EXPORT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM generar_fichero_export USING ps_datos TYPE zsinv0001_grid.


  DATA: t_ci_exp  TYPE ztinv0001_ci,
        wa_ci_exp TYPE zsinv0001_ci.

  DATA: t_pos      TYPE STANDARD TABLE OF ztinv_pi,
        wa_pos     TYPE                   ztinv_pi,

        t_pos_exp  TYPE                   ztinv0001_pi,
        wa_pos_exp TYPE                   zsinv0001_pi.

  DATA: i_tab_header TYPE         truxs_t_text_data,
        i_tab        TYPE         truxs_t_text_data,
        wa_itab      TYPE LINE OF truxs_t_text_data.

  DATA: lv_error TYPE flag.

  DATA: lv_ruta_exp TYPE rstxt-tdname.
  DATA archivo TYPE string.

  TYPES: BEGIN OF tipo_matnr,
           matnr TYPE matnr,
           maktx TYPE maktx.
  TYPES: END OF tipo_matnr.
  TYPES: tty_matnr TYPE STANDARD TABLE OF tipo_matnr.
  DATA: t_matnr  TYPE         tty_matnr,
        wa_matnr TYPE LINE OF tty_matnr,
        path     TYPE         rstxt-tdname.

  CLEAR: i_tab, i_tab_header, lv_ruta_exp, wa_ci_exp, t_ci_exp, t_pos,
         t_pos_exp, archivo.
  REFRESH: i_tab, i_tab_header, t_ci_exp, t_pos, t_pos_exp.
* SACAMOS PATH
  CALL FUNCTION 'ZTINV_TE_GET_PATH'
    EXPORTING
      term              = ps_datos-term
      sentido           = 'EXPORT'
    IMPORTING
      path              = path
    EXCEPTIONS
      no_existe         = 1
      terminal_inactivo = 2
      OTHERS            = 3.
  IF sy-subrc <> 0.
    MESSAGE e398(00) WITH 'Problemas ruta fichero'.
  ELSE.

    CONCATENATE path '\' ps_datos-codint '_' ps_datos-docum  '.csv' INTO lv_ruta_exp.
    TRANSLATE lv_ruta_exp TO UPPER CASE.
*    CONCATENATE gv_ruta_exp '\' ps_datos-codint '_' ps_datos-docum  '.csv' INTO lv_ruta_exp.
    DATA: lt_csv TYPE truxs_t_text_data.
    REFRESH lt_csv.
*--------------------------------------------------------
** open dataset
*--------------------------------------------------------
*    OPEN DATASET lv_ruta_exp FOR OUTPUT IN TEXT MODE ENCODING DEFAULT .
    IF sy-subrc = 0.

*--------------------------------------------------------
** cabecera
*--------------------------------------------------------
      MOVE-CORRESPONDING ps_datos TO wa_ci_exp .
      wa_ci_exp-tipo_reg = '0'.
      CASE ps_datos-mtart.
        WHEN 'ZREC'. MOVE 'R' TO wa_ci_exp-tipo_inv.
        WHEN 'ZPAP'. MOVE 'P' TO wa_ci_exp-tipo_inv.
      ENDCASE.
      APPEND wa_ci_exp TO t_ci_exp.

*   convertimos a csv (campos separados por ;
      CALL FUNCTION 'SAP_CONVERT_TO_CSV_FORMAT'
        EXPORTING
          i_field_seperator    = ';'
*         I_LINE_HEADER        =
*         I_FILENAME           = t_txt
*         I_APPL_KEEP          = ' '
        TABLES
          i_tab_sap_data       = t_ci_exp
        CHANGING
          i_tab_converted_data = i_tab_header
        EXCEPTIONS
          conversion_failed    = 1
          OTHERS               = 2.
*
*    IF sy-subrc = 0.
*--------------------------------------------------------
**    posición
*--------------------------------------------------------
      SELECT * FROM ztinv_pi
        INTO TABLE t_pos
        WHERE docum = ps_datos-docum
          AND version = ps_datos-version.

      IF t_pos[] IS NOT INITIAL.
        SELECT mara~matnr maktx FROM mara
          INNER JOIN makt ON mara~matnr = makt~matnr
          INTO TABLE t_matnr
          FOR ALL ENTRIES IN t_pos
          WHERE mara~matnr = t_pos-matnr AND
                spras = sy-langu.
      ENDIF.

      LOOP AT t_pos INTO wa_pos.
        MOVE-CORRESPONDING wa_pos TO wa_pos_exp.

        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
          EXPORTING
            input  = wa_pos-matnr
          IMPORTING
            output = wa_pos_exp-matnr.

        wa_pos_exp-tipo_reg = '1'.

*        READ TABLE t_matnr INTO wa_matnr WITH KEY matnr = wa_pos-matnr.
*        IF sy-subrc = 0.
*          wa_pos_exp-maktx = wa_matnr-maktx.
*        ENDIF.

        APPEND wa_pos_exp TO t_pos_exp.
      ENDLOOP.

*     convertimos a csv (campos separados por ;
      CALL FUNCTION 'SAP_CONVERT_TO_CSV_FORMAT'
        EXPORTING
          i_field_seperator    = ';'
*         I_LINE_HEADER        =
*         I_FILENAME           = t_txt
*         I_APPL_KEEP          = ' '
        TABLES
          i_tab_sap_data       = t_pos_exp
        CHANGING
          i_tab_converted_data = i_tab
        EXCEPTIONS
          conversion_failed    = 1
          OTHERS               = 2.

      APPEND LINES OF i_tab TO i_tab_header.

*------------------------------------------------------
**    descargamos la itab
*------------------------------------------------------
      archivo = lv_ruta_exp.

      CALL FUNCTION 'GUI_DOWNLOAD'
        EXPORTING
          filename                = archivo
          write_field_separator   = ';'
        TABLES
          data_tab                = i_tab_header
        EXCEPTIONS
          file_write_error        = 1
          no_batch                = 2
          gui_refuse_filetransfer = 3
          invalid_type            = 4
          no_authority            = 5
          unknown_error           = 6.
      IF sy-subrc <> 0.
        lv_error = 'X'.
      ENDIF.

    ELSE.
      lv_error = 'X'.
    ENDIF.
*  ELSE.
*    lv_error = 'X'.
*  ENDIF.

*--------------------------------------------------------
** close dataset
*--------------------------------------------------------
*    CLOSE DATASET lv_ruta_exp.

*--------------------------------------------------------
** mensajes
*--------------------------------------------------------
    IF lv_error = 'X'.
*   Error en la descarga del inventario
      MESSAGE i003(zinv) DISPLAY LIKE 'E'.
    ELSE.
*   El inventario se ha descargado en c:\temp
      MESSAGE i002(zinv) WITH path.
      UPDATE ztinv_ci SET tdname = lv_ruta_exp WHERE docum EQ ps_datos-docum.
      COMMIT WORK AND WAIT.
      DATA: r_out TYPE zsinv0001_grid.
      READ TABLE gti_mostrar INTO r_out WITH KEY docum = zsinv0001_grid-docum.
      r_out-tdname = zsinv0001_grid-tdname = lv_ruta_exp.

      MODIFY gti_mostrar FROM r_out INDEX sy-tabix.
      PERFORM refrescar_alv.
    ENDIF.




*  DATA: l_file TYPE string.
*
*  DATA: t_pos      TYPE STANDARD TABLE OF ztinv_pi,
*        wa_pos     TYPE                   ztinv_pi,
*
*        t_pos_exp  TYPE                   ztinv0001_pi,
*        wa_pos_exp TYPE                   zsinv0001_pi.
*
*  TYPES: BEGIN OF tipo_matnr,
*           matnr TYPE matnr,
*           maktx TYPE maktx.
*  TYPES: END OF tipo_matnr.
*  TYPES: tty_matnr TYPE STANDARD TABLE OF tipo_matnr.
*  DATA: t_matnr  TYPE         tty_matnr,
*        wa_matnr TYPE LINE OF tty_matnr.
*
*  CONCATENATE gv_ruta_exp '\' ps_datos-docum  '.xls' INTO l_file.
*
*
*  SELECT * FROM ztinv_pi
*    INTO TABLE t_pos
*    WHERE docum = ps_datos-docum.
*
*  IF t_pos[] IS NOT INITIAL.
*    SELECT mara~matnr maktx FROM mara
*      INNER JOIN makt ON mara~matnr = makt~matnr
*      INTO TABLE t_matnr
*      FOR ALL ENTRIES IN t_pos
*      WHERE mara~matnr = t_pos-matnr AND
*            spras = sy-langu.
*  ENDIF.
*
*
*  LOOP AT t_pos INTO wa_pos.
*    MOVE-CORRESPONDING wa_pos TO wa_pos_exp.
*
*    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
*      EXPORTING
*        input  = wa_pos-matnr
*      IMPORTING
*        output = wa_pos_exp-matnr.
*
*    wa_pos_exp-tipo_reg = '1'.
*
*    READ TABLE t_matnr INTO wa_matnr WITH KEY matnr = wa_pos-matnr.
*    IF sy-subrc = 0.
*      wa_pos_exp-maktx = wa_matnr-maktx.
*    ENDIF.
*
*      APPEND wa_pos_exp TO t_pos_exp.
*
*  ENDLOOP.
*
*
*CALL FUNCTION 'GUI_DOWNLOAD'
*  EXPORTING
**   BIN_FILESIZE                    =
*    filename                        = l_file
*   FILETYPE                        = 'ASC'
**   APPEND                          = ' '
**   WRITE_FIELD_SEPARATOR           = ' '
**   HEADER                          = '00'
**   TRUNC_TRAILING_BLANKS           = ' '
**   WRITE_LF                        = 'X'
**   COL_SELECT                      = ' '
**   COL_SELECT_MASK                 = ' '
**   DAT_MODE                        = ' '
**   CONFIRM_OVERWRITE               = ' '
**   NO_AUTH_CHECK                   = ' '
**   CODEPAGE                        = ' '
**   IGNORE_CERR                     = ABAP_TRUE
**   REPLACEMENT                     = '#'
**   WRITE_BOM                       = ' '
**   TRUNC_TRAILING_BLANKS_EOL       = 'X'
**   WK1_N_FORMAT                    = ' '
**   WK1_N_SIZE                      = ' '
**   WK1_T_FORMAT                    = ' '
**   WK1_T_SIZE                      = ' '
**   WRITE_LF_AFTER_LAST_LINE        = ABAP_TRUE
**   SHOW_TRANSFER_STATUS            = ABAP_TRUE
**   VIRUS_SCAN_PROFILE              = '/SCET/GUI_DOWNLOAD'
** IMPORTING
**   FILELENGTH                      =
*  tables
*    data_tab                        = t_pos_exp
**   FIELDNAMES                      =
** EXCEPTIONS
**   FILE_WRITE_ERROR                = 1
**   NO_BATCH                        = 2
**   GUI_REFUSE_FILETRANSFER         = 3
**   INVALID_TYPE                    = 4
**   NO_AUTHORITY                    = 5
**   UNKNOWN_ERROR                   = 6
**   HEADER_NOT_ALLOWED              = 7
**   SEPARATOR_NOT_ALLOWED           = 8
**   FILESIZE_NOT_ALLOWED            = 9
**   HEADER_TOO_LONG                 = 10
**   DP_ERROR_CREATE                 = 11
**   DP_ERROR_SEND                   = 12
**   DP_ERROR_WRITE                  = 13
**   UNKNOWN_DP_ERROR                = 14
**   ACCESS_DENIED                   = 15
**   DP_OUT_OF_MEMORY                = 16
**   DISK_FULL                       = 17
**   DP_TIMEOUT                      = 18
**   FILE_NOT_FOUND                  = 19
**   DATAPROVIDER_EXCEPTION          = 20
**   CONTROL_FLUSH_ERROR             = 21
**   OTHERS                          = 22
*          .
*IF sy-subrc <> 0.
** Implement suitable error handling here
*ENDIF.
  ENDIF.



ENDFORM.                    " GENERAR_FICHERO_EXPORT
*&---------------------------------------------------------------------*
*&      Form  CAMBIO_DE_STATUS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM cambio_de_status .
  DATA: ls_datos TYPE zsinv0001_grid,
        lv_ind   TYPE sy-tabix.

  READ TABLE gti_mostrar INTO ls_datos WITH KEY docum = zsinv0001_grid-docum.
  IF sy-subrc = 0.
    lv_ind = sy-tabix.
    PERFORM cambiar_status CHANGING ls_datos.
    MODIFY gti_mostrar FROM ls_datos INDEX lv_ind.

  ENDIF.

ENDFORM.                    " CAMBIO_DE_STATUS
*&---------------------------------------------------------------------*
*&      Form  EXPORT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM export .
  DATA: ls_datos TYPE zsinv0001_grid.

  READ TABLE gti_mostrar INTO ls_datos WITH KEY docum = zsinv0001_grid-docum.
*  IF ls_datos IS NOT INITIAL..
  IF sy-subrc EQ 0.
    PERFORM generar_fichero_export USING ls_datos.
  ENDIF.

ENDFORM.                    " EXPORT
*&---------------------------------------------------------------------*
*&      Form  IMPORT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM
  import .
  DATA: ls_datos TYPE zsinv0001_grid.

  DATA: lt_fich TYPE ztinv0001_pi,
        wa_fich TYPE zsinv0001_pi,
        wa_head TYPE zsinv0001_ci,
        tt_fich TYPE zsinv0001_pi_m_tt.


  DATA: wa_pi_new TYPE ztinv_pi.

  DATA: lv_status TYPE zstatus.

  DATA: lv_ind        TYPE sy-tabix,
        max_pos       TYPE posnr,
        lv_pos        TYPE sy-tabix,
        lv_docum_fich TYPE c LENGTH 10,
        lv_matnr      TYPE matnr,
        lv_dec        TYPE matnr,
        lv_version    TYPE zversn,
        lv_error      TYPE flag.
  IF NOT zsinv0001_grid-term IS INITIAL.
    CALL FUNCTION 'ZTINV_TE_GET_PATH'
      EXPORTING
        term                   = zsinv0001_grid-term
        sentido                = 'IMPORT'
      IMPORTING
        path                   = gv_file
      EXCEPTIONS
        no_existe              = 1
        terminal_inactivo      = 2
        problema_busqueda_ruta = 3
        OTHERS                 = 4.
*     PERFORM f_file_open_dialog CHANGING gv_file.
  ENDIF.

  PERFORM f_file_open_dialog CHANGING gv_file.
*  ENDIF.
  IF gv_file IS INITIAL.
    lv_error = 'X'.
    MESSAGE i005(zinv) DISPLAY LIKE 'E'.

  ENDIF.
  CHECK lv_error IS INITIAL.
  PERFORM f_subir_csv TABLES   lt_fich
                                USING    gv_file
                                CHANGING lv_error tt_fich.
  IF lv_error IS NOT INITIAL.
    MESSAGE i398(00) WITH text-fi1 gv_file.
  ENDIF.
*  PERFORM f_subir_xls TABLE++S   lt_fich
*                                USING    gv_file
*                                CHANGING lv_error.

  CHECK lv_error IS INITIAL.

  IF lt_fich[] IS INITIAL.
    lv_error = 'X'.
*   El fichero a cargar está vacio
    MESSAGE i005(zinv) DISPLAY LIKE 'E'.
  ELSE.

*   validamos que el status del fichero subido sea G y que el número de inventario del fichero
*   corresponda al número de inventario en el que estamos trabajando
*    READ TABLE lt_fich INTO wa_fich WITH KEY tipo_reg = '0'.
*
*    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*      EXPORTING
*        input  = wa_fich-matnr
*      IMPORTING
*        output = lv_docum_fich.
*
*    IF lv_docum_fich <> zsinv0001_grid-docum.
*      lv_error = 'X'.
**     El inventario del fichero no coincide con el inventario de trabajo
*      MESSAGE i013(zinv) DISPLAY LIKE 'E'.
*
*    ELSEIF wa_fich-lgort <> 'G'.
*      lv_error = 'X'.
**     El status indicado en el fichero es distinto a G
*      MESSAGE i006(zinv) DISPLAY LIKE 'E'.
*    puede haber dos inventarios en un fichero
*    CLEAR: wa_fich, wa_head.
*    READ TABLE lt_fich INTO wa_fich WITH KEY tipo_reg = '0'.
*    wa_head-tipo_reg  = wa_fich-tipo_reg.
*    wa_head-docum     = wa_fich-matnr.
*    wa_head-werks     = wa_fich-maktx.
*    wa_head-lgort     = wa_fich-werks.
*    wa_head-tipo_inv  = wa_fich-lgort.
*    wa_head-status    = wa_fich-charg.
*    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*      EXPORTING
*        input  = wa_head-docum
*      IMPORTING
*        output = lv_docum_fich.
    DATA: sw_del TYPE flag.
    CLEAR sw_del.
*   nos quedamos con el fichero que queremos
    DATA: sw_tabix LIKE sy-tabix.
    LOOP AT lt_fich INTO wa_fich.
      MOVE sy-tabix TO sw_tabix.
      CASE wa_fich-tipo_reg.
        WHEN '0'.
          CLEAR: wa_head, sw_del, lv_error.
*          wa_head-tipo_reg  = wa_fich-tipo_reg.
          wa_head-docum     = wa_fich-matnr.
*          wa_head-werks     = wa_fich-maktx.
*          wa_head-lgort     = wa_fich-werks.
*          wa_head-tipo_inv  = wa_fich-lgort.
*          wa_head-status    = wa_fich-charg.
          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = wa_head-docum
            IMPORTING
              output = lv_docum_fich.
          IF lv_docum_fich <> zsinv0001_grid-docum.
            MOVE 'X' TO: lv_error, sw_del.
            DELETE lt_fich INDEX sw_tabix.
          ENDIF.
        WHEN OTHERS.
          IF sw_del EQ 'X'.
            DELETE lt_fich INDEX sw_tabix.
          ENDIF.
      ENDCASE.
    ENDLOOP.
    CLEAR: wa_fich, wa_head.
    READ TABLE lt_fich INTO wa_fich WITH KEY tipo_reg = '0'.
    wa_head-tipo_reg  = wa_fich-tipo_reg.
    wa_head-docum     = wa_fich-matnr.
    wa_head-werks     = wa_fich-maktx.
    wa_head-lgort     = wa_fich-werks.
    wa_head-tipo_inv  = wa_fich-lgort.
    wa_head-status    = wa_fich-charg.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = wa_head-docum
      IMPORTING
        output = lv_docum_fich.

    IF lv_docum_fich <> zsinv0001_grid-docum.
      lv_error = 'X'.
*     El inventario del fichero no coincide con el inventario de trabajo
      MESSAGE i013(zinv) DISPLAY LIKE 'E'.

    ELSEIF wa_head-status <> 'G'.
      lv_error = 'X'.
*     El status indicado en el fichero es distinto a G
      MESSAGE i006(zinv) DISPLAY LIKE 'E'.
    ELSEIF ( zsinv0001_grid-mtart EQ 'ZPAP' AND wa_head-tipo_inv NE 'P' )
        OR ( zsinv0001_grid-mtart EQ 'ZREC' AND wa_head-tipo_inv NE 'R' ).
      lv_error = 'X'.
      MESSAGE i016(zinv) DISPLAY LIKE 'E'.
    ELSE.
      DATA: t_mensajes LIKE bapiret2 OCCURS 0 WITH HEADER LINE,
            t_inve_pi  LIKE ztinv_pi OCCURS 0 WITH HEADER LINE,
            sw_error,
            version    LIKE zsinv0001_grid-version.
      CALL FUNCTION 'ZTINV_COMPARAR'
        EXPORTING
          lt_fich    = lt_fich
          docum      = zsinv0001_grid-docum
        IMPORTING
          version    = version
          error      = lv_error
        TABLES
          t_mensajes = t_mensajes
          gti_pi     = t_inve_pi.
*      IF t_mensajes[] IS NOT INITIAL.
      PERFORM log_inventario TABLES t_mensajes USING zsinv0001_grid-docum 'FICHERO'.
*      ENDIF.
      IF t_inve_pi[] IS NOT INITIAL.
        DATA: sw_grabamos.
        PERFORM grabamos_pregunta USING lv_error zsinv0001_grid-docum CHANGING sw_grabamos.
        IF sw_grabamos EQ 'X'.
          REFRESH gti_pi.
          LOOP AT t_inve_pi.
            MOVE-CORRESPONDING t_inve_pi TO wa_pi.

            SELECT SINGLE maktx INTO wa_pi-maktx FROM makt WHERE matnr EQ t_inve_pi-matnr
                                                             AND spras EQ sy-langu.
            READ TABLE t_dominio_casuistica INTO wa_dominio
                             WITH KEY domvalue_l  = wa_pi-casuistica
                                      ddlanguage = sy-langu.
            IF wa_dominio IS NOT INITIAL.
              wa_pi-casuistica_txt = wa_dominio-ddtext.
            ENDIF.
            APPEND wa_pi TO gti_pi.
          ENDLOOP.
          SELECT SINGLE * INTO wa_ci FROM ztinv_ci WHERE docum EQ zsinv0001_grid-docum.
          zsinv0001_grid-version = version.
          wa_ci-version = version.
          wa_ci-status  = 'G'.
          wa_ci-aedat   = sy-datum.
          wa_ci-aezeit  = sy-uzeit.
          wa_ci-aenam   = sy-uname.
          IF t_mensajes[] IS NOT INITIAL.
            wa_ci-log =
            zsinv0001_grid-log = 'X'.
          ENDIF.
          UPDATE ztinv_ci FROM wa_ci.
          INSERT ztinv_pi FROM TABLE t_inve_pi.
          IF sy-subrc = 0.
            PERFORM guardar_mensajes TABLES t_mensajes USING zsinv0001_grid ''.
*            DATA posi LIKE ztinv_pi-posicion.
*            posi = 0.
*            LOOP AT t_mensajes.
*              ADD 1 TO posi.
*              CLEAR ztinv_log.
*              ztinv_log-mandt    = sy-mandt.
*              ztinv_log-docum    = zsinv0001_grid-docum.
*              ztinv_log-version  = zsinv0001_grid-version.
*              ztinv_log-posicion = posi.
*              ztinv_log-error    = lv_error.
*              ztinv_log-tipo     = t_mensajes-type.
*              ztinv_log-id       = t_mensajes-id.
*              ztinv_log-numero   = t_mensajes-number.
*              ztinv_log-m1       = t_mensajes-message_v1.
*              ztinv_log-m2       = t_mensajes-message_v2.
*              ztinv_log-m3       = t_mensajes-message_v3.
*              ztinv_log-m4       = t_mensajes-message_v4.
*              INSERT                ztinv_log FROM                ztinv_log.
*            ENDLOOP.
            COMMIT WORK AND WAIT.
            zsinv0001_grid-status  = wa_ci-status.
            zsinv0001_grid-aedat   = sy-datum.
            zsinv0001_grid-aezeit  = sy-uzeit.
            zsinv0001_grid-aenam   = sy-uname.
            zsinv0001_grid-version = wa_ci-version.
            DATA: r_out TYPE zsinv0001_grid.
            READ TABLE gti_mostrar INTO r_out WITH KEY docum = zsinv0001_grid-docum.
            r_out = zsinv0001_grid.
            MODIFY gti_mostrar FROM r_out INDEX sy-tabix.
            PERFORM impacto_economico USING '' CHANGING gv_imp_calc.
**           Fichero subido correctamente
*            MESSAGE i008(zinv).
          ELSE.
            lv_error = 'X'.
            ROLLBACK WORK.
*           Fichero no subido, error en la actualización de la tabla
            MESSAGE i009(zinv).
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
**      *      READ TABLE gti_mostrar INTO ls_datos WITH KEY docum = zsinv0001_grid-docum.
*
**      IF ls_datos IS NOT INITIAL.
*      IF sy-subrc EQ 0.
**       Si el inventario existe, incrementamos la versión y cargamos las nuevas posiciones
**       con la nueva versión (para guardar un histórico).
*        SELECT SINGLE * FROM ztinv_ci
*          INTO wa_ci
*          WHERE docum = ls_datos-docum.
*
**       recuperamos la maxima posición de la versión actual
*        SELECT MAX( posicion ) FROM ztinv_pi
*          INTO max_pos
*          WHERE docum = ls_datos-docum AND
*                version = wa_ci-version.
*
**        max_pos = max_pos + 1.
*
**       Incrementamos la versión de la cabecera
*        wa_ci-version = wa_ci-version + 1.
**        UPDATE ztinv_ci FROM wa_ci.
*
***       comparamos la versión actual con la versión del fichero para mostrar por pantalla
***       las diferencias y cargamos el nuevo fichero con la versión nueva (en t_pi_new)
**        clear: t_pi_new.
**        refresh: t_pi_new.
**
**        loop at gti_pi into wa_pi.
**          lv_ind = sy-tabix.
**
**          call function 'CONVERSION_EXIT_ALPHA_OUTPUT'
**            exporting
**              input  = wa_pi-matnr
**            importing
**              output = wa_pi-matnr.
**
**          read table lt_fich into wa_fich with key matnr = wa_pi-matnr
**                                                   charg = wa_pi-charg.
**
**          if sy-subrc = 0.
**            check wa_fich-tipo_reg = '1'.
**
***           actualizamos las posiciones que vemos en pantalla
**            if wa_pi-menge <> wa_fich-menge.
**              wa_pi-menge = wa_fich-menge.
**              wa_pi-menge_new = 'X'.
**            endif.
**
**            if wa_pi-lgort <> wa_fich-lgort.
**              wa_pi-zlgort = wa_fich-lgort.
**            endif.
**
**            wa_pi-contado = wa_fich-contado.
**
**            call function 'MOVE_CHAR_TO_NUM'
**              exporting
**                chr             = wa_fich-longitud
**              importing
**                num             = wa_pi-longitud
**              exceptions
**                convt_no_number = 1
**                convt_overflow  = 2
**                others          = 3.
**            if sy-subrc <> 0.
***             MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
***                     WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
**            endif.
**
**
***           CASUÍSTICA 1: Son materiales/lotes que han aparecido en un almacén físicamente
***                 y están dados de alta en otro
***                 contado = ' ' y existe = ''.
***           CASUÍSTICA 2:  Materiales /lotes que hemos contado en nuestro almacén a inventariar
***                 contado = 'X' y existe = ''
***           CASUÍSTICA 3: Materiales /lotes que hemos contado en nuestro almacén a inventariar.
***                        contado = 'X' y existe <> ''
***           CASUÍSTICA 4: Lotes que no hemos contado, por lo tanto no existen y habrá que darlos de baja
**
**            if wa_pi-lgort <> wa_fich-lgort.
**              wa_pi-casuistica = '1'.
**            else.
**              if wa_fich-contado = 'X' and wa_fich-existe = ''.
**                wa_pi-casuistica = '2'.
**              elseif wa_fich-contado = 'X' and wa_fich-existe <> ''.
**                wa_pi-casuistica = '3'.
**              elseif wa_fich-contado = '' and wa_fich-existe = ''.
**                wa_pi-casuistica = '4'.
**              endif.
**            endif.
**
**            read table t_dominio_casuistica into wa_dominio
**                               with key domvalue_l  = wa_pi-casuistica
**                                        ddlanguage = sy-langu.
**            if wa_dominio is not initial.
**              wa_pi-casuistica_txt = wa_dominio-ddtext.
**            endif.
**
**            wa_pi-erdat_mod = sy-datum.
**            wa_pi-erzeit_mod = sy-uzeit.
**            wa_pi-ernam_mod = sy-uname.
**
**            modify gti_pi from wa_pi index lv_ind.
**
**          else.
**
**            check wa_fich-tipo_reg = '1'.
**
***           Cargamos el nuevo fichero con la versión nueva
**            wa_pi_new-docum = wa_ci-docum.
**            wa_pi_new-version = wa_ci-version.
**            wa_pi_new-posicion = max_pos.
**            wa_pi_new-werks = wa_ci-werks.
**            wa_pi_new-lgort = wa_ci-lgort.
**            wa_pi_new-charg = wa_fich-charg.
**
**            call function 'CONVERSION_EXIT_ALPHA_INPUT'
**              exporting
**                input  = wa_fich-matnr
**              importing
**                output = wa_pi_new-matnr.
**
**            wa_pi_new-bstar = '1'.
**            wa_pi_new-menge = wa_fich-menge.
**
**            select single meins from mara
**              into wa_pi_new-meins
**              where matnr = wa_pi_new-matnr.
**
**            call function 'MOVE_CHAR_TO_NUM'
**              exporting
**                chr             = wa_fich-longitud
**              importing
**                num             = wa_pi_new-longitud
**              exceptions
**                convt_no_number = 1
**                convt_overflow  = 2
**                others          = 3.
**            if sy-subrc <> 0.
***              MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
***                      WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
**            endif.
**
**            wa_pi_new-contado = wa_fich-contado.
***             wa_pi_new-menge_new
***             wa_pi_new-ZERO_NEW
***             wa_pi_new-CASUISTICA
**            wa_pi_new-erdat = sy-datum.
**            wa_pi_new-erzeit = sy-uzeit.
**            wa_pi_new-ernam = sy-uname.
***             wa_pi_new-ERDAT_MOD
***             wa_pi_new-ERZEIT_MOD
***             wa_pi_new-ERNAM_MOD
**
**            append wa_pi_new to t_pi_new.
**
**            max_pos = max_pos + 1.
**          endif.
**        endloop.
*
*
**       buscamos las líneas del fichero que no estén inventariadas y las añadimos con la nueva versión
**       en la tabla interna t_pi_new
*
*        lv_pos = 1.
*
*        LOOP AT lt_fich INTO wa_fich WHERE tipo_reg = '1'.
*
*          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*            EXPORTING
*              input  = wa_fich-matnr
*            IMPORTING
*              output = wa_fich-matnr.
*
*          READ TABLE gti_pi INTO wa_pi WITH KEY matnr = wa_fich-matnr
*                                                charg = wa_fich-charg.
*          IF sy-subrc = 0.
*
*            lv_ind = sy-tabix.
*            wa_pi-read = 'X'.
*            wa_pi-version = wa_ci-version.
**           actualizamos las posiciones que vemos en pantalla
*            IF wa_pi-menge <> wa_fich-menge.
*              wa_pi-menge = wa_fich-menge.
*              wa_pi-menge_new = 'X'.
*            ENDIF.
*
*            IF wa_pi-lgort <> wa_fich-lgort.
*              wa_pi-zlgort = wa_fich-lgort.
*            ENDIF.
*
*            wa_pi-contado  = wa_fich-contado.
*            wa_pi-longitud = wa_fich-longitud.
**            CALL FUNCTION 'MOVE_CHAR_TO_NUM'
**              EXPORTING
**                chr             = wa_fich-longitud
**              IMPORTING
**                num             = wa_pi-longitud
**              EXCEPTIONS
**                convt_no_number = 1
**                convt_overflow  = 2
**                OTHERS          = 3.
**            IF sy-subrc <> 0.
***             MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
***                     WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
**            ENDIF.
*
*
**           CASUÍSTICA 1: Son materiales/lotes que han aparecido en un almacén físicamente
**                 y están dados de alta en otro
**                 contado = ' ' y existe = ''.
**           CASUÍSTICA 2:  Materiales /lotes que hemos contado en nuestro almacén a inventariar
**                 contado = 'X' y existe = ''
**           CASUÍSTICA 3: Materiales /lotes que hemos contado en nuestro almacén a inventariar.
**                        contado = 'X' y existe <> ''
**           CASUÍSTICA 4: Lotes que no hemos contado, por lo tanto no existen y habrá que darlos de baja
*
*            IF wa_ci-lgort <> wa_fich-lgort.
*              IF wa_fich-contado = 'X' AND wa_fich-existe = ''.
*                wa_pi-casuistica = '1'.
*              ENDIF.
*            ELSE.
*              IF wa_fich-contado = 'X'.
*                IF wa_fich-existe = ''.
*                  wa_pi-casuistica = '2'.
*                ELSE.
*                  IF wa_fich-existe = '9999'.
*                    wa_pi-casuistica = '3'.
*                  ENDIF.
*                ENDIF.
*              ELSE.
*                IF wa_fich-existe = ''.
*                  wa_pi-casuistica = '4'.
*                ENDIF.
*              ENDIF.
*            ENDIF.
*
*            IF wa_pi-casuistica IS NOT INITIAL.
*              READ TABLE t_dominio_casuistica INTO wa_dominio
*                               WITH KEY domvalue_l  = wa_pi-casuistica
*                                        ddlanguage = sy-langu.
*              IF wa_dominio IS NOT INITIAL.
*                wa_pi-casuistica_txt = wa_dominio-ddtext.
*              ENDIF.
*            ELSE.
*              CLEAR: wa_pi-casuistica_txt.
*            ENDIF.
*
*            wa_pi-erdat_mod = sy-datum.
*            wa_pi-erzeit_mod = sy-uzeit.
*            wa_pi-ernam_mod = sy-uname.
*
*            MODIFY gti_pi FROM wa_pi INDEX lv_ind.
*
*
*
*          ELSE.
**           actualizamos las posiciones que vemos en pantalla
*            max_pos = max_pos + 1.
*            wa_pi-docum = wa_ci-docum.
*            wa_pi-posicion = max_pos.
*            wa_pi-read     = 'X'.
*            wa_pi-version = wa_ci-version.
*            wa_pi-werks = wa_fich-werks.
*            wa_pi-lgort = ''.
*            wa_pi-zlgort = wa_fich-lgort.
*            wa_pi-charg = wa_fich-charg.
*            wa_pi-matnr = wa_fich-matnr.
*
*            SELECT SINGLE maktx FROM makt
*              INTO wa_pi-maktx
*              WHERE matnr = wa_fich-matnr AND
*                    spras = sy-langu.
*
*            wa_pi-bstar = '1'. ""stock libre (en almacén)
*            wa_pi-menge = wa_fich-menge.
*
*            SELECT SINGLE meins FROM mara
*              INTO wa_pi-meins
*              WHERE matnr = wa_fich-matnr.
*
*            wa_pi-menge_new = 'X'.
**
**            wa_pi-zero = ''.
**            wa_pi-devo = ''.
**            wa_pi-zero_new = ''.
*            wa_pi-contado = wa_fich-contado.
*
*
**           CASUÍSTICA 1: Son materiales/lotes que han aparecido en un almacén físicamente
**                 y están dados de alta en otro
**                 contado = ' ' y existe = ''.
**           CASUÍSTICA 2:  Materiales /lotes que hemos contado en nuestro almacén a inventariar
**                 contado = 'X' y existe = ''
**           CASUÍSTICA 3: Materiales /lotes que hemos contado en nuestro almacén a inventariar.
**                        contado = 'X' y existe <> ''
**           CASUÍSTICA 4: Lotes que no hemos contado, por lo tanto no existen y habrá que darlos de baja
*            IF wa_ci-lgort <> wa_fich-lgort.
*              IF wa_fich-contado = 'X' AND wa_fich-existe = ''.
*                wa_pi-casuistica = '1'.
*              ENDIF.
*            ELSE.
*              IF wa_fich-contado = 'X'.
*                IF wa_fich-existe = ''.
*                  wa_pi-casuistica = '2'.
*                ELSE.
*                  IF wa_fich-existe = '9999'.
*                    wa_pi-casuistica = '3'.
*                  ENDIF.
*                ENDIF.
*              ELSE.
*                IF wa_fich-existe = ''.
*                  wa_pi-casuistica = '4'.
*                ENDIF.
*              ENDIF.
*            ENDIF.
*
*            IF wa_pi-casuistica IS NOT INITIAL.
*              READ TABLE t_dominio_casuistica INTO wa_dominio
*                              WITH KEY domvalue_l  = wa_pi-casuistica
*                                       ddlanguage = sy-langu.
*              IF wa_dominio IS NOT INITIAL.
*                wa_pi-casuistica_txt = wa_dominio-ddtext.
*              ENDIF.
*            ELSE.
*              CLEAR: wa_pi-casuistica_txt.
*            ENDIF.
*
*            wa_pi-erdat = sy-datum.
*            wa_pi-erzeit = sy-uzeit.
*            wa_pi-ernam = sy-uname.
*            wa_pi-bstar = '1'.
*            APPEND wa_pi TO gti_pi.
*
*
*          ENDIF.
*
**         insertamos el registro en la itab donde recogemos la nueva versión de inventario.
*          MOVE-CORRESPONDING wa_fich TO wa_pi_new.
*          MOVE-CORRESPONDING wa_pi   TO wa_pi_new.
*          wa_pi_new-docum = wa_ci-docum.
*          wa_pi_new-version = wa_ci-version.
*          wa_pi_new-posicion = lv_pos.
*          wa_pi_new-erdat = sy-datum.
*          wa_pi_new-erzeit = sy-uzeit.
*          wa_pi_new-ernam = sy-uname.
*          wa_pi_new-bstar = '1'. ""stock libre (en almacén)
*          APPEND wa_pi_new TO t_pi_new.
*
*          lv_pos = lv_pos + 1.
*
*        ENDLOOP.
**        READ TABLE gti_pi WITH KEY read = '' INTO wa_pi.
**        IF sy-subrc EQ 0.
**          lv_error = 'X'.
**          MESSAGE i015(zinv).
**        ELSEIF lv_error NE 'X'.
**        IF lv_error NE 'X'.
**
**          IF t_pi_new[] IS NOT INITIAL
**          AND lv_error NE 'X'.
**            wa_ci-status = 'G'.
**            wa_ci-aedat  = sy-datum.
**            wa_ci-aezeit = sy-uzeit.
**            wa_ci-aenam  = sy-uname.
**            UPDATE ztinv_ci FROM wa_ci.
**            INSERT ztinv_pi FROM TABLE t_pi_new.
**            IF sy-subrc = 0.
**              COMMIT WORK AND WAIT.
**              zsinv0001_grid-status  = wa_ci-status.
**              zsinv0001_grid-aedat   = sy-datum.
**              zsinv0001_grid-aezeit  = sy-uzeit.
**              zsinv0001_grid-aenam   = sy-uname.
**              zsinv0001_grid-version = wa_ci-version.
**              DATA: r_out TYPE zsinv0001_grid.
**              READ TABLE gti_mostrar INTO r_out WITH KEY docum = zsinv0001_grid-docum.
**              r_out = zsinv0001_grid.
**
**              MODIFY gti_mostrar FROM r_out INDEX sy-tabix.
****           Fichero subido correctamente
***            MESSAGE i008(zinv).
**            ELSE.
**              lv_error = 'X'.
**              ROLLBACK WORK.
**
***           Fichero no subido, error en la actualización de la tabla
**              MESSAGE i009(zinv).
**            ENDIF.
**          ENDIF.
**        ENDIF.
*      ENDIF.
*        ENDIF.
*      ENDIF.
*  CHECK lv_error NE 'X'.

* Calculamos el impacto económico de las casuísticas 3 y 4
*  PERFORM impacto_economico USING '' CHANGING gv_imp_calc.
*  CLEAR: gv_imp_calc.
*
*  LOOP AT gti_pi INTO wa_pi WHERE casuistica = '3' OR casuistica = '4'.
*    CLEAR: lv_verpr, lv_peinh.
*
*    SELECT SINGLE verpr peinh FROM mbew
*      INTO ( lv_verpr, lv_peinh )
*      WHERE matnr = wa_pi-matnr.
*
**   impacto económico = cantidad inventariada * Precio / cantidad base
*    IF lv_peinh IS NOT INITIAL.
*      IF wa_pi-casuistica = '3' .
*        gv_imp_calc = gv_imp_calc + ( wa_pi-menge * lv_verpr / lv_peinh ).
*      ELSE.
*        gv_imp_calc = gv_imp_calc - ( wa_pi-menge * lv_verpr / lv_peinh ).
*      ENDIF.
*    ENDIF.
*  ENDLOOP.

* Refrescamos el ALV
  PERFORM refrescar_alv_200.

ENDFORM.                    " IMPORT
*&---------------------------------------------------------------------*
*&      Form  PREPARE_FIELCAT_200
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM prepare_fielcat_200 .

* Variable auxiliar
  DATA: ls_fieldcat  TYPE lvc_s_fcat,
        ls_group_alv TYPE lvc_s_sgrp.

* Recuperamos el catálogo de campos de la estructura
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZSINV0001_PI_GRID'
    CHANGING
      ct_fieldcat      = gti_fieldcat_200.

  LOOP AT gti_fieldcat_200 INTO ls_fieldcat.
    CASE ls_fieldcat-fieldname.
      WHEN 'DOCUM'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'WERKS'.
        ls_fieldcat-no_out = 'X'.

      WHEN 'MEINS'.
        ls_fieldcat-scrtext_l = text-013.
        ls_fieldcat-scrtext_m = text-013.
        ls_fieldcat-scrtext_s = text-013.
        ls_fieldcat-reptext   = text-013.

      WHEN 'ZERO'.
        ls_fieldcat-scrtext_l = text-014.
        ls_fieldcat-scrtext_m = text-014.
        ls_fieldcat-scrtext_s = text-014.
        ls_fieldcat-reptext   = text-014.

      WHEN 'DEVO'.
        ls_fieldcat-scrtext_l = text-015.
        ls_fieldcat-scrtext_m = text-015.
        ls_fieldcat-scrtext_s = text-015.
        ls_fieldcat-reptext   = text-015.

      WHEN 'PROCESADO'.
        ls_fieldcat-scrtext_l = text-016.
        ls_fieldcat-scrtext_m = text-016.
        ls_fieldcat-scrtext_s = text-016.
        ls_fieldcat-reptext   = text-016.

      WHEN 'CONTADO'.
        ls_fieldcat-scrtext_l = text-017.
        ls_fieldcat-scrtext_m = text-017.
        ls_fieldcat-scrtext_s = text-017.
        ls_fieldcat-reptext   = text-017.

      WHEN 'LONGITUD'.
        ls_fieldcat-scrtext_l = text-018.
        ls_fieldcat-scrtext_m = text-018.
        ls_fieldcat-scrtext_s = text-018.
        ls_fieldcat-reptext   = text-018.

      WHEN 'CASUISTICA'.
        ls_fieldcat-scrtext_l = text-019.
        ls_fieldcat-scrtext_m = text-019.
        ls_fieldcat-scrtext_s = text-019.
        ls_fieldcat-reptext   = text-019.

      WHEN 'CASUISTICA_TXT'.
        ls_fieldcat-scrtext_l = text-020.
        ls_fieldcat-scrtext_m = text-020.
        ls_fieldcat-scrtext_s = text-020.
        ls_fieldcat-reptext   = text-020.

      WHEN 'ERDAT_MOD'.
        ls_fieldcat-scrtext_l = text-021.
        ls_fieldcat-scrtext_m = text-021.
        ls_fieldcat-scrtext_s = text-021.
        ls_fieldcat-reptext   = text-021.

      WHEN 'ERZEIT_MOD'.
        ls_fieldcat-scrtext_l = text-022.
        ls_fieldcat-scrtext_m = text-022.
        ls_fieldcat-scrtext_s = text-022.
        ls_fieldcat-reptext   = text-022.

      WHEN 'ERNAM_MOD'.
        ls_fieldcat-scrtext_l = text-023.
        ls_fieldcat-scrtext_m = text-023.
        ls_fieldcat-scrtext_s = text-023.
        ls_fieldcat-reptext   = text-023.

      WHEN 'MENGE_NEW'.
        ls_fieldcat-scrtext_l = text-024.
        ls_fieldcat-scrtext_m = text-024.
        ls_fieldcat-scrtext_s = text-024.
        ls_fieldcat-reptext   = text-024.

      WHEN 'ZERO_NEW'.
        ls_fieldcat-scrtext_l = text-025.
        ls_fieldcat-scrtext_m = text-025.
        ls_fieldcat-scrtext_s = text-025.
        ls_fieldcat-reptext   = text-025.

      WHEN 'ZLGORT'.
        ls_fieldcat-scrtext_l = text-028.
        ls_fieldcat-scrtext_m = text-028.
        ls_fieldcat-scrtext_s = text-028.
        ls_fieldcat-reptext   = text-028.
    ENDCASE.

*   Modificamos
    MODIFY gti_fieldcat_200 FROM ls_fieldcat.
    CLEAR ls_fieldcat.
  ENDLOOP.

ENDFORM.                    " PREPARE_FIELCAT_200
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR_ALV_200
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM refrescar_alv_200 .
  DATA: ls_layout_200 TYPE lvc_s_layo,
        ls_stable     TYPE lvc_s_stbl.

* Sacamos el layout del ALV
  CALL METHOD g_grid_200->get_frontend_layout
    IMPORTING
      es_layout = ls_layout_200.

* Ponemos de nuevo que optimice las columnas
  ls_layout_200-cwidth_opt = 'X'.

* Cargamos de nuevo el layout
  CALL METHOD g_grid_200->set_frontend_layout
    EXPORTING
      is_layout = ls_layout_200.

* Refrescamos el ALV
  ls_stable-row = 'X'.
  ls_stable-col = 'X'.

  CALL METHOD g_grid_200->refresh_table_display
    EXPORTING
      is_stable = ls_stable.

ENDFORM.                    " REFRESCAR_ALV_200
*&---------------------------------------------------------------------*
*&      Form  FINALIZAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM finalizar .
  SELECT SINGLE * INTO wa_ci FROM ztinv_ci
      WHERE docum EQ zsinv0001_grid-docum. "JJR 01.02.2017
  PERFORM regularizar_stock USING wa_ci
                            CHANGING t_pi_new.
  PERFORM refrescar_alv_200.
ENDFORM.                    " FINALIZAR
*&---------------------------------------------------------------------*
*&      Form  REGULARIZAR_STOCK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GTI_PI_NEW  text
*----------------------------------------------------------------------*
FORM regularizar_stock  USING wa_ci TYPE ztinv_ci
                        CHANGING t_pi_new TYPE STANDARD TABLE.
* si CONTADO <> X y LGORT = TCI-LGORT: los ponemos a cero
* si CONTADO = X y LGORT = TCI-LGORT y ZLOGORT = 9999: los ponemos a cero
* si CONTADO = X y LGORT <> TCI-LGORT: habrá que hacer un 311.
* Sería conveniente antes de hacer nada, que el usuario de el OK al impacto
* económico
  PERFORM impacto_economico  USING space   CHANGING gv_imp_calc.
  DATA:  lv_question      TYPE c LENGTH 100,
         error            TYPE xfeld,
*         t_pi_mod         TYPE TABLE OF tipo_pos,
*         t_pi_error       TYPE TABLE OF tipo_pos,
         lv_answer(1),
         lv_charg         TYPE charg_d,
         lv_clabs         LIKE mchb-clabs,
         lv_imp_calc_char TYPE c LENGTH 14.

* El impacto económico es &. ¿Quiere finalizar el inventario?
  lv_imp_calc_char = gv_imp_calc.

  CONCATENATE 'El impacto económico es' lv_imp_calc_char '¿Quiere finalizar el inventario?'
  INTO lv_question SEPARATED BY space.

  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
*     TITLEBAR      = ' '
*     DIAGNOSE_OBJECT             = ' '
      text_question = lv_question
      text_button_1 = text-010
*     ICON_BUTTON_1 = ' '
      text_button_2 = text-011
*     ICON_BUTTON_2 = ' '
*     DEFAULT_BUTTON              = '1'
*     DISPLAY_CANCEL_BUTTON       = 'X'
*     USERDEFINED_F1_HELP         = ' '
      start_column  = 10
      start_row     = 10
*     POPUP_TYPE    =
*     IV_QUICKINFO_BUTTON_1       = ' '
*     IV_QUICKINFO_BUTTON_2       = ' '
    IMPORTING
      answer        = lv_answer
*         TABLES
*     PARAMETER     =
*         EXCEPTIONS
*     TEXT_NOT_FOUND              = 1
*     OTHERS        = 2
    .
*        IF sy-subrc <> 0.
*          Implement suitable error handling here
*        ENDIF.
  IF lv_answer = '1'. " Sí ìmpacto económico
    DATA: n_errores TYPE i.
    DATA: t_mensajes LIKE bapiret2 OCCURS 0 WITH HEADER LINE.
    REFRESH t_mensajes.
    n_errores = 0.
    LOOP AT gti_pi INTO wa_pi  WHERE casuistica IS NOT INITIAL
                                 AND procesado  NE 'X'.
      IF wa_pi-casuistica CA 'ACD'.
        mensaje 'I' 'ZINV' '024' wa_pi-matnr wa_pi-charg
                                 wa_pi-casuistica wa_pi-casuistica_txt t_mensajes.
      ENDIF.
      CLEAR error.
      CASE wa_pi-casuistica.
        WHEN 'A'. " SAP dice que el stock esta en un almacen y la pistola dice que esta aqui
          PERFORM mov_311 TABLES t_mensajes CHANGING wa_ci wa_pi error.
        WHEN 'B' OR 'E'.
*         no hacemos nada

        WHEN 'C'. " Afloramiento de stock
*         MSC1N en caso de que el material/lote no exista, MI10 para añadir el stock
          CLEAR: lv_charg, lv_clabs.
          DATA: sw_no_hacer_mi10.
          CLEAR sw_no_hacer_mi10.
          SELECT SINGLE charg clabs FROM mchb
            INTO (lv_charg, lv_clabs)
            WHERE matnr = wa_pi-matnr
              AND werks = wa_pi-werks
              AND lgort = wa_pi-zlgort
              AND charg = wa_pi-charg.

          IF sy-subrc <> 0.
            if wa_pi-zlgort is initial.
              wa_pi-zlgort = zsinv0001_grid-lgort.
            endif.
            wa_pi-lgort = wa_pi-zlgort.
            PERFORM crear_lote TABLES t_mensajes USING wa_pi
                               CHANGING error.
          ELSEIF lv_clabs > 0. " estamos intentando dar de alta STOCK y este ya esta
            DATA: diferencia LIKE mchb-clabs.
            diferencia = abs( lv_clabs - wa_pi-menge ).
            IF diferencia <= 9. " kilos
              MOVE 'X' TO sw_no_hacer_mi10.
*             El material/lote &/& ya estaba dado de alta en centro/almacen &/&
              mensaje 'W' 'ZINV' '028' wa_pi-matnr wa_pi-charg wa_pi-werks wa_pi-lgort
                             t_mensajes.
            ENDIF.
          ENDIF.
*          IF sw_no_hacer_mi10 EQ 'X'. "01.02.2017 JJR
          IF sw_no_hacer_mi10 EQ ''.   "01.02.2017 JJR
            IF error IS INITIAL.
              IF wa_pi-longitud IS NOT INITIAL.
                CALL FUNCTION 'ZTINV_LONGITUD_LOTE'
                  EXPORTING
                    matnr    = wa_pi-matnr
                    werks    = wa_pi-werks
                    charg    = wa_pi-charg
                    longitud = wa_pi-longitud
*                   COMMIT   = 'X'
*              IMPORTING
*                   OK       =
*              TABLES
*                   T_RETURN =
                  .
              ENDIF.

            ENDIF.
            IF error IS INITIAL.
              wa_pi-lgort = zsinv0001_grid-lgort.
              PERFORM mi10 TABLES t_mensajes USING wa_pi ''
                           CHANGING error.
            ENDIF.
          ENDIF.
        WHEN 'D'.
*         MI10 para restar stock.
          CLEAR: sw_no_hacer_mi10, lv_clabs.
          SELECT  clabs FROM mchb up to 1 ROWS
            INTO  lv_clabs
            WHERE matnr = wa_pi-matnr
              AND werks = wa_pi-werks
              AND lgort = wa_pi-lgort
              AND charg = wa_pi-charg.
          ENDSELECT.
          if sy-subrc eq 0
          and lv_clabs > 0.
            wa_pi-menge = 0. " ( -1 ) * wa_pi-menge.
            PERFORM mi10 TABLES t_mensajes USING wa_pi 'X'
                                           CHANGING error.
          else.
*             El material/lote &/& ya no está en el cen/alm &/&
              mensaje 'W' 'ZINV' '026' wa_pi-matnr wa_pi-charg wa_pi-werks wa_pi-lgort
                             t_mensajes.

          endif.
      ENDCASE.

      IF error IS INITIAL.

        MODIFY gti_pi FROM wa_pi.
        UPDATE ztinv_pi SET procesado = 'X'
                            erdat_mod  = sy-datum
                            erzeit_mod = sy-uzeit
                            ernam_mod  = sy-datum
                                        WHERE docum    = wa_pi-docum
                                          AND version  = wa_pi-version
                                          AND posicion = wa_pi-posicion.
        wa_pi-procesado = 'X'.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'
*     IMPORTING
*           RETURN        =
          .

*        APPEND wa_pi TO t_pi_mod.
        MODIFY gti_pi FROM wa_pi.
      ELSE.
        ADD 1 TO n_errores.
*        APPEND wa_pi TO t_pi_error.
      ENDIF.
    ENDLOOP.

    IF n_errores > 0.
*       ERROR al finalizar el inventario
      MESSAGE i014(zinv).

    ELSE.
      wa_ci-status = 'F'. "el estatus pasará a F.
      zsinv0001_grid-status = 'F'.
      zsinv0001_grid-aedat  = wa_ci-aedat  = sy-datum.
      zsinv0001_grid-aenam  = wa_ci-aenam  = sy-uname.
      zsinv0001_grid-aezeit = wa_ci-aezeit = sy-uzeit.
      DATA: r_out TYPE zsinv0001_grid.
      READ TABLE gti_mostrar INTO r_out WITH KEY docum = zsinv0001_grid-docum.
      r_out = zsinv0001_grid.
      MODIFY gti_mostrar FROM r_out INDEX sy-tabix.

      UPDATE ztinv_ci SET status = 'F'
      aedat  = sy-datum
                            aezeit = sy-uzeit
                            aenam  = sy-datum
                        WHERE docum = zsinv0001_grid-docum.
      IF sy-subrc = 0.
        COMMIT WORK.
*       Inventario finalizado
        MESSAGE i012(zinv).
      ENDIF.

    ENDIF.
    PERFORM guardar_mensajes TABLES t_mensajes USING zsinv0001_grid 'X'.
    PERFORM log_inventario TABLES t_mensajes USING zsinv0001_grid-docum 'PROCESAR'.

  ENDIF.
  PERFORM refrescar_alv_200.
ENDFORM.                    " REGULARIZAR_STOCK
*&---------------------------------------------------------------------*
*&      Form  MOV_311
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_PI  text
*----------------------------------------------------------------------*
FORM
  mov_311  TABLES t_men STRUCTURE bapiret2
              CHANGING wa_ci TYPE ztinv_ci
                       wa_pi TYPE tipo_pos
                       error.

  DATA: goodsmvt_header TYPE bapi2017_gm_head_01 OCCURS 0 WITH HEADER LINE,
        goodsmvt_code   TYPE bapi2017_gm_code OCCURS 0 WITH HEADER LINE,
        goodsmvt_item   TYPE bapi2017_gm_item_create OCCURS 0 WITH HEADER LINE,
        return          TYPE bapiret2 OCCURS 0 WITH HEADER LINE.


  CLEAR: goodsmvt_header, goodsmvt_code, goodsmvt_item, return.
  REFRESH: goodsmvt_header, goodsmvt_code, goodsmvt_item, return.


  goodsmvt_header-pstng_date = sy-datum.
  goodsmvt_header-doc_date = sy-datum.

  goodsmvt_code-gm_code = '04'.

  goodsmvt_item-material  = wa_pi-matnr.
  goodsmvt_item-plant =  wa_pi-werks.
  goodsmvt_item-stge_loc  =  wa_pi-lgort.
  goodsmvt_item-batch =  wa_pi-charg.
  goodsmvt_item-move_type = '311'.
  SELECT SUM( clabs ) INTO wa_pi-menge FROM mchb WHERE matnr EQ wa_pi-matnr
                                                   AND werks EQ wa_pi-werks
                                                   AND lgort EQ wa_pi-lgort
                                                   AND charg EQ wa_pi-charg.
  IF wa_pi-menge <= 0
  or sy-subrc ne 0.
*    El material/lote &/& ya no está en el cen/alm &/&
    mensaje 'W' 'ZINV' '026' wa_pi-matnr wa_pi-charg wa_pi-werks wa_pi-lgort
                             t_men.
    SELECT * UP TO 1 ROWS FROM mchb WHERE matnr EQ wa_pi-matnr
                                      AND charg EQ wa_pi-charg
                                      AND clabs > 0.
*      El material/lote &/& se encuentra en cen/alm &/&
      mensaje 'W' 'ZINV' '027' wa_pi-matnr wa_pi-charg mchb-werks mchb-lgort
                             t_men.
    ENDSELECT.

  ELSE.
    goodsmvt_item-entry_qnt = wa_pi-menge.
    goodsmvt_item-entry_uom = wa_pi-meins.

    goodsmvt_item-move_plant = wa_ci-werks. "Recieving/Issueing plant
    goodsmvt_item-move_stloc = wa_ci-lgort. "Reciving storage location

    APPEND goodsmvt_item.


    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header = goodsmvt_header
        goodsmvt_code   = goodsmvt_code
*       TESTRUN         = ' '
*       GOODSMVT_REF_EWM              =
* IMPORTING
*       GOODSMVT_HEADRET              =
*       MATERIALDOCUMENT              =
*       MATDOCUMENTYEAR =
      TABLES
        goodsmvt_item   = goodsmvt_item
*       GOODSMVT_SERIALNUMBER         =
        return          = return
*       GOODSMVT_SERV_PART_DATA       =
*       EXTENSIONIN     =
      .
  ENDIF.
  READ TABLE return WITH KEY type = 'E'.
  IF sy-subrc = 0.
    error = 'X'.
*    MESSAGE ID return-id TYPE 'I' NUMBER return-number WITH return-message_v1 return-message_v2 return-message_v3 return-message_v4.
*    MESSAGE text-010 TYPE 'W'.
  ENDIF.
  CHECK return[] IS NOT INITIAL.
  APPEND LINES OF return TO t_men.
ENDFORM.                    " MOV_311
*&---------------------------------------------------------------------*
*&      Form  CREAR_LOTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_PI  text
*      <--P_ERROR  text
*----------------------------------------------------------------------*
FORM crear_lote  TABLES t_mens STRUCTURE bapiret2
                USING    wa_pi  TYPE tipo_pos
                 CHANGING error.

  DATA: t_return TYPE bapiret2 OCCURS 0 WITH HEADER LINE.

  CLEAR: t_return. REFRESH: t_return.

  CALL FUNCTION 'BAPI_BATCH_CREATE'
    EXPORTING
      material             = wa_pi-matnr
      batch                = wa_pi-charg
      plant                = wa_pi-werks
*     BATCHATTRIBUTES      =
*     BATCHCONTROLFIELDS   =
      batchstoragelocation = wa_pi-zlgort
*     INTERNALNUMBERCOM    =
*     EXTENSION1           =
*     MATERIAL_EVG         =
* IMPORTING
*     BATCH                =
*     BATCHATTRIBUTES      =
    TABLES
      return               = t_return.

  READ TABLE t_return WITH KEY type = 'E'.
  IF sy-subrc = 0.
*    MESSAGE ID t_return-id TYPE 'I' NUMBER t_return-number WITH t_return-message_v1 t_return-message_v2 t_return-message_v3 t_return-message_v4.
    error = 'X'.
  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'
*         IMPORTING
*       RETURN        =
      .
  ENDIF.
  CHECK t_return[] IS NOT INITIAL.
  APPEND LINES OF t_return TO t_mens.


ENDFORM.                    " CREAR_LOTE
*&---------------------------------------------------------------------*
*&      Form  MI10
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_PI  text
*----------------------------------------------------------------------*
FORM mi10  TABLES t_mens STRUCTURE bapiret2
            USING    wa_pi TYPE tipo_pos VALUE(wa_null)
           CHANGING error.

  DATA: wa_datum(10).
  WRITE sy-datum TO wa_datum.
  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPMM07I' '0700'.
  PERFORM bdc_field       USING 'RM07I-ZLDAT'
                                wa_datum.
  PERFORM bdc_field       USING 'IKPF-WERKS'
                                wa_pi-werks.
  PERFORM bdc_field       USING 'IKPF-LGORT'
                                wa_pi-lgort.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '/00'.

*  DO 999 TIMES.
*  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPMM07I' '0731'.
  PERFORM bdc_field       USING 'ISEG-MATNR(01)'
                                 wa_pi-matnr.
  PERFORM bdc_field       USING 'ISEG-CHARG(01)'
                                 wa_pi-charg.
  IF wa_null IS INITIAL.
    DATA: menge(12).
    WRITE wa_pi-menge TO menge UNIT wa_pi-meins LEFT-JUSTIFIED.
    PERFORM bdc_field       USING 'ISEG-ERFMG(01)'
                                  menge.
    PERFORM bdc_field       USING 'ISEG-XNULL(01)'
                                  '' .
  ELSE.
    PERFORM bdc_field       USING 'ISEG-XNULL(01)'
                                'X' .
  ENDIF.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                               '/00'.
*  ENDDO.

*  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPMM07I' '0731'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                               '=BU'.

  CLEAR: i_messtab.
  REFRESH: i_messtab.

  CALL TRANSACTION 'MI10' USING bdcdata MODE modo_bi
                          MESSAGES INTO i_messtab
                          UPDATE 'S'.
  READ TABLE i_messtab WITH KEY msgtyp = 'E'.
  IF sy-subrc EQ 0. " Hay error
    MOVE 'X' TO error.
*    MESSAGE ID i_messtab-msgid TYPE 'I' NUMBER i_messtab-msgnr WITH i_messtab-msgv1 i_messtab-msgv2 i_messtab-msgv3 i_messtab-msgv4.
*    " Error general creación de orden:
*    CLEAR gs_messages.
*    gs_messages-type = 'E'.
*    gs_messages-number = '027'.
*    gs_messages-id = 'ZPP'.
*    APPEND gs_messages TO gt_messages.
  ELSE.
    READ TABLE i_messtab WITH KEY msgtyp = 'A'.
    IF sy-subrc EQ  0.
      MOVE 'X' TO error.
    ENDIF.
  ENDIF.
  CHECK i_messtab[] IS NOT INITIAL.
  DATA: t_mensa LIKE bapiret2 OCCURS 0 WITH HEADER LINE.
  REFRESH t_mensa.
  CALL FUNCTION 'CONVERT_BDCMSGCOLL_TO_BAPIRET2'
    TABLES
      imt_bdcmsgcoll = i_messtab
      ext_return     = t_mensa.
  APPEND LINES OF t_mensa TO t_mens.

ENDFORM.                    " MI10
*&---------------------------------------------------------------------*
*&      Form  F_SUBIR_XLS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_FICH  text
*      -->P_GV_FILE  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM f_subir_xls TABLES   lt_zssd0001 TYPE ztinv0001_pi
                 USING gv_file
                 CHANGING lc_error.


  DATA: lv_filename LIKE rlgrap-filename.

  DATA : it_file LIKE alsmex_tabline OCCURS 0 WITH HEADER LINE.

  TYPES : BEGIN OF  sbu_upload ,
            tipo_reg TYPE char1,
            matnr    TYPE matnr,
            maktx    TYPE maktx,
            werks    TYPE werks_d,
            lgort    TYPE lgort_d,
            charg    TYPE charg_d,
            menge    TYPE zmenge_d,
            longitud TYPE zmenge_d,
            contado  TYPE xfeld,
            existe   TYPE lgort_d,
          END OF sbu_upload .

  DATA tbu_upload TYPE STANDARD TABLE OF sbu_upload  WITH HEADER LINE.
  DATA: pack TYPE p DECIMALS 2.

  lv_filename = gv_file.

  CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
    EXPORTING
      filename                = lv_filename
      i_begin_col             = '1'
      i_begin_row             = '1'
      i_end_col               = '9999'
      i_end_row               = '9999'
    TABLES
      intern                  = it_file
    EXCEPTIONS
      inconsistent_parameters = 1
      upload_ole              = 2
      OTHERS                  = 3.

  IF sy-subrc <> 0.
*   Implement suitable error handling here
  ELSE.
    LOOP AT it_file.
      CASE it_file-col.
        WHEN '0001'.
          MOVE it_file-value TO tbu_upload-tipo_reg.

        WHEN '0002'.
          MOVE it_file-value TO tbu_upload-matnr.

        WHEN '0003'.
          MOVE it_file-value TO tbu_upload-maktx.

        WHEN '0004'.
          MOVE it_file-value TO tbu_upload-werks.

        WHEN '0005'.
          MOVE it_file-value TO tbu_upload-lgort.

        WHEN '0006'.
          MOVE it_file-value TO tbu_upload-charg.

        WHEN '0007'.
          IF it_file-value IS NOT INITIAL.
            CALL FUNCTION 'MOVE_CHAR_TO_NUM'
              EXPORTING
                chr             = it_file-value
              IMPORTING
                num             = pack
              EXCEPTIONS
                convt_no_number = 1
                convt_overflow  = 2
                OTHERS          = 3.
            IF sy-subrc <> 0.
*             Implement suitable error handling here
            ELSE.
              tbu_upload-menge = pack.
            ENDIF.
          ENDIF.

        WHEN '0008'.
          MOVE it_file-value TO tbu_upload-longitud.

        WHEN '0009'.
          MOVE it_file-value TO tbu_upload-contado.

        WHEN '0010'.
          MOVE it_file-value TO tbu_upload-existe.
      ENDCASE.

      AT END OF row.
        APPEND tbu_upload.
        CLEAR tbu_upload.
      ENDAT.
    ENDLOOP.
  ENDIF.

  lt_zssd0001[] = tbu_upload[].

ENDFORM.                    " F_SUBIR_XLS
*&---------------------------------------------------------------------*
*&      Form  IMPACTO_ECONOMICO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GTI_PI  text
*      <--P_GV_IMP_CALC  text
*----------------------------------------------------------------------*
FORM impacto_economico  USING VALUE(p_alv)
                        CHANGING gv_imp_calc.
  DATA: t_alv_ie LIKE ztinv_pi_scr OCCURS 0 WITH HEADER LINE.
  REFRESH t_alv_ie.

  CLEAR: gv_imp_calc.
  DATA: wa_pi TYPE tipo_pos.
  LOOP AT gti_pi INTO wa_pi WHERE casuistica CA 'ACD'
                              AND procesado NE 'X'.
    CLEAR: lv_verpr, lv_peinh.
    CLEAR t_alv_ie.
    MOVE-CORRESPONDING wa_pi TO t_alv_ie.

    SELECT SINGLE verpr peinh stprs vprsv FROM mbew
      INTO (lv_verpr, lv_peinh, lv_stprs, lv_vprsv)
      WHERE matnr = wa_pi-matnr
        AND bwkey = wa_pi-werks.
    CASE lv_vprsv.
      WHEN 'V'.
        t_alv_ie-vmver = lv_verpr.
      WHEN 'S'.
        t_alv_ie-vmver =
              lv_verpr = lv_stprs.
    ENDCASE.
    t_alv_ie-peinh = lv_peinh.
*   impacto económico = cantidad inventariada * Precio / cantidad base
    CASE wa_pi-casuistica.
      WHEN 'A'.
        t_alv_ie-tcode = 'MIGO 311'.
      WHEN 'C'  " afloran
        OR 'D'. " desaparecen
        IF lv_peinh IS NOT INITIAL.
          CASE wa_pi-casuistica .
            WHEN 'C'.
              t_alv_ie-calculo = wa_pi-menge * lv_verpr / lv_peinh.
              gv_imp_calc = gv_imp_calc + ( wa_pi-menge * lv_verpr / lv_peinh ).
              t_alv_ie-sign = '+'.
              t_alv_ie-tcode = 'MI10 +'.
            WHEN 'D'.
              t_alv_ie-calculo = -1 * wa_pi-menge * lv_verpr / lv_peinh.
              t_alv_ie-sign = '-'.
              gv_imp_calc = gv_imp_calc - ( wa_pi-menge * lv_verpr / lv_peinh ).
              t_alv_ie-tcode = 'MI10 0'.
          ENDCASE.

        ENDIF.
    ENDCASE.
    APPEND t_alv_ie.
  ENDLOOP.

  CHECK p_alv EQ 'X' AND t_alv_ie[] IS NOT INITIAL.
  CALL FUNCTION 'DISPLAY_BASIC_LIST'
    EXPORTING
*     BASIC_LIST_TITLE    =
      file_name           = 'PP'
*     HEAD_LINE1          = ' '
*     HEAD_LINE2          = ' '
*     HEAD_LINE3          = ' '
*     HEAD_LINE4          = ' '
*     FOOT_NOTE1          = ' '
*     FOOT_NOTE2          = ' '
*     FOOT_NOTE3          = ' '
*     LAY_OUT             = 0
*     DYN_PUSHBUTTON_TEXT1       =
*     DYN_PUSHBUTTON_TEXT2       =
*     DYN_PUSHBUTTON_TEXT3       =
*     DYN_PUSHBUTTON_TEXT4       =
*     DYN_PUSHBUTTON_TEXT5       =
*     DYN_PUSHBUTTON_TEXT6       =
      data_structure      = 'ZTINV_PI_SCR'
*     CURRENT_REPORT      =
*     LIST_LEVEL          = ' '
*     ADDITIONAL_OPTIONS  = ' '
*     WORD_DOCUMENT       =
*     APPLICATION         =
*     OLDVALUES           = ' '
*     NO_ALV_GRID         =
*     ALV_MARKER          =
*   IMPORTING
*     RETURN_CODE         =
    TABLES
      data_tab            = t_alv_ie
*     FIELDNAME_TAB       =
*     SELECT_TAB          =
*     ERROR_TAB           =
*     RECEIVERS           =
    EXCEPTIONS
      download_problem    = 1
      no_data_tab_entries = 2
      table_mismatch      = 3
      print_problems      = 4
      OTHERS              = 5.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.

ENDFORM.                    " IMPACTO_ECONOMICO
*&---------------------------------------------------------------------*
*&      Form  BLOQUEAR_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_ZSINV0001_GRID_DOCUM  text
*      -->P_0215   text
*      <--P_SW_BLOQUEADO  text
*----------------------------------------------------------------------*
FORM bloquear_inventario  USING    p_docum
                                   VALUE(p_accion)
                          CHANGING p_bloqueado.
  CASE p_accion.
    WHEN 'B'.
      CALL FUNCTION 'ENQUEUE_EZINV'
        EXPORTING
*         MODE_ZTINV_CI  = 'E'
*         MANDT          = SY-MANDT
          docum          = p_docum
*         X_DOCUM        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
        MOVE c_no TO p_bloqueado.
        DATA: uname LIKE sy-uname.
        uname = sy-msgv1.
        MESSAGE i018(zinv) WITH p_docum uname.
      ELSE.
        MOVE c_si TO p_bloqueado.
      ENDIF.

    WHEN 'D'.
      CALL FUNCTION 'DEQUEUE_EZINV'
        EXPORTING
*         MODE_ZTINV_CI       = 'E'
*         MANDT = SY-MANDT
          docum = p_docum
*         X_DOCUM             = ' '
*         _SCOPE              = '3'
*         _SYNCHRON           = ' '
*         _COLLECT            = ' '
        .
      MOVE c_si TO p_bloqueado.
  ENDCASE.
ENDFORM.                    " BLOQUEAR_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  LOG_INVENTARIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T_MENSAJES  text
*      -->P_ZSINV0001_GRID_DOCUM  text
*----------------------------------------------------------------------*
FORM log_inventario  TABLES   t_mensajes STRUCTURE bapiret2
                     USING    p_docum VALUE(donde).
  DATA: titulo TYPE baltitle.
  CHECK t_mensajes[] IS NOT INITIAL.
  CASE donde.
    WHEN 'LOG'.
      CONCATENATE text-sho p_docum INTO titulo.
    WHEN 'FICHERO'.
      CONCATENATE text-log p_docum INTO titulo.
    WHEN 'PROCESAR'.
      CONCATENATE text-pro p_docum INTO titulo.
  ENDCASE.
  CALL FUNCTION 'SUSR_DISPLAY_LOG'
    EXPORTING
      display_in_popup = 'X'
      log_title        = titulo
*     DISPLAY_IN_SUBSCREEN       =
    TABLES
*     IT_LOG_SPROT     =
      it_log_bapiret2  = t_mensajes
    EXCEPTIONS
      parameter_error  = 1
      OTHERS           = 2.
ENDFORM.                    " LOG_INVENTARIO
*&---------------------------------------------------------------------*
*&      Form  GRABAMOS_PREGUNTA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_ERROR  text
*      -->P_ZSINV0001_GRID_DOCUM  text
*      <--P_SW_GRABAMOS  text
*----------------------------------------------------------------------*
FORM grabamos_pregunta  USING    p_error
                                 p_docum
                        CHANGING p_grabamos.
  CLEAR p_grabamos.
  IF p_error NE 'X'.
    MOVE 'X' TO p_grabamos.
  ELSE.
    DATA: respuesta.
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
*       TITLEBAR      = ' '
*       DIAGNOSE_OBJECT             = ' '
        text_question = text-029 " Fichero de inventario erróneo
        text_button_1 = text-030 " Grabar
*       ICON_BUTTON_1 = ' '
        text_button_2 = text-031 " No grabar
*       ICON_BUTTON_2 = ' '
*       DEFAULT_BUTTON              = '1'
*       DISPLAY_CANCEL_BUTTON       = 'X'
*       USERDEFINED_F1_HELP         = ' '
        start_column  = 10
        start_row     = 10
*       POPUP_TYPE    =
*       IV_QUICKINFO_BUTTON_1       = ' '
*       IV_QUICKINFO_BUTTON_2       = ' '
      IMPORTING
        answer        = respuesta
*         TABLES
*       PARAMETER     =
*         EXCEPTIONS
*       TEXT_NOT_FOUND              = 1
*       OTHERS        = 2
      .
*        IF sy-subrc <> 0.
*          Implement suitable error handling here
*        ENDIF.
    CHECK respuesta EQ '1'.
    MOVE 'X' TO p_grabamos.
  ENDIF.
ENDFORM.                    " GRABAMOS_PREGUNTA
*&---------------------------------------------------------------------*
*&      Form  GUARDAR_MENSAJES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T_MENSAJES  text
*      -->P_ZSINV0001_GRID  text
*----------------------------------------------------------------------*
FORM guardar_mensajes  TABLES   t_mensajes STRUCTURE bapiret2
                       USING    r_zsinv0001_grid TYPE zsinv0001_grid
                               VALUE(p_commit).
  CHECK t_mensajes[] IS NOT INITIAL.
  DELETE FROM ztinv_log WHERE docum EQ r_zsinv0001_grid-docum
                          AND version EQ r_zsinv0001_grid-version.
  DATA posi LIKE ztinv_pi-posicion.
  posi = 0.
  LOOP AT t_mensajes.
    ADD 1 TO posi.
    CLEAR ztinv_log.
    ztinv_log-mandt    = sy-mandt.
    ztinv_log-docum    = r_zsinv0001_grid-docum.
    ztinv_log-version  = r_zsinv0001_grid-version.
    ztinv_log-posicion = posi.
    ztinv_log-error    = lv_error.
    ztinv_log-tipo     = t_mensajes-type.
    ztinv_log-id       = t_mensajes-id.
    ztinv_log-numero   = t_mensajes-number.
    ztinv_log-m1       = t_mensajes-message_v1.
    ztinv_log-m2       = t_mensajes-message_v2.
    ztinv_log-m3       = t_mensajes-message_v3.
    ztinv_log-m4       = t_mensajes-message_v4.
    INSERT                ztinv_log FROM                ztinv_log.
  ENDLOOP.
  CHECK p_commit EQ 'X'.
  COMMIT WORK AND WAIT.
ENDFORM.                    " GUARDAR_MENSAJES
