
class ZCLPP_RECETAS_REPARTO_PULPER definition
  public
  final
  create public .

public section.

  data GT_ZTPP0043 type ZTTPP0043 .
  constants GC_REMITENTE_MAIL type AD_SMTPADR value 'sap@hinojosa.es' ##NO_TEXT.

  methods CONSTRUCTOR
    importing
      !I_WERKS type WERKS_D
      !I_LGORT_ROLLO type FIP_T_LGORT_RANGE
      !I_LGORT_PULPER type LGORT_D
      !I_D_INI_RO type DATUM
      !I_H_INI_RO type UZEIT
      !I_D_FIN_RO type DATUM
      !I_H_FIN_RO type UZEIT
      !I_D_FIN_MP type DATUM
      !I_H_FIN_MP type UZEIT
      !I_APLICAR_CRONO type CHAR1 .
  class-methods GENERAR_MOVIMIENTO_261
    importing
      !IT_BAPI_ITEMS type TAB_BAPI_GOODSMVT_ITEM
      !I_TP_CONSUMO type CHAR01
      !I_NO_COMMIT type FLAG optional
    exporting
      !O_MBLNR type MBLNR
      !O_MJAHR type MJAHR
      !O_RC type CHAR02
      !OT_BAPIRET2 type BAPIRET2_T .
  class-methods OBTENER_LOTES_HERM_DSD_SINETIQ
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_KGS type LABST
      !I_LGORT type LGORT_D
      !I_LIFNR type LIFNR
    exporting
      !OT_ZTPP0041 type ZTTPP0041 .
  class-methods OBTENER_LOTES_FICT_DSD_SIN_ETI
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_KGS type LABST
      !I_LGORT type LGORT_D
      !I_LIFNR type LIFNR
    exporting
      !OT_ZTPP0041 type ZTTPP0041 .
  class-methods GENERAR_MOVIMIENTO_311
    importing
      !I_MOVIMIENTO_311_312 type BWART default '311'
      !I_MATNR type MATNR
      !I_CHARG type CHARG_D
      !I_WERKS type WERKS_D
      !I_LGORT_ORI type LGORT_D
      !I_LGORT_DES type LGORT_D default '4002'
      !I_CANTIDAD type MENGE_D
      !I_COMMIT type FLAG
    exporting
      !O_RC type CHAR2 .
  class-methods SUSTITUIR_FICT_X_SIN_ETIQUETA
    importing
      !I_WERKS type WERKS_D
      !I_RECETA type ZID_RECETA
      !I_FICT type CHARG_D
      !I_SIN_ETIQ type CHARG_D
      !I_OPERARIO type ZNOMBRE_OPER default ' '
    exporting
      !O_RC type CHAR02 .
  class-methods CONSUMIR_LOTE_MP
    importing
      !I_WERKS type WERKS_D
      !I_RECETA type ZID_RECETA
      !I_MATNR type MATNR
      !I_FICT type CHARG_D
      !I_SIN_ETIQ type CHARG_D
      !I_LGORT_ORI type LGORT_D
      !I_CANTIDAD type MENGE_D
      !I_OPERARIO type ZNOMBRE_OPER default ' '
      !I_OLD type FLAG default ' '
    exporting
      !O_RC type CHAR02
      !O_MBLNR type MBLNR
      !O_MJAHR type MJAHR
      !O_MESSAGE type BAPI_MSG
      !O_LOTE_HERMANO type CHARG_D .
  class-methods MARCAR_FICTICIOS_SIN_PAREJA
    importing
      !I_WERKS type WERKS_D
      !I_UBICACION type LGORT_D .
  class-methods CALCULAR_FECHAS
    importing
      !I_WERKS type WERKS_D
    exporting
      !O_D_INI_RO type DATUM
      !O_H_INI_RO type UZEIT
      !O_D_FIN_RO type DATUM
      !O_H_FIN_RO type UZEIT
      !O_D_FIN_MP type DATUM
      !O_H_FIN_MP type UZEIT .
  class-methods PROCESAR_ERRORES_PENDIENTES
    importing
      !I_WERKS type WERKS_D .
  methods OBTENER_DATOS_RESERVA
    importing
      !I_LOTE_ROLLO type CHARG_D
      !I_OF_ROLLO type AUFNR
      !I_MATNR type MATNR
    exporting
      !O_SW_RES type FLAG
      !O_RESERVA type RSNUM
      !O_RESERVA_POS type RSPOS .
  methods PROCESAR_REPARTO_PULPER .
  methods ENVIAR_MAIL_ERRORES_PROCESO .
  methods ENVIAR_MAIL_AVISO_DESVIACION
    importing
      !I_NUM_MIN type SYTABIX .
  methods ENVIAR_MAIL_CRONO_OVERFLOW
    importing
      !I_KG_ACUMULADOS type MENGE_D .
  class-methods OBTENER_DESCR_MATERIAL
    importing
      !I_MATNR type MATNR
    returning
      value(R_MAKTX) type MAKTX .
  class-methods OBTENER_DATOS_TRAZABILIDAD
    importing
      !I_WERKS type WERKS_D
      !IR_LOTES_ROLLO type ZPPR_CHARG_D
      !IR_RECETAS type ZRRID_RECETA optional
    returning
      value(RT_DATOS_TRAZABILIDAD) type ZTTPP_RECETAS_TRAZABILIDAD .
  class-methods ACTUALIZAR_PMV_BATCH
    importing
      !I_WERKS type WERKS_D
      !I_MODO_TEST type ABAP_BOOL
    exporting
      !O_SIN_ETIQ_BLANC type ZTTPP0041
      !O_SIN_ETIQ_1 type ZTTPP0041
      !O_SIN_ETIQ_999 type ZTTPP0041 .
  class-methods OBTENER_ULTIMA_PRODUCCION
    importing
      !I_WERKS type WERKS_D
    returning
      value(R_KG_ULTIMA_EJEC) type MENGE_D .
protected section.
private section.

  types:
    BEGIN OF ty_rollos_fabricados,
      matnr TYPE matnr,
*      maktx_fab TYPE maktx,
      charg TYPE charg_d,
      aufnr TYPE aufnr,
      stat  TYPE j_status,
      menge TYPE menge_d,
      meins TYPE meins,
      rsnum TYPE rsnum,

    END OF ty_rollos_fabricados .
  types:
    BEGIN OF ty_mp_consumida,
      matnr      TYPE matnr,
      charg      TYPE charg_d,
      menge      TYPE menge_d,
      menge_cons TYPE menge_d,
      meins      TYPE meins,
      procesado  TYPE xflag,
      id_receta  TYPE zid_receta,
    END OF ty_mp_consumida .
  types:
    BEGIN OF ty_mp_consumida_tot,
      matnr TYPE matnr,
      menge TYPE menge_d,
      meins TYPE meins,
*      procesado  TYPE xflag,
    END OF ty_mp_consumida_tot .
  types:
    BEGIN OF ty_lista_mat_x_reserva,
      rsnum TYPE rsnum,
      rspos TYPE rspos,
      matnr TYPE matnr,
*      procesado  TYPE xflag,
    END OF ty_lista_mat_x_reserva .
  types:
    BEGIN OF ty_datos_traz_receta,
      werks       TYPE werks_d,
      id_receta   TYPE zid_receta,
      zcalidad    TYPE zzcalidad,
      descrip_rec TYPE zdescrip_rec,
    END OF ty_datos_traz_receta .
  types:
    BEGIN OF ty_datos_traz_doc_material,
      werks    TYPE werks_d,
      mblnr    TYPE mblnr,
      mjahr    TYPE mjahr,
      lifnr    TYPE lifnr,
      name1_gp TYPE name1_gp,
    END OF ty_datos_traz_doc_material .
  types:
    BEGIN OF ty_datos_traz_rollo,
      werks     TYPE werks_d,
      charg     TYPE charg_d,
      fecha_fab TYPE datum,
      hora_fab  TYPE uzeit,
    END OF ty_datos_traz_rollo .
  types:
    BEGIN OF ty_charg_err,
           charg     TYPE charg_d,
           fecha_pul TYPE datum,
           hora_pul  TYPE uzeit,
         END OF ty_charg_err .
  types:
    tty_charg_err TYPE STANDARD TABLE OF ty_charg_err .
  types:
    tty_rollos_fabricados TYPE STANDARD TABLE OF ty_rollos_fabricados .
  types:
    tty_mp_consumida      TYPE STANDARD TABLE OF ty_mp_consumida .
  types:
    tty_mp_consumida_tot  TYPE STANDARD TABLE OF ty_mp_consumida_tot .
  types:
    tyy_lista_mat_x_reserva  TYPE STANDARD TABLE OF ty_lista_mat_x_reserva .
  types:
    tty_datos_traz_receta       TYPE STANDARD TABLE OF ty_datos_traz_receta .
  types:
    tty_datos_traz_doc_material TYPE STANDARD TABLE OF ty_datos_traz_doc_material .
  types:
    tty_datos_traz_rollo TYPE STANDARD TABLE OF ty_datos_traz_rollo .

  data GT_ZTPP0044 type ZTTPP0044 .
  data GT_MAT_PRIMA type TTY_MP_CONSUMIDA .
  data GT_LISTA_MAT_X_RESERVA type TYY_LISTA_MAT_X_RESERVA .
  data GT_ROLLOS_FABRICADOS type ZTTPP_ROLLOS_FABRICADOS .
  class-data GC_PROGRAM type PROGNAME value 'ZRPP0002_V2' ##NO_TEXT.
  data G_WERKS type WERKS_D .
  data GR_LGORT_ROLLO type FIP_T_LGORT_RANGE .
  data G_LGORT_PULPER type LGORT_D .
  data G_FECHA_FIN_MP type DATUM .
  data G_HORA_FIN_MP type UZEIT .
  data G_FECHA_INI_ROLLOS type DATUM .
  data G_FECHA_FIN_ROLLOS type DATUM .
  data G_HORA_INI_ROLLOS type UZEIT .
  data G_HORA_FIN_ROLLOS type UZEIT .
  data GW_ERROR_EN_PROCESO type FLAG .
  class-data GT_DESCR_MATERIAL type MAKT_TAB .
  class-data GT_DATOS_TRAZ_REC type TTY_DATOS_TRAZ_RECETA .
  class-data GT_DATOS_TRAZ_DOC_MAT type TTY_DATOS_TRAZ_DOC_MATERIAL .
  class-data GT_DATOS_TRAZ_ROLLO type TTY_DATOS_TRAZ_ROLLO .
  data GT_BAPIRET2 type BAPIRET2_T .
*  DATA g_minutos_crono TYPE int4 .
  data G_FECHA_CRONO type DATUM .
  data G_HORA_CRONO type UZEIT .
  data GS_ZTPP0003 type ZTPP0003 .
  data GS_ZTPP0046 type ZTPP0046 .
  data G_KG_HERMANOS_CRONO type MENGE_D .
  data G_FACTOR_CORRECTOR type ZFACTOR_PROD .

  methods GENERAR_REPARTO_TEORICO .
  methods OBTENER_FABRICACION_ROLLOS .
  methods OBTENER_LOTES_MP_PULPER .
  class-methods GRABAR_REPARTO_ZTPP0043_44
    changing
      !CS_ZTPP0043 type ZTPP0043
      !CS_ZTPP0044 type ZTPP0044 optional .
  methods GRABAR_TABLA_ZTPP0003 .
  methods PROCESAR_REPARTO_ROLLO
    importing
      !IT_ITEMS_BAPI type TAB_BAPI_GOODSMVT_ITEM
      !I_LOTE_ROLLO type CHARG_D
      !IW_SOLO_GRABAR_43 type FLAG default ' '
    exporting
      !OT_BAPIRET2 type BAPIRET2_T .
  class-methods OBTENER_DATOS_TRAZ_RECETA
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
    returning
      value(RS_DATOS_REC) type TY_DATOS_TRAZ_RECETA .
  class-methods OBTENER_DATOS_TRAZ_DOC_MAT
    importing
      !I_WERKS type WERKS_D
      !I_MBLNR type MBLNR
      !I_MJAHR type MJAHR
    returning
      value(RS_DATOS_DOC_MAT) type TY_DATOS_TRAZ_DOC_MATERIAL .
  class-methods OBTENER_DATOS_TRAZ_ROLLO
    importing
      !I_WERKS type WERKS_D
      !I_CHARG type CHARG_D
    returning
      value(RS_DATOS_ROLLO) type TY_DATOS_TRAZ_ROLLO .
  methods OBTENER_LOTES_MP_PULPER_CRONO .
  methods OBTENER_PARAMETROS_CRONO .
  methods CALCULAR_DIF_CRONO_VS_FECHAS
    returning
      value(R_DURACION) type SYTABIX .
  methods CALCULAR_FACTOR_N_DIAS
    exporting
      !O_FECHA_INI_FAC type DATUM
      !O_FECHA_FIN_FAC type DATUM
      !KG_MP_FACT type MENGE_D
      !KG_PROD_FACT type MENGE_D
      !FACTOR type ZFACTOR_PROD .
  methods ACTUALIZAR_PMV_A_LOTES_MP .
  methods CALCULAR_FACTOR_CORRECTOR .
endclass. "ZCLPP_RECETAS_REPARTO_PULPER definition
class ZCLPP_RECETAS_REPARTO_PULPER implementation.
***************************************************************************
* Actualizamos el registro de la tabla con la última fecha/hora procesada *
***************************************************************************

  METHOD GRABAR_TABLA_ZTPP0003.

    UPDATE ztpp0003 SET fecha         =  g_fecha_fin_rollos
                        hora          =  g_hora_fin_rollos
                        factor_correc =  gs_ztpp0003-factor_correc
                        min_desv      =  gs_ztpp0003-min_desv
*                        kg_mp       =  gs_ztpp0003-kg_mp
*                        kg_rollos   =  gs_ztpp0003-kg_rollos
                WHERE werks = g_werks

                AND progname = zclpp_recetas_reparto_pulper=>gc_program.

  ENDMETHOD.
*********************************************************************************
*  02/01//2020 CMS                                                              *
*                                                                               *
*  Reparto Pulper.                                                              *
*  A partir de la selección anterior de rollos fabricado y MP consumida en      *
*  pulper, se realiza el el reparto.                                            *                                                                             *
*                                                                               *
*                                                                               *
*********************************************************************************

  METHOD procesar_reparto_pulper.

    DATA: ls_ztpp0044           TYPE ztpp0044,
          ls_bapi_items         TYPE bapi2017_gm_item_create,
          lt_bapi_items         TYPE TABLE OF bapi2017_gm_item_create,
          lt_bapi_items_no_resb TYPE TABLE OF bapi2017_gm_item_create.
    DATA: gr_table_print TYPE REF TO cl_salv_table,
          lw_ctec        TYPE flag.

    CLEAR : gw_error_en_proceso.

    gs_ztpp0046-n_rollos_ok = lines( gt_rollos_fabricados ).
* Rellenamos los items para cada rollo, con o sin reseva...
    LOOP AT gt_rollos_fabricados INTO DATA(ls_rollos).
      CLEAR: lt_bapi_items ,lt_bapi_items_no_resb .

* Validamos si la orden está en estado CTEC, entonces siempre sin reserva.
      SELECT SINGLE aufnr INTO @DATA(l_aufnr)
        FROM aufk AS a
        INNER JOIN jest AS j ON a~objnr = j~objnr
        WHERE a~aufnr = @ls_rollos-aufnr AND
              j~stat  = 'I0045'.  " Estado OF --> CTEC (Cierre Técnico)
      IF sy-subrc = 0.
        lw_ctec = 'X'.
      ELSE.
        lw_ctec = ' '.
      ENDIF.

      LOOP AT gt_ztpp0043 ASSIGNING FIELD-SYMBOL(<ztpp0043>) WHERE lote_rollo = ls_rollos-charg.

        CLEAR: ls_bapi_items.
        ls_bapi_items-material     = <ztpp0043>-matnr_mp.
        ls_bapi_items-plant        = g_werks.
        ls_bapi_items-stge_loc     = <ztpp0043>-almacen_pm.
        ls_bapi_items-batch        = <ztpp0043>-lote_mp.
        ls_bapi_items-move_type    = '261'.
        ls_bapi_items-stck_type    = ' '. " Libre utilización
        ls_bapi_items-entry_qnt    = <ztpp0043>-kg_mp.
        ls_bapi_items-entry_uom    = 'KG'.
        ls_bapi_items-orderid      = <ztpp0043>-of_rollo.

        IF lw_ctec = ' '. " Si la OF NO está en estado CTEC, miramos si hay datos de reserva.
          CALL METHOD obtener_datos_reserva
            EXPORTING
              i_lote_rollo  = <ztpp0043>-lote_rollo
              i_of_rollo    = <ztpp0043>-of_rollo
              i_matnr       = <ztpp0043>-matnr_mp
            IMPORTING
              o_sw_res      = DATA(l_sw_res)
              o_reserva     = ls_bapi_items-reserv_no
              o_reserva_pos = ls_bapi_items-res_item.
        ENDIF.

        IF l_sw_res = 'X'  AND lw_ctec = ' '.
          APPEND ls_bapi_items TO lt_bapi_items.
        ELSE.
          APPEND ls_bapi_items TO lt_bapi_items_no_resb.
        ENDIF.

      ENDLOOP.

** Procesamos items CON Reserva
      IF lt_bapi_items IS NOT INITIAL.
        CALL METHOD procesar_reparto_rollo
          EXPORTING
            it_items_bapi     = lt_bapi_items
            i_lote_rollo      = ls_rollos-charg
            iw_solo_grabar_43 = ' ' " iw_solo_grabar_43
          IMPORTING
            ot_bapiret2       = DATA(lt_bapiret2).
      ENDIF.

* Procesamos items SIN Reserva
      IF lt_bapi_items_no_resb IS NOT INITIAL.
        CALL METHOD procesar_reparto_rollo
          EXPORTING
            it_items_bapi     = lt_bapi_items_no_resb
            i_lote_rollo      = ls_rollos-charg
            iw_solo_grabar_43 = ' ' "iw_solo_grabar_43
          IMPORTING
            ot_bapiret2       = lt_bapiret2.
      ENDIF.

    ENDLOOP.

*    IF iw_solo_grabar_43 = ' '.


* Actualizamos el PMV de todos los lotes consumidos.
    CALL METHOD actualizar_pmv_a_lotes_mp.


    IF gw_error_en_proceso = 'X'.
      CALL METHOD enviar_mail_errores_proceso.
    ENDIF.

*    ENDIF.

* Sumatorio Kg.PULPER despues del proceso
    SELECT SUM( clabs ) INTO @DATA(l_suma_kg_pulper)
      FROM  mchb
      WHERE   werks = @g_werks
        AND   lgort = @g_lgort_pulper
        AND   lvorm = @space
        AND   clabs > 0
* Filtramos los registros erroneos, para no repartirlos de nuevo.
        AND   charg NOT IN ( SELECT lote_mp
                              FROM ztpp0044
                              WHERE werks           = @g_werks AND
                                    ind_err_activo  = 'X'
                            ).

    WRITE :/.
    WRITE :/ |Kg. totales Pulper DESPUES del proceso: { l_suma_kg_pulper }|.
    WRITE :/.
    gs_ztpp0046-kg_pulper_fin = l_suma_kg_pulper.

    CALL METHOD grabar_tabla_ztpp0003.

* Grabación del registro de log con la información del proceso
    INSERT ztpp0046 FROM gs_ztpp0046.

  ENDMETHOD.
*******************************************************************************************
*                                                                                         *
* Se seleccionarán los lotes MP ficticios que cumplan los siguientes criterios:           *
*                                                                                         *
* •	Que el lote MP ficticio esté pendiente tratar (indicador lectura sin etiqueta = 1)    *
* •	Que el lote MP “hermano” sea del mismo material, tenga el mismo peso, se encuentre    *
*   en la misma ubicación y tenga el mismo proveedor que el lote a regularizar.           *
* •	Que la lectura del lote ficticio no haya sido anterior a 3 meses.                     *
*                                                                                         *
*******************************************************************************************
  METHOD obtener_lotes_fict_dsd_sin_eti.
    DATA: l_fecha_3m TYPE datum.

* Restamos 3 meses a la fecha actual para filtrar lotes ficticios.
    CALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'
      EXPORTING
        date      = sy-datum
        days      = 0
        months    = 3
        signum    = '-'
        years     = 0
      IMPORTING
        calc_date = l_fecha_3m.

    SELECT z~* INTO TABLE @ot_ztpp0041
      FROM ztpp0041 AS z
      INNER JOIN mseg AS m ON m~matnr = z~matnr AND
                              m~werks = z~werks AND
*                              m~lgort = z~lgort AND
                              m~charg = z~lote_mp_hermano
      WHERE z~werks         = @i_werks AND
            z~matnr         = @i_matnr AND
            z~kg_reales     = @i_kgs   AND
*            z~lgort         = @i_lgort AND
            m~bwart         = '101'    AND
            m~lifnr         = @i_lifnr AND
            z~ind_sin_etiq  = '1' AND
            z~fecha_ins     >= @l_fecha_3m.

IF sy-subrc <> 0.

  SELECT z~* INTO TABLE @ot_ztpp0041
      FROM ztpp0041 AS z
      INNER JOIN mseg AS m ON m~matnr = z~matnr_equiv AND
                              m~werks = z~werks AND
*                              m~lgort = z~lgort AND
                              m~charg = z~lote_mp_hermano
      WHERE z~werks         = @i_werks AND
            z~matnr_equiv   = @i_matnr AND
            z~kg_reales     = @i_kgs   AND
*            z~lgort         = @i_lgort AND
            m~bwart         = '101'    AND
            m~lifnr         = @i_lifnr AND
            z~ind_sin_etiq  = '1' AND
            z~fecha_ins     >= @l_fecha_3m.


ENDIF.

  ENDMETHOD.
*******************************************************************************************
*                                                                                         *
* Se seleccionarán los lotes MP ficticios que cumplan los siguientes criterios:           *
*                                                                                         *
* •	Que el lote MP ficticio esté pendiente tratar (indicador lectura sin etiqueta = 1)    *
* •	Que el lote MP “hermano” sea del mismo material, tenga el mismo peso,
*   se encuentre en la misma ubicación ---> 26/02/2020-CMS-59274 Se anula filtro de ubicación!
* y tenga el mismo proveedor que el lote a regularizar.           *
* •	Que la lectura del lote ficticio no haya sido anterior a 3 meses.                     *
*                                                                                         *
*******************************************************************************************
  METHOD obtener_lotes_herm_dsd_sinetiq.
    DATA: l_fecha_3m TYPE datum.

* Restamos 3 meses a la fecha actual para filtrar lotes ficticios.

    CALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'
      EXPORTING
        date      = sy-datum
        days      = 0
        months    = 3
        signum    = '-'
        years     = 0
      IMPORTING
        calc_date = l_fecha_3m.



    SELECT z~* INTO TABLE @ot_ztpp0041
      FROM ztpp0041 AS z
      INNER JOIN mseg AS m ON m~matnr = z~matnr AND
                              m~werks = z~werks AND
                              m~charg = z~charg
      WHERE z~werks           = @i_werks AND
            z~matnr           = @i_matnr AND
            z~kg_reales       = @i_kgs   AND
            z~lote_mp_hermano = ' ' AND
            m~bwart           = '101'    AND
            m~lifnr           = @i_lifnr AND
            z~fecha_ins       >= @l_fecha_3m.

* 69611 - 24/11/2021 - Si no se encuentran lotes hermanos con el propio material,
* buscamos el mismo material en el campo MATNR_EQUIV, para encontrar los equivalentes.
    IF sy-subrc <> 0.
      SELECT z~* INTO TABLE @ot_ztpp0041
        FROM ztpp0041 AS z
        INNER JOIN mseg AS m ON m~matnr = z~matnr_equiv AND
                                m~werks = z~werks AND
                                m~charg = z~charg
        WHERE z~werks           = @i_werks AND
              z~matnr_equiv     = @i_matnr AND
              z~kg_reales       = @i_kgs   AND
              z~lote_mp_hermano = ' ' AND
              m~bwart           = '101'    AND
              m~lifnr           = @i_lifnr AND
              z~fecha_ins       >= @l_fecha_3m.

    ENDIF.


    "JCB 06.11.24. Nuevo cálculo
    IF ot_ztpp0041 IS INITIAL.
      SELECT mseg~werks, mseg~matnr, mseg~charg, mseg~cpudt_mkpf AS fecha_ins, mseg~cputm_mkpf AS hora_ins, mseg~menge AS kg_reales
        INTO CORRESPONDING FIELDS OF TABLE @ot_ztpp0041
        FROM mseg INNER JOIN mch1 ON mch1~matnr = mseg~matnr AND
                                     mch1~charg = mseg~charg
        WHERE mseg~werks       = @i_werks AND
              mseg~matnr       = @i_matnr AND
              mseg~menge       = @i_kgs   AND
              mseg~bwart       = '311'    AND
              mch1~lifnr       = @i_lifnr AND
              mseg~lgort       = '4002'   AND       "TODO: Revisar este hardcode
              mseg~cpudt_mkpf  >= @l_fecha_3m.


      LOOP AT ot_ztpp0041 ASSIGNING FIELD-SYMBOL(<fs_ztpp0041>).
        IF <fs_ztpp0041>-hora_ins BETWEEN '060000' AND '135959'.
          <fs_ztpp0041>-turno = 'T1'.
        ELSEIF <fs_ztpp0041>-hora_ins BETWEEN '140000' AND '215959'.
          <fs_ztpp0041>-turno = 'T2'.
        ELSE.
          <fs_ztpp0041>-turno = 'T3'.
        ENDIF.

        SELECT SINGLE id_receta
          INTO <fs_ztpp0041>-id_receta
          FROM ztpp0040
          WHERE werks = <fs_ztpp0041>-werks AND
                ( fecha_ini < <fs_ztpp0041>-fecha_ins OR ( fecha_ini = <fs_ztpp0041>-fecha_ins AND hora_ini <= <fs_ztpp0041>-hora_ins  ) ) AND
                ( fecha_fin > <fs_ztpp0041>-fecha_ins OR ( fecha_fin = <fs_ztpp0041>-fecha_ins AND hora_fin >= <fs_ztpp0041>-hora_ins  ) ).
      ENDLOOP.
*  operario  TYPE znombre_oper,
    ENDIF.










  ENDMETHOD.
  METHOD actualizar_pmv_a_lotes_mp.
    DATA: l_any TYPE lfgja,
          l_mes TYPE lfmon.

    LOOP AT gt_mat_prima INTO DATA(ls_mp).


      SELECT SINGLE * INTO @DATA(ls_datos_bala)
        FROM ztpp0041
        WHERE werks     = @g_werks         AND
              id_receta = @ls_mp-id_receta AND
              charg     = @ls_mp-charg.

      IF sy-subrc = 0.

        CLEAR: l_any , l_mes.
        l_any = sy-datum(4).
        l_mes = sy-datum+4(2).


* Obtener la suma valoraciones de los distintos registros de cada rollo del cual se consume.
        SELECT SUM( dmbtr ) INTO @ls_datos_bala-pmv
            FROM mseg
          WHERE werks = @g_werks AND
                charg = @ls_mp-charg AND
                bwart = '261'.
          IF sy-subrc <> 0 .
            clear ls_datos_bala-pmv.
          ENDIF.

*        CALL METHOD zclpp_consumo_recetas_mp=>obtener_precio_medio_variable
*          EXPORTING
*            i_werks            = g_werks
*            i_matnr            = ls_mp-matnr
*            i_kg_reales        = ls_mp-menge
*            i_any              = l_any
*            i_mes              = l_mes
*          IMPORTING
*            o_precio_medio_var = ls_datos_bala-pmv
*           o_importe_pmv      =
          .
        ls_datos_bala-ind_lote_consum = 'X'.
        MODIFY ztpp0041 FROM ls_datos_bala.


* Búsqueda de fictios pendientes, para asignar el mismo PMV.
        SELECT * INTO TABLE @DATA(lt_hermanos)
          FROM ztpp0041
          WHERE werks           = @g_werks AND
                id_receta       =  @ls_mp-id_receta AND
                charg           LIKE '999%' AND
                ind_sin_etiq    = '1' AND
                lote_mp_hermano = @ls_mp-charg.
        IF sy-subrc = 0.

          LOOP AT lt_hermanos INTO DATA(ls_herm).

            ls_herm-pmv = ls_datos_bala-pmv.
            MODIFY ztpp0041 FROM ls_herm.

          ENDLOOP.

        ENDIF.



      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD actualizar_pmv_batch.
    DATA: l_cont_blanc       TYPE i,
          l_cont_blanc_ko    TYPE i,
          l_cont_herm        TYPE i,
          l_cont_herm_ko     TYPE i,
          l_cont_herm_999    TYPE i,
          l_cont_herm_999_ko TYPE i.

    CLEAR: l_cont_blanc    , l_cont_herm   ,
           l_cont_blanc_ko , l_cont_herm_ko   ,
           l_cont_herm_999 , l_cont_herm_999_ko .

    SELECT * INTO TABLE @DATA(lt_lotes)
      FROM ztpp0041
      WHERE werks = @i_werks AND
            ind_sin_etiq = ' '.

* Informamos lotes "normales" (ind_sin_etiq = ' ')
    LOOP AT lt_lotes ASSIGNING FIELD-SYMBOL(<fs_lote>).

* Obtener la suma valoraciones de los distintos registros de cada rollo del cual se consume.
      SELECT SUM( dmbtr ) INTO @<fs_lote>-pmv
          FROM mseg
        WHERE werks = @i_werks AND
              charg = @<fs_lote>-charg AND
              bwart = '261'.
      IF sy-subrc <> 0 OR <fs_lote>-pmv = 0.
        CLEAR: <fs_lote>-pmv , <fs_lote>-ind_lote_consum.
        ADD 1 TO l_cont_blanc_ko.

        INSERT <fs_lote> INTO TABLE o_sin_etiq_blanc.
      ELSE.
        ADD 1 TO l_cont_blanc.
        <fs_lote>-ind_lote_consum = 'X'.
      ENDIF.
      IF i_modo_test = ' '.
        MODIFY ztpp0041 FROM <fs_lote>.
      ENDIF.

    ENDLOOP.

    WRITE :/ |IND_SIN_ETIQ = ' '|.
    WRITE :/ |     OK-> { l_cont_blanc }|.
    WRITE :/ |     KO-> { l_cont_blanc_ko }|.

******************************************************************************


* Tratamiento de Hermanos (Sin etiqueta emparejados).
    SELECT * INTO TABLE @DATA(lt_lotes_herm)
      FROM ztpp0041
      WHERE werks = @i_werks AND
            ind_sin_etiq = '1' AND
            NOT ( charg LIKE '999%' OR charg LIKE '998%' ).

    LOOP AT lt_lotes_herm ASSIGNING <fs_lote>.

* Obtener la suma valoraciones de los distintos registros de cada rollo del cual se consume.
      SELECT SUM( dmbtr ) INTO @<fs_lote>-pmv
          FROM mseg AS ms
        WHERE ms~werks = @i_werks AND
              ms~bwart = '261' AND
              ms~charg = @<fs_lote>-charg.
*                  IN ( SELECT lote_mp_hermano
*                              FROM ztpp0041
*                             WHERE werks      = @i_werks AND
*                                   id_receta  = @<fs_lote>-id_receta AND
*                                   charg      = @<fs_lote>-lote_mp_hermano ).
      IF sy-subrc <> 0 OR <fs_lote>-pmv = 0.

        CLEAR <fs_lote>-pmv.
        <fs_lote>-ind_lote_consum = ' '.
        ADD 1 TO l_cont_herm_ko.

        INSERT <fs_lote> INTO TABLE o_sin_etiq_1.

      ELSE.

        <fs_lote>-ind_lote_consum = 'X'.
        ADD 1 TO l_cont_herm.

      ENDIF.

      IF i_modo_test = ' '.
        MODIFY ztpp0041 FROM <fs_lote>.
      ENDIF.

    ENDLOOP.

    WRITE :/ .
    WRITE :/ |IND_SIN_ETIQ = '1' y no son 999* / 998*|.
    WRITE :/ |     OK-> { l_cont_herm }|.
    WRITE :/ |     KO-> { l_cont_herm_ko }|.


******************************************************************************

* Tratamiento de Hermanos (Ficticios).
    CLEAR: lt_lotes_herm[].
    SELECT * INTO TABLE @lt_lotes_herm
      FROM ztpp0041
      WHERE werks = @i_werks AND
            ind_sin_etiq = '1' AND
           ( charg LIKE '999%' OR charg LIKE '998%' ).

    LOOP AT lt_lotes_herm ASSIGNING <fs_lote>.

* Obtener la suma valoraciones de los distintos registros de cada rollo del cual se consume.
      SELECT SUM( dmbtr ) INTO @<fs_lote>-pmv
          FROM mseg AS ms
        WHERE ms~werks = @i_werks AND
              ms~bwart = '261' AND
              ms~charg = @<fs_lote>-lote_mp_hermano .

      IF sy-subrc <> 0  OR <fs_lote>-pmv = 0.
        CLEAR <fs_lote>-pmv.
        <fs_lote>-ind_lote_consum = ' '.
        ADD 1 TO l_cont_herm_999_ko.
        INSERT <fs_lote> INTO TABLE o_sin_etiq_999.
      ELSE.
        <fs_lote>-ind_lote_consum = ' '.
        ADD 1 TO l_cont_herm_999.
      ENDIF.

      IF i_modo_test = ' '.
        MODIFY ztpp0041 FROM <fs_lote>.
      ENDIF.
    ENDLOOP.

    WRITE :/ .
    WRITE :/ |IND_SIN_ETIQ = '1' y  999* / 998*|.
    WRITE :/ |     OK-> { l_cont_herm_999 }|.
    WRITE :/ |     KO-> { l_cont_herm_999_ko }|.


  ENDMETHOD.
  METHOD CALCULAR_DIF_CRONO_VS_FECHAS.

    clear r_duracion.

    IF  g_fecha_fin_mp > g_fecha_crono OR  "por debajo de la estimación
  ( g_fecha_fin_mp = g_fecha_crono AND g_hora_fin_mp > g_hora_crono ).

      CALL FUNCTION 'SWI_DURATION_DETERMINE'
        EXPORTING
          start_date = g_fecha_crono
          end_date   = g_fecha_fin_mp
          start_time = g_hora_crono
          end_time   = g_hora_fin_mp
        IMPORTING
          duration   = r_duracion.

      r_duracion = r_duracion / 60 * ( -1 ).

    ELSEIF g_fecha_fin_mp < g_fecha_crono OR " por encima de la estimación.
           ( g_fecha_fin_mp = g_fecha_crono AND g_hora_fin_mp < g_hora_crono ).

      CALL FUNCTION 'SWI_DURATION_DETERMINE'
        EXPORTING
          start_date = g_fecha_fin_mp
          end_date   = g_fecha_crono
          start_time = g_hora_fin_mp
          end_time   = g_hora_crono
        IMPORTING
          duration   = r_duracion.

      r_duracion = r_duracion / 60.

    ENDIF.


  ENDMETHOD.
  METHOD calcular_factor_corrector.


*Minuts estimats (Me) = 480 (incloure columna en la taula ZTPP0003)
*Minuts límit (Ml) = 120 (incloure columna en la taula ZTPP0003)
*Minuts desviament (Md) = calculats en cada iteració.
*Factor corrector (Fc) a calcular en cada iteració. Incloure’l en la taula ZTPP0046 (actual) i a la taula ZTPP0003 (següent)
*
*Si Md <= -Me,           Fc = 2
*Si Md >  -Me i < -Ml -> Fc = 1 – (Md/Me)
*Si Md >= -Ml i <= +Ml,  Fc = 1
*Si Md >  +Ml i < +Me -> Fc = 1 – (Md/Me)
*Si Md >= +Me,           Fc = 0

* Variables utilizadas para el cálculo:
* desv_min      : desviación obtenida en la ejecución actual (positivo cerca de la fecha actual, negativo anterior a la fecha prevista consumo MP).
* min_estimados : minutos de diferencia entre hora ejecución y la fecha/hora prevista consumo MP (480min o 8h).
* min_limite    : limite que determinará si cálculamos factor corrector por haber excedido la desviación permitida (120min).

    IF gs_ztpp0046-desv_min <= ( gs_ztpp0003-min_estimados * -1 ).

      gs_ztpp0003-factor_correc = 2.

    ELSEIF ( gs_ztpp0046-desv_min > ( gs_ztpp0003-min_estimados * -1 ) ) AND
           ( gs_ztpp0046-desv_min < ( gs_ztpp0003-min_limit * -1 ) ).

      gs_ztpp0003-factor_correc = 1 - ( gs_ztpp0046-desv_min / gs_ztpp0003-min_estimados ).

    ELSEIF ( gs_ztpp0046-desv_min >= ( gs_ztpp0003-min_limit * -1 ) ) AND
           ( gs_ztpp0046-desv_min <=  gs_ztpp0003-min_limit ).

      gs_ztpp0003-factor_correc = 1.

    ELSEIF ( gs_ztpp0046-desv_min > ( gs_ztpp0003-min_limit ) ) AND
           ( gs_ztpp0046-desv_min <  gs_ztpp0003-min_estimados ).

      gs_ztpp0003-factor_correc = 1 - ( gs_ztpp0046-desv_min / gs_ztpp0003-min_estimados ).

    ELSEIF  gs_ztpp0046-desv_min >  gs_ztpp0003-min_estimados.

      gs_ztpp0003-factor_correc = 0.

    ENDIF.

  ENDMETHOD.
  METHOD calcular_factor_n_dias.

    DATA: l_data_ini_calc TYPE datum,
          l_pulper        TYPE matnr VALUE '2001764'.
    DATA: lr_matnr  TYPE RANGE OF matnr,
          lsr_matnr LIKE LINE OF lr_matnr.

    l_data_ini_calc = gs_ztpp0003-fecha - gs_ztpp0003-dias_calc_factor.

    l_pulper = |{ l_pulper ALPHA = IN }|.
    SELECT matnr , matkl INTO TABLE @DATA(lt_mat)
      FROM mara
      WHERE ( mtart = 'ZREC' OR matnr = @l_pulper ).

    LOOP AT lt_mat INTO DATA(ls_mat).
      CLEAR lsr_matnr.
      lsr_matnr-sign   = 'I'.
      lsr_matnr-option   = 'EQ'.
      lsr_matnr-low   = ls_mat-matnr.
      INSERT lsr_matnr  INTO TABLE lr_matnr.
    ENDLOOP.

* Obtener mov 311 -> Traspaso a pulper de materiales ZREC o pulper (bobinas pulper)
    SELECT * FROM mseg
      INTO TABLE @DATA(lt_mseg)
      WHERE werks EQ @g_werks         AND
            lgort EQ @g_lgort_pulper  AND
            bwart IN ( '311', '312' ) AND
            sobkz EQ @space           AND
             ( budat_mkpf >= @l_data_ini_calc AND budat_mkpf <= @gs_ztpp0003-fecha ) AND
            matnr IN @lr_matnr.

    DATA: l_kg_mp_n_dias TYPE menge_d.
    DATA: l_kg_pr_n_dias TYPE menge_d.

    CLEAR l_kg_mp_n_dias.
    LOOP AT lt_mseg INTO DATA(ls_mseg).
      CASE ls_mseg-bwart.
        WHEN '311'.
          l_kg_mp_n_dias = l_kg_mp_n_dias + ls_mseg-menge.
        WHEN '312'.
          l_kg_mp_n_dias = l_kg_mp_n_dias - ls_mseg-menge.
        WHEN OTHERS.
      ENDCASE.
    ENDLOOP.



* Producción de rollos

    SELECT s~* INTO TABLE @DATA(lt_mseg_prod)
     FROM mseg AS s
     INNER JOIN mara AS m ON s~matnr = m~matnr
     WHERE ( budat_mkpf >= @l_data_ini_calc AND budat_mkpf <= @gs_ztpp0003-fecha )
           AND s~kzbew = 'F'
           AND s~werks = @g_werks
           AND s~lgort IN @gr_lgort_rollo
           AND ( s~bwart = '101' OR s~bwart = '102' ) " Movimiento de creación
           AND m~mtart = 'ZROL'.                   " Tipo de Material: Rollo

    CLEAR l_kg_pr_n_dias.
    LOOP AT lt_mseg_prod INTO DATA(ls_mseg_prod).
      CASE ls_mseg_prod-bwart.
        WHEN '101'.
          l_kg_pr_n_dias = l_kg_pr_n_dias + ls_mseg_prod-menge.
        WHEN '102'.
          l_kg_pr_n_dias = l_kg_pr_n_dias - ls_mseg_prod-menge.
        WHEN OTHERS.
      ENDCASE.
    ENDLOOP.


**** A la prod.bruta, le restaremos los hermanos con IND_SIN_ETIQ = 1. MP consumida en diferido + Lotes ficticios pendientes de consumir.
    SELECT SUM( kg_reales )
      INTO @DATA(l_suma_lotes_1)
      FROM ztpp0041
      WHERE fecha_ins >= @l_data_ini_calc AND fecha_ins <= @gs_ztpp0003-fecha AND
            ind_sin_etiq = '1' AND
            werks  = @g_werks.

    IF sy-subrc = 0.
      l_kg_pr_n_dias = l_kg_pr_n_dias - l_suma_lotes_1.
    ENDIF.




    gs_ztpp0003-factor_prod = l_kg_mp_n_dias / l_kg_pr_n_dias.
    gs_ztpp0003-kg_mp       = l_kg_mp_n_dias.
    gs_ztpp0003-kg_rollos   = l_kg_pr_n_dias.

    WRITE :/.
    WRITE :/ |Datos de cálculo de factor de consumo a { gs_ztpp0003-fecha DATE = USER }:|.
    WRITE :/ | Tramo de fechas cálculo            : { l_data_ini_calc DATE = USER } { gs_ztpp0003-fecha DATE = USER }|.
    WRITE :/ | Kg. MP                             : { gs_ztpp0003-kg_mp }|.
    WRITE :/ | Kg. Producción (sin herm.)         : { gs_ztpp0003-kg_rollos }|.
    WRITE :/ | Kg. lote hermanos(IND_SIN_ETIQ=1)  : { l_suma_lotes_1 }|.
    WRITE :/ | Factor de consumo                  : { gs_ztpp0003-factor_prod }|.
    WRITE :/.

    UPDATE ztpp0003 SET "fecha       =  g_fecha_fin_rollos
                        "hora        =  g_hora_fin_rollos
                        factor_prod =  gs_ztpp0003-factor_prod
                        kg_mp       =  gs_ztpp0003-kg_mp
                        kg_rollos   =  gs_ztpp0003-kg_rollos
                WHERE werks = g_werks
                AND progname = zclpp_recetas_reparto_pulper=>gc_program.

    COMMIT WORK AND WAIT.


    o_fecha_ini_fac = l_data_ini_calc.
    o_fecha_fin_fac = gs_ztpp0003-fecha.
    kg_mp_fact      = gs_ztpp0003-kg_mp.
    kg_prod_fact    = gs_ztpp0003-kg_rollos.
    factor          = gs_ztpp0003-factor_prod.

  ENDMETHOD.
  METHOD calcular_fechas.

    " Fecha inicio-hora inicio para selección fabricación:
    SELECT SINGLE fecha , hora , MIN_ESTIMADOS INTO @DATA(ls_fab_ini)
      FROM ztpp0003
      WHERE werks  = @i_werks
      AND progname = @ZCLPP_RECETAS_REPARTO_PULPER=>gc_program.

* Rango de fecha/hora para selección de Rollos.
* Incrementamos 1 segundo, y si son las 12h --> +1dia
    o_h_ini_ro  = ls_fab_ini-hora + 1.

    IF o_h_ini_ro = '000000'.
      o_d_ini_ro = ls_fab_ini-fecha + 1.
    ELSE.
      o_d_ini_ro = ls_fab_ini-fecha.
    ENDIF.

    o_d_fin_ro = sy-datum.
    o_h_fin_ro = sy-uzeit.

* Rango de fecha/hora para selección de MP.

***** Fecha/Hora Fin Consumo MP = Fecha/Hora Últ.ejec - 4h
****    o_h_fin_mp = o_h_ini_ro - 14400.
****    IF o_h_fin_mp > o_h_ini_ro.
****      o_d_fin_mp = o_d_ini_ro - 1.
****    ELSE.
****      o_d_fin_mp = o_d_ini_ro.
****    ENDIF.

* (CMS - 62288 - 31/07/2020) Cálculamos la fecha/hora fin MP "ESTIMADA", a partir de la fecha/hora
* fin rollo (fecha/hora actual) y rentándole los minutos estimados (480)
*    o_h_fin_mp = o_h_ini_ro - 14400.
    o_h_fin_mp = o_h_fin_ro - ( ls_fab_ini-min_estimados * 60 ).
    IF o_h_fin_mp > o_h_fin_ro.
      o_d_fin_mp = o_d_fin_ro - 1.
    ELSE.
      o_d_fin_mp = o_d_fin_ro.
    ENDIF.

  ENDMETHOD.
   METHOD constructor.

     g_werks = i_werks.
     g_lgort_pulper = i_lgort_pulper.
     gr_lgort_rollo = i_lgort_rollo.

     g_fecha_ini_rollos  = i_d_ini_ro.
     g_hora_ini_rollos   = i_h_ini_ro.
     g_fecha_fin_rollos  = i_d_fin_ro.
     g_hora_fin_rollos   = i_h_fin_ro.

     g_fecha_fin_mp      = i_d_fin_mp.
     g_hora_fin_mp       = i_h_fin_mp.

     gs_ztpp0046-werks        = g_werks.
     gs_ztpp0046-fecha_ejec   = sy-datum.
     gs_ztpp0046-hora_ejec    = sy-uzeit.

************************* INI Version anterior en DESUSO
     CASE i_aplicar_crono.

       WHEN 'N'." Normal
         CALL METHOD obtener_fabricacion_rollos.

         CALL METHOD obtener_lotes_mp_pulper.

         CALL METHOD generar_reparto_teorico.
************************* FIN Version anterior en DESUSO

* Versión CRONO Actual
       WHEN 'C'." Crono

* Obtención de los parámetros de la tabla ZTPP0003.
         CALL METHOD obtener_parametros_crono.

         IF sy-datum > gs_ztpp0003-fecha OR gs_ztpp0003-factor_prod IS INITIAL .

           CALL METHOD calcular_factor_n_dias
             IMPORTING
               o_fecha_ini_fac = gs_ztpp0046-fecha_ini_factor
               o_fecha_fin_fac = gs_ztpp0046-fecha_fin_factor
               kg_mp_fact      = gs_ztpp0046-kg_mp_fact
               kg_prod_fact    = gs_ztpp0046-kg_prod_fact
               factor          = gs_ztpp0046-factor.
         ENDIF.

         CALL METHOD obtener_fabricacion_rollos.
         CALL METHOD obtener_lotes_mp_pulper_crono.

         WRITE :/ |Fecha/hora fin  programada para MP  : { g_fecha_fin_mp DATE = USER } / { g_hora_fin_mp TIME = USER }|.
         WRITE :/ |Fecha/hora fin nuevo método "Crono" : { g_fecha_crono  DATE = USER } / { g_hora_crono  TIME = USER }|.

         gs_ztpp0046-fecha_fin_prog   = g_fecha_fin_mp.
         gs_ztpp0046-hora_fin_prog    = g_hora_fin_mp.
         gs_ztpp0046-fecha_fin_prod   = g_fecha_crono.
         gs_ztpp0046-hora_fin_prod    = g_hora_crono.
         gs_ztpp0046-max_pulper       = gs_ztpp0003-max_pulper.

         DATA(l_dif_min) = calcular_dif_crono_vs_fechas( ).

         IF l_dif_min < 0 .
           DATA(l_dif_sin_sig) = l_dif_min * ( -1 ).
         else.
             l_dif_sin_sig = l_dif_min.
         ENDIF.

         IF l_dif_sin_sig >= gs_ztpp0003-minutos_crono .

           WRITE :/ |Desviación fecha/hora consumo pulper de { l_dif_min } minutos|.
           CALL METHOD enviar_mail_aviso_desviacion( l_dif_min ).

         ENDIF.
         gs_ztpp0046-desv_min = l_dif_min.
         gs_ztpp0003-min_desv = l_dif_min.

         CALL METHOD calcular_factor_corrector.
           WRITE :/ |Factor corrector calculado: { gs_ztpp0003-factor_correc }|.

         CALL METHOD generar_reparto_teorico.

     ENDCASE.

   ENDMETHOD.
  METHOD consumir_lote_mp.

    DATA: ls_bapi_items TYPE bapi2017_gm_item_create,
          lt_bapi_items TYPE TABLE OF bapi2017_gm_item_create,
          ls_44         TYPE ztpp0044.

    o_rc = '00'.

    IF i_old = 'X'.
      CALL METHOD zclpp_recetas_reparto_pulper=>generar_movimiento_311
        EXPORTING
          i_matnr     = i_matnr
          i_charg     = i_sin_etiq
          i_werks     = i_werks
          i_lgort_ori = i_lgort_ori
          i_lgort_des = '4002'  " tiramos a Pulper.
          i_cantidad  = i_cantidad
          i_commit    = 'X'
        IMPORTING
          o_rc        = DATA(l_rc).

      IF l_rc <> '00'.
        o_rc = l_rc.
        EXIT.
      ENDIF.

    ELSE. " New
      DATA lt_43_reparto TYPE TABLE OF ztpp0043.
*    Obtener datos de reparto del lote hermano del ficticio.
      SELECT *
        INTO TABLE @lt_43_reparto
        FROM ztpp0043
        WHERE werks = @i_werks AND
              lote_mp IN ( SELECT lote_mp_hermano
                              FROM ztpp0041
                              WHERE werks     = @i_werks  AND
                                    id_receta = @i_receta AND
                                    charg     = @i_fict
                           ).

      IF lt_43_reparto[] IS INITIAL.
        SELECT SINGLE lote_mp_hermano
          INTO @DATA(vl_lote_mp_hermano)
          FROM ztpp0041
          WHERE werks     = @i_werks  AND
                id_receta = @i_receta AND
                charg     = @i_fict.

        "JCB 06.11.24. Necesidades Implantación RFID Sarriá. Buscar movimientos de MSEG
        IF vl_lote_mp_hermano IS NOT INITIAL.
          SELECT mseg~werks, mseg~matnr, mseg~charg, mseg~lgort, mseg~menge, mseg~meins, mseg~shkzg,
                 mseg~aufnr
            INTO TABLE @DATA(tl_mseg)
            FROM mseg
            WHERE mseg~werks       = @i_werks             AND
                  mseg~matnr       = @i_matnr             AND
                  mseg~bwart       IN ('261', '262')      AND
                  mseg~charg       = @vl_lote_mp_hermano.
        ENDIF.

        DATA wl_43_reparto LIKE LINE OF lt_43_reparto.
        LOOP AT tl_mseg ASSIGNING FIELD-SYMBOL(<fs_mseg>).
          CLEAR wl_43_reparto.
          DATA(vl_signo)            = SWITCH int4( <fs_mseg>-shkzg WHEN 'H' THEN 1 ELSE -1 ).
          wl_43_reparto-werks       = <fs_mseg>-werks.
          wl_43_reparto-id_receta   = i_receta.
          wl_43_reparto-lote_mp     = <fs_mseg>-charg.
          wl_43_reparto-matnr_mp    = <fs_mseg>-matnr.
          wl_43_reparto-kg_mp       = <fs_mseg>-menge * vl_signo.
          wl_43_reparto-meins_mp    = <fs_mseg>-meins.
          wl_43_reparto-almacen_pm  = <fs_mseg>-lgort.
          wl_43_reparto-of_rollo    = <fs_mseg>-aufnr.

*          wl_43_reparto-lote_rollo
*          wl_43_reparto-matnr_rollo
*          wl_43_reparto-kg_rollo
*          wl_43_reparto-meins_rollo


          COLLECT wl_43_reparto INTO lt_43_reparto.
        ENDLOOP.
      ENDIF.


      IF lt_43_reparto[] IS INITIAL.
        o_lote_hermano = vl_lote_mp_hermano.
        o_rc = '02'. " No se han encontrado datos del lote de referencia
        EXIT.
      ENDIF.

      LOOP AT lt_43_reparto ASSIGNING FIELD-SYMBOL(<fs_43>).
        <fs_43>-lote_mp    = i_sin_etiq.
        <fs_43>-almacen_pm = i_lgort_ori.
        CLEAR: <fs_43>-fecha_ins ,
               <fs_43>-hora_ins ,
               <fs_43>-contr_ins ,
               <fs_43>-fecha_upd ,
               <fs_43>-hora_upd ,
               <fs_43>-contr_upd .

        CLEAR: ls_bapi_items.", lt_bapi_items.
        ls_bapi_items-material     = <fs_43>-matnr_mp.
        ls_bapi_items-plant        = i_werks.
        ls_bapi_items-stge_loc     = <fs_43>-almacen_pm.
        ls_bapi_items-batch        = <fs_43>-lote_mp.
        ls_bapi_items-move_type    = '261'.
        ls_bapi_items-stck_type    = ' '. " Libre utilización
        ls_bapi_items-entry_qnt    = <fs_43>-kg_mp.
        ls_bapi_items-entry_uom    = 'KG'.
        ls_bapi_items-orderid      = <fs_43>-of_rollo.

        APPEND ls_bapi_items TO lt_bapi_items.
      ENDLOOP.

      CALL METHOD zclpp_recetas_reparto_pulper=>generar_movimiento_261
        EXPORTING
          it_bapi_items = lt_bapi_items
          i_tp_consumo  = 'D' "Consumo pulper / Diferido
*         i_no_commit   = 'X' "Consumo pulper / Diferido
        IMPORTING
          o_mblnr       = o_mblnr
          o_mjahr       = o_mjahr
          o_rc          = l_rc
          ot_bapiret2   = DATA(lt_bapiret2).

      CLEAR ls_44.
      IF l_rc = '00'.

* Grabar ZTPP0043 a BBDD.
        LOOP AT lt_43_reparto ASSIGNING <fs_43>.
          <fs_43>-ind_no_tratado    = ' '.
          <fs_43>-mblnr_261         = o_mblnr.
          <fs_43>-mjahr_261         = o_mjahr.
          CALL METHOD zclpp_recetas_reparto_pulper=>grabar_reparto_ztpp0043_44
            CHANGING
              cs_ztpp0043 = <fs_43>.
        ENDLOOP.
      ELSE.
        o_message = lt_bapiret2[ type = 'E' ]-message.
        o_rc      = '01'.
        EXIT.
      ENDIF.

    ENDIF.

* Crear registro en ZTPP0041.
    CALL METHOD zclpp_recetas_reparto_pulper=>sustituir_fict_x_sin_etiqueta
      EXPORTING
        i_werks    = i_werks
        i_receta   = i_receta
        i_fict     = i_fict
        i_sin_etiq = i_sin_etiq
        i_operario = i_operario
      IMPORTING
        o_rc       = l_rc.

    IF l_rc <> '00'.
      o_rc = l_rc.
      o_rc(1) = '1'.
      EXIT.
    ENDIF.

  ENDMETHOD.
  METHOD enviar_mail_aviso_desviacion.
    DATA: send_request TYPE REF TO cl_bcs,
          document     TYPE REF TO cl_document_bcs,
          recipient    TYPE REF TO if_recipient_bcs,
          li_sender2   TYPE REF TO cl_sapuser_bcs,
          l_count_mail TYPE so_obj_len,
          t_attach     TYPE solix_tab,
          wa_attach    TYPE solix.

    DATA l_text TYPE so_text255.
    DATA: lt_bodytext    TYPE bcsy_text,
          l_bodytext_row TYPE soli.
    DATA: li_sender TYPE REF TO cl_cam_address_bcs,
          l_new.
    DATA: c_newline(1) TYPE c VALUE cl_abap_char_utilities=>newline.

    IF gs_ztpp0003-mail_sistemas IS INITIAL.
      RETURN.
    ENDIF.

    TRY.
        CALL METHOD cl_bcs=>create_persistent
          RECEIVING
            result = send_request.
    ENDTRY.

    l_text = |<body><b>IMPORTANTE</b>: Centro { g_werks }: desviación fecha/hora consumo pulper de consumo de { i_num_min } minutos. <br> <br> <br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    DATA(l_num_min) =   i_num_min * ( -1 ).


    l_text = |Fecha/hora fin teórica MP : { g_fecha_fin_mp DATE = USER } / { g_hora_fin_mp TIME = USER }<br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.
    l_text = |Fecha/hora fin calculada consumo MP : { g_fecha_crono  DATE = USER } / { g_hora_crono  TIME = USER }<br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    l_text = |</body>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    DATA(l_subject) = |C{ g_werks }: { i_num_min } minutos de desviación en consumo pulper|. "  sy-datum DATE = USER } { sy-uzeit TIME = USER  } |.

    TRY.
        CALL METHOD cl_document_bcs=>create_document
          EXPORTING
            i_type    = 'HTM'
            i_subject = CONV so_obj_des( l_subject )
            i_text    = lt_bodytext
          RECEIVING
            result    = document.
      CATCH cx_document_bcs .
    ENDTRY.

    CALL METHOD send_request->set_document( document ).

    li_sender ?= cl_cam_address_bcs=>create_internet_address( i_address_string = CONV adr6-smtp_addr( GC_REMITENTE_MAIL ) ).

    CALL METHOD send_request->set_sender
      EXPORTING
        i_sender = li_sender.

    recipient = cl_cam_address_bcs=>create_internet_address( gs_ztpp0003-mail_sistemas ).
    CALL METHOD send_request->add_recipient( i_recipient = recipient ).

    TRY.
        CALL METHOD send_request->send( ).

      CATCH cx_root .
        WRITE :/ |Error al enviar el mail.|.
    ENDTRY.

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD ENVIAR_MAIL_CRONO_OVERFLOW.
    DATA: send_request TYPE REF TO cl_bcs,
          document     TYPE REF TO cl_document_bcs,
          recipient    TYPE REF TO if_recipient_bcs,
          li_sender2   TYPE REF TO cl_sapuser_bcs,
          l_count_mail TYPE so_obj_len,
          t_attach     TYPE solix_tab,
          wa_attach    TYPE solix.

    DATA l_text TYPE so_text255.
    DATA: lt_bodytext    TYPE bcsy_text,
          l_bodytext_row TYPE soli.
    DATA: li_sender TYPE REF TO cl_cam_address_bcs,
          l_new.
    DATA: c_newline(1) TYPE c VALUE cl_abap_char_utilities=>newline.

    IF gs_ztpp0003-mail_sistemas IS INITIAL.
      RETURN.
    ENDIF.

    TRY.
        CALL METHOD cl_bcs=>create_persistent
          RECEIVING
            result = send_request.
    ENDTRY.

    l_text = |<body><b>IMPORTANTE</b>: Centro { g_werks }: Consumo superior a la producción. ¡Pulper a 0 Kg!. <br> <br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    l_text = |Kg. MP consumidos:  { i_kg_acumulados } Kg. <br> <br> <br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    l_text = |</body>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    DATA(l_subject) = |C{ g_werks }: Consumo superior a la producción. ¡0 Kg en pulper!|. "  sy-datum DATE = USER } { sy-uzeit TIME = USER  } |.

    TRY.
        CALL METHOD cl_document_bcs=>create_document
          EXPORTING
            i_type    = 'HTM'
            i_subject = CONV so_obj_des( l_subject )
            i_text    = lt_bodytext
          RECEIVING
            result    = document.
      CATCH cx_document_bcs .
    ENDTRY.

    CALL METHOD send_request->set_document( document ).

    li_sender ?= cl_cam_address_bcs=>create_internet_address( i_address_string = CONV adr6-smtp_addr( GC_REMITENTE_MAIL ) ).

    CALL METHOD send_request->set_sender
      EXPORTING
        i_sender = li_sender.

    recipient = cl_cam_address_bcs=>create_internet_address( gs_ztpp0003-mail_sistemas ).
    CALL METHOD send_request->add_recipient( i_recipient = recipient ).

    TRY.
        CALL METHOD send_request->send( ).

      CATCH cx_root .
        WRITE :/ |Error al enviar el mail.|.
    ENDTRY.

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD enviar_mail_errores_proceso.
    DATA: send_request TYPE REF TO cl_bcs,
          document     TYPE REF TO cl_document_bcs,
          recipient    TYPE REF TO if_recipient_bcs,
          li_sender2   TYPE REF TO cl_sapuser_bcs,
          l_count_mail TYPE so_obj_len,
          t_attach     TYPE solix_tab,
          wa_attach    TYPE solix.

    DATA l_text TYPE so_text255.
    DATA: lt_bodytext    TYPE bcsy_text,
          l_bodytext_row TYPE soli.
    DATA: li_sender TYPE REF TO cl_cam_address_bcs,
          l_new.
    DATA: c_newline(1) TYPE c VALUE cl_abap_char_utilities=>newline.
*    SELECT SINGLE *
*      FROM ztpp0003 INTO @DATA(ls_03)
*      WHERE werks     = @g_werks AND
*            progname  = @zclpp_recetas_reparto_pulper=>gc_program.
*    CHECK sy-subrc EQ 0.

    IF gs_ztpp0003-mail_sistemas IS INITIAL AND gs_ztpp0003-mail_negocio IS INITIAL.
      RETURN.
    ENDIF.

    TRY.
        CALL METHOD cl_bcs=>create_persistent
          RECEIVING
            result = send_request.
    ENDTRY.

    l_text = |<body><b>IMPORTANTE</b>: Se ha producido un error en el reparto de consumos de pulper en el centro &. <br>|.
    REPLACE '&' IN l_text WITH g_werks.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    l_text = |Por favor, revisar los lotes existentes en el pulper para determinar el error. <br><br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.
    l_text = |Errores devueltos por la BAPI de consumo:<br>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    LOOP AT gt_bapiret2 INTO DATA(ls_bapiret2).
      l_text = |{ ls_bapiret2-message } <br>|.
      APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    ENDLOOP.

    l_text = |</body>|.
    APPEND VALUE soli( line = l_text ) TO lt_bodytext.

    DATA(l_subject) = |Error reparto consumo pulper. Centro: { g_werks }|. "  sy-datum DATE = USER } { sy-uzeit TIME = USER  } |.

    TRY.
        CALL METHOD cl_document_bcs=>create_document
          EXPORTING
            i_type    = 'HTM'
            i_subject = CONV so_obj_des( l_subject )
            i_text    = lt_bodytext
          RECEIVING
            result    = document.
      CATCH cx_document_bcs .
    ENDTRY.


    CALL METHOD send_request->set_document( document ).


    li_sender ?= cl_cam_address_bcs=>create_internet_address( i_address_string = CONV adr6-smtp_addr( gc_remitente_mail ) ).

    CALL METHOD send_request->set_sender
      EXPORTING
        i_sender = li_sender.

    IF gs_ztpp0003-mail_negocio IS NOT INITIAL.

      recipient = cl_cam_address_bcs=>create_internet_address( gs_ztpp0003-mail_negocio ).

      CALL METHOD send_request->add_recipient( i_recipient = recipient ).

    ENDIF.

    IF gs_ztpp0003-mail_sistemas IS NOT INITIAL AND ( gs_ztpp0003-mail_sistemas NE gs_ztpp0003-mail_negocio ).

      recipient = cl_cam_address_bcs=>create_internet_address( gs_ztpp0003-mail_sistemas ).

      CALL METHOD send_request->add_recipient( i_recipient = recipient ).

    ENDIF.

    TRY.
        CALL METHOD send_request->send( ).

      CATCH cx_root .
        WRITE :/ |Error al enviar el mail.|.
    ENDTRY.


    COMMIT WORK AND WAIT.


  ENDMETHOD.
  METHOD generar_movimiento_261.

    DATA: lt_goodsmvt_item TYPE tab_bapi_goodsmvt_item.

    DATA: ls_goodsmvt_header TYPE         bapi2017_gm_head_01,
          ls_goodsmvt_code   TYPE         bapi2017_gm_code,
          ls_goodsmvt_item   TYPE         bapi2017_gm_item_create,
          ls_return          TYPE         bapiret2,
          ls_return_roll     TYPE         bapiret2,
          lt_return          TYPE  STANDARD TABLE OF bapiret2.

    CLEAR: lt_goodsmvt_item[] , ot_bapiret2.
    lt_goodsmvt_item[] = it_bapi_items[].

* 14-05-2020 CMS Borramos los consumos a 0 o negativos que pueda haber
    delete lt_goodsmvt_item where ENTRY_QNT <= 0.

    CLEAR ls_goodsmvt_code.
    ls_goodsmvt_code-gm_code       = '06'.

    CLEAR ls_goodsmvt_header.
    ls_goodsmvt_header-pstng_date  = sy-datum.
    ls_goodsmvt_header-doc_date    = sy-datum.

    CASE i_tp_consumo.
      WHEN 'P'.
        ls_goodsmvt_header-header_txt  = text-003. " Consumo Pulper.
      WHEN 'D'.
        ls_goodsmvt_header-header_txt  = text-004. " Consumo diferido.
      WHEN OTHERS.
    ENDCASE.

    CLEAR: o_mblnr, o_mjahr.
    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = ls_goodsmvt_header
        goodsmvt_code    = ls_goodsmvt_code
      IMPORTING
        materialdocument = o_mblnr
        matdocumentyear  = o_mjahr
      TABLES
        goodsmvt_item    = lt_goodsmvt_item
        return           = ot_bapiret2.

    IF line_exists( ot_bapiret2[ type = 'E' ] ).
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
        IMPORTING
          return = ls_return_roll.

      o_rc = '01'.

    ELSE.
      o_rc = '00'.

      CHECK i_no_commit <> 'X'.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
    ENDIF.


  ENDMETHOD.
  METHOD generar_movimiento_311.

    DATA: ls_header TYPE bapi2017_gm_head_01,
          ##NEEDED
          l_mblnr   TYPE bapi2017_gm_head_ret-mat_doc,
          lt_item   TYPE bapi2017_gm_item_create_t,
          ls_item   TYPE bapi2017_gm_item_create,
          lt_return TYPE TABLE OF bapiret2.


    CLEAR: ls_header , ls_item , lt_item[].

    ls_header-pstng_date = sy-datum.
    ls_header-doc_date   = sy-datum.

    SELECT SINGLE meins FROM mara INTO @DATA(l_meins)
                                  WHERE matnr EQ @i_matnr AND
                                        lvorm EQ @space.

    ls_item-material    = i_matnr.
    ls_item-batch       = i_charg.
    ls_item-plant       = i_werks.
    ls_item-stge_loc    = i_lgort_ori.

    IF i_movimiento_311_312 <> '702'.

      ls_item-move_stloc  = i_lgort_des.

    ENDIF.

    ls_item-move_type   = i_movimiento_311_312.
    ls_item-entry_qnt   = i_cantidad.
    ls_item-entry_uom   = l_meins.
    APPEND ls_item TO lt_item.

    CALL FUNCTION 'BUFFER_REFRESH_ALL'.

*  SET UPDATE TASK LOCAL.

    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = ls_header
        goodsmvt_code    = CONV bapi2017_gm_code( '04' )
      IMPORTING
        materialdocument = l_mblnr
      TABLES
        goodsmvt_item    = lt_item
        return           = lt_return.


    IF line_exists( lt_return[ type = 'E' ] ).
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      o_rc = '01'.
      MESSAGE lt_return[ 1 ]-message TYPE 'S' DISPLAY LIKE 'E'. .
    ELSE.
      o_rc = '00'.
      IF i_commit = 'X'.
        COMMIT WORK AND WAIT.
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD generar_reparto_teorico.
    DATA: l_peso_tot_rollos TYPE menge_d,
          lt_ztpp0044       TYPE zttpp0044,
          ls_ztpp0041       TYPE  ztpp0041
          .

    CLEAR: l_peso_tot_rollos, gt_ztpp0043.

* Calculamos el total de kg POSITIVOS para calcular la proporcionalidad de reparto entre rollos.
    LOOP AT gt_rollos_fabricados INTO DATA(ls_rollos) WHERE menge > 0.
      l_peso_tot_rollos = l_peso_tot_rollos + ls_rollos-menge.
      DATA(l_last_rollo) = ls_rollos-charg.
    ENDLOOP.

    IF l_peso_tot_rollos IS INITIAL.
      WRITE |No hay kg de rollo para repartir sobre ellos.|.
    ENDIF.
* Guardamos en tabla interna los lotes correspondientes a MP asociada a Receta.
    SELECT  *
      INTO TABLE @DATA(lt_ztpp0041)
      FROM ztpp0041
      FOR ALL ENTRIES IN @gt_mat_prima
      WHERE werks = @g_werks AND
            charg = @gt_mat_prima-charg.


*    LOOP AT gt_mat_prima INTO DATA(ls_mat_prima).
    LOOP AT gt_mat_prima ASSIGNING FIELD-SYMBOL(<mat_prima>).

* Obtenemos datos de la receta asociada al lote.
      TRY.
          CLEAR: ls_ztpp0041.
          ls_ztpp0041 = lt_ztpp0041[ werks = g_werks
                                     charg = <mat_prima>-charg ].
        CATCH cx_root .
*          Bobinas y rollos pulper no se encuentran en receta
*          WRITE |Lote no encontrado en ZTPP0041: { <mat_prima>-charg }|.
*          CONTINUE.
      ENDTRY.

      LOOP AT gt_rollos_fabricados INTO ls_rollos.
        check ls_rollos-menge > 0.
        APPEND INITIAL LINE TO gt_ztpp0043 ASSIGNING FIELD-SYMBOL(<fs_nuevo_reparto>).

        <fs_nuevo_reparto>-werks          = g_werks.
        <fs_nuevo_reparto>-id_receta      = ls_ztpp0041-id_receta.
        <fs_nuevo_reparto>-lote_mp        = <mat_prima>-charg.
        <fs_nuevo_reparto>-lote_rollo     = ls_rollos-charg.
        <fs_nuevo_reparto>-matnr_mp       = <mat_prima>-matnr.
        <fs_nuevo_reparto>-almacen_pm     = g_lgort_pulper.

* Vamos restando los kg asignados a cada Rollo, y en la última, nos quedamos con el resto.
        IF ls_rollos-charg = l_last_rollo.
          <fs_nuevo_reparto>-kg_mp          = <mat_prima>-menge_cons.
        ELSE.
          <fs_nuevo_reparto>-kg_mp          = ( <mat_prima>-menge * ls_rollos-menge ) / l_peso_tot_rollos.
          <mat_prima>-menge_cons = <mat_prima>-menge_cons - <fs_nuevo_reparto>-kg_mp.
        ENDIF.

        <fs_nuevo_reparto>-meins_mp       = <mat_prima>-meins.
        <fs_nuevo_reparto>-of_rollo       = ls_rollos-aufnr.
        <fs_nuevo_reparto>-matnr_rollo    = ls_rollos-matnr.
        <fs_nuevo_reparto>-kg_rollo       = ls_rollos-menge.
        <fs_nuevo_reparto>-meins_rollo    = ls_rollos-meins.
        <fs_nuevo_reparto>-fecha_ins      = sy-datum.
        <fs_nuevo_reparto>-hora_ins       = sy-uzeit.
      ENDLOOP.

    ENDLOOP.

* Ordenación para agrupar mov.261 contra la misma OF
    SORT gt_ztpp0043 ASCENDING BY of_rollo   DESCENDING
                                  lote_rollo DESCENDING
                                  lote_mp    DESCENDING.

  ENDMETHOD.
  METHOD grabar_reparto_ztpp0043_44.

    IF cs_ztpp0043-id_receta IS NOT INITIAL.

      SELECT SINGLE id_receta INTO @DATA(l_rec)
        FROM ztpp0043
        WHERE werks      = @cs_ztpp0043-werks AND
              lote_mp    = @cs_ztpp0043-lote_mp AND
              lote_rollo = @cs_ztpp0043-lote_rollo.

      IF sy-subrc = 0.
        cs_ztpp0043-mandt          = sy-mandt.
        cs_ztpp0043-contr_upd      = sy-uname.
        cs_ztpp0043-fecha_upd      = sy-datum.
        cs_ztpp0043-hora_upd       = sy-uzeit.
        UPDATE ztpp0043 FROM  cs_ztpp0043.
      ELSE.
        cs_ztpp0043-mandt          = sy-mandt.
        cs_ztpp0043-contr_ins      = sy-uname.
        cs_ztpp0043-fecha_ins      = sy-datum.
        cs_ztpp0043-hora_ins       = sy-uzeit.
        INSERT INTO ztpp0043 VALUES cs_ztpp0043.

      ENDIF.

    ENDIF.

* Si la ejecucion ha sido sin errores, miramos si hay registro en la 44, y lo dejamos como tratado OK
    IF cs_ztpp0043-ind_no_tratado = ' '.
      SELECT SINGLE  num_intentos
                INTO @DATA(l_intentos)
                FROM ztpp0044
                WHERE werks           = @cs_ztpp0043-werks AND
                      lote_mp         = @cs_ztpp0043-lote_mp AND
                      lote_rollo      = @cs_ztpp0043-lote_rollo AND
                      ind_err_activo  = 'X'.
      IF sy-subrc = 0.
        l_intentos   = l_intentos + 1.
        UPDATE ztpp0044 SET num_intentos    = @l_intentos ,
                            ind_err_activo  = ' ' ,
                            contr_upd       = @sy-uname ,
                            fecha_consumo   = @sy-datum ,
                            fecha_upd       = @sy-datum ,
                            hora_upd        = @sy-uzeit ,
                            hora_consumo    = @sy-uzeit
                      WHERE werks           = @cs_ztpp0043-werks AND
                            lote_mp         = @cs_ztpp0043-lote_mp AND
                            lote_rollo      = @cs_ztpp0043-lote_rollo.
      ENDIF.

* Si la ejecución no ha ido bien, creamos o modificamos el registro de error en la ZTPP0044.
    ELSE.
      IF cs_ztpp0044 IS SUPPLIED AND cs_ztpp0044 IS NOT INITIAL.
        SELECT SINGLE  num_intentos
          INTO @l_intentos
          FROM ztpp0044
          WHERE werks      = @cs_ztpp0044-werks AND
                lote_mp    = @cs_ztpp0044-lote_mp AND
                lote_rollo = @cs_ztpp0044-lote_rollo.

        IF sy-subrc = 0.
          cs_ztpp0044-mandt          = sy-mandt.
          cs_ztpp0044-contr_upd      = sy-uname.
          cs_ztpp0044-fecha_upd      = sy-datum.
          cs_ztpp0044-hora_upd       = sy-uzeit.
          cs_ztpp0044-num_intentos   = l_intentos + 1.
          UPDATE ztpp0044 FROM  cs_ztpp0044.
        ELSEIF cs_ztpp0044-ind_err_activo = 'X'.
          cs_ztpp0044-mandt          = sy-mandt.
          cs_ztpp0044-contr_ins      = sy-uname.
          cs_ztpp0044-fecha_ins      = sy-datum.
          cs_ztpp0044-hora_ins       = sy-uzeit.
          cs_ztpp0044-num_intentos   = 1.
          INSERT INTO ztpp0044 VALUES cs_ztpp0044.
        ENDIF.

      ENDIF.
    ENDIF.


    COMMIT WORK AND WAIT.
  ENDMETHOD.
  METHOD marcar_ficticios_sin_pareja.

    UPDATE ztpp0041 SET ind_sin_etiq  = '9' ,
                        fecha_upd     = @sy-datum ,
                        hora_upd      = @sy-uzeit ,
                        contr_upd     = @sy-uname ,
                        pmv           = 0 ,
                        ind_lote_consum = ' '
      WHERE werks         = @i_werks AND
            lgort         = @i_ubicacion AND
            ( charg         LIKE '999%' or
              charg         LIKE '998%'  )
            AND
            ind_sin_etiq  = '1'.

    COMMIT WORK.

  ENDMETHOD.
  METHOD obtener_datos_reserva.

    TRY.
        DATA(l_rsnum) = gt_rollos_fabricados[ charg = i_lote_rollo
                                              aufnr = i_of_rollo   ]-rsnum.
        DATA(ls_mat_x_reserva) = gt_lista_mat_x_reserva[ rsnum = l_rsnum
                                                         matnr = i_matnr ].

        IF ls_mat_x_reserva-rsnum IS NOT INITIAL.
          o_sw_res      = 'X'.
          o_reserva     = ls_mat_x_reserva-rsnum.
          o_reserva_pos = ls_mat_x_reserva-rspos.
        ENDIF.
      CATCH cx_root .
        CLEAR:  o_sw_res,
                o_reserva,
                o_reserva_pos.

    ENDTRY.

  ENDMETHOD.
  METHOD obtener_datos_traz_doc_mat.

    TRY.
        rs_datos_doc_mat = gt_datos_traz_doc_mat[ werks = i_werks
                                                   mblnr = i_mblnr
                                                   mjahr = i_mjahr
                                                  ].
      CATCH cx_root .

* Obtener datos de proveedor y de compra a partir del mov 101 o 309/531 para pulper.
        SELECT SINGLE lifnr , dmbtr , waers , budat_mkpf , ebeln , ebelp
           INTO @DATA(ls_mseg)
           FROM mseg
           WHERE mblnr = @i_mblnr AND
                 mjahr = @i_mjahr.
        IF sy-subrc = 0.
          APPEND INITIAL LINE TO gt_datos_traz_doc_mat ASSIGNING FIELD-SYMBOL(<fs_dat_doc>).
          <fs_dat_doc>-werks     = i_werks.
          <fs_dat_doc>-mblnr     = i_mblnr.
          <fs_dat_doc>-mjahr     = i_mjahr.
          <fs_dat_doc>-lifnr     = ls_mseg-lifnr.
          SELECT SINGLE name1
            INTO <fs_dat_doc>-name1_gp
            FROM lfa1
            WHERE lifnr = <fs_dat_doc>-lifnr.
            rs_datos_doc_mat = <fs_dat_doc>.
        ENDIF.

    ENDTRY.

  ENDMETHOD.
  METHOD obtener_datos_traz_receta.

    TRY.
        rs_datos_rec = gt_datos_traz_rec[ werks     = i_werks
                                                id_receta = i_id_receta  ].

      CATCH cx_root .
        CALL METHOD zclpp_recetas_mp=>obtener_datos_form_receta_mp
          EXPORTING
            i_werks                 = i_werks
            i_id_receta             = i_id_receta
          IMPORTING
            os_datos_form_receta_mp = DATA(ls_datos_rec_mp)
            o_rc                    = DATA(l_rc).

        APPEND INITIAL LINE TO gt_datos_traz_rec ASSIGNING FIELD-SYMBOL(<fs_dat_rec>).
        <fs_dat_rec>-werks       = i_werks.
        <fs_dat_rec>-id_receta   = i_id_receta.
        <fs_dat_rec>-descrip_rec = ls_datos_rec_mp-descr_rec.
        <fs_dat_rec>-zcalidad    = ls_datos_rec_mp-zcalidad.
        rs_datos_rec = <fs_dat_rec>.

    ENDTRY.

  ENDMETHOD.
  METHOD OBTENER_DATOS_TRAZ_ROLLO.

    TRY.
        rs_datos_rollo = gt_datos_traz_rollo[ werks = i_werks
                                              charg = i_charg
                                                  ].
      CATCH cx_root .

      select single budat_mkpf as budat , max( cputm_mkpf ) as butim
        into @data(ls_datos_fab)
        from mseg
        where werks = @i_werks and
              lgort = '1020' and
              bwart = '101'  and  " OR bwart = '102' ) " Movimiento de creación
              charg = @i_charg and
              budat_mkpf in ( select max( budat_mkpf )
                              from mseg
                              where werks = @i_werks and
                                    lgort = '1020' and
                                    bwart = '101'  and
                                    charg = @i_charg )
        GROUP BY budat_mkpf
        .

        IF sy-subrc = 0.
          APPEND INITIAL LINE TO gt_datos_traz_rollo ASSIGNING FIELD-SYMBOL(<fs_dat_rollo>).
          <fs_dat_rollo>-werks     = i_werks.
          <fs_dat_rollo>-charg     = i_charg.
          <fs_dat_rollo>-fecha_fab = ls_datos_fab-budat.
          <fs_dat_rollo>-hora_fab  = ls_datos_fab-butim.
          rs_datos_rollo = <fs_dat_rollo>.
        ENDIF.

    ENDTRY.

  ENDMETHOD.
  METHOD obtener_datos_trazabilidad.
    DATA: lt_43 TYPE STANDARD TABLE OF ztpp0043.

    SELECT *
      INTO TABLE @lt_43
      FROM ztpp0043
      WHERE werks = @i_werks AND
            lote_rollo IN @ir_lotes_rollo AND
            id_receta  IN @ir_recetas.

    CHECK sy-subrc = 0.

    SELECT *
      INTO TABLE @DATA(lt_41)
      FROM ztpp0041
      FOR ALL ENTRIES IN @lt_43
      WHERE werks      = @i_werks AND
            id_receta IN @ir_recetas AND
            charg      = @lt_43-lote_mp.

    LOOP AT lt_43 INTO DATA(ls_43).
      APPEND INITIAL LINE TO rt_datos_trazabilidad ASSIGNING FIELD-SYMBOL(<fs_traz>).

      <fs_traz>-werks                 = ls_43-werks.
      <fs_traz>-matnr_fab             = ls_43-matnr_rollo.
      <fs_traz>-of_rollo              = ls_43-of_rollo.
      <fs_traz>-lote_fab              = ls_43-lote_rollo.
      <fs_traz>-kg_lote_fab           = ls_43-kg_rollo.
      <fs_traz>-uni_lote_fab          = ls_43-meins_rollo.
      <fs_traz>-lote_mp               = ls_43-lote_mp.
      <fs_traz>-kg_consu_mp           = ls_43-kg_mp.
      <fs_traz>-uni_consu_mp          = ls_43-meins_mp.
      <fs_traz>-id_receta             = ls_43-id_receta.
      <fs_traz>-matnr_mp              = ls_43-matnr_mp.
      <fs_traz>-fecha_con_pul_261     = ls_43-fecha_ins.
      <fs_traz>-hora_con_pul_261      = ls_43-hora_ins.
      <fs_traz>-maktx_fab             = obtener_descr_material( <fs_traz>-matnr_fab ).
      <fs_traz>-maktx_mp              = obtener_descr_material( <fs_traz>-matnr_mp ).

* Datos de receta
      DATA(ls_datos_rollo) = obtener_datos_traz_rollo( i_werks = i_werks
                                                      i_charg = <fs_traz>-lote_fab ).
      <fs_traz>-fecha_fab_rollo       = ls_datos_rollo-fecha_fab.
      <fs_traz>-hora_fab_rollo        = ls_datos_rollo-hora_fab.


      TRY.
          DATA(ls_41) = lt_41[ werks = i_werks charg = ls_43-lote_mp ].
          <fs_traz>-fecha_tras_pul_311    = ls_41-fecha_ins.
          <fs_traz>-hora_tras_pul_311     = ls_41-hora_ins.

        CATCH cx_root .
      ENDTRY.

* Datos de receta
      DATA(ls_datos_rec) = obtener_datos_traz_receta( i_werks = i_werks
                                                      i_id_receta = <fs_traz>-id_receta
                                                     ).
      <fs_traz>-descrip_rec           = ls_datos_rec-descrip_rec.
      <fs_traz>-zcalidad              = ls_datos_rec-zcalidad.

* Datos de receta
      DATA(ls_datos_doc) = obtener_datos_traz_doc_mat( i_werks = i_werks
                                                       i_mblnr = ls_41-mblnr
                                                       i_mjahr = ls_41-mjahr   ).
      <fs_traz>-lifnr                 = ls_datos_doc-lifnr.
      <fs_traz>-name1_gp              = ls_datos_doc-name1_gp.

    ENDLOOP.

  ENDMETHOD.
  METHOD obtener_descr_material.


    TRY.
        r_maktx =    gt_descr_material[ matnr = i_matnr ]-maktx.

      CATCH cx_root .
        SELECT SINGLE maktx INTO     r_maktx

          FROM makt
          WHERE matnr = i_matnr AND
                spras = sy-langu.
        IF sy-subrc = 0.
          APPEND INITIAL LINE TO gt_descr_material ASSIGNING FIELD-SYMBOL(<fs_makt>).
          <fs_makt>-matnr = i_matnr.
          <fs_makt>-maktx = r_maktx.
        ELSE.
          CLEAR r_maktx.
        ENDIF.

    ENDTRY.


  ENDMETHOD.
  METHOD obtener_fabricacion_rollos.

    " Órdenes y referencias consumos:
    TYPES: BEGIN OF ty_ord_cons,
             aufnr TYPE aufnr,
             charg TYPE charg_d,
             rsnum TYPE rsnum,
             budat TYPE budat,
           END OF ty_ord_cons.
    DATA:  gt_ord_cons TYPE STANDARD TABLE OF ty_ord_cons.

    TYPES: BEGIN OF ty_cant_neg,
             matnr TYPE matnr,
             charg TYPE charg_d,
             aufnr TYPE aufnr,
             menge TYPE menge_d,
             meins TYPE meins,
           END OF ty_cant_neg.
    DATA:  gt_cant_neg TYPE STANDARD TABLE OF ty_cant_neg.

    IF g_fecha_ini_rollos = g_fecha_fin_rollos.

      SELECT s~*  " , j~stat
          INTO TABLE @DATA(lt_mseg)
        FROM mseg AS s
        INNER JOIN mara AS m ON s~matnr = m~matnr
        WHERE  ( budat_mkpf = @g_fecha_ini_rollos AND
                 cputm_mkpf >= @g_hora_ini_rollos AND
                 cputm_mkpf <= @g_hora_fin_rollos )
              AND kzbew = 'F'
              AND s~werks = @g_werks
              AND lgort IN @gr_lgort_rollo
              AND ( bwart = '101' OR bwart = '102' )
              AND m~mtart = 'ZROL'
              .

    ELSE.

      SELECT s~* " , j~stat
        INTO TABLE @lt_mseg
       FROM mseg AS s
       INNER JOIN mara AS m ON s~matnr = m~matnr
       WHERE  ( ( budat_mkpf = @g_fecha_ini_rollos AND cputm_mkpf >= @g_hora_ini_rollos ) OR
                ( budat_mkpf = @g_fecha_fin_rollos AND cputm_mkpf <= @g_hora_fin_rollos ) OR
                ( budat_mkpf < @g_fecha_fin_rollos AND budat_mkpf > @g_fecha_ini_rollos ) )
             AND s~kzbew = 'F'
             AND s~werks = @g_werks
             AND s~lgort IN @gr_lgort_rollo
             AND ( s~bwart = '101' OR s~bwart = '102' ) " Movimiento de creación
             AND m~mtart = 'ZROL'.                   " Tipo de Material: Rollo      .

    ENDIF.

    LOOP AT lt_mseg INTO DATA(ls_mseg).

      ASSIGN gt_rollos_fabricados[ matnr = ls_mseg-matnr
                                charg = ls_mseg-charg
                                aufnr = ls_mseg-aufnr
                           ] TO FIELD-SYMBOL(<fs_rollos_fab>).
      IF sy-subrc = 0.
        CASE ls_mseg-bwart.
          WHEN '101'.
            <fs_rollos_fab>-menge = <fs_rollos_fab>-menge + ls_mseg-menge.
          WHEN '102'.
            <fs_rollos_fab>-menge = <fs_rollos_fab>-menge - ls_mseg-menge.
          WHEN OTHERS.
        ENDCASE.
      ELSE.
        APPEND INITIAL LINE TO gt_rollos_fabricados ASSIGNING <fs_rollos_fab>.
        <fs_rollos_fab>-charg    = ls_mseg-charg.
        <fs_rollos_fab>-matnr    = ls_mseg-matnr.
        <fs_rollos_fab>-aufnr    = ls_mseg-aufnr.
        <fs_rollos_fab>-meins    = ls_mseg-meins.
        <fs_rollos_fab>-budat    = ls_mseg-budat_mkpf.

        CASE ls_mseg-bwart.
          WHEN '101'.
            <fs_rollos_fab>-menge    = ls_mseg-menge.
          WHEN '102'.
            <fs_rollos_fab>-menge    = ls_mseg-menge * ( -1 ).
          WHEN OTHERS.
        ENDCASE.

        SELECT SINGLE rsnum  INTO @<fs_rollos_fab>-rsnum
          FROM caufv AS c
          WHERE aufnr = @ls_mseg-aufnr. "and

      ENDIF.

    ENDLOOP.

* Borramos rollos con kg. a 0 o negativos en el periodo filtrado(102 que hayan tenido 101's previos).
*    DELETE gt_rollos_fabricados WHERE menge <= 0.

    SELECT rsnum rspos matnr
          INTO TABLE gt_lista_mat_x_reserva
          FROM resb
          FOR ALL ENTRIES IN gt_rollos_fabricados
          WHERE rsnum = gt_rollos_fabricados-rsnum AND
                      rgekz <> 'X'.

  ENDMETHOD.
  METHOD obtener_lotes_mp_pulper.

    DATA: lr_charg  TYPE RANGE OF charg_d,
          lsr_charg LIKE LINE OF lr_charg.

* Obtenemos lotes en el Pulper.
    SELECT * INTO TABLE @DATA(lti_mchb)
      FROM  mchb
      WHERE   werks = @g_werks
        AND   lgort = @g_lgort_pulper
        AND   lvorm = @space
        AND   clabs > 0
* Filtramos los registros erroneos, para no repartirlos.
        AND   charg NOT IN ( SELECT lote_mp
                              FROM ztpp0044
                              WHERE werks = @g_werks AND
                                    ind_err_activo = 'X'
                            ).

    CHECK sy-subrc EQ 0.

    CLEAR lr_charg[].
    LOOP AT lti_mchb INTO DATA(ls_mchb).
      CLEAR lsr_charg.
      lsr_charg-sign   = 'I'.
      lsr_charg-option   = 'EQ'.
      lsr_charg-low   = ls_mchb-charg.
      INSERT lsr_charg  INTO TABLE lr_charg.
*      lr_charg = VALUE #( ( sign = 'I' option = 'EQ' low = ls_mchb-charg ) ).
    ENDLOOP.



* Obtenemos los movimientos 311 y 312 de los lotes encontrados anteriormente en el pulper.
    SELECT * FROM mseg
      INTO TABLE @DATA(lt_mseg)
      WHERE werks EQ @g_werks AND
            lgort EQ @g_lgort_pulper AND
            bwart IN ( '311', '312' ) AND
            sobkz EQ @space AND
            ( ( budat_mkpf EQ @g_fecha_fin_mp AND cputm_mkpf LE @g_hora_fin_mp ) OR  budat_mkpf LT @g_fecha_fin_mp ) AND
            charg IN @lr_charg.

    LOOP AT lt_mseg INTO DATA(ls_mseg).

      APPEND INITIAL LINE TO gt_mat_prima ASSIGNING FIELD-SYMBOL(<fs_mp>).

      SELECT SINGLE id_receta
        INTO @<fs_mp>-id_receta
        FROM ztpp0041 WHERE werks = @g_werks AND
                            charg = @ls_mseg-charg.

      <fs_mp>-charg       = ls_mseg-charg.
      <fs_mp>-matnr       = ls_mseg-matnr.

      TRY.
          ls_mchb = lti_mchb[ charg = ls_mseg-charg ].
          <fs_mp>-menge       = ls_mchb-clabs.
          <fs_mp>-menge_cons  = ls_mchb-clabs.
          <fs_mp>-meins       = ls_mseg-meins.

        CATCH cx_root .
          WRITE :/ |Error. Kg no encontrados para lote MP: { ls_mseg-charg }|.
      ENDTRY.

    ENDLOOP.


  ENDMETHOD.
  METHOD obtener_lotes_mp_pulper_crono.

    DATA: lr_charg            TYPE RANGE OF charg_d,
          lsr_charg           LIKE LINE OF lr_charg,
          l_kg_acum           TYPE menge_d,
          l_kg_totales_rollos TYPE menge_d,
          l_kg_herm_factoriz  TYPE menge_d,
          l_sw_kg_superados   TYPE flag,
          l_kg_a_cons_cap_max TYPE menge_d, " kg.pulper actual - capacidad max. pulper = kg que se deben consumir, como mínimo.
          l_desviacion_kg     TYPE menge_d, "
          l_ult_fecha         TYPE datum,
          l_ult_hora          TYPE uzeit,
          l_ult_lote          TYPE charg_d,
          l_ult_matnr         TYPE matnr.

    DATA: l_kg_herm_bucle      TYPE menge_d,
          l_kg_herm_fact_bucle TYPE menge_d.

* Obtener los Kg.Pulper(ZTPP0046-KG_PULPER_INI) antes de hacer consumo.
    SELECT SUM( clabs ) INTO @gs_ztpp0046-kg_pulper_ini
      FROM  mchb
      WHERE   werks = @g_werks
        AND   lgort = @g_lgort_pulper
        AND   lvorm = @space
        AND   clabs > 0
* Filtramos los registros erroneos, para no repartirlos de nuevo.
        AND   charg NOT IN ( SELECT lote_mp
                              FROM ztpp0044
                              WHERE werks           = @g_werks AND
                                    ind_err_activo  = 'X'
                            ).
    WRITE :/.
    WRITE :/ |Kg. totales Pulper ANTES del proceso: { gs_ztpp0046-kg_pulper_ini }|.
    WRITE :/.

* Calculamos (obligatorios) a consumir = ( kg.actuales pulper ) - ( Capacidad Máxima pulper )
    l_kg_a_cons_cap_max = gs_ztpp0046-kg_pulper_ini - gs_ztpp0003-max_pulper.

* Calculamos el total de kg de los rollos
    LOOP AT gt_rollos_fabricados INTO DATA(ls_rollos).
      l_kg_totales_rollos = l_kg_totales_rollos + ls_rollos-menge.
    ENDLOOP.

* Si el consumo total de rollos es negativo(102), salimos.
    WRITE :/ |Kg rollo reales: { l_kg_totales_rollos } Kg|.
    CHECK l_kg_totales_rollos > 0.

    gs_ztpp0046-kg_prod = l_kg_totales_rollos.

* 20/09/2020 INI CMS Comprobamos los kg. producidos de la última ejecución, si es menor que ZTPP0003-KG_CONTROL_PARADA
* no aplicaremos el factor corrector.
* 25/09/2020 la última producción obtenida, es la media de las 3 últimas ejecuciones.
    IF  gs_ztpp0003-kg_control_parada > obtener_ultima_produccion( g_werks ).

      gs_ztpp0003-factor_correc = 1.

    endif.
* 20/09/2020 FIN CMS

*    Aplicamos el coeficiente multiplicador y el factor corrector si lo hubiese.
*    Se añade el factor corrector calculado en  la ejecución anterior a partir de la desviación minutos. (CMS 31/07/2020 - 62288)
      l_kg_totales_rollos = l_kg_totales_rollos * ( gs_ztpp0003-factor_prod * gs_ztpp0003-factor_correc ).

      WRITE :/ |Coeficiente multiplicador      : { gs_ztpp0003-factor_prod }|.
      WRITE :/ |Kg rollo con factores aplicados: { l_kg_totales_rollos } Kg|.
      WRITE :/ |Factor corrector aplicado      : { gs_ztpp0003-factor_correc }|.
      gs_ztpp0046-kg_prod_ajust = l_kg_totales_rollos.
      gs_ztpp0046-factor        = gs_ztpp0003-factor_prod.
      gs_ztpp0046-factor_correc = gs_ztpp0003-factor_correc.

* Obtener Lote/kg. de MP en Stock
      SELECT * INTO TABLE @DATA(lti_mchb)
        FROM  mchb
        WHERE   werks = @g_werks
          AND   lgort = @g_lgort_pulper
          AND   lvorm = @space
          AND   clabs > 0
* Filtramos los registros erroneos, para no repartirlos de nuevo.
          AND   charg NOT IN ( SELECT lote_mp
                                FROM ztpp0044
                                WHERE werks           = @g_werks AND
                                      ind_err_activo  = 'X'
                              ).
      CHECK sy-subrc EQ 0.

      CLEAR: lr_charg[] .
      LOOP AT lti_mchb INTO DATA(ls_mchb).
        CLEAR lsr_charg.
        lsr_charg-sign   = 'I'.
        lsr_charg-option   = 'EQ'.
        lsr_charg-low   = ls_mchb-charg.
        INSERT lsr_charg  INTO TABLE lr_charg.
      ENDLOOP.

* Obtenemos los movimientos 311 y 312 de los lotes encontrados anteriormente en el pulper.
      SELECT * FROM mseg
        INTO TABLE @DATA(lt_mseg)
        WHERE werks EQ @g_werks AND
              lgort EQ @g_lgort_pulper AND
              bwart IN ( '311', '312' ) AND
              sobkz EQ @space AND
              charg IN @lr_charg.

      SORT lt_mseg BY budat_mkpf ASCENDING
                      cputm_mkpf ASCENDING.

      CLEAR: l_kg_acum            , l_sw_kg_superados ,
             g_fecha_crono        , g_hora_crono      , l_desviacion_kg ,
             g_kg_hermanos_crono  , l_kg_herm_factoriz.

      LOOP AT lt_mseg INTO DATA(ls_mseg).

        APPEND INITIAL LINE TO gt_mat_prima ASSIGNING FIELD-SYMBOL(<fs_mp>).

        SELECT SINGLE id_receta
          INTO @<fs_mp>-id_receta
          FROM ztpp0041 WHERE werks = @g_werks AND
                              charg = @ls_mseg-charg.

        <fs_mp>-charg       = ls_mseg-charg.
        <fs_mp>-matnr       = ls_mseg-matnr.

        TRY.
            ls_mchb = lti_mchb[ charg = ls_mseg-charg ].
            <fs_mp>-menge       = ls_mchb-clabs.
            <fs_mp>-menge_cons  = ls_mchb-clabs.
            <fs_mp>-meins       = ls_mseg-meins.

* Acumulamos el lote MP leído en el loop
            l_kg_acum           = l_kg_acum + <fs_mp>-menge.

            CLEAR: l_kg_herm_bucle , l_kg_herm_fact_bucle.

* Búsqueda de fictios pendientes de procesar para RESTAR kg.producción (l_kg_totales_rollos).
            SELECT * INTO TABLE @DATA(lt_hermanos)
              FROM ztpp0041
              WHERE werks           = @g_werks AND
                    id_receta       =  @<fs_mp>-id_receta AND
                    charg           LIKE '999%' AND
                    ind_sin_etiq    = '1' AND
                    lote_mp_hermano = @ls_mseg-charg.
            IF sy-subrc = 0.


              LOOP AT lt_hermanos INTO DATA(ls_herm).
* Restamos los Kg. de los ficticios a los Kg totales rollos aplicando el factor de producción.
                l_kg_totales_rollos   = l_kg_totales_rollos - ( ls_herm-kg_reales * gs_ztpp0003-factor_prod ).
                g_kg_hermanos_crono   = g_kg_hermanos_crono + ls_herm-kg_reales.
                l_kg_herm_factoriz    = l_kg_herm_factoriz + ( ls_herm-kg_reales * gs_ztpp0003-factor_prod ).

                l_kg_herm_bucle       = l_kg_herm_bucle       + ls_herm-kg_reales.
                l_kg_herm_fact_bucle  = l_kg_herm_fact_bucle  + ( ls_herm-kg_reales * gs_ztpp0003-factor_prod ).
              ENDLOOP.

            ENDIF.

* Validar si la MP leida(l_kg_acum) supera la producción, para hacer el corte
            IF l_kg_acum > l_kg_totales_rollos AND l_sw_kg_superados = ' '.

              IF sy-uzeit < '120000'. " los 3 primeros procesos del dia descontaremos el ultimo lote para no superar el limite de producción
                g_fecha_crono         =  l_ult_fecha.
                g_hora_crono          =  l_ult_hora.
              ELSE.
                g_fecha_crono     =  ls_mseg-budat_mkpf.
                g_hora_crono      =  ls_mseg-cputm_mkpf.
                l_ult_lote        =  ls_mseg-charg.
                l_ult_matnr       =  ls_mseg-matnr.
              ENDIF.
              l_sw_kg_superados = 'X'.
            ENDIF.

            IF l_sw_kg_superados = 'X'.

              IF l_kg_acum > l_kg_a_cons_cap_max.
* SOLO si hay "Kg. Desviación" informaremos los Kg/Fecha/hora Desviación Capacidad
                IF l_desviacion_kg > 0.
                  gs_ztpp0046-fecha_capacidad = ls_mseg-budat_mkpf.
                  gs_ztpp0046-hora_capacidad  = ls_mseg-cputm_mkpf.
                  gs_ztpp0046-desv_capacidad  = l_desviacion_kg.
                ENDIF.
                IF sy-uzeit < '120000'. " los 3 primeros procesos del dia descontaremos el ultimo lote para no superar el limite de producción
* Si no hay que tener en cuenta el último lote MP y sus hermanos, lo restamos de las diferentes variables acumuladas
                  l_kg_acum             = l_kg_acum - <fs_mp>-menge.
                  l_kg_totales_rollos   = l_kg_totales_rollos + l_kg_herm_fact_bucle.
                  g_kg_hermanos_crono   = g_kg_hermanos_crono - l_kg_herm_bucle.
                  l_kg_herm_factoriz    = l_kg_herm_factoriz - l_kg_herm_fact_bucle.
                  CLEAR <fs_mp>.
                ENDIF.
                EXIT.

              ELSE.
                l_desviacion_kg = l_desviacion_kg + <fs_mp>-menge.
              ENDIF.
            ENDIF.

          CATCH cx_root .
            WRITE :/ |Error. Kg no encontrados para lote MP: { ls_mseg-charg }|.
        ENDTRY.


        l_ult_fecha       =  ls_mseg-budat_mkpf.
        l_ult_hora        =  ls_mseg-cputm_mkpf.
        l_ult_lote        =  ls_mseg-charg.
        l_ult_matnr       =  ls_mseg-matnr.

      ENDLOOP.

      IF g_fecha_crono IS INITIAL.
        CALL METHOD enviar_mail_crono_overflow
          EXPORTING
            i_kg_acumulados = l_kg_acum.

        g_fecha_crono = l_ult_fecha.
        g_hora_crono  = l_ult_hora.
      ENDIF.


* De 24h de la noche a 12h del mediodia, se borra el último registro generado
      DELETE gt_mat_prima WHERE charg IS INITIAL.


      WRITE :/ .
      WRITE :/ |Datos cálculo proceso "crono":|.
      WRITE :/ |Kg.acumulados MP                        = { l_kg_acum }|.
      WRITE :/ |Kg.acumulados de lotes hermanos         = { g_kg_hermanos_crono }|.
      WRITE :/ |Kg.produc.rollos  (descontando hermanos) = { l_kg_totales_rollos }|.
      WRITE :/ |Lot de corte--> material:{ l_ult_matnr ALPHA = OUT } lote: { l_ult_lote ALPHA = OUT }|.
      WRITE :/ .

      gs_ztpp0046-desv_capacidad      = l_desviacion_kg.
      gs_ztpp0046-kg_mp_consum        = l_kg_acum.
      gs_ztpp0046-kg_balas_herm       = g_kg_hermanos_crono.
      gs_ztpp0046-kg_balas_herm_fact  = l_kg_herm_factoriz.
      gs_ztpp0046-kg_prod_consum      = l_kg_totales_rollos.
      gs_ztpp0046-material_mp         = l_ult_matnr.
      gs_ztpp0046-lote_mp             = l_ult_lote.

    ENDMETHOD.
  METHOD obtener_parametros_crono.

    SELECT SINGLE *
      INTO @gs_ztpp0003
      FROM ztpp0003
      WHERE werks    = @g_werks AND
            progname = 'ZRPP0002_V2'.

  ENDMETHOD.
  METHOD obtener_ultima_produccion.

** Obtener la última ejecución.
*    SELECT SINGLE kg_prod
*      FROM ztpp0046
*      INTO @r_kg_ultima_ejec
*      WHERE werks = @i_werks AND
*            fecha_ejec IN ( SELECT MAX( fecha_ejec )
*                              FROM ztpp0046
*                              WHERE werks = @i_werks
*                           ) AND
*            hora_ejec IN ( SELECT MAX( hora_ejec )
*                             FROM ztpp0046
*                             WHERE werks = @i_werks AND
*                                    fecha_ejec IN ( SELECT MAX( fecha_ejec )
*                                                      FROM ztpp0046
*                                                      WHERE werks = @i_werks
*                                                   )
*                           ).

*Obtener la media de las 3 últimas ejecuciones.
    DATA(l_sydatum_1) = sy-datum - 1.

    SELECT fecha_ejec , hora_ejec , kg_prod
      FROM ztpp0046
      INTO TABLE @DATA(lt_kg)
      WHERE werks = @i_werks AND
            fecha_ejec IN ( @sy-datum , @l_sydatum_1 )
      ORDER BY fecha_ejec DESCENDING ,
               hora_ejec  DESCENDING.

    TRY.
        r_kg_ultima_ejec = ( lt_kg[ 1 ]-kg_prod + lt_kg[ 2 ]-kg_prod + lt_kg[ 3 ]-kg_prod ) / 3.
      CATCH cx_root .
    ENDTRY.

  ENDMETHOD.
  method PROCESAR_ERRORES_PENDIENTES.

        DATA:    ls_bapi_items   TYPE bapi2017_gm_item_create,
             lt_bapi_items   TYPE TABLE OF bapi2017_gm_item_create,
             ls_43           TYPE ztpp0043,
             l_num_rollos_ok TYPE i,
             l_num_rollos_ko TYPE i,
             l_idx           TYPE mblpo
             .

    CLEAR: l_num_rollos_ok , l_num_rollos_ko.
    SELECT *
      INTO TABLE @DATA(lt_44)
      FROM ztpp0044
      WHERE werks = @i_werks AND
            ind_err_activo = 'X'
      ORDER BY lote_rollo ASCENDING,
               lote_mp    ASCENDING.

    SELECT DISTINCT  lote_rollo , ubic_pm
      INTO TABLE @DATA(lt_rollos)
      FROM ztpp0044
      WHERE werks = @i_werks AND
            ind_err_activo = 'X'.


    LOOP AT lt_rollos INTO DATA(ls_rollos).
      CLEAR: lt_bapi_items .
      LOOP AT lt_44 ASSIGNING FIELD-SYMBOL(<ztpp0044>) WHERE lote_rollo = ls_rollos-lote_rollo.

        CLEAR: ls_bapi_items.
        ls_bapi_items-material     = <ztpp0044>-matnr_mp.
        ls_bapi_items-plant        = i_werks.
        ls_bapi_items-stge_loc     = <ztpp0044>-ubic_pm.
        ls_bapi_items-batch        = <ztpp0044>-lote_mp.
        ls_bapi_items-move_type    = '261'.
        ls_bapi_items-stck_type    = ' '. " Libre utilización
        ls_bapi_items-entry_qnt    = <ztpp0044>-kg_pend_mp.
        ls_bapi_items-entry_uom    = 'KG'.
        ls_bapi_items-orderid      = <ztpp0044>-of_rollo.

        APPEND ls_bapi_items TO lt_bapi_items.

      ENDLOOP.

* Una vez obtenidos los Items, creamos el documento
      IF lt_bapi_items IS NOT INITIAL.

        CALL METHOD zclpp_recetas_reparto_pulper=>generar_movimiento_261
          EXPORTING
            it_bapi_items = lt_bapi_items
            i_tp_consumo  = 'P' "Consumo pulper / Diferido
          IMPORTING
            o_mblnr       = DATA(l_mblnr)
            o_mjahr       = DATA(l_mjahr)
            o_rc          = DATA(l_rc)
            ot_bapiret2   = DATA(lt_bapiret2).

        l_idx = 0.

* Si ha habido error, printamos los errores de la llamada a la BAPI.
        IF l_rc <> '00'.
          WRITE :/ |Error en REPROCESO del lote de rollo: { ls_rollos-lote_rollo }; OF: { ls_bapi_items-orderid }|.
          LOOP AT lt_bapiret2 INTO DATA(ls_bapiret2).
            WRITE :/ |{ ls_bapiret2-type } { ls_bapiret2-id } { ls_bapiret2-number } { ls_bapiret2-message } { ls_bapiret2-message_v1 } { ls_bapiret2-message_v2 } { ls_bapiret2-message_v3 } { ls_bapiret2-message_v4 } |.
          ENDLOOP.

          ADD 1 TO l_num_rollos_ko.
        ELSE.
          ADD 1 TO l_num_rollos_ok.
        ENDIF.


        LOOP AT lt_bapi_items INTO DATA(ls_item).
          ADD 1 TO l_idx.
          TRY.
              ASSIGN lt_44[ lote_mp    = ls_item-batch
                            lote_rollo = ls_rollos-lote_rollo ] TO FIELD-SYMBOL(<fs_44>).
            CATCH cx_root .
              CONTINUE.
          ENDTRY.

          CASE l_rc.
            WHEN '00'.

              CLEAR ls_43.
              SELECT SINGLE *
                INTO @ls_43
                FROM ztpp0043
                WHERE  lote_mp    = @ls_item-batch AND
                       lote_rollo = @ls_rollos-lote_rollo AND
                       werks      = @i_werks.
              IF sy-subrc <> 0. "Informamos campos clave para el método de grabacion 43-44
                ls_43-lote_mp           = ls_item-batch.
                ls_43-lote_rollo        = ls_rollos-lote_rollo.
                ls_43-werks             = i_werks.
              ENDIF.
              ls_43-ind_no_tratado    = ' '.
              ls_43-mblnr_261         = l_mblnr.
              ls_43-mjahr_261         = l_mjahr.
              ls_43-zeile_261         = l_idx.
              <fs_44>-ind_err_activo  = ' '.
              <fs_44>-fecha_consumo    = sy-datum.
              <fs_44>-hora_consumo     = sy-uzeit.
              CALL METHOD zclpp_recetas_reparto_pulper=>grabar_reparto_ztpp0043_44
                CHANGING
                  cs_ztpp0043 = ls_43
                  cs_ztpp0044 = <fs_44>.


            WHEN '01'.
              CLEAR ls_43.
              SELECT SINGLE *
                INTO @ls_43
                FROM ztpp0043
                WHERE  lote_mp    = @ls_item-batch AND
                       lote_rollo = @ls_rollos-lote_rollo AND
                       werks      = @i_werks.
              IF sy-subrc <> 0. "Informamos campos clave para el método de grabacion 43-44
                ls_43-lote_mp           = i_werks.
                ls_43-lote_rollo        = ls_rollos-lote_rollo.
                ls_43-werks             = i_werks.
              ENDIF.

              <fs_44>-ind_err_activo   = 'X'.
              ls_43-ind_no_tratado     = 'X'.
              TRY.
                  ls_bapiret2 =  lt_bapiret2[ type = 'E' row = l_idx ].

                  <fs_44>-type            = ls_bapiret2-type.
                  <fs_44>-id              = ls_bapiret2-id.
                  <fs_44>-znumber         = ls_bapiret2-number.
                  CALL FUNCTION 'BAPI_MESSAGE_GETDETAIL'
                    EXPORTING
                      id         = <fs_44>-id
                      number     = <fs_44>-znumber
                      textformat = ' '
                      message_v1 = ls_bapiret2-message_v1
                      message_v2 = ls_bapiret2-message_v2
                      message_v3 = ls_bapiret2-message_v3
                      message_v4 = ls_bapiret2-message_v4
                    IMPORTING
                      message    = <fs_44>-message
                    .
                  ls_43-msg_no_tratado = <fs_44>-message.
                CATCH cx_root .
                  CLEAR:  <fs_44>-type,
                          <fs_44>-id,
                          <fs_44>-znumber,
                          <fs_44>-message,
                          ls_43-msg_no_tratado.
              ENDTRY.

              CALL METHOD zclpp_recetas_reparto_pulper=>grabar_reparto_ztpp0043_44
                CHANGING
                  cs_ztpp0043 = ls_43
                  cs_ztpp0044 = <fs_44>.
            WHEN OTHERS.
          ENDCASE.
          COMMIT WORK AND WAIT.

        ENDLOOP.

      ENDIF.

    ENDLOOP.

    WRITE :/ |Resultado del reproceso de errores pendientes:|.
    WRITE :/ |Rollos procesados OK: { l_num_rollos_ok }|.
    WRITE :/ |Rollos erroneos     : { l_num_rollos_ko }|.


  endmethod.
  METHOD procesar_reparto_rollo.
    DATA: l_rc TYPE char02.
* Procesamos items con Reserva
    CHECK it_items_bapi IS NOT INITIAL.

    l_rc = '00'.

    IF iw_solo_grabar_43 = ' '.
      CALL METHOD zclpp_recetas_reparto_pulper=>generar_movimiento_261
        EXPORTING
          it_bapi_items = it_items_bapi
          i_tp_consumo  = 'P' "Consumo pulper / Diferido
        IMPORTING
          o_mblnr       = DATA(l_mblnr)
          o_mjahr       = DATA(l_mjahr)
          o_rc          = l_rc
          ot_bapiret2   = DATA(lt_bapiret2).
    ENDIF.

    DATA(l_idx) = 0.

* Si ha habido error, printamos los errores de la llamada a la BAPI.
    IF l_rc <> '00'.
      WRITE :/ |Error al procesar lote de rollo: { i_lote_rollo }; OF:{ it_items_bapi[ 1 ]-orderid }|.
      LOOP AT lt_bapiret2 INTO DATA(ls_bapiret2) where type = 'E'.
        WRITE :/ |{ ls_bapiret2-type } { ls_bapiret2-id } { ls_bapiret2-number } { ls_bapiret2-message } { ls_bapiret2-message_v1 } { ls_bapiret2-message_v2 } { ls_bapiret2-message_v3 } { ls_bapiret2-message_v4 } |.
        insert ls_bapiret2 into TABLE gt_bapiret2.
      ENDLOOP.
    ENDIF.


    LOOP AT it_items_bapi INTO DATA(ls_item).
      ADD 1 TO l_idx.
      TRY.
          ASSIGN gt_ztpp0043[ lote_mp    = ls_item-batch
                              lote_rollo = i_lote_rollo ] TO FIELD-SYMBOL(<fs_43>).
        CATCH cx_root .
          CONTINUE.
      ENDTRY.

      CASE l_rc.
        WHEN '00'.

          <fs_43>-ind_no_tratado   = ' '.
          <fs_43>-mblnr_261        = l_mblnr.
          <fs_43>-mjahr_261        = l_mjahr.
          <fs_43>-zeile_261        = l_idx.
          CALL METHOD zclpp_recetas_reparto_pulper=>grabar_reparto_ztpp0043_44
            CHANGING
              cs_ztpp0043 = <fs_43>.

        WHEN '01'.

          APPEND INITIAL LINE TO gt_ztpp0044 ASSIGNING FIELD-SYMBOL(<zttpp0044>).
          gw_error_en_proceso = 'X'.
          <zttpp0044>-werks           = <fs_43>-werks.
          <zttpp0044>-lote_mp         = <fs_43>-lote_mp.
          <zttpp0044>-lote_rollo      = <fs_43>-lote_rollo.
          <zttpp0044>-matnr_rollo     = <fs_43>-matnr_rollo.
          <zttpp0044>-matnr_mp        = <fs_43>-matnr_mp.
          <zttpp0044>-kg_pend_mp      = <fs_43>-kg_mp.
          <zttpp0044>-kg_lote_rollo   = <fs_43>-kg_rollo.
          <zttpp0044>-ubic_pm         = <fs_43>-almacen_pm.
          <zttpp0044>-of_rollo        = <fs_43>-of_rollo.

          <zttpp0044>-ind_err_activo  = 'X'.
          <fs_43>-ind_no_tratado   = 'X'.
          TRY.
              ls_bapiret2 =  lt_bapiret2[ type = 'E' row = l_idx ].

              <zttpp0044>-type            = ls_bapiret2-type.
              <zttpp0044>-id              = ls_bapiret2-id.
              <zttpp0044>-znumber         = ls_bapiret2-number.
              CALL FUNCTION 'BAPI_MESSAGE_GETDETAIL'
                EXPORTING
                  id         = <zttpp0044>-id
                  number     = <zttpp0044>-znumber
                  textformat = ' '
                  message_v1 = ls_bapiret2-message_v1
                  message_v2 = ls_bapiret2-message_v2
                  message_v3 = ls_bapiret2-message_v3
                  message_v4 = ls_bapiret2-message_v4
                IMPORTING
                  message    = <zttpp0044>-message
                .
              <fs_43>-msg_no_tratado = <zttpp0044>-message.
            CATCH cx_root .
              CLEAR:  <zttpp0044>-type,
                      <zttpp0044>-id,
                      <zttpp0044>-znumber,
                      <zttpp0044>-message,
                      <fs_43>-msg_no_tratado.
          ENDTRY.

          CALL METHOD zclpp_recetas_reparto_pulper=>grabar_reparto_ztpp0043_44
            CHANGING
              cs_ztpp0043 = <fs_43>
              cs_ztpp0044 = <zttpp0044>.
          COMMIT WORK AND WAIT.
        WHEN OTHERS.
      ENDCASE.

    ENDLOOP.

  ENDMETHOD.
  METHOD sustituir_fict_x_sin_etiqueta.

    o_rc = '00'.

    SELECT SINGLE * INTO @DATA(ls_z41)
      FROM ztpp0041
      WHERE werks     = @i_werks  AND
            id_receta = @i_receta AND
            charg     = @i_fict.

    IF sy-subrc <> 0.
      o_rc = '01'.
      EXIT.
    ENDIF.

* Actualizar el indicador al registro ficticio para que conste como substituido.
    UPDATE    ztpp0041
       SET    ind_sin_etiq = '2'
              fecha_upd    = sy-datum
              hora_upd     = sy-uzeit
              pmv          = 0
              ind_lote_consum = ' '
      WHERE werks     = i_werks  AND
            id_receta = i_receta AND
            charg     = i_fict.

    IF sy-subrc <> 0.
      o_rc = '02'.
      EXIT.
    ENDIF.

* Obtenemos el doc.material + periodo (mov.101) del lote hermano del ficticio.
    SELECT SINGLE * INTO @DATA(ls_z41_bro)
      FROM ztpp0041
      WHERE werks     = @i_werks  AND
            id_receta = @i_receta AND
            charg     = @ls_z41-lote_mp_hermano.
      IF sy-subrc = 0.
        ls_z41-mblnr  = ls_z41_bro-mblnr.
        ls_z41-mjahr  = ls_z41_bro-mjahr.

        ls_z41-pmv                = ls_z41_bro-pmv.
        ls_z41-ind_lote_consum    = 'X'.
      ENDIF.

* Generamos nuevo registro a partir del ficticio, para el lote sin etiqueta.
    ls_z41-lote_mp_hermano    = ls_z41-charg.
    ls_z41-charg              = i_sin_etiq.
    IF i_operario IS SUPPLIED.
      ls_z41-contr_upd          = i_operario.
    ENDIF.
    ls_z41-fecha_upd          = sy-datum.
    ls_z41-hora_upd           = sy-uzeit.
    INSERT INTO ztpp0041 VALUES ls_z41.

    IF sy-subrc <> 0.
      o_rc = '03'.
      EXIT.
    ENDIF.

  ENDMETHOD.
