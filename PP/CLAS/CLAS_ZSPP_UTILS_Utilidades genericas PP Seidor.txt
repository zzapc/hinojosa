
CLASS zspp_utils DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS get_ofs_grafo
      IMPORTING
        !i_aufnr    TYPE aufnr
      EXPORTING
        !o_tt_aufnr TYPE zspp_tt_aufnr.
    CLASS-METHODS get_lote_tinta
      IMPORTING
        !i_matnr       TYPE matnr
        !i_lgort       TYPE lgort_d
        !i_werks       TYPE werks_d
        !i_clabs       TYPE labst
        !i_lifo_date   TYPE datum OPTIONAL
      RETURNING
        VALUE(o_charg) TYPE zspp_tt_charg.

    CLASS-METHODS get_tinta
      IMPORTING
        !i_matnr           TYPE matnr
      RETURNING
        VALUE(or_es_tinta) TYPE xfeld .

    CLASS-METHODS determina_fecha_fin_sichz
      IMPORTING
        VALUE(i_fecha_fin) TYPE datum
        !i_aufnr           TYPE aufnr
      RETURNING
        VALUE(o_fecha)     TYPE datum .

    CLASS-METHODS determina_fecha_fin
      IMPORTING
        VALUE(i_fecha_fin) TYPE datum
        !i_werks           TYPE werks_d
      RETURNING
        VALUE(o_fecha)     TYPE datum .
    CLASS-METHODS check_lote_inspeccion
      IMPORTING
        !i_aufnr       TYPE aufnr
        !i_sala_blanca TYPE xfeld
      EXPORTING
        !o_prueflos    TYPE qplos
        !o_werks       TYPE werks_d
        !o_estado      TYPE any .
    CLASS-METHODS get_lote_inspeccion
      IMPORTING
        !i_aufnr     TYPE aufnr
      EXPORTING
        !ot_prueflos TYPE zspp_tt_utils_prueflos .
    CLASS-METHODS lock_of
      IMPORTING
        !i_aufnr               TYPE aufnr
      EXPORTING
        !o_bloqueada_con_exito TYPE xfeld
        !o_ya_bloqueada        TYPE xfeld .
    CLASS-METHODS unlock_of
      IMPORTING
        !i_aufnr                  TYPE aufnr
      EXPORTING
        !o_ya_bloqueada           TYPE xfeld
        !o_desbloqueada_con_exito TYPE xfeld .
    CLASS-METHODS get_puesto_trabajo
      IMPORTING
        !i_aufnr       TYPE aufnr
        !i_vornr       TYPE vornr DEFAULT '0010'
        !i_ktsch       TYPE any DEFAULT ''
      RETURNING
        VALUE(o_arbpl) TYPE arbpl .
    CLASS-METHODS get_asp_puesto
      IMPORTING
        !i_arbpl       TYPE arbpl
        !i_werks       TYPE werks_d
      RETURNING
        VALUE(o_prvbe) TYPE prvbe .
    CLASS-METHODS get_ubicacion_asp
      IMPORTING
        !i_prvbe       TYPE prvbe
        !i_lgnum       TYPE lgnum
        !i_werks       TYPE werks_d OPTIONAL
      RETURNING
        VALUE(o_lgpla) TYPE lgpla .
    CLASS-METHODS get_lgnum_of_werks
      IMPORTING
        !i_werks       TYPE werks_d
        !i_lgort       TYPE lgort_d
      RETURNING
        VALUE(o_lgnum) TYPE lgnum .
    CLASS-METHODS get_centro_of
      IMPORTING
        !i_aufnr       TYPE aufnr
      RETURNING
        VALUE(o_werks) TYPE werks_d .
    CLASS-METHODS check_of_exist
      IMPORTING
        !i_aufnr          TYPE aufnr
      EXPORTING
        !o_return         TYPE bapiret2_tab
        !o_error          TYPE xfeld
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS get_of_status
      IMPORTING
        !i_aufnr          TYPE aufnr
      EXPORTING
        !ot_status        TYPE tttjo2t
        !ot_return        TYPE bapiret2_tab
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS get_of_user_status
      IMPORTING
        !i_aufnr          TYPE aufnr
      EXPORTING
        !ot_status        TYPE bu_tj30t_t
        !ot_return        TYPE bapiret2_tab
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS check_matnr_exists
      IMPORTING
        !i_matnr          TYPE matnr
      EXPORTING
        !o_return         TYPE bapiret2_tab
        !o_error          TYPE xfeld
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS check_vornr_exists
      IMPORTING
        !i_aufnr          TYPE aufnr
        !vornr            TYPE vornr
      EXPORTING
        !o_return         TYPE bapiret2_tab
        !o_error          TYPE xfeld
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS check_posnr_exists
      IMPORTING
        !i_aufnr          TYPE aufnr
        !i_posnr          TYPE aposn
      EXPORTING
        !o_return         TYPE bapiret2_tab
        !o_error          TYPE xfeld
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS add_compo_resb
      IMPORTING
        !i_aufnr          TYPE aufnr
        !i_matnr          TYPE matnr
        !i_menge          TYPE menge_d
        !i_vornr          TYPE vornr
        !i_postp          TYPE postp
      EXPORTING
        !o_bapiret        TYPE bapiret2_tab
      CHANGING
        VALUE(co_obj_log) TYPE REF TO zspp_seidor_guardar_log OPTIONAL .
    CLASS-METHODS check_lock_of
      IMPORTING
        !i_aufnr      TYPE aufnr
      EXPORTING
        !o_desbloqueo TYPE xfeld .
    CLASS-METHODS change_compo_resb
      IMPORTING
        !i_aufnr      TYPE aufnr
        !is_comp_key  TYPE coxt_s_ord_comp_key
        !is_comp_data TYPE zsppst_comp_orden
      EXPORTING
        !ot_return    TYPE bapiret2_tab .
    CLASS-METHODS check_matnr_of
      IMPORTING
        !i_matnr   TYPE matnr
        !i_aufnr   TYPE aufnr
      EXPORTING
        !o_error   TYPE xfeld
        !ot_return TYPE bapiret2_tab .
    CLASS-METHODS get_batch_of
      IMPORTING
        !i_aufnr   TYPE aufnr
      EXPORTING
        !o_error   TYPE xfeld
        !ot_return TYPE bapiret2_tab
        !o_charg   TYPE charg_d .
    CLASS-METHODS get_release_date
      IMPORTING
        !i_aufnr TYPE aufnr
      EXPORTING
        !o_ftrmi TYPE co_ftrmi .
  PROTECTED SECTION.
  PRIVATE SECTION.
endclass. "ZSPP_UTILS definition
class ZSPP_UTILS implementation.
  METHOD add_compo_resb.

    DATA lv_desbloqueo TYPE xfeld.

    CLEAR lv_desbloqueo.
    DO 10 TIMES.
      zspp_utils=>check_lock_of(
        EXPORTING
          i_aufnr      = i_aufnr                  " Número de orden
        IMPORTING
          o_desbloqueo = lv_desbloqueo                 " desbloqueada si o no
      ).

      IF lv_desbloqueo IS NOT INITIAL.
        EXIT.
      ENDIF.
    ENDDO.

    IF lv_desbloqueo IS INITIAL.
      APPEND INITIAL LINE TO o_bapiret ASSIGNING FIELD-SYMBOL(<erro>).
      <erro>-type = 'E'.
      <erro>-id = '00'.
      <erro>-number = '398'.
      <erro>-message_v1 = 'Orden'.
      <erro>-message_v2 = i_aufnr.
      <erro>-message_v3 = 'está bloq por usuario.'.
      <erro>-message_v4 = 'Imposible añadir componente' && i_matnr.
      MESSAGE ID <erro>-id TYPE <erro>-type NUMBER <erro>-number
      WITH <erro>-message_v1  <erro>-message_v2 <erro>-message_v3 <erro>-message_v4
      INTO <erro>-message.
      EXIT.
    ENDIF.

    DATA : is_order_key            TYPE  coxt_ord_key,
           is_requirement_quantity TYPE  coxt_s_quantity,
           i_material              TYPE  coxt_material,
           is_storage_location     TYPE  coxt_s_storage_location,
           is_storage_locationx    TYPE  coxt_s_storage_locationx,
           i_batch                 TYPE  coxt_batch,
           i_batchx                TYPE  coxt_batchx,
           lv_postp                TYPE  resb-postp,
           i_posno                 TYPE cif_r3res-positionno,
           i_operation             TYPE afvc-aplzl,
           i_cant_conf             TYPE coxt_s_quantity,
           i_cant_confx            TYPE coxt_s_quantityx.

    is_order_key = i_aufnr.
    i_material = i_matnr.
    i_cant_conf-quantity = is_requirement_quantity-quantity = i_menge.
    SELECT SINGLE meins INTO @DATA(lv_meins) FROM mara WHERE matnr EQ @i_matnr.
    i_cant_conf-uom = is_requirement_quantity-uom = lv_meins.
    is_storage_location-werks = zspp_utils=>get_centro_of( i_aufnr = i_aufnr ).
    SELECT SINGLE lgpro
      INTO @is_storage_location-lgort
      FROM marc
      WHERE matnr EQ @i_matnr
      AND werks EQ @is_storage_location-werks.
    IF is_storage_location-lgort IS INITIAL.
      SELECT SINGLE lgfsb
            INTO @is_storage_location-lgort
            FROM marc
            WHERE matnr EQ @i_matnr
            AND werks EQ @is_storage_location-werks.
      IF is_storage_location-lgort IS INITIAL.
        is_storage_location-lgort = '2000'.
      ENDIF.
    ENDIF.
    is_storage_locationx-werks = 'X'.
    is_storage_locationx-lgort = 'X'.

    lv_postp = i_postp.

    DATA lv_aplzl TYPE co_aplzl.
    SELECT SINGLE aplzl
    FROM afko AS t1 INNER JOIN afvc AS t2
    ON t1~aufpl EQ t2~aufpl
    INTO lv_aplzl
    WHERE vornr EQ i_vornr AND aufnr EQ i_aufnr AND loekz EQ space.
    i_operation = lv_aplzl.
*    i_batch = i_charg.
*    i_cant_confx = i_batchx = 'X'.

    DATA ret TYPE  coxt_bapireturn.
    CLEAR ret.

    SELECT MAX( posnr ) INTO @DATA(lv_posnr)
*    FROM stpo AS t1 INNER JOIN afko AS t2 ON t1~stlnr EQ t2~stlnr
      FROM resb
      WHERE aufnr EQ @i_aufnr.

    lv_posnr = lv_posnr + 10.
*  i_posno = i_posno + 10.
    TRY.
        CALL FUNCTION 'CO_XT_COMPONENT_ADD'
          EXPORTING
            is_order_key         = is_order_key
            i_material           = i_material
            is_requ_quan         = is_requirement_quantity
            is_conf_quan         = i_cant_conf
            is_conf_quanx        = i_cant_confx
            i_operation          = i_operation
*           I_SEQUENCE           =
            is_storage_location  = is_storage_location
            is_storage_locationx = is_storage_locationx
            i_batch              = i_batch
            i_batchx             = i_batchx
*           I_CUOBJ              =
*           I_CUOBJX             =
*           I_BATCH_SEL_CUOBJ    =
*           I_BATCH_SEL_CUOBJX   =
            i_postp              = lv_postp
*           I_KZKUP              =
*           I_KZKUPX             =
*           I_XFEHL              =
*           I_XFEHLX             =
*           I_SOBKZ              =
*           I_SOBKZX             =
*           I_KDAUF              =
*           I_KDAUFX             =
*           I_KDPOS              =
*           I_KDPOSX             =
*           I_PSPEL              =
*           I_PSPELX             =
            i_posno              = i_posno
*           I_KZAUS              =
*           I_KZAUSX             =
*           I_NAFKZ              =
*           I_NAFKZX             =
*           I_NOMAT              =
*           I_NOMATX             =
*           I_NFUML              =
*           I_NFUMLX             =
*           I_NFPKZ              =
*           I_NFPKZX             =
*           I_NOMNG              =
*           I_NOMNGX             =
          IMPORTING
*           ES_AFPO              =
*           ES_ISSUEDATE         =
            es_bapireturn        = ret
*           E_ERROR_OCCURRED     =
*           ES_RESBD_CREATED     =
* TABLES
*           RESBT_EXP            =
          .
      CATCH cx_root INTO DATA(wa_excep).
        DATA(long) = wa_excep->get_longtext(
          preserve_newlines = abap_true
        ).
        DATA(short) = wa_excep->get_text( ).


        APPEND INITIAL LINE TO o_bapiret ASSIGNING FIELD-SYMBOL(<fs_ret>).
        <fs_ret>-type = 'E'.
        <fs_ret>-id = '00'.
        <fs_ret>-number = '398'.
        <fs_ret>-message_v1 = <fs_ret>-message = long.
        RETURN.
    ENDTRY.
    WAIT UP TO 1 SECONDS.
    APPEND INITIAL LINE TO o_bapiret ASSIGNING <fs_ret>.
    MOVE-CORRESPONDING ret TO <fs_ret>.

    IF ret-type EQ 'A' OR ret-type EQ 'E' OR ret-type EQ 'X'.
      RETURN.
    ENDIF.

    CALL FUNCTION 'CO_XT_ORDER_PREPARE_COMMIT'.
    WAIT UP TO 1 SECONDS.
    DATA resb TYPE TABLE OF resbdget.
    DATA lv_aufnr TYPE aufnr.
    lv_aufnr = i_aufnr.
    CALL FUNCTION 'CO_BC_RESBD_OF_ORDER_GET'
      EXPORTING
        aufnr_act      = lv_aufnr
        get_old        = ' '
        no_maktx       = 'X'
        no_statx       = 'X'
        check_deleted  = ' '
        no_read        = ' '
        check_vbkz_del = 'X'
        i_archive      = ' '
      TABLES
*       ARESB_EXP      =
        resbd_get      = resb.

    DATA lv_num TYPE sy-tabix.
    DATA wa_resb TYPE resbdget.
*  FIELD-SYMBOLS <fs_resb> TYPE resbdget.
*  DATA lv_indice_old TYPE sy-tabix.
    DATA lv_rspos TYPE rspos.
*  "Modificamos los valores de la línea original para ajustar las cantidades
*  READ TABLE resb WITH KEY posnr = i_posnr ASSIGNING <fs_resb>.
*  lv_indice_old = sy-tabix.
*  <fs_resb>-bdmng = <fs_resb>-bdmng - i_menge.
*  <fs_resb>-erfmg = <fs_resb>-erfmg - i_menge.
*  <fs_resb>-splkz = 1.
*  lv_rspos = <fs_resb>-rspos.
*  DATA resb_act TYPE resbd.
*  MOVE-CORRESPONDING <fs_resb> TO resb_act.
*
*  WAIT UP TO 1 SECONDS.
*  CALL FUNCTION 'CO_BT_RESB_UPDATE'
*    EXPORTING
*      resb_new  = resb_act
*      tabix_old = lv_indice_old
**     NO_DUM_UPD           = ' '
**     NO_REQ_PROCESS       = ' '
**     INS_MODE  = ' '
**     FLG_OCM   = ' '
**     I_RGEKZ_UPD          = ' '
**     IMPORTING
**     TABIX_NEW =
*    .

    DESCRIBE TABLE resb LINES lv_num.
    "La última línea será la que hemos añadido
    READ TABLE resb INTO wa_resb INDEX lv_num.
    IF sy-subrc = 0.
      "El matkl no lo trae correctamente, lo rescatamos
      SELECT SINGLE matkl FROM mara INTO wa_resb-matkl WHERE matnr = wa_resb-matnr.

      DATA resb_upd TYPE resbd.
      MOVE-CORRESPONDING wa_resb TO resb_upd.
      resb_upd-vornr = i_vornr.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = resb_upd-vornr
        IMPORTING
          output = resb_upd-vornr.


      resb_upd-posnr = lv_posnr + 10.
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = resb_upd-posnr
        IMPORTING
          output = resb_upd-posnr.
      WAIT UP TO 1 SECONDS.
      CALL FUNCTION 'CO_BT_RESB_UPDATE'
        EXPORTING
          resb_new  = resb_upd
          tabix_old = lv_num
*         NO_DUM_UPD           = ' '
*         NO_REQ_PROCESS       = ' '
*         INS_MODE  = ' '
*         FLG_OCM   = ' '
*         I_RGEKZ_UPD          = ' '
*     IMPORTING
*         TABIX_NEW =
        .

    ENDIF.

    COMMIT WORK AND WAIT.

    WAIT UP TO 1 SECONDS.


  ENDMETHOD.
  METHOD change_compo_resb.
    DATA: lti_return    TYPE coxt_t_bapireturn,
          lti_aufnr_key TYPE TABLE OF ord_pre.

    DATA: ls_aufnr_key TYPE ord_pre,
          ls_canti     TYPE coxt_s_quantity,
          ls_cantix    TYPE coxt_s_quantityx,
          ls_material  TYPE coxt_material,
          ls_materialx TYPE coxt_materialx,
          ls_return    TYPE coxt_bapireturn,
          ls_bapret    TYPE bapiret2,
          ls_resb      TYPE resb,
          ls_resbd     TYPE resbd.

    DATA: ls_order_key   TYPE coxt_ord_key,
          ls_conf_canti  TYPE coxt_s_quantity,
          ls_conf_cantix TYPE coxt_s_quantityx,
          ls_almacen     TYPE coxt_s_storage_location,
          ls_almacenx    TYPE coxt_s_storage_locationx,
          ls_lote        TYPE coxt_batch,
          ls_lotex       TYPE coxt_batchx,
          ls_conf_obj    TYPE coxt_config_object,
          ls_conf_objx   TYPE coxt_config_objectx.

    DATA: lv_aplzl  TYPE co_aplzl,
          lv_error  TYPE c,
          lv_change TYPE flag.


* Inicializamos
    CLEAR: lv_change, ot_return.
    REFRESH ot_return.

* Sacamos los datos del componente en la base de datos
    SELECT SINGLE * INTO ls_resb
        FROM  resb
        WHERE rsnum = is_comp_key-rsnum
        AND   rspos = is_comp_key-rspos
        AND   rsart = is_comp_key-rsart.
    CHECK sy-subrc = 0.

* Si ha modificado la cantidad de la reserva --> Cargamos las
* estructuras de cantidad
    CLEAR: ls_canti, ls_cantix.
    IF is_comp_data-menge <> ls_resb-bdmng.
      ls_canti-quantity   = is_comp_data-menge.
      ls_canti-uom        = ls_resb-meins.
      ls_cantix-quantity  = 'X'.
      ls_cantix-uom       = 'X'.
*   Marcamos la modificación
      lv_change = 'X'.
    ENDIF.

* Si se ha modificado el material --> Cargamos las estructuras del
* material
    CLEAR: ls_material, ls_materialx.
    ls_material   = is_comp_data-matnr.
    IF is_comp_data-matnr <> ls_resb-matnr.
      ls_materialx  = 'X'.
*   Marcamos la modificación
      lv_change = 'X'.
    ENDIF.

* Si se ha modificado el lote --> Cargamos las estructuras del lote
    IF is_comp_data-charg <> ls_resb-charg.
      ls_lote   = is_comp_data-charg.
      ls_lotex  = 'X'.
*   Marcamos la modificación
      lv_change = 'X'.
    ENDIF.

* Chequeamos que ha habido algún cambio en el componente
    CHECK lv_change = 'X'.

* Datos del centro/almacén (son obligatorios para la función)
    CLEAR ls_almacen.
    ls_almacen-werks = ls_resb-werks.
    ls_almacen-lgort = ls_resb-lgort.


* Inicializamos las tablas internas para la función
    CALL FUNCTION 'CO_XT_ORDER_INITIALIZE'.

* Llamamos a la función que modifica el componente
    ls_order_key = i_aufnr.
    CALL FUNCTION 'CO_XT_COMPONENT_CHANGE'
      EXPORTING
        is_order_key               = ls_order_key
        is_order_component_key     = is_comp_key
        is_requirement_quantity    = ls_canti
        is_requirement_quantityx   = ls_cantix
        is_confirmed_quantity      = ls_conf_canti
        is_confirmed_quantityx     = ls_conf_cantix
        i_material                 = ls_material
        i_materialx                = ls_materialx
        is_storage_location        = ls_almacen
        is_storage_locationx       = ls_almacenx
        i_batch                    = ls_lote
        i_batchx                   = ls_lotex
        i_mi_configuration_object  = ls_conf_obj
        i_mi_configuration_objectx = ls_conf_objx
      IMPORTING
        es_bapireturn              = ls_return
        e_error_occurred           = lv_error.

* Añadimos mensajes al log
    IF ls_return-type = 'E'.
      MOVE-CORRESPONDING ls_return TO ls_bapret.
      APPEND ls_bapret TO ot_return.
      EXIT.
    ENDIF.

* Preparamos el COMMIT
    CALL FUNCTION 'CO_XT_ORDER_PREPARE_COMMIT'.

* Ejecutamos el COMMIT
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

* Si todo va bien añadimos un mensaje de éxito al log
    CLEAR ls_bapret.
    ls_bapret-type    = 'S'.
    ls_bapret-id      = '00'.
    ls_bapret-number  = '398'.
    ls_bapret-message = ls_bapret-message_v1 = 'Componente modificado con éxito'.
    APPEND ls_bapret TO ot_return.
  ENDMETHOD.
  METHOD check_lock_of.

    DATA: lv_cont        TYPE i.


    CLEAR: lv_cont, o_desbloqueo.


    WHILE ( o_desbloqueo <> 'X').

      CALL FUNCTION 'ENQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = i_aufnr
*         X_AUFNR        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
* Implement suitable error handling here
        WAIT UP TO 1 SECONDS.
        lv_cont = lv_cont + 1.

      ELSE.
        CALL FUNCTION 'DEQUEUE_ESORDER'
          EXPORTING
            mode_aufk = 'E'
            mandt     = sy-mandt
            aufnr     = i_aufnr
*           X_AUFNR   = ' '
*           _SCOPE    = '3'
*           _SYNCHRON = ' '
*           _COLLECT  = ' '
          .

        o_desbloqueo = 'X'.
        EXIT.
      ENDIF.

      IF lv_cont >= 30.
        EXIT.
*        o_desbloqueo = 'X'.
      ENDIF.

    ENDWHILE.


  ENDMETHOD.
  METHOD check_lote_inspeccion.

    CLEAR: o_werks, o_prueflos, o_estado.

    get_lote_inspeccion(
      EXPORTING
        i_aufnr     = i_aufnr
      IMPORTING
        ot_prueflos = DATA(it_prueflos)
    ).
    READ TABLE it_prueflos WITH KEY aufnr = i_aufnr INTO DATA(wa_qals).
    IF sy-subrc = 0.
      o_werks = wa_qals-werks.
      o_prueflos = wa_qals-prueflos.

      "Obtenemos las operaciones del lote de inspeccion
      SELECT * FROM qaoperation
        WHERE prueflos EQ @wa_qals-prueflos
        ORDER BY PRIMARY KEY
        INTO TABLE @DATA(it_qaop).

      "Obtenemos las operaciones notificadas
      SELECT  prueflos, vorglfnr, probenr, vcode
           FROM qapp
           WHERE prueflos EQ @wa_qals-prueflos
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(it_qapp).
      IF sy-subrc = 0.

        LOOP AT it_qaop ASSIGNING FIELD-SYMBOL(<qaop>).
          READ TABLE it_qapp TRANSPORTING NO FIELDS WITH KEY prueflos = <qaop>-prueflos vorglfnr = <qaop>-vorglfnr.
          IF sy-subrc <> 0.
            DATA(lv_faltan_operaciones) = 'X'.
          ENDIF.
        ENDLOOP.

        IF lv_faltan_operaciones IS INITIAL.

          SORT it_qapp BY prueflos vorglfnr probenr DESCENDING.
          "Con esto nos quedamos con la última notificacion
          DELETE ADJACENT DUPLICATES FROM it_qapp COMPARING prueflos vorglfnr.
          READ TABLE it_qapp TRANSPORTING NO FIELDS WITH KEY vcode = space.
          IF sy-subrc <> 0.

            DATA lv_udcode TYPE qvcode.
            LOOP AT it_qapp ASSIGNING FIELD-SYMBOL(<qapp>).
              IF lv_udcode IS INITIAL AND <qapp>-vcode EQ 'OK'.
                lv_udcode = 'OK'.
              ENDIF.
              IF ( lv_udcode IS INITIAL OR lv_udcode EQ 'OK' ) AND <qapp>-vcode EQ 'OKD'.
                lv_udcode = 'OKD'.
              ENDIF.
              IF i_sala_blanca EQ abap_true.
                IF <qapp>-vcode EQ 'NOKS'.
                  lv_udcode = 'NOKS'.
                ENDIF.
                IF <qapp>-vcode EQ 'NOOK'.
                  lv_udcode = 'NOOK'.
                  EXIT.
                ENDIF.
              ELSE.
                IF <qapp>-vcode EQ 'NOOK' OR <qapp>-vcode EQ 'NOKS'.
                  lv_udcode = 'NOOK'.
                  EXIT.
                ENDIF.
              ENDIF.

            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    o_estado = lv_udcode.

  ENDMETHOD.
  METHOD check_matnr_exists.

    CLEAR: o_return[], o_error.

    DATA lv_m1 TYPE symsgv.
    SELECT SINGLE matnr INTO @DATA(lv_matnr) FROM mara WHERE matnr EQ @i_matnr.
    IF sy-subrc <> 0.
      o_error = 'X'.
      IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
        lv_m1 = i_matnr.
        co_obj_log->guardar_mensaje(
          EXPORTING
            i_type       = 'E'
            i_id         = '00'
            i_number     = '398'
            i_message_v1 = 'El nº de material'
            i_message_v2 = lv_m1
            i_message_v3 = 'no existe'
*           i_message_v4 =
        ).
      ELSE.
        APPEND INITIAL LINE TO o_return ASSIGNING FIELD-SYMBOL(<ret>).
        <ret>-type = 'E'.
        <ret>-id = '00'.
        <ret>-number = '398'.
        <ret>-message_v1 = 'El nº de material'.
        <ret>-message_v2 = i_matnr.
        <ret>-message_v3 = 'no existe'.
        MESSAGE ID <ret>-id TYPE <ret>-type NUMBER <ret>-number
        INTO <ret>-message
        WITH <ret>-message_v1 <ret>-message_v2 <ret>-message_v3 <ret>-message_v4.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD check_matnr_of.

    FREE: o_error, ot_return.

    DATA: lv_aufnr TYPE aufnr,
          lv_matnr TYPE matnr.

    lv_aufnr = i_aufnr.
    lv_matnr = i_matnr.

    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
      EXPORTING
        input        = lv_matnr
      IMPORTING
        output       = lv_matnr
      EXCEPTIONS
        length_error = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*       WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = lv_aufnr
      IMPORTING
        output = lv_aufnr.

    SELECT SINGLE t1~aufnr, plnbez
      INTO @DATA(lv_of)
      FROM afko AS t1
      WHERE t1~aufnr EQ @lv_aufnr
      AND plnbez EQ @lv_matnr.
    IF sy-subrc <> 0.
      o_error = abap_true.
      APPEND INITIAL LINE TO ot_return ASSIGNING FIELD-SYMBOL(<error>).
      <error>-type = 'E'.
      <error>-id = '00'.
      <error>-number = 398.
      <error>-message_v1 = 'El material'.
      <error>-message_v2 = |{ i_matnr ALPHA = OUT }|.
      <error>-message_v3 = 'no coincide con el material de la orden'.
      <error>-message_v4 = |{ i_aufnr ALPHA = OUT }|.
      CONDENSE <error>-message_v1.
      CONDENSE <error>-message_v2.
      CONDENSE <error>-message_v3.
      CONDENSE <error>-message_v4.
      MESSAGE ID <error>-id TYPE <error>-type NUMBER <error>-number
      INTO <error>-message
      WITH <error>-message_v1 <error>-message_v2 <error>-message_v3 <error>-message_v4.
    ENDIF.
  ENDMETHOD.
  METHOD check_of_exist.

    CLEAR: o_return[], o_error.

    DATA lv_m1 TYPE symsgv.
    SELECT SINGLE aufnr INTO @DATA(lv_aufnr) FROM aufk WHERE aufnr EQ @i_aufnr.
    IF sy-subrc <> 0.
      o_error = 'X'.
      IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
        lv_m1 = |{ i_aufnr ALPHA = OUT }|.
        co_obj_log->guardar_mensaje(
          EXPORTING
            i_type       = 'E'
            i_id         = '00'
            i_number     = '398'
            i_message_v1 = 'El nº de orden'
            i_message_v2 = lv_m1
            i_message_v3 = 'no existe'
*           i_message_v4 =
        ).
      ELSE.
        APPEND INITIAL LINE TO o_return ASSIGNING FIELD-SYMBOL(<ret>).
        <ret>-type = 'E'.
        <ret>-id = '00'.
        <ret>-number = '398'.
        <ret>-message_v1 = 'El nº de orden'.
        <ret>-message_v2 = |{ i_aufnr ALPHA = OUT }|.
        <ret>-message_v3 = 'no existe'.
        MESSAGE ID <ret>-id TYPE <ret>-type NUMBER <ret>-number
        INTO <ret>-message
        WITH <ret>-message_v1 <ret>-message_v2 <ret>-message_v3 <ret>-message_v4.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD check_posnr_exists.


    CLEAR: o_return[], o_error.
    DATA lv_m1 TYPE symsgv.
    DATA lv_m2 TYPE symsgv.

    CLEAR: lv_m1, lv_m2.

    IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr    = i_aufnr
        IMPORTING
*         o_return   =
          o_error    = o_error
        CHANGING
          co_obj_log = co_obj_log
      ).
    ELSE.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr  = i_aufnr
        IMPORTING
          o_return = o_return
          o_error  = o_error
*      CHANGING
*         co_obj_log =
      ).
    ENDIF.
    IF o_error IS INITIAL.

      SELECT SINGLE posnr
        FROM resb
        WHERE xloek EQ @space
        AND aufnr EQ @i_aufnr
        AND posnr EQ @i_posnr
        INTO @DATA(lv_posnr).
      IF sy-subrc <> 0.
        o_error = abap_true.
        IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
          lv_m1 = |{ i_posnr ALPHA = OUT }|.
          lv_m2 = |{ i_aufnr ALPHA = OUT }|.
          co_obj_log->guardar_mensaje(
            EXPORTING
              i_type       = 'E'
              i_id         = '00'
              i_number     = '398'
              i_message_v1 = 'La operación'
              i_message_v2 = lv_m1
              i_message_v3 = 'no existe o está borrada para la orden'
              i_message_v4 = lv_m2
          ).
        ELSE.
          APPEND INITIAL LINE TO o_return ASSIGNING FIELD-SYMBOL(<ret>).
          <ret>-type = 'E'.
          <ret>-id = '00'.
          <ret>-number = '398'.
          <ret>-message_v1 = 'La posición'.
          <ret>-message_v2 = |{ i_posnr ALPHA = OUT }|.
          <ret>-message_v3 = 'no existe o está borrada para la orden'.
          <ret>-message_v4 = |{ i_aufnr ALPHA = OUT }|.
          MESSAGE ID <ret>-id TYPE <ret>-type NUMBER <ret>-number
          INTO <ret>-message
          WITH <ret>-message_v1 <ret>-message_v2 <ret>-message_v3 <ret>-message_v4.
        ENDIF.

      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD check_vornr_exists.

    CLEAR: o_return[], o_error.
    DATA lv_m1 TYPE symsgv.
    DATA lv_m2 TYPE symsgv.

    CLEAR: lv_m1, lv_m2.

    IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr    = i_aufnr
        IMPORTING
*         o_return   =
          o_error    = o_error
        CHANGING
          co_obj_log = co_obj_log
      ).
    ELSE.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr  = i_aufnr
        IMPORTING
          o_return = o_return
          o_error  = o_error
*      CHANGING
*         co_obj_log =
      ).
    ENDIF.
    IF o_error IS NOT INITIAL.

      SELECT SINGLE t1~vornr
        FROM afvc AS t1 INNER JOIN afko AS t2 ON t1~aufpl EQ t2~aufpl
        WHERE t1~loekz EQ @space
        INTO @DATA(lv_vornr).
      IF sy-subrc <> 0.
        o_error = abap_true.
        IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
          lv_m1 = |{ vornr ALPHA = OUT }|.
          lv_m2 = |{ i_aufnr ALPHA = OUT }|.
          co_obj_log->guardar_mensaje(
            EXPORTING
              i_type       = 'E'
              i_id         = '00'
              i_number     = '398'
              i_message_v1 = 'La operación'
              i_message_v2 = lv_m1
              i_message_v3 = 'no existe o está borrada para la orden'
              i_message_v4 = lv_m2
          ).
        ELSE.
          APPEND INITIAL LINE TO o_return ASSIGNING FIELD-SYMBOL(<ret>).
          <ret>-type = 'E'.
          <ret>-id = '00'.
          <ret>-number = '398'.
          <ret>-message_v1 = 'La operación'.
          <ret>-message_v2 = |{ vornr ALPHA = OUT }|.
          <ret>-message_v3 = 'no existe o está borrada para la orden'.
          <ret>-message_v4 = |{ i_aufnr ALPHA = OUT }|.
          MESSAGE ID <ret>-id TYPE <ret>-type NUMBER <ret>-number
          INTO <ret>-message
          WITH <ret>-message_v1 <ret>-message_v2 <ret>-message_v3 <ret>-message_v4.
        ENDIF.

      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD determina_fecha_fin.

    o_fecha = i_fecha_fin.

    SELECT SINGLE fabkl INTO @DATA(calendar) FROM t001w WHERE werks = @i_werks.


    CALL FUNCTION 'DATE_CONVERT_TO_FACTORYDATE'
      EXPORTING
        correct_option               = '+'
        date                         = o_fecha
        factory_calendar_id          = calendar
      IMPORTING
        date                         = o_fecha
*       factorydate                  =
*       workingday_indicator         =
      EXCEPTIONS
        calendar_buffer_not_loadable = 1
        correct_option_invalid       = 2
        date_after_range             = 3
        date_before_range            = 4
        date_invalid                 = 5
        factory_calendar_not_found   = 6
        OTHERS                       = 7.
    IF sy-subrc <> 0.
* MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.
  METHOD determina_fecha_fin_sichz.

    SELECT SINGLE sichz, werks
      FROM caufv
      WHERE aufnr = @i_aufnr
      INTO ( @DATA(lv_sichz), @DATA(lv_werks) ).

    SELECT SINGLE fabkl INTO @DATA(calendar) FROM t001w WHERE werks = @lv_werks.

    DATA lv_fkday TYPE mdcal-fkday.
    lv_fkday = lv_sichz.

    CALL FUNCTION 'WDKAL_DATE_ADD_FKDAYS'
      EXPORTING
        i_date  = i_fecha_fin
        i_fkday = lv_fkday
        i_fabkl = calendar
      IMPORTING
        e_date  = o_fecha
*       e_fkday =
      EXCEPTIONS
        error   = 1
        OTHERS  = 2.
    IF sy-subrc <> 0.
* MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

*    o_fecha = i_fecha_fin + lv_sichz.
*
*    determina_fecha_fin(
*      EXPORTING
*        i_fecha_fin = o_fecha
*        i_werks     = lv_werks
*      RECEIVING
*        o_fecha     = o_fecha
*    ).
*

  ENDMETHOD.
  METHOD get_asp_puesto.

    IF i_werks IS NOT INITIAL.
      SELECT SINGLE prvbe INTO o_prvbe FROM crhd WHERE arbpl EQ i_arbpl AND werks EQ i_werks.
    ELSE.
      SELECT SINGLE prvbe INTO o_prvbe FROM crhd WHERE arbpl EQ i_arbpl.
    ENDIF.

  ENDMETHOD.
  METHOD get_batch_of.

    FREE: o_charg, o_error, ot_return.

    check_of_exist(
      EXPORTING
        i_aufnr  = i_aufnr
      IMPORTING
        o_return = ot_return
        o_error  = o_error
*      CHANGING
*       co_obj_log =
    ).

    IF o_error IS NOT INITIAL.
      RETURN.
    ENDIF.

    SELECT SINGLE charg INTO o_charg FROM afpo WHERE aufnr EQ i_aufnr.
    IF sy-subrc = 0 AND o_charg IS INITIAL.
      o_error = abap_true.
      APPEND INITIAL LINE TO ot_return ASSIGNING FIELD-SYMBOL(<error>).
      <error>-type = 'E'.
      <error>-number = 398.
      <error>-id = '00'.
      <error>-message = <error>-message_v1 = |No existe lote a nivel de OF { i_aufnr ALPHA = OUT }.|.
    ENDIF.

  ENDMETHOD.
  METHOD get_centro_of.
    CLEAR o_werks.
    SELECT SINGLE werks INTO o_werks FROM aufk WHERE aufnr EQ i_aufnr.
  ENDMETHOD.
  METHOD get_lgnum_of_werks.
    CLEAR o_lgnum.

    SELECT SINGLE lgnum FROM t320 WHERE werks = @i_werks AND lgort = @i_lgort INTO @o_lgnum.

  ENDMETHOD.
  METHOD get_lote_inspeccion.

    FREE ot_prueflos.

    SELECT aufnr,  prueflos, werk AS werks
    FROM qals INNER JOIN jest ON qals~objnr EQ jest~objnr
               WHERE aufnr EQ @i_aufnr
               AND NOT EXISTS ( SELECT objnr FROM jest AS t3 WHERE ( t3~stat EQ 'I0224' AND t3~inact EQ @space
                                                                OR ( t3~stat EQ 'I0043' AND t3~inact EQ @space ) )
                                                                AND t3~objnr EQ jest~objnr )
               INTO TABLE @ot_prueflos.

    SORT ot_prueflos BY aufnr prueflos werks ASCENDING.
    DELETE ADJACENT DUPLICATES FROM ot_prueflos COMPARING ALL FIELDS.

  ENDMETHOD.
  METHOD get_lote_tinta.

    FREE o_charg.

    DATA(lv_fecha) = sy-datum.

    IF i_lifo_date IS NOT INITIAL.
      lv_fecha = i_lifo_date.
    ENDIF.

    SELECT t1~matnr, t1~werks, t1~lgort, clabs, t1~charg, lwedt
      FROM mchb AS t1 INNER JOIN mch1 AS t2
      ON t1~matnr = t2~matnr AND t1~charg EQ t2~charg
      WHERE t1~matnr = @i_matnr
      AND t1~lgort = @i_lgort
      AND t1~werks = @i_werks
      AND clabs > 0
      INTO TABLE @DATA(it_lotes).

    DATA lv_cant_neces TYPE menge_d.
    lv_cant_neces = i_clabs.

    LOOP AT it_lotes ASSIGNING FIELD-SYMBOL(<f>).

      APPEND INITIAL LINE TO o_charg ASSIGNING FIELD-SYMBOL(<flote>).
      IF <f>-clabs >= lv_cant_neces.
        <flote>-charg = <f>-charg.
        <flote>-matnr = <f>-matnr.
        <flote>-lgort = <f>-lgort.
        <flote>-werks = <f>-werks.
        <flote>-clabs = lv_cant_neces.
        lv_cant_neces = 0.
        EXIT.
      ELSE.
        <flote>-charg = <f>-charg.
        <flote>-matnr = <f>-matnr.
        <flote>-lgort = <f>-lgort.
        <flote>-werks = <f>-werks.
        <flote>-clabs = <f>-clabs.
        lv_cant_neces = lv_cant_neces - <f>-clabs.
      ENDIF.

    ENDLOOP.

    IF lv_cant_neces > 0.
      APPEND INITIAL LINE TO o_charg ASSIGNING <flote>.

      <flote>-charg = 'NONSTOCK'.
      <flote>-matnr = i_matnr.
      <flote>-lgort = i_lgort.
      <flote>-werks = i_werks.
      <flote>-clabs = lv_cant_neces.

    ENDIF.


  ENDMETHOD.
  METHOD get_of_status.

    FREE: ot_status, ot_return.

    IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr    = i_aufnr
        IMPORTING
          o_return   = DATA(lt_return)
          o_error    = DATA(lv_err)
        CHANGING
          co_obj_log = co_obj_log
      ).
    ELSE.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr  = i_aufnr
        IMPORTING
          o_return = lt_return
          o_error  = lv_err
*      CHANGING
*         co_obj_log = co_obj_log
      ).

      APPEND LINES OF lt_return TO ot_return.
    ENDIF.
    IF lv_err IS NOT INITIAL.
      RETURN.
    ENDIF.

    SELECT t1~istat, t1~spras, t1~txt04, t1~txt30
      FROM tj02t AS t1 INNER JOIN jest AS t2 ON t1~istat EQ t2~stat
      INNER JOIN aufk AS t3 ON t2~objnr EQ t3~objnr
      WHERE t2~inact EQ @space
      AND t1~spras EQ @sy-langu
      AND aufnr EQ @i_aufnr
      INTO TABLE @ot_status.

  ENDMETHOD.
  METHOD get_of_user_status.

    CLEAR: ot_status[], ot_return[].

    IF co_obj_log IS SUPPLIED AND co_obj_log IS NOT INITIAL.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr    = i_aufnr
        IMPORTING
          o_return   = DATA(lt_return)
          o_error    = DATA(lv_err)
        CHANGING
          co_obj_log = co_obj_log
      ).
    ELSE.
      zspp_utils=>check_of_exist(
        EXPORTING
          i_aufnr  = i_aufnr
        IMPORTING
          o_return = lt_return
          o_error  = lv_err
*      CHANGING
*         co_obj_log = co_obj_log
      ).

      APPEND LINES OF lt_return TO ot_return.
    ENDIF.
    IF lv_err IS NOT INITIAL.
      RETURN.
    ENDIF.

    SELECT t1~stsma, t1~estat, t1~spras, t1~txt04, t1~txt30, t1~ltext
      FROM tj30t AS t1 INNER JOIN jest AS t2 ON t1~estat EQ t2~stat
      INNER JOIN aufk AS t3 ON t2~objnr EQ t3~objnr

      WHERE t2~inact EQ @space
      AND t1~spras EQ @sy-langu
      INTO TABLE @ot_status.


  ENDMETHOD.
  METHOD get_ofs_grafo.

    FREE o_tt_aufnr.

    APPEND INITIAL LINE TO o_tt_aufnr ASSIGNING FIELD-SYMBOL(<a>).
    <a> = i_aufnr.

    SELECT SINGLE prodnet FROM caufv WHERE aufnr = @i_aufnr INTO @DATA(lv_es_grafo).
    IF lv_es_grafo = abap_true.

      "si es hijo, recuperamos los hermanos y el padre
      SELECT SINGLE maufnr
        FROM caufv
        WHERE aufnr = @i_aufnr
        AND maufnr <> @space
        INTO @DATA(lv_padre).
      IF sy-subrc = 0.
        APPEND INITIAL LINE TO o_tt_aufnr ASSIGNING <a>.
        <a> = lv_padre.
      ENDIF.

      "Si es la OF padre, recuperamos los hijos
      SELECT aufnr
        FROM caufv
        WHERE ( maufnr = @i_aufnr OR maufnr = @lv_padre ) AND maufnr <> @space
        APPENDING TABLE @o_tt_aufnr.

    ENDIF.

    SORT o_tt_aufnr ASCENDING.
    DELETE ADJACENT DUPLICATES FROM o_tt_aufnr.


  ENDMETHOD.
  METHOD get_puesto_trabajo.
    DATA: l_vornr TYPE vornr.

    CLEAR o_arbpl.
    IF i_vornr IS INITIAL.
      IF i_ktsch IS INITIAL.
        SELECT crhd~arbpl vornr FROM afko
        INNER JOIN afvc ON afvc~aufpl = afko~aufpl
        INNER JOIN crhd ON crhd~objid = afvc~arbid
        INTO (o_arbpl, l_vornr)
        UP TO 1 ROWS
        WHERE afko~aufnr = i_aufnr
        AND crhd~objty = 'A'
        ORDER BY vornr arbpl.
        ENDSELECT.
      ELSE.
        SELECT crhd~arbpl vornr FROM afko
        INNER JOIN afvc ON afvc~aufpl = afko~aufpl
        INNER JOIN crhd ON crhd~objid = afvc~arbid
        INTO (o_arbpl, l_vornr)
        UP TO 1 ROWS
        WHERE afko~aufnr = i_aufnr
        AND afvc~ktsch = i_ktsch
        AND crhd~objty = 'A'
        ORDER BY vornr arbpl.
        ENDSELECT.
      ENDIF.
    ELSE.
      SELECT crhd~arbpl vornr FROM afko
      INNER JOIN afvc ON afvc~aufpl = afko~aufpl
      INNER JOIN crhd ON crhd~objid = afvc~arbid
      INTO (o_arbpl, l_vornr)
      UP TO 1 ROWS
      WHERE afko~aufnr = i_aufnr
      AND afvc~vornr = i_vornr
      AND crhd~objty = 'A'
      ORDER BY vornr arbpl.
      ENDSELECT.
    ENDIF.

  ENDMETHOD.
  METHOD get_release_date.

    CLEAR o_ftrmi.

    SELECT SINGLE ftrmi FROM caufv WHERE aufnr = @i_aufnr INTO @o_ftrmi.

  ENDMETHOD.
  METHOD get_tinta.

    CLEAR or_es_tinta.

    SELECT SINGLE matnr, matkl
      INTO @DATA(var1)
      FROM mara
      WHERE matnr EQ @i_matnr
      AND matkl BETWEEN '35000' AND '38630'.
    IF sy-subrc = 0.
      or_es_tinta = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD get_ubicacion_asp.

*    IF i_lgnum IS NOT INITIAL.
*
*      SELECT SINGLE lgpla INTO o_lgpla FROM /scwm/tpsastage WHERE psa EQ i_prvbe AND lgnum EQ i_lgnum.
*      IF sy-subrc <> 0.
*        DATA(lv_asp) = 'X'.
*      ENDIF.
*    ELSE.
*      DATA(lv_asp) = 'X'.
*    ENDIF.
*
*    IF lv_asp IS NOT INITIAL.

    SELECT SINGLE lgpla INTO o_lgpla
    FROM pkhd
    WHERE prvbe EQ i_prvbe
      AND werks EQ i_werks.
    IF sy-subrc <> 0.
      SELECT SINGLE lgpla INTO o_lgpla
            FROM pkhd
            WHERE prvbe EQ i_prvbe.
    ENDIF.

*    ENDIF.
  ENDMETHOD.
  METHOD lock_of.


    CLEAR: o_bloqueada_con_exito, o_ya_bloqueada.

    CALL FUNCTION 'ENQUEUE_ESORDER'
      EXPORTING
        mode_aufk      = 'E'
        mandt          = sy-mandt
        aufnr          = i_aufnr
*       X_AUFNR        = ' '
*       _SCOPE         = '2'
*       _WAIT          = ' '
*       _COLLECT       = ' '
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      o_ya_bloqueada = abap_true.
    ELSE.
      o_bloqueada_con_exito = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD unlock_of.

    CLEAR: o_desbloqueada_con_exito, o_ya_bloqueada.

    TRY.
        CALL FUNCTION 'DDEQUEUE_ESORDER'
          EXPORTING
            mode_aufk = 'E'
            mandt     = sy-mandt
            aufnr     = i_aufnr
*           X_AUFNR   = ' '
*           _SCOPE    = '3'
*           _SYNCHRON = ' '
*           _COLLECT  = ' '
          .
        o_desbloqueada_con_exito = abap_true.
      CATCH cx_root.
        o_ya_bloqueada = abap_true.
    ENDTRY.

  ENDMETHOD.
