
CLASS zclpp_creacion_ofs DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_ofs_pend,
        icon_estat        TYPE icon_d,
        icon_bob_part_max TYPE icon_d,
        werks             TYPE werks_d,
        aufnr             TYPE aufnr,
        matnr             TYPE matnr,
        maktx             TYPE maktx,
        kg_plan_bobi      TYPE z_cantidad_sin_dec,
        meins_plan_bobi   TYPE meins,
        fecha_fab         TYPE datum,
        matkl             TYPE matkl,
        gramaje           TYPE zgramaje,
        ancho_bob         TYPE zancho,
        kunnr             TYPE kunnr,
        desc_cli          TYPE char30,
        vbeln             TYPE vbeln,
        posnr             TYPE posnr,
        etenr             TYPE etenr,
        fecha_ent         TYPE datum,
        meins_plan_rol    TYPE meins,
        aufnr_rol         TYPE aufnr,
        matnr_rol         TYPE matnr,
        maktx_rol         TYPE maktx,
        ancho_rol         TYPE zancho,
        kg_plan_rol       TYPE z_cantidad_sin_dec,
        meins_fab_bobi    TYPE meins,
        kg_fabr_bobi      TYPE z_cantidad_sin_dec,
        kg_fab_rol        TYPE z_cantidad_sin_dec,
        meins_fab_rol     TYPE meins,
      END OF ty_ofs_pend .
    TYPES:
      tty_ofs_pend TYPE STANDARD TABLE OF ty_ofs_pend .
**  types:
**    BEGIN OF ty_repartos_sin_of,
**        werks      TYPE werks_d,
**        kunnr      TYPE kunnr,
**        desc_cli   TYPE char30,
**        vbeln      TYPE vbeln,
**        posnr      TYPE posnr,
**        etenr      TYPE etenr,
**        tp_pedido  TYPE ztp_pedido,
**        matnr      TYPE matnr,
**        maktx      TYPE maktx,
**        matkl      TYPE matkl,
**        ancho      TYPE zancho,
**        gramaje    TYPE zgramaje,
**        menge      TYPE z_cantidad_sin_dec,
**        meins      TYPE meins,
**        fecha_ent  TYPE datum,
**        cant_pend  TYPE z_cantidad_sin_dec,
**        meins_pend TYPE meins,
**        aufnr      TYPE aufnr,
**        semana     TYPE kweek,
**      END OF ty_repartos_sin_of .
    TYPES:
      BEGIN OF ty_repartos_sin_of,
        tp_pedido  TYPE ztp_pedido,
        vbeln      TYPE vbeln,
        posnr      TYPE posnr,
        etenr      TYPE etenr,
        kunnr      TYPE kunnr,
        desc_cli   TYPE char30,
        matnr      TYPE matnr,
        maktx      TYPE maktx,
        matkl      TYPE matkl,
        gramaje    TYPE zgramaje,
        ancho      TYPE zancho,
        menge      TYPE z_cantidad_sin_dec,
        meins      TYPE meins,
        fecha_ent  TYPE datum,
        cant_pend  TYPE z_cantidad_sin_dec,
        meins_pend TYPE meins,
        werks      TYPE werks_d,
        aufnr      TYPE aufnr,
        semana     TYPE kweek,
      END OF ty_repartos_sin_of .

    TYPES:
      tty_repartos_sin_of     TYPE STANDARD TABLE OF ty_repartos_sin_of .
    TYPES:
      BEGIN OF ty_repart_abie,
        werks        TYPE werks_d,
        vbeln        TYPE vbeln,
        posnr        TYPE posnr,
        etenr        TYPE etenr,
        tp_pedido    TYPE ztp_pedido,
        menge_ped    TYPE z_cantidad_sin_dec,
        meins_ped    TYPE meins,
        menge_pte    TYPE z_cantidad_sin_dec,
        meins_pte    TYPE meins,
        fecha_ent    TYPE datum,
        aufnr_bob    TYPE aufnr,
        menge_teo    TYPE z_cantidad_sin_dec,
        meins_teo    TYPE meins,
        menge_fab    TYPE z_cantidad_sin_dec,
        meins_fab    TYPE meins,
        menge_pte_of TYPE z_cantidad_sin_dec,
        meins_pte_of TYPE meins,

      END OF ty_repart_abie .
    TYPES:
      tty_repart_abie TYPE STANDARD TABLE OF ty_repart_abie .
    TYPES:
      BEGIN OF ty_stock,
        kunnr     TYPE kunnr,
        desc_cli  TYPE char30,
        matnr     TYPE matnr,
        maktx     TYPE maktx,
        menge_a   TYPE z_cantidad_sin_dec,
        meins_a   TYPE meins,
        menge_r   TYPE z_cantidad_sin_dec,
        meins_r   TYPE meins,
        menge_sin TYPE z_cantidad_sin_dec,
        meins_sin TYPE meins,
        menge_p   TYPE z_cantidad_sin_dec,
        meins_p   TYPE meins,
      END OF ty_stock .
    TYPES:
      tty_stock TYPE STANDARD TABLE OF ty_stock .
    TYPES:
      BEGIN OF ty_stock_col,
        kunnr     TYPE kunnr,
        desc_cli  TYPE char30,
        matnr     TYPE matnr,
        maktx     TYPE maktx,
        menge_a   TYPE z_cantidad_sin_dec,
        meins_a   TYPE meins,
        menge_r   TYPE z_cantidad_sin_dec,
        meins_r   TYPE meins,
        menge_sin TYPE z_cantidad_sin_dec,
        meins_sin TYPE meins,
        menge_p   TYPE z_cantidad_sin_dec,
        meins_p   TYPE meins,
        t_color   TYPE lvc_t_scol,
      END OF ty_stock_col .
    TYPES:
      tty_stock_col TYPE STANDARD TABLE OF ty_stock_col .
    TYPES:
      ttyr_kunnr TYPE RANGE OF kunnr .
    TYPES:
      ttyr_matnr TYPE RANGE OF matnr .
    TYPES:
      ttyr_matkl TYPE RANGE OF matkl .
    TYPES:
      BEGIN OF ty_caract_lote,
        kunnr     TYPE kunnr,
        vbeln     TYPE vbeln,
        posnr     TYPE posnr,
        de        TYPE char3,
        lgort     TYPE lgort_d,
        fecha_fab TYPE datum,
*        long_bobina
      END OF ty_caract_lote .
    TYPES:
      tty_caract_lote TYPE STANDARD TABLE OF ty_caract_lote .
    TYPES:
      BEGIN OF ty_reparto_selec,
        werks      TYPE werks_d,
        kunnr      TYPE kunnr,
        desc_cli   TYPE char30,
        vbeln      TYPE vbeln,
        posnr      TYPE posnr,
        etenr      TYPE etenr,
        menge      TYPE z_cantidad_sin_dec,
        meins      TYPE meins,
        ancho      TYPE zancho,
        menge_of   TYPE z_cantidad_sin_dec,
        tp_pedido  TYPE ztp_pedido,
        matnr      TYPE matnr,
        maktx      TYPE maktx,
        matkl      TYPE matkl,
        gramaje    TYPE zgramaje,
        fecha_ent  TYPE datum,
        cant_pend  TYPE z_cantidad_sin_dec,
        meins_pend TYPE meins,
        aufnr      TYPE aufnr,
        semana     TYPE kweek,
      END OF ty_reparto_selec .
    TYPES:
      tty_reparto_selec     TYPE STANDARD TABLE OF ty_reparto_selec .
    TYPES:
      BEGIN OF ty_key_data_of,
        werks         TYPE werks_d,
        order_type    TYPE aufart,
        fecha_fin_fab TYPE datum,
        menge         TYPE menge_d,
        meins         TYPE meins,
        matnr         TYPE matnr,
        kunnr         TYPE kunnr,
        vbeln         TYPE vbeln,
        posnr         TYPE posnr,
        etenr         TYPE etenr,
        fec_entrega   TYPE datum,
        zzaufnr_rollo TYPE zzaufnr_rollo1, "para bobinas y cabos
        kunnr2        TYPE kunnr,
        vbeln2        TYPE vbeln,
        posnr2        TYPE posnr,
        etenr2        TYPE etenr,
        fec_entrega2  TYPE datum,
        kunnr3        TYPE kunnr,
        vbeln3        TYPE vbeln,
        posnr3        TYPE posnr,
        etenr3        TYPE etenr,
        fec_entrega3  TYPE datum,
        aufnr         TYPE aufnr,
        aufnr_rollo   TYPE aufnr,
        rc            TYPE char2,
        zrollos       TYPE zzrollos1,
        ztornadas     TYPE zztor1,
        bob_partida   TYPE numc2, " se añade el campo de BOBINA PARTIDA para actualizar el campo AUFK-ZZSECUENCIA
        s_msg         TYPE bapiret2,
      END OF ty_key_data_of .
    TYPES:
      tty_key_data_of     TYPE STANDARD TABLE OF ty_key_data_of .
    TYPES:
      BEGIN OF ty_datos_ofs_bob_rollo,
        werks           TYPE werks_d,
        aufnr_bobi      TYPE aufnr,
        kg_plan_bobi    TYPE z_cantidad_sin_dec,
        kg_fabr_bobi    TYPE z_cantidad_sin_dec,
        f_fin_fab_bobi  TYPE datum,
        aufnr_rollo     TYPE aufnr,
        kg_plan_rollo   TYPE z_cantidad_sin_dec,
        kg_fabr_rollo   TYPE z_cantidad_sin_dec,
        f_fin_fab_rollo TYPE datum,
      END OF ty_datos_ofs_bob_rollo .
    TYPES:
      tty_datos_ofs_bob_rollo     TYPE STANDARD TABLE OF ty_datos_ofs_bob_rollo .

    DATA gc_ancho_trim TYPE zancho .
    DATA gc_ancho_max TYPE zancho .
    DATA gc_ancho_min TYPE zancho .
    DATA gr_capac_asig TYPE REF TO zclpp_capacidad_asignada .
    DATA gt_ofs_pend TYPE tty_ofs_pend .
    DATA gt_repartos_sin_of TYPE tty_repartos_sin_of .
    DATA g_fabneta_kg_bobinas TYPE z_cantidad_sin_dec .
    DATA g_fabneta_kg_cabos TYPE z_cantidad_sin_dec .
    DATA g_fabneta_porc_bobinas TYPE i .
    DATA g_fabneta_kg_bobinas_normaliz TYPE z_cantidad_sin_dec .

    METHODS constructor
      IMPORTING
        !i_werks              TYPE werks_d OPTIONAL
        !i_mjahr              TYPE mjahr OPTIONAL
        !i_semana             TYPE numc2 OPTIONAL
        !i_sw_no_act_sin_asig TYPE flag OPTIONAL
        !or_semana            TYPE REF TO zclpp_creacion_ofs OPTIONAL
        !o_rc                 TYPE char2 OPTIONAL .
    CLASS-METHODS instanciar_semana
      IMPORTING
        !i_werks      TYPE werks_d
        !i_mjahr      TYPE mjahr
        !i_semana     TYPE numc2
        !i_begda      TYPE datum OPTIONAL
        !i_endda      TYPE datum OPTIONAL
      EXPORTING
        !or_semana_of TYPE REF TO zclpp_creacion_ofs
        !o_rc         TYPE char2 .
    CLASS-METHODS navegar_semana
      IMPORTING
        !i_tp_cambio  TYPE char1
      EXPORTING
        !o_rc         TYPE char02
      CHANGING
        !cr_semana    TYPE REF TO zclpp_capacidad_asignada
        !cr_semana_of TYPE REF TO zclpp_creacion_ofs .
    CLASS-METHODS get_fecha_fabricacion_of
      IMPORTING
        !i_fecha_entrega   TYPE datum OPTIONAL
        !i_fecha_actual    TYPE datum OPTIONAL
      RETURNING
        VALUE(r_fecha_fab) TYPE datum .
    CLASS-METHODS crear_of
      IMPORTING
        !i_rollo_list_mat  TYPE matnr OPTIONAL
      CHANGING
        !cs_datos_creacion TYPE ty_key_data_of .
    CLASS-METHODS get_stock_x_cliente
      IMPORTING
        !i_werks  TYPE werks_d
        !i_matnr  TYPE matnr OPTIONAL
        !ir_matnr TYPE ttyr_matnr OPTIONAL
        !i_kunnr  TYPE kunnr OPTIONAL
        !ir_kunnr TYPE ttyr_kunnr OPTIONAL
        !ir_matkl TYPE ttyr_matkl OPTIONAL
      EXPORTING
        !os_stock TYPE ty_stock
        !ot_stock TYPE tty_stock_col .
    CLASS-METHODS obtener_caract_lote
      IMPORTING
        !i_matnr   TYPE matnr
        !i_charg   TYPE charg_d
      EXPORTING
        !os_caract TYPE ty_caract_lote .
    CLASS-METHODS get_pedidos_abiertos
      IMPORTING
        !i_werks              TYPE werks_d
        !i_kunnr              TYPE kunnr
        !i_matnr              TYPE matnr
      EXPORTING
        !ot_repartos_abiertos TYPE tty_repart_abie .
    METHODS get_datos_ini_creacion_of
      EXPORTING
        !ot_stock             TYPE tty_stock
        !ot_repartos_abiertos TYPE tty_repart_abie
        !o_fecha_fabr_final   TYPE datum
        !o_cantidad           TYPE z_cantidad_sin_dec
        !o_kg_totales         TYPE z_cantidad_sin_dec
        !o_ancho_total        TYPE zancho
        !o_rc                 TYPE char2
      CHANGING
        !ct_repartos          TYPE tty_reparto_selec .
    METHODS check_datos_creacion_ok
      IMPORTING
        !i_ancho_cabo       TYPE zancho
        !i_num_bobinas      TYPE numc2
      EXPORTING
        !o_kg_cabo          TYPE z_cantidad_sin_dec
        !o_kg_totales       TYPE z_cantidad_sin_dec
        !o_ancho_total      TYPE zancho
        !o_rc               TYPE char2
      CHANGING
        !c_fecha_fabr_final TYPE datum
        !c_cantidad         TYPE z_cantidad_sin_dec
        !ct_repartos        TYPE tty_reparto_selec .
    METHODS procesar_datos_creacion_of
      EXPORTING
        !o_rc TYPE char2 .
    CLASS-METHODS check_anulacion_ofs
      IMPORTING
        !it_ofs_pend_selec TYPE tty_ofs_pend
      EXPORTING
        !o_rc              TYPE char2 .
    CLASS-METHODS anulacion_ofs
      IMPORTING
        !it_ofs_pend_selec TYPE tty_ofs_pend
      EXPORTING
        !o_rc              TYPE char2
        !o_of_error        TYPE aufnr .
    METHODS refrescar_tablas_alvs
      IMPORTING
        !i_flag  TYPE flag OPTIONAL
        !i_werks TYPE werks_d OPTIONAL .
    CLASS-METHODS replanificar_of
      IMPORTING
        !it_ofs_pend_selec TYPE tty_ofs_pend
        !i_datum           TYPE datum
      EXPORTING
        !o_rc              TYPE char2 .
    METHODS avisos_fecha_fabricacion_of
      RETURNING
        VALUE(r_answer) TYPE char1 .
    METHODS calcular_ancho_maximo
      IMPORTING
        !i_num_bobinas          TYPE numc2
      RETURNING
        VALUE(r_ancho_max_cabo) TYPE zancho .
    CLASS-METHODS cambiar_rollo_lista_mat_bobina
      IMPORTING
        !i_of          TYPE aufnr
        !i_menge       TYPE menge_d
        !i_matnr_rollo TYPE matnr
      EXPORTING
        !o_rc          TYPE char2
        !os_ret        TYPE bapiret2 .
protected section.
private section.

  data GT_REPARTOS_SELEC type TTY_REPARTO_SELEC .
  class-data GC_DIAS_MENOS_FENTREGA type NUMC3 value 7 ##NO_TEXT.
  class-data GC_DIAS_MAS_FECHA_ACTUAL type NUMC3 value 3 ##NO_TEXT.
  data GS_DATOS_OF_ROLLO type TY_KEY_DATA_OF .
  data GS_DATOS_OF_CABO type TY_KEY_DATA_OF .
  data GT_DATOS_OF_REP_SELEC type TTY_KEY_DATA_OF .

  methods VALIDACION_INICIAL_DATOS_OF
    exporting
      !O_CANTIDAD type Z_CANTIDAD_SIN_DEC
      !O_RC type CHAR2 .
  methods GET_KG_REDONDEADOS_OF
    importing
      !I_ANCHO_CABO type ZANCHO
      !I_NUM_BOBINAS type NUMC2 optional
    exporting
      !O_KG_CABO type Z_CANTIDAD_SIN_DEC
      !O_KG_TOTALES type Z_CANTIDAD_SIN_DEC
    changing
      !C_CANTIDAD_OFS type Z_CANTIDAD_SIN_DEC .
  class-methods GET_MATNR_ROLLO
    importing
      !I_GRAMAJE type ZGRAMAJE
      !I_ANCHO type ZANCHO
      !I_MATKL type MATKL
    exporting
      !O_MATNR type MATNR .
  class-methods GET_MATNR_CABO
    importing
      !I_GRAMAJE type ZGRAMAJE
      !I_ANCHO type ZANCHO
      !I_MATKL type MATKL
    exporting
      !O_MATNR type MATNR .
  class-methods CONTROL_ERRORES_CREACION_OF
    importing
      !IS_DATOS_OF type TY_KEY_DATA_OF
      !I_TXT_TP_OF type CHAR10
    changing
      !CT_MSG_ERR type ESP1_MESSAGE_TAB_TYPE .
  class-methods GET_NEW_ID_PEDIDO_CABO
    returning
      value(R_VBELN) type VBELN .
  class-methods GET_NUMERO_ROLLOS
    importing
      !I_WERKS type WERKS_D
      !I_KG type Z_CANTIDAD_SIN_DEC
    exporting
      !O_ROLLOS type ZZROLLOS
      !O_TORNADAS type ZTORNADA .
  class-methods POPUP_MSG_CREACION_OFS
    importing
      !IT_MSG type ESP1_MESSAGE_TAB_TYPE
      !I_FORZAR_POPUP type FLAG optional
    returning
      value(R_RC_ERROR) type FLAG .
  class-methods ESPERA_HASTA_CREACION_OF
    importing
      !I_AUFNR type AUFNR .
  methods GET_OF_SEMANA_SELEC_COOISPI
    importing
      !IR_AUFNR type PSHLP_RANGE_T_AUFNR optional .
  class-methods CHECK_COSTES_MATERIAL
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
    returning
      value(R_RC) type CHAR2 .
  class-methods VALIDAR_ANCHO_5MM
    importing
      !I_ANCHO_IN type ZANCHO
    returning
      value(O_ANCHO_CALC) type ZANCHO .
  class-methods VALIDAR_LISTA_MATERIALES_BOM
    importing
      !I_CANTIDAD type Z_CANTIDAD_SIN_DEC
      !I_MATNR type MATNR
      !I_WERKS type WERKS_D
    exporting
      !O_RC type CHAR02 .
  class-methods DETERMINAR_SI_5MM
    importing
      !IV_ANCH_BOB type ZANCHO
    exporting
      !EV_ANCHO_5MM type ZANCHO .
  methods GET_OFS_ABIERTAS_FECHA
    importing
      !IR_AUFNR type PSHLP_RANGE_T_AUFNR optional
      !I_WERKS type WERKS_D .
endclass. "ZCLPP_CREACION_OFS definition
class ZCLPP_CREACION_OFS implementation.
*
* •	Fecha final de fabricación -> Será la fecha final de fabricación en la OF.
* Se informará la fecha final de fabricación como la fecha de entrega menos 7 días.
* Si la fecha de fabricación se sitúa en el pasado, tomar la fecha actual + 3 días. Editable.
*

  METHOD get_fecha_fabricacion_of.


    r_fecha_fab = i_fecha_entrega - gc_dias_menos_fentrega.

    IF r_fecha_fab < i_fecha_actual.
      r_fecha_fab = i_fecha_actual + gc_dias_mas_fecha_actual.
    ENDIF.

  ENDMETHOD.
******************************************************
* 29/10/2020 CMS
* A partir de los datos de entrada: cantidad OFs y el ancho del cabo
*
* Se calcula:
*  1. A partir de la cantidad de entrada se reparte y redondea en millares los kg.OF de cada reparto
*  2. Si se informa el ancho de cabo, se calculan sus kg. en proporción a la cantidad de entrada
******************************************************
  METHOD get_kg_redondeados_of.

    DATA: l_ancho_total  TYPE zancho,
          l_menge        TYPE menge_d,
          l_resto        TYPE menge_d,
          l_medio        TYPE menge_d,
          l_cantidad_old TYPE menge_d.

    l_cantidad_old = c_cantidad_ofs.
    CLEAR: c_cantidad_ofs , o_kg_cabo.

    l_medio = 1 / 2.

* Suma de anchos seleccionados.
    LOOP AT gt_repartos_selec ASSIGNING FIELD-SYMBOL(<fs_rep>).
      l_ancho_total = l_ancho_total + <fs_rep>-ancho.
    ENDLOOP.

* Segun la cantidad de entrada, se reparte según ancho a cada reparto seleccionado.
    LOOP AT gt_repartos_selec ASSIGNING <fs_rep>.

      l_menge = ( <fs_rep>-ancho * l_cantidad_old ) / l_ancho_total.
      l_menge = l_menge / 1000.
      l_resto = frac( l_menge ).
      IF l_resto < l_medio.
        <fs_rep>-menge_of = trunc( l_menge ) * 1000.
      ELSE.
        <fs_rep>-menge_of = ( trunc( l_menge ) + 1 ) * 1000.
      ENDIF.

      c_cantidad_ofs = c_cantidad_ofs + <fs_rep>-menge_of.

    ENDLOOP.

* Cálculo de kg. cabo a partir del ancho cabo.
    IF i_ancho_cabo IS NOT INITIAL.
* DTM - Cálculo del ancho según número de bobinas (bobinas partidas)
      IF i_num_bobinas GT 0.
        l_ancho_total = l_ancho_total * i_num_bobinas.
      ENDIF.
* DTM

      o_kg_cabo = ( i_ancho_cabo * l_cantidad_old ) / l_ancho_total.
    ENDIF.
    l_menge = o_kg_cabo / 1000.
    l_resto = frac( l_menge ).
    IF l_resto < l_medio.
      o_kg_cabo = trunc( l_menge ) * 1000.
    ELSE.
      o_kg_cabo = ( trunc( l_menge ) + 1 ) * 1000.
    ENDIF.

    o_kg_totales = c_cantidad_ofs + o_kg_cabo.

  ENDMETHOD.
*1. Se calculará el ancho total del rollo que corresponde a la suma total de los anchos de las bobinas + trim.

*2. Se validará que el ancho total del rollo no sea superior al ancho máximo de rollo.
*   En caso contrario, se avisará de esta circunstancia (Ancho total superior al ancho máximo de máquina. Aceptar)

*3. Se validará que el ancho total del rollo no sea inferior al ancho mínimo de rollo.
*   En caso contrario, se avisará de esta circunstancia (Ancho total inferior al ancho mínimo de máquina. Aceptar)

*4. Se validará que todos los materiales pertenecen a la misma calidad y gramaje.
*   En caso contrario, se avisará de esta circunstancia (Materiales no combinables. Aceptar)

*5. Se validará que todos los repartos tienen la misma cantidad.
*   En caso contrario, se avisará de esta circunstancia (Cantidades no combinables. Aceptar)

  METHOD validacion_inicial_datos_of.

    DATA: l_total_kg TYPE z_cantidad_sin_dec,
          l_ancho    TYPE zancho.

    CLEAR: l_total_kg , l_ancho.
    o_rc = '00'.
*    l_ancho = gc_ancho_trim.

    LOOP AT gt_repartos_selec INTO DATA(ls_repartos).

      l_total_kg = l_total_kg + ls_repartos-menge.
      l_ancho    = l_ancho    + ls_repartos-ancho.

      IF ls_repartos-matkl   <> gt_repartos_selec[ 1 ]-matkl OR
         ls_repartos-gramaje <> gt_repartos_selec[ 1 ]-gramaje .
        o_rc = '03'.
        EXIT.
      ENDIF.

*      IF ls_repartos-matkl   <> gt_repartos_selec[ 1 ]-menge.
*        o_rc = '03'.
*        EXIT.
*      ENDIF.

    ENDLOOP.

    CHECK o_rc = '00'.

    l_ancho = l_ancho + gc_ancho_trim.

    IF l_ancho  > gc_ancho_max.
      o_rc = '01'.
      EXIT.
    ENDIF.


    IF l_ancho < gc_ancho_min.
      o_rc = '02'.
      EXIT.
    ENDIF.

    o_rc = '00'.
    o_cantidad = l_total_kg.

  ENDMETHOD.
* Mostrar avisos si:
* 1. f.fab<actual+3dias o
* 2. f.fab.>domingo actual
  METHOD avisos_fecha_fabricacion_of.
    DATA: l_hoy_mas_3d TYPE datum,
          l_msg        TYPE string
          .

    r_answer = '1'.

    l_hoy_mas_3d = sy-datum + 3.

    IF gs_datos_of_rollo-fecha_fin_fab < l_hoy_mas_3d.

      l_msg = |Fecha fin fabricación inferior a 3 días. ¿Desea continuar?|.
      r_answer = '2'.

    ELSEIF gs_datos_of_rollo-fecha_fin_fab > gr_capac_asig->g_dia_fin_semana. "Si la fecha es mayor que el domingo.selec.

      l_msg = |Fecha fin fabricación superior a fecha de capacidad. ¿Desea continuar?|.
      r_answer = '2'.

    ENDIF.

    IF r_answer = '2'.

      CLEAR r_answer.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = 'Aviso'
          text_question         = l_msg
          text_button_1         = 'Aceptar'
          icon_button_1         = 'ICON_CHECKED'
          text_button_2         = 'Cancelar' "
          icon_button_2         = 'ICON_CANCEL' "'Cancelar'
          default_button        = '2'
          display_cancel_button = ' '
        IMPORTING
          answer                = r_answer " '1'-> OK  / '2'-> CANCELAR
        EXCEPTIONS
          text_not_found        = 1
          OTHERS                = 2.

    ENDIF.


  ENDMETHOD.
  METHOD anulacion_ofs.

    TYPES: BEGIN OF ty_aufnr,
             aufnr TYPE aufnr,
           END OF ty_aufnr.

    DATA: ls_aufnr   TYPE  bapi_order_key,
          lt_aufnr   TYPE STANDARD TABLE OF bapi_order_key,
          ls_return  TYPE bapiret2,
          lti_return TYPE STANDARD TABLE OF bapi_order_return,
          lt_msg     TYPE                   esp1_message_tab_type,
          ls_msg     LIKE LINE OF lt_msg.

    o_rc = '00'.

    LOOP AT it_ofs_pend_selec INTO DATA(ls_of).
      ls_aufnr = ls_of-aufnr.
      INSERT ls_aufnr INTO TABLE lt_aufnr.
    ENDLOOP.

* Añadimos la OF rollo.
    ls_aufnr = ls_of-aufnr_rol.
    INSERT ls_aufnr INTO TABLE lt_aufnr.

* Bloqueamos las órdenes.
    LOOP AT lt_aufnr INTO ls_aufnr.

      CALL FUNCTION 'ENQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = ls_aufnr-order_number
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
        o_rc       = '04'.
        o_of_error = ls_aufnr.
        EXIT.
      ENDIF.

    ENDLOOP.

    IF o_rc = '00'.

* Borrado
      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
        EXPORTING
          scope_compl_tech   = '1'
          work_process_group = 'COWORK_BAPI'
          work_process_max   = 99
        IMPORTING
          return             = ls_return
        TABLES
          orders             = lt_aufnr
          detail_return      = lti_return.
      IF line_exists( lti_return[ type = 'E' ] ).
        o_rc = '05'.
        EXIT.
      ENDIF.
    ENDIF.


* Anulamos OFs de bobina/cabo seleccionadas
*    LOOP AT it_ofs_pend_selec INTO ls_of.
*      CLEAR: ls_aufnr , lt_aufnr[], ls_return , lti_return[].
*      ls_aufnr = ls_of-aufnr.
*      INSERT ls_aufnr INTO TABLE lt_aufnr.
*      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
*        EXPORTING
*          scope_compl_tech   = '1'
*          work_process_group = 'COWORK_BAPI'
*          work_process_max   = 99
*        IMPORTING
*          return             = ls_return
*        TABLES
*          orders             = lt_aufnr
*          detail_return      = lti_return.
*      IF line_exists( lti_return[ type = 'E' ] ).
*        o_rc = '01'.
*        EXIT.
*      ENDIF.
*    ENDLOOP.

* Si no ha habido error, anular OF Rollo.
*    IF o_rc = '00'.
*
*      CLEAR: ls_aufnr , lt_aufnr[], ls_return , lti_return[].
*
*      ls_aufnr = ls_of-aufnr_rol.
*      INSERT ls_aufnr INTO TABLE lt_aufnr.
*
*      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
*        EXPORTING
*          scope_compl_tech   = '1'
*          work_process_group = 'COWORK_BAPI'
*          work_process_max   = 99
*        IMPORTING
*          return             = ls_return
*        TABLES
*          orders             = lt_aufnr
*          detail_return      = lti_return.
*
*      IF line_exists( lti_return[ type = 'E' ] ).
*        o_rc = '02'.
*      ENDIF.
*
*    ENDIF.

    CASE o_rc.
      WHEN '00'.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.
        WAIT UP TO 1 SECONDS.

      WHEN '05'.
        CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

        LOOP AT lti_return ASSIGNING FIELD-SYMBOL(<fs_return>).

          CLEAR ls_msg.
          ls_msg-msgid = <fs_return>-id.
          ls_msg-msgty = <fs_return>-type.
          ls_msg-msgno = <fs_return>-number.
          ls_msg-msgv1 = <fs_return>-message_v1.
          ls_msg-msgv2 = <fs_return>-message_v2.
          ls_msg-msgv3 = <fs_return>-message_v3.
          ls_msg-msgv4 = <fs_return>-message_v4.
          INSERT ls_msg INTO TABLE lt_msg.
          EXIT.
        ENDLOOP.

        CALL FUNCTION 'C14Z_MESSAGES_SHOW_AS_POPUP'
          TABLES
            i_message_tab = lt_msg.

*        o_rc = '04'.
        EXIT.
      WHEN OTHERS.
    ENDCASE.

* Bloqueamos las órdenes.
    LOOP AT lt_aufnr INTO ls_aufnr.

      CALL FUNCTION 'DEQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = ls_aufnr-order_number
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
*        o_rc       = '01'.
*        o_of_error = ls_aufnr.
*        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD calcular_ancho_maximo.
    DATA: l_ancho_max_x_cabo LIKE gc_ancho_max,
          l_ancho_bob        LIKE gc_ancho_max,
          lv_ancho_5mm       TYPE zancho. "DTM

    CASE gr_capac_asig->g_werks.

      WHEN '3000'.l_ancho_max_x_cabo = gc_ancho_max.

      WHEN '3020'.l_ancho_max_x_cabo = gc_ancho_max. "- 10. "DTM
      WHEN OTHERS.
    ENDCASE.

    LOOP AT gt_repartos_selec INTO DATA(ls_reparto).
* DTM Se calcula el ancho para 5mm si hiciera falta
      CALL METHOD zclpp_creacion_ofs=>determinar_si_5mm
        EXPORTING
          iv_anch_bob  = ls_reparto-ancho
        IMPORTING
          ev_ancho_5mm = lv_ancho_5mm.
* DTM

* DTM Se añade el ancho de la bobina
      l_ancho_bob = l_ancho_bob + lv_ancho_5mm. "ls_reparto-ancho.
* DTM
    ENDLOOP.

* Si el resultado calculado del cabo es negativo, mostraremos 0.
    DATA: l_num TYPE p.

    l_num = l_ancho_max_x_cabo - ( l_ancho_bob * i_num_bobinas ) - gc_ancho_trim.
*    r_ancho_max_cabo = l_ancho_max_x_cabo - ( l_ancho_bob * i_num_bobinas ) - gc_ancho_trim.


* Si el cálculo es negativo, mostrar 0
    IF l_num > 0.
      r_ancho_max_cabo = l_num.
    ELSE.
      r_ancho_max_cabo = 0.
    ENDIF.

****    IF r_ancho_max_cabo < 0.
****      r_ancho_max_cabo = 0.
****    ENDIF.

  ENDMETHOD.
  METHOD cambiar_rollo_lista_mat_bobina.

    DATA: ls_comp_key  TYPE coxt_s_ord_comp_key,
          ls_comp_data TYPE zstpp_comp_orden,
          lt_return    TYPE bapiret2_t.

    o_rc = '00'.

*    SELECT SINGLE re~rsnum , re~rspos , re~rsart , re~charg , af~GMEIN
    SELECT  re~rsnum , re~rspos , re~rsart , re~charg , af~gmein
      INTO TABLE @DATA(lt_resb)
*      INTO  @DATA(ls_resb)
      FROM resb AS re
      INNER JOIN afko AS af ON af~rsnum = re~rsnum
      INNER JOIN mara AS ma ON ma~matnr = re~matnr "DTM
      WHERE af~aufnr =  @i_of AND
            ma~mtart = 'ZROL'. "DTM
**            sortf = 'ROLLO'.

    LOOP AT lt_resb INTO DATA(ls_resb).

      CLEAR: ls_comp_key , ls_comp_data , lt_return[].
      " Datos de componente a cambiar:
      ls_comp_key-rsnum = ls_resb-rsnum.
      ls_comp_key-rspos = ls_resb-rspos.
      ls_comp_key-rsart = ls_resb-rsart.

      " Datos del componente que se va a añadir:
      ls_comp_data-matnr = i_matnr_rollo.
      ls_comp_data-menge = i_menge.
      ls_comp_data-meins = ls_resb-gmein.
      ls_comp_data-charg = ls_resb-charg.


      CALL FUNCTION 'ZMFPP_CHANGE_COMP_ORDEN'
        EXPORTING
          i_aufnr      = i_of
          is_comp_key  = ls_comp_key
          is_comp_data = ls_comp_data
        TABLES
          et_return    = lt_return.

        TRY.
          os_ret = lt_return[ type = 'E' ].
          o_rc = '09'.
        CATCH cx_root .
        ENDTRY.
    ENDLOOP.


  ENDMETHOD.
  METHOD check_anulacion_ofs.

    o_rc = '00'.

    DATA(l_aufnr_rol) = it_ofs_pend_selec[ 1 ]-aufnr_rol.

* Se valida que no se seleccione más de 1 OF Rollo.
    LOOP AT it_ofs_pend_selec INTO DATA(ls_ofs).
      IF ls_ofs-aufnr_rol <> l_aufnr_rol.
        o_rc = '01'.
        EXIT.
      ENDIF.
    ENDLOOP.

    CHECK o_rc = '00'.

* Obtenemos todas las OFs de bobina/cabo asociadas a la única OF Rollo seleccionada.
    CALL METHOD zcl_secuenciador=>obtener_of_bobina
      EXPORTING
        i_aufnr_rollo   = l_aufnr_rol
      IMPORTING
        ot_aufnr_bobina = DATA(lt_aufnr_bob).


* Se valida que todas las bobinas/cabos estén en la selección.
    LOOP AT lt_aufnr_bob INTO DATA(l_of_bobina).

      IF NOT line_exists( it_ofs_pend_selec[ aufnr = l_of_bobina-aufnr ] ).
        o_rc = '02'.
        EXIT.
      ENDIF.

    ENDLOOP.

    data(l_werks) = it_ofs_pend_selec[ 1 ]-werks.
    CALL METHOD zcl_secuenciador=>validar_rollos_1020
      EXPORTING
        i_werks = l_werks
        i_aufnr = l_aufnr_rol
      IMPORTING
        o_error = DATA(l_error).
    IF l_error = 'X'.
      o_rc = '03'."    MESSAGE 'Atención! No se permite cierre técnico de OFs con rollos pend.de bobinar.' TYPE 'I'.
      EXIT.
    ENDIF.



  ENDMETHOD.
  METHOD CHECK_COSTES_MATERIAL.

    DATA: lv_code          LIKE sy-subrc.

    CALL FUNCTION 'COPC_CHECK_MBEW_KEKO'
      EXPORTING
        material = i_matnr
        bwkey    = i_werks
        status   = 'FR'
      IMPORTING
        rcode    = lv_code.

    IF lv_code <> 0. "  NO se ha hecho el calculo de costes
      r_rc = 'KO'.
    ELSE.
      r_rc = 'OK'.
    ENDIF.

  ENDMETHOD.
  METHOD check_datos_creacion_ok.

    DATA: l_fecha_min TYPE datum,
          l_dia_mas_2 TYPE datum,
          l_cantidad  TYPE z_cantidad_sin_dec,
          l_cont      TYPE i,
          l_ancho_5mm TYPE zancho.

    CLEAR: o_ancho_total , o_rc, o_kg_cabo , o_kg_totales ,
           gt_repartos_selec[] , l_fecha_min, l_cantidad.

    CLEAR: gt_repartos_selec[] .
    gt_repartos_selec[] = ct_repartos[].

    o_rc = '00'.

* Obtener fecha fabricación final calculada.
    IF c_fecha_fabr_final IS INITIAL.
      c_fecha_fabr_final = zclpp_creacion_ofs=>get_fecha_fabricacion_of( i_fecha_entrega  = l_fecha_min
                                                                         i_fecha_actual   = sy-datum
                                                                        ).
    ELSE. " validación de la fecha introducida.
      l_dia_mas_2 = sy-datum + 2.

      IF c_fecha_fabr_final < sy-datum.
        o_rc = '05'.
        EXIT.
      ENDIF.
    ENDIF.

* Cálculo de los Kg.TOTALES (c_cantidad), fecha mínima y ancho total.
    CASE lines( gt_repartos_selec ).
      WHEN 1.

        l_fecha_min = gt_repartos_selec[ 1 ]-fecha_ent.

* Verificar si ancho acaba en 5mm (Smith), para redondear a la decena superior.
        l_ancho_5mm = validar_ancho_5mm( gt_repartos_selec[ 1 ]-ancho ).

        o_ancho_total = l_ancho_5mm.
*        o_ancho_total = gt_repartos_selec[ 1 ]-ancho.

        IF c_cantidad IS INITIAL.
          c_cantidad = gt_repartos_selec[ 1 ]-menge.
        ENDIF.

      WHEN OTHERS. "Si hay mas de 1 reparto, obtenemos la lista de clientes y la fecha entrega mínima.

        LOOP AT gt_repartos_selec[] INTO DATA(ls_reparto).

          l_cont = l_cont + 1.

          IF l_fecha_min IS INITIAL OR l_fecha_min > ls_reparto-fecha_ent.
            l_fecha_min = ls_reparto-fecha_ent.
          ENDIF.

* Verificar si ancho acaba en 5mm (Smith), para redondear a la decena superior.
          l_ancho_5mm = validar_ancho_5mm( gt_repartos_selec[ l_cont ]-ancho ).

          o_ancho_total = o_ancho_total + l_ancho_5mm.
*          o_ancho_total = o_ancho_total + ls_reparto-ancho.

          l_cantidad    = l_cantidad + ls_reparto-menge.

        ENDLOOP.

        IF c_cantidad IS INITIAL.
          c_cantidad = l_cantidad.
        ENDIF.
    ENDCASE.

* Obtener kg. OF repartos, kg.OF cabo y kg.OF rollo
    CALL METHOD me->get_kg_redondeados_of
      EXPORTING
        i_ancho_cabo   = i_ancho_cabo
        i_num_bobinas  = i_num_bobinas
      IMPORTING
        o_kg_cabo      = o_kg_cabo
        o_kg_totales   = o_kg_totales
      CHANGING
        c_cantidad_ofs = c_cantidad.

    o_ancho_total = ( o_ancho_total * i_num_bobinas ) + i_ancho_cabo + gc_ancho_trim.

* Validación de ancho máximo.
    IF o_ancho_total  > gc_ancho_max.
      o_rc = '01'.
      EXIT.
    ENDIF.

* Validación de ancho mínimo.
    IF o_ancho_total < gc_ancho_min.
      o_rc = '02'.
      EXIT.
    ENDIF.

    CLEAR gs_datos_of_cabo.
    IF i_ancho_cabo IS NOT INITIAL.

      CALL METHOD zclpp_creacion_ofs=>get_matnr_cabo
        EXPORTING
          i_gramaje = gt_repartos_selec[ 1 ]-gramaje
          i_ancho   = i_ancho_cabo
          i_matkl   = gt_repartos_selec[ 1 ]-matkl
        IMPORTING
          o_matnr   = gs_datos_of_cabo-matnr.
      IF gs_datos_of_cabo-matnr IS INITIAL.
        o_rc = '03'. "Material de cabo no encontrado
        EXIT.
      ELSE.
        gs_datos_of_cabo-werks         = gt_repartos_selec[ 1 ]-werks.
        gs_datos_of_cabo-fecha_fin_fab = c_fecha_fabr_final.
        gs_datos_of_cabo-menge         = o_kg_cabo.
        gs_datos_of_cabo-meins         = gt_repartos_selec[ 1 ]-meins.
        gs_datos_of_cabo-fec_entrega   = gt_repartos_selec[ 1 ]-fecha_ent.
        gs_datos_of_cabo-kunnr         = |C{ me->gr_capac_asig->g_werks }|. "Cliente cabo: la propia papelera.

*    Validación de la determinación de costes.
        IF check_costes_material( i_werks = gs_datos_of_cabo-werks
                                  i_matnr = gs_datos_of_cabo-matnr )  = 'KO'.
          o_rc = '06'. "Error en la determinación de costes
          EXIT.
        ENDIF.

      ENDIF.

    ENDIF.

    CLEAR gs_datos_of_rollo.
    CALL METHOD zclpp_creacion_ofs=>get_matnr_rollo
      EXPORTING
        i_gramaje = gt_repartos_selec[ 1 ]-gramaje
        i_ancho   = o_ancho_total
        i_matkl   = gt_repartos_selec[ 1 ]-matkl
      IMPORTING
        o_matnr   = gs_datos_of_rollo-matnr.

    IF gs_datos_of_rollo-matnr IS INITIAL.
      o_rc = '04'. "Material de rollo no encontrado
      EXIT.
    ENDIF.

    CALL METHOD zclpp_creacion_ofs=>validar_lista_materiales_bom
      EXPORTING
        i_cantidad = o_kg_totales
        i_matnr    = gs_datos_of_rollo-matnr
        i_werks    = gt_repartos_selec[ 1 ]-werks
      IMPORTING
        o_rc       = o_rc.

    CHECK o_rc EQ '00'. " Si se informa "08", se identificará con este error en la lista de materiales

    gs_datos_of_rollo-werks         = gt_repartos_selec[ 1 ]-werks.
    gs_datos_of_rollo-fecha_fin_fab = c_fecha_fabr_final.
    gs_datos_of_rollo-menge         = o_kg_totales.
    gs_datos_of_rollo-meins         = gt_repartos_selec[ 1 ]-meins.
    gs_datos_of_rollo-kunnr         = gt_repartos_selec[ 1 ]-kunnr.
    gs_datos_of_rollo-fec_entrega   = gt_repartos_selec[ 1 ]-fecha_ent.

*    Validación de la determinación de costes.
    IF check_costes_material( i_werks = me->gr_capac_asig->g_werks
                              i_matnr = gs_datos_of_rollo-matnr    )  = 'KO'.

      o_rc = '06'. "Error en la determinación de costes
      EXIT.
    ENDIF.


    CLEAR: gt_datos_of_rep_selec , l_cont.
    LOOP AT gt_repartos_selec[] INTO ls_reparto.

      l_cont = l_cont + 1.

* Validación de costes de los materiales seleccionados en los repartos.
      IF check_costes_material( i_werks = me->gr_capac_asig->g_werks
                                i_matnr = ls_reparto-matnr           )  = 'KO'.
        o_rc = '06'. "Error en la determinación de costes
        EXIT.
      ENDIF.

      APPEND INITIAL LINE TO gt_datos_of_rep_selec ASSIGNING FIELD-SYMBOL(<fs_datos_of_rep>).
      <fs_datos_of_rep>-werks         = ls_reparto-werks.
      <fs_datos_of_rep>-fecha_fin_fab = c_fecha_fabr_final.
      <fs_datos_of_rep>-menge         = ls_reparto-menge_of.
      <fs_datos_of_rep>-meins         = ls_reparto-meins.
      <fs_datos_of_rep>-matnr         = ls_reparto-matnr.
      <fs_datos_of_rep>-kunnr         = ls_reparto-kunnr.
      <fs_datos_of_rep>-vbeln         = ls_reparto-vbeln.
      <fs_datos_of_rep>-posnr         = ls_reparto-posnr.
      <fs_datos_of_rep>-etenr         = ls_reparto-etenr.
      <fs_datos_of_rep>-fec_entrega   = ls_reparto-fecha_ent.

* 65930 - 19/04/2021 - CMS Marcar bobina partida.
      <fs_datos_of_rep>-bob_partida = i_num_bobinas.

* En los datos adicionales de rollo, se informa datos de reparto de cada bobina.
      CASE l_cont.
        WHEN 1. " Si solo hay selecionado un reparto, miramos el nºbobinas (bobina partida)
          gs_datos_of_rollo-kunnr = <fs_datos_of_rep>-kunnr.
          gs_datos_of_rollo-vbeln = <fs_datos_of_rep>-vbeln.
          gs_datos_of_rollo-posnr = <fs_datos_of_rep>-posnr.
          gs_datos_of_rollo-etenr = <fs_datos_of_rep>-etenr.
          gs_datos_of_rollo-fec_entrega = <fs_datos_of_rep>-fec_entrega.
          CASE i_num_bobinas.
            WHEN 2.
              gs_datos_of_rollo-kunnr2 = <fs_datos_of_rep>-kunnr.
              gs_datos_of_rollo-vbeln2 = <fs_datos_of_rep>-vbeln.
              gs_datos_of_rollo-posnr2 = <fs_datos_of_rep>-posnr.
              gs_datos_of_rollo-etenr2 = <fs_datos_of_rep>-etenr.
              gs_datos_of_rollo-fec_entrega2 = <fs_datos_of_rep>-fec_entrega.
            WHEN 3.
              gs_datos_of_rollo-kunnr2 = <fs_datos_of_rep>-kunnr.
              gs_datos_of_rollo-vbeln2 = <fs_datos_of_rep>-vbeln.
              gs_datos_of_rollo-posnr2 = <fs_datos_of_rep>-posnr.
              gs_datos_of_rollo-etenr2 = <fs_datos_of_rep>-etenr.
              gs_datos_of_rollo-fec_entrega2 = <fs_datos_of_rep>-fec_entrega.

              gs_datos_of_rollo-kunnr3 = <fs_datos_of_rep>-kunnr.
              gs_datos_of_rollo-vbeln3 = <fs_datos_of_rep>-vbeln.
              gs_datos_of_rollo-posnr3 = <fs_datos_of_rep>-posnr.
              gs_datos_of_rollo-etenr3 = <fs_datos_of_rep>-etenr.
              gs_datos_of_rollo-fec_entrega3 = <fs_datos_of_rep>-fec_entrega.
            WHEN OTHERS.
          ENDCASE.
        WHEN 2.
          gs_datos_of_rollo-kunnr2 = <fs_datos_of_rep>-kunnr.
          gs_datos_of_rollo-vbeln2 = <fs_datos_of_rep>-vbeln.
          gs_datos_of_rollo-posnr2 = <fs_datos_of_rep>-posnr.
          gs_datos_of_rollo-etenr2 = <fs_datos_of_rep>-etenr.
        WHEN 3.
          gs_datos_of_rollo-kunnr3 = <fs_datos_of_rep>-kunnr.
          gs_datos_of_rollo-vbeln3 = <fs_datos_of_rep>-vbeln.
          gs_datos_of_rollo-posnr3 = <fs_datos_of_rep>-posnr.
          gs_datos_of_rollo-etenr3 = <fs_datos_of_rep>-etenr.
        WHEN OTHERS.
      ENDCASE.

      IF l_cont = 1.

      ENDIF.

    ENDLOOP.

* Validar que no se creen mas de 3 bobinas/cabo--> "No se permite combinar más de 3 OFs"
    DATA(l_linies) = lines( gt_repartos_selec ).

    l_linies = l_linies * i_num_bobinas. " multiplicamos para bobina partida.  Si no hay bob.partida nºbobinas=1.

    IF ( l_linies > 2 AND i_ancho_cabo > 0 ) OR l_linies > 3.
      o_rc = '07'. "No se permite combinar más de 3 OFs.
    ENDIF.

    ct_repartos[] = gt_repartos_selec[].

  ENDMETHOD.
  METHOD constructor.

    DATA: l_ancho_trim TYPE zancho_trim,
          l_ancho_min  TYPE zancho_min,
          l_arbpl      TYPE arbpl.

    CASE i_werks.
      WHEN '3000'. l_arbpl = 'MAQUINA'.
      WHEN '3020'. l_arbpl = 'MAQUI_10'.
      WHEN OTHERS.
    ENDCASE.

* Obtener constantes de ancho trim/max/min.
    SELECT SINGLE ancho_trim ancho_min ancho_maximo
        INTO (l_ancho_trim , l_ancho_min , gc_ancho_max)
        FROM  ztpp0008
        WHERE werks = i_werks
        AND   arbpl = l_arbpl.

    gc_ancho_trim = l_ancho_trim.
    gc_ancho_min  = l_ancho_min.


  ENDMETHOD.
  METHOD control_errores_creacion_of.
    DATA: ls_msg LIKE LINE OF ct_msg_err.

    IF is_datos_of-aufnr IS INITIAL.
      CLEAR ls_msg.
      ls_msg-msgno = 356. "Error en la creación de OF de &
      ls_msg-msgid = 'ZPP'.
      ls_msg-msgty = 'E'.
      ls_msg-msgv1 = i_txt_tp_of.
      INSERT ls_msg                 INTO TABLE ct_msg_err.

      IF is_datos_of-s_msg IS NOT INITIAL.
        CLEAR ls_msg.
        ls_msg-msgno = is_datos_of-s_msg-number.
        ls_msg-msgid = is_datos_of-s_msg-id.
        ls_msg-msgty = is_datos_of-s_msg-type.
        ls_msg-msgv1 = is_datos_of-s_msg-message_v1.
        ls_msg-msgv2 = is_datos_of-s_msg-message_v2.
        ls_msg-msgv3 = is_datos_of-s_msg-message_v3.
        ls_msg-msgv4 = i_txt_tp_of.
        INSERT ls_msg                 INTO TABLE ct_msg_err.
      ENDIF.
    ELSE.

      CLEAR ls_msg.
      ls_msg-msgno = 355. "OF de & & creada correctamente
      ls_msg-msgid = 'ZPP'.
      ls_msg-msgty = 'S'.
      ls_msg-msgv1 = i_txt_tp_of.
      ls_msg-msgv2 = CONV #( is_datos_of-aufnr ).
      INSERT ls_msg                 INTO TABLE ct_msg_err.

      CASE is_datos_of-rc.
        WHEN '00'.


        WHEN '02'. " Error en la determinación de costes para OF de &. 357
          CLEAR ls_msg.
          ls_msg-msgno = 357. "Error en la creación de OF de &
          ls_msg-msgid = 'ZPP'.
          ls_msg-msgty = 'E'.
          ls_msg-msgv1 = i_txt_tp_of.
          INSERT ls_msg                 INTO TABLE ct_msg_err.
        WHEN '09'. "
          ls_msg-msgno = 360. " Error en la modificación de la lista de material
          ls_msg-msgid = 'ZPP'.
          ls_msg-msgty = 'E'.
          ls_msg-msgv1 = i_txt_tp_of.
          INSERT ls_msg                 INTO TABLE ct_msg_err.


        WHEN '10'. " Error al insertar datos adicionales para OF de &  358
          CLEAR ls_msg.
          ls_msg-msgno = 358. "Error en la creación de OF de &
          ls_msg-msgid = 'ZPP'.
          ls_msg-msgty = 'E'.
          ls_msg-msgv1 = i_txt_tp_of.
          INSERT ls_msg                 INTO TABLE ct_msg_err.

        WHEN OTHERS.
      ENDCASE.

    ENDIF.



  ENDMETHOD.
    METHOD crear_of.

      DATA: ls_orderdata TYPE bapi_pi_order_create,
            l_auart      TYPE bapi_order_copy-order_type,
            ls_return    TYPE bapiret2,
            l_objnr      TYPE jest-objnr,
            wa_jest      TYPE jest.

      CLEAR: ls_orderdata, ls_return.  " lt_return[].
      cs_datos_creacion-rc = '00'.

      ls_orderdata-material         = cs_datos_creacion-matnr.
      ls_orderdata-plant            = cs_datos_creacion-werks.
      ls_orderdata-order_type       = cs_datos_creacion-order_type.
      ls_orderdata-quantity         = cs_datos_creacion-menge.
      ls_orderdata-quantity_uom     = cs_datos_creacion-meins.
*    ls_orderdata-basic_start_date = cs_datos_creacion-fecha_fin_fab. "la antigua, que s'informava a ZPP0001
      ls_orderdata-basic_end_date    = cs_datos_creacion-fecha_fin_fab.


      CALL FUNCTION 'BAPI_PROCORD_CREATE'
        EXPORTING
          orderdata    = ls_orderdata
        IMPORTING
*         return       = ls_return
          return       = cs_datos_creacion-s_msg
          order_number = cs_datos_creacion-aufnr
          order_type   = l_auart.

      IF cs_datos_creacion-aufnr IS INITIAL.
        cs_datos_creacion-rc = '01'.
        EXIT.
      ELSE.
        l_objnr = |OR{ l_objnr }|.

      ENDIF.

* Añadimos la espera
      CALL METHOD zclpp_creacion_ofs=>espera_hasta_creacion_of
        EXPORTING
          i_aufnr = cs_datos_creacion-aufnr.

      SELECT SINGLE * INTO wa_jest
         FROM jest
         WHERE objnr = l_objnr AND
         ( stat = zcl_secuenciador=>gc_i0045_out OR           " I0045 -> Cierre técnico
           stat = zcl_secuenciador=>gc_i0115_err_costes ) AND " I0115 -> Error det.costes
         inact = ' '.
      IF sy-subrc = 0.
        cs_datos_creacion-rc = '02'. "Error en la determinación de costes
        EXIT.
      ELSE.

        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.


      ENDIF.

      CALL METHOD zclpp_creacion_ofs=>espera_hasta_creacion_of
        EXPORTING
          i_aufnr = cs_datos_creacion-aufnr.

* PASO 3: DATOS ADICIONALES ROLLO
* batch input
*
      CALL FUNCTION 'ZMFPP_BI_DATOS_ADIC_OF_COR2'
        EXPORTING
          i_aufnr       = cs_datos_creacion-aufnr
          i_kunnr_1     = cs_datos_creacion-kunnr
          i_vbeln_1     = cs_datos_creacion-vbeln
          i_posnr_1     = cs_datos_creacion-posnr
          i_etenr_1     = cs_datos_creacion-etenr
          i_mbdat_1     = cs_datos_creacion-fec_entrega
          i_kunnr_2     = cs_datos_creacion-kunnr2
          i_vbeln_2     = cs_datos_creacion-vbeln2
          i_posnr_2     = cs_datos_creacion-posnr2
          i_etenr_2     = cs_datos_creacion-etenr2
          i_mbdat_2     = cs_datos_creacion-fec_entrega2
          i_kunnr_3     = cs_datos_creacion-kunnr3
          i_vbeln_3     = cs_datos_creacion-vbeln3
          i_posnr_3     = cs_datos_creacion-posnr3
          i_etenr_3     = cs_datos_creacion-etenr3
          i_mbdat_3     = cs_datos_creacion-fec_entrega3
          i_aufnr_rollo = cs_datos_creacion-aufnr_rollo
          i_bob_partida = cs_datos_creacion-bob_partida
        IMPORTING
          o_rc          = cs_datos_creacion-rc.  "si hay error RC = '10'  Se controla en metodo control_errores_creacion_of

      CHECK cs_datos_creacion-rc = '00'.
* PASO 4: Lista de materiales, si es bobina.
      IF i_rollo_list_mat IS NOT INITIAL.

        CALL METHOD zclpp_creacion_ofs=>cambiar_rollo_lista_mat_bobina
          EXPORTING
            i_of          = cs_datos_creacion-aufnr
            i_menge       = cs_datos_creacion-menge
            i_matnr_rollo = i_rollo_list_mat
          IMPORTING
            o_rc          = cs_datos_creacion-rc.

      ENDIF.

    ENDMETHOD.
  METHOD determinar_si_5mm.

    DATA: lv_ult_pos TYPE char1,
          lv_pos     TYPE n,
          lv_string  TYPE string.

*Calcular ancho, y restar 1.
    lv_pos = strlen( iv_anch_bob ).
    lv_pos     = lv_pos - 1.

    lv_string  = iv_anch_bob.

* Obtener la última posición.
    lv_ult_pos = lv_string+lv_pos(1).

    IF lv_ult_pos = '5'.
      ev_ancho_5mm = iv_anch_bob + 5.
    ELSE.
      ev_ancho_5mm = iv_anch_bob.
    ENDIF.

  ENDMETHOD.
  METHOD espera_hasta_creacion_of.

    DATA: lv_ok        TYPE xflag,
          lv_aufnr_aux TYPE aufnr,
          lv_cont      TYPE i.

    CLEAR: lv_ok, lv_cont, lv_aufnr_aux.
    WHILE lv_ok IS INITIAL.
      WAIT UP TO 1 SECONDS.
      lv_cont = lv_cont + 1.

      SELECT SINGLE aufnr INTO lv_aufnr_aux
        FROM aufk
        WHERE aufnr = i_aufnr.

      IF lv_aufnr_aux IS NOT INITIAL.
        lv_ok = 'X'.
      ENDIF.

      IF lv_cont = 15.
        lv_ok = 'X'.
      ENDIF.
    ENDWHILE.


*    CALL FUNCTION 'ENQUEUE_ESORDER'
*      EXPORTING
*        mode_aufk      = 'E'
*        mandt          = sy-mandt
*        aufnr          = i_aufnr
*      EXCEPTIONS
*        foreign_lock   = 1
*        system_failure = 2
*        OTHERS         = 3.
*    IF sy-subrc <> 0.
*    ENDIF.


  ENDMETHOD.
  METHOD get_datos_ini_creacion_of.
    DATA: "lr_kunnr    TYPE RANGE OF kunnr,
*          ls_kunnr    LIKE LINE OF lr_kunnr,
      l_fecha_min  TYPE datum,
      lv_ancho_5mm TYPE zancho. "DTM

    CLEAR: ot_stock[] , ot_repartos_abiertos[] , o_fecha_fabr_final , o_ancho_total , o_rc,
           gt_repartos_selec[] , l_fecha_min. " lr_kunnr[]

    gt_repartos_selec[] = ct_repartos[].

    CALL METHOD me->validacion_inicial_datos_of
      IMPORTING
        o_rc       = o_rc
        o_cantidad = o_cantidad.

    IF o_rc = '02'. "Se permite acceder con ancho menor al mínimo
      o_rc = '00'.
    ENDIF.

    CHECK o_rc = '00'.

    CASE lines( gt_repartos_selec ).
      WHEN 1.
*        lr_kunnr  = VALUE #( ( sign = 'I' option = 'EQ' low = gt_repartos_selec[ 1 ]-kunnr ) ).

        l_fecha_min = gt_repartos_selec[ 1 ]-fecha_ent.
        o_ancho_total = gt_repartos_selec[ 1 ]-ancho.

* Obtener stock de cliente seleccionado.
        CALL METHOD zclpp_creacion_ofs=>get_stock_x_cliente
          EXPORTING
            i_werks  = gt_repartos_selec[ 1 ]-werks
            i_matnr  = gt_repartos_selec[ 1 ]-matnr
            i_kunnr  = gt_repartos_selec[ 1 ]-kunnr
          IMPORTING
            os_stock = DATA(ls_stock).

        INSERT ls_stock INTO TABLE ot_stock.

      WHEN OTHERS. "Si hay mas de 1 reparto, obtenemos la lista de clientes y la fecha entrega mínima.

        LOOP AT gt_repartos_selec[] INTO DATA(ls_reparto).

*          CLEAR ls_kunnr.
*          ls_kunnr-sign     = 'I'.
*          ls_kunnr-option   = 'EQ'.
*          ls_kunnr-low      = ls_reparto-kunnr.
*          INSERT ls_kunnr INTO TABLE lr_kunnr.

          IF l_fecha_min IS INITIAL OR l_fecha_min > ls_reparto-fecha_ent.
            l_fecha_min = ls_reparto-fecha_ent.
          ENDIF.

          o_ancho_total = o_ancho_total + ls_reparto-ancho.

* obtener stock de clientes seleccionados.
          DATA: lt_stock TYPE zclpp_creacion_ofs=>tty_stock.
          CLEAR lt_stock.
          CALL METHOD zclpp_creacion_ofs=>get_stock_x_cliente
            EXPORTING
              i_werks  = ls_reparto-werks
              i_matnr  = ls_reparto-matnr
              i_kunnr  = ls_reparto-kunnr
            IMPORTING
              os_stock = ls_stock.

*          LOOP AT lt_stock INTO DATA(ls_stock).
          INSERT ls_stock INTO TABLE ot_stock.
*          ENDLOOP.
        ENDLOOP.

    ENDCASE.

* DTM Comprobar ancho 5mm
    CALL METHOD zclpp_creacion_ofs=>determinar_si_5mm
      EXPORTING
        iv_anch_bob  = o_ancho_total
      IMPORTING
        ev_ancho_5mm = lv_ancho_5mm.

* DTM Se utiliza el ancho total correcto
    CLEAR: o_ancho_total.
    o_ancho_total = lv_ancho_5mm + gc_ancho_trim.

**    o_ancho_total = o_ancho_total + gc_ancho_trim.

** Obtener stock de cliente/s seleccionado/s.
*    CALL METHOD zclpp_creacion_ofs=>get_stock_x_cliente
*      EXPORTING
*        i_werks  = gt_repartos_selec[ 1 ]-werks
*        i_matnr  = gt_repartos_selec[ 1 ]-matnr
*        ir_kunnr = lr_kunnr
*      IMPORTING
*        ot_stock = ot_stock.

* Obtener fecha fabricación final calculada.
    o_fecha_fabr_final = zclpp_creacion_ofs=>get_fecha_fabricacion_of( i_fecha_entrega  = l_fecha_min
                                                                       i_fecha_actual   = sy-datum
                                                                      ).

* Obtener pedidos abiertos del primer cliente.
    CALL METHOD zclpp_creacion_ofs=>get_pedidos_abiertos
      EXPORTING
        i_werks              = gt_repartos_selec[ 1 ]-werks
        i_kunnr              = gt_repartos_selec[ 1 ]-kunnr
        i_matnr              = gt_repartos_selec[ 1 ]-matnr
      IMPORTING
        ot_repartos_abiertos = ot_repartos_abiertos.

    DELETE ot_repartos_abiertos WHERE vbeln = gt_repartos_selec[ 1 ]-vbeln AND
                                      posnr = gt_repartos_selec[ 1 ]-posnr AND
                                      etenr = gt_repartos_selec[ 1 ]-etenr.


* Obtener kg. OF repartos, kg.OF cabo y kg.OF rollo
    CALL METHOD me->get_kg_redondeados_of
      EXPORTING
        i_ancho_cabo   = 0
      IMPORTING
*       o_kg_cabo      =
        o_kg_totales   = o_kg_totales
      CHANGING
        c_cantidad_ofs = o_cantidad.

    ct_repartos[] = gt_repartos_selec[].

* Borrar duplicados de cliente/material, de la tabla de stock,
* por si se seleccionan dos repartos del mismo material y cliente.
    SORT ot_stock BY kunnr matnr ASCENDING.
    DELETE ADJACENT DUPLICATES FROM ot_stock COMPARING kunnr matnr.

  ENDMETHOD.
  METHOD GET_MATNR_CABO.

    SELECT SINGLE matnr INTO o_matnr
      FROM mara
      WHERE matkl     = i_matkl
      AND   lvorm     = abap_false
      AND   mtart     = 'ZPAP'
      AND   ( mstae   = abap_false OR mstae = '00' )
      AND   zzgramaje = i_gramaje
      AND   zzancho   = i_ancho.
    IF sy-subrc NE 0.
      CLEAR o_matnr.
      EXIT.
    ENDIF.

  ENDMETHOD.
  METHOD get_matnr_rollo.

    SELECT SINGLE matnr INTO o_matnr
      FROM mara
      WHERE matkl     = i_matkl
      AND   lvorm     = abap_false
      AND   mtart     = 'ZROL'
      AND   ( mstae   = abap_false OR mstae = '00' )
      AND   zzgramaje = i_gramaje
      AND   zzancho   = i_ancho.
    IF sy-subrc NE 0.
      CLEAR o_matnr.
      EXIT.
    ENDIF.

  ENDMETHOD.
  method GET_NEW_ID_PEDIDO_CABO.

        CALL FUNCTION 'NUMBER_GET_NEXT'
      EXPORTING
        nr_range_nr             = '01'
        object                  = 'ZPPCABOPED'
      IMPORTING
        number                  = r_vbeln
      EXCEPTIONS
        interval_not_found      = 1
        number_range_not_intern = 2
        object_not_found        = 3
        quantity_is_0           = 4
        quantity_is_not_1       = 5
        interval_overflow       = 6
        buffer_overflow         = 7.


  endmethod.
  METHOD get_numero_rollos.

    CASE i_werks.

      WHEN  '3020'. "Coeficiente 1000 para Sarriá
        o_tornadas = zcl_secuenciador=>gc_tornadas_3020.
        o_rollos   = ceil( i_kg / zcl_secuenciador=>gc_kg_rollo_3020 ).

      WHEN  '3000'. "Coeficiente 1200 para l'Alquería
        o_tornadas = zcl_secuenciador=>gc_tornadas_3000.
        o_rollos   = ceil( i_kg / zcl_secuenciador=>gc_kg_rollo_3000 ).

    ENDCASE.



  ENDMETHOD.
  METHOD get_of_semana_selec_cooispi.

    CONSTANTS: c_zi01 TYPE auart VALUE 'ZI01',
               c_zi02 TYPE auart VALUE 'ZI02'.

    DATA: l_aj_ancho        LIKE me->g_fabneta_kg_bobinas.
    DATA: l_aj_gram         LIKE me->g_fabneta_kg_bobinas.

    CLEAR: g_fabneta_kg_bobinas , g_fabneta_kg_cabos, g_fabneta_porc_bobinas , gt_ofs_pend[].

* Obtenemos datos de OFs de bobinas/cabos
    SELECT a~aufnr , a~zzkunnr1 , a~zzebeln1 , a~zzebelp1, a~zzfec_entreg1, a~zzurgt1, a~zzaufnr_rollo ,
           b~gmein , b~plnbez ,  b~gltrp , b~gamng , b~igmng , j~stat " GAMNG->kg plan bob  // IGMNG->kg.fabricados bob. // ZZAUFNR_ROLLO
      INTO TABLE @DATA(lt_of_bobi)
      FROM aufk AS a
      INNER JOIN afko AS b ON a~aufnr = b~aufnr
      INNER JOIN jest AS j ON j~objnr = a~objnr
      WHERE b~gltrp BETWEEN @gr_capac_asig->g_dia_ini_semana AND @gr_capac_asig->g_dia_fin_semana AND
            a~aufnr IN @ir_aufnr AND
            a~auart = @c_zi02 AND
            a~werks = @gr_capac_asig->g_werks AND
            j~stat IN ( @zcl_secuenciador=>gc_i0001_abierta ,
                        @zcl_secuenciador=>gc_i0002_liberada ,
                        @zcl_secuenciador=>gc_i0045_out       ) AND
            j~inact = ' '.


    LOOP AT lt_of_bobi INTO DATA(ls_of_bobi).

* Si la OF está en estado CTEC y tiene 0 kg, no se muestra
      IF ls_of_bobi-stat = zcl_secuenciador=>gc_i0045_out AND ls_of_bobi-igmng = 0.
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO gt_ofs_pend ASSIGNING FIELD-SYMBOL(<fs_ofs>).


      <fs_ofs>-werks            = gr_capac_asig->g_werks.
      <fs_ofs>-matnr            = ls_of_bobi-plnbez.
      <fs_ofs>-maktx            = zclpp_recetas_reparto_pulper=>obtener_descr_material( <fs_ofs>-matnr ).
      <fs_ofs>-aufnr            = ls_of_bobi-aufnr.
      <fs_ofs>-kg_plan_bobi     = ls_of_bobi-gamng.
      <fs_ofs>-meins_plan_bobi  = ls_of_bobi-gmein.
      <fs_ofs>-kg_fabr_bobi     = ls_of_bobi-igmng.
      <fs_ofs>-meins_fab_bobi   = ls_of_bobi-gmein.
      <fs_ofs>-fecha_fab        = ls_of_bobi-gltrp.


      CALL METHOD zclpp_capacidad_asignada=>get_ancho_gramaje_material
        EXPORTING
          i_matnr   = <fs_ofs>-matnr
        IMPORTING
          o_ancho   = <fs_ofs>-ancho_bob
          o_gramaje = <fs_ofs>-gramaje
          o_matkl   = <fs_ofs>-matkl.

* Acumulamos Kg. de bobinas/cabos
      IF <fs_ofs>-ancho_bob >= 1340.

        g_fabneta_kg_bobinas = g_fabneta_kg_bobinas + <fs_ofs>-kg_plan_bobi.

* Ajuste de kg.bobina
        l_aj_ancho = <fs_ofs>-kg_plan_bobi - ( ( gr_capac_asig->gc_ancho_medio    * <fs_ofs>-kg_plan_bobi ) /  <fs_ofs>-ancho_bob ).
        l_aj_gram  = <fs_ofs>-kg_plan_bobi - ( ( gr_capac_asig->gc_gramaje_medio  * <fs_ofs>-kg_plan_bobi ) /  <fs_ofs>-gramaje  ).

* Acumular kg.bobina ajustados
        g_fabneta_kg_bobinas_normaliz = g_fabneta_kg_bobinas_normaliz + ( <fs_ofs>-kg_plan_bobi + l_aj_ancho + l_aj_gram ).

      ELSE.
        g_fabneta_kg_cabos = g_fabneta_kg_cabos + <fs_ofs>-kg_plan_bobi.
      ENDIF.

* Obtenemos datos del rollo asociado a la bobina/cabo
      <fs_ofs>-vbeln            = ls_of_bobi-zzebeln1.
      <fs_ofs>-posnr            = ls_of_bobi-zzebelp1.
      <fs_ofs>-etenr            = ls_of_bobi-zzurgt1.
      <fs_ofs>-fecha_ent        = ls_of_bobi-zzfec_entreg1.
      <fs_ofs>-kunnr            = ls_of_bobi-zzkunnr1.
      <fs_ofs>-desc_cli         = zclpp_capacidad_asignada=>get_descripcion_cliente( <fs_ofs>-kunnr ).


      SELECT SINGLE a~aufnr , b~gmein , b~plnbez , b~gltrp , b~gamng , b~igmng " GAMNG->kg plan rollo  // IGMNG->kg.fabricados rollo // ZZAUFNR_ROLLO
        INTO @DATA(ls_of_rollo)
        FROM aufk AS a
        INNER JOIN afko AS b ON a~aufnr = b~aufnr
        WHERE b~aufnr = @ls_of_bobi-zzaufnr_rollo AND
              a~auart = @c_zi01.

      IF sy-subrc = 0.

        <fs_ofs>-aufnr_rol        = ls_of_rollo-aufnr.
        <fs_ofs>-matnr_rol        = ls_of_rollo-plnbez.
        <fs_ofs>-maktx_rol        = zclpp_recetas_reparto_pulper=>obtener_descr_material( <fs_ofs>-matnr_rol ).

        CALL METHOD zclpp_capacidad_asignada=>get_ancho_gramaje_material
          EXPORTING
            i_matnr = <fs_ofs>-matnr_rol
          IMPORTING
            o_ancho = <fs_ofs>-ancho_rol.

        <fs_ofs>-kg_plan_rol      = ls_of_rollo-gamng.
        <fs_ofs>-meins_plan_rol   = ls_of_rollo-gmein.
        <fs_ofs>-kg_fab_rol       = ls_of_rollo-igmng.
        <fs_ofs>-meins_fab_rol    = ls_of_rollo-gmein.

      ENDIF.

* Obtenemos datos del secuenciador.
      SELECT SINGLE *
        INTO @DATA(ls_datos_seq)
        FROM ztpp0009
        WHERE aufnr = @ls_of_bobi-zzaufnr_rollo and
              num_fabr < 100.
      IF sy-subrc = 0.

        CASE 'X'.
          WHEN ls_datos_seq-ind_bloq.
            <fs_ofs>-icon_estat = '@06@'.

          WHEN ls_datos_seq-ind_fin.
            <fs_ofs>-icon_estat = '@DF@'.
          WHEN ls_datos_seq-ind_calidad_ok.
            <fs_ofs>-icon_estat = '@EJ@'.
          WHEN OTHERS.
            CASE ls_datos_seq-stat.
              WHEN zcl_secuenciador=>gc_i0002_liberada. " Liberada
                  <fs_ofs>-icon_estat = '@5Y@'.   "Bandera Verda
              WHEN zcl_secuenciador=>gc_i0001_abierta.  "Abierta
                CLEAR <fs_ofs>-icon_estat.
              WHEN OTHERS.
            ENDCASE.
        ENDCASE.


      ENDIF.

*      CASE ls_of_bobi-stat.
*        WHEN zcl_secuenciador=>gc_i0001_abierta.  <fs_ofs>-icon_estat = ' '.      " '@BZ@'. "Rombo blau
*        WHEN zcl_secuenciador=>gc_i0002_liberada. <fs_ofs>-icon_estat = '@5Y@'.    "Bandera verde
*        WHEN zcl_secuenciador=>gc_i0045_out.      <fs_ofs>-icon_estat = '@DF@'. "Finalizado ->Bandera a quadres
**        WHEN .
*        WHEN OTHERS.
*      ENDCASE.

    ENDLOOP.

* Calcular porcentaje de kg.bobinas ajustadas sobre el total de kg.presupuestados netos.
    IF gr_capac_asig->g_kg_netos_presup <> 0. "Evitar DUMP division / 0
      g_fabneta_porc_bobinas = ( g_fabneta_kg_bobinas_normaliz * 100 ) / ( gr_capac_asig->g_kg_netos_presup - gr_capac_asig->g_kg_ajust_capac ).
    ELSE.
      CLEAR g_fabneta_porc_bobinas.
    ENDIF.

  ENDMETHOD.
  METHOD get_ofs_abiertas_fecha.

    TYPES: BEGIN OF ty_of_bobi,
             aufnr         TYPE aufnr,
             zzkunnr1      TYPE zzkunnr10,
             zzebeln1      TYPE zzebeln1,
             zzebelp1      TYPE zzebelp1,
             zzfec_entreg1 TYPE zzfec_entreg1,
             zzurgt1       TYPE zzurgt1,
             zzaufnr_rollo TYPE zzaufnr_rollo1,
             gmein         TYPE meins,
             plnbez        TYPE matnr,
             gltrp         TYPE co_gltrp,
             gamng         TYPE gamng,
             igmng         TYPE co_igmng,
             stat          TYPE j_status,
           END OF ty_of_bobi.

    CONSTANTS: lc_zi01 TYPE auart VALUE 'ZI01',
               lc_zi02 TYPE auart VALUE 'ZI02'.

    DATA: lt_of_bobi  TYPE TABLE OF ty_of_bobi,
          lv_aj_ancho LIKE me->g_fabneta_kg_bobinas,
          lv_aj_gram  LIKE me->g_fabneta_kg_bobinas.

    CLEAR: g_fabneta_kg_bobinas , g_fabneta_kg_cabos,
           g_fabneta_porc_bobinas , gt_ofs_pend[],
           lt_of_bobi[].

* Obtenemos datos de OFs de bobinas/cabos por fechas
    SELECT a~aufnr , a~zzkunnr1 , a~zzebeln1 , a~zzebelp1, a~zzfec_entreg1, a~zzurgt1, a~zzaufnr_rollo ,
           b~gmein , b~plnbez ,  b~gltrp , b~gamng , b~igmng , j~stat " GAMNG->kg plan bob  // IGMNG->kg.fabricados bob. // ZZAUFNR_ROLLO
      INTO TABLE @lt_of_bobi
      FROM aufk AS a
      INNER JOIN afko AS b ON a~aufnr = b~aufnr
      INNER JOIN jest AS j ON j~objnr = a~objnr
      WHERE a~aufnr IN @ir_aufnr AND
            a~auart = @lc_zi02 AND
            a~werks = @gr_capac_asig->g_werks AND
            j~stat EQ @zcl_secuenciador=>gc_i0001_abierta AND
            j~inact = ' '.

    LOOP AT lt_of_bobi INTO DATA(ls_of_bobi).

* Si la OF está en estado CTEC y tiene 0 kg, no se muestra
      IF ls_of_bobi-stat = zcl_secuenciador=>gc_i0045_out AND ls_of_bobi-igmng = 0.

        CONTINUE.

      ENDIF.

      APPEND INITIAL LINE TO gt_ofs_pend ASSIGNING FIELD-SYMBOL(<fs_ofs>).

      <fs_ofs>-werks            = gr_capac_asig->g_werks.
      <fs_ofs>-matnr            = ls_of_bobi-plnbez.
      <fs_ofs>-maktx            = zclpp_recetas_reparto_pulper=>obtener_descr_material( <fs_ofs>-matnr ).
      <fs_ofs>-aufnr            = ls_of_bobi-aufnr.
      <fs_ofs>-kg_plan_bobi     = ls_of_bobi-gamng.
      <fs_ofs>-meins_plan_bobi  = ls_of_bobi-gmein.
      <fs_ofs>-kg_fabr_bobi     = ls_of_bobi-igmng.
      <fs_ofs>-meins_fab_bobi   = ls_of_bobi-gmein.
      <fs_ofs>-fecha_fab        = ls_of_bobi-gltrp.


      CALL METHOD zclpp_capacidad_asignada=>get_ancho_gramaje_material
        EXPORTING
          i_matnr   = <fs_ofs>-matnr
        IMPORTING
          o_ancho   = <fs_ofs>-ancho_bob
          o_gramaje = <fs_ofs>-gramaje
          o_matkl   = <fs_ofs>-matkl.

* Acumulamos Kg. de bobinas/cabos
      IF <fs_ofs>-ancho_bob >= 1340.

        g_fabneta_kg_bobinas = g_fabneta_kg_bobinas + <fs_ofs>-kg_plan_bobi.

* Ajuste de kg.bobina
        lv_aj_ancho = <fs_ofs>-kg_plan_bobi - ( ( gr_capac_asig->gc_ancho_medio    * <fs_ofs>-kg_plan_bobi ) /  <fs_ofs>-ancho_bob ).
        lv_aj_gram  = <fs_ofs>-kg_plan_bobi - ( ( gr_capac_asig->gc_gramaje_medio  * <fs_ofs>-kg_plan_bobi ) /  <fs_ofs>-gramaje  ).

* Acumular kg.bobina ajustados
        g_fabneta_kg_bobinas_normaliz = g_fabneta_kg_bobinas_normaliz + ( <fs_ofs>-kg_plan_bobi + lv_aj_ancho + lv_aj_gram ).

      ELSE.

        g_fabneta_kg_cabos = g_fabneta_kg_cabos + <fs_ofs>-kg_plan_bobi.

      ENDIF.

* Obtenemos datos del rollo asociado a la bobina/cabo
      <fs_ofs>-vbeln     = ls_of_bobi-zzebeln1.
      <fs_ofs>-posnr     = ls_of_bobi-zzebelp1.
      <fs_ofs>-etenr     = ls_of_bobi-zzurgt1.
      <fs_ofs>-fecha_ent = ls_of_bobi-zzfec_entreg1.
      <fs_ofs>-kunnr     = ls_of_bobi-zzkunnr1.
      <fs_ofs>-desc_cli  = zclpp_capacidad_asignada=>get_descripcion_cliente( <fs_ofs>-kunnr ).

      SELECT SINGLE a~aufnr , b~gmein , b~plnbez , b~gltrp , b~gamng , b~igmng " GAMNG->kg plan rollo  // IGMNG->kg.fabricados rollo // ZZAUFNR_ROLLO
        INTO @DATA(ls_of_rollo)
        FROM aufk AS a
        INNER JOIN afko AS b ON a~aufnr = b~aufnr
        WHERE b~aufnr = @ls_of_bobi-zzaufnr_rollo AND
              a~auart = @lc_zi01.

      IF sy-subrc = 0.

        <fs_ofs>-aufnr_rol        = ls_of_rollo-aufnr.
        <fs_ofs>-matnr_rol        = ls_of_rollo-plnbez.
        <fs_ofs>-maktx_rol        = zclpp_recetas_reparto_pulper=>obtener_descr_material( <fs_ofs>-matnr_rol ).

        CALL METHOD zclpp_capacidad_asignada=>get_ancho_gramaje_material
          EXPORTING
            i_matnr = <fs_ofs>-matnr_rol
          IMPORTING
            o_ancho = <fs_ofs>-ancho_rol.

        <fs_ofs>-kg_plan_rol      = ls_of_rollo-gamng.
        <fs_ofs>-meins_plan_rol   = ls_of_rollo-gmein.
        <fs_ofs>-kg_fab_rol       = ls_of_rollo-igmng.
        <fs_ofs>-meins_fab_rol    = ls_of_rollo-gmein.

      ENDIF.

* Obtenemos datos del secuenciador.
      SELECT SINGLE *
        INTO @DATA(ls_datos_seq)
        FROM ztpp0009
        WHERE aufnr = @ls_of_bobi-zzaufnr_rollo AND
              num_fabr < 100.
      IF sy-subrc = 0.

        CASE 'X'.

          WHEN ls_datos_seq-ind_bloq.

            <fs_ofs>-icon_estat = '@06@'.

          WHEN ls_datos_seq-ind_fin.

            <fs_ofs>-icon_estat = '@DF@'.

          WHEN ls_datos_seq-ind_calidad_ok.

            <fs_ofs>-icon_estat = '@EJ@'.

          WHEN OTHERS.

            CASE ls_datos_seq-stat.

              WHEN zcl_secuenciador=>gc_i0001_abierta.  "Abierta

                CLEAR <fs_ofs>-icon_estat.

              WHEN OTHERS.

            ENDCASE.

        ENDCASE.

      ENDIF.

    ENDLOOP.

* Calcular porcentaje de kg.bobinas ajustadas sobre el total de kg.presupuestados netos.
    IF gr_capac_asig->g_kg_netos_presup <> 0. "Evitar DUMP division / 0

      g_fabneta_porc_bobinas = ( g_fabneta_kg_bobinas_normaliz * 100 ) / ( gr_capac_asig->g_kg_netos_presup - gr_capac_asig->g_kg_ajust_capac ).

    ELSE.

      CLEAR g_fabneta_porc_bobinas.

    ENDIF.

  ENDMETHOD.
  METHOD get_pedidos_abiertos.

    CONSTANTS: gc_zint TYPE char4  VALUE 'ZINT', "Compras
               gc_zta  TYPE char3 VALUE 'ZTA'.   "Ventas

    DATA: lr_lifnr  TYPE RANGE OF lifnr.
    DATA: lr_vkorg  TYPE RANGE OF vbak-vkorg.
    DATA: l_ebelp TYPE ebelp.

    CLEAR: lr_vkorg , lr_lifnr , ot_repartos_abiertos.

* Obtenemos proveedores del centro.
    SELECT lifnr , name1
      INTO TABLE @DATA(lt_lifnr)
      FROM lfa1
      WHERE werks = @i_werks.
    IF sy-subrc = 0.
      LOOP AT lt_lifnr INTO DATA(ls_lifnr).
        lr_lifnr = VALUE #( ( sign = 'I'  option = 'EQ'  low = ls_lifnr-lifnr )
                           ).
      ENDLOOP.
    ENDIF.

* Obtener pedidos compra
    SELECT a~ebeln ,
           b~ebelp , b~meins , b~matnr , b~matkl ,
           c~etenr , c~glmng , c~eindt , c~menge ,
           v~kunnr
      INTO TABLE @DATA(lt_datos_compra)
      FROM ekko AS a
      INNER JOIN ekpo AS b ON a~ebeln = b~ebeln
      INNER JOIN eket AS c ON b~ebeln = c~ebeln AND b~ebelp = c~ebelp
      INNER JOIN ekpv AS v ON b~ebeln = v~ebeln AND b~ebelp = v~ebelp
      WHERE a~lifnr       IN @lr_lifnr
        AND a~bsart       EQ @gc_zint
        AND a~reswk       <> @space
        AND b~elikz       EQ @space
        AND b~loekz       EQ @space
        AND b~zzbloq_plan EQ @space
        AND ( a~zzsegcal <> '2' AND a~zzsegcal <> '3' )
        AND b~zzbloq_fabr <> 'X'
        AND b~eglkz       <> 'X'
        AND b~zzabgru     EQ @space
        AND b~retpo       <> 'X'
        AND v~kunnr       = @i_kunnr
        AND b~matnr       = @i_matnr.

    LOOP AT lt_datos_compra INTO DATA(ls_datos_compra).

      APPEND INITIAL LINE TO ot_repartos_abiertos ASSIGNING FIELD-SYMBOL(<fs_rep_abie>).
      <fs_rep_abie>-werks      = i_werks.
      <fs_rep_abie>-tp_pedido  = 'C'.
      <fs_rep_abie>-vbeln      = ls_datos_compra-ebeln.
      <fs_rep_abie>-posnr      = ls_datos_compra-ebelp.
      <fs_rep_abie>-etenr      = ls_datos_compra-etenr.
      <fs_rep_abie>-menge_ped  = ls_datos_compra-menge.
      <fs_rep_abie>-meins_ped  = ls_datos_compra-meins.
      <fs_rep_abie>-meins_pte  = ls_datos_compra-meins.
      <fs_rep_abie>-fecha_ent  = ls_datos_compra-eindt.

* Cálculo de Kg.pendientes
      IF ls_datos_compra-glmng > <fs_rep_abie>-menge_ped.
        <fs_rep_abie>-menge_pte = 0.
      ELSE.
        <fs_rep_abie>-menge_pte =  <fs_rep_abie>-menge_ped - ls_datos_compra-glmng. "GLMNG= cant.suministrada
      ENDIF.

    ENDLOOP.

*****************************
*** Obtener pedidos venta ***
*****************************

    SELECT t~vkorg
      INTO TABLE @DATA(lt_vkorg)
        FROM tvko AS t
      INNER JOIN t001k AS k ON k~bukrs = t~bukrs
      INNER JOIN t001w AS w ON k~bwkey = w~bwkey
      WHERE w~werks = @i_werks.


    LOOP AT lt_vkorg INTO DATA(ls_vkorg).
      lr_vkorg = VALUE #( ( sign = 'I'  option = 'EQ'  low = ls_vkorg-vkorg )
                         ).
    ENDLOOP.

    SELECT k~vbeln , k~kunnr , p~posnr , p~matnr , p~matkl ,
           r~etenr , r~lifsp , r~edatu , r~wmeng , r~vrkme , r~bmeng
      FROM vbak AS k
      INNER JOIN vbap AS p  ON p~vbeln  = k~vbeln
      INNER JOIN vbep AS r  ON r~vbeln  = p~vbeln AND r~posnr = p~posnr
      INTO TABLE @DATA(lt_datos_ventas)
      WHERE k~vkorg       IN @lr_vkorg
        AND k~auart       EQ @gc_zta "OR auart EQ gc_ztas )
        AND k~lifsk       EQ @space
        AND k~zzsegcal    = ' '
*        AND st~lfsta      EQ 'C'
        AND p~pstyv = 'TAN'
        AND p~abgru EQ @space
        AND r~wmeng > 0
        AND k~kunnr = @i_kunnr
        AND p~matnr = @i_matnr.
    .

    SELECT vbeln , posnr
      FROM vbup INTO TABLE @DATA(lt_vbup)
      FOR ALL ENTRIES IN @lt_datos_ventas
      WHERE vbeln = @lt_datos_ventas-vbeln AND
            posnr = @lt_datos_ventas-posnr AND
            lfsta EQ 'C'. "estatus de entrega de la posicion


    IF sy-subrc EQ 0.
      LOOP AT lt_vbup INTO DATA(ls_vbup).
        DELETE lt_datos_ventas WHERE vbeln = ls_vbup-vbeln AND posnr = ls_vbup-posnr.
      ENDLOOP.
    ENDIF.


    LOOP AT lt_datos_ventas INTO DATA(ls_datos_ventas).

      APPEND INITIAL LINE TO ot_repartos_abiertos ASSIGNING <fs_rep_abie>.
      <fs_rep_abie>-werks      = i_werks.
      <fs_rep_abie>-tp_pedido  = 'V'.
      <fs_rep_abie>-vbeln      = ls_datos_ventas-vbeln.
      <fs_rep_abie>-posnr      = ls_datos_ventas-posnr.
      <fs_rep_abie>-etenr      = ls_datos_ventas-etenr.
      <fs_rep_abie>-menge_ped  = ls_datos_ventas-wmeng.
      <fs_rep_abie>-meins_ped  = ls_datos_ventas-vrkme.
      <fs_rep_abie>-meins_pte  = ls_datos_ventas-vrkme.
      <fs_rep_abie>-fecha_ent  = ls_datos_ventas-edatu.

* Cálculo de Kg.pendientes
      IF <fs_rep_abie>-menge_ped > ls_datos_ventas-bmeng.
        <fs_rep_abie>-menge_pte = <fs_rep_abie>-menge_ped - ls_datos_ventas-bmeng.
      ELSE.
        <fs_rep_abie>-menge_pte = 0.
      ENDIF.

    ENDLOOP.

    SORT ot_repartos_abiertos[] BY fecha_ent DESCENDING.


* Una vez tenemos compras + ventas, buscamos info de su OF.
    LOOP AT ot_repartos_abiertos ASSIGNING <fs_rep_abie>.

      l_ebelp = <fs_rep_abie>-posnr.

      CALL METHOD zclpp_capacidad_asignada=>get_orden_fabric_pedido
        EXPORTING
          i_pedido      = <fs_rep_abie>-vbeln
          i_posicion    = l_ebelp
          i_reparto     = <fs_rep_abie>-etenr
        IMPORTING
          o_of_asignada = <fs_rep_abie>-aufnr_bob
*         o_estat       =
          o_kg_plan     = <fs_rep_abie>-menge_teo
          o_kg_fabr     = <fs_rep_abie>-menge_fab
          o_meins       = <fs_rep_abie>-meins_teo
*         o_fecha_fabr  =
        .

      <fs_rep_abie>-meins_fab = <fs_rep_abie>-meins_teo.
      <fs_rep_abie>-meins_pte_of = <fs_rep_abie>-meins_teo.

* Cálculo de Kg.pendientes OF bobina
      IF <fs_rep_abie>-menge_teo > <fs_rep_abie>-menge_fab.
        <fs_rep_abie>-menge_pte_of = <fs_rep_abie>-menge_teo - <fs_rep_abie>-menge_fab.
      ELSE.
        <fs_rep_abie>-menge_pte_of = 0.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD get_stock_x_cliente.

    DATA: lr_matnr TYPE ttyr_matnr.
    DATA: lr_kunnr TYPE ttyr_matnr.

    CLEAR: lr_matnr , lr_kunnr , os_stock.

* Si entran valores individuales, movemos a los rangos locales para filtrar.
    IF i_matnr IS NOT INITIAL.
      lr_matnr  = VALUE #( sign = 'I' option = 'EQ' ( low = i_matnr ) ).
    ELSE.
      lr_matnr = ir_matnr.
    ENDIF.

    IF i_kunnr IS NOT INITIAL.
      lr_kunnr  = VALUE #( sign = 'I' option = 'EQ' ( low = i_kunnr ) ).
    ELSE.
      lr_kunnr = ir_kunnr.
    ENDIF.

* Select copiada de Tx.ZPP0001/Rep.ZRPP0042.
    SELECT b~mtart   , a~matnr , b~matkl , b~zzcalidad , b~zzgramaje , b~zzancho ,
           b~zzlargo , a~werks , a~lgort , a~charg , b~meins ,
           a~clabs   , a~cumlm , a~cinsm , a~ceinm , a~cspem , a~cretm ,
           a~cvmla   , a~cvmum , a~cvmin , a~cvmei , a~cvmsp , a~cvmre ,
           a~ersda   ,a~laeda
    INTO TABLE @DATA(lt_stock)
    FROM mchb AS a
    INNER JOIN mara AS b ON b~matnr = a~matnr
    WHERE a~matnr IN @lr_matnr AND
          b~matkl IN @ir_matkl AND
          a~werks   = @i_werks
    AND a~lgort   = '1040'
    AND ( a~clabs <> 0 ).

    LOOP AT lt_stock INTO DATA(ls_stock).

      CALL METHOD zclpp_creacion_ofs=>obtener_caract_lote
        EXPORTING
          i_matnr   = ls_stock-matnr
          i_charg   = ls_stock-charg
        IMPORTING
          os_caract = DATA(ls_caract).

*      CHECK ls_caract-kunnr = i_kunnr.
      CHECK ls_caract-kunnr IN lr_kunnr AND ls_caract-kunnr IS NOT INITIAL.

      ASSIGN ot_stock[ kunnr = ls_caract-kunnr ] TO FIELD-SYMBOL(<fs_stock>).
      IF sy-subrc = 0.
        CASE ls_caract-de.
          WHEN 'A'. <fs_stock>-menge_a   = <fs_stock>-menge_a   + ls_stock-clabs.
          WHEN 'R'. <fs_stock>-menge_r   = <fs_stock>-menge_r   + ls_stock-clabs.
          WHEN ' '. <fs_stock>-menge_sin = <fs_stock>-menge_sin + ls_stock-clabs.
          WHEN 'P'. <fs_stock>-menge_p   = <fs_stock>-menge_p   + ls_stock-clabs.
          WHEN OTHERS.
        ENDCASE.

      ELSE.
        APPEND INITIAL LINE TO ot_stock ASSIGNING <fs_stock>.
        <fs_stock>-kunnr      = ls_caract-kunnr.
        <fs_stock>-kunnr = |{ <fs_stock>-kunnr ALPHA = IN }|. "DTM
        <fs_stock>-desc_cli   =  zclpp_capacidad_asignada=>get_descripcion_cliente( <fs_stock>-kunnr ).
        <fs_stock>-matnr      = ls_stock-matnr.
        <fs_stock>-maktx      =  zclpp_recetas_reparto_pulper=>obtener_descr_material( <fs_stock>-matnr ).
        <fs_stock>-meins_a    = 'KG'.
        <fs_stock>-meins_r    = 'KG'.
        <fs_stock>-meins_sin  = 'KG'.
        <fs_stock>-meins_p    = 'KG'.

        CASE ls_caract-de.
          WHEN 'A'. <fs_stock>-menge_a   = ls_stock-clabs.
          WHEN 'R'. <fs_stock>-menge_r   = ls_stock-clabs.
          WHEN ' '. <fs_stock>-menge_sin = ls_stock-clabs.
          WHEN 'P'. <fs_stock>-menge_p   = ls_stock-clabs.
          WHEN OTHERS.
        ENDCASE.
      ENDIF.

    ENDLOOP.

    IF lines( ot_stock ) = 0 AND
       i_kunnr IS NOT INITIAL AND
       i_matnr IS NOT INITIAL.

      os_stock-kunnr      = i_kunnr.
      os_stock-desc_cli   =  zclpp_capacidad_asignada=>get_descripcion_cliente( i_kunnr ).
      os_stock-matnr      = i_matnr.
      os_stock-maktx      =  zclpp_recetas_reparto_pulper=>obtener_descr_material( i_matnr ).

    ENDIF.

    IF line_exists( ot_stock[ 1 ] ).
      os_stock = CORRESPONDING #( ot_stock[ 1 ] ).
    ENDIF.


  ENDMETHOD.
  METHOD instanciar_semana.

    DATA: l_kg_fab_neta_bob LIKE or_semana_of->g_fabneta_kg_bobinas.


    o_rc = '00'.

    or_semana_of = NEW zclpp_creacion_ofs( i_werks  = i_werks
                                           i_mjahr  = i_mjahr
                                           i_semana = i_semana ).

    CALL METHOD zclpp_capacidad_asignada=>instanciar_semana
      EXPORTING
        i_werks              = i_werks
        i_mjahr              = i_mjahr
        i_semana             = i_semana
        i_sw_no_act_sin_asig = 'X'
      IMPORTING
        or_semana            = or_semana_of->gr_capac_asig
        o_rc                 = o_rc.

    CHECK o_rc = '00'.

**    CALL METHOD or_semana_of->get_of_semana_selec_cooispi( ).
    CALL METHOD or_semana_of->get_ofs_abiertas_fecha
      EXPORTING
        i_werks = i_werks.


* A partir de los pedidos asignada a una semana, bifurcamos entre repartos con OF (ALV sup.)
* y repartos sin OF(ALV inf.).

    LOOP AT or_semana_of->gr_capac_asig->gt_pedidos_asig INTO DATA(ls_pedido).

      IF ls_pedido-aufnr IS INITIAL.

        APPEND INITIAL LINE TO or_semana_of->gt_repartos_sin_of ASSIGNING FIELD-SYMBOL(<fs_sin_of>).
        <fs_sin_of> = CORRESPONDING #( ls_pedido ).

      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD navegar_semana.


    CALL METHOD zclpp_capacidad_asignada=>cambiar_semana
      EXPORTING
        i_tp_cambio = i_tp_cambio
      IMPORTING
        o_rc        = o_rc
      CHANGING
        cr_semana   = cr_semana.

    FREE: cr_semana_of.

    CALL METHOD instanciar_semana
      EXPORTING
        i_werks      = cr_semana->g_werks
        i_mjahr      = cr_semana->g_semana(4)
        i_semana     = cr_semana->g_semana+4(2)
      IMPORTING
        or_semana_of = cr_semana_of
        o_rc         = o_rc.


  ENDMETHOD.
  METHOD obtener_caract_lote.

    DATA: lv_object            TYPE objnum,
          lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
          lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
          lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
          ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
          lt_return            TYPE bapiret2_tab,
          ls_alloc_values_char TYPE bapi1003_alloc_values_char,
          lv_num               TYPE i,
          lv_fec_n             TYPE n LENGTH 8.
    REFRESH: lt_alloc_values_num, lt_alloc_values_char.
    REFRESH: lt_alloc_values_curr, lt_return.
    CLEAR: lv_object, ls_alloc_values_char.
    CLEAR: lt_alloc_values_num, lt_alloc_values_char.
    CLEAR: lt_alloc_values_curr, lt_return.

    clear os_caract.

    CONCATENATE i_matnr i_charg INTO lv_object.

    CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
      EXPORTING
        objectkey       = lv_object
        objecttable     = 'MCH1'
        classnum        = 'Z_BOBINA'
        classtype       = '023'
*       KEYDATE         = SY-DATUM
*       UNVALUATED_CHARS       = ' '
*       LANGUAGE        = SY-LANGU
*   IMPORTING
*       STATUS          =
*       STANDARDCLASS   =
      TABLES
        allocvaluesnum  = lt_alloc_values_num
        allocvalueschar = lt_alloc_values_char
        allocvaluescurr = lt_alloc_values_curr
        return          = lt_return.

    TRY.
        os_caract-kunnr = lt_alloc_values_char[ charact = 'Z_CLIENTE' ]-value_neutral.
        CONDENSE os_caract-kunnr.
      CATCH cx_root .
    ENDTRY.

    TRY.
        os_caract-vbeln = lt_alloc_values_char[ charact = 'Z_PEDIDO' ]-value_neutral.
        CONDENSE os_caract-vbeln.
      CATCH cx_root .
    ENDTRY.

    TRY.
        os_caract-posnr = lt_alloc_values_char[ charact = 'Z_POSICION' ]-value_neutral.
        CONDENSE os_caract-posnr.
      CATCH cx_root .
    ENDTRY.

    TRY.
        os_caract-de = lt_alloc_values_char[ charact = 'LOBM_UDCODE' ]-value_neutral+9(1).
      CATCH cx_root .
    ENDTRY.

    TRY.
        lv_num = lt_alloc_values_num[ charact = 'Z_FECHA_FABRICACION' ]-value_from.
        os_caract-fecha_fab = lv_num.
      CATCH cx_root .
    ENDTRY.


*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'Z_CLIENTE'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_kunnr = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_kunnr.
*  ENDIF.
*
*
** PEDIDO:
*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'Z_PEDIDO'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_pedido = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_pedido.
*  ENDIF.
*
** POSICIÓN:
*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'Z_POSICION'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_posicion = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_posicion.
*  ENDIF.
*
*
** DECISION DE EMPLEO
*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'LOBM_UDCODE'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_vcode = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_vcode.
*  ENDIF.
*
*
** Papelera - Ubicacion Bobina - UDEFINE 27/06/2018
*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'Z_UBIC_HPAP'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_ubic = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_ubic.
*  ENDIF.
*
** Papelera - MOtivo rechazo
*  CLEAR ls_alloc_values_char.
*  READ TABLE lt_alloc_values_char INTO ls_alloc_values_char
*             WITH KEY charact = 'ZPPI_MOTIVO_REPROCESO_BOBINA'.
*
*  IF ls_alloc_values_char-value_neutral IS NOT INITIAL.
*    CONDENSE ls_alloc_values_char-value_neutral.
*    p_motivo_rechazo = ls_alloc_values_char-value_neutral.
*  ELSE.
*    CLEAR p_motivo_rechazo.
*  ENDIF.
*
*
** FECHA FABRICACIÓN:
*  CLEAR ls_alloc_values_num.
*  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
*                               WITH KEY charact = 'Z_FECHA_FABRICACION'.
*  IF ls_alloc_values_num IS NOT INITIAL.
*    CLEAR: lv_num, lv_fec_n.
*    lv_num = ls_alloc_values_num-value_from.
*    lv_fec_n = lv_num.
*    p_hsdat = lv_fec_n .
*  ELSE.
*    p_hsdat = '00000000'.
*  ENDIF.
*
**LONGITUD BOBINA
*  DATA l_longitud TYPE i.
*  CLEAR ls_alloc_values_num.
*  READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
*                               WITH KEY charact = 'Z_LONGITUD_B'.
*  IF ls_alloc_values_num IS NOT INITIAL.
*    CLEAR: lv_num, lv_fec_n.
*    lv_num = ls_alloc_values_num-value_from.
*    l_longitud = lv_num.
*    p_longitud = l_longitud.
*  ELSE.
*    p_hsdat = '00000000'.
*  ENDIF.




  ENDMETHOD.
  METHOD popup_msg_creacion_ofs.

*    DATA: lt_msg TYPE esp1_message_tab_type,
*          ls_msg TYPE esp1_message_wa_type.


    IF line_exists( it_msg[ msgty = 'E' ] ).
      r_rc_error = 'X'.
    ENDIF.

    IF r_rc_error = 'X' OR i_forzar_popup = 'X'.

      CALL FUNCTION 'C14Z_MESSAGES_SHOW_AS_POPUP'
        TABLES
          i_message_tab = it_msg.

    ENDIF.


  ENDMETHOD.
  METHOD procesar_datos_creacion_of.
    CONSTANTS: gc_aufa_bob TYPE aufart VALUE 'ZI02',
               gc_aufa_rol TYPE aufart VALUE 'ZI01'.
    DATA: lt_msg TYPE esp1_message_tab_type,
          ls_msg TYPE esp1_message_wa_type,
          l_txt  TYPE char10,
          l_num  TYPE numc2.

    CLEAR: lt_msg.

    o_rc = '00'.

* Avisos de fechas
    IF avisos_fecha_fabricacion_of( ) <> '1'.
      o_rc = '01'.
      EXIT.
    ENDIF.

* Antes de procesar el rollo, validamos si hay cabo, para generar ID_PEDIDO y grabarlo
* en una de las 3 pos. de datos adicionales del rollo.
    IF gs_datos_of_cabo IS NOT INITIAL.

      gs_datos_of_cabo-order_type   = gc_aufa_bob.
      gs_datos_of_cabo-vbeln        = get_new_id_pedido_cabo( ).
      gs_datos_of_cabo-posnr        = 10.
      gs_datos_of_cabo-etenr        = 1.

      IF gs_datos_of_rollo-fec_entrega2 IS INITIAL.

        gs_datos_of_cabo-fec_entrega        = gs_datos_of_rollo-fec_entrega.
        gs_datos_of_rollo-fec_entrega2      = gs_datos_of_rollo-fec_entrega. "DTM

      ELSEIF gs_datos_of_rollo-fec_entrega2 > gs_datos_of_rollo-fec_entrega.

        gs_datos_of_cabo-fec_entrega        = gs_datos_of_rollo-fec_entrega.

      ELSE.

        gs_datos_of_cabo-fec_entrega        = gs_datos_of_rollo-fec_entrega2.

      ENDIF.
* Incorporamos datos del cabo en los datos adicionales de OF Rollo
      IF gs_datos_of_rollo-kunnr2 IS INITIAL.
        gs_datos_of_rollo-kunnr2       = gs_datos_of_cabo-kunnr.
        gs_datos_of_rollo-vbeln2       = gs_datos_of_cabo-vbeln.
        gs_datos_of_rollo-posnr2       = gs_datos_of_cabo-posnr.
        gs_datos_of_rollo-etenr2       = gs_datos_of_cabo-etenr.
        gs_datos_of_rollo-fec_entrega2 = gs_datos_of_rollo-fec_entrega. "Le ponemos la misma f.entrega que la bobina
      ELSEIF gs_datos_of_rollo-kunnr3 IS INITIAL.
        gs_datos_of_rollo-kunnr3 = gs_datos_of_cabo-kunnr.
        gs_datos_of_rollo-vbeln3 = gs_datos_of_cabo-vbeln.
        gs_datos_of_rollo-posnr3 = gs_datos_of_cabo-posnr.
        gs_datos_of_rollo-etenr3 = gs_datos_of_cabo-etenr.

        IF gs_datos_of_rollo-fec_entrega2 > gs_datos_of_rollo-fec_entrega.
          gs_datos_of_rollo-fec_entrega3 = gs_datos_of_rollo-fec_entrega.
        ELSE.
          gs_datos_of_rollo-fec_entrega3 = gs_datos_of_rollo-fec_entrega2.
        ENDIF.
      ENDIF.

    ENDIF.


* Creación OF Rollo.
    CLEAR gs_datos_of_rollo-aufnr_rollo. " Este campo sólo se informa para bobinas/cabos
    gs_datos_of_rollo-order_type = gc_aufa_rol.

    CALL METHOD zclpp_creacion_ofs=>crear_of
      CHANGING
        cs_datos_creacion = gs_datos_of_rollo.

    CALL METHOD zclpp_creacion_ofs=>control_errores_creacion_of
      EXPORTING
        is_datos_of = gs_datos_of_rollo
        i_txt_tp_of = 'rollo'
      CHANGING
        ct_msg_err  = lt_msg.

    CHECK popup_msg_creacion_ofs( lt_msg ) = ' '.

* Crear OF bobina(s).
    l_num = 0.
    LOOP AT gt_datos_of_rep_selec INTO DATA(ls_datos_of).

      CHECK NOT line_exists( lt_msg[ msgty = 'E' ] ).

      ls_datos_of-order_type  = gc_aufa_bob.
      ls_datos_of-aufnr_rollo = gs_datos_of_rollo-aufnr.

      CALL METHOD zclpp_creacion_ofs=>crear_of
        EXPORTING
          i_rollo_list_mat  = gs_datos_of_rollo-matnr
        CHANGING
          cs_datos_creacion = ls_datos_of.

**      l_num = l_num + 1.
      l_txt = |bobina|. "|bobina { l_num }|.

      CALL METHOD zclpp_creacion_ofs=>control_errores_creacion_of
        EXPORTING
          is_datos_of = ls_datos_of
          i_txt_tp_of = l_txt
        CHANGING
          ct_msg_err  = lt_msg.

    ENDLOOP.

    CHECK popup_msg_creacion_ofs( lt_msg ) = ' '.

* Crear OF cabo, si procede.
    IF gs_datos_of_cabo IS NOT INITIAL.

* Informar OF rollo asociada al cabo/OF cabo
      gs_datos_of_cabo-aufnr_rollo  = gs_datos_of_rollo-aufnr.



      CALL METHOD zclpp_creacion_ofs=>crear_of
        EXPORTING
          i_rollo_list_mat  = gs_datos_of_rollo-matnr
        CHANGING
          cs_datos_creacion = gs_datos_of_cabo.

      CALL METHOD zclpp_creacion_ofs=>control_errores_creacion_of
        EXPORTING
          is_datos_of = gs_datos_of_cabo
          i_txt_tp_of = 'cabo'
        CHANGING
          ct_msg_err  = lt_msg.
    ENDIF.

    CHECK popup_msg_creacion_ofs( it_msg         = lt_msg
                                  i_forzar_popup = 'X'   ) = ' '.

  ENDMETHOD.
  METHOD refrescar_tablas_alvs.

    CLEAR : me->gt_ofs_pend , me->gt_repartos_sin_of.

* Refrescamos ALV SUP.
    IF i_flag IS INITIAL.

      CALL METHOD get_of_semana_selec_cooispi( ).

    ELSE.

      CALL METHOD get_ofs_abiertas_fecha
        EXPORTING
          i_werks = i_werks.

    ENDIF.

* Actualizamos los pedidos asignados a la semana selec.
    CALL METHOD gr_capac_asig->get_pedidos_asignados
      EXPORTING
        iw_no_ofs = 'X'.

* Trasladamos los pedidos asignados SIN OF, para el ALV inferior
    LOOP AT gr_capac_asig->gt_pedidos_asig INTO DATA(ls_pedido) WHERE aufnr IS INITIAL.

      APPEND INITIAL LINE TO me->gt_repartos_sin_of ASSIGNING FIELD-SYMBOL(<fs_sin_of>).
      <fs_sin_of> = CORRESPONDING #( ls_pedido ).

    ENDLOOP.

  ENDMETHOD.
  METHOD replanificar_of.

    DATA: ls_orderdata  TYPE bapi_pi_order_change,
          ls_orderdatax TYPE bapi_pi_order_changex,
          ls_return     TYPE bapiret2,
          lw_flag_rollo TYPE flag,
          lt_msg        TYPE esp1_message_tab_type,
          ls_msg        LIKE LINE OF lt_msg.

    CLEAR lw_flag_rollo.

    LOOP AT it_ofs_pend_selec INTO DATA(ls_of).

      IF lw_flag_rollo IS INITIAL.

        CLEAR: ls_orderdata , ls_orderdatax.
        ls_orderdata-basic_end_date = i_datum.
        ls_orderdatax-basic_end_date = 'X'.
        CLEAR ls_orderdata-basic_start_date.
        ls_orderdatax-basic_start_date = 'X'.


        CALL FUNCTION 'BAPI_PROCORD_CHANGE'
          EXPORTING
            number     = ls_of-aufnr_rol
            orderdata  = ls_orderdata
            orderdatax = ls_orderdatax
          IMPORTING
            return     = ls_return.

        lw_flag_rollo = 'X'.
        IF ls_return-type = 'E'.
          CLEAR: ls_msg , lt_msg.
          ls_msg-msgid = ls_return-id.
          ls_msg-msgty = ls_return-type.
          ls_msg-msgno = ls_return-number.
          ls_msg-msgv1 = ls_return-message_v1.
          ls_msg-msgv2 = ls_return-message_v2.
          ls_msg-msgv3 = ls_return-message_v3.
          ls_msg-msgv4 = ls_return-message_v4.
          INSERT ls_msg INTO TABLE lt_msg.
          CALL FUNCTION 'C14Z_MESSAGES_SHOW_AS_POPUP'
            TABLES
              i_message_tab = lt_msg.

          o_rc = '04'.
          EXIT.
        ENDIF.

      ENDIF.

      CLEAR: ls_orderdata , ls_orderdatax.
      ls_orderdata-basic_end_date = i_datum.
      ls_orderdatax-basic_end_date = 'X'.
      ls_orderdatax-basic_start_date = 'X'.

      CALL FUNCTION 'BAPI_PROCORD_CHANGE'
        EXPORTING
          number     = ls_of-aufnr
          orderdata  = ls_orderdata
          orderdatax = ls_orderdatax
        IMPORTING
          return     = ls_return.

      IF ls_return-type = 'E'.

        CLEAR: ls_msg , lt_msg.
        ls_msg-msgid = ls_return-id.
        ls_msg-msgty = ls_return-type.
        ls_msg-msgno = ls_return-number.
        ls_msg-msgv1 = ls_return-message_v1.
        ls_msg-msgv2 = ls_return-message_v2.
        ls_msg-msgv3 = ls_return-message_v3.
        ls_msg-msgv4 = ls_return-message_v4.
        INSERT ls_msg INTO TABLE lt_msg.
        CALL FUNCTION 'C14Z_MESSAGES_SHOW_AS_POPUP'
          TABLES
            i_message_tab = lt_msg.

        o_rc = '04'.
        EXIT.
      ENDIF.


    ENDLOOP.

    IF o_rc = '04'.
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
* IMPORTING
*   RETURN        =
        .
    ELSE.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      o_rc = '00'.
      WAIT UP TO 1 SECONDS.

    ENDIF.

  ENDMETHOD.
  METHOD validar_ancho_5mm.

    DATA: l_ult_pos TYPE char1.
    DATA: l_pos TYPE n.
    DATA: l_string TYPE string.

*Calcular ancho, y restar 1.
    l_pos = strlen( i_ancho_in ).
    l_pos     = l_pos - 1.

    l_string  = i_ancho_in.

* Obtener la última posición.
    l_ult_pos = l_string+l_pos(1).

    IF l_ult_pos = '5'.
      o_ancho_calc = i_ancho_in + 5.
    ELSE.
      o_ancho_calc = i_ancho_in.
    ENDIF.


  ENDMETHOD.
  METHOD validar_lista_materiales_bom.


    DATA: l_fecha TYPE datum,
          l_kg    TYPE menge_d,
          lt_stb  TYPE STANDARD TABLE OF stpox.

    l_fecha = sy-datum.
    l_kg    = i_cantidad.

    CALL FUNCTION 'CS_BOM_EXPL_MAT_V2'
      EXPORTING
        aumgb                 = 'X'
        capid                 = 'PI01'
        datuv                 = l_fecha "sy-datum
        ehndl                 = 'X'
        emeng                 = l_kg " p_wmeng
        mehrs                 = '1'
        mmory                 = '1'
        mtnrv                 = i_matnr "p_matnr
        stlal                 = '01'
        stlan                 = '1'
        stpst                 = 0
        svwvo                 = 'X'
        werks                 = i_werks "p_werks
        vrsvo                 = 'X'
      TABLES
        stb                   = lt_stb
      EXCEPTIONS
        alt_not_found         = 1
        call_invalid          = 2
        material_not_found    = 3
        missing_authorization = 4
        no_bom_found          = 5
        no_plant_data         = 6
        no_suitable_bom_found = 7
        conversion_error      = 8
        OTHERS                = 9.
    IF sy-subrc <> 0.
      o_rc = '08'.
    ELSEIF lt_stb[] IS NOT INITIAL.
      o_rc = '00'.
    ENDIF.

  ENDMETHOD.
