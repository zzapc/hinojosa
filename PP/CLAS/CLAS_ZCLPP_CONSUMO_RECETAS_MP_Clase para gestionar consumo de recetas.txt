
class ZCLPP_CONSUMO_RECETAS_MP definition
  public
  final
  create public .

public section.

  types:
    BEGIN OF  ty_list_teorica ,
      matnr TYPE matnr,
      idnrk TYPE idnrk,
      menge TYPE menge_d,
      porc  TYPE netwr,
    END OF ty_list_teorica .
  types:
    tty_list_teorica TYPE STANDARD TABLE OF ty_list_teorica .

  class-data GT_MP type ZTTPP0036 read-only .
  class-data GT_MP_EQ type ZTTPP0037 .
  class-data GTR_ALMACENES_CAMPA type ZTTPP_RANGE_LGORT .
  class-data GC_BOBINA_PULPER type MATNR value '000000000002001764' ##NO_TEXT.
  class-data GC_WERKS_3000 type WERKS_D read-only value '3000' ##NO_TEXT.

*  class-data GT_LISTA_TEORICA type TTY_LIST_TEORICA .
  class-methods OBTENER_DATOS_RECETA_CONSUMIDA
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_T1 type FLAG
      !I_T2 type FLAG
      !I_T3 type FLAG
      !IR_FECHA_FAB type TRGR_DATE optional
      !I_FILTRO_FECHA_PULPER type FLAG optional
    exporting
      !OS_DATOS_FORM_RECETA_MP type ZSPP_FORM_RECETA_MP
      !OT_DATOS_CONSUMO type ZTPP0057_ALV300
      !O_RC type CHAR02 .
  class-methods GENERAR_CONSUMO_RECETA
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_LOTE type CHARG_D
      !I_MATNR type MATNR
      !I_LGORT type LGORT_D
      !I_OPERARIO type ZNOMBRE_OPER
    exporting
      !O_RC type CHAR02 .
  class-methods VALIDAR_LECTURA_LOTE_RF
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_LOTE type CHARG_D
    exporting
      !O_RC type CHAR02 .
  class-methods CALCULAR_PESO_BALAS_DE_ALMACEN
    importing
      !I_WERKS type WERKS_D
      !IT_MATNR type RANGE_T_MATNR
    exporting
      !OT_DATOS_MAT_CAMPA type ZTTPP_DATOS_BALAS_ALM_CAMPA .
  class-methods CLASS_CONSTRUCTOR .
  class-methods OBTENER_LOTES_MP_X_RECETA
    importing
      !I_WERKS type WERKS_D
      !IR_RECETAS type ZRRID_RECETA
      !IR_CHARG type ZPPR_CHARG_D
      !IR_FECHA_FAB type TRGR_DATE optional
      !IR_FECHA_TURNO type TRGR_DATE
      !I_T1 type FLAG
      !I_T2 type FLAG
      !I_T3 type FLAG
    exporting
      !OT_DETALLE_LOTES type ZTPP_RECETAS_DETALLE_LOTES .
  class-methods GRAFICO_CONTROL_RECETA
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_TURNO type ZTURNO
    changing
      !I_CONTAINER type ref to CL_GUI_CUSTOM_CONTAINER .
  class-methods OBTENER_INTERVALO_CTRL_RECETA
    importing
      !I_WERKS type WERKS_D
    returning
      value(R_SEGUNDOS_INTERVALO) type I .
  class-methods ES_ANTIGUO_TRATAMIENTO
    importing
      !I_WERKS type WERKS_D
    returning
      value(R_RC) type FLAG .
  class-methods GENERAR_LOTE_HERMANO
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_LOTE type CHARG_D
      !I_OPERARIO type ZNOMBRE_OPER
      !I_SW_PIS_REG type CHAR1 optional
    exporting
      !O_RC type CHAR02
      !O_LOTE_HERMANO type ZTPP0041 .
  class-methods OBTENER_NEXT_LOTE_FICTICIO
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_SW_PIS_REG type CHAR1
    exporting
      !O_SIGUIENTE_LOTE type CHARG_D .
  class-methods OBTENER_DATOS_ECONOM_MP_X_REC
    importing
      !I_WERKS type WERKS_D
      !I_RECETA type ZID_RECETA
      !I_T1 type FLAG
      !I_T2 type FLAG
      !I_T3 type FLAG
      !IR_FECHA_TURNO type TRGR_DATE
    exporting
      !OT_DATOS_ECONOMICOS type ZTTPP_RECETA_VALOR_ECON_NODEC .
  class-methods OBTENER_DAT_ACUMULADOS_RECETA
    importing
      !I_WERKS type WERKS_D
      !I_ID_RECETA type ZID_RECETA
      !I_T1 type FLAG
      !I_T2 type FLAG
      !I_T3 type FLAG
      !IR_FECHA_FAB type TRGR_DATE optional
    exporting
      !OS_DATOS_FORM_RECETA_MP type ZSPP_FORM_RECETA_MP
      !OT_DATOS_CONSUMO type ZTPP0057_ALV300
      !O_RC type CHAR02 .
  class-methods OBTENER_PRECIO_MEDIO_VARIABLE
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_KG_REALES type MENGE_D
      !I_ANY type LFGJA
      !I_MES type LFMON
    exporting
      !O_PRECIO_MEDIO_VAR type NETWR
      !O_IMPORTE_PMV type NETWR .
  class-methods OBTENER_LISTA_MAT_TEORICA
    importing
      !I_WERKS type WERKS_D
      !I_CALIDAD type ZZCALIDAD
    exporting
      !OT_LISTA_MAT type TTY_LIST_TEORICA .
  class-methods GENERAR_CONSUMO_RECETA_MIGO311
    importing
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
      !I_MATNR type MATNR
      !I_CHARG type CHARG_D
      !I_MENGE type MENGE_D
      !I_MEINS type MEINS .
protected section.
private section.

  types:
    tty_mp    TYPE STANDARD TABLE OF ztpp0036 .
  types:
    tty_mp_eq TYPE STANDARD TABLE OF ztpp0037 .
  types:
    BEGIN OF ty_preu_hist,
             werks TYPE werks,
             matnr TYPE matnr,
             lfgja TYPE lfgja,
             lfmon TYPE lfmon,
             verpr TYPE verpr,
             peinh TYPE peinh,
             stprs TYPE verpr,
           END OF ty_preu_hist .
  types:
    tty_preu_hist TYPE STANDARD TABLE OF ty_preu_hist .

  class-data GT_PRECIO_MEDIO_VARIABLE type TTY_PREU_HIST .
  class-data GT_DATOS_PRESU type ZTTPP0045 .

  class-methods OBTENER_VALOR_PRESUPUESTADO
    importing
      !I_WERKS type WERKS_D
      !I_MATNR type MATNR
      !I_KG_REALES type BRGEW
      !I_ANY type LFGJA
      !I_MES type BUMON
    exporting
      !O_VALOR_PRESUPUESTADO type NETWR .
endclass. "ZCLPP_CONSUMO_RECETAS_MP definition
class ZCLPP_CONSUMO_RECETAS_MP implementation.
*******************************************************
*                                                     *
* Validaciones realizadas:                            *
*  '01' La receta debe estar vigente (o [A]ctua)      *
*  '02' Lote no valido.                               *
*  '03' Material no válido para esta receta.          *
*                                                     *
*******************************************************

  METHOD validar_lectura_lote_rf.

    o_rc = '00'.

* Obtenemos datos de la receta, para validar que la receta está vigente.
    SELECT SINGLE *
      INTO @DATA(ls_40)
      FROM ztpp0040
      WHERE werks       = @i_werks AND
            id_receta   = @i_id_receta.
    IF sy-subrc <> 0. "La receta no existe
      o_rc = '01'.
      EXIT.
    ENDIF.

* Comprobamos que la receta esté vigente
    CALL METHOD zclpp_recetas_mp=>obtener_temporalidad_receta
      EXPORTING
        i_fecha_ini = ls_40-fecha_ini
        i_hora_ini  = ls_40-hora_ini
        i_fecha_fin = ls_40-fecha_fin
        i_hora_fin  = ls_40-hora_fin
      RECEIVING
        r_return    = DATA(l_rc).
    IF l_rc <> 'A' AND
       l_rc <> 'P' . "La receta debe estar vigente o pasada (o [A]ctual)
      o_rc = '01'.
      EXIT.
    ENDIF.

* Obtenemos el material del lote.
    SELECT SINGLE matnr
      INTO @DATA(l_matnr_lote)
      FROM mcha
      WHERE werks       = @i_werks  AND
            charg       = @i_lote.
    IF sy-subrc <> 0. "Lote no valido
      o_rc = '02'.
      EXIT.
    ENDIF.

    SELECT SINGLE *
      INTO @DATA(ls_mchb)
      FROM mchb
      WHERE matnr = @l_matnr_lote
        AND charg = @i_lote
*        AND lgort = '4002'
        AND werks = @i_werks
        AND clabs > 0.
    IF sy-subrc <> 0.
      o_rc = '03'.
      EXIT.
    ENDIF.

* El material del lote debe estar definido com MP de la receta
    SELECT SINGLE *
      INTO @DATA(ls)
      FROM ztpp0039
      WHERE werks       = @i_werks AND
            id_receta   = @i_id_receta AND
            matnr       = @l_matnr_lote.
    IF sy-subrc <> 0.
* Si el material no está en la receta, buscamos si es MP equivalente
      TRY.

* Obtenemos el material equivalente con menor "ORDEN".
          SELECT SINGLE matnr_equiv INTO @DATA(l_matnr)
            FROM ztpp0039 AS z9
            INNER JOIN ztpp0037 AS z7 ON z7~werks = z9~werks AND z7~matnr_equiv = z9~matnr
            WHERE z9~werks = @i_werks AND
                  z7~werks = @i_werks AND
              id_receta    = @i_id_receta AND
              matnr_mp     = @l_matnr_lote
              AND orden IN ( SELECT MIN( orden )
                              FROM ztpp0039 AS z9
                              INNER JOIN ztpp0037 AS z7 ON z7~werks = z9~werks AND z7~matnr_equiv = z9~matnr
                              WHERE z9~werks    = @i_werks AND
                                    z7~werks    = @i_werks AND
                                id_receta       = @i_id_receta AND
                                matnr_mp        = @l_matnr_lote
                                              ).

*            DATA(l_matnr) = gt_mp_eq[ matnr_mp = l_matnr_lote
*                                      werks    = i_werks ]-matnr_equiv.
*            SELECT SINGLE *
*              INTO @DATA(ls_39)
*              FROM ztpp0039
*              WHERE werks   = @i_werks AND
*                id_receta   = @i_id_receta AND
*                matnr       = @l_matnr.
          IF sy-subrc <> 0.
            o_rc = '04'. "Material no válido para esta receta.
            EXIT.
          ENDIF.
        CATCH cx_root .
          o_rc = '04'. "Material no válido para esta receta.
          EXIT.
      ENDTRY.


    ENDIF.

* Validamos que el lote no esté registrado en esta u otra receta
    SELECT SINGLE *
      INTO @DATA(ls_41)
      FROM ztpp0041
      WHERE werks = @i_werks AND
            charg = @i_lote.
    IF sy-subrc = 0.
      o_rc = '05'. " Ya se ha leido el lote
      EXIT.
    ENDIF.


  ENDMETHOD.
  method CALCULAR_PESO_BALAS_DE_ALMACEN.

    select matnr ,
           sum( clabs ) as menge_tot ,
           count( * )   as num_balas
      into  TABLE @data(lt_mchb) " ot_datos_mat_campa
      from mchb
      where werks  = @i_werks               and
            lgort in @gtr_almacenes_campa   and
            matnr in @it_matnr              and
            clabs > 0
      group by matnr.

      LOOP AT lt_mchb into data(ls_mchb).
        APPEND INITIAL LINE TO ot_datos_mat_campa ASSIGNING FIELD-SYMBOL(<fs>).
        <fs>-matnr         = ls_mchb-matnr .
        <fs>-menge_tot     = ls_mchb-menge_tot.
        <fs>-num_balas     = ls_mchb-num_balas.
        <fs>-meins          = 'KG'.
        <fs>-menge_bala     = <fs>-menge_tot / <fs>-num_balas.
      ENDLOOP.

  endmethod.
  METHOD class_constructor.

    SELECT *
      INTO TABLE gt_mp
      FROM ztpp0036
      WHERE lvorm = ' '.

    SELECT *
      INTO TABLE gt_mp_eq
      FROM ztpp0037
      WHERE lvorm = ' '.

* Almacenes de la campa.
    gtr_almacenes_campa = VALUE #( sign = 'I' option = 'EQ' ( low = '1000' )
                                                 ( low = '1001' )
                                                 ( low = '1002' )
                                                 ( low = '1003' )
                                                 ( low = '1004' )
                                                 ( low = '1005' )
                                                 ( low = '1006' )
                                                 ( low = '1007' )
                                                 ( low = '1008' )
                                                 ( low = '1009' )
                                                 ( low = '1010' )
                                                 ( low = '1011' )
                                                 ( low = '1012' )
                                                 ( low = '1013' )
                                                 ( low = '1014' )
                                                 ( low = '1015' )
                                                 ( low = '1016' )
                                                 ( low = '1017' )
                                                 ( low = '1018' )
                                                 ( low = '1019' ) "ni 1020 pope ni 1021
                                                 ( low = '1022' )
                                                 ( low = '1023' )
                                                 ( low = '1024' )
                                                 ( low = '1025' )
                                                 ( low = '1026' )
                                                 ( low = '1027' )
                                                 ( low = '1028' )
                                                 ( low = '1029' )
                                                 ( low = '1030' )
                                                 ( low = '1031' )
                                                 ( low = '1032' )
                                                 ( low = '1033' )
                                                 ( low = '1034' )
                                                 ( low = '1035' )
                                                 ( low = '1036' )
                                                 ( low = '1037' )
                                                 ( low = '1038' )
                                                 ( low = '1039' )
                           ).

  ENDMETHOD.
  method ES_ANTIGUO_TRATAMIENTO.

    select single flag_inactivo
      into @r_rc
      from ztpp0032
      where APL   = 'NUEVO_TRATAMIENTO_RECETAS_RF' and
            werks = @i_werks.

  endmethod.
  METHOD generar_consumo_receta.

    DATA: ls_41 TYPE ztpp0041.

* Validaciones realizadas:
*  '01' La receta debe estar vigente (o [A]ctua)
*  '02' Lote no valido.
*  '03' Material no válido para esta receta.

*07 lote ya asignado a una receta
*08 Error al insertar registro

    CALL METHOD zclpp_consumo_recetas_mp=>validar_lectura_lote_rf
      EXPORTING
        i_werks     = i_werks
        i_id_receta = i_id_receta
        i_lote      = i_lote
      IMPORTING
        o_rc        = o_rc.

*--> FCC 29.08.23 - Consumos pulper (2)

*    CHECK o_rc = '00'.

    IF ( o_rc NE '00' ).
      o_rc = '00'.
      EXIT.
    ENDIF.

*<-- FCC 29.08.23 - Consumos pulper (2)

    DATA: l_bwart TYPE bwart.

    IF i_matnr = gc_bobina_pulper.
      l_bwart = '309'.
    ELSE.
      l_bwart = '101'.
    ENDIF.

    SELECT SINGLE *
      INTO @DATA(ls_mov101)
      FROM mseg
      WHERE werks = @i_werks AND
            charg = @i_lote  AND
            bwart = @l_bwart  AND
            budat_mkpf = ( SELECT MAX( budat_mkpf ) FROM mseg
                            WHERE werks = @i_werks AND
                                  charg = @i_lote  AND
                                  bwart = @l_bwart  ).

    IF sy-subrc <> 0.

      IF i_matnr = gc_bobina_pulper.
        l_bwart = '531'.
      else. " Si no se ha encontrado el 101 y no es bob.pulper buscamos mov.701
        l_bwart = '701'.
      ENDIF.

        SELECT SINGLE *
           INTO @ls_mov101
           FROM mseg
           WHERE werks = @i_werks AND
                 charg = @i_lote  AND
                 bwart = @l_bwart  AND
                 budat_mkpf = ( SELECT MAX( budat_mkpf ) FROM mseg
                                 WHERE werks = @i_werks AND
                                       charg = @i_lote  AND
                                       bwart = @l_bwart  ).

        IF sy-subrc <> 0." AND i_matnr <> gc_bobina_pulper.

          o_rc = '04'. "movimiento 101 no encontrado para MP
          EXIT.
        ENDIF.

    ENDIF.

* Obtenemos materiales que componen la receta.
    CALL METHOD zclpp_recetas_mp=>obtener_datos_form_receta_mp
      EXPORTING
        i_werks                 = i_werks
        i_id_receta             = i_id_receta
      IMPORTING
        os_datos_form_receta_mp = DATA(ls_datos_rec)
        o_rc                    = DATA(l_rc).



    CLEAR ls_41.
    ls_41-werks         = i_werks.
    ls_41-id_receta     = i_id_receta.
    ls_41-charg         = i_lote.
    ls_41-lgort         = i_lgort.
    ls_41-mblnr         = ls_mov101-mblnr.
    ls_41-mjahr         = ls_mov101-mjahr.
    ls_41-zeile         = ls_mov101-zeile.

    TRY. " Buscamos si es material es MP.
*        ls_41-matnr = gt_mp[ matnr = ls_mov101-matnr ]-matnr.
        ls_41-matnr = ls_datos_rec-t_materiales_mp[ matnr = ls_mov101-matnr ]-matnr.
      CATCH cx_root .

        TRY.
* Buscamos el material equivalente con un "ORDEN" menor, en caso de que haya más de uno.

            SELECT SINGLE matnr_equiv INTO @ls_41-matnr
              FROM ztpp0039 AS z9
              INNER JOIN ztpp0037 AS z7 ON z7~werks = z9~werks AND z7~matnr_equiv = z9~matnr
              WHERE z9~werks  = @i_werks AND
                    z7~werks  = @i_werks AND
                    id_receta = @i_id_receta AND
                    matnr_mp  = @i_matnr
              AND orden IN ( SELECT MIN( orden )
                              FROM ztpp0039 AS z9
                              INNER JOIN ztpp0037 AS z7 ON z7~werks = z9~werks AND z7~matnr_equiv = z9~matnr
                              WHERE z9~werks    = @i_werks AND
                                    z7~werks    = @i_werks AND
                                    id_receta   = @i_id_receta AND
                                    matnr_mp    = @i_matnr
                                              ).

* Buscamos que el material corresponda a la receta.
*            ls_41-matnr = ls_datos_rec-t_materiales_mp[ matnr = ls_41-matnr ]-matnr.

            ls_41-matnr_equiv  = ls_mov101-matnr.

            ls_41-ind_equiv    = 'X'.
          CATCH cx_root .
            o_rc = '06'. "Material erróneo.
            EXIT.
        ENDTRY.

    ENDTRY.

    SELECT SINGLE *
      INTO @DATA(ls_mchb)
      FROM mchb
      WHERE matnr = @i_matnr
        AND charg = @i_lote
*        AND lgort = '4002'
        AND werks = @i_werks
        AND clabs > 0.
    IF sy-subrc <> 0.
      o_rc = '05'.   " Esta validado previamente
      EXIT.
    ENDIF.

    ls_41-kg_reales     = ls_mchb-clabs.
    ls_41-meins         = 'KG'.

    CALL METHOD zclpp_trazabilidad_usuario=>obtener_datos_turno
      IMPORTING
        o_turno = ls_41-turno.


* Guardamos la fecha de fabricación, si es la madrugada del T3, restamos 1.
    IF ls_41-turno = 'T3' AND sy-uzeit BETWEEN '000000' AND '055959'.
      ls_41-fecha_fabr     = sy-datum - 1.
    ELSE.
      ls_41-fecha_fabr     = sy-datum.

    ENDIF.

    ls_41-fecha_ins     = sy-datum.
    ls_41-hora_ins      = sy-uzeit.
    ls_41-contr_ins     = i_operario.
    ls_41-tp_reg        = '1'.
*    INSERT INTO ztpp0041 VALUES ls_41. "FCC 29.08.23 - Consumos pulper (2)
    MODIFY ztpp0041 FROM ls_41.
    IF sy-subrc = 0.
      o_rc = '00'.
    ELSE.
      o_rc = '08'.
    ENDIF.

  ENDMETHOD.
METHOD generar_consumo_receta_migo311.

**********************************************************************
* Parámetros locales
**********************************************************************

*  DATA: ls_ztpp0041 TYPE ztpp0041.

  DATA: lv_id_receta TYPE zid_receta,
        lv_operario  TYPE znombre_oper.

**********************************************************************
* Validaciones
**********************************************************************

  "JCB. 04.11.24. Parámetro RFID
  "CHECK i_werks EQ zclpp_consumo_recetas_mp=>gc_werks_3000.
  SELECT SINGLE valor
    INTO @DATA(vl_centro_rfid)
    FROM zparametros
    WHERE clave = 'ZRFIDPARAM' AND
          campo = @i_werks.
  CHECK vl_centro_rfid = 'X'.



  CHECK i_charg IS NOT INITIAL.

  SELECT COUNT(*)
    FROM mara
   WHERE matnr EQ i_matnr
     AND mtart EQ 'ZREC'.

  CHECK sy-subrc EQ 0.

  CHECK i_menge GT 0.

**********************************************************************
* Lógica
**********************************************************************

**** GET RECETA

  SELECT id_receta
    FROM ztpp0040
    INTO @DATA(lv_receta)
   WHERE werks EQ @i_werks
     AND fecha_ini LE @sy-datum
     AND fecha_fin GT @sy-datum.

    IF ( lv_id_receta IS INITIAL OR lv_id_receta LT lv_receta ).
      MOVE lv_receta TO lv_id_receta.
    ENDIF.

  ENDSELECT.

**** GET OPERARIO NAME

  MOVE sy-uname TO lv_operario.

**** CREATE ZTPP0041 ROW

  zclpp_consumo_recetas_mp=>generar_consumo_receta(
    EXPORTING
      i_werks     = i_werks     " Centro
      i_id_receta = lv_id_receta   " HPAP-PP Id de Receta
      i_lote      = i_charg     " Número de lote
      i_matnr     = i_matnr     " Número de material
      i_lgort     = i_lgort     " Almacén
      i_operario  = lv_operario    " HPAP-PP Nombre del operario
*    IMPORTING
*      o_rc        =     " IS-H: campo general de longitud 2 p.módulo de funciones
  ).

ENDMETHOD.
  METHOD generar_lote_hermano.

    SELECT SINGLE * INTO @DATA(ls_lote_hermano)
      FROM ztpp0041
      WHERE werks     = @i_werks     AND
            id_receta = @i_id_receta AND
            charg     = @i_lote.

    IF sy-subrc <> 0.
      o_rc  = '01'.
    ELSE.

      CALL METHOD zclpp_consumo_recetas_mp=>obtener_next_lote_ficticio
        EXPORTING
          i_werks          = i_werks
          i_id_receta      = i_id_receta
          i_sw_pis_reg     = i_sw_pis_reg
        IMPORTING
          o_siguiente_lote = ls_lote_hermano-charg.

      ls_lote_hermano-contr_ins        = i_operario.
      ls_lote_hermano-fecha_ins        = ls_lote_hermano-fecha_ins. "sy-datum.
      ls_lote_hermano-hora_ins         = ls_lote_hermano-hora_ins.  "sy-uzeit.
      ls_lote_hermano-lote_mp_hermano  = i_lote.
      ls_lote_hermano-ind_sin_etiq     = '1'.       "Sin Etiqueta

* Limpiamos campos calculados a partir del lote.
      CLEAR:  ls_lote_hermano-mblnr ,
              ls_lote_hermano-mjahr ,
              ls_lote_hermano-zeile
              .


      INSERT INTO ztpp0041 VALUES ls_lote_hermano.
      IF sy-subrc <> 0.
        o_rc = '02'.
      ELSE.
        o_rc = '00'.
        o_lote_hermano = ls_lote_hermano.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD grafico_control_receta.

    CALL METHOD zclpp_consumo_recetas_mp=>obtener_datos_receta_consumida
      EXPORTING
        i_werks          = i_werks
        i_id_receta      = i_id_receta
        i_t1             = 'X'
        i_t2             = 'X'
        i_t3             = 'X'
      IMPORTING
        ot_datos_consumo = DATA(lt_datos_rec)
        o_rc             = DATA(l_rc).

    CHECK l_rc = '00'.

    DATA: lt_y_values TYPE STANDARD TABLE OF  gprval,
          lt_x_texts  TYPE STANDARD TABLE OF  gprtxt.

    LOOP AT lt_datos_rec INTO DATA(ls_datos).
      APPEND VALUE gprtxt( coltxt = ls_datos-maktx )     TO lt_x_texts.
      APPEND VALUE gprval( val1   = ls_datos-kg_ciclo )  TO lt_y_values.
      APPEND VALUE gprval( val2   = ls_datos-kg_reales ) TO lt_y_values.
    ENDLOOP.

    CALL FUNCTION 'GFW_PRES_SHOW'
      EXPORTING
        container         = 'I_CONTAINER'
        presentation_type = gfw_prestype_horizontal_bars
      TABLES
        values            = lt_y_values
        column_texts      = lt_x_texts
      EXCEPTIONS
        error_occurred    = 1
        OTHERS            = 2.
  ENDMETHOD.
  METHOD obtener_dat_acumulados_receta.
    TYPES: BEGIN OF ty_equ,
             matnr       TYPE matnr,
             matnr_equiv TYPE matnr,
           END OF ty_equ.

* Tabla para acumular KG con decimales
    TYPES: BEGIN OF ty_tab_kg_dec,
             matnr     TYPE matnr,
             kg_reales TYPE menge_d,
             porc_real TYPE zporc_mat_rec,
           END OF ty_tab_kg_dec.

    DATA: lt_kg_dec TYPE STANDARD TABLE OF ty_tab_kg_dec.

    DATA: gs_colinfo   TYPE LINE OF lvc_t_scol,
          ls_cellcolor TYPE lvc_s_scol.
    DATA: l_any_pres TYPE mjahr,
          l_mes_pres TYPE bumon.

    CLEAR: lt_kg_dec[].

    CALL METHOD zclpp_recetas_mp=>obtener_datos_form_receta_mp
      EXPORTING
        i_werks                 = i_werks
        i_id_receta             = i_id_receta
      IMPORTING
        os_datos_form_receta_mp = os_datos_form_receta_mp
        o_rc                    = o_rc.

    CHECK o_rc = '00'.

    SELECT *
      FROM ztpp0041
      INTO TABLE @DATA(lt_041)
      WHERE werks      = @i_werks     AND
            id_receta  = @i_id_receta AND
            fecha_fabr IN @ir_fecha_fab AND " Hinojosa Paper - Comparación económica de recetas (ZPP0067), fecha de selección por turno, no por dia natural
*            fecha_ins IN @ir_fecha_fab AND
            ind_sin_etiq IN ( ' ' , '0' , '1' ). " para no tener en cuenta los ficticios consumidos mediante "lotes sin etiqueta"
    IF sy-subrc <> 0.
      o_rc = '01'. " Turno no encontrado
*        EXIT. dejamos que siga y muestre datos con consumos reales a CERO.
    ENDIF.

    IF i_t1 = ' '.
      DELETE lt_041 WHERE turno = 'T1'.
    ENDIF.

    IF i_t2 = ' '.
      DELETE lt_041 WHERE turno = 'T2'.
    ENDIF.

    IF i_t3 = ' '.
      DELETE lt_041 WHERE turno = 'T3'.
    ENDIF.

* Creamos un registro por cada material definido en la receta, informamos datos de definición de receta.
    LOOP AT os_datos_form_receta_mp-t_materiales_mp INTO DATA(ls_mat).

      APPEND INITIAL LINE TO ot_datos_consumo ASSIGNING FIELD-SYMBOL(<fs_consumo>).
      <fs_consumo>-matnr        = ls_mat-matnr.
      <fs_consumo>-maktx        = ls_mat-maktx.

*Creamos registro para calcular KG y % real con decimales
      APPEND INITIAL LINE TO lt_kg_dec ASSIGNING FIELD-SYMBOL(<fs_kg_dec>).
      <fs_kg_dec>-matnr = ls_mat-matnr.
      CLEAR <fs_kg_dec>-kg_reales. " = ls_mat-matnr.

    ENDLOOP.

* Acumulamos kg de materiales.
    LOOP AT lt_041 INTO DATA(ls_041).

      ASSIGN ot_datos_consumo[ matnr = ls_041-matnr ] TO <fs_consumo>.
      IF sy-subrc = 0.
        <fs_consumo>-kg_reales    = <fs_consumo>-kg_reales + ls_041-kg_reales.

* Si hay consumo, PMV de tabla, sino se calcula el PMV actual.
        IF ls_041-ind_lote_consum = 'X'.
          <fs_consumo>-pmv          = <fs_consumo>-pmv + ls_041-pmv.
        ELSE.
          CLEAR: l_any_pres , l_mes_pres.
          l_any_pres = sy-datum(4).
          l_mes_pres = sy-datum+4(2).
          CALL METHOD zclpp_consumo_recetas_mp=>obtener_precio_medio_variable
            EXPORTING
              i_werks            = i_werks
              i_matnr            = ls_041-matnr
              i_kg_reales        = ls_041-kg_reales
              i_any              = l_any_pres
              i_mes              = l_mes_pres
            IMPORTING
              o_precio_medio_var = ls_041-pmv
*             o_importe_pmv      =
            .
          <fs_consumo>-pmv = <fs_consumo>-pmv + ls_041-pmv.
        ENDIF.
      ELSE.
        APPEND INITIAL LINE TO ot_datos_consumo ASSIGNING <fs_consumo>.
        <fs_consumo>-matnr        = ls_041-matnr.
        <fs_consumo>-kg_reales    = ls_041-kg_reales.
        <fs_consumo>-pmv          = ls_041-pmv.
      ENDIF.

* Acumulamos los KG con decimales para sumarizar y luego hallar %
      READ TABLE lt_kg_dec WITH KEY matnr = ls_041-matnr ASSIGNING <fs_kg_dec>.
      IF sy-subrc = 0.
        <fs_kg_dec>-kg_reales    = <fs_kg_dec>-kg_reales + ls_041-kg_reales.
      ELSE.
        APPEND INITIAL LINE TO lt_kg_dec ASSIGNING <fs_kg_dec>.
        <fs_kg_dec>-matnr       = ls_041-matnr.
        <fs_kg_dec>-kg_reales   = ls_041-kg_reales.
      ENDIF.

    ENDLOOP.

* Calcular porcentajes reales y aplicar color rojo en la dif.de porcentajes.
    DATA: l_tot_kg          TYPE menge_d,
          l_num_reg_with_kg TYPE n,
          l_tot_porc        TYPE zporc_mat_rec.

* Acumulación de kg.totales.
    LOOP AT lt_kg_dec INTO DATA(ls_cons).
      l_tot_kg          = l_tot_kg + ls_cons-kg_reales.
      l_num_reg_with_kg = l_num_reg_with_kg + 1.
    ENDLOOP.

* Cálculo de porcentaje Total.
    LOOP AT ot_datos_consumo ASSIGNING <fs_consumo>.

      ASSIGN lt_kg_dec[ matnr = <fs_consumo>-matnr ] TO <fs_kg_dec>.

* Movemos los KG con decimales, al campo de pantalla, mediante redondeo.
      CALL FUNCTION 'ROUND'
        EXPORTING
          decimals = 3
          input    = <fs_kg_dec>-kg_reales
        IMPORTING
          output   = <fs_consumo>-kg_reales.

      DATA(l_porc_dec) = ( <fs_kg_dec>-kg_reales * 100 ) / l_tot_kg.

* Movemos los % reales con decimales, al campo de pantalla, mediante redondeo.
      CALL FUNCTION 'ROUND'
        EXPORTING
          decimals = 2
          input    = l_porc_dec
        IMPORTING
          output   = <fs_consumo>-porc_real.

      l_tot_porc          = l_tot_porc + <fs_consumo>-porc_real.

    ENDLOOP.

*Ajuste de suma de porcentajes a 100%
    TRY.
        IF l_tot_porc <> 100 AND l_tot_porc <> 0.
          ASSIGN ot_datos_consumo[ l_num_reg_with_kg ] TO <fs_consumo>.
          <fs_consumo>-porc_real = <fs_consumo>-porc_real + ( 100 - l_tot_porc ).
        ENDIF.
      CATCH cx_root .
    ENDTRY.

  ENDMETHOD.
  METHOD obtener_datos_econom_mp_x_rec.

    DATA:  l_menge           TYPE menge_d,
      l_total_kg_reales TYPE menge_d,
      l_total_kg_teor   TYPE menge_d.

    DATA: lt_datos_consumo TYPE  ztpp0057_alv300.

    CLEAR lt_datos_consumo[].
    CALL METHOD zclpp_consumo_recetas_mp=>obtener_dat_acumulados_receta
      EXPORTING
        i_werks                 = i_werks
        i_id_receta             = i_receta
        i_t1                    = i_t1
        i_t2                    = i_t2
        i_t3                    = i_t3
        ir_fecha_fab            = ir_fecha_turno
      IMPORTING
        os_datos_form_receta_mp = DATA(ls_dat_receta)
        ot_datos_consumo        = lt_datos_consumo
        o_rc                    = DATA(l_rc).

    CLEAR: l_total_kg_reales.
    LOOP AT lt_datos_consumo INTO DATA(ls_datos_consumo).
      l_total_kg_reales = l_total_kg_reales + ls_datos_consumo-kg_reales.
    ENDLOOP.

    CALL METHOD zclpp_consumo_recetas_mp=>obtener_lista_mat_teorica
      EXPORTING
        i_werks      = i_werks
        i_calidad    = ls_dat_receta-zcalidad
      IMPORTING
        ot_lista_mat = DATA(lt_lista_mat).

    CLEAR ot_datos_economicos[].
    LOOP AT lt_datos_consumo INTO ls_datos_consumo.

      APPEND INITIAL LINE TO ot_datos_economicos ASSIGNING FIELD-SYMBOL(<fs_dat_econ>).
      <fs_dat_econ>-matnr       = ls_datos_consumo-matnr.
      <fs_dat_econ>-maktx = zclpp_recetas_mp=>gt_descr_mp[ matnr = <fs_dat_econ>-matnr ]-maktx.

*      CALL FUNCTION 'ROUND'
*        EXPORTING
*          decimals = 2
*          input    = ls_datos_consumo-porc_real
*        IMPORTING
*          output   = <fs_dat_econ>-porc_real.

      <fs_dat_econ>-porc_real = ls_datos_consumo-porc_real.

      <fs_dat_econ>-kg_reales   = ls_datos_consumo-kg_reales.


*      l_menge = <fs_dat_econ>-kg_reales.
*      CALL FUNCTION 'ROUND'
*        EXPORTING
*          decimals = 3
*          input    = <fs_dat_econ>-kg_reales
*        IMPORTING
*          output   = l_menge.

      <fs_dat_econ>-coste_real  = ls_datos_consumo-pmv.
      <fs_dat_econ>-importe_pmv = ( 1000 * <fs_dat_econ>-coste_real ) / <fs_dat_econ>-kg_reales.
*      <fs_dat_econ>-importe_pmv = ( 1000 * <fs_dat_econ>-coste_real ) / l_menge.

      TRY.
          DATA(ls_lista_mat) =  lt_lista_mat[ idnrk = <fs_dat_econ>-matnr ].
          <fs_dat_econ>-porc_teor   = ls_lista_mat-porc.
          <fs_dat_econ>-kg_teor     = ( <fs_dat_econ>-porc_teor * l_total_kg_reales ) / 100.

          l_total_kg_teor = l_total_kg_teor + <fs_dat_econ>-kg_teor.

        CATCH cx_root .
      ENDTRY.

      <fs_dat_econ>-desv_coste  = <fs_dat_econ>-coste_teor - <fs_dat_econ>-coste_real.

    ENDLOOP.

    LOOP AT lt_lista_mat INTO ls_lista_mat.

      IF NOT line_exists( ot_datos_economicos[ matnr = ls_lista_mat-idnrk ] ).

        APPEND INITIAL LINE TO ot_datos_economicos ASSIGNING <fs_dat_econ>.
        <fs_dat_econ>-matnr       = ls_lista_mat-idnrk.
        <fs_dat_econ>-maktx       = zclpp_recetas_mp=>gt_descr_mp[ matnr = <fs_dat_econ>-matnr ]-maktx.

        <fs_dat_econ>-porc_teor   = ls_lista_mat-porc.
        <fs_dat_econ>-kg_teor     = ( <fs_dat_econ>-porc_teor * l_total_kg_reales ) / 100.

        l_total_kg_teor = l_total_kg_teor + <fs_dat_econ>-kg_teor.

      ENDIF.

    ENDLOOP.

* Ajuste de los kg.teóricos para cuadrarlos con los kg.reales totales.
    IF l_total_kg_teor <> l_total_kg_reales.
      <fs_dat_econ>-kg_teor = <fs_dat_econ>-kg_teor - ( l_total_kg_teor - l_total_kg_reales ).
    ENDIF.

* Si hay PMV informado, calcular teórico a partir de éste. Sino, obtener PMV actual e informar PMV actual
    LOOP AT ot_datos_economicos ASSIGNING <fs_dat_econ>.

      IF <fs_dat_econ>-importe_pmv = 0.

        l_menge = <fs_dat_econ>-kg_teor.
        CALL METHOD zclpp_consumo_recetas_mp=>obtener_precio_medio_variable
          EXPORTING
            i_werks            = i_werks
            i_matnr            = <fs_dat_econ>-matnr
*            i_kg_reales        = <fs_dat_econ>-kg_teor
            i_kg_reales        = l_menge
            i_any              = sy-datum(4)
            i_mes              = sy-datum+4(2)
          IMPORTING
            o_precio_medio_var = <fs_dat_econ>-coste_teor
            o_importe_pmv      = <fs_dat_econ>-importe_pmv.

      ELSE.

        <fs_dat_econ>-coste_teor   = ( <fs_dat_econ>-importe_pmv * <fs_dat_econ>-kg_teor ) / 1000.

      ENDIF.

      <fs_dat_econ>-desv_coste  = <fs_dat_econ>-coste_teor - <fs_dat_econ>-coste_real.

    ENDLOOP.

    DATA: ls_cellcolor TYPE lvc_s_scol.

* Colorear desviación (Verde/Rojo)
    LOOP AT ot_datos_economicos ASSIGNING <fs_dat_econ>.

      CLEAR ls_cellcolor.

      IF <fs_dat_econ>-desv_coste > 0.
        ls_cellcolor-fname = 'DESV_COSTE'.
        ls_cellcolor-color-col = '5' . "Rojo
        ls_cellcolor-color-int = 0.
        ls_cellcolor-color-inv = 0.
        APPEND ls_cellcolor TO <fs_dat_econ>-t_color.

      ELSEIF <fs_dat_econ>-desv_coste < 0.

        ls_cellcolor-fname = 'DESV_COSTE'.
        ls_cellcolor-color-col = '6'. "Verde
        ls_cellcolor-color-int = 0.
        ls_cellcolor-color-inv = 0.
        APPEND ls_cellcolor TO <fs_dat_econ>-t_color.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD obtener_datos_receta_consumida.
    TYPES: BEGIN OF ty_equ,
             matnr       TYPE matnr,
             matnr_equiv TYPE matnr,
           END OF ty_equ.

* Tabla para acumular KG con decimales
    TYPES: BEGIN OF ty_tab_kg_dec,
             matnr     TYPE matnr,
             kg_reales TYPE menge_d,
             porc_real TYPE zporc_mat_rec,
           END OF ty_tab_kg_dec.

    DATA: ls_mat_equiv TYPE ty_equ.
    DATA: lt_mat_equiv TYPE STANDARD TABLE OF ty_equ.
    DATA: lt_kg_dec TYPE STANDARD TABLE OF ty_tab_kg_dec.

    DATA: gs_colinfo   TYPE LINE OF lvc_t_scol,
          ls_cellcolor TYPE lvc_s_scol.

    CLEAR: lt_kg_dec[], lt_mat_equiv.

    CALL METHOD zclpp_recetas_mp=>obtener_datos_form_receta_mp
      EXPORTING
        i_werks                 = i_werks
        i_id_receta             = i_id_receta
      IMPORTING
        os_datos_form_receta_mp = os_datos_form_receta_mp
        o_rc                    = o_rc.

    CHECK o_rc = '00'.

* Obtenemos consumos de receta
    IF i_filtro_fecha_pulper = abap_true.

      SELECT *
        FROM ztpp0041
        INTO TABLE @DATA(lt_041)
        WHERE werks     = @i_werks     AND
              id_receta = @i_id_receta AND
              fecha_ins  in @ir_fecha_fab AND
              ind_sin_etiq IN ( ' ' , '0' , '1' ). " para no tener en cuenta los ficticios consumidos mediante "lotes sin etiqueta"
      IF sy-subrc <> 0.
        o_rc = '01'. " Receta no ncontrada
      ENDIF.

    ELSE.
      SELECT *
        FROM ztpp0041
        INTO TABLE @lt_041
        WHERE werks      = @i_werks     AND
              id_receta  = @i_id_receta AND
              fecha_fabr in @ir_fecha_fab AND
              ind_sin_etiq IN ( ' ' , '0' , '1' ). " para no tener en cuenta los ficticios consumidos mediante "lotes sin etiqueta"
      IF sy-subrc <> 0.
        o_rc = '01'. " Turno no encontrado
*        EXIT. dejamos que siga y muestre datos con consumos reales a CERO.
      ENDIF.

    ENDIF.

    IF i_t1 = ' '.
      DELETE lt_041 WHERE turno = 'T1'.
    ENDIF.

    IF i_t2 = ' '.
      DELETE lt_041 WHERE turno = 'T2'.
    ENDIF.

    IF i_t3 = ' '.
      DELETE lt_041 WHERE turno = 'T3'.
    ENDIF.

* Creamos un registro por cada material definido en la receta, informamos datos de definición de receta.
    LOOP AT os_datos_form_receta_mp-t_materiales_mp INTO DATA(ls_mat).

      APPEND INITIAL LINE TO ot_datos_consumo ASSIGNING FIELD-SYMBOL(<fs_consumo>).
      <fs_consumo>-matnr        = ls_mat-matnr.
      <fs_consumo>-maktx        = ls_mat-maktx.
      <fs_consumo>-kg_ciclo     = ls_mat-kg_ciclo.
      <fs_consumo>-porc_ciclo   = ls_mat-porc_ciclo.
      TRY.
          <fs_consumo>-tolerancia   = gt_mp[ matnr = <fs_consumo>-matnr
                                             werks = i_werks            ]-tolerancia.
        CATCH cx_root .
      ENDTRY.

*Creamos registro para calcular KG y % real con decimales
      APPEND INITIAL LINE TO lt_kg_dec ASSIGNING FIELD-SYMBOL(<fs_kg_dec>).
      <fs_kg_dec>-matnr = ls_mat-matnr.
      CLEAR <fs_kg_dec>-kg_reales. " = ls_mat-matnr.
    ENDLOOP.

* Acumulamos kg de materiales nativos(NO equivalentes).
    LOOP AT lt_041 INTO DATA(ls_041) WHERE ind_equiv = ' '.

*     ASSIGN ot_datos_consumo[ matnr = ls_041-matnr ] TO <fs_consumo>.
      READ TABLE ot_datos_consumo WITH KEY matnr = ls_041-matnr ASSIGNING <fs_consumo>.
      IF sy-subrc = 0.
        <fs_consumo>-kg_reales    = <fs_consumo>-kg_reales + ls_041-kg_reales.
      ENDIF.

* Acumulamos los KG con decimales para sumarizar y luego hallar %
      READ TABLE lt_kg_dec WITH KEY matnr = ls_041-matnr ASSIGNING <fs_kg_dec>.
      IF sy-subrc = 0.
        <fs_kg_dec>-kg_reales    = <fs_kg_dec>-kg_reales + ls_041-kg_reales.
      ENDIF.

    ENDLOOP.


* Tratamos los materiales equivalentes.
    CLEAR : ls_mat_equiv , lt_mat_equiv[].

    LOOP AT lt_041 INTO DATA(ls_mp_eq) WHERE ind_equiv = 'X'.

      TRY. "Acumulamos kg en el material equivalente, si no existe se crea en el catch.
          IF NOT line_exists( lt_mat_equiv[ matnr       = ls_mp_eq-matnr
                                            matnr_equiv = ls_mp_eq-matnr_equiv ] ).
            CLEAR ls_mat_equiv.
            ls_mat_equiv-matnr        = ls_mp_eq-matnr.
            ls_mat_equiv-matnr_equiv  = ls_mp_eq-matnr_equiv.
            INSERT ls_mat_equiv INTO TABLE lt_mat_equiv.
          ENDIF.

* Acumulamos KG con decimales.
          IF line_exists( lt_kg_dec[ matnr = ls_mp_eq-matnr_equiv ] ).
            ASSIGN lt_kg_dec[ matnr = ls_mp_eq-matnr_equiv ] TO <fs_kg_dec>.
            IF sy-subrc = 0.
              <fs_kg_dec>-kg_reales = <fs_kg_dec>-kg_reales + ls_mp_eq-kg_reales.
            ENDIF.
          ELSE.
            APPEND INITIAL LINE TO lt_kg_dec ASSIGNING <fs_kg_dec>.
            <fs_kg_dec>-matnr = ls_mp_eq-matnr_equiv.
            <fs_kg_dec>-kg_reales = ls_mp_eq-kg_reales.

          ENDIF.

          IF NOT line_exists( ot_datos_consumo[ matnr = ls_mp_eq-matnr_equiv ] ).

            APPEND INITIAL LINE TO ot_datos_consumo ASSIGNING <fs_consumo>.
            <fs_consumo>-matnr  = ls_mp_eq-matnr_equiv.

            TRY. " Descripción de material
                <fs_consumo>-maktx = zclpp_recetas_mp=>gt_descr_mp[ matnr = <fs_consumo>-matnr ]-maktx.
              CATCH cx_root .
                CLEAR <fs_consumo>-maktx.
            ENDTRY.

            <fs_consumo>-ind_equiv  = 'X'.

* Pintamos de amarillo para indicar que es material equivalente
            CLEAR ls_cellcolor.
            ls_cellcolor-fname = 'MATNR'.
            ls_cellcolor-color-col = '3'.
            ls_cellcolor-color-int = '0'.
            APPEND ls_cellcolor TO <fs_consumo>-color.
            CLEAR ls_cellcolor.
            ls_cellcolor-fname = 'MAKTX'.
            ls_cellcolor-color-col = '3'.
            ls_cellcolor-color-int = '0'.
            APPEND ls_cellcolor TO <fs_consumo>-color.

          ENDIF.

        CATCH cx_root .
      ENDTRY.

    ENDLOOP.

* Calcular porcentajes reales y aplicar color rojo en la dif.de porcentajes.

    DATA: l_tot_kg          TYPE menge_d,
          l_num_reg_with_kg TYPE n,
          l_tot_porc        TYPE zporc_mat_rec.

* Acumulación de kg.totales.
    LOOP AT lt_kg_dec INTO DATA(ls_cons).
      l_tot_kg          = l_tot_kg + ls_cons-kg_reales.
      l_num_reg_with_kg = l_num_reg_with_kg + 1.
    ENDLOOP.

* Cálculo de porcentaje Total.
    LOOP AT ot_datos_consumo ASSIGNING <fs_consumo>. " WHERE ind_equiv = ' '.

      ASSIGN lt_kg_dec[ matnr = <fs_consumo>-matnr ] TO <fs_kg_dec>.

* Movemos los KG con decimales, al campo de pantalla, mediante redondeo.
      CALL FUNCTION 'ROUND'
        EXPORTING
          decimals = 3
          input    = <fs_kg_dec>-kg_reales
        IMPORTING
          output   = <fs_consumo>-kg_reales.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ENDIF.

      DATA(l_porc_dec) = ( <fs_kg_dec>-kg_reales * 100 ) / l_tot_kg.

* Movemos los % reales con decimales, al campo de pantalla, mediante redondeo.
      CALL FUNCTION 'ROUND'
        EXPORTING
          decimals = 2
          input    = l_porc_dec
        IMPORTING
          output   = <fs_consumo>-porc_real.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ENDIF.

      l_tot_porc          = l_tot_porc + <fs_consumo>-porc_real.

    ENDLOOP.

*Ajuste de suma de porcentajes a 100%
    TRY.
        IF l_tot_porc <> 100 AND l_tot_porc <> 0.
          ASSIGN ot_datos_consumo[ l_num_reg_with_kg ] TO <fs_consumo>.
          <fs_consumo>-porc_real = <fs_consumo>-porc_real + ( 100 - l_tot_porc ).
        ENDIF.
      CATCH cx_root .
    ENDTRY.

*  Trasladar % de equivalentes, a los materiales substituidos. Y limpiar porc. de material equiv.
    TRY.
        LOOP AT lt_mat_equiv ASSIGNING FIELD-SYMBOL(<fs_mat_equiv>).
          ASSIGN ot_datos_consumo[ matnr = <fs_mat_equiv>-matnr ] TO <fs_consumo>.
          <fs_consumo>-porc_real = <fs_consumo>-porc_real + ot_datos_consumo[ matnr = <fs_mat_equiv>-matnr_equiv ]-porc_real.


          CLEAR ot_datos_consumo[ matnr = <fs_mat_equiv>-matnr_equiv ]-porc_real.
        ENDLOOP.
      CATCH cx_root .
    ENDTRY.


    DATA: l_porc_dif TYPE zporc_mat_rec.


* Cálculo de la diferencia entre kg ciclo/kg reales, si dif. es mayor q tolerancia: ROJO
    LOOP AT ot_datos_consumo ASSIGNING <fs_consumo> WHERE ind_equiv = ' '.


      l_porc_dif = <fs_consumo>-porc_real - <fs_consumo>-porc_ciclo.

      DATA: x TYPE p VALUE '3.54',
            y TYPE p DECIMALS 2.

      CALL FUNCTION 'ROUND'
        EXPORTING
          decimals = 2
          input    = l_porc_dif
        IMPORTING
          output   = <fs_consumo>-porc_dif.

* Si es negativo, cambiamos signo para comparar con la tolerancia.

      IF <fs_consumo>-porc_dif < 0.
        l_porc_dif = <fs_consumo>-porc_dif * -1.
*        DATA(l_signo)    = '-'.
      ELSE.
        l_porc_dif       = <fs_consumo>-porc_dif.
*        l_signo          = '+'.
      ENDIF.

      IF l_porc_dif > <fs_consumo>-tolerancia.
        CLEAR ls_cellcolor.
        ls_cellcolor-fname = 'PORC_DIF'.
        ls_cellcolor-color-col = '6' .

*        CASE l_signo.
*          WHEN '+'.
        ls_cellcolor-color-int = '1'.
*          WHEN '-'.ls_cellcolor-color-int = '0'.
*          WHEN OTHERS.
*        ENDCASE.
        <fs_consumo>-ko  = '@02@'.
        APPEND ls_cellcolor TO <fs_consumo>-color.
      ELSE.
        CLEAR <fs_consumo>-ko.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD obtener_intervalo_ctrl_receta.

    SELECT SINGLE valor
      FROM ztpp0033
      INTO @DATA(l_valor)
      WHERE werks   = @i_werks and
            ID_PARM = 'CTRL_REC'.

    r_segundos_intervalo = l_valor.

  ENDMETHOD.
  METHOD obtener_lista_mat_teorica.

    DATA: l_kg_total TYPE menge_d.
    DATA l_total TYPE netwr.

    SELECT SINGLE matnr_prod INTO @DATA(l_matnr_prod)
      FROM ztpp0035
      WHERE zcalidad = @i_calidad.

    CHECK sy-subrc = 0.

    SELECT m~matnr , p~idnrk , p~menge
      INTO CORRESPONDING FIELDS OF TABLE @ot_lista_mat
      FROM stpo AS p
      INNER JOIN stko AS k ON  p~stlty = k~stlty AND p~stlnr = k~stlnr
      INNER JOIN mast AS m ON  m~stlnr = k~stlnr
      WHERE m~matnr = @l_matnr_prod AND
            m~werks = @i_werks.

    CLEAR: l_kg_total.
    LOOP AT ot_lista_mat INTO DATA(ls_lista_mat).
      l_kg_total = l_kg_total + ls_lista_mat-menge.
    ENDLOOP.

    CLEAR: l_total.
    LOOP AT ot_lista_mat ASSIGNING FIELD-SYMBOL(<fs_lista_mat>).
      DATA(l_porc_dec) = ( <fs_lista_mat>-menge * 100 ) / l_kg_total.
      <fs_lista_mat>-porc = l_porc_dec.
      l_total = l_total +  <fs_lista_mat>-porc.
    ENDLOOP.

    IF l_total <> 100.
      <fs_lista_mat>-porc = <fs_lista_mat>-porc - ( l_total - 100 ).
    ENDIF.

  ENDMETHOD.
  METHOD obtener_lotes_mp_x_receta.

    TYPES: BEGIN OF ty_prov,
             lifnr TYPE lifnr,
             name1 TYPE name1_gp,
           END OF ty_prov.

* Estructura para precios históricos.
    TYPES: BEGIN OF ty_preu_hist,
             matnr TYPE matnr,
             lfgja TYPE lfgja,
             lfmon TYPE lfmon,
             verpr TYPE verpr,
             peinh TYPE peinh,
             stprs TYPE verpr,
           END OF ty_preu_hist.
    DATA: ls_historic  TYPE ty_preu_hist,
          lt_preu_hist TYPE TABLE OF ty_preu_hist.


    DATA: lt_recetas   TYPE TABLE OF zspp_form_receta_mp,
          lt_proveedor TYPE STANDARD TABLE OF ty_prov.

    SELECT *
      INTO TABLE @DATA(lt_041)
      FROM ztpp0041
      WHERE werks           = @i_werks      AND
            id_receta      IN @ir_recetas   AND
            charg          IN @ir_charg     AND
            fecha_ins     IN @ir_fecha_fab  and "  fecha lanzamiento a pulper
            fecha_fabr    in @ir_fecha_turno
*            ind_sin_etiq    <> '9'
    .

* Aplicar filtro de turno.
    IF i_t1 = ' '.
      DELETE lt_041 WHERE turno = 'T1'.
    ENDIF.

    IF i_t2 = ' '.
      DELETE lt_041 WHERE turno = 'T2'.
    ENDIF.

    IF i_t3 = ' '.
      DELETE lt_041 WHERE turno = 'T3'.
    ENDIF.


    CLEAR ot_detalle_lotes.

    LOOP AT lt_041 INTO DATA(ls_041).

      APPEND INITIAL LINE TO ot_detalle_lotes ASSIGNING FIELD-SYMBOL(<fs>).

* Obtener datos de la receta
      TRY.
          DATA(ls_rec) = lt_recetas[ werks      = i_werks
                                     id_receta  = ls_041-id_receta ].
        CATCH cx_root .

          CALL METHOD zclpp_recetas_mp=>obtener_datos_form_receta_mp
            EXPORTING
              i_werks                 = i_werks
              i_id_receta             = ls_041-id_receta
            IMPORTING
              os_datos_form_receta_mp = ls_rec
              o_rc                    = DATA(o_rc).

          INSERT ls_rec INTO TABLE lt_recetas[].

      ENDTRY.

      <fs>-id_receta          = ls_041-id_receta.
      <fs>-lgort              = ls_041-lgort.
      <fs>-ind_sin_etiq       = ls_041-ind_sin_etiq.
      <fs>-descrip_rec        = ls_rec-descr_rec.
      <fs>-zcalidad           = ls_rec-zcalidad.
      <fs>-fecha_ini          = ls_rec-fecha_ini.
      <fs>-hora_ini           = ls_rec-hora_ini.
      <fs>-fecha_fin          = ls_rec-fecha_fin.
      <fs>-hora_fin           = ls_rec-hora_fin.
      <fs>-cod_motivo         = ls_rec-cod_motivo.
      <fs>-desc_calidad       = ls_rec-descr_calidad.

* Datos de PMV y IND_CONSUMO de la tabla ZTPP0041.
      <fs>-precio_med_var     = ls_041-pmv.
      <fs>-ind_consumo        = ls_041-ind_lote_consum.

      TRY.
          <fs>-desc_motivo = zclpp_recetas_mp=>gt_motivos[ werks      = i_werks
                                                           cod_motivo = <fs>-cod_motivo  ]-desc_motivo.
        CATCH cx_root .
          CLEAR <fs>-desc_motivo.
      ENDTRY.

      IF ls_041-matnr_equiv IS NOT INITIAL.
        <fs>-matnr           =  ls_041-matnr_equiv.
        <fs>-matnr_equiv     =  ls_041-matnr.
* Descripción de material
        TRY.
            <fs>-desc_mat_equiv = zclpp_recetas_mp=>gt_descr_mp[ matnr = <fs>-matnr_equiv ]-maktx.
          CATCH cx_root .
            CLEAR <fs>-desc_mat_equiv.
        ENDTRY.

      ELSE.
        <fs>-matnr           =  ls_041-matnr.
      ENDIF.

* Descripción de material
      TRY.
          <fs>-desc_mat = zclpp_recetas_mp=>gt_descr_mp[ matnr = <fs>-matnr ]-maktx.
        CATCH cx_root .
          CLEAR <fs>-desc_mat.
      ENDTRY.


      IF ls_041-ind_sin_etiq = '1' AND ls_041-charg(2) = '99'.

        SELECT SINGLE mblnr , mjahr , zeile  INTO @DATA(ls_datos_lote_herm)
          FROM ztpp0041
          WHERE werks           = @i_werks    AND
                charg   = @ls_041-lote_mp_hermano.

        ls_041-mblnr = ls_datos_lote_herm-mblnr.
        ls_041-mjahr = ls_datos_lote_herm-mjahr.
        ls_041-zeile = ls_datos_lote_herm-zeile.

      ELSEIF ls_041-ind_sin_etiq = '1' AND ls_041-charg(2) <> '99'.

        CLEAR ls_datos_lote_herm.
        SELECT SINGLE mblnr , mjahr , zeile  INTO @ls_datos_lote_herm
          FROM ztpp0041
          WHERE werks           = @i_werks    AND
                charg  IN ( SELECT lote_mp_hermano
                              FROM ztpp0041
                              WHERE werks     = @i_werks          AND
                                    id_receta = @ls_041-id_receta AND
                                    charg     = @ls_041-lote_mp_hermano
                           ).
        ls_041-mblnr = ls_datos_lote_herm-mblnr.
        ls_041-mjahr = ls_datos_lote_herm-mjahr.
        ls_041-zeile = ls_datos_lote_herm-zeile.

      ENDIF.

* Obtener datos de proveedor y de compra a partir del mov 101 o 309/531 para pulper.

      IF <fs>-matnr = gc_bobina_pulper. " Si se trata de bobina pulper, precio compra = 0.
        CLEAR     <fs>-precio_compra.
        <fs>-waers = 'EUR'. "APC20250327 Esto es simplemente por formateos del ALV
      ELSE.


        SELECT SINGLE lifnr , dmbtr , waers , budat_mkpf , ebeln , ebelp
           INTO @DATA(ls_mseg)
           FROM mseg
           WHERE mblnr = @ls_041-mblnr AND
                 mjahr = @ls_041-mjahr AND
                 zeile = @ls_041-zeile.
        IF sy-subrc = 0.
          <fs>-lifnr              = ls_mseg-lifnr.
          <fs>-precio_compra      = ls_mseg-dmbtr.
          <fs>-waers              = ls_mseg-waers.
          <fs>-budat              = ls_mseg-budat_mkpf.

* Obtener el proveedor.
          TRY.
              <fs>-name1_gp = lt_proveedor[ lifnr = <fs>-lifnr ]-name1.
            CATCH cx_root .

              SELECT SINGLE name1
                INTO <fs>-name1_gp
                FROM lfa1
                WHERE lifnr = <fs>-lifnr.

              IF sy-subrc <> 0.
                CLEAR <fs>-name1_gp.
              ELSE.
                lt_proveedor = VALUE #( ( lifnr = <fs>-lifnr
                                          name1 = <fs>-name1_gp ) ).
              ENDIF.

          ENDTRY.

          <fs>-dif_dies          =  ls_041-fecha_ins - ls_mseg-budat_mkpf.
        ENDIF.

      ENDIF.

* Obtención del precio de compra del pedido de compra
********        IF <fs>-matnr = gc_bobina_pulper. " Si se trata de bobina pulper, precio compra = 0.
********          CLEAR <fs>-precio_compra.
********
********        ELSE.
********          SELECT SINGLE * INTO @DATA(ls_prec_compra)
********             FROM ekpo
********             WHERE  ebeln = @ls_mseg-ebeln AND
********                    ebelp = @ls_mseg-ebelp .
********          IF sy-subrc = 0.
********            <fs>-precio_compra = ( ls_prec_compra-netpr * ls_041-kg_reales ) / ls_prec_compra-peinh.
********          ENDIF.
********        ENDIF.

*      ELSE.
*        CLEAR ls_mseg.

      <fs>-charg             =  ls_041-charg.
      <fs>-fecha_m311        =  ls_041-fecha_ins.
      <fs>-hora_m311         =  ls_041-hora_ins.
      <fs>-fecha_fabr        =  ls_041-fecha_fabr.
      <fs>-turno             =  ls_041-turno.
      <fs>-kg_reales         =  ls_041-kg_reales.
      <fs>-meins             =  ls_041-meins.
      <fs>-lote_mp_hermano   =  ls_041-lote_mp_hermano.
      <fs>-operario          =  ls_041-contr_ins.
      <fs>-mblnr             =  ls_041-mblnr.
      <fs>-mjahr             =  ls_041-mjahr.


      IF "( <fs>-charg(5) <> '999RR' AND <fs>-charg(5) <> '998RR' ) AND
          ( ls_041-ind_sin_etiq <> '2' AND ls_041-ind_sin_etiq <> '9' ) .

* Obtención de valor presupuestado
        DATA: l_any_pres TYPE mjahr,
              l_mes_pres TYPE bumon.

        l_any_pres = <fs>-fecha_m311(4).
        l_mes_pres = <fs>-fecha_m311+4(2).

        CALL METHOD zclpp_consumo_recetas_mp=>obtener_valor_presupuestado
          EXPORTING
            i_werks               = i_werks
            i_matnr               = <fs>-matnr
            i_kg_reales           = <fs>-kg_reales
            i_any                 = l_any_pres
            i_mes                 = l_mes_pres
          IMPORTING
            o_valor_presupuestado = <fs>-valor_presu.

        <fs>-dif_pmv_presu = <fs>-precio_med_var - <fs>-valor_presu.

      ELSE.
** Borramos campos para lotes ficticios

        CLEAR: <fs>-valor_presu , <fs>-precio_med_var , <fs>-dif_dies , <fs>-precio_compra.

      ENDIF.

      IF <fs>-ind_consumo = ' ' AND  ( <fs>-ind_sin_etiq = '1' OR <fs>-ind_sin_etiq = ' ' ).

        CLEAR: l_any_pres , l_mes_pres.
        l_any_pres = <fs>-fecha_m311(4).
        l_mes_pres = <fs>-fecha_m311+4(2).

        CALL METHOD zclpp_consumo_recetas_mp=>obtener_precio_medio_variable
          EXPORTING
            i_werks            = i_werks
            i_matnr            = <fs>-matnr
            i_kg_reales        = <fs>-kg_reales
            i_any              = l_any_pres
            i_mes              = l_mes_pres
          IMPORTING
            o_precio_medio_var = <fs>-precio_med_var.
*            o_importe_pmv      = .

      ENDIF.

* Cálculamos la diferencia.
      <fs>-dif_pmv_presu = <fs>-precio_med_var - <fs>-valor_presu.

    ENDLOOP.

  ENDMETHOD.
  METHOD obtener_next_lote_ficticio.
    DATA: l_int TYPE int4.

    CASE i_sw_pis_reg.
      WHEN 'P'.

        SELECT MAX( charg ) INTO @DATA(l_lote_max)
          FROM ztpp0041
          WHERE werks     = @i_werks     AND
                id_receta = @i_id_receta AND
                charg     LIKE '999RR%'.

        IF sy-subrc <> 0 OR l_lote_max IS INITIAL.
          o_siguiente_lote = '999RR00001'.
        ELSE.
          DATA(l_substr) = l_lote_max+5(5).

          l_int = CONV int4( l_substr ).
          l_int = l_int + 1.
          l_substr = CONV char05( l_int ).

          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = l_substr
            IMPORTING
              output = l_substr.

          o_siguiente_lote = |999RR{ l_substr }|.
        ENDIF.

      WHEN 'R'.

        SELECT MAX( charg ) INTO @l_lote_max
          FROM ztpp0041
          WHERE werks     = @i_werks     AND
                id_receta = @i_id_receta AND
                charg     LIKE '998RR%'.

        IF sy-subrc <> 0 OR l_lote_max IS INITIAL.
          o_siguiente_lote = '998RR00001'.
        ELSE.
          CLEAR l_substr.
          l_substr = l_lote_max+5(5).

          l_int = CONV int4( l_substr ).
          l_int = l_int + 1.
          l_substr = CONV char05( l_int ).

          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = l_substr
            IMPORTING
              output = l_substr.

          o_siguiente_lote = |998RR{ l_substr }|.
        ENDIF.


      WHEN OTHERS.
    ENDCASE.

  ENDMETHOD.
  METHOD obtener_precio_medio_variable.

    TRY.
        DATA(ls_historic) = gt_precio_medio_variable[ werks = i_werks
                                                      matnr = i_matnr
                                                      lfgja = i_any
                                                      lfmon = i_mes     ].

        CASE i_matnr.
          WHEN gc_bobina_pulper. " para bobina pulper obtenemos el precio standard
            o_precio_medio_var = ( ls_historic-stprs * i_kg_reales ) / ls_historic-peinh .
          WHEN OTHERS.
            o_precio_medio_var = ( ls_historic-verpr * i_kg_reales ) / ls_historic-peinh .
        ENDCASE.

      CATCH cx_root .
* Buscamos precio historico.
        SELECT SINGLE  bwkey , matnr , lfgja , lfmon , verpr , peinh , stprs
                            FROM mbewh
                            INTO @ls_historic
                            WHERE "werks = @i_werks AND
                                  matnr = @i_matnr      AND
                                  lfgja = @i_any      AND
                                  lfmon = @i_mes      AND
                                  bwkey = @i_werks    AND
                                  vprsv = 'V'.
        IF sy-subrc <> 0.
          CLEAR ls_historic.

* Si no hay histórico, buscamos precio actual.
          SELECT SINGLE verpr , peinh , stprs
            FROM mbew
            INTO @DATA(ls_preu_act)
            WHERE matnr = @i_matnr AND
                  bwkey = @i_werks        AND
                  bwtar = ' '.
          IF sy-subrc = 0.
            TRY.
                gt_precio_medio_variable = VALUE #( ( werks = i_werks
                                                      matnr = i_matnr
                                                      lfgja = i_any
                                                      lfmon = i_mes
                                                      verpr = ls_preu_act-verpr
                                                      peinh = ls_preu_act-peinh
                                                      stprs = ls_preu_act-stprs
                                                   ) ).
              CATCH cx_root .
            ENDTRY.

            ls_historic-verpr = ls_preu_act-verpr.
            ls_historic-peinh = ls_preu_act-peinh.
            ls_historic-stprs = ls_preu_act-stprs.
          ENDIF.

        ELSE.
          TRY.
              gt_precio_medio_variable = VALUE #( ( werks = i_werks
                                                    matnr = ls_historic-matnr
                                                    lfgja = ls_historic-lfgja
                                                    lfmon = ls_historic-lfmon
                                                    verpr = ls_historic-verpr
                                                    peinh = ls_historic-peinh
                                                    stprs = ls_historic-stprs
                                                 ) ).
            CATCH cx_root .
          ENDTRY.
        ENDIF.
    ENDTRY.

    IF ls_historic IS NOT INITIAL.
      CASE i_matnr.
        WHEN gc_bobina_pulper. " para bobina pulper obtenemos el precio standard
          o_precio_medio_var = ( ls_historic-stprs * i_kg_reales ) / ls_historic-peinh .
          o_importe_pmv      = ls_historic-stprs.
        WHEN OTHERS.
          o_precio_medio_var = ( ls_historic-verpr * i_kg_reales ) / ls_historic-peinh .
          o_importe_pmv      = ls_historic-verpr.
      ENDCASE.
    ENDIF.


  ENDMETHOD.
  METHOD obtener_valor_presupuestado.

    TRY.
        DATA(ls_45) = gt_datos_presu[ werks    = i_werks
                                      mjahr    = i_any
                                      matnr    = i_matnr
                                      periodo  = i_mes ].

        o_valor_presupuestado   = ( ls_45-precio * i_kg_reales ) / 1000 .

      CATCH cx_root .

        SELECT SINGLE * INTO @ls_45
          FROM ztpp0045
          WHERE werks   = @i_werks       AND
                mjahr   = @i_any    AND
                matnr   = @i_matnr    AND
                periodo IN ( SELECT MAX( periodo )
                              FROM ztpp0045
                              WHERE werks    = @i_werks  AND
                                    mjahr    = @i_any    AND
                                    matnr    = @i_matnr  AND
                                    periodo <= @i_mes
                            ).

        IF sy-subrc = 0.
          o_valor_presupuestado   = ( ls_45-precio * i_kg_reales ) / 1000 .
*          <fs>-dif_pmv_presu = <fs>-precio_med_var - <fs>-valor_presu.

          gt_datos_presu = VALUE #( ( werks   = i_werks
                                      matnr   = i_matnr
                                      mjahr   = i_any
                                      periodo = i_mes
                                      precio  = ls_45-precio
                                       ) ).

        ENDIF.

    ENDTRY.

  ENDMETHOD.
