
class ZHCL_PP_CORE definition
  public
  inheriting from ZHCL_CORE
  final
  create public .

public section.

  types:
    BEGIN OF t_situacion,
        aufnr     TYPE aufnr,
        situacion TYPE zssd_de_situacion,
      END OF t_situacion .
  types:
    tt_situacion TYPE SORTED TABLE OF t_situacion WITH UNIQUE KEY aufnr .
  types:
    BEGIN OF t_ruta,
        matnr TYPE matnr,
        werks TYPE werks_d,
        ruta  TYPE string,
      END OF t_ruta .
  types:
    tt_ruta TYPE SORTED TABLE OF t_ruta WITH UNIQUE KEY matnr werks .
  types:
    BEGIN OF zcgty_s_consumption_data,
        bwart TYPE bwart,
        aufnr TYPE aufnr,
        vornr TYPE vornr,
        werks TYPE werks_d,
        lgort TYPE lgort_d,
        matnr TYPE matnr,
        charg TYPE charg_d,
        menge TYPE menge_d,
        meins TYPE meins,
        lgtyp TYPE lgtyp,
        lgpla TYPE lgpla,
        fnoti TYPE boolean, " forzar notificación
        fmigo TYPE boolean, " forzar migo
      END OF zcgty_s_consumption_data .
  types:
    BEGIN OF zcgty_s_cinumber_cons_result.
             INCLUDE TYPE afwi.
    TYPES:   cinum TYPE lvs_benum,
             lenum TYPE lenum,
             bwart TYPE bwart,
             aufnr TYPE aufnr,
             vornr TYPE vornr,
             rsnum TYPE rsnum,
             rspos TYPE rspos,
             werks TYPE werks_d,
             lgort TYPE lgort_d,
             matnr TYPE matnr,
             charg TYPE charg_d,
             menge TYPE menge_d,
             rmeng TYPE menge_d,
             meins TYPE meins,
             lgtyp TYPE lgtyp,
             lgpla TYPE lgpla,
             budat TYPE budat,
             uzeit TYPE uzeit,
             machi TYPE arbpl,
             tbnum TYPE tbnum,
             tbpos TYPE tbpos,
             tanum TYPE tanum,
             tapos TYPE tapos,
             proce TYPE zprocesado_wm,
             conta TYPE zcontabilizado_wm,
             msgtx TYPE msgtx,
             uname TYPE uname,
           END OF zcgty_s_cinumber_cons_result .
  types:
    zcgty_t_consumption_data     TYPE STANDARD TABLE OF zcgty_s_consumption_data .
  types:
    zcgty_t_cinumber_cons_result TYPE STANDARD TABLE OF zcgty_s_cinumber_cons_result WITH EMPTY KEY .

  constants C_TIPO_CONSUMO_MIGO type INT1 value 2 ##NO_TEXT.
  constants C_TIPO_CONSUMO_NOTIF type INT1 value 1 ##NO_TEXT.
  constants C_TIPO_CONSUMO_NOTIF_MIGO type INT1 value 3 ##NO_TEXT.
  class-data C_CLASS_LABEL type MSGID read-only value 'ZHCL_PP_CORE' ##NO_TEXT.
  constants C_CLASE_MOV_CONSUMOS type BWART value '261' ##NO_TEXT.
  data I_SITUACION type TT_SITUACION .
  data I_RUTA type TT_RUTA .

  methods CONSUMO_BOBINA_CINUMBER
    importing
      value(VP_CINUMBER) type ZWM_INTF_OMP_SAP-CINUMBER
      value(VP_DIAM) type BSTMG
      value(VP_LENUM) type LQUA-LENUM
      value(VP_LGNUM) type LAGP-LGNUM
      value(VP_LGPLA) type LAGP-LGPLA
      value(VP_LGTYP) type LAGP-LGTYP
      value(VP_TESTRUN) type TESTRUN optional
    returning
      value(TP_CONSUMOS) type ZWM_T_CONSUMOS_PP
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  methods CONSUMO_BOBINA_CINUMBER_WM
    importing
      !I_TYPE type INT1 default C_TIPO_CONSUMO_NOTIF_MIGO
      !I_DATUM type BUCHDATUM optional
      !I_UZEIT type UZEIT optional
      !I_CINUMBER type LVS_BENUM
      !I_WERKS type WERKS_D
      !I_LGORT type LGORT_D
      !I_LENUM type LENUM
      !I_MENGE type MENGE_D
      !I_MEINS type MEINS
      !I_LGTYP type LGTYP
      !I_LGPLA type LGPLA
      value(I_TESTRUN) type TESTRUN optional
      !I_TEST_CONSUMOS_PREVIOS type MSEG-MENGE optional
      !I_COD_CONSUMO type ZWM_COD_CONSUMO default '02'
      !O_LOG type ref to ZCL_AP_LOG optional
    exporting
      !E_TOLERANCIA type ZWM_VALOR_TOLERANCIA
      !E_TOLERANCIA_MEINS type MEINS
      !E_STOCK_WM_KG type MSEG-MENGE
      !E_MENGE_KG type MSEG-MENGE
      !E_CTD_CONSU_KG type MSEG-MENGE
      !E_MEINH type MEINS
    returning
      value(R_T_RESULT) type ZCGTY_T_CINUMBER_CONS_RESULT
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  methods CONSUMO_ORDEN_PRODUCCION
    importing
      !I_TYPE type INT1 default C_TIPO_CONSUMO_NOTIF
      !I_DATUM type BUCHDATUM optional
      !I_UZEIT type UZEIT optional
      !I_T_COMPSUMPTION_DATA type ZCGTY_T_CONSUMPTION_DATA
      value(I_TESTRUN) type TESTRUN optional
    returning
      value(R_T_AFWI) type TY_T_AFWI
    raising
      /IWBEP/CX_MGW_BUSI_EXCEPTION .
  methods CONSTRUCTOR
    importing
      !IMPORT_DATOS_GLOBALES type ABAP_BOOL default '' .
  methods GET_SITUACION_OF
    importing
      !AUFNR type AUFNR
      !TCODE type SY-TCODE default SY-TCODE
    returning
      value(SITUACION) type ZSSD_DE_SITUACION .
  methods GET_OF_FROM_DOC
    importing
      !VGBEL type LIPS-VGBEL
      !VGPOS type LIPS-VGPOS
      !WERKS type LIPS-WERKS
      !MATNR type MATNR optional
    returning
      value(AUFNR) type AUFNR .
  class-methods S_CONV_CINUMBER_2_INTERNAL
    importing
      !I_MJAHR type MJAHR
      !I_CINUMBER type LVS_BENUM
    returning
      value(R_CINUMBER) type LVS_BENUM .
  class-methods S_CONV_CINUMBER_2_EXTERNAL
    importing
      !I_CINUMBER type LVS_BENUM
    returning
      value(R_CINUMBER) type LVS_BENUM .
  methods GET_RUTA
    importing
      !MATNR type MATNR
      !WERKS type WERKS_D
    returning
      value(RUTA) type STRING .
  methods EXPORT_DATOS_GLOBALES .
  methods IMPORT_DATOS_GLOBALES .
  PROTECTED SECTION.

  PRIVATE SECTION.
    METHODS _update_zwm_consumos_pp_table
      IMPORTING i_s_zwm_consumos_pp TYPE zwm_consumos_pp
      RETURNING VALUE(r_result)     TYPE subrc.

    METHODS _map_zwmconsumospp_w_ciresult
      IMPORTING i_is_new                   TYPE boolean DEFAULT 'X'
                i_s_cinum_result           TYPE zcgty_s_cinumber_cons_result
      RETURNING VALUE(r_s_zwm_consumos_pp) TYPE zwm_consumos_pp.

    METHODS _consumo_orden_pp_migo
      IMPORTING VALUE(i_datum)        TYPE buchdatum OPTIONAL
                VALUE(i_uzeit)        TYPE uzeit     OPTIONAL
                i_t_compsumption_data TYPE zcgty_t_consumption_data
                VALUE(i_testrun)      TYPE testrun   OPTIONAL
                VALUE(i_commit)       TYPE xfeld     DEFAULT 'X'
      RETURNING VALUE(r_t_afwi)       TYPE ty_t_afwi
      RAISING   /iwbep/cx_mgw_busi_exception.

    METHODS _consumo_orden_pp_w_tt
      IMPORTING i_datum               TYPE buchdatum OPTIONAL
                i_uzeit               TYPE uzeit     OPTIONAL
                i_t_compsumption_data TYPE zcgty_t_consumption_data
                VALUE(i_testrun)      TYPE testrun   OPTIONAL
      RETURNING VALUE(r_t_afwi)       TYPE ty_t_afwi
      RAISING   /iwbep/cx_mgw_busi_exception.

    METHODS _consumo_orden_pp_w_tt_migo
      IMPORTING i_datum               TYPE buchdatum OPTIONAL
                i_uzeit               TYPE uzeit     OPTIONAL
                i_t_compsumption_data TYPE zcgty_t_consumption_data
                VALUE(i_testrun)      TYPE testrun   OPTIONAL
      RETURNING VALUE(r_t_afwi)       TYPE ty_t_afwi
      RAISING   /iwbep/cx_mgw_busi_exception.

    METHODS _build_tt_data
      IMPORTING i_datum                    TYPE buchdatum OPTIONAL
                i_uzeit                    TYPE uzeit     OPTIONAL
                i_werks                    TYPE werks_d   OPTIONAL
                i_aufnr                    TYPE aufnr
                i_vornr                    TYPE vornr
                i_cortext                  TYPE co_rtext
      RETURNING VALUE(r_s_timeticket_data) TYPE bapi_pp_timeticket
      RAISING   /iwbep/cx_mgw_busi_exception.

    METHODS _build_migo_data
      IMPORTING i_s_comp_data            TYPE zcgty_s_consumption_data
      RETURNING VALUE(r_s_goodsmvt_data) TYPE bapi2017_gm_item_create
      RAISING   /iwbep/cx_mgw_busi_exception.
endclass. "ZHCL_PP_CORE definition
class ZHCL_PP_CORE implementation.
  METHOD _build_migo_data.
**********************************************************************
* Parámetros locales
**********************************************************************

    DATA ls_comp_data TYPE zcgty_s_consumption_data.

**********************************************************************
* Validaciones
**********************************************************************

****** PREPARE DATA

    MOVE-CORRESPONDING i_s_comp_data TO ls_comp_data.

****** IMPORT DATA

***** GOODSMVT

    IF ls_comp_data-bwart IS INITIAL.
      ls_comp_data-bwart = c_clase_mov_consumos.
    ENDIF.

***** MATNR

    IF ls_comp_data-matnr IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha indicado un número de material válido.' ).
    ENDIF.

***** AUFNR

    IF ls_comp_data-aufnr IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'El número de OF no es válido.' ).
    ENDIF.

***** WERKS

    IF ls_comp_data-werks IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'El código de centro no es válido.' ).
    ENDIF.

***** LGORT

    IF ls_comp_data-lgort IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'El código de almacén no es válido.' ).
    ENDIF.

***** MENGE

    IF ls_comp_data-menge IS INITIAL OR ls_comp_data-menge <= 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'La cantidad no ha sido informada.' ).
    ENDIF.

***** MENGE

    IF ls_comp_data-meins IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'La unidad de medida no ha sido informada.' ).
    ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** FILL DATA

***** GOODS_MVT

    r_s_goodsmvt_data = VALUE #( move_type = ls_comp_data-bwart
                                 entry_qnt = ls_comp_data-menge
                                 entry_uom = ls_comp_data-meins
                                 material  = ls_comp_data-matnr
                                 plant     = ls_comp_data-werks
                                 stge_loc  = ls_comp_data-lgort
                                 batch     = ls_comp_data-charg
                                 stge_type = ls_comp_data-lgtyp
                                 stge_bin  = ls_comp_data-lgpla ).
  ENDMETHOD.
  METHOD _build_tt_data.
**********************************************************************
* Parámetros locales
**********************************************************************

    DATA: lv_cons_date TYPE datum,
          lv_cons_time TYPE uzeit.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** DATUM

    IF i_datum IS NOT INITIAL.
      lv_cons_date = i_datum.
    ELSE.
      lv_cons_date = sy-datum.
    ENDIF.

***** UZEIT

    IF i_uzeit IS NOT INITIAL.
      lv_cons_time = i_uzeit.
    ELSE.
      lv_cons_time = sy-uzeit.
    ENDIF.

***** AUFNR

    IF i_aufnr IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'El número de OF no es válido.' ).
    ENDIF.

***** VORNR

    IF i_vornr IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'El número de operación no es válido.' ).
    ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** RETURN DATA

    r_s_timeticket_data = VALUE #( postg_date      = lv_cons_date
                                   orderid         = i_aufnr
                                   operation       = i_vornr
                                   conf_text       = i_cortext
                                   plant           = i_werks
                                   exec_start_date = lv_cons_date
                                   exec_start_time = lv_cons_time
                                   exec_fin_date   = lv_cons_date
                                   exec_fin_time   = lv_cons_time
                                   ex_created_by   = sy-uname ).
  ENDMETHOD.
  METHOD _consumo_orden_pp_migo.
    DATA: wl_goodsmvt_header  TYPE bapi2017_gm_head_01,
          vl_goodsmvt_code    TYPE bapi2017_gm_code,
          tl_goodsmvt_item    TYPE TABLE OF bapi2017_gm_item_create,
          vl_materialdocument TYPE bapi2017_gm_head_ret-mat_doc,
          vl_matdocumentyear  TYPE bapi2017_gm_head_ret-doc_year.
    DATA tl_return TYPE TABLE OF bapiret2.

    CHECK i_t_compsumption_data IS NOT INITIAL.

    IF i_datum IS INITIAL. i_datum = sy-datum. ENDIF.
    IF i_uzeit IS INITIAL. i_uzeit = sy-uzeit. ENDIF.

    wl_goodsmvt_header-pstng_date = i_datum.
    wl_goodsmvt_header-doc_date   = i_datum.
    wl_goodsmvt_header-pr_uname   = sy-uname.
    vl_goodsmvt_code              = '06'.

    SELECT aufnr, vornr, rsnum, rspos, rsart      ##NULL_VALUES_OK
      INTO TABLE @DATA(tl_resb)
      FROM resb
      FOR ALL ENTRIES IN @i_t_compsumption_data
      WHERE aufnr = @i_t_compsumption_data-aufnr
        AND vornr = @i_t_compsumption_data-vornr
        AND matnr = @i_t_compsumption_data-matnr
        AND xloek = @space.

    LOOP AT i_t_compsumption_data INTO DATA(wl_consumo).
      IF wl_consumo-bwart IS INITIAL. wl_consumo-bwart = c_clase_mov_consumos. ENDIF.

      READ TABLE tl_resb INTO DATA(wl_resb) WITH KEY aufnr = wl_consumo-aufnr
                                                     vornr = wl_consumo-vornr.
      IF sy-subrc <> 0.
        CLEAR wl_resb.
      ENDIF.

      APPEND INITIAL LINE TO tl_goodsmvt_item ASSIGNING FIELD-SYMBOL(<fs_goodsmvt_item>).
      <fs_goodsmvt_item>-material  = wl_consumo-matnr.
      <fs_goodsmvt_item>-plant     = wl_consumo-werks.
      <fs_goodsmvt_item>-stge_loc  = wl_consumo-lgort.
      <fs_goodsmvt_item>-batch     = wl_consumo-charg.
      <fs_goodsmvt_item>-entry_qnt = wl_consumo-menge.
      <fs_goodsmvt_item>-entry_uom = wl_consumo-meins.
      <fs_goodsmvt_item>-orderid   = wl_consumo-aufnr.
      <fs_goodsmvt_item>-activity  = wl_consumo-vornr.
      <fs_goodsmvt_item>-move_type = wl_consumo-bwart.
      <fs_goodsmvt_item>-reserv_no = wl_resb-rsnum.
      <fs_goodsmvt_item>-res_item  = wl_resb-rspos.
      <fs_goodsmvt_item>-res_type  = wl_resb-rsart.
      <fs_goodsmvt_item>-item_text = |CDE/{ wl_consumo-lgtyp }/{ wl_consumo-lgpla }|.
    ENDLOOP.

    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = wl_goodsmvt_header
        goodsmvt_code    = vl_goodsmvt_code
        testrun          = i_testrun
      IMPORTING
        materialdocument = vl_materialdocument
        matdocumentyear  = vl_matdocumentyear
      TABLES
        goodsmvt_item    = tl_goodsmvt_item
        return           = tl_return.

    zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = tl_return ).

    LOOP AT tl_goodsmvt_item ASSIGNING <fs_goodsmvt_item>.
      APPEND INITIAL LINE TO r_t_afwi ASSIGNING FIELD-SYMBOL(<fs_afwi>).
      <fs_afwi>-mblnr = vl_materialdocument.
      <fs_afwi>-mjahr = vl_matdocumentyear.
      <fs_afwi>-mblpo = sy-tabix.
    ENDLOOP.

    IF i_testrun = space AND i_commit = 'X'.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
    ENDIF.

***********************************************************************
** Variables
***********************************************************************
*
*  DATA: lv_cons_date          TYPE datum,
*        lv_cons_time          TYPE uzeit,
*        lv_index              TYPE i,
*        lv_garg               TYPE seqg3-garg,
*        lv_post_wrong_entries TYPE bapi_coru_param-ins_err VALUE '0'.
*
*  DATA: ls_return1 TYPE bapiret1,
*        ls_return2 TYPE bapiret2.
*
*  DATA: lt_timeticket    TYPE bapi_pp_timeticket_tt,
*        lt_goodsmvnts    TYPE bapi2017_gm_item_create_t,
*        lt_lconf_gmov     TYPE bapi_link_conf_goodsmov_tt,
*        lt_enq           TYPE TABLE OF seqg3,
*        lt_detail_return TYPE TABLE OF bapi_coru_return,
*        lt_return        TYPE bapiret2_t.
*
***********************************************************************
** Validaciones
***********************************************************************

*  IF ( i_datum IS NOT INITIAL ).
*    lv_cons_date = i_datum.
*  ELSE.
*    lv_cons_date = sy-datum.
*  ENDIF.
*
*  IF ( i_uzeit IS NOT INITIAL ).
*    lv_cons_time = i_uzeit.
*  ELSE.
*    lv_cons_time = sy-uzeit.
*  ENDIF.
*
***********************************************************************
** Lógica
***********************************************************************
*
******* PREPARE DATA
*
****** FILL COMPSUMPTION DATA
*
*  LOOP AT i_t_compsumption_data INTO DATA(ls_compsumption_data).
*
***** CHECKS
*
*    IF ( ls_compsumption_data-bwart IS INITIAL ).
*      ls_compsumption_data-bwart = '261'.
*    ENDIF.
*
*    IF ( ls_compsumption_data-aufnr IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = '' number = '001' message = 'No se ha informado a orden de consumo' ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-vornr IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la operación de la orden' message_v1 = ls_compsumption_data-aufnr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-werks IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el centro' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-lgort IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el almacén' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-matnr IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el material a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-charg IS INITIAL ).
*     APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el lote a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-menge IS INITIAL OR ls_compsumption_data-menge <= 0 ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la cantidad a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    IF ( ls_compsumption_data-meins IS INITIAL ).
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la unidad de medida a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
*    CLEAR: lv_garg.
*    CONCATENATE sy-mandt ls_compsumption_data-matnr ls_compsumption_data-werks INTO lv_garg RESPECTING BLANKS.
*    CALL FUNCTION 'ENQUEUE_READ'
*      EXPORTING
*        gclient = sy-mandt
*        gname   = 'MARC'
*        garg    = lv_garg
*        guname  = sy-uname
*      TABLES
*        enq     = lt_enq.
*    IF lt_enq IS NOT INITIAL.
*      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'Material bloqueado por usuario o proceso'
*                      message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*      CONTINUE.
*    ENDIF.
*
***** FILL DATA
*
**** TIMETICKET
*
*    APPEND VALUE #( postg_date = lv_cons_date orderid = ls_compsumption_data-aufnr operation = ls_compsumption_data-vornr conf_text = space
*                    exec_start_date = lv_cons_date exec_start_time = lv_cons_time exec_fin_date = lv_cons_date exec_fin_time = lv_cons_time ex_created_by = sy-uname ) TO lt_timeticket.
*
**** GOODS_MVT
*
*    APPEND VALUE #( move_type = ls_compsumption_data-bwart entry_qnt = ls_compsumption_data-menge entry_uom = ls_compsumption_data-meins material = ls_compsumption_data-matnr
*                    plant = ls_compsumption_data-werks stge_loc = ls_compsumption_data-lgort batch = ls_compsumption_data-charg stge_type = ls_compsumption_data-lgtyp stge_bin = ls_compsumption_data-lgpla ) TO lt_goodsmvnts.
*
**** LINK CONF GOODS_MVT
*
*    ADD 1 TO lv_index.
*    APPEND VALUE #( index_confirm = lv_index index_goodsmov = lv_index ) TO lt_lconf_gmov.
*
*  ENDLOOP.
*
****** CHECKS
*
***** ERRORES
*
*  READ TABLE lt_return INTO DATA(ls_return) WITH KEY type = 'E'.
*  IF ( sy-subrc = 0 ).
*    zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).
*  ENDIF.
*
***** COMPSUMPTION DATA
*
**** DATA FILLED
*
*  IF ( lines( lt_goodsmvnts ) <= 0 ).
*    zcl_seis_odata_utils=>lanzar_excepcion( 'No se han podido determinar consumos' ).
*  ENDIF.
*
***** COMPSUMPTION
*
*  CALL FUNCTION 'BAPI_PRODORDCONF_CREATE_TT'
*    EXPORTING
*      post_wrong_entries = lv_post_wrong_entries
*      testrun            = i_testrun
*    IMPORTING
*      return             = ls_return1
*    TABLES
*      timetickets        = lt_timeticket
*      goodsmovements     = lt_goodsmvnts
*      link_conf_goodsmov = lt_lconf_gmov
*      detail_return      = lt_detail_return
*    EXCEPTIONS
*      error_message      = 1.
*
***** SAVE OR NOT
*
*  IF ( sy-subrc = 0 ).
*
*    IF ( line_exists( lt_detail_return[ type = 'E' ] ) ).
*
*      ROLLBACK WORK.
*      MOVE-CORRESPONDING lt_detail_return TO lt_return.
*      zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).
*
*    ELSE.
*
*      IF ( i_testrun <> abap_true ).
*
*        COMMIT WORK AND WAIT.
*
*        READ TABLE lt_detail_return INTO DATA(ls_detail_return) INDEX 1.
*
*        "Espero a que se actualice el documento de material en AFWI
*        DO 5 TIMES.
*
*          SELECT COUNT(*) UP TO 1 ROWS
*            FROM afwi
*           WHERE rueck = @ls_detail_return-conf_no
*             AND rmzhl = @ls_detail_return-conf_cnt
*             AND mblnr <> @space
*             AND mjahr <> @space
*             AND mblpo <> @space.
*
*          IF ( sy-subrc = 0 ).
*            EXIT.
*          ELSE.
*            WAIT UP TO 1 SECONDS.
*          ENDIF.
*
*        ENDDO.
*
*        "Cuando se actualiza, recupero los datos de AFWI
*        LOOP AT lt_detail_return INTO DATA(ls_getail_return).
*
*          SELECT SINGLE *
*            FROM afwi
*            INTO @DATA(ls_afwi)
*           WHERE rueck = @ls_getail_return-conf_no
*             AND rmzhl = @ls_getail_return-conf_cnt.
*
*          IF ( sy-subrc = 0 ).
*            APPEND ls_afwi TO r_t_afwi.
*          ENDIF.
*
*        ENDLOOP.
*
*      ELSE.
*
*        "En modo test no tenemos notificaciones...recuperamos datos para que no vuelva la tabla vacía
*        LOOP AT lt_detail_return INTO ls_detail_return.
*          APPEND VALUE #( rueck = ls_detail_return-conf_no rmzhl = ls_detail_return-conf_cnt ) TO r_t_afwi.
*        ENDLOOP.
*
*      ENDIF.
*
*    ENDIF.
*
*  ENDIF.
  ENDMETHOD.
  METHOD _consumo_orden_pp_w_tt.
**********************************************************************
* Parámetros locales
**********************************************************************

    " TODO: variable is assigned but never used (ABAP cleaner)
    DATA: lv_cons_date          TYPE datum,
          " TODO: variable is assigned but never used (ABAP cleaner)
          lv_cons_time          TYPE uzeit,
          lv_index              TYPE i,
          lv_garg               TYPE seqg3-garg,
          lv_post_wrong_entries TYPE bapi_coru_param-ins_err VALUE '0'.
    DATA: lt_timeticket    TYPE bapi_pp_timeticket_tt,
          lt_return        TYPE bapiret2_t,
          lt_goodsmvnts    TYPE bapi2017_gm_item_create_t,
          lt_lconf_gmov    TYPE bapi_link_conf_goodsmov_tt,
          lt_enq           TYPE TABLE OF seqg3,
          lt_detail_return TYPE TABLE OF bapi_coru_return.
    " TODO: variable is assigned but never used (ABAP cleaner)
    DATA ls_return1 TYPE bapiret1.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

    IF i_datum IS NOT INITIAL.
      lv_cons_date = i_datum.
    ELSE.
      lv_cons_date = sy-datum.
    ENDIF.

    IF i_uzeit IS NOT INITIAL.
      lv_cons_time = i_uzeit.
    ELSE.
      lv_cons_time = sy-uzeit.
    ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

    LOOP AT i_t_compsumption_data INTO DATA(ls_compsumption_data).

***** FILL TT DATA

      IF ls_compsumption_data-fnoti = abap_true.

        TRY.
            APPEND me->_build_tt_data( i_datum = i_datum i_uzeit = i_uzeit i_werks = ls_compsumption_data-werks i_aufnr = ls_compsumption_data-aufnr i_vornr = ls_compsumption_data-vornr i_cortext = space ) TO lt_timeticket.
          CATCH /iwbep/cx_mgw_busi_exception INTO DATA(lo_exception).
            APPEND VALUE #( type = 'E' id = '' number = '001' message = lo_exception->if_message~get_text( ) ) TO lt_return.
            CONTINUE.
        ENDTRY.

      ENDIF.

***** FILL COMPSUMPTION DATA

      IF ls_compsumption_data-fmigo = abap_true.

        TRY.
            APPEND me->_build_migo_data( i_s_comp_data = ls_compsumption_data ) TO lt_goodsmvnts.
          CATCH /iwbep/cx_mgw_busi_exception INTO lo_exception.
            APPEND VALUE #( type = 'E' id = '' number = '001' message = lo_exception->if_message~get_text( ) ) TO lt_return.
            CONTINUE.
        ENDTRY.

***** FILL INDEX

        lv_index = lv_index + 1.
        APPEND VALUE #( index_confirm = lv_index index_goodsmov = lv_index ) TO lt_lconf_gmov.

      ENDIF.

***** CHECK BLOCKED MATNR

      IF i_testrun IS INITIAL.
        CLEAR lv_garg.
        CONCATENATE sy-mandt ls_compsumption_data-matnr ls_compsumption_data-werks INTO lv_garg RESPECTING BLANKS.
        CALL FUNCTION 'ENQUEUE_READ'
          EXPORTING
            gclient = sy-mandt
            gname   = 'MARC'
            garg    = lv_garg
            guname  = sy-uname
          TABLES
            enq     = lt_enq.
        IF lt_enq IS NOT INITIAL.
          APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'Material bloqueado por usuario o proceso'
                          message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
          CONTINUE.
        ENDIF.
      ENDIF.

    ENDLOOP.

***** CHECKS

**** ERRORES

    " TODO: variable is assigned but never used (ABAP cleaner)
    READ TABLE lt_return INTO DATA(ls_return) WITH KEY type = 'E'.
    IF sy-subrc = 0.
      zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).
    ENDIF.

**** COMPSUMPTION

    CALL FUNCTION 'BAPI_PRODORDCONF_CREATE_TT'
      EXPORTING
        post_wrong_entries = lv_post_wrong_entries
        testrun            = i_testrun
      IMPORTING
        return             = ls_return1
      TABLES
        timetickets        = lt_timeticket
        goodsmovements     = lt_goodsmvnts
        link_conf_goodsmov = lt_lconf_gmov
        detail_return      = lt_detail_return
      EXCEPTIONS
        error_message      = 1.

    EXIT.

**** SAVE OR NOT

    IF sy-subrc = 0.

      IF line_exists( lt_detail_return[ type = 'E' ] ).

        ROLLBACK WORK.
        MOVE-CORRESPONDING lt_detail_return TO lt_return.
        zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).

      ELSE.

        IF i_testrun <> abap_true. " Chequeamos si modo test

          COMMIT WORK AND WAIT.

          READ TABLE lt_detail_return INTO DATA(ls_detail_return) INDEX 1.

          IF lines( lt_goodsmvnts ) > 0.

            " Espero a que se actualice el documento de material en AFWI
            DO 5 TIMES.

              SELECT COUNT(*) UP TO 1 ROWS
                FROM afwi
               WHERE rueck  = @ls_detail_return-conf_no
                 AND rmzhl  = @ls_detail_return-conf_cnt
                 AND mblnr <> @space
                 AND mjahr <> @space
                 AND mblpo <> @space.

              IF sy-subrc = 0.
                EXIT.
              ELSE.
                WAIT UP TO 1 SECONDS.
              ENDIF.

            ENDDO.

            " Cuando se actualiza, recupero los datos de AFWI
            LOOP AT lt_detail_return INTO DATA(ls_getail_return).

              SELECT SINGLE *
                FROM afwi
                INTO @DATA(ls_afwi)
               WHERE rueck = @ls_getail_return-conf_no
                 AND rmzhl = @ls_getail_return-conf_cnt.

              IF sy-subrc = 0.
                APPEND ls_afwi TO r_t_afwi.
              ENDIF.

            ENDLOOP.

          ELSE.

            " Si no se consume nada, devolvemos solo notificación
            LOOP AT lt_detail_return INTO ls_detail_return.
              APPEND VALUE #( rueck = ls_detail_return-conf_no rmzhl = ls_detail_return-conf_cnt ) TO r_t_afwi.
            ENDLOOP.

          ENDIF.

        ELSE. " MODO TEST

          " En modo test no tenemos notificaciones...recuperamos datos para que no vuelva la tabla vacía
          LOOP AT lt_detail_return INTO ls_detail_return.
            APPEND VALUE #( rueck = ls_detail_return-conf_no rmzhl = ls_detail_return-conf_cnt ) TO r_t_afwi.
          ENDLOOP.

        ENDIF.

      ENDIF.

    ENDIF.

******
************ PREPARE DATA
******
*********** FILL COMPSUMPTION DATA
******
******  LOOP AT i_t_compsumption_data INTO DATA(ls_compsumption_data).
******
********** CHECKS
******
******    IF ( ls_compsumption_data-bwart IS INITIAL ).
******      ls_compsumption_data-bwart = '261'.
******    ENDIF.
******
******    IF ( ls_compsumption_data-aufnr IS INITIAL ).
******      APPEND VALUE #( type = 'E' id = '' number = '001' message = 'No se ha informado a orden de consumo' ) TO lt_return.
******      CONTINUE.
******    ENDIF.
******
******    IF ( ls_compsumption_data-vornr IS INITIAL ).
******      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la operación de la orden' message_v1 = ls_compsumption_data-aufnr ) TO lt_return.
******      CONTINUE.
******    ENDIF.
******
******    IF ( ls_compsumption_data-werks IS INITIAL ).
******      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el centro' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
******      CONTINUE.
******    ENDIF.
******
******    IF ( ls_compsumption_data-lgort IS INITIAL ).
******      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el almacén' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
******      CONTINUE.
******    ENDIF.
******
******    "Chequeamos si debe notificarse realmente o no.
******    "Hay CIs que interesa notificar una operación de una OF pero no otra
******    CHECK ls_compsumption_data-fnoti = abap_true.
******
*********    IF ( ls_compsumption_data-matnr IS INITIAL ).
*********      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el material a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*********      CONTINUE.
*********    ENDIF.
*********
*********    IF ( ls_compsumption_data-charg IS INITIAL ).
*********     APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado el lote a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*********      CONTINUE.
*********    ENDIF.
******
*********    IF ( ls_compsumption_data-menge IS INITIAL OR ls_compsumption_data-menge <= 0 ).
*********      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la cantidad a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*********      CONTINUE.
*********    ENDIF.
*********
*********    IF ( ls_compsumption_data-meins IS INITIAL ).
*********      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'No se ha informado la unidad de medida a consumir' message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
*********      CONTINUE.
*********    ENDIF.
******
******    CLEAR: lv_garg.
******    CONCATENATE sy-mandt ls_compsumption_data-matnr ls_compsumption_data-werks INTO lv_garg RESPECTING BLANKS.
******    CALL FUNCTION 'ENQUEUE_READ'
******      EXPORTING
******        gclient = sy-mandt
******        gname   = 'MARC'
******        garg    = lv_garg
******        guname  = sy-uname
******      TABLES
******        enq     = lt_enq.
******    IF lt_enq IS NOT INITIAL.
******      APPEND VALUE #( type = 'E' id = zhcl_pp_core=>c_class_label number = '001' message = 'Material bloqueado por usuario o proceso'
******                      message_v1 = ls_compsumption_data-aufnr message_v2 = ls_compsumption_data-vornr ) TO lt_return.
******      CONTINUE.
******    ENDIF.
******
********** FILL DATA
******
********* TIMETICKET
******
******    APPEND VALUE #( postg_date = lv_cons_date orderid = ls_compsumption_data-aufnr operation = ls_compsumption_data-vornr conf_text = space
******                    exec_start_date = lv_cons_date exec_start_time = lv_cons_time exec_fin_date = lv_cons_date exec_fin_time = lv_cons_time ex_created_by = sy-uname ) TO lt_timeticket.
******
******    IF (  ls_compsumption_data-matnr IS NOT INITIAL
******      AND ls_compsumption_data-bwart IS NOT INITIAL
******      AND ( ls_compsumption_data-menge IS NOT INITIAL AND ls_compsumption_data-menge > 0 )
******      AND ls_compsumption_data-meins IS NOT INITIAL ).
******
********* GOODS_MVT
******
******      APPEND VALUE #( move_type = ls_compsumption_data-bwart entry_qnt = ls_compsumption_data-menge entry_uom = ls_compsumption_data-meins material = ls_compsumption_data-matnr
******                      plant = ls_compsumption_data-werks stge_loc = ls_compsumption_data-lgort batch = ls_compsumption_data-charg stge_type = ls_compsumption_data-lgtyp stge_bin = ls_compsumption_data-lgpla ) TO lt_goodsmvnts.
******
********* LINK CONF GOODS_MVT
******
******      ADD 1 TO lv_index.
******      APPEND VALUE #( index_confirm = lv_index index_goodsmov = lv_index ) TO lt_lconf_gmov.
******
******    ENDIF.
******
******  ENDLOOP.
******
*********** CHECKS
******
********** ERRORES
******
******  READ TABLE lt_return INTO DATA(ls_return) WITH KEY type = 'E'.
******  IF ( sy-subrc = 0 ).
******    zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).
******  ENDIF.
******
********** COMPSUMPTION DATA
******
********* DATA FILLED
******
*******  IF ( lines( lt_goodsmvnts ) <= 0 ).
*******    zcl_seis_odata_utils=>lanzar_excepcion( 'No se han podido determinar consumos' ).
*******  ENDIF.
******
********** COMPSUMPTION
******
******  CALL FUNCTION 'BAPI_PRODORDCONF_CREATE_TT'
******    EXPORTING
******      post_wrong_entries = lv_post_wrong_entries
******      testrun            = i_testrun
******    IMPORTING
******      return             = ls_return1
******    TABLES
******      timetickets        = lt_timeticket
******      goodsmovements     = lt_goodsmvnts
******      link_conf_goodsmov = lt_lconf_gmov
******      detail_return      = lt_detail_return
******    EXCEPTIONS
******      error_message      = 1.
******
********** SAVE OR NOT
******
******  IF ( sy-subrc = 0 ).
******
******    IF ( line_exists( lt_detail_return[ type = 'E' ] ) ).
******
******      ROLLBACK WORK.
******      MOVE-CORRESPONDING lt_detail_return TO lt_return.
******      zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = lt_return ).
******
******    ELSE.
******
******      IF ( i_testrun <> abap_true ). "Chequeamos si modo test
******
******        COMMIT WORK AND WAIT.
******
******        READ TABLE lt_detail_return INTO DATA(ls_detail_return) INDEX 1.
******
******        IF ( lines( lt_goodsmvnts ) > 0 ).
******
******          "Espero a que se actualice el documento de material en AFWI
******          DO 5 TIMES.
******
******            SELECT COUNT(*) UP TO 1 ROWS
******              FROM afwi
******             WHERE rueck = @ls_detail_return-conf_no
******               AND rmzhl = @ls_detail_return-conf_cnt
******               AND mblnr <> @space
******               AND mjahr <> @space
******               AND mblpo <> @space.
******
******            IF ( sy-subrc = 0 ).
******              EXIT.
******            ELSE.
******              WAIT UP TO 1 SECONDS.
******            ENDIF.
******
******          ENDDO.
******
******          "Cuando se actualiza, recupero los datos de AFWI
******          LOOP AT lt_detail_return INTO DATA(ls_getail_return).
******
******            SELECT SINGLE *
******              FROM afwi
******              INTO @DATA(ls_afwi)
******             WHERE rueck = @ls_getail_return-conf_no
******               AND rmzhl = @ls_getail_return-conf_cnt.
******
******            IF ( sy-subrc = 0 ).
******              APPEND ls_afwi TO r_t_afwi.
******            ENDIF.
******
******          ENDLOOP.
******
******        ELSE.
******
******          "Si no se consume nada, devolvemos solo notificación
******          LOOP AT lt_detail_return INTO ls_detail_return.
******            APPEND VALUE #( rueck = ls_detail_return-conf_no rmzhl = ls_detail_return-conf_cnt ) TO r_t_afwi.
******          ENDLOOP.
******
******        ENDIF.
******
******      ELSE. " MODO TEST
******
******        "En modo test no tenemos notificaciones...recuperamos datos para que no vuelva la tabla vacía
******        LOOP AT lt_detail_return INTO ls_detail_return.
******          APPEND VALUE #( rueck = ls_detail_return-conf_no rmzhl = ls_detail_return-conf_cnt ) TO r_t_afwi.
******        ENDLOOP.
******
******      ENDIF.
******
******    ENDIF.
******
******  ENDIF.
  ENDMETHOD.
  METHOD _consumo_orden_pp_w_tt_migo.
    " Primero notificamos en la orden pero sin indicar cantidad de consumo
    DATA(tl_compsumption_data_tt) = i_t_compsumption_data.
    LOOP AT tl_compsumption_data_tt ASSIGNING FIELD-SYMBOL(<fs_compsumption_data_tt>).
      CLEAR <fs_compsumption_data_tt>-fmigo.
    ENDLOOP.

    DATA(tl_afwi_tt) = _consumo_orden_pp_w_tt( i_datum                      = i_datum
                                               i_uzeit                      = i_uzeit
                                               i_t_compsumption_data        = tl_compsumption_data_tt
                                               i_testrun                    = i_testrun ).

    " Primero creamos el documento de material directamente con MIGO.
    DATA(tl_afwi_migo) = _consumo_orden_pp_migo( i_datum                      = i_datum
                                                 i_uzeit                      = i_uzeit
                                                 i_t_compsumption_data        = i_t_compsumption_data
                                                 i_testrun                    = i_testrun ).

***  "Montamos la respuesta
***  r_t_afwi = tl_afwi_tt.
***  LOOP AT tl_afwi_tt ASSIGNING FIELD-SYMBOL(<fs_afwi>).
***    READ TABLE tl_afwi_migo ASSIGNING FIELD-SYMBOL(<fs_afwi_migo>) INDEX 1.
***    IF sy-subrc = 0.
***      <fs_afwi>-mblnr = <fs_afwi_migo>-mblnr.
***      <fs_afwi>-mjahr = <fs_afwi_migo>-mjahr.
***    ENDIF.
***  ENDLOOP.

    " Montamos respuesta
    APPEND LINES OF tl_afwi_tt[]   TO r_t_afwi[].
    APPEND LINES OF tl_afwi_migo[] TO r_t_afwi[].
  ENDMETHOD.
  METHOD _map_zwmconsumospp_w_ciresult.
**********************************************************************
* Parámetros locales
**********************************************************************

    DATA lv_create_new TYPE boolean.

**********************************************************************
* Validaciones
**********************************************************************

    CHECK i_s_cinum_result IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE

    lv_create_new = i_is_new.

****** CHECK NEW

    " Compruebo si hay que crearlo como nuevo registro
    IF lv_create_new = abap_false.

      SELECT SINGLE *
        INTO @r_s_zwm_consumos_pp
        FROM zwm_consumos_pp
       WHERE werks     = @i_s_cinum_result-werks
         AND contador2 = @i_s_cinum_result-mblpo
         AND mblnr     = @i_s_cinum_result-mblnr
         AND ci_number = @i_s_cinum_result-cinum
         AND aufnr     = @i_s_cinum_result-aufnr
         AND matnr     = @i_s_cinum_result-matnr
         AND charg     = @i_s_cinum_result-charg
         AND lenum     = @i_s_cinum_result-lenum.

      " Si no encontramos coincidencias, creamos nuevo
      IF sy-subrc <> 0.
        lv_create_new = abap_true.
      ENDIF.

    ENDIF.

***** FILL DATA NEW OR NOT

    IF lv_create_new = abap_true.

***** KEY FIELDS

      r_s_zwm_consumos_pp-werks = i_s_cinum_result-werks.

      SELECT MAX( contador )
        INTO @r_s_zwm_consumos_pp-contador
        FROM zwm_consumos_pp
       WHERE werks = @r_s_zwm_consumos_pp-werks.

      r_s_zwm_consumos_pp-contador      = r_s_zwm_consumos_pp-contador + 1.

      r_s_zwm_consumos_pp-contador2     = i_s_cinum_result-mblpo.

***** NO KEY FIELDS

      r_s_zwm_consumos_pp-dats          = i_s_cinum_result-budat.
      r_s_zwm_consumos_pp-tims          = i_s_cinum_result-uzeit.
      r_s_zwm_consumos_pp-id_bob_ecm    = i_s_cinum_result-aufnr && i_s_cinum_result-vornr.
      r_s_zwm_consumos_pp-ci_number     = i_s_cinum_result-cinum.
      r_s_zwm_consumos_pp-lenum         = i_s_cinum_result-lenum.
      r_s_zwm_consumos_pp-aufnr         = i_s_cinum_result-aufnr.
      r_s_zwm_consumos_pp-lgpla         = i_s_cinum_result-lgpla.
      r_s_zwm_consumos_pp-matnr         = i_s_cinum_result-matnr.
      r_s_zwm_consumos_pp-charg         = i_s_cinum_result-charg.

      r_s_zwm_consumos_pp-consumo       = i_s_cinum_result-menge.
      r_s_zwm_consumos_pp-meins_consumo = i_s_cinum_result-meins.
      r_s_zwm_consumos_pp-restante      = i_s_cinum_result-rmeng.
      r_s_zwm_consumos_pp-meins         = i_s_cinum_result-meins.

      SELECT COUNT(*)
        FROM usr02
       WHERE bname = i_s_cinum_result-uname
         AND ustyp = 'A'. " Diálogo

      IF sy-subrc = 0.
        r_s_zwm_consumos_pp-cla_manual = 'X'.
      ENDIF.

      r_s_zwm_consumos_pp-texto = i_s_cinum_result-msgtx.
      r_s_zwm_consumos_pp-rueck = i_s_cinum_result-rueck.
      r_s_zwm_consumos_pp-rmzhl = i_s_cinum_result-rmzhl.
      r_s_zwm_consumos_pp-mblnr = i_s_cinum_result-mblnr.
      r_s_zwm_consumos_pp-mjahr = i_s_cinum_result-mjahr.
      r_s_zwm_consumos_pp-tanum = i_s_cinum_result-tanum.

      IF    i_s_cinum_result-rueck IS INITIAL
         OR i_s_cinum_result-rmzhl IS INITIAL
         OR i_s_cinum_result-mblnr IS INITIAL
         OR i_s_cinum_result-mblpo IS INITIAL
         OR i_s_cinum_result-mjahr IS INITIAL.

        r_s_zwm_consumos_pp-cla_error = abap_true.

      ENDIF.

      r_s_zwm_consumos_pp-ernam = sy-uname.
      r_s_zwm_consumos_pp-erdat = sy-datum.
      r_s_zwm_consumos_pp-erzet = sy-uzeit.

    ELSE.

***** NO KEY FIELDS

      r_s_zwm_consumos_pp-dats          = i_s_cinum_result-budat.
      r_s_zwm_consumos_pp-tims          = i_s_cinum_result-uzeit.
      r_s_zwm_consumos_pp-id_bob_ecm    = i_s_cinum_result-aufnr && i_s_cinum_result-vornr.
      r_s_zwm_consumos_pp-ci_number     = i_s_cinum_result-cinum.
      r_s_zwm_consumos_pp-lgpla         = i_s_cinum_result-lgpla.

      r_s_zwm_consumos_pp-consumo       = i_s_cinum_result-menge.
      r_s_zwm_consumos_pp-meins_consumo = i_s_cinum_result-meins.
      r_s_zwm_consumos_pp-restante      = i_s_cinum_result-rmeng.
      r_s_zwm_consumos_pp-meins         = i_s_cinum_result-meins.

      SELECT COUNT(*)
        FROM usr02
       WHERE bname = i_s_cinum_result-uname
         AND ustyp = 'A'. " Diálogo

      IF sy-subrc = 0.
        r_s_zwm_consumos_pp-cla_manual = 'X'.
      ENDIF.

      r_s_zwm_consumos_pp-texto = i_s_cinum_result-msgtx.
      r_s_zwm_consumos_pp-rueck = i_s_cinum_result-rueck.
      r_s_zwm_consumos_pp-rmzhl = i_s_cinum_result-rmzhl.
      r_s_zwm_consumos_pp-mblnr = i_s_cinum_result-mblnr.
      r_s_zwm_consumos_pp-mjahr = i_s_cinum_result-mblpo.
      r_s_zwm_consumos_pp-tanum = i_s_cinum_result-tanum.

      IF    i_s_cinum_result-rueck IS INITIAL
         OR i_s_cinum_result-rmzhl IS INITIAL
         OR i_s_cinum_result-mblnr IS INITIAL
         OR i_s_cinum_result-mblpo IS INITIAL
         OR i_s_cinum_result-mjahr IS INITIAL.

        r_s_zwm_consumos_pp-cla_error = abap_true.

      ENDIF.

      r_s_zwm_consumos_pp-aenam = sy-uname.
      r_s_zwm_consumos_pp-aedat = sy-datum.
      r_s_zwm_consumos_pp-aezet = sy-uzeit.

    ENDIF.
  ENDMETHOD.
  METHOD _update_zwm_consumos_pp_table.
**********************************************************************
* Parámetros locales
**********************************************************************

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

    CHECK i_s_zwm_consumos_pp IS NOT INITIAL.
    CHECK i_s_zwm_consumos_pp-werks IS NOT INITIAL AND i_s_zwm_consumos_pp-contador IS NOT INITIAL AND i_s_zwm_consumos_pp-contador2 IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** UPDATE

    MODIFY zwm_consumos_pp FROM i_s_zwm_consumos_pp.

    IF sy-subrc = 0.
      COMMIT WORK AND WAIT.
    ELSE.
      ROLLBACK WORK.
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    super->constructor( ).

    clave_parametros = 'CORE_PP'.

    IF import_datos_globales = 'X'.
      import_datos_globales( ).
    ENDIF.
  ENDMETHOD.
  METHOD consumo_bobina_cinumber.
    " TODO: parameter VP_LGTYP is never used (ABAP cleaner)

    TYPES: BEGIN OF st_cinumbers,
             aufnr            TYPE zsppt_cinumbers-aufnr,
             vornr            TYPE zsppt_cinumbers-vornr,
             ci_number        TYPE zsppt_cinumbers-ci_number,
             cant_step        TYPE zsppt_cinumbers-cant_step,
             rsnum            TYPE zsppt_cinumbers-rsnum,
             rspos            TYPE zsppt_cinumbers-rspos,
             bwart            TYPE resb-bwart,
             stepcontribution TYPE zsppt_cinumbers-stepcontribution,
             porc_cantidad    TYPE p LENGTH 10 DECIMALS 6,
             cantidad_consumo TYPE ekpo-menge,
             meins            TYPE ekpo-meins,
           END OF st_cinumbers.

    DATA vl_cantidad_total       TYPE ekpo-menge.
    DATA tl_xloek_rg             TYPE RANGE OF resb-xloek.
    " Recorremos los CINUMBERS/Ordenes para completar con los datos de consumo
    DATA vl_cantidad_consumo_aux TYPE ekpo-menge.
    DATA: tl_timetickets        TYPE bapi_pp_timeticket_tt,
          tl_goodsmovements     TYPE bapi2017_gm_item_create_t,
          tl_link_conf_goodsmov TYPE bapi_link_conf_goodsmov_tt.
    DATA vl_index TYPE i.
    " Verificamos bloqueos
    DATA: vl_garg TYPE seqg3-garg,
          tl_enq  TYPE TABLE OF seqg3.
    " Ahora sí que hacemos los consumos
    DATA: vl_post_wrong_entries TYPE bapi_coru_param-ins_err VALUE '0',
          " TODO: variable is assigned but never used (ABAP cleaner)
          wl_return_prodordconf TYPE bapiret1,
          tl_detail_return      TYPE TABLE OF bapi_coru_return,
          tl_return             TYPE bapiret2_t.
    DATA tl_trite TYPE l03b_trite_t.

    SELECT SINGLE werks, lgort, lgnum
      INTO @DATA(wl_t320)
      FROM t320
      WHERE lgnum = @vp_lgnum.
    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'Almacén WM incorrecto' ).
    ENDIF.

    DATA(rl_consumos) = NEW zcl_zui5_wm_consumos_dpc_imp( ).

    " TODO: variable is assigned but only used in commented-out code (ABAP cleaner)
    DATA(wl_estacion) = rl_consumos->estaciones_getdetail( vp_werks = wl_t320-werks
                                                           vp_lgpla = vp_lgpla ).

    " Buscamos los CI Numbers
    SELECT  *
      INTO TABLE @DATA(tl_intf_omp_sap)
      FROM zwm_intf_omp_sap
      WHERE lgnum    = @vp_lgnum
        AND cinumber = @vp_cinumber.

    IF sy-subrc <> 0.
      SELECT  *
        INTO TABLE @tl_intf_omp_sap
        FROM zwm_intf_omp_sap
        WHERE lgnum = @vp_lgnum
          AND benum = @vp_cinumber.
    ENDIF.

    IF sy-subrc <> 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha encontrado el CI Number' ).
    ENDIF.

    DATA: tl_cinumbers TYPE TABLE OF st_cinumbers,
          wl_cinumbers LIKE LINE OF tl_cinumbers.

    LOOP AT tl_intf_omp_sap ASSIGNING FIELD-SYMBOL(<fs_intf_omp_sap>).
      CLEAR wl_cinumbers.
      wl_cinumbers-ci_number = <fs_intf_omp_sap>-benum.
      wl_cinumbers-meins     = zcl_wm_nt_generic=>gc_meins_kg.

      IF <fs_intf_omp_sap>-upper_orderid IS NOT INITIAL.
        wl_cinumbers-aufnr            = <fs_intf_omp_sap>-upper_orderid.
        wl_cinumbers-stepcontribution = <fs_intf_omp_sap>-stepcontribution_upper.
        wl_cinumbers-cant_step        = wl_cinumbers-stepcontribution.
        APPEND wl_cinumbers TO tl_cinumbers.
      ENDIF.
      IF <fs_intf_omp_sap>-lower_orderid IS NOT INITIAL.
        wl_cinumbers-aufnr            = <fs_intf_omp_sap>-lower_orderid.
        wl_cinumbers-stepcontribution = <fs_intf_omp_sap>-stepcontribution_lower.
        wl_cinumbers-cant_step        = wl_cinumbers-stepcontribution.
        APPEND wl_cinumbers TO tl_cinumbers.
      ENDIF.
    ENDLOOP.

    " Totalizamos los cant_step para sacar el porcentaje de contribución
    LOOP AT tl_cinumbers ASSIGNING FIELD-SYMBOL(<fs_cinumbers>).
      vl_cantidad_total = vl_cantidad_total + <fs_cinumbers>-cant_step.
    ENDLOOP.

    " Buscamos las reservas de las ordenes/ci numbers identificadas
    IF tl_cinumbers IS NOT INITIAL.
      SELECT resb~rsnum, resb~rspos, resb~rsart, resb~matnr, resb~aufnr, resb~werks,
             resb~bdmng, resb~meins, resb~enmng, resb~sortf, resb~bwart, resb~vornr,
             mara~zzgramaje, mara~zzancho, mara~zzlargo, mara~mtart, t023t~wgbez60
        INTO TABLE @DATA(tl_resb)
        FROM resb INNER JOIN ( mara LEFT OUTER JOIN t023t ON  t023t~spras = @sy-langu
                                                          AND t023t~matkl = mara~matkl )
                  ON mara~matnr = resb~matnr
        FOR ALL ENTRIES IN @tl_cinumbers
        WHERE resb~aufnr  = @tl_cinumbers-aufnr
          AND resb~xloek IN @tl_xloek_rg.
    ENDIF.

    " Buscamos la bobina en el cuanto
    SELECT *
      INTO TABLE @DATA(tl_lqua)
      FROM lqua
      UP TO 1 ROWS
      WHERE lgnum = @vp_lgnum
        AND lenum = @vp_lenum
      ORDER BY verme DESCENDING, gesme DESCENDING.
    IF sy-subrc = 0.
      DATA(wl_lqua) = tl_lqua[ 1 ].
    ELSE.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha encontrado unidad de almacén' ).
    ENDIF.

    " Obtener cantidad actual EN KG
    DATA(vl_cantidad_actual) = zcl_wm_nt_generic=>conv_matnr( iv_matnr      = wl_lqua-matnr
                                                              iv_meins_dest = zcl_wm_nt_generic=>gc_meins_kg
                                                              iv_meins_orig = wl_lqua-meins
                                                              iv_qty        = wl_lqua-verme ).

    " Obtener cantidad restante EN KG
    DATA(vl_cantidad_restante) = vp_diam.

    IF vl_cantidad_restante > 0.
      zcl_wm_nt_generic=>conv_mat_diametro(
        EXPORTING iv_matnr          = wl_lqua-matnr
                  iv_qty            = vl_cantidad_restante
                  iv_meins          = zcl_wm_nt_generic=>gc_meins_dia
                  iv_dest_meins     = zcl_wm_nt_generic=>gc_meins_kg
                  iv_werks          = wl_t320-werks
        RECEIVING rv_qty = vl_cantidad_restante
        EXCEPTIONS um_no_valid       = 1
                   missing_constants = 2
                   missing_matnr     = 3
                   no_base_calc      = 4
                   OTHERS            = 5 ).
    ENDIF.

    IF vl_cantidad_actual = 0.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No hay stock en la bobina' ).
    ELSEIF vl_cantidad_actual < vl_cantidad_restante.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No hay suficiente stock en la bobina para la cantidad indicada' ).
    ENDIF.

    DATA(vl_cantidad_consumo) = vl_cantidad_actual - vl_cantidad_restante.
    " No debería pasar, pero si si por cualquier casual la cantidad de consumo es mayor que la actual, cogemos la actual
    IF vl_cantidad_consumo > vl_cantidad_actual.
      vl_cantidad_consumo = vl_cantidad_actual.
    ENDIF.

    LOOP AT tl_cinumbers ASSIGNING <fs_cinumbers>.
      ASSIGN tl_resb[ aufnr = <fs_cinumbers>-aufnr
                      sortf = vp_lgpla ] TO FIELD-SYMBOL(<fs_resb>).
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
      <fs_cinumbers>-rsnum = <fs_resb>-rsnum.
      <fs_cinumbers>-rspos = <fs_resb>-rspos.
      <fs_cinumbers>-vornr = <fs_resb>-vornr.
      <fs_cinumbers>-bwart = <fs_resb>-bwart.

      IF vl_cantidad_total <> 0.
        <fs_cinumbers>-porc_cantidad = <fs_cinumbers>-cant_step / vl_cantidad_total.
      ENDIF.

      <fs_cinumbers>-cantidad_consumo = vl_cantidad_consumo * <fs_cinumbers>-porc_cantidad.
      CALL FUNCTION 'ROUND'
        EXPORTING
          input         = <fs_cinumbers>-cantidad_consumo
          sign          = '-' " Redondeo hacia abajo
        IMPORTING
          output        = <fs_cinumbers>-cantidad_consumo
        EXCEPTIONS
          input_invalid = 1
          overflow      = 2
          type_invalid  = 3
          OTHERS        = 4.
      vl_cantidad_consumo_aux = vl_cantidad_consumo_aux + <fs_cinumbers>-cantidad_consumo.
    ENDLOOP.

    " El último consumo se lleva la diferencia
    IF <fs_cinumbers> IS ASSIGNED AND vl_cantidad_consumo <> vl_cantidad_consumo_aux.
      <fs_cinumbers>-cantidad_consumo = <fs_cinumbers>-cantidad_consumo + ( vl_cantidad_consumo - vl_cantidad_consumo_aux ).
    ENDIF.

    LOOP AT tl_cinumbers ASSIGNING <fs_cinumbers> WHERE cantidad_consumo > 0.
      APPEND INITIAL LINE TO tl_timetickets ASSIGNING FIELD-SYMBOL(<fs_timetickets>).
      <fs_timetickets>-orderid         = <fs_cinumbers>-aufnr.
      <fs_timetickets>-operation       = <fs_cinumbers>-vornr.

      <fs_timetickets>-postg_date      = sy-datlo.
      <fs_timetickets>-conf_text       = ''.
      <fs_timetickets>-exec_start_date = sy-datlo.
      <fs_timetickets>-exec_start_time = sy-timlo.
      <fs_timetickets>-exec_fin_date   = sy-datlo.
      <fs_timetickets>-exec_fin_time   = sy-timlo.
      <fs_timetickets>-ex_created_by   = sy-uname.

      APPEND INITIAL LINE TO tl_goodsmovements ASSIGNING FIELD-SYMBOL(<fs_goodsmovements>).
      <fs_goodsmovements>-move_type = <fs_cinumbers>-bwart.
      <fs_goodsmovements>-entry_qnt = <fs_cinumbers>-cantidad_consumo.
      <fs_goodsmovements>-entry_uom = <fs_cinumbers>-meins.
      <fs_goodsmovements>-material  = wl_lqua-matnr.
      <fs_goodsmovements>-plant     = wl_lqua-werks.
      <fs_goodsmovements>-stge_loc  = wl_lqua-lgort.
      <fs_goodsmovements>-batch     = wl_lqua-charg.
      <fs_goodsmovements>-stge_type = '100'.
      <fs_goodsmovements>-stge_bin  = vp_lgpla.

      vl_index = vl_index + 1.
      APPEND INITIAL LINE TO tl_link_conf_goodsmov ASSIGNING FIELD-SYMBOL(<fs_link_conf_goodsmov>).
      <fs_link_conf_goodsmov>-index_confirm  = vl_index.
      <fs_link_conf_goodsmov>-index_goodsmov = vl_index.

      APPEND INITIAL LINE TO tp_consumos ASSIGNING FIELD-SYMBOL(<fs_consumos>).
      <fs_consumos>-werks         = <fs_goodsmovements>-plant.
      <fs_consumos>-contador2     = <fs_link_conf_goodsmov>-index_goodsmov.
      <fs_consumos>-dats          = <fs_timetickets>-exec_start_date.
      <fs_consumos>-tims          = <fs_timetickets>-exec_start_time.
      <fs_consumos>-id_bob_ecm    = <fs_timetickets>-orderid && <fs_timetickets>-operation.
      <fs_consumos>-ci_number     = <fs_cinumbers>-ci_number.
      <fs_consumos>-lenum         = vp_lenum.
      <fs_consumos>-aufnr         = <fs_cinumbers>-aufnr.
      <fs_consumos>-lgpla         = <fs_goodsmovements>-stge_bin.
      <fs_consumos>-matnr         = <fs_goodsmovements>-material.
      <fs_consumos>-charg         = <fs_goodsmovements>-batch.
      <fs_consumos>-restante      = vl_cantidad_restante.
      <fs_consumos>-meins         = <fs_cinumbers>-meins.
      <fs_consumos>-consumo       = <fs_goodsmovements>-entry_qnt.
      <fs_consumos>-meins_consumo = <fs_goodsmovements>-entry_uom.
      <fs_consumos>-cla_manual    = 'X'.
      <fs_consumos>-ernam         = sy-uname.
      <fs_consumos>-erdat         = sy-datum.
      <fs_consumos>-erzet         = sy-uzeit.
    ENDLOOP.

    IF tl_goodsmovements IS INITIAL.
      zcl_seis_odata_utils=>lanzar_excepcion( 'No se han podido determinar consumos' ).
    ENDIF.

    IF vp_testrun IS INITIAL.
      CONCATENATE sy-mandt wl_lqua-matnr wl_lqua-werks INTO vl_garg RESPECTING BLANKS.

      DO 5 TIMES.
        CALL FUNCTION 'ENQUEUE_READ'
          EXPORTING
            gclient = sy-mandt
            gname   = 'MARC'
            garg    = vl_garg
            guname  = sy-uname
          TABLES
            enq     = tl_enq.

        IF tl_enq IS NOT INITIAL.
          WAIT UP TO 1 SECONDS.
        ELSE.
          EXIT.
        ENDIF.
      ENDDO.
    ENDIF.

    CALL FUNCTION 'BAPI_PRODORDCONF_CREATE_TT'
      EXPORTING
        post_wrong_entries = vl_post_wrong_entries
        testrun            = vp_testrun
      IMPORTING
        return             = wl_return_prodordconf
      TABLES
        timetickets        = tl_timetickets
        goodsmovements     = tl_goodsmovements
        link_conf_goodsmov = tl_link_conf_goodsmov
        detail_return      = tl_detail_return
      EXCEPTIONS
        error_message      = 1.
    IF sy-subrc = 1.
      zcl_seis_odata_utils=>lanzar_excepcion( ).
    ENDIF.

    MOVE-CORRESPONDING tl_detail_return TO tl_return.
    zcl_seis_odata_utils=>lanzar_excepcion( bapiret2_t = tl_return ).

    LOOP AT tp_consumos ASSIGNING <fs_consumos>.
      ASSIGN tl_detail_return[ row = <fs_consumos>-contador2 ] TO FIELD-SYMBOL(<fs_detail_return>).
      IF sy-subrc = 0.
        <fs_consumos>-texto = <fs_detail_return>-message.
        <fs_consumos>-rueck = <fs_detail_return>-conf_no.
        <fs_consumos>-rmzhl = <fs_detail_return>-conf_cnt.
      ENDIF.
    ENDLOOP.

    IF vp_testrun = space.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      WAIT UP TO 2 SECONDS.

      SELECT MAX( contador )
        INTO @DATA(vl_contador)
        FROM zwm_consumos_pp
        WHERE werks = @wl_t320-werks.
      vl_contador = vl_contador + 1.

      LOOP AT tp_consumos ASSIGNING <fs_consumos>.
        <fs_consumos>-contador = vl_contador.
      ENDLOOP.

      " Buscamos los movimientos de mercancías de la notificación
      IF tp_consumos IS NOT INITIAL.
        SELECT rueck, rmzhl, wablnr, weblnr, myear
          INTO TABLE @DATA(tl_afru)
          FROM afru
          FOR ALL ENTRIES IN @tp_consumos
          WHERE rueck = @tp_consumos-rueck
            AND rmzhl = @tp_consumos-rmzhl.

        SELECT rueck, rmzhl, mblnr, mjahr, mblpo
          INTO TABLE @DATA(tl_afwi)
          FROM afwi
          FOR ALL ENTRIES IN @tp_consumos
          WHERE rueck = @tp_consumos-rueck
            AND rmzhl = @tp_consumos-rmzhl.
      ENDIF.

      LOOP AT tp_consumos ASSIGNING <fs_consumos>.
        ASSIGN tl_afru[ rueck = <fs_consumos>-rueck
                        rmzhl = <fs_consumos>-rmzhl ] TO FIELD-SYMBOL(<fs_afru>).
        IF sy-subrc = 0.
          <fs_consumos>-mblnr = <fs_afru>-wablnr.
          <fs_consumos>-mjahr = <fs_afru>-myear.
        ENDIF.

        IF <fs_consumos>-mblnr IS INITIAL.
          ASSIGN tl_afwi[ rueck = <fs_consumos>-rueck
                          rmzhl = <fs_consumos>-rmzhl ] TO FIELD-SYMBOL(<fs_afwi>).
          IF sy-subrc = 0.
            <fs_consumos>-mblnr = <fs_afwi>-mblnr.
            <fs_consumos>-mjahr = <fs_afwi>-mjahr.
          ENDIF.
        ENDIF.

        IF <fs_consumos>-mblnr IS INITIAL.
          <fs_consumos>-cla_error = 'X'.
          <fs_consumos>-texto     = 'Consumo realizado, pero no se ha podido determinar doc. material'.
          CONTINUE.
        ENDIF.
      ENDLOOP.

      IF tp_consumos IS NOT INITIAL.
        SELECT ltbp~lgnum, ltbp~tbnum, ltbp~tbpos, ltbp~meins, ltbp~menge, ltbp~charg,
               ltbk~nltyp, ltbk~nlpla, ltbp~tanum
          INTO TABLE @DATA(tl_ltbp)
          FROM ltbk INNER JOIN ltbp ON  ltbp~lgnum = ltbk~lgnum
                                    AND ltbp~tbnum = ltbk~tbnum
          FOR ALL ENTRIES IN @tp_consumos
          WHERE ltbk~lgnum  = @vp_lgnum
            AND ltbk~mblnr  = @tp_consumos-mblnr
            AND ltbk~mjahr  = @tp_consumos-mjahr
            AND ltbk~mblnr <> @space
            AND ltbk~mblnr <> '0000000000'.
      ENDIF.

      " Aquí lo que necesito es que hagamos la consultaSi la NT asociada a la posición del
      " documento de material está completada (ltbp tiene la OT informada)no hace falta crear OT.

      " Además, he probado y falla la creación e la OT con 1 documentos de material con dos posiciones.
      " Esto ocurre porque cada posición genera su NT y en el código solo apuntamos a una y el trite lo estamos rellenando para los dos.
      " Es decir, hay que llamar a crear OF una vez por cada posición de documento de material si se cumple lo definido en este punto (No existe OT ya)

      LOOP AT tl_ltbp ASSIGNING FIELD-SYMBOL(<fs_ltbp>).
        IF <fs_ltbp>-tanum IS INITIAL.
          CLEAR tl_trite.
          APPEND INITIAL LINE TO tl_trite ASSIGNING FIELD-SYMBOL(<fs_trite>).
          <fs_trite>-tbpos = <fs_ltbp>-tbpos.
          <fs_trite>-altme = <fs_ltbp>-meins.
          <fs_trite>-anfme = <fs_ltbp>-menge.
          <fs_trite>-charg = <fs_ltbp>-charg.
          <fs_trite>-nltyp = <fs_ltbp>-nltyp.
          <fs_trite>-nlpla = <fs_ltbp>-nlpla.

          <fs_trite>-vlpla = wl_lqua-lgpla.
          <fs_trite>-vltyp = wl_lqua-lgtyp.
          <fs_trite>-letyp = wl_lqua-letyp.

          TRY.
              DATA(rl_utils_wm) = NEW zcl_utils_wm( i_werks = wl_t320-werks
                                                    i_lgort = wl_t320-lgort ).
              DATA(vl_tanum) = rl_utils_wm->create_to_4_tr( i_tbnum   = <fs_ltbp>-tbnum
                                                            i_t_trite = tl_trite
                                                            i_commit  = 'X' ).
            CATCH zcx_wm_exception INTO DATA(rl_wm_exc).
              " TODO: variable is assigned but never used (ABAP cleaner)
              DATA(vl_msg) = rl_wm_exc->get_text( ).
            CATCH zcx_mm_exception INTO DATA(rl_mm_exc).
              vl_msg = rl_mm_exc->get_text( ).
          ENDTRY.

        ELSE.
          vl_tanum = <fs_ltbp>-tanum.
        ENDIF.
      ENDLOOP.

      LOOP AT tp_consumos ASSIGNING <fs_consumos> WHERE mblnr IS NOT INITIAL.
        <fs_consumos>-tanum = vl_tanum.
        IF <fs_consumos>-tanum IS INITIAL.
          <fs_consumos>-cla_error = 'X'.
          <fs_consumos>-texto     = 'Consumo realizado, pero no se ha realizada la OT'.
          CONTINUE.
        ENDIF.
      ENDLOOP.

      " Actualizamos tablaS Z de bobinas
      MODIFY zwm_consumos_pp FROM TABLE tp_consumos.

*
*    " cvivo - Lanzamos la impresión aquí, 1 etiqueta por consumo
*    IF vl_cantidad_restante > 0.
*      DATA tl_selection_table TYPE TABLE OF rsparamsl_255.
*      EXPORT lv_vengo_inter_consumo = abap_true         TO MEMORY ID 'VENGO_CONSUMO' .
*      EXPORT lv_cod_maq_portabo     = wl_estacion-lgpla TO MEMORY ID 'MAQUINA'.
*
*      " create label for remaining
*      tl_selection_table = VALUE #( ( selname = 'P_LGNUM' kind = 'P' sign = 'I' option = 'EQ' low = p_lgnum )
*                                    ( selname = 'S_LENUM' kind = 'S' sign = 'I' option = 'EQ' low = p_lenum ) ).
*      SUBMIT zimpresion_ua WITH SELECTION-TABLE tl_selection_table AND RETURN.
*      FREE MEMORY ID: 'VENGO_CONSUMO', 'MAQUINA'.
*    ENDIF.

    ENDIF.
  ENDMETHOD.
  METHOD consumo_bobina_cinumber_wm.
**********************************************************************
* Parámetros locales
**********************************************************************

****** TYPES

    DATA: lv_datum          TYPE datum,
          lv_time           TYPE uzeit,
          lv_cinumber_int   TYPE lvs_benum,
          lv_lgnum          TYPE lgnum,
          lv_consu_stock_kg TYPE menge_d,
          lv_total_stock_kg TYPE menge_d,
          lv_noti           TYPE boolean,
          lv_migo           TYPE boolean,
          lv_cons_type      TYPE int1.
    DATA: lt_r_aufnr   TYPE range_t_aufnr,
          l_string     TYPE string,
          lt_comp_data TYPE zcgty_t_consumption_data,
          lt_afwi      TYPE TABLE OF afwi.
    DATA: l_gramaje TYPE i,
          l_ancho   TYPE i.
    DATA ls_result TYPE zcgty_s_cinumber_cons_result.
    DATA: BEGIN OF ls_r_rmzhl,
            sign   TYPE sign,
            option TYPE option,
            low    TYPE co_rmzhl,
            high   TYPE co_rmzhl,
          END OF ls_r_rmzhl.

****** PARAMS

    DEFINE log.
      IF NOT o_log IS INITIAL AND i_testrun IS INITIAL.
        o_log->log( p1 = &2 msgty = &1 ).
      ENDIF.
    END-OF-DEFINITION.

    DEFINE lanzar_excepcion.
      LOG 'E' &1.
      zcl_seis_odata_utils=>lanzar_excepcion( &1 ).
    END-OF-DEFINITION.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

***** FECHA

    IF i_datum IS NOT INITIAL.
      lv_datum = i_datum.
    ELSE.
      lv_datum = sy-datum.
    ENDIF.

***** HORA

    IF i_uzeit IS NOT INITIAL.
      lv_time = i_uzeit.
    ELSE.
      lv_time = sy-uzeit.
    ENDIF.

***** CINUMBER

    IF i_cinumber IS INITIAL.
* zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha informado el CI Number' ).
      lanzar_excepcion 'No se ha informado el CI Number'.
    ENDIF.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** CINUMBER 2 INTERNAL

    lv_cinumber_int = |{ zhcl_pp_core=>s_conv_cinumber_2_internal( i_mjahr = i_datum(4) i_cinumber = i_cinumber ) ALPHA = IN }|.

    IF lv_cinumber_int IS INITIAL.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'El CI Number informado no contiene el formato correcto' ).
      lanzar_excepcion 'El CI Number informado no contiene el formato correcto'.
    ENDIF.

***** LGNUM

    lv_lgnum = zhcl_wm_core=>s_get_lgnum_4_werks_and_lgort( i_werks = i_werks i_lgort = i_lgort ).

    IF lv_lgnum IS INITIAL.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'No existe almacén WM para centro/almacén IM informado' ).
      lanzar_excepcion 'No existe almacén WM para centro/almacén IM informado'.
    ENDIF.

***** GET CIs FROM PAPER_REQUIREMENTS INTERFACE TABLE

    " Buscamos los CI Numbers
    SELECT SINGLE *
      INTO @DATA(ls_intf_omp_sap)
      FROM zwm_intf_omp_sap
      WHERE lgnum = @lv_lgnum
        AND benum = @lv_cinumber_int.

    IF sy-subrc <> 0.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'No se ha encontrado el CI Number en la tabla ZWM_INTF_OMP_SAP' ).
      lanzar_excepcion 'No se ha encontrado el CI Number en la tabla ZWM_INTF_OMP_SAP'.
    ENDIF.

***** GET RESB DATA

    IF ls_intf_omp_sap-upper_orderid <> space OR ls_intf_omp_sap-upper_orderid <> 0.
      APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_intf_omp_sap-upper_orderid ) TO lt_r_aufnr.
    ENDIF.

    IF ls_intf_omp_sap-lower_orderid <> space OR ls_intf_omp_sap-lower_orderid <> 0.
      APPEND VALUE #( sign = 'I' option = 'EQ' low = ls_intf_omp_sap-lower_orderid ) TO lt_r_aufnr.
    ENDIF.

    " Buscamos las reservas de las ordenes/ci numbers identificadas
    SELECT resb~rsnum, resb~rspos, resb~rsart, resb~matnr, resb~aufnr, resb~werks,
           resb~bdmng, resb~meins, resb~enmng, resb~sortf, resb~bwart, resb~vornr,
           mara~zzgramaje, mara~zzancho, mara~zzlargo, mara~mtart, t023t~wgbez60
      INTO TABLE @DATA(lt_resb)
      FROM resb INNER JOIN ( mara LEFT OUTER JOIN t023t ON t023t~spras = @sy-langu AND t023t~matkl = mara~matkl )
        ON mara~matnr = resb~matnr
     WHERE resb~aufnr IN @lt_r_aufnr
       AND resb~xloek  = @space
       AND resb~werks  = @i_werks
       AND resb~lgort  = @i_lgort.

    IF sy-subrc <> 0.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'No existen reservas para realizar el consumo debido a que las ordenes han sido eliminadas o no existen.' ).
      lanzar_excepcion 'No existen reservas para realizar el consumo debido a que las ordenes han sido eliminadas o no existen.'.
    ENDIF.

***** GET LQUA DATA

    " Buscamos la bobina en el cuanto
    SELECT SINGLE *
      FROM lqua
      INTO @DATA(ls_lqua)
     WHERE lgnum = @lv_lgnum
       AND lenum = @i_lenum.

    IF sy-subrc <> 0.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'La bobina introducida no existe en el sistema' ).

      SELECT SINGLE vlenr FROM ltap
        INTO @DATA(l_vlenr)
       WHERE lgnum = @lv_lgnum
         AND vlenr = @i_lenum.
      IF sy-subrc <> 0.
        lanzar_excepcion 'La bobina introducida no existe en el sistema'.
      ELSE.
        lanzar_excepcion 'La bobina introducida se consumió totalmente'.
      ENDIF.
    ENDIF.

***** GET AND WORK STOCK QTYs

    IF i_meins = zcl_wm_nt_generic=>gc_meins_dia.
      zcl_wm_nt_generic=>conv_mat_diametro(
        EXPORTING
          iv_matnr          = ls_lqua-matnr
          iv_qty            = i_menge
          iv_meins          = i_meins
          iv_dest_meins     = zcl_wm_nt_generic=>gc_meins_kg
          iv_werks          = i_werks
        RECEIVING
          rv_qty            = DATA(l_qty)
        EXCEPTIONS
          um_no_valid       = 1
          missing_constants = 2
          missing_matnr     = 3
          no_base_calc      = 4
          overflow          = 5
          OTHERS            = 6 ).
      IF sy-subrc = 0.
        lv_consu_stock_kg = ceil( l_qty ).
      ELSE.
        CASE sy-subrc.
          WHEN 5.
            lanzar_excepcion 'Valor de díametro demasiado grande'.
          WHEN OTHERS.
            lanzar_excepcion 'Error en conversión de diámetro a kilos'.
        ENDCASE.
      ENDIF.

    ELSE.
      lv_consu_stock_kg = ceil( zcl_wm_nt_generic=>conv_matnr( iv_matnr = ls_lqua-matnr iv_meins_dest = zcl_wm_nt_generic=>gc_meins_kg iv_meins_orig = i_meins iv_qty = i_menge ) ).
    ENDIF.
    e_menge_kg = lv_consu_stock_kg. " Devolvemos datos (modo test)

    l_string = |La cantidad a consumir en KG es = { e_menge_kg }|.
    LOG 'I' l_string.
**** TOTAL STOCK

    SELECT SUM( verme )
      FROM lqua
      INTO @lv_total_stock_kg
     WHERE lgnum = @lv_lgnum
       AND matnr = @ls_lqua-matnr
       AND charg = @ls_lqua-charg.

    " Obtengo cantidad total en KG
    IF lv_total_stock_kg > 0.
      lv_total_stock_kg = zcl_wm_nt_generic=>conv_matnr( iv_matnr = ls_lqua-matnr iv_meins_dest = zcl_wm_nt_generic=>gc_meins_kg iv_meins_orig = ls_lqua-meins iv_qty = lv_total_stock_kg ).
      IF lv_total_stock_kg <= 0.
*        zcl_seis_odata_utils=>lanzar_excepcion( 'No queda stock de la bobina indicada' ).
        lanzar_excepcion 'No queda stock de la bobina indicada'.
      ENDIF.
    ELSE.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'No queda stock de la bobina indicada' ).
      lanzar_excepcion 'No queda stock de la bobina indicada'.
    ENDIF.

    lv_total_stock_kg = lv_total_stock_kg - i_test_consumos_previos.

    e_stock_wm_kg = lv_total_stock_kg. " Devolvemos datos (modo test)
**** CONS STOCK

    SELECT matnr, meinh FROM marm
      INTO TABLE @DATA(lt_marm)
    WHERE matnr  = @ls_lqua-matnr
      AND meinh IN ( 'M', 'ST' ).

    READ TABLE lt_marm INTO DATA(ls_marm) WITH KEY meinh = 'M'.
    IF sy-subrc = 0.
      e_meinh = ls_marm-meinh.
    ELSE.
      CLEAR ls_marm.
      READ TABLE lt_marm INTO ls_marm WITH KEY meinh = 'ST'.
      IF sy-subrc = 0.
        e_meinh = ls_marm-meinh.
      ELSE.
*        zcl_seis_odata_utils=>lanzar_excepcion( 'Error en UMA para el material, no tiene M o UN' ).
        lanzar_excepcion 'Error en UMA para el material, no tiene M o UN'.
      ENDIF.
    ENDIF.

    IF e_meinh IS NOT INITIAL AND i_cod_consumo = '02'.
      SELECT SINGLE *
        INTO @DATA(ls_tolerancia)
        FROM zwm_tolerancia
        WHERE werks = @ls_lqua-werks
          AND lgort = @ls_lqua-lgort
          AND meins = @e_meinh.
      IF ls_tolerancia-dinamico IS INITIAL.
        e_tolerancia = ls_tolerancia-tolerancia.
        e_tolerancia_meins = e_meinh.
      ELSE.
        l_gramaje = ls_lqua-matnr+10(4).
        l_ancho = ls_lqua-matnr+14(4).
        e_tolerancia = ( ls_tolerancia-minutos * ls_tolerancia-velocidad * l_gramaje * l_ancho ) / 1000000.
        e_tolerancia = trunc( e_tolerancia ).
        e_tolerancia_meins = 'KG'.
      ENDIF.
      DATA(l_tolerancia_kg) = zcl_wm_nt_generic=>conv_matnr( iv_matnr = ls_lqua-matnr iv_meins_dest = zcl_wm_nt_generic=>gc_meins_kg iv_meins_orig = e_tolerancia_meins iv_qty = CONV #( e_tolerancia ) ).
    ENDIF.

    " Ajusto cantidad si ctd total < ctd cons
*  IF lv_total_stock_kg < lv_consu_stock_kg.
    IF lv_consu_stock_kg + l_tolerancia_kg >= lv_total_stock_kg.
      IF lv_consu_stock_kg >= lv_total_stock_kg.
        l_string = |Consumo final será igual al stock disponible { lv_total_stock_kg }|.
      ELSE.
        l_string = |Consumo final será igual al stock disponible { lv_total_stock_kg } por considerar tolerancia { l_tolerancia_kg }|.
      ENDIF.
      LOG 'I' l_string.
      lv_consu_stock_kg = lv_total_stock_kg.

    ENDIF.
    e_ctd_consu_kg = lv_consu_stock_kg. " Devolvemos datos (modo test)

    " Compruebo que la cantidad a consumir > 0
    IF lv_consu_stock_kg <= 0.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'La cantidad indicada es igual o inferior a cero al transformar a KG' ).
      lanzar_excepcion 'La cantidad indicada es igual o inferior a cero al transformar a KG'.
    ENDIF.

****** COMPSUMPTION

    " Upper order id
    IF ls_intf_omp_sap-upper_orderid <> space OR ls_intf_omp_sap-upper_orderid > 0.

      " Para bobinas intento recuperar la operación a partir de la ubicación de consumo
      " si no encuentro fuerzo consumo en operación 10 (hasta ahora siempre es onduladora)
      READ TABLE lt_resb INTO DATA(ls_resb) WITH KEY sortf = i_lgpla.
      IF sy-subrc <> 0.
        ls_resb-vornr = '0010'.
        ls_resb-sortf = i_lgpla.
      ENDIF.

      " Evaluamos tipo de consumo
      CASE i_type.
        WHEN c_tipo_consumo_notif.      " 1
          lv_noti = abap_true.
          lv_migo = abap_true.
        WHEN c_tipo_consumo_migo.       " 2
          lv_noti = abap_false.
          lv_migo = abap_true.
        WHEN c_tipo_consumo_notif_migo. " 3

          " Compruebo si existen notificaciones en la operación
          SELECT COUNT(*) UP TO 1 ROWS                 "#EC CI_NOFIELD.
            FROM afru
           WHERE aufnr = ls_resb-aufnr
             AND vornr = ls_resb-vornr.
          IF sy-subrc <> 0.
            lv_noti = abap_true.
            lv_migo = abap_true.
          ELSE.
            lv_noti = abap_false.
            lv_migo = abap_true.
          ENDIF.

      ENDCASE.

      " Debe notificarse?
      APPEND VALUE #( bwart = ls_resb-bwart
                      aufnr = ls_intf_omp_sap-upper_orderid
                      vornr = ls_resb-vornr
                      werks = i_werks
                      lgort = i_lgort
                      matnr = ls_lqua-matnr
                      charg = ls_lqua-charg
                      menge = ceil( lv_consu_stock_kg * ls_intf_omp_sap-stepcontribution_upper )
                      meins = zcl_wm_nt_generic=>gc_meins_kg
                      lgtyp = i_lgtyp
                      lgpla = i_lgpla
                      fnoti = lv_noti
                      fmigo = lv_migo ) TO lt_comp_data.

    ENDIF.

    " Lower order id
    IF ls_intf_omp_sap-lower_orderid <> space OR ls_intf_omp_sap-lower_orderid > 0.

      " Para bobinas intento recuperar la operación a partir de la ubicación de consumo
      " si no encuentro fuerzo consumo en operación 10 (hasta ahora siempre es onduladora)
      READ TABLE lt_resb INTO ls_resb WITH KEY sortf = i_lgpla.
      IF sy-subrc <> 0.
        ls_resb-vornr = '0010'.
        ls_resb-sortf = i_lgpla.
      ENDIF.

      " Evaluamos tipo de consumo
      CASE i_type.
        WHEN c_tipo_consumo_notif.      " 1
          lv_noti = abap_true.
          lv_migo = abap_true.
        WHEN c_tipo_consumo_migo.       " 2
          lv_noti = abap_false.
          lv_migo = abap_true.
        WHEN c_tipo_consumo_notif_migo. " 3

          " Compruebo si existen notificaciones en la operación
          SELECT COUNT(*) UP TO 1 ROWS
            FROM afru
           WHERE aufnr = ls_resb-aufnr
             AND vornr = ls_resb-vornr.
          IF sy-subrc <> 0.
            lv_noti = abap_true.
            lv_migo = abap_true.
          ELSE.
            lv_noti = abap_false.
            lv_migo = abap_true.
          ENDIF.

      ENDCASE.

      APPEND VALUE #( bwart = ls_resb-bwart
                      aufnr = ls_intf_omp_sap-lower_orderid
                      vornr = ls_resb-vornr
                      werks = i_werks
                      lgort = i_lgort
                      matnr = ls_lqua-matnr
                      charg = ls_lqua-charg
                      menge = floor( lv_consu_stock_kg * ls_intf_omp_sap-stepcontribution_lower )
                      meins = zcl_wm_nt_generic=>gc_meins_kg
                      lgtyp = i_lgtyp
                      lgpla = i_lgpla
                      fnoti = lv_noti
                      fmigo = lv_migo ) TO lt_comp_data.

    ENDIF.

    " Afinamos tipo consumo
    IF i_type = c_tipo_consumo_notif_migo.

      IF line_exists( lt_comp_data[ fnoti = abap_true ] ).
        lv_cons_type = c_tipo_consumo_notif_migo.
      ELSE.
        lv_cons_type = c_tipo_consumo_migo.
      ENDIF.

    ENDIF.

    " Realizo consumo con los datos anteriores
    lt_afwi = consumo_orden_produccion( i_type = lv_cons_type i_datum = lv_datum i_uzeit = lv_time i_t_compsumption_data = lt_comp_data i_testrun = i_testrun ).

****** WORK RESULT

    " Si se ha lanzado en modo test, recopilamos resultado y no creamos OT
    IF i_testrun = abap_true.

      LOOP AT lt_afwi INTO DATA(ls_afwi).
        DATA(l_tabix) = sy-tabix.

        MOVE-CORRESPONDING ls_afwi TO ls_result.

        READ TABLE lt_comp_data INTO DATA(ls_compdata) INDEX l_tabix.
        MOVE-CORRESPONDING ls_compdata TO ls_result.

        ls_result-lenum = i_lenum.

        ls_result-msgtx = 'Consumo lanzado en modo test'.

        APPEND ls_result TO r_t_result.

      ENDLOOP.

      RETURN.
    ENDIF.

    IF lines( lt_afwi ) <= 0.
*      zcl_seis_odata_utils=>lanzar_excepcion( 'No se han podido contabilizar notificaciones' ).
      lanzar_excepcion 'No se han podido contabilizar notificaciones'.
    ENDIF.

    " Con AFWI, recuperamos los datos de retorno
    LOOP AT lt_afwi INTO ls_afwi.

      CLEAR ls_result.

      MOVE-CORRESPONDING ls_afwi TO ls_result.

      ls_result-uname = sy-uname.
      ls_result-werks = i_werks.
      ls_result-lgort = i_lgort.
      ls_result-lenum = i_lenum.
      ls_result-lgtyp = i_lgtyp.
      ls_result-lgpla = i_lgpla.
      ls_result-cinum = lv_cinumber_int.
      ls_result-rsnum = ls_resb-rsnum.
      ls_result-rspos = ls_resb-rspos.
      ls_result-rmeng = lv_total_stock_kg.
      ls_result-machi = ls_intf_omp_sap-machine_code.

      IF ls_afwi-rueck IS NOT INITIAL AND ls_afwi-rueck > 0 AND ls_afwi-rmzhl IS NOT INITIAL AND ls_afwi-rmzhl > 0. " Consumo con notificación
        l_string = |Se ha generado notificación { ls_afwi-rueck } { ls_afwi-rmzhl }|.
        LOG 'S' l_string.

        SELECT SINGLE aufnr, vornr
          FROM afru
          INTO ( @ls_result-aufnr, @ls_result-vornr )
         WHERE rueck = @ls_result-rueck
           AND rmzhl = @ls_result-rmzhl.

        IF sy-subrc = 0.
          " Recálculo stock total
          lv_total_stock_kg = lv_total_stock_kg - lt_comp_data[ aufnr = ls_result-aufnr vornr = ls_result-vornr ]-menge.
          ls_result-proce   = abap_true.

          l_string = |Marcamos como proceso. Stock { lv_total_stock_kg }|.
          LOG 'S' l_string.
        ENDIF.

        SELECT SINGLE bwart, matnr, charg, budat_mkpf, cputm_mkpf, menge, meins, tbnum, tbpos
          FROM mseg
          INTO ( @ls_result-bwart, @ls_result-matnr, @ls_result-charg, @ls_result-budat, @ls_result-uzeit, @ls_result-menge, @ls_result-meins, @ls_result-tbnum, @ls_result-tbpos )
         WHERE mblnr = @ls_result-mblnr
           AND zeile = @ls_result-mblpo
           AND mjahr = @ls_result-mjahr.

        IF sy-subrc = 0.

          ls_result-conta = abap_true.
          ls_result-msgtx = |{ 'Consumo realizado: Doc.Mat(' } { ls_result-mblnr } { '-' } { ls_afwi-mblpo } { ')' }|.
          LOG 'S' ls_result-msgtx.
*  **** CREATE OT

          TRY.

              DATA(lv_ot) = NEW zhcl_wm_core( i_werks = i_werks i_lgort = i_lgort )->create_to_4_mblnr_zeile( i_mblnr = ls_afwi-mblnr i_mblpo = ls_afwi-mblpo i_mjahr = ls_afwi-mjahr i_lenum = i_lenum ).

              IF lv_ot IS NOT INITIAL.
                ls_result-tanum = lv_ot.
                CONCATENATE ls_result-msgtx 'OT:' lv_ot INTO ls_result-msgtx SEPARATED BY space.
                l_string = |OT: { lv_ot }|.
                LOG 'S' l_string.
              ENDIF.

            CATCH zcx_exception INTO DATA(lo_exception).
              CONCATENATE ls_result-msgtx 'Error OT:' lo_exception->if_t100_message~t100key-attr1 INTO ls_result-msgtx.
              l_string = |Error OT: { lo_exception->if_t100_message~t100key-attr1 }|.
              LOG 'E' l_string.
              l_string = |Error OT1 CONSUMO_BOBINA_CINUMBER_WM: { lo_exception->get_text( ) }|.
              LOG 'E' l_string.
          ENDTRY.

        ELSE.

          SELECT SINGLE matnr, charg
            FROM affw
            INTO ( @ls_result-matnr, @ls_result-charg )
           WHERE weblnr  = @ls_afwi-mblnr
             AND weblpos = @ls_afwi-mblpo.

          ls_result-msgtx = |{ 'Consumo ok, pero con errores posteriores. Revisar COGI para ' } { |{ ls_result-matnr ALPHA = OUT }| } { '-' } { |{ ls_result-charg ALPHA = OUT }| } { ')' }|.
          LOG 'W' ls_result-msgtx.
        ENDIF.

      ELSE. " Consumo sin notificación

        SELECT SINGLE bwart, matnr, charg, budat_mkpf, cputm_mkpf, menge, meins, tbnum, tbpos, aufnr
          FROM mseg
          INTO ( @ls_result-bwart, @ls_result-matnr, @ls_result-charg, @ls_result-budat, @ls_result-uzeit, @ls_result-menge, @ls_result-meins, @ls_result-tbnum, @ls_result-tbpos, @ls_result-aufnr )
         WHERE mblnr = @ls_result-mblnr
           AND zeile = @ls_result-mblpo
           AND mjahr = @ls_result-mjahr.

        IF sy-subrc = 0.

          " Recálculo stock total
          lv_total_stock_kg = lv_total_stock_kg - ls_result-menge.
          ls_result-proce = abap_true.

          ls_result-conta = abap_true.
          ls_result-msgtx = |{ 'Consumo realizado: Doc.Mat(' } { ls_result-mblnr } { '-' } { ls_afwi-mblpo } { ')' }|.
          LOG 'S' ls_result-msgtx.
*  **** CREATE OT

          TRY.

              lv_ot = NEW zhcl_wm_core( i_werks = i_werks i_lgort = i_lgort )->create_to_4_mblnr_zeile( i_mblnr = ls_afwi-mblnr i_mblpo = ls_afwi-mblpo i_mjahr = ls_afwi-mjahr i_lenum = i_lenum ).

              IF lv_ot IS NOT INITIAL.
                ls_result-tanum = lv_ot.
                CONCATENATE ls_result-msgtx 'OT:' lv_ot INTO ls_result-msgtx SEPARATED BY space.
                l_string = |OT: { lv_ot }|.
                LOG 'S' l_string.
              ENDIF.

            CATCH zcx_exception INTO lo_exception.
              CONCATENATE ls_result-msgtx 'Error OT:' lo_exception->if_t100_message~t100key-attr1 INTO ls_result-msgtx.
              l_string = |Error OT: { lo_exception->if_t100_message~t100key-attr1 }|.
              LOG 'E' l_string.
              l_string = |Error OT2 CONSUMO_BOBINA_CINUMBER_WM: { lo_exception->get_text( ) }|.
              LOG 'E' l_string.
          ENDTRY.

        ELSE.

          ls_result-matnr = lt_comp_data[ 1 ]-matnr.
          ls_result-charg = lt_comp_data[ 1 ]-charg.

          ls_result-msgtx = |{ 'Consumo ok, pero con errores posteriores. Revisar COGI para ' } { |{ ls_result-matnr ALPHA = OUT }| } { '-' } { |{ ls_result-charg ALPHA = OUT }| } { ')' }|.
          LOG 'W' ls_result-msgtx.
        ENDIF.

      ENDIF.

      APPEND ls_result TO r_t_result.

      _update_zwm_consumos_pp_table( i_s_zwm_consumos_pp = _map_zwmconsumospp_w_ciresult( i_is_new = abap_false i_s_cinum_result = ls_result ) ).

    ENDLOOP.
  ENDMETHOD.
  METHOD consumo_orden_produccion.
**********************************************************************
* Parámetros locales
**********************************************************************

    DATA: lv_cons_date TYPE datum,
          lv_cons_time TYPE uzeit.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

    IF i_datum IS NOT INITIAL.
      lv_cons_date = i_datum.
    ELSE.
      lv_cons_date = sy-datum.
    ENDIF.

    IF i_uzeit IS NOT INITIAL.
      lv_cons_time = i_uzeit.
    ELSE.
      lv_cons_time = sy-uzeit.
    ENDIF.

**********************************************************************
* Lógica
**********************************************************************
    CASE i_type.
      WHEN c_tipo_consumo_notif. " Con notificación
        r_t_afwi = _consumo_orden_pp_w_tt( i_datum                = lv_cons_date
                                           i_uzeit                = lv_cons_time
                                           i_t_compsumption_data  = i_t_compsumption_data
                                           i_testrun              = i_testrun ).

      WHEN c_tipo_consumo_migo. " Sin notificación. Consumo vía MIGO
        r_t_afwi = _consumo_orden_pp_migo( i_datum                = lv_cons_date
                                           i_uzeit                = lv_cons_time
                                           i_t_compsumption_data  = i_t_compsumption_data
                                           i_testrun              = i_testrun ).

      WHEN c_tipo_consumo_notif_migo. " Notificación sin consumo + Consumo vía MIGO
        r_t_afwi = _consumo_orden_pp_w_tt_migo( i_datum                = lv_cons_date
                                                i_uzeit                = lv_cons_time
                                                i_t_compsumption_data  = i_t_compsumption_data
                                                i_testrun              = i_testrun ).

      WHEN OTHERS.
        zcl_seis_odata_utils=>lanzar_excepcion( message = 'Tipo de consumo no permitido'(001) ).
    ENDCASE.
  ENDMETHOD.
  METHOD export_datos_globales.
    EXPORT i_situacion FROM i_situacion
           i_ruta FROM i_ruta TO MEMORY ID 'ZHCL_PP_CORE'.
  ENDMETHOD.
  METHOD get_of_from_doc.
    DATA l_ebelp TYPE ebelp.

    CLEAR aufnr.
    SELECT aufk~aufnr, erdat, matnr FROM aufk JOIN afpo ON aufk~aufnr = afpo~aufnr
      INTO TABLE @DATA(i_ord)
      WHERE aufk~kdauf = @vgbel
        AND aufk~kdpos = @vgpos
        AND werks      = @werks
    ORDER BY erdat DESCENDING, aufk~aufnr DESCENDING.
    IF sy-subrc <> 0.
      l_ebelp = vgpos+1.
      SELECT aufk~aufnr, erdat, matnr FROM aufk JOIN afpo ON aufk~aufnr = afpo~aufnr
        INTO TABLE @i_ord
        WHERE zzsubco_ebeln = @vgbel
          AND zzsubco_ebelp = @l_ebelp
          AND werks         = @werks
      ORDER BY erdat DESCENDING, aufk~aufnr DESCENDING.
    ENDIF.

    IF lines( i_ord ) = 1.
      aufnr = i_ord[ 1 ]-aufnr.
    ELSEIF lines( i_ord ) > 1 AND NOT matnr IS INITIAL.
      ASSIGN i_ord[ matnr = matnr ] TO FIELD-SYMBOL(<ord>).
      IF sy-subrc = 0.
        aufnr = <ord>-aufnr.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_ruta.
    CLEAR ruta.
    ASSIGN i_ruta[ matnr = matnr
                   werks = werks ] TO FIELD-SYMBOL(<ruta>).
    IF sy-subrc = 0.
      ruta = <ruta>-ruta.
    ELSE.
      DATA(rutas) = VALUE zhcl_mm_core=>tt_datos_mat_centro_ruta( ( matnr = matnr
                                                                    werks = werks ) ).
      NEW zhcl_mm_core( )->get_datos_material_centro_ruta( CHANGING i_rutas = rutas ).
      ASSIGN rutas[ 1 ] TO FIELD-SYMBOL(<rutas>).
      IF sy-subrc = 0.
        ruta = <rutas>-ruta.
      ENDIF.

      INSERT VALUE #(  matnr = matnr
                       werks = werks
                       ruta  = ruta ) INTO TABLE i_ruta.
    ENDIF.
  ENDMETHOD.
  METHOD get_situacion_of.
    DATA l_porc TYPE p LENGTH 15 DECIMALS 4.

    ASSIGN i_situacion[ aufnr = aufnr ] TO FIELD-SYMBOL(<situacion>).
    IF sy-subrc = 0.
      situacion = <situacion>-situacion.
    ELSE.
      CLEAR situacion.
      SELECT stat FROM jest JOIN caufv ON jest~objnr = caufv~objnr
      INTO TABLE @DATA(i_jest)
      WHERE aufnr = @aufnr
        AND inact = ''
      ORDER BY stat.

      IF line_exists( i_jest[ stat = 'I0046' ] ). " CERR "#EC PREFER_CASE.
        situacion = '02'. " Terminado
      ELSEIF line_exists( i_jest[ stat = 'I0045' ] ). " CTEC
        situacion = '06'. " Cierre administrativo
      ELSEIF line_exists( i_jest[ stat = 'I0010' ] ). " NOTP
        situacion = '05'. " Fabricado Parcialmente
      ELSEIF line_exists( i_jest[ stat = 'I0002' ] ). " LIB.
        situacion = '04'. " Lanzado a máquina
      ELSEIF line_exists( i_jest[ stat = 'I0513' ] ). " PLAN
        situacion = '01'. " Planificado
      ELSEIF line_exists( i_jest[ stat = 'I0001' ] ). " ABIE
        situacion = '00'. " Abierto
      ENDIF.

      IF    situacion = '02' OR situacion = '06' " Cierres
         OR situacion = '05'. " Algo notificado
        SELECT SUM( psmng ), SUM( wemng ) FROM afpo
          INTO (@DATA(l_cantidad_planificada), @DATA(l_cantidad_producida))
         WHERE aufnr = @aufnr.
        IF sy-subrc = 0.
          IF l_cantidad_producida = 0 AND ( situacion = '02' OR situacion = '06' ). " Han dicho que terminada pero sin nada planificada
            situacion = '03'. " Cerradas sin nada fabricado
          ELSEIF situacion = '05' OR situacion = '06'.
            IF l_cantidad_planificada > 0.
              l_porc = 100 * l_cantidad_producida / l_cantidad_planificada.
              IF l_porc >= 70.
                situacion = '02'. " Terminado.
              ENDIF.
            ELSEIF l_cantidad_planificada = 0 AND situacion = '05'. " Puede haber notificación de horas
              situacion = '04'. " Lanzado a máquina
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      INSERT VALUE #( aufnr = aufnr
                      situacion = situacion ) INTO TABLE i_situacion.

      DATA zaufk TYPE zaufk.
      DATA(l_reintentos) = 0.
      TRY.
          SELECT SINGLE * FROM zaufk
            INTO zaufk
           WHERE aufnr = aufnr.
          IF sy-subrc = 0.
            IF zaufk-situacion NE situacion.
              UPDATE zaufk
                 SET situacion = situacion
                     aedat = sy-datum
                     aezet = sy-uzeit
                     aenam = sy-uname
                     aedat_sc = sy-datum
                     aezet_sc = sy-uzeit
              tcode = tcode
        WHERE aufnr = aufnr.
            ELSE.
              DATA: l_sec     TYPE int4,
                    l_cambios TYPE xfeld.

* Por temas del control de busqueda de registros que no han cambiado en última hora, actualizamos la fecha en que lo hemos mirado
              CLEAR l_cambios.
              IF sy-datum > zaufk-aedat_sc.
                l_cambios = 'X'.
              ELSE.
                l_sec = sy-uzeit - zaufk-aezet_sc.
                IF l_sec > 60.
                  l_cambios = 'X'.
                ENDIF.
              ENDIF.
              IF l_cambios = 'X'.
                UPDATE zaufk
                   SET aedat_sc = sy-datum
                       aezet_sc = sy-uzeit
                 WHERE aufnr = aufnr.
              ENDIF.
            ENDIF.
          ELSE.
            CLEAR zaufk.
            zaufk-aufnr = aufnr.
            zaufk-situacion = situacion.
            zaufk-aedat = sy-datum.
            zaufk-aezet = sy-uzeit.
            zaufk-aedat_sc = sy-datum.
            zaufk-aezet_sc = sy-uzeit.
            zaufk-aenam = sy-uname.
            zaufk-tcode = tcode.
            INSERT zaufk FROM zaufk.
          ENDIF.
        CATCH cx_root.                                      "#EC *
          IF l_reintentos < 3.
            l_reintentos = l_reintentos + 1.
            RETRY.
          ENDIF.
      ENDTRY.
    ENDIF.
  ENDMETHOD.
  METHOD import_datos_globales.
    CLEAR: i_situacion, i_ruta.
    IMPORT i_situacion TO i_situacion
           i_ruta TO i_ruta FROM MEMORY ID 'ZHCL_PP_CORE'.
    FREE MEMORY ID 'ZHCL_PP_CORE'.
  ENDMETHOD.
  METHOD s_conv_cinumber_2_external.
*--------------------------------------------------------------------*

    " Formato interno: yyaaaabbc
    " Formato externo: aaaa bb c
    " donde:
    " - yy son los dos últimos dígitos del año
    " - aaaa: Primer valor código.
    " - bb: Segundo valor del código. Tiene espacios
    " - c: Tercer valor del código

*--------------------------------------------------------------------*

**********************************************************************
* Parámetros locales
**********************************************************************

    DATA: lv_cinumber_i TYPE lvs_benum,
          lv_aaaa       TYPE c LENGTH 4,
          lv_bb         TYPE c LENGTH 2,
          lv_c          TYPE c LENGTH 1.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

    CHECK i_cinumber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

    lv_cinumber_i = |{ i_cinumber ALPHA = OUT }|.

    CONDENSE lv_cinumber_i NO-GAPS.

    IF strlen( lv_cinumber_i ) <> 9.
      RETURN.
    ENDIF.

****** CONVERT DATA

    lv_aaaa = |{ lv_cinumber_i+2(4) ALPHA = IN }|.
    lv_bb   = |{ lv_cinumber_i+6(2) ALPHA = IN }|.
    lv_c    = |{ lv_cinumber_i+8(1) ALPHA = IN }|.

****** SET RESULT

    CONCATENATE lv_aaaa lv_bb lv_c INTO r_cinumber SEPARATED BY space RESPECTING BLANKS.
  ENDMETHOD.
  METHOD s_conv_cinumber_2_internal.
**********************************************************************
* Parámetros locales
**********************************************************************

    " Formato externo: aaaa bb c
    " Formato interno: yyaaaabbc
    " donde:
    " - yy son los dos últimos dígitos del año
    " - aaaa: Primer valor código.
    " - bb: Segundo valor del código. Tiene espacios
    " - c: Tercer valor del código
    DATA: lv_mjahr       TYPE mjahr,
          lv_cinumber_ex TYPE lvs_benum,
          lv_aaaa        TYPE c LENGTH 4,
          lv_bb          TYPE c LENGTH 2,
          lv_c           TYPE c LENGTH 1.

    DATA lt_split TYPE TABLE OF char4.

**********************************************************************
* Validaciones
**********************************************************************

****** IMPORT DATA

    CHECK i_mjahr IS NOT INITIAL.
    CHECK i_cinumber IS NOT INITIAL.

**********************************************************************
* Lógica
**********************************************************************

****** PREPARE DATA

***** YEAR

    lv_mjahr = |{ i_mjahr ALPHA = OUT }|.
    IF strlen( lv_mjahr ) <> 4.
      RETURN.
    ENDIF.

***** CINUMBER

    lv_cinumber_ex = |{ i_cinumber ALPHA = OUT }|.
    SPLIT lv_cinumber_ex AT space INTO TABLE lt_split.

    " Si no tiene espacios en blanco, entendemos que ya tiene el formato moderno, y por lo tanto no hay que convertir
    IF lines( lt_split ) <= 1.

      READ TABLE lt_split INTO DATA(ls_line) INDEX 1.
      IF sy-subrc = 0.
        CONDENSE lv_cinumber_ex NO-GAPS.
        IF strlen( lv_cinumber_ex ) = 9.
          r_cinumber = lv_cinumber_ex.
          EXIT.
        ELSE.
          EXIT.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.

    ELSE.

      DELETE lt_split WHERE table_line IS INITIAL.

    ENDIF.

****** CONVERT DATA

    READ TABLE lt_split INTO ls_line INDEX 1.
    IF sy-subrc = 0.
      lv_aaaa = |{ ls_line(4) ALPHA = IN }|.
    ELSE.
      EXIT.
    ENDIF.

    READ TABLE lt_split INTO ls_line INDEX 2.
    IF sy-subrc = 0.
      lv_bb = |{ ls_line(2) ALPHA = IN }|.
    ELSE.
      EXIT.
    ENDIF.

    READ TABLE lt_split INTO ls_line INDEX 3.
    IF sy-subrc = 0.
      lv_c = |{ ls_line(1) ALPHA = IN }|.
    ELSE.
      EXIT.
    ENDIF.

****** SET RETURN

    CONCATENATE i_mjahr+2(2) lv_aaaa lv_bb lv_c INTO r_cinumber RESPECTING BLANKS.
    r_cinumber = |{ r_cinumber ALPHA = IN }|.

    IF strlen( r_cinumber ) < 9.
      CLEAR r_cinumber.
    ENDIF.
  ENDMETHOD.
