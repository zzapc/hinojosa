*&---------------------------------------------------------------------*
*&  Include           ZRPP0010_F01
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  F0300_GET_FIELDS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f0300_get_fields .
  DATA : l_f_type(01) TYPE c.

* find out the fields of structure g_s_mseg_lean
  DESCRIBE FIELD g_s_mseg_lean INTO g_t_td.

  LOOP AT g_t_td-names       INTO  g_s_nameinfo.
*   select all entries who contain 'MSEG-' oder 'MKPF-'
    CASE  g_s_nameinfo-name(05).
      WHEN  'MKPF-'.
        MOVE    c_tilde      TO  g_s_nameinfo-name+4(01).
        APPEND  g_s_nameinfo-name
                             TO  g_t_mseg_fields.

      WHEN  'MSEG-'.
        MOVE  : g_s_nameinfo-name
                             TO  g_s_mseg_fields-fieldname,
                c_tilde      TO  g_s_mseg_fields-fieldname+4(01).
        APPEND  g_s_mseg_fields        TO  g_t_mseg_fields.

      WHEN  OTHERS.
    ENDCASE.
  ENDLOOP.
                                                            "n1784874
** serious error if table g_t_mseg_field does not contain fields
*  IF  g_t_mseg_fields[] IS INITIAL.                         "n599218
*    MESSAGE e895                                     "#EC *    "n599218
*      WITH 'Error, contact system administrator'.    "#EC *    "n599218
*  ELSE.
*    SORT                     g_t_mseg_fields.
*    DELETE ADJACENT DUPLICATES FROM  g_t_mseg_fields.
*  ENDIF.
ENDFORM.                    " F0300_GET_FIELDS
*&---------------------------------------------------------------------*
*&      Form  F0400_CREATE_FIELDCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f0400_create_fieldcat .

  CLEAR                      g_s_fieldcat.

  g_s_fieldcat-fieldname     = 'MATNR'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

  g_s_fieldcat-fieldname     = 'WERKS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

* lagerort                   storage location
* the following special stocks O, V, W need no storage location
  IF  sobkz = 'O'  OR
      sobkz = 'V'  OR
      sobkz = 'W'.
  ELSE.
    g_s_fieldcat-fieldname     = 'LGORT'.
    g_s_fieldcat-ref_tabname   = 'MSEG'.
    g_s_fieldcat-sp_group      = 'O'.
    PERFORM  f0410_fieldcat    USING  c_take   c_out.
  ENDIF.

* Bewegungsart               movement type
  g_s_fieldcat-fieldname     = 'BWART'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

* Sonderbestandskennzeichen  Special stock indicator
  g_s_fieldcat-fieldname     = 'SOBKZ'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

* Nummer des Materialbelegs  Number of material document
  g_s_fieldcat-fieldname     = 'MBLNR'.
  g_s_fieldcat-ref_tabname   = 'MKPF'.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

* Position im Materialbeleg  Item in material document
  g_s_fieldcat-fieldname     = 'ZEILE'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

  IF bwbst = 'X'.
*   Nummer Buchhaltungsbeleg   Accounting document number
    g_s_fieldcat-fieldname     = 'BELNR'.
    g_s_fieldcat-ref_tabname   = 'BSIM'.
    g_s_fieldcat-sp_group      = 'O'.
    PERFORM  f0410_fieldcat    USING  c_take   c_out.
  ENDIF.

* Buchungsdatum im Beleg     Posting date in the document
  g_s_fieldcat-fieldname     = 'BUDAT'.
  g_s_fieldcat-ref_tabname   = 'MKPF'.
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

  g_s_fieldcat-fieldname     = 'MENGE'.     " Menge
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Quantity
  g_s_fieldcat-qfieldname    = 'MEINS'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

  g_s_fieldcat-fieldname     = 'MEINS'.     " Basismengeneinheit
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Base unit of measure
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_out.

  IF NOT bwbst IS INITIAL.   "mit bewertetem Bestand
*   Betrag in Hauswaehrung   Amount in local currency
    g_s_fieldcat-fieldname     = 'DMBTR'.
    g_s_fieldcat-ref_tabname   = 'BSIM'.
    g_s_fieldcat-cfieldname    = 'WAERS'.
    g_s_fieldcat-sp_group      = 'M'.
    PERFORM  f0410_fieldcat    USING  c_take   c_out.
  ENDIF.

  g_s_fieldcat-fieldname     = 'MJAHR'.     " Materialbelegjahr
  g_s_fieldcat-ref_tabname   = 'MKPF'.      " Material doc. year
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'GJAHR'.     " Geschäftsjahr
  g_s_fieldcat-ref_tabname   = 'BKPF'.      " Fiscal Year
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'VGART'.    " Vorgangsart
  g_s_fieldcat-ref_tabname   = 'MKPF'.     " Transaction/event type
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'USNAM'.    " Name des Benutzers
  g_s_fieldcat-ref_tabname   = 'MKPF'.     " User name
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'CPUDT'.    " Tag der Erfassung
  g_s_fieldcat-ref_tabname   = 'MKPF'.     " Acc. doc. entry date
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'CPUTM'.     " Uhrzeit der Erfassung
  g_s_fieldcat-ref_tabname   = 'MKPF'.      " Time of entry
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'SHKZG'.    " Soll-/Haben-Kennzeichen
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " Debit/credit indicator
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'BWTAR'.     " Bewertungsart
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Valuation type
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

* Kennzeichen Bewertung Sonderbestand
* Indicator: valuation of special stock
  g_s_fieldcat-fieldname     = 'KZBWS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'CHARG'.     " Chargennummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Batch number
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'BUKRS'.     " Buchungskreis
  g_s_fieldcat-ref_tabname   = 'T001'.      " Company code
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  IF gv_switch_ehp6ru = abap_true AND bwbst = 'X'.
*   G/L account
    g_s_fieldcat-fieldname     = 'HKONT'.
    g_s_fieldcat-ref_tabname   = 'BSEG'.
    g_s_fieldcat-sp_group      = 'O'.
    PERFORM  f0410_fieldcat    USING  c_take   c_no_out.
  ENDIF.

  g_s_fieldcat-fieldname     = 'KZBEW'.     " Bewegungskennzeichen
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Movement indicator
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'KZVBR'.     " Kennz. Verbrauchsbuchung
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Consumption posting
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'KZZUG'.     " Zugangskennzeichen
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Receipt indicator
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'BUSTM'. " Buchungsstring für Mengen
  g_s_fieldcat-ref_tabname   = 'MSEG'.  " Posting string for quantities
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

  g_s_fieldcat-fieldname     = 'BUSTW'.    " Buchungsstring für Werte
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " Posting string for values
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

* Kennzeichen: Mengenfortschreibung im Materialstammsatz
* Quantity Updating in Material Master Record
  g_s_fieldcat-fieldname     = 'MENGU'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

* Kennzeichen: Wertfortschreibung im Materialstammsatz
* Value Updating in Material Master Record
  g_s_fieldcat-fieldname     = 'WERTU'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

* Bewegungsartengruppe zur Bestandsauswertung
* Movement type group for stock analysis
  g_s_fieldcat-fieldname     = 'BWAGR'.

* the reference table changed in release 46B
  g_s_fieldcat-ref_tabname   = 'T156Q'.

  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.

* process 'goods receipt/issue slip' as hidden field        "n450596
  g_s_fieldcat-fieldname     = 'XABLN'.                     "n450596
  g_s_fieldcat-ref_tabname   = 'MKPF'.                      "n450596
  g_s_fieldcat-sp_group      = 'S'.                         "n450596
  PERFORM  f0410_fieldcat    USING  c_take   c_no_out.      "n450596

* the following fields will be processed if they are in working table
* g_t_mseg_fields         Customer Exit :
* these fields can be activated in include RM07MLBD_CUST_FIELDS

  g_s_fieldcat-fieldname     = 'INSMK'.    " Bestandsart
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " stock type
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'LIFNR'.    " Kontonummer Lieferant
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " vendor's account number
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'KUNNR'.    " Kontonummer des Kunden
  g_s_fieldcat-ref_tabname   = 'MSEG'.   " account number of customer
  g_s_fieldcat-sp_group      = 'V'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname   = 'MAT_KDAUF'.
  g_s_fieldcat-ref_tabname = 'MSEG'.
  g_s_fieldcat-sp_group    = 'V'.
  PERFORM  f0410_fieldcat  USING  c_check  c_no_out.

  g_s_fieldcat-fieldname   = 'MAT_KDPOS'.
  g_s_fieldcat-ref_tabname = 'MSEG'.
  g_s_fieldcat-sp_group    = 'V'.
  PERFORM  f0410_fieldcat  USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'KDAUF'.     " Kundenauftragsnummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Sales Order Number
  g_s_fieldcat-sp_group      = 'V'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'KDPOS'.    " Positionsnummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " Item number in Sales Order
  g_s_fieldcat-sp_group      = 'V'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Einteilung Kundenauftrag   Delivery schedule for sales order
  g_s_fieldcat-fieldname     = 'KDEIN'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'F'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Menge in Erfassungsmengeneinheit   Quantity in unit of entry
  g_s_fieldcat-fieldname     = 'ERFMG'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-qfieldname    = 'ERFME'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'ERFME'.     " Erfassungsmengeneinheit
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Unit of entry
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Menge in Bestellpreismengeneinheit
* Quantity in purchase order price unit
  g_s_fieldcat-fieldname     = 'BPMNG'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-qfieldname    = 'BPRME'.
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'BPRME'.     " Bestellpreismengeneinheit
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Order price unit
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'EBELN'.     " Bestellnummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Purchase order number
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Positionsnummer des Einkaufsbelegs
* Item Number of Purchasing Document
  g_s_fieldcat-fieldname     = 'EBELP'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'SJAHR'.     " Materialbelegjahr
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Material doc. year
  g_s_fieldcat-sp_group      = 'D'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'SMBLN'.     " Nummer des Materialbelegs
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Number of material doc.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'SMBLP'.     " Position im Materialbeleg
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Item in material document
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'ELIKZ'.  " Endlieferungskennzeichen
  g_s_fieldcat-ref_tabname   = 'MSEG'.   "Delivery completed" indicator
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'SGTXT'.     " Positionstext
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Item Text
  g_s_fieldcat-sp_group      = 'E'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'WEMPF'.     " Warenempfänger
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Goods recipient
  g_s_fieldcat-sp_group      = 'V'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'ABLAD'.     " Abladestelle
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Unloading point
  g_s_fieldcat-sp_group      = 'V'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'GSBER'.     " Geschäftsbereich
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Business Area
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Geschäftsbereich des Geschäftspartners
* Trading partner's business area
  g_s_fieldcat-fieldname     = 'PARGB'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'PARBU'.   " Verrechnender Buchungskreis
  g_s_fieldcat-ref_tabname   = 'MSEG'.    " Clearing company code
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'KOSTL'.     " Kostenstelle
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Cost Center
  g_s_fieldcat-sp_group      = 'K'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'AUFNR'.     " Auftragsnummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Order Number
  g_s_fieldcat-sp_group      = 'K'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'ANLN1'.     " Anlagen-Hauptnummer
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Main asset number
  g_s_fieldcat-sp_group      = 'K'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Nummer der Reservierung / des Sekundärbedarfs
* Number of reservation/dependent requirements
  g_s_fieldcat-fieldname     = 'RSNUM'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Positionsnummer der Reservierung / des Sekundärbedarfs
* Item number of reservation/dependent requirements
  g_s_fieldcat-fieldname     = 'RSPOS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Final issue for this reservation
  g_s_fieldcat-fieldname     = 'KZEAR'.    " Kennzeichen: Endausfassung
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* empfangendes/abgebendes Material
* Receiving/issuing material
  g_s_fieldcat-fieldname     = 'UMMAT'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Empfangendes/Abgebendes Werk
* Receiving plant/issuing plant
  g_s_fieldcat-fieldname     = 'UMWRK'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Empfangender/Abgebender Lagerort
* Receiving/issuing storage location
  g_s_fieldcat-fieldname     = 'UMLGO'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'UMCHA'.  " Empfangende/Abgebende Charge
  g_s_fieldcat-ref_tabname   = 'MSEG'.   " Receiving/issuing batch
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Empfangende/Abgebende Bwertungsart
* Valuation type of transfer batch
  g_s_fieldcat-fieldname     = 'UMBAR'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Sonderbestandskennzeichen der Umlagerung
* Special stock indicator for physical stock transfer
  g_s_fieldcat-fieldname     = 'UMSOK'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Kennzeichen Wareneingang unbewertet
* Goods receipt, non-valuated
  g_s_fieldcat-fieldname     = 'WEUNB'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Kennzeichen: Grund der Bewegung
* Reason for movement
  g_s_fieldcat-fieldname     = 'GRUND'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'KSTRG'.    " Kostenträger
  g_s_fieldcat-ref_tabname   = 'MSEG'.  " Cost Object
  g_s_fieldcat-sp_group      = 'K'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Nummer für Ergebnisobjekte (CO-PA)
* Profitability segment number (CO-PA)
  g_s_fieldcat-fieldname     = 'PAOBJNR'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'K'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'PRCTR'.     " Profit Center
  g_s_fieldcat-ref_tabname   = 'MSEG'.      " Profit Center
  g_s_fieldcat-sp_group      = 'O'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Material, auf dem der Bestand geführt wird
* Material on which stock is managed
  g_s_fieldcat-fieldname     = 'MATBF'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Empfangendes/Abgebendes Material
* Receiving/issuing material
  g_s_fieldcat-fieldname     = 'UMMAB'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Gesamter bewerteter Bestand
* Total valuated stock before the posting
  g_s_fieldcat-fieldname     = 'LBKUM'.
  g_s_fieldcat-qfieldname    = 'MEINS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Wert des gesamten bewerteten Bestandes
* Value of total valuated stock before the posting
  g_s_fieldcat-fieldname     = 'SALK3'.
  g_s_fieldcat-cfieldname    = 'WAERS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'B'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

  g_s_fieldcat-fieldname     = 'VPRSV'.    " Preissteuerungskennzeichen
  g_s_fieldcat-ref_tabname   = 'MSEG'.     " Price control indicator
  g_s_fieldcat-sp_group      = 'S'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Wert zu Verkaufspreisen ohne Mehrwertsteuer
* Value at sales prices excluding value-added tax
  g_s_fieldcat-fieldname     = 'VKWRA'.
  g_s_fieldcat-cfieldname    = 'WAERS'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'S'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Ursprungszeile im Materialbeleg
* Original line in material document
  g_s_fieldcat-fieldname     = 'URZEI'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'S'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Menge in Mengeneinheit aus Lieferschein
* Quantity in unit of measure from delivery note
  g_s_fieldcat-fieldname     = 'LSMNG'.
  g_s_fieldcat-qfieldname    = 'LSMEH'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* Mengeneinheit aus Lieferschein
* Unit of measure from delivery note
  g_s_fieldcat-fieldname     = 'LSMEH'.
  g_s_fieldcat-ref_tabname   = 'MSEG'.
  g_s_fieldcat-sp_group      = 'M'.
  PERFORM  f0410_fieldcat    USING  c_check  c_no_out.

* if the field catalog contains a field with values in currency,
* add the currency to to field-catalogue
  DATA : l_cnt_waers_active TYPE i,
         l_cnt_waers_total  TYPE i.

  LOOP AT fieldcat           INTO  g_s_fieldcat.
    CHECK : g_s_fieldcat-cfieldname    = 'WAERS'.
*   this field has a reference to the currency key
    ADD  1                   TO  l_cnt_waers_total.

    CHECK : g_s_fieldcat-no_out IS INITIAL.
*   this field is active
    ADD  1                   TO  l_cnt_waers_active.
  ENDLOOP.

  IF    l_cnt_waers_active > 0.
*   there is at least one active reference field
*   declare currency key WAERS active, too
    g_s_fieldcat-fieldname     = 'WAERS'.   "Currency Key
    g_s_fieldcat-ref_tabname   = 'T001'.
    g_s_fieldcat-sp_group      = 'M'.
    PERFORM  f0410_fieldcat    USING  c_take   c_out.

  ELSEIF  l_cnt_waers_total > 0.
*   there are only hidden reference fields
*   declare currency key WAERS hidden, too
    g_s_fieldcat-fieldname     = 'WAERS'.   "Currency Key
    g_s_fieldcat-ref_tabname   = 'T001'.
    g_s_fieldcat-sp_group      = 'M'.
    PERFORM  f0410_fieldcat    USING  c_take   c_no_out.
  ENDIF.

ENDFORM.                    " F0400_CREATE_FIELDCAT

*----------------------------------------------------------------------*
*    F0410_FIELDCAT
*----------------------------------------------------------------------*

FORM f0410_fieldcat
         USING  l_f_check
                l_f_no_out   TYPE      slis_fieldcat_main-no_out.

  DATA : l_f_continue(01) TYPE c,
         l_f_type(01)     TYPE c,
         l_f_fieldname    TYPE stype_fields.

  FIELD-SYMBOLS : <l_fs>.

  IF  l_f_check = c_take.
*   take this entry without check
    MOVE  'X'                TO  l_f_continue.
  ELSE.
*   create key and look for fieldname
    CONCATENATE              g_s_fieldcat-ref_tabname
                             '~'
                             g_s_fieldcat-fieldname
                             INTO l_f_fieldname.

    READ TABLE g_t_mseg_fields         INTO g_s_mseg_fields
                             WITH KEY
                             fieldname = l_f_fieldname
                             BINARY SEARCH.

    IF sy-subrc IS INITIAL.
      MOVE  'X'              TO  l_f_continue.
    ELSE.
*     additional fields are displayed in wrong format :
*     clear the working area for the field catalog when
*     the current field should not be processed
      CLEAR                  g_s_fieldcat.
      CLEAR                  l_f_continue.
    ENDIF.
  ENDIF.

* append entry to field catalog if field is in structure
* else leave this routine
  IF l_f_continue IS INITIAL.
    CLEAR                    g_s_fieldcat.
    EXIT.
  ENDIF.

  IF  NOT l_f_no_out IS INITIAL.
    MOVE  l_f_no_out         TO  g_s_fieldcat-no_out.
  ENDIF.

  ADD  : 1                   TO  g_f_col_pos.
  MOVE : g_f_col_pos         TO  g_s_fieldcat-col_pos,
         g_f_tabname         TO  g_s_fieldcat-tabname.
  APPEND g_s_fieldcat        TO  fieldcat.

* create the table with the fields who will be enriched with colors
* and sign
  IF  g_s_fieldcat-fieldname  =  'MENGE'  OR
      g_s_fieldcat-fieldname  =  'MEINS'  OR
      g_s_fieldcat-fieldname  =  'DMBTR'  OR
      g_s_fieldcat-fieldname  =  'WAERS'  OR
      g_s_fieldcat-fieldname  =  'ERFMG'  OR
      g_s_fieldcat-fieldname  =  'ERFME'  OR

      g_s_fieldcat-fieldname  =  'BPMNG'  OR
      g_s_fieldcat-fieldname  =  'BPRME'  OR
      g_s_fieldcat-fieldname  =  'BSTMG'  OR
      g_s_fieldcat-fieldname  =  'BSTME'  OR
      g_s_fieldcat-fieldname  =  'EXBWR'  OR
      g_s_fieldcat-fieldname  =  'VKWRT'  OR

      g_s_fieldcat-fieldname  =  'EXVKW'  OR
      g_s_fieldcat-fieldname  =  'VKWRA'  OR
      g_s_fieldcat-fieldname  =  'LSMNG'  OR
      g_s_fieldcat-fieldname  =  'LSMEH'  OR
      g_s_fieldcat-fieldname  =  'SHKZG'.

*   look for the type of this field
    CONCATENATE              g_s_fieldcat-ref_tabname
                             '-'
                             g_s_fieldcat-fieldname
                             INTO l_f_fieldname.

    ASSIGN  (l_f_fieldname)  TO <l_fs>.

    IF  sy-subrc IS INITIAL.
      DESCRIBE FIELD <l_fs>    TYPE  l_f_type.
      MOVE : g_s_fieldcat-fieldname
                             TO  g_t_color_fields-fieldname,
           l_f_type          TO  g_t_color_fields-type.
      APPEND                 g_t_color_fields.
    ENDIF.
  ENDIF.

  CLEAR                      g_s_fieldcat.

ENDFORM.                     "F0410_FIELDCAT
*&---------------------------------------------------------------------*
*&      Form  F4_FOR_VARIANT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f4_for_variant .
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = variante
      i_save     = variant_save
*     it_default_fieldcat =
    IMPORTING
      e_exit     = variant_exit
      es_variant = def_variante
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF variant_exit = space.
      p_vari = def_variante-variant.
    ENDIF.
  ENDIF.
ENDFORM.                    " F4_FOR_VARIANT
*&---------------------------------------------------------------------*
*&      Form  F0600_CREATE_RANGE_LGORT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f0600_create_range_lgort .
  REFRESH                    g_ra_lgort.
  CLEAR                      g_ra_lgort.

  IF      lgbst = 'X'.       "only Storage loc./batch stock
*   copy the existing select-options
    MOVE lgort[]               TO  g_ra_lgort[].

*   add an exclusion for storage location = space
    MOVE : 'E'               TO  g_ra_lgort-sign,
           'EQ'              TO  g_ra_lgort-option.
    APPEND                   g_ra_lgort.

  ELSEIF  bwbst = 'X'.       "only valuated stocks
*   copy the existing select-options
    MOVE lgort[]               TO  g_ra_lgort[].

  ELSEIF  sbbst = 'X'.       "only special stocks
    IF      sobkz  =  'O'  OR
            sobkz  =  'V'  OR
            sobkz  =  'W'.
*     only records with storage location = space allowed
      MOVE : 'I'             TO  g_ra_lgort-sign,
             'EQ'            TO  g_ra_lgort-option.
      APPEND                 g_ra_lgort.
    ELSE.
*     Copy the existing select-options
      MOVE lgort[]             TO  g_ra_lgort[].
    ENDIF.
  ENDIF.
ENDFORM.                    " F0600_CREATE_RANGE_LGORT
*&---------------------------------------------------------------------*
*&      Form  SELECCION_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM seleccion_datos .

ENDFORM.                    " SELECCION_DATOS
*&---------------------------------------------------------------------*
*&      Form  NEW_DB_RUN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM new_db_run .
  REFRESH datum.  "delete existing entries because ...
  APPEND datum.   ".. relevant data is appended here
  TRY.
      CALL BADI gr_badi_rm07mlbd_dbsys_opt->calculate_stocks
        EXPORTING
          it_material          = matnr[]
          it_company_code      = bukrs[]
          it_plant             = werks[]
          it_storage_location  = lgort[]
          it_batch             = charg[]
          it_valuation_type    = bwtar[]
          it_movement_type     = bwart[]
          it_posting_date      = datum[]
          iv_special_stock_ind = sobkz
          iv_batch_stock       = lgbst
          iv_valuated_stock    = bwbst
          iv_special_stock     = sbbst
          iv_batch_mat_only    = ''
          iv_batch_no_mchb     = ''
          iv_no_reversals      = ''
        IMPORTING
          et_stock_inventory   = gt_stock_inventory
          ev_no_dbsys_opt      = gv_no_dbsys_opt.
    CATCH cx_badi.
      gv_newdb = abap_false.
  ENDTRY.
  IF gv_no_dbsys_opt = abap_true.
    gv_newdb = abap_false.
  ELSE.
    LOOP AT gt_stock_inventory ASSIGNING <gs_stock_inventory>.
      MOVE-CORRESPONDING <gs_stock_inventory> TO bestand.
      MOVE-CORRESPONDING <gs_stock_inventory> TO g_s_makt.
      APPEND bestand.
      APPEND g_s_makt TO g_t_makt.
      CLEAR <gs_stock_inventory>-maktx. "to compare it to bestand in AUT
    ENDLOOP.
* if result is empty, call subroutines to get the detailed error messages "1784986
    IF gv_newdb = abap_true AND sy-subrc NE 0.
      gv_newdb = abap_false.
      PERFORM aktuelle_bestaende.
      PERFORM f1000_select_mseg_mkpf.
      gv_newdb = abap_true.
    ENDIF.
    SORT g_t_makt BY matnr.
    DELETE ADJACENT DUPLICATES FROM g_t_makt.
  ENDIF.
ENDFORM.                    " NEW_DB_RUN
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BESTAENDE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bestaende .

  DATA: lt_plant          TYPE STANDARD TABLE OF t001w-werks,
        lo_converter_osql TYPE REF TO            if_auth_objects_to_sql.

  FIELD-SYMBOLS: <lv_plant> TYPE t001w-werks.

  IF bwbst = abap_false.
    lo_converter_osql = cl_auth_objects_to_sql=>create_for_open_sql( ).
    lo_converter_osql->add_authorization_object(
            EXPORTING iv_authorization_object = 'M_MSEG_WMB'
                     it_activities = VALUE #(
                                     ( auth_field = 'ACTVT' value = '03' )
                                                                 )
                     it_field_mapping = VALUE #(
                                     ( auth_field = 'WERKS'
                                       view_field = VALUE #( table_ddic_name = 'T001W'
                                                             table_alias = ''
                                                             field_name = 'WERKS' ) )
                                                        ) ).
    CLEAR: gv_where_clause, gv_not_authorized.
    TRY.
        gv_where_clause = lo_converter_osql->get_sql_condition( ).
      CATCH cx_auth_not_authorized.
        gv_not_authorized = abap_true.
    ENDTRY.
  ENDIF.                                                    "^n_1899544

* delete the range tables for the creation of table g_t_organ
  IF  g_t_organ[] IS INITIAL.                               "n433765
    REFRESH : g_0000_ra_werks, g_0000_ra_bwkey, g_0000_ra_bukrs.
    CLEAR   : g_0000_ra_werks, g_0000_ra_bwkey, g_0000_ra_bukrs.
  ENDIF.

**** Begin of correction 1916359
**** Retrieve plant records for which the user has no authority to issue the corresponding authority message
**** Only for compatibility reasons after code pushdown of authority check to DB
****  IF gv_where_clause IS NOT INITIAL AND gv_not_authorized = abap_false AND NOT bwbst = 'X'.
****    IF lgbst = 'X' AND xchar = ' '.
****      PERFORM hdb_check_table USING 'MARD' ''.
****      SELECT DISTINCT werks FROM mard INTO TABLE lt_plant  CONNECTION (dbcon)
****                                                 WHERE werks IN g_ra_werks
****                                                 AND NOT (gv_where_clause)
****                                                 AND lgort IN g_ra_lgort
****                                                 AND matnr IN matnr.
****    ELSEIF lgbst = 'X' AND xchar = 'X' AND xnomchb IS NOT INITIAL.
****      PERFORM hdb_check_table USING 'MCHA' ''.              "n1710850
****      SELECT DISTINCT werks FROM mcha INTO TABLE lt_plant CONNECTION (dbcon)
****                                                 WHERE werks IN g_ra_werks
****                                                 AND NOT (gv_where_clause)
****                                                 AND matnr IN matnr
****                                                 AND charg IN charg.
****    ELSEIF sbbst = 'X'.
****      CASE    sobkz.
****        WHEN  'O'.
****          PERFORM hdb_check_table USING 'MSLB' ''.
****          SELECT DISTINCT werks FROM mslb INTO TABLE lt_plant CONNECTION (dbcon)
****                                                     WHERE werks IN g_ra_werks
****                                                     AND NOT (gv_where_clause)
****                                                     AND matnr IN matnr
****                                                     AND charg IN charg
****                                                     AND sobkz = sobkz.
****        WHEN  'V' OR  'W'.
****          PERFORM hdb_check_table USING 'MSKU' ''.
****          SELECT DISTINCT werks FROM msku INTO TABLE lt_plant CONNECTION (dbcon)
****                                                     WHERE werks IN g_ra_werks
****                                                     AND NOT (gv_where_clause)
****                                                     AND matnr IN matnr
****                                                     AND charg IN charg
****                                                     AND sobkz = sobkz.
****        WHEN  'K' OR  'M'.
****          PERFORM hdb_check_table USING 'MKOL' ''.
****          SELECT DISTINCT werks FROM mkol INTO TABLE lt_plant CONNECTION (dbcon)
****                                                     WHERE werks IN g_ra_werks
****                                                     AND NOT (gv_where_clause)
****                                                     AND lgort IN g_ra_lgort
****                                                     AND matnr IN matnr
****                                                     AND charg IN charg
****                                                     AND sobkz = sobkz.
****        WHEN  'Q'.
****          PERFORM hdb_check_table USING 'MSPR' ''.
****          SELECT DISTINCT werks FROM mspr INTO TABLE lt_plant CONNECTION (dbcon)
****                                                     WHERE werks IN g_ra_werks
****                                                     AND NOT (gv_where_clause)
****                                                     AND lgort IN g_ra_lgort
****                                                     AND matnr IN matnr
****                                                     AND charg IN charg
****                                                     AND sobkz = sobkz.
****        WHEN  'E' OR 'T'.
****          PERFORM hdb_check_table USING 'MSKA' ''.
****          SELECT DISTINCT werks FROM mska INTO TABLE lt_plant CONNECTION (dbcon)
****                                                     WHERE werks IN g_ra_werks
****                                                     AND NOT (gv_where_clause) "n_1899544
****                                                     AND lgort IN g_ra_lgort
****                                                     AND matnr IN matnr
****                                                     AND charg IN charg
****                                                     AND sobkz = sobkz.
****        WHEN  OTHERS.
****      ENDCASE.
****    ENDIF.
****    LOOP AT lt_plant ASSIGNING <lv_plant>.
****      PERFORM f9000_auth_plant_check USING <lv_plant>.
****    ENDLOOP.
****  ENDIF.
**** End of correction 1916359

  IF      bwbst = 'X'.
*   select the valuated stocks
    PERFORM                  aktuelle_bst_bwbst.

  ELSEIF lgbst = 'X'.
*   all own stock from storage locations or batches

    PERFORM                aktuelle_bst_lgbst_mard.

  ELSEIF   sbbst = 'X'.
*    special stocks
*    ENHANCEMENT-SECTION     AKTUELLE_BESTAENDE_01 SPOTS ES_RM07MLBD.
    CASE    sobkz.
      WHEN  'O'.
        PERFORM              aktuelle_bst_sbbst_o.
      WHEN  'V' OR  'W'.
        PERFORM              aktuelle_bst_sbbst_v_w.
      WHEN  'K' OR  'M'.
        PERFORM              aktuelle_bst_sbbst_k_m.
      WHEN  'Q'.
        PERFORM              aktuelle_bst_sbbst_q.
      WHEN  'E'.
        PERFORM              aktuelle_bst_sbbst_e.
      WHEN  'T'.
        PERFORM              aktuelle_bst_sbbst_t.
      WHEN  OTHERS.
*       Angegebener Sonderbestand nicht vorhanden.
        MESSAGE s290(db).
        PERFORM              anforderungsbild.
    ENDCASE.
*    END-ENHANCEMENT-SECTION.
  ENDIF.

* create table g_t_organ with the plants and valuation areas from
* the database selection if table g_t_organ is empty
  PERFORM  f0000_create_table_g_t_organ
                             USING  c_no_error.
*


ENDFORM.                    " AKTUELLE_BESTAENDE
*&---------------------------------------------------------------------*
*&      Form  F1000_SELECT_MSEG_MKPF
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f1000_select_mseg_mkpf .
** selection of material docs in database tables MKPF and MSEG

** was the MSEG conversion done? then choose new logic
  IF g_f_msegex_act IS INITIAL.
* what kind of database access does the user choose ?
*  IF      pa_dbstd = 'X'.
*   standard access, the database optimizer looks for the
*   access path
*    PERFORM hdb_check_table USING 'MKPF' 'MSEG'.
    SELECT (g_t_mseg_fields)
         INTO CORRESPONDING FIELDS OF TABLE g_t_mseg_lean
         FROM mkpf AS mkpf  JOIN mseg AS mseg
                  ON mkpf~mandt  =  mseg~mandt  AND
                     mkpf~mblnr  =  mseg~mblnr  AND
                     mkpf~mjahr  =  mseg~mjahr
        " CONNECTION (dbcon)
         WHERE mseg~matnr  IN  matnr
           AND mseg~werks  IN  g_ra_werks
           AND mseg~lgort  IN  g_ra_lgort
           AND mseg~charg  IN  charg
           AND mseg~bwtar  IN  bwtar
           AND mseg~bwart  IN  bwart
           AND mkpf~budat  GE  datum-low
           AND mseg~sobkz  IN  g_ra_sobkz.

  ELSE.

*        PERFORM hdb_check_table USING 'MKPF' 'MSEG'.
    SELECT (g_t_mseg_fields)
     INTO CORRESPONDING FIELDS OF TABLE g_t_mseg_lean
     FROM mkpf AS mkpf  JOIN mseg AS mseg
              ON mkpf~mandt  =  mseg~mandt  AND
                 mkpf~mblnr  =  mseg~mblnr  AND
                 mkpf~mjahr  =  mseg~mjahr
     "CONNECTION (dbcon)
     WHERE mseg~matnr       IN  matnr
       AND mseg~werks       IN  g_ra_werks
       AND mseg~lgort       IN  g_ra_lgort
       AND mseg~charg       IN  charg
       AND mseg~bwtar       IN  bwtar
       AND mseg~bwart       IN  bwart
       AND mseg~budat_mkpf  GE  datum-low
       AND mseg~sobkz       IN  g_ra_sobkz.

  ENDIF.

  IF  g_t_mseg_lean IS INITIAL.
*   no material documents found
    MESSAGE                  s842(m7).
  ENDIF.

  DATA: lt_imchb_tmp LIKE imchb OCCURS 0,
        ls_imchb     LIKE imchb.

* check whether the found MM doc items contain retail and
* and beverage specific values
* check authority in this loop - endloop
  LOOP AT g_t_mseg_lean      ASSIGNING <g_fs_mseg_lean>.
*   a) check authorisation
*    PERFORM        f9000_auth_plant_check
*                             USING  <g_fs_mseg_lean>-werks.
*
*    IF  g_flag_authority IS INITIAL.
*      DELETE                g_t_mseg_lean.
*      CONTINUE.             "take the next entry
*    ENDIF.

*   b) look for special indicators
    IF  NOT <g_fs_mseg_lean>-xauto IS INITIAL.
      IF  <g_fs_mseg_lean>-xauto IN g_ra_xauto.
        MOVE  'X'            TO  g_cust_tied_empties.
      ENDIF.
    ENDIF.
*   838360_v
*   according to note 62272 MCHB may be archived even if the batches
*   are still in use. Therefore we try to find such batches by
*   collecting the batches used in MSEG.
    IF NOT <g_fs_mseg_lean>-charg IS INITIAL.
      ls_imchb-matnr = <g_fs_mseg_lean>-matnr.
      ls_imchb-werks = <g_fs_mseg_lean>-werks.
      ls_imchb-lgort = <g_fs_mseg_lean>-lgort.
      ls_imchb-charg = <g_fs_mseg_lean>-charg.
      APPEND ls_imchb TO lt_imchb_tmp.
    ENDIF.
*   838360_^
* for active ingredient materials MB5B should not display
* the 141 and 142 movements for the selection valuated
* stock to avoid wrong beginning stock amount.
    IF bwbst = 'X' AND <g_fs_mseg_lean>-bustw = 'MB08'.
      DELETE                 g_t_mseg_lean.
      CONTINUE.              "take the next entry
    ENDIF.
  ENDLOOP.

* 838360_v
  IF NOT lt_imchb_tmp[] IS INITIAL.
*   the following lines merge the batches found in MCHB with the ones
*   found in the material documents.
    SORT lt_imchb_tmp DESCENDING BY werks matnr lgort charg.
    DELETE ADJACENT DUPLICATES FROM lt_imchb_tmp
                               COMPARING werks matnr lgort charg.
    APPEND LINES OF lt_imchb_tmp TO imchb.
*   due to the merge of mchb batches and mseg batches there will be
*   duplicate entries in imchb by now. They will be deleted. The
*   following sort makes sure that only lines without a quantity are
*   deleted by the 'delete adjacent duplicates' command.
    SORT imchb DESCENDING BY werks matnr lgort charg
                             clabs cumlm cinsm ceinm cspem cretm.
    DELETE ADJACENT DUPLICATES FROM imchb
                               COMPARING matnr werks lgort charg.
    FREE lt_imchb_tmp.
  ENDIF.
* 838360_^
*
** function for tied empties is active and
** stock type = storage location/batch ?
  IF  NOT g_cust_tied_empties IS INITIAL   AND
      NOT lgbst               IS INITIAL.
*   sort the results by documents numbers und items
    SORT  g_t_mseg_lean      BY  mblnr mjahr zeile.
  ENDIF.
*
** process table withe the results form the database selection
  LOOP AT g_t_mseg_lean      INTO  g_s_mseg_lean.
    PERFORM                  f1100_check_lgort_sokzg.

    IF  g_flag_delete = 'X'.
      DELETE                 g_t_mseg_lean.
      CONTINUE.              "take the next entry
    ENDIF.

*   function for tied empties is active and                 "
*   stock type = storage location/batch ?
    IF  NOT g_cust_tied_empties IS INITIAL   AND
        NOT lgbst               IS INITIAL.

*     check whether this line was generated automatically
      IF  g_s_mseg_lean-xauto = 'X'.
*       look for the origin line
        COMPUTE  g_f_zeile = g_s_mseg_lean-zeile - 1.

*       check whether the previous line contains the
*       original posting
        IF  g_s_mseg_pr-matnr = g_s_mseg_lean-matnr AND
            g_s_mseg_pr-mblnr = g_s_mseg_lean-mblnr AND
            g_s_mseg_pr-mjahr = g_s_mseg_lean-mjahr AND
            g_s_mseg_pr-zeile = g_f_zeile.
*         the previous entry contains the original line

          IF  g_s_mseg_pr-xauto IN g_ra_xauto.
*           the previous line contains a matching value
*           XAUTO -> save it in working table
            APPEND  g_s_mseg_pr     TO  g_t_mseg_or.
          ENDIF.
        ELSE.
*         the previous entry does not contain the original
*         posting : save the key
          g_s_mseg_key-matnr      = g_s_mseg_lean-matnr.
          g_s_mseg_key-mblnr      = g_s_mseg_lean-mblnr.
          g_s_mseg_key-mjahr      = g_s_mseg_lean-mjahr.
          g_s_mseg_key-zeile      = g_f_zeile.
          APPEND  g_s_mseg_key    TO  g_t_mseg_key.
        ENDIF.
      ENDIF.

*     save the current entry in the buffer previous entry
      MOVE-CORRESPONDING g_s_mseg_lean TO  g_s_mseg_pr.
    ENDIF.
  ENDLOOP.
*
* function for tied empties is active and
* stock type = storage location/batch ?
  IF  NOT g_cust_tied_empties IS INITIAL   AND
      NOT lgbst               IS INITIAL.

*   Select the missing items with the origin posting lines
*   and append them into the working table

    IF  NOT g_t_mseg_key[] IS INITIAL.

      REFRESH g_t_mseg_key.
      MOVE g_t_mseg_key_te[] TO g_t_mseg_key[].

      IF  NOT g_t_mseg_key[] IS INITIAL.
* are there any keys left after reading mm docs from archive?
*      PERFORM hdb_check_table USING 'MSEG' ''.
        SELECT mblnr mjahr zeile matnr xauto
             FROM  mseg  "CONNECTION (dbcon)
           APPENDING TABLE g_t_mseg_or
           FOR ALL ENTRIES IN g_t_mseg_key
           WHERE  mblnr = g_t_mseg_key-mblnr
             AND  mjahr = g_t_mseg_key-mjahr
             AND  zeile = g_t_mseg_key-zeile
             AND  xauto IN g_ra_xauto.   "only F, L, M, W
      ENDIF.
    ENDIF.

    SORT  g_t_mseg_or      BY  mblnr mjahr zeile matnr.

*   process the MM docs in any cases :
*   - delete the lines with the special value for XAUTO
*   - check lines who were created automatically whether
*     the original line has a special value for XAUTO
    LOOP AT g_t_mseg_lean INTO  g_s_mseg_lean.
      CLEAR                g_flag_delete.

*     evaluate field XAUTO
      IF      g_s_mseg_lean-xauto IS INITIAL.
*       no action
      ELSEIF  g_s_mseg_lean-xauto IN g_ra_xauto.
*       delete MM docs with XAUTO = 'F', 'L', 'M', 'W'
        MOVE  'X'            TO  g_flag_delete.

      ELSEIF  g_s_mseg_lean-xauto = 'X'.
        IF  NOT g_t_mseg_or[] IS INITIAL.
*         check field XAUTO of the original MM doc item
          COMPUTE  g_f_zeile = g_s_mseg_lean-zeile - 1.

          READ TABLE g_t_mseg_or
                    INTO  g_s_mseg_or
                    WITH KEY mblnr = g_s_mseg_lean-mblnr
                             mjahr = g_s_mseg_lean-mjahr
                             zeile = g_f_zeile
                             matnr = g_s_mseg_lean-matnr
                             BINARY SEARCH.

          IF  sy-subrc IS INITIAL.
*           the original line was a posting for a tied
*           empties material -> delete this entry
            MOVE  'X'        TO  g_flag_delete.
          ENDIF.
        ENDIF.
      ENDIF.

      IF  g_flag_delete = 'X'.
        DELETE               g_t_mseg_lean.
      ENDIF.
    ENDLOOP.

*   release the space of the working tables
    FREE : g_t_mseg_or, g_t_mseg_key.
  ENDIF.

* is the table g_t_mseg_lean empty and no authority problems
  DESCRIBE TABLE g_t_mseg_lean         LINES  g_f_cnt_lines.

  IF  g_f_cnt_lines   IS INITIAL  AND
      g_f_cnt_before  =  g_f_cnt_after.
*   Keinen Eintrag zu den Suchbegriffen gefunden/selektiert
    MESSAGE                  s083(m7).
  ENDIF.

ENDFORM.                    " F1000_SELECT_MSEG_MKPF
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_BWBST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_bwbst .
* define local working areas  / for the result of the
* database selections and the control break
  DATA : l_t_mbew         TYPE stab_mbew,
         l_s_mbew         TYPE stype_mbew,

         l_s_mbew_split   TYPE stype_mbew,
         l_s_mbew_normal  TYPE stype_mbew,
         l_flag_split(01) TYPE c.

** build Valuation Class restriction table
*  IF gv_switch_ehp6ru = abap_true.
*    PERFORM build_bklas_selection.
*  ENDIF.

* read the matching valuation entries
*  PERFORM hdb_check_table USING 'MBEW' ''.
  SELECT matnr bwkey bwtar lbkum salk3 bwtty  FROM mbew" CONNECTION (dbcon)
         INTO CORRESPONDING FIELDS OF TABLE l_t_mbew
         WHERE  matnr  IN  matnr
           AND  bwkey  IN  g_ra_bwkey
           AND  bwtar  IN  bwtar
           AND  bklas  IN  ibklas.


* read the matching valuation records of the valuate
* special stock sales order
*  PERFORM hdb_check_table USING 'EBEW' ''.
  SELECT matnr bwkey bwtar bwtty
         SUM( lbkum ) AS lbkum
         SUM( salk3 ) AS salk3  FROM  ebew" CONNECTION (dbcon)
         APPENDING CORRESPONDING FIELDS OF TABLE l_t_mbew
         WHERE  matnr  IN  matnr
           AND  bwkey  IN  g_ra_bwkey
           AND  bwtar  IN  bwtar
           AND  bklas  IN  ibklas
         GROUP BY  matnr  bwkey bwtar bwtty.

* read the matching valuation records of the valuated
* special stock projects
*  PERFORM hdb_check_table USING 'QBEW' ''.
  SELECT matnr bwkey bwtar bwtty
         SUM( lbkum ) AS lbkum
         SUM( salk3 ) AS salk3  FROM  qbew" CONNECTION (dbcon)
         APPENDING CORRESPONDING FIELDS OF TABLE l_t_mbew
         WHERE  matnr  IN  matnr
           AND  bwkey  IN  g_ra_bwkey
           AND  bwtar  IN  bwtar
           AND  bklas  IN  ibklas
         GROUP BY  matnr  bwkey bwtar bwtty.

* read the matching valuation records of the valuated
* special subcontractor stock OBEW
*  PERFORM hdb_check_table USING 'OBEW' ''.
  SELECT matnr bwkey bwtar bwtty
         SUM( lbkum ) AS lbkum
         SUM( salk3 ) AS salk3  FROM  obew" CONNECTION (dbcon)
         APPENDING CORRESPONDING FIELDS OF TABLE l_t_mbew
         WHERE  matnr  IN  matnr
           AND  bwkey  IN  g_ra_bwkey
           AND  bwtar  IN  bwtar
           AND  bklas  IN  ibklas
         GROUP BY  matnr  bwkey bwtar bwtty.

  IF l_t_mbew[] IS INITIAL.
    MESSAGE s120(zpp).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* create table g_t_organ if it is still empty
  IF  g_t_organ[] IS INITIAL.
*   create working table G_0000_RA_BWKEY with the valuation areas
    LOOP AT l_t_mbew INTO  l_s_mbew.
      ON CHANGE OF l_s_mbew-bwkey.
        MOVE : l_s_mbew-bwkey
                             TO  g_0000_ra_bwkey-low,
               'I'           TO  g_0000_ra_bwkey-sign,
               'EQ'          TO  g_0000_ra_bwkey-option.
        COLLECT              g_0000_ra_bwkey.
      ENDON.
    ENDLOOP.

    PERFORM  f0000_create_table_g_t_organ
                             USING  c_no_error.
  ENDIF.

  SORT  l_t_mbew             BY  matnr  bwkey.

  LOOP AT l_t_mbew           INTO  l_s_mbew.
*   check if MBEW record is a mother segment (splitval)
    IF  l_s_mbew-bwtar IS INITIAL
        AND NOT l_s_mbew-bwtty IS INITIAL.
      CLEAR l_s_mbew-lbkum.
      CLEAR l_s_mbew-salk3.
    ENDIF.
*   process a single entry / add the stock and value
    IF  l_s_mbew-bwtar IS INITIAL.
      MOVE : l_s_mbew-matnr  TO  l_s_mbew_normal-matnr,
             l_s_mbew-bwkey  TO  l_s_mbew_normal-bwkey.
      ADD :  l_s_mbew-lbkum  TO  l_s_mbew_normal-lbkum,
             l_s_mbew-salk3  TO  l_s_mbew_normal-salk3.
    ELSE.
*     material has split valuation
      MOVE : 'X'             TO  l_flag_split,
             l_s_mbew-matnr  TO  l_s_mbew_split-matnr,
             l_s_mbew-bwkey  TO  l_s_mbew_split-bwkey.
      ADD :  l_s_mbew-lbkum  TO  l_s_mbew_split-lbkum,
             l_s_mbew-salk3  TO  l_s_mbew_split-salk3.
    ENDIF.

*   control break after material and valuation area
    AT END OF bwkey.
*     create a entry for the next working table
      IF  l_flag_split = 'X'.
*       if the material has split valuation, take only
*       the sums from the entries with valuation type
        MOVE-CORRESPONDING  l_s_mbew_split  TO  g_s_mbew.
      ELSE.
        MOVE-CORRESPONDING  l_s_mbew_normal TO  g_s_mbew.
      ENDIF.

*     check the authority
      PERFORM  f9300_read_organ
                   USING     c_bwkey   g_s_mbew-bwkey.

      IF sy-subrc IS INITIAL.
*       enrich the entries with the field currency key
        MOVE g_s_organ-waers TO  g_s_mbew-waers.
        APPEND  g_s_mbew     TO  g_t_mbew.

*       create the key table for the material texts
        PERFORM  f9400_material_key
                             USING  g_s_mbew-matnr.
      ENDIF.

*     clear the working areas for the next group
      CLEAR : l_flag_split, l_s_mbew_normal, l_s_mbew_split.
    ENDAT.
  ENDLOOP.

* no entries left in table g_t_mbew ?
  IF  g_t_mbew[] IS INITIAL.
    MESSAGE s120(zpp).
*     Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

ENDFORM.                    " AKTUELLE_BST_BWBST
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_LGBST_MARD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_lgbst_mard .
  SELECT * FROM mard INTO CORRESPONDING FIELDS OF TABLE imard" CONNECTION (dbcon)
                                           WHERE werks IN g_ra_werks
                                           AND   (gv_where_clause) "n_1899544
                                           AND   lgort IN g_ra_lgort
                                           AND   matnr IN matnr.

  IF sy-subrc NE 0.          "no records found ?
    MESSAGE s120(zpp).
*   Kein Material in Selektion vorhanden.
    PERFORM                  anforderungsbild.
  ENDIF.

* does the user has the the authority for the found entries ?
  LOOP AT imard.
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*      PERFORM f9000_auth_plant_check USING imard-werks.       "n_1916359

    PERFORM  f9200_collect_plant     USING  imard-werks.

    PERFORM  f9400_material_key      USING  imard-matnr.

  ENDLOOP.

  DESCRIBE TABLE imard       LINES g_f_cnt_lines.
  IF  g_f_cnt_lines IS INITIAL.       "no records left  ?
    MESSAGE s120(zpp).
*   Kein Material in Selektion vorhanden.
    PERFORM                  anforderungsbild.
  ENDIF.

  IF NOT charg-low IS INITIAL OR NOT charg-high IS INITIAL.
    CLEAR charg.
    MESSAGE w285(db).
*   Charge wird zurückgesetzt.
  ENDIF.

ENDFORM.                    " AKTUELLE_BST_LGBST_MARD
*&---------------------------------------------------------------------*
*&      Form  ANFORDERUNGSBILD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM anforderungsbild . "Salir del programa
  IF NOT sy-calld IS INITIAL.
    LEAVE.
  ELSE.
    LEAVE TO TRANSACTION sy-tcode.
  ENDIF.
ENDFORM.                    " ANFORDERUNGSBILD
*&---------------------------------------------------------------------*
*&      Form  F0000_CREATE_TABLE_G_T_ORGAN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_C_NO_ERROR  text
*----------------------------------------------------------------------*
FORM f0000_create_table_g_t_organ  USING    p_c_no_error.
* at least on of these 3 range tables must be filled for the creation
* of table g_t_organ
* field  description         range table
* -----  -----------         -----------
* werks  plant               g_0000_ra_plant
* bwkey  valuation area      g_0000_ra_bwkey
* bukrs  company code        g_0000_ra_plant

* table g_t_organ must be empty
  CHECK : g_t_organ[] IS INITIAL.

* select all plant from table t001w
  SELECT * FROM t001w        WHERE  werks  IN  g_0000_ra_werks.

*   check the valuation area
    CHECK : t001w-bwkey IN g_0000_ra_bwkey.

*   read the valuation area
    SELECT SINGLE * FROM t001k
                             WHERE  bwkey  =  t001w-bwkey.

    CHECK : sy-subrc IS INITIAL.       "entry found ?

*   company code is required ?
    CHECK : t001k-bukrs IN g_0000_ra_bukrs.

    SELECT SINGLE * FROM t001  WHERE  bukrs  =  t001k-bukrs.

    CHECK : sy-subrc IS INITIAL.       "entry found ?


*    PERFORM  f9000_auth_plant_check    USING  t001w-werks.

*   go on if the user has authority for this plant
*    CHECK : g_flag_authority = 'X'.
* END OF CHANGE for note 1049935

*   create table g_t_organ_lean
    MOVE : t001w-werks       TO  g_s_organ-werks,
           t001w-bwkey       TO  g_s_organ-bwkey,
           t001-bukrs        TO  g_s_organ-bukrs,
           t001-ktopl        TO  g_s_organ-ktopl,
           t001k-bwmod       TO  g_s_organ-bwmod,
           t001-waers        TO  g_s_organ-waers.

*   write 2 entries for the both search methods _
*   1. with key   valuation area
*   2. with key   plant
    MOVE-CORRESPONDING  g_s_organ
                             TO  g_t_organ.
    MOVE : c_bwkey           TO  g_t_organ-keytype,
           g_s_organ-bwkey   TO  g_t_organ-keyfield.
    APPEND                   g_t_organ.

    MOVE : c_werks           TO  g_t_organ-keytype,
         g_s_organ-werks     TO  g_t_organ-keyfield.
    APPEND                   g_t_organ.
    CLEAR                    g_s_organ.

*   create the range tables for plants
    MOVE : t001w-werks       TO  g_ra_werks-low,
           'I'               TO  g_ra_werks-sign,
           'EQ'              TO  g_ra_werks-option.
    APPEND                   g_ra_werks.

*   create the range tables for plants and valuation areas
    MOVE : t001k-bwkey       TO  g_ra_bwkey-low,
           'I'               TO  g_ra_bwkey-sign,
           'EQ'              TO  g_ra_bwkey-option.
    APPEND                   g_ra_bwkey.
  ENDSELECT.

* is table g_t_organ empty ?
  IF  g_t_organ[] IS INITIAL.
*   no plants for selection found / process error message ?
*    IF  l_f_error = c_error.
    MESSAGE e281(m7).
*     Kein Eintrag zur Selektion Buchungskreis Werk Lagerort vorhanden
*    ENDIF.
  ELSE.
    SORT  g_t_organ          BY  keytype  keyfield  bwkey  werks.
    DELETE ADJACENT DUPLICATES FROM g_t_organ.

    SORT                     g_ra_werks.
    DELETE ADJACENT DUPLICATES FROM g_ra_werks.

    SORT                     g_ra_bwkey.
    DELETE ADJACENT DUPLICATES FROM g_ra_bwkey.
  ENDIF.
ENDFORM.                    " F0000_CREATE_TABLE_G_T_ORGAN
*&---------------------------------------------------------------------*
*&      Form  F9200_COLLECT_PLANT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IMARD_WERKS  text
*----------------------------------------------------------------------*
FORM f9200_collect_plant  USING    l_f_werks.
  CHECK : g_t_organ[] IS INITIAL.

* build the range table g_0000_ra_werks
  MOVE : l_f_werks           TO  g_0000_ra_werks-low,
         'I'                 TO  g_0000_ra_werks-sign,
         'EQ'                TO  g_0000_ra_werks-option.
  COLLECT                    g_0000_ra_werks.

ENDFORM.                    " F9200_COLLECT_PLANT
*&---------------------------------------------------------------------*
*&      Form  F9300_READ_ORGAN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_C_BWKEY  text
*      -->P_G_S_MBEW_BWKEY  text
*----------------------------------------------------------------------*
FORM f9300_read_organ  USING     l_f_keytype   LIKE g_s_organ-keytype
                             l_f_keyfield  LIKE g_s_organ-keyfield.

* buffer
  STATICS : l_s_old          TYPE      stype_organ,
            l_9300_subrc     LIKE      sy-subrc.

  IF  l_f_keytype   =  l_s_old-keytype  AND
      l_f_keyfield  =  l_s_old-keyfield.
*   the same key : take the data from the buffer
    MOVE-CORRESPONDING  l_s_old        TO  g_s_organ.
    MOVE  l_9300_subrc                 TO  sy-subrc.
  ELSE.
*   the key has changed : read in table g_t_organ
    READ TABLE g_t_organ     WITH KEY
                             keytype   =  l_f_keytype
                             keyfield  =  l_f_keyfield
                             BINARY SEARCH.

    IF  sy-subrc IS INITIAL.
*     entry found
      MOVE-CORRESPONDING : g_t_organ   TO  g_s_organ,
                           g_t_organ   TO  l_s_old.
      CLEAR                            l_9300_subrc.
    ELSE.
*     entry not found / fill the buffer
      CLEAR : l_s_old,       g_s_organ.
      MOVE  : sy-subrc       TO  l_9300_subrc,
              l_f_keytype    TO  l_s_old-keytype,
              l_f_keyfield   TO  l_s_old-keyfield.
    ENDIF.
  ENDIF.

ENDFORM.                    " F9300_READ_ORGAN
*&---------------------------------------------------------------------*
*&      Form  F9400_MATERIAL_KEY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_G_S_MBEW_MATNR  text
*----------------------------------------------------------------------*
FORM f9400_material_key  USING  l_f_matnr LIKE mara-matnr.

* create key table with material number
  MOVE : l_f_matnr           TO g_t_mat_key-matnr.
  COLLECT                    g_t_mat_key.
ENDFORM.                    " F9400_MATERIAL_KEY
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_SBBST_O
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_sbbst_o .
* process Special Stocks with Vendor
* Bemerkung: Im Gegensatz zu den anderen Sonderbeständen existieren
*            der Lohnbearbeitungs- und Kundenkonsignationsbestand
*            nur auf Werksebene.
*  PERFORM hdb_check_table USING 'MSLB' ''.
*  IF gv_not_authorized = abap_false.
  SELECT * FROM mslb INTO CORRESPONDING FIELDS OF TABLE xmslb" CONNECTION (dbcon)
                             WHERE  werks  IN  g_ra_werks
                               AND  (gv_where_clause)
                             AND  matnr  IN  matnr
                             AND  charg  IN  charg
                             AND  sobkz  =   'O'.
*  ELSE.
*    sy-subrc = 4.
*  ENDIF.

  IF sy-subrc <> 0.                     "no records found ?
*    MESSAGE s289(m7).
    MESSAGE s120(zpp).
*    Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process the found records special stock vendor
  LOOP AT xmslb.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*    PERFORM f9000_auth_plant_check USING xmslb-werks.       "n_1916359

*     fill range table g_0000_ra_werks if it is still empty
    PERFORM  f9200_collect_plant     USING  xmslb-werks.

    PERFORM  f9400_material_key      USING  xmslb-matnr.

  ENDLOOP.

* error, if no records are left
  DESCRIBE TABLE xmslb LINES g_f_cnt_lines.
  IF  g_f_cnt_lines IS INITIAL.
*    MESSAGE s289(m7).
    MESSAGE s120(zpp).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmslb.
  LOOP AT xmslb.
    MOVE-CORRESPONDING xmslb TO imslb.
    COLLECT imslb.
  ENDLOOP.
  FREE xmslb. REFRESH xmslb.

*  IF xchar = ' '.
  LOOP AT imslb.
    MOVE-CORRESPONDING imslb TO imslbx.
    COLLECT imslbx.
  ENDLOOP.
  SORT imslbx.
*  ELSEIF xchar = 'X'.
*    LOOP AT imslb.
*      CHECK imslb-charg IS INITIAL.
*      DELETE imslb.
*    ENDLOOP.
*  ENDIF.
ENDFORM.                    " AKTUELLE_BST_SBBST_O
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_SBBST_V_W
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_sbbst_v_w .
*---------------- Sonderbestand Kundenkonsignation --------------------*
*   elseif sobkz = 'V' or sobkz = 'W'.
*  PERFORM hdb_check_table USING 'MSKU' ''.                  "n1710850
*  IF gv_not_authorized = abap_false.                            "n_1899544
  SELECT * FROM msku INTO CORRESPONDING FIELDS OF TABLE xmsku" CONNECTION (dbcon) "n1710850
                                     WHERE werks IN g_ra_werks
                                     AND   (gv_where_clause) "n_1899544
                                   AND   matnr IN matnr
                                   AND   charg IN charg
                                   AND   sobkz EQ sobkz.
*  ELSE.
*    sy-subrc = 4.
*  ENDIF.

  IF sy-subrc <> 0.          "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process Special Stocks with Customer
  LOOP AT xmsku.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*    PERFORM f9000_auth_plant_check USING xmsku-werks.       "n_1916359

    PERFORM  f9200_collect_plant     USING  xmsku-werks.

    PERFORM  f9400_material_key      USING  xmsku-matnr.

  ENDLOOP.                                                  "^n_1899544

  DESCRIBE TABLE xmsku       LINES  g_f_cnt_lines.
  IF g_f_cnt_lines IS INITIAL.         "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmsku.
  LOOP AT xmsku.
    MOVE-CORRESPONDING xmsku TO imsku.
    COLLECT imsku.
  ENDLOOP.
  FREE xmsku. REFRESH xmsku.

  LOOP AT imsku.
    MOVE-CORRESPONDING imsku TO imskux.
    COLLECT imskux.
  ENDLOOP.
  SORT imskux.


  IF sy-subrc NE 0.
    MESSAGE s042(m7).                                "#EC *    "n443935
*       Charge ist nicht vorhanden.
    PERFORM anforderungsbild.
  ENDIF.
ENDFORM.                    " AKTUELLE_BST_SBBST_V_W
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_SBBST_K_M
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_sbbst_k_m .
*-------------- Sonderbestand Lieferantenkonsignation -----------------*
*   elseif sobkz = 'K' or sobkz = 'M'.

  SELECT * FROM mkol INTO CORRESPONDING FIELDS OF TABLE xmkol" CONNECTION (dbcon) "n1710850
                                    WHERE werks IN g_ra_werks
                                    AND   (gv_where_clause) "n_1899544
                                  AND   lgort IN g_ra_lgort
                                  AND   matnr IN matnr
                                  AND   charg IN charg
                                  AND   sobkz EQ sobkz.
                                                            "n_1899544

  IF sy-subrc <> 0.          "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process Special Stocks from Vendor
  LOOP AT xmkol.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*    PERFORM f9000_auth_plant_check USING xmkol-werks.       "n_1916359

    PERFORM  f9200_collect_plant     USING  xmkol-werks.

    PERFORM  f9400_material_key      USING  xmkol-matnr.

  ENDLOOP.                                                  "^n_1899544

  DESCRIBE TABLE xmkol       LINES  g_f_cnt_lines.
  IF g_f_cnt_lines IS INITIAL.         "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmkol.
  LOOP AT xmkol.
    MOVE-CORRESPONDING xmkol TO imkol.
    COLLECT imkol.
  ENDLOOP.
  FREE xmkol. REFRESH xmkol.


  LOOP AT imkol.
    MOVE-CORRESPONDING imkol TO imkolx.
    COLLECT imkolx.
  ENDLOOP.
  SORT imkolx.

  IF sy-subrc NE 0.
    MESSAGE s042(m7).                                "#EC *    "n443935
*       Charge ist nicht vorhanden.
    PERFORM anforderungsbild.
  ENDIF.
ENDFORM.                    " AKTUELLE_BST_SBBST_K_M
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_SBBST_Q
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_sbbst_q .

*  IF gv_not_authorized = abap_false.                              "n_1899544
  SELECT * FROM mspr INTO CORRESPONDING FIELDS OF TABLE xmspr" CONNECTION (dbcon) "n1710850
                                     WHERE werks IN g_ra_werks
                                     AND   (gv_where_clause) "n_1899544
                                   AND   lgort IN g_ra_lgort
                                   AND   matnr IN matnr
                                   AND   charg IN charg
                                   AND   sobkz EQ sobkz.
*  ELSE.                                                           "n_1899544
*    sy-subrc = 4.                                                 "n_1899544
*  ENDIF.                                                          "n_1899544

  IF sy-subrc <> 0.          "no record found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process project stock
  LOOP AT xmspr.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*    PERFORM f9000_auth_plant_check USING xmspr-werks.       "n_1916359

    PERFORM  f9200_collect_plant     USING  xmspr-werks.

    PERFORM  f9400_material_key      USING  xmspr-matnr.

  ENDLOOP.                                                  "^n_1899544

  DESCRIBE TABLE xmspr       LINES  g_f_cnt_lines.
  IF  g_f_cnt_lines IS INITIAL.        "no record left
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmspr.
  LOOP AT xmspr.
    MOVE-CORRESPONDING xmspr TO imspr.
    COLLECT imspr.
  ENDLOOP.
  FREE xmspr. REFRESH xmspr.

  LOOP AT imspr.
    MOVE-CORRESPONDING imspr TO imsprx.
    COLLECT imsprx.
  ENDLOOP.
  SORT imsprx.

ENDFORM.                    " AKTUELLE_BST_SBBST_Q
*&---------------------------------------------------------------------*
*&      Form  AKTUELLE_BST_SBBST_E
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM aktuelle_bst_sbbst_e .
*---------------------- Kundenauftragsbestand -------------------------*

  SELECT * FROM mska INTO CORRESPONDING FIELDS OF TABLE xmska" CONNECTION (dbcon) "n1710850
                                     WHERE werks IN g_ra_werks
                                     AND   (gv_where_clause) "n_1899544
                                   AND   lgort IN g_ra_lgort
                                   AND   matnr IN matnr
                                   AND   charg IN charg
                                   AND   sobkz EQ sobkz.

  IF sy-subrc <> 0.            "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process Sales Order Stock
  LOOP AT xmska.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB

    PERFORM  f9200_collect_plant     USING  xmska-werks.

    PERFORM  f9400_material_key      USING  xmska-matnr.

  ENDLOOP.                                                  "^n_1899544

  DESCRIBE TABLE xmska       LINES  g_f_cnt_lines.
  IF  g_f_cnt_lines IS INITIAL.        "no records left ?
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmska.
  LOOP AT xmska.
    MOVE-CORRESPONDING xmska TO imska.
    COLLECT imska.
  ENDLOOP.
  FREE xmska. REFRESH xmska.

  LOOP AT imska.
    MOVE-CORRESPONDING imska TO imskax.
    COLLECT imskax.
  ENDLOOP.
  SORT imskax.


ENDFORM.                     "aktuelle_bst_sbbst_e

*----------------------------------------------------------------------*
*    AKTUELLE_BST_SBBST_T
*----------------------------------------------------------------------*

FORM aktuelle_bst_sbbst_t.
*---------------------- Buchungskreisübergreifender Transitbestand ----*

  SELECT * FROM mska INTO CORRESPONDING FIELDS OF TABLE xmska" CONNECTION (dbcon) "n1710850
                                     WHERE werks IN g_ra_werks
                                     AND   (gv_where_clause) "n_1899544
                                   AND   lgort IN g_ra_lgort
                                   AND   matnr IN matnr
                                   AND   charg IN charg
                                   AND   sobkz EQ sobkz.

  IF sy-subrc <> 0.            "no records found
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

* process CTS Stock
  LOOP AT xmska.                                            "vn_1899544
* The following authority check will return true always because only valid records have been fetched from DB
* The check is done only (in combinnation with a check on the not authorized plants in the calling form routine)
* to issue a message that "records have been removed due to missing authority".
* Only for compatibility reasons after code pushdown of authority check to DB
*    PERFORM f9000_auth_plant_check USING xmska-werks.       "n_1916359

    PERFORM  f9200_collect_plant     USING  xmska-werks.

    PERFORM  f9400_material_key      USING  xmska-matnr.

  ENDLOOP.                                                  "^n_1899544

  DESCRIBE TABLE xmska       LINES  g_f_cnt_lines.
  IF  g_f_cnt_lines IS INITIAL.        "no records left ?
    MESSAGE s289(m7).
*   Kein Material in Selektion vorhanden.
    PERFORM anforderungsbild.
  ENDIF.

  SORT xmska.
  LOOP AT xmska.
    MOVE-CORRESPONDING xmska TO imska.
    COLLECT imska.
  ENDLOOP.
  FREE xmska. REFRESH xmska.


  LOOP AT imska.
    MOVE-CORRESPONDING imska TO imskax.
    COLLECT imskax.
  ENDLOOP.
  SORT imskax.


ENDFORM.                     "aktuelle_bst_sbbst_e
*&---------------------------------------------------------------------*
*&      Form  F1100_CHECK_LGORT_SOKZG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f1100_check_lgort_sokzg .
  CLEAR                      g_flag_delete.
*   c) additional checks if valuated stock is required
  IF  bwbst = 'X'.
*     check fields sobkz and kzwbs for valuated stocks
    IF      g_s_mseg_lean-sobkz  =  c_space  OR
            g_s_mseg_lean-sobkz  =  'O'      OR
            g_s_mseg_lean-sobkz  =  'V'      OR
            g_s_mseg_lean-sobkz  =  'W'.                    "n435403
*       OK : special stock indicator = ' ', 'O', 'W' or 'V'
    ELSEIF  g_s_mseg_lean-kzbws = 'A'  OR
            g_s_mseg_lean-kzbws = 'M'.
*       ok : document with valuated special stock
    ELSE.
      MOVE  'X'            TO  g_flag_delete.
    ENDIF.
  ELSE.
*   b) check the combination of special stock indicator and
*      storage location
    IF       g_s_mseg_lean-sobkz = 'O'  OR
             g_s_mseg_lean-sobkz = 'T'  OR                "SIT
             g_s_mseg_lean-sobkz = 'V'  OR
             g_s_mseg_lean-sobkz = 'W'.
*     these entries must not have a storage location
      IF  NOT g_s_mseg_lean-lgort IS INITIAL.
        MOVE  'X'            TO  g_flag_delete.
      ENDIF.
    ELSE.
*     the others entries should have a storage location
      IF  g_s_mseg_lean-lgort IS INITIAL.
        MOVE  'X'            TO  g_flag_delete.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " F1100_CHECK_LGORT_SOKZG
*&---------------------------------------------------------------------*
*&      Form  TABELLEN_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tabellen_lesen .
  IF  NOT g_t_mat_key[] IS INITIAL.                         "n451923

*   select the material masters
*    PERFORM hdb_check_table USING 'MARA' ''.                "n1710850
    SELECT matnr meins mtart FROM mara"  CONNECTION (dbcon)  "n1710850
                   INTO CORRESPONDING FIELDS OF TABLE imara
                   FOR ALL ENTRIES IN g_t_mat_key
                             WHERE  matnr  =  g_t_mat_key-matnr.
*   select the short text for all materials
*   take only the necessary fields                          "n451923
*    PERFORM hdb_check_table USING 'MAKT' ''.                "n1710850
    SELECT matnr maktx       FROM makt" CONNECTION (dbcon)   "n1710850
         INTO CORRESPONDING FIELDS OF TABLE g_t_makt        "n451923
                   FOR ALL ENTRIES IN g_t_mat_key
                   WHERE  matnr = g_t_mat_key-matnr
                     AND  spras = sy-langu.

    SORT  imara              BY  matnr.                     "n451923
    SORT  g_t_makt           BY  matnr.                     "n451923
    FREE                     g_t_mat_key.
  ENDIF.

  DATA: BEGIN OF k1 OCCURS 0,
          mtart LIKE t134m-mtart,
        END OF k1.
  REFRESH k1.

  LOOP AT imara.
    k1-mtart = imara-mtart.
    COLLECT k1.
  ENDLOOP.

  IF  NOT k1[] IS INITIAL.                                  "n451923
    SELECT * FROM t134m                                 "#EC CI_GENBUFF
           INTO CORRESPONDING FIELDS OF TABLE it134m
           FOR ALL ENTRIES IN k1         WHERE mtart = k1-mtart
                                         AND   bwkey IN g_ra_bwkey.
  ENDIF.                                                    "n451923

  LOOP AT it134m.
*   read table organ with key bwkey = it134m-bwkey.
    PERFORM  f9300_read_organ
                   USING     c_bwkey     it134m-bwkey.

    IF sy-subrc NE 0.
      DELETE it134m.
    ENDIF.
  ENDLOOP.

* To find postings with valuation string, but without relevance for
* the valuated stock, Big-G recommended this logic:
* Take lines from MSEG where for the combination BUSTW/XAUTO=XBGBB
* there is an entry in T156W with key BSX.
  SELECT bustw xbgbb FROM t156w
                     INTO CORRESPONDING FIELDS OF TABLE it156w
                     WHERE vorsl = 'BSX'.
  SORT it156w BY bustw xbgbb.
  DELETE ADJACENT DUPLICATES FROM it156w.
  DELETE it156w WHERE bustw = space.
ENDFORM.                    " TABELLEN_LESEN
*&---------------------------------------------------------------------*
*&      Form  BELEGSELEKTION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belegselektion .
* does the user wants the valuated stocks ?
  IF bwbst = 'X'.
*   delete the MM-documents without values
    PERFORM unbewertet_weg.

    IF g_t_mbew[] IS INITIAL.                               "n450764
      MESSAGE s289(m7).
*     Kein Material in Selektion vorhanden.
      PERFORM anforderungsbild.
    ENDIF.

*   select the corresponding FI-documents
    PERFORM                  fi_belege_lesen.
  ENDIF.
*
  IF sbbst IS INITIAL.
    PERFORM                  kontiert_aussortieren.
  ENDIF.
*
  PERFORM                    bewegungsarten_lesen.
*
** does the user want no reversal movements ? only in releases >=45B
*  IF NOT nosto IS INITIAL.
*    PERFORM                  storno.
*  ENDIF.
*
** does the user wants the valuated stocks ?
  IF bwbst = 'X'.
    PERFORM                  belege_ergaenzen.
  ENDIF.
*
  PERFORM                    belege_sortieren.
ENDFORM.                    " BELEGSELEKTION
*&---------------------------------------------------------------------*
*&      Form  FI_BELEGE_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fi_belege_lesen .

* Not related to note 184465, but a significant performance issue
* if ORGAN is large due to many plants/storage locations.
  DATA: BEGIN OF t_bwkey OCCURS 0,                          "184465
          bwkey LIKE bsim-bwkey,                            "184465
        END OF t_bwkey.                                     "184465

  LOOP AT g_t_organ          WHERE  keytype  =  c_bwkey.
    MOVE g_t_organ-bwkey     TO  t_bwkey-bwkey.
    COLLECT t_bwkey.                                        "184465
  ENDLOOP.                                                  "184465

  READ TABLE t_bwkey INDEX 1.                               "184465
  CHECK sy-subrc = 0.                                       "184465

*  PERFORM hdb_check_table USING 'BSIM' ''.                  "n1710850
  SELECT * FROM bsim"  CONNECTION (dbcon)                    "n1710850
         INTO CORRESPONDING FIELDS OF TABLE g_t_bsim_lean   "n443935
           FOR ALL ENTRIES IN t_bwkey   WHERE  bwkey = t_bwkey-bwkey
                                        AND    matnr IN matnr
                                        AND    bwtar IN bwtar
                                        AND    budat >= datum-low.

  LOOP AT g_t_bsim_lean      INTO  g_s_bsim_lean.           "n443935
    PERFORM  f9300_read_organ
                   USING     c_bwkey  g_s_bsim_lean-bwkey.  "n443935

    IF  sy-subrc IS INITIAL.
*     record found : the user has the authority, go on
      MOVE  g_s_organ-bukrs  TO  g_s_bsim_lean-bukrs.       "n443935
      MODIFY  g_t_bsim_lean  FROM  g_s_bsim_lean            "n443935
                             TRANSPORTING  bukrs.           "n451923

*     create working table with the keys for the FI documents
      MOVE-CORRESPONDING  g_s_bsim_lean                     "n443935
                             TO  g_t_bkpf_key.              "n443935
      APPEND                 g_t_bkpf_key.
    ELSE.
      DELETE                 g_t_bsim_lean.                 "n443935
    ENDIF.
  ENDLOOP.

ENDFORM.                    " FI_BELEGE_LESEN
*&---------------------------------------------------------------------*
*&      Form  UNBEWERTET_WEG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM unbewertet_weg .
  SORT  it134m               BY bwkey mtart.                "n451923
                                                            "n450764
* delete the materials in plants without valuation          "n450764
  LOOP AT g_t_mbew           INTO  g_s_mbew.                "n450764
    READ TABLE imara                                        "n450764
                   WITH KEY matnr = g_s_mbew-matnr          "n450764
                   BINARY SEARCH.                           "n450764
                                                            "n450764
    READ TABLE it134m WITH KEY bwkey = g_s_mbew-bwkey       "n450764
                               mtart = imara-mtart BINARY SEARCH.
    IF sy-subrc NE 0.
*     message ...
      DELETE                 g_t_mbew.                      "n450764
    ELSE.
      IF it134m-wertu = ' '.
        DELETE               g_t_mbew.                      "n450764
      ELSE.                                                 "n450764
*       enrich the entries with the quantity unit           "n450764
        MOVE    imara-meins  TO    g_s_mbew-meins.          "n450764

        MODIFY  g_t_mbew     FROM  g_s_mbew                 "n450764
                             TRANSPORTING  meins.           "n450764
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " UNBEWERTET_WEG
*&---------------------------------------------------------------------*
*&      Form  KONTIERT_AUSSORTIEREN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM kontiert_aussortieren .
  DATA : l_f_bwkey LIKE t001k-bwkey.                        "n497992

  SORT  it134m               BY  bwkey  mtart.              "n497992

  LOOP AT g_t_mseg_lean      INTO  g_s_mseg_lean
                             WHERE  kzvbr <> space
                               AND ( kzbew = 'B' OR kzbew = 'F' ).

*   get the valuation area                                  "n497992
    IF  curm = '3'.                                         "n497992
*     valuation level is company code                       "n497992
      IF  g_s_mseg_lean-bukrs IS INITIAL.                   "n497992
*       get the valuation area for this plant               "n497992
        PERFORM  f9300_read_organ                           "n497992
                   USING     c_werks   g_s_mseg_lean-werks. "n497992
                                                            "n497992
        MOVE  g_s_organ-bwkey     TO  l_f_bwkey.            "n497992
      ELSE.                                                 "n497992
        MOVE  g_s_mseg_lean-bukrs TO  l_f_bwkey.            "n497992
      ENDIF.                                                "n497992
    ELSE.                                                   "n497992
*     valuation level is plant                              "n497992
      MOVE  g_s_mseg_lean-werks   TO  l_f_bwkey.            "n497992
    ENDIF.                                                  "n497992

    READ TABLE imara WITH KEY matnr = g_s_mseg_lean-matnr
                             BINARY SEARCH.

    IF  sy-subrc IS INITIAL.
      READ TABLE it134m      WITH KEY  bwkey = l_f_bwkey    "n497992
                                       mtart = imara-mtart  "n497992
                             BINARY SEARCH.

      IF  sy-subrc IS INITIAL.
        IF NOT it134m-mengu IS INITIAL AND
           NOT it134m-wertu IS INITIAL.
          DELETE              g_t_mseg_lean.
        ENDIF.
      ENDIF.
    ELSE.
      DELETE                  g_t_mseg_lean.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " KONTIERT_AUSSORTIEREN
*&---------------------------------------------------------------------*
*&      Form  BEWEGUNGSARTEN_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM bewegungsarten_lesen .
  DATA: BEGIN OF k2 OCCURS 0,
          bwart LIKE t156s-bwart,
        END OF k2.
  REFRESH k2.

* select the movement types from the selected documents
  LOOP AT g_t_mseg_lean      INTO  g_s_mseg_lean.
    MOVE  g_s_mseg_lean-bwart          TO  k2-bwart.
    COLLECT                            k2.
  ENDLOOP.

* Read data for movement type from new tables
* T156SY/C/Q with function module from release >=46B
  DATA: t_st156s LIKE st156s OCCURS 0
                 WITH HEADER LINE.

  REFRESH it156.
  LOOP AT k2.
    REFRESH t_st156s.

    CALL FUNCTION 'MB_CONTROL_MOVETYPE_GET'
      EXPORTING
        i_bwart              = k2-bwart
      TABLES
        te_st156s_tab        = t_st156s
      EXCEPTIONS
        inconsistent_entries = 1
        no_entries_found     = 2
        OTHERS               = 3.

    IF sy-subrc = 0.                                        "311588
      LOOP AT t_st156s.
        MOVE-CORRESPONDING t_st156s TO it156.
        APPEND it156.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

  SORT it156 BY bwart wertu mengu sobkz kzbew kzzug kzvbr.

  SELECT * FROM t156m INTO CORRESPONDING FIELDS OF TABLE it156x
           FOR ALL ENTRIES IN it156  WHERE bustm EQ it156-bustm.

  LOOP AT it156.
    CLEAR it156-lbbsa.
    READ TABLE it156x WITH KEY bustm = it156-bustm.
    it156-lbbsa = it156x-lbbsa.
    MODIFY it156.
  ENDLOOP.

  DATA: rc TYPE i.                                          "147374
  LOOP AT g_t_mseg_lean      INTO  g_s_mseg_lean.
*   find and delete reversal movements / only in releases >= 45B

    READ TABLE it156 WITH KEY bwart = g_s_mseg_lean-bwart
                              wertu = g_s_mseg_lean-wertu
                              mengu = g_s_mseg_lean-mengu
                              sobkz = g_s_mseg_lean-sobkz
                              kzbew = g_s_mseg_lean-kzbew
                              kzzug = g_s_mseg_lean-kzzug
                              kzvbr = g_s_mseg_lean-kzvbr
                             BINARY SEARCH.

    rc = sy-subrc.                                          "147374
    IF  g_s_mseg_lean-bustm = space AND
        g_s_mseg_lean-bustw = space AND
        rc                  = 0.                            "147374
      MOVE : it156-bustm     TO  g_s_mseg_lean-bustm,       "147374
             it156-bustw     TO  g_s_mseg_lean-bustw.       "147374
    ENDIF.

    IF rc = 0.                                              "147374
      MOVE : it156-lbbsa     TO  g_s_mseg_lean-lbbsa.

      IF NOT it156-bwagr IS INITIAL.
        MOVE : it156-bwagr   TO  g_s_mseg_lean-bwagr.
      ELSE.
        MOVE : 'REST'        TO  g_s_mseg_lean-bwagr.
      ENDIF.
    ELSE.
      MOVE : 'REST'          TO  g_s_mseg_lean-bwagr.
    ENDIF.                                                  "147374

    MODIFY  g_t_mseg_lean    FROM  g_s_mseg_lean.
  ENDLOOP.

ENDFORM.                    " BEWEGUNGSARTEN_LESEN
*&---------------------------------------------------------------------*
*&      Form  BELEGE_ERGAENZEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belege_ergaenzen .

* - show the current activity and the progress              "n599218
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'                 "n599218
    EXPORTING                                               "n599218
      text = text-061.       "Reading FI documents          "n599218

* Eliminate material documents with valuation string, but without
* relevance to the valuated stock. IT156W contains all valuation
* strings with posting key BSX. XBGBB says: "I am an accrural posting".
* For more details please ask Big-G.

  LOOP AT g_t_mseg_lean      INTO  g_s_mseg_lean.
*   special processing for tied empties active ?            "n497992
    IF  NOT g_cust_tied_empties IS INITIAL.                 "n497992
*     look for MM documents with xauto = L and change       "n497992
*     indicators                                            "n497992
      CASE  g_s_mseg_lean-xauto.                            "n497992
        WHEN  'X'.                                          "n497992
        WHEN  space.                                        "n497992

        WHEN  OTHERS.                                       "n547170
*         range table g_ra_xauto contains the special       "n547170
*         indicators for the transfer movements of the      "n547170
*         tied empties                                      "n547170
          IF  g_s_mseg_lean-xauto IN g_ra_xauto.            "n547170
            MOVE  g_s_mseg_lean-xauto                       "n497992
                             TO  g_s_mseg_lean-retail.      "n497992
            CLEAR              g_s_mseg_lean-xauto.         "n497992
            MODIFY  g_t_mseg_lean    FROM  g_s_mseg_lean    "n497992
                             TRANSPORTING xauto retail.     "n497992
          ENDIF.                                            "n547170
      ENDCASE.                                              "n497992
    ENDIF.                                                  "n497992

    READ TABLE it156w        WITH KEY
                             bustw = g_s_mseg_lean-bustw
                             xbgbb = g_s_mseg_lean-xauto
                             TRANSPORTING NO FIELDS
                             BINARY SEARCH.
    IF sy-subrc <> 0.
      DELETE                 g_t_mseg_lean.
    ELSE.                                                   "n443935
*     enrich the current entry with the company code        "n443935
      PERFORM f9300_read_organ                              "n443935
                   USING     c_werks  g_s_mseg_lean-werks.  "n443935
                                                            "n443935
      CHECK : sy-subrc IS INITIAL.                          "n443935
      MOVE  g_s_organ-bukrs  TO  g_s_mseg_lean-bukrs.       "n443935
      MODIFY  g_t_mseg_lean  FROM  g_s_mseg_lean            "n443935
                             TRANSPORTING  bukrs.           "n451923
    ENDIF.
  ENDLOOP.

* For all available FI documents from BSIM, read the header data
* from BKPF to get the link to the originating material document.

  IF  NOT g_t_bkpf_key[] IS INITIAL.
*   look for the header of the matching FI documents

    SORT  g_t_bkpf_key       BY  bukrs belnr gjahr.
    DELETE ADJACENT DUPLICATES FROM g_t_bkpf_key.

*   save result from database selection into global hashed  "n856424
*   table g_t_bkpf                                          "n856424
*    PERFORM hdb_check_table USING 'BKPF' ''.                "n1710850
    SELECT  *                 FROM bkpf "CONNECTION (dbcon)  "n1710850
      INTO CORRESPONDING FIELDS OF TABLE g_t_bkpf           "n856424
           FOR ALL ENTRIES IN g_t_bkpf_key
                   WHERE  bukrs = g_t_bkpf_key-bukrs
                     AND  belnr = g_t_bkpf_key-belnr
                     AND  gjahr = g_t_bkpf_key-gjahr.

    IF  sy-subrc IS INITIAL.
*     create working table l_t_keytab_m
      FREE                   g_t_bkpf_key.

      LOOP AT g_t_bsim_lean  INTO  g_s_bsim_lean.           "n443935
*       enrich the working table g_t_bsim_lean with the     "n443935
*       MM doc info                                         "n443935
                                                            "n443935
*       look for the matching FI document header            "n443935
        READ TABLE g_t_bkpf  ASSIGNING <g_fs_bkpf>          "n856424
                   WITH KEY  bukrs = g_s_bsim_lean-bukrs    "n443935
                             belnr = g_s_bsim_lean-belnr    "n443935
                             gjahr = g_s_bsim_lean-gjahr.   "n443935
                                                            "n443935
        IF  sy-subrc IS INITIAL.                            "n443935
*         enrich table G_T_BSIM_LEAN with the MM doc        "n443935

*         consider only FI docs created by MM docs here     "n856424
          CHECK : <g_fs_bkpf>-awtyp = 'MKPF'.               "n856424
          MOVE  <g_fs_bkpf>-awkey TO  g_s_bsim_lean-awkey.  "n856424

          MODIFY  g_t_bsim_lean   FROM  g_s_bsim_lean       "n443935
                                  TRANSPORTING  awkey.      "n451923
        ENDIF.                                              "n443935
      ENDLOOP.                                              "n443935
                                                            "n443935
      BREAK-POINT                ID mmim_rep_mb5b.          "n921164
*     dynamic break-point : G_T_BSIM_LEAN is available     "n921164
                                                            "n443935
*     sort working table for acces with MM document         "n443935
      SORT  g_t_bsim_lean    BY  bukrs                      "n443935
                                 bwkey                      "n443935
                                 matnr                      "n443935
                                 bwtar                      "n443935
                                 shkzg                      "n443935
                                 meins                      "n443935
                                 budat                      "n443935
                                 blart                      "n443935
                                 awkey.                     "n443935
    ENDIF.
  ENDIF.

* For each material document, write the number of the created
* FI document into IMSEG. If there are more than one FI document,
* the one with the same BLART and the same posting date is chosen.
* BLART alone is not sufficient as the document type of the
* revaluation document is customizeable (T158-BLAUM).
* If a document as been found to have an entry in KEYTAB, this
* entry is marked as "accessed". So later on the FI document is
* known to be already in the list via this material document.

* clear the working areas                                   "n443935
  PERFORM                    belege_ergaenzen_clear.        "n443935
                                                            "n443935
* sort main table with MM document                          "n443935
  SORT  g_t_mseg_lean        BY  bukrs                      "n443935
                                 werks                      "n443935
                                 matnr                      "n443935
                                 bwtar                      "n443935
                                 shkzg                      "n443935
                                 meins                      "n443935
                                 budat                      "n443935
                                 blart                      "n443935
                                 mblnr                      "n443935
                                 mjahr.                     "n443935
                                                            "n443935
* process the table with the MM docs with control break     "n443935
* the sequential reading is done in a DO-Loop, because      "n451923
* the MODIFY does not refer the current entry               "n451923
  CLEAR                      g_cnt_loop.                    "n451923
                                                            "n451923
  DO.                                                       "n451923
    ADD  1                   TO  g_cnt_loop.                "n443935
                                                            "n451923
    READ TABLE g_t_mseg_lean INTO  g_s_mseg_lean            "n451923
                             INDEX  g_cnt_loop.             "n451923
                                                            "n451923
    IF  sy-subrc <> 0.       "end of table reached ?        "n443935
      EXIT.                                                 "n443935
    ENDIF.                                                  "n443935
                                                            "n443935
*   fill group key                                          "n443935
    MOVE-CORRESPONDING  g_s_mseg_lean                       "n443935
                             TO  g_s_mseg_new.              "n443935
                                                            "n443935
*   valuation area depends on the customizing settings      "n443935
    IF curm = '3'.                                          "n443935
*     the valuation level is company code                   "n443935
      MOVE : g_s_mseg_lean-bukrs                            "n443935
                             TO  g_s_mseg_new-bwkey.        "n443935
    ELSE.                                                   "n443935
*     the valuation level is plant                          "n443935
      MOVE : g_s_mseg_lean-werks                            "n443935
                             TO  g_s_mseg_new-bwkey.        "n443935
    ENDIF.                                                  "n443935
                                                            "n443935
*   control break                                           "n443935
    IF  g_cnt_loop > 1.                                     "n443935
      IF  g_s_mseg_new NE g_s_mseg_old.                     "n443935
        PERFORM              belege_ergaenzen_2.            "n443935
      ENDIF.                                                "n443935
    ENDIF.                                                  "n443935
                                                            "n443935
*   save the entry in the working table for this group      "n443935
    ADD  1                   TO  g_cnt_mseg_entries.        "n443935
    MOVE-CORRESPONDING  g_s_mseg_new                        "n443935
                             TO  g_s_mseg_old.              "n443935
    MOVE-CORRESPONDING  g_s_mseg_lean                       "n451923
                             TO  g_s_mseg_work.             "n451923
    MOVE  g_cnt_loop         TO  g_s_mseg_work-tabix.       "n451923
    APPEND  g_s_mseg_work    TO  g_t_mseg_work.             "n443935
  ENDDO.                                                    "n451923
                                                            "n443935
* process the last group                                    "n443935
  PERFORM                    belege_ergaenzen_2.            "n443935
                                                            "n443935
* Append FI-documents without material documents (price change,
* invoice, revaluation document, ...).

  BREAK-POINT                ID mmim_rep_mb5b.              "n921164
* dynamic break-point : process remaining FI docs          "n921164
                                                            "n443935
* process the remaining FI documents                        "n443935
  LOOP AT g_t_bsim_lean      INTO  g_s_bsim_lean.           "n443935
    CLEAR                    g_s_mseg_lean.                 "n443935
                                                            "n443935
    CASE    g_s_bsim_lean-accessed.                         "n443935
      WHEN  'D'.                                            "n443935
*       this FI could be assigned to a MM doc successfully  "n443935
        CONTINUE.            "-> ignore this entry          "n443935
                                                            "n443935
      WHEN  'X'.                                            "n443935
*       take this entry; but there could be inconsistencies "n443935
*       between the MM and FI documents and set '???' to    "n443935
*       movement type in the list                           "n443935
        MOVE  '???'          TO  g_s_mseg_lean-bwart.       "n443935
                                                            "n443935
      WHEN  OTHERS.                                         "n443935
    ENDCASE.                                                "n443935
                                                            "n443935

*   customizing for the selection of remaining BSIM entries "n497992
*   ( FI document ) without matching MSEG ( MM document )   "n497992
*   like price changes, account adjustments, etc...         "n497992

*    IF  g_flag_break-b4 = 'X'.                              "n921164
*      BREAK-POINT                ID mmim_rep_mb5b.          "n921164
**     dynamic break-point : stop here when strange          "n921164
**     FI documents are shown                                "n921164
*    ENDIF.                                                  "n921164

    IF NOT g_cust_bseg_bsx IS INITIAL.                      "n497992
      DATA l_s_ktosl LIKE bseg-ktosl.                       "n497992
                                                            "n497992
*     look for the matching BSEG entry                      "n497992
      SELECT SINGLE ktosl    FROM bseg                      "n497992
                             INTO l_s_ktosl                 "n497992
         WHERE  bukrs  =  g_s_bsim_lean-bukrs               "n497992
           AND  belnr  =  g_s_bsim_lean-belnr               "n497992
           AND  gjahr  =  g_s_bsim_lean-gjahr               "n497992
           AND  buzei  =  g_s_bsim_lean-buzei.              "n497992
                                                            "n497992
      IF  sy-subrc IS INITIAL.                              "n497992
        IF l_s_ktosl  =  'BSX'.                             "n497992
*         ok: entry found; transaction key is BSX           "n497992
        ELSE.                                               "n497992
          CONTINUE.          "Do not process this entry     "n497992
        ENDIF.                                              "n497992
      ENDIF.                                                "n497992
    ENDIF.                                                  "n497992

*   create a entry in the main working table G_T_MSEG_LEAN  "n443935
*   for this remaining FI document, delete the quantity,    "n443935
*   and set the info of the original MM doc                 "n443935
    MOVE-CORRESPONDING  g_s_bsim_lean                       "n443935
                             TO  g_s_mseg_lean.             "n443935
    CLEAR                    g_s_mseg_lean-menge.           "n443935
    MOVE : g_s_bsim_lean-awkey                              "n443935
                             TO  matkey,                    "n443935
           matkey-mblnr      TO  g_s_mseg_lean-mblnr,       "n443935
           matkey-mjahr      TO  g_s_mseg_lean-mjahr.       "n443935
                                                            "n443935
    PERFORM  f9300_read_organ                               "n443935
                   USING     c_bwkey  g_s_bsim_lean-bwkey.  "n443935
                                                            "n443935
    MOVE : g_s_organ-werks   TO  g_s_mseg_lean-werks,       "n443935
           g_s_organ-waers   TO  g_s_mseg_lean-waers.       "n443935

*   complete this line with CPU-date, CPU-time and user     "n856424
*   read FI doc header in working table G_T_BKPF            "n856424
    READ TABLE g_t_bkpf      ASSIGNING <g_fs_bkpf>          "n856424
      WITH KEY bukrs  =  g_s_bsim_lean-bukrs                "n856424
               belnr  =  g_s_bsim_lean-belnr                "n856424
               gjahr  =  g_s_bsim_lean-gjahr.               "n856424
                                                            "n856424
    IF sy-subrc IS INITIAL.                                 "n856424
      MOVE : <g_fs_bkpf>-cpudt    TO  g_s_mseg_lean-cpudt,  "n856424
             <g_fs_bkpf>-cputm    TO  g_s_mseg_lean-cputm,  "n856424
             <g_fs_bkpf>-usnam    TO  g_s_mseg_lean-usnam.  "n856424
    ENDIF.                                                  "n856424

    IF gv_switch_ehp6ru = abap_true.
      MOVE-CORRESPONDING g_s_bsim_lean TO g_t_bseg_key.
      APPEND  g_t_bseg_key.
    ENDIF.

    APPEND  g_s_mseg_lean    TO  g_t_mseg_lean.             "n443935
  ENDLOOP.                                                  "n443935
                                                            "n443935
  FREE :                     g_t_bsim_lean.                 "n443935
  FREE :                     g_t_bkpf.                      "n856424

  FIELD-SYMBOLS:
    <fs_mseg_lean> TYPE stype_mseg_lean,
    <fs_bseg>      TYPE stype_bseg.

  DATA:
    ls_accdet TYPE stype_accdet.

* add G/L account data to G_T_MSEG_LEAN
* (if available - from FI doc item, if not - from current settings)
  IF gv_switch_ehp6ru = abap_true.
    SORT g_t_bseg_key BY bukrs belnr gjahr buzei.
    DELETE ADJACENT DUPLICATES FROM g_t_bseg_key.

*   save result from database selection into hashed table
    IF NOT g_t_bseg_key[] IS INITIAL.
      SELECT bukrs belnr gjahr buzei hkont FROM bseg
        INTO CORRESPONDING FIELDS OF TABLE g_t_bseg
        FOR ALL ENTRIES IN g_t_bseg_key
          WHERE bukrs = g_t_bseg_key-bukrs
            AND belnr = g_t_bseg_key-belnr
            AND gjahr = g_t_bseg_key-gjahr
            AND buzei = g_t_bseg_key-buzei
        ORDER BY PRIMARY KEY.
    ENDIF.

    LOOP AT g_t_mseg_lean ASSIGNING <fs_mseg_lean>.
*     look for the matching FI document item
      READ TABLE g_t_bseg ASSIGNING <fs_bseg>
        WITH KEY bukrs = <fs_mseg_lean>-bukrs
                 belnr = <fs_mseg_lean>-belnr
                 gjahr = <fs_mseg_lean>-gjahr
                 buzei = <fs_mseg_lean>-buzei.
      IF  sy-subrc IS INITIAL.
*       enrich table G_T_MSEG_LEAN with the G/L account
        <fs_mseg_lean>-hkont = <fs_bseg>-hkont.
      ELSE.
*       get G/L account from current account determination settings
        CLEAR ls_accdet.
        MOVE-CORRESPONDING <fs_mseg_lean> TO ls_accdet.
        PERFORM get_acc_det CHANGING ls_accdet.
        <fs_mseg_lean>-hkont = ls_accdet-hkont.
      ENDIF.
    ENDLOOP.
    FREE: g_t_bseg_key, g_t_bseg.
  ENDIF.

** filter documents by G/L account, in case G/L account is restricted
*  IF gv_switch_ehp6ru = abap_true AND hkont IS NOT INITIAL.
*    DELETE g_t_mseg_lean WHERE hkont NOT IN hkont.
**   leave program if no records left
*    IF g_t_mseg_lean IS INITIAL.
*      MESSAGE s289.
*      PERFORM anforderungsbild.
*    ENDIF.
*  ENDIF.

ENDFORM.                    " BELEGE_ERGAENZEN
*&---------------------------------------------------------------------*
*&      Form  BELEGE_ERGAENZEN_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belege_ergaenzen_2 .
  MOVE : g_s_mseg_old-mblnr  TO  matkey-mblnr,              "n443935
           g_s_mseg_old-mjahr  TO  matkey-mjahr.            "n443935
                                                            "n443935
  READ  TABLE g_t_bsim_lean  INTO  g_s_bsim_lean            "n443935
                   WITH KEY  bukrs  =  g_s_mseg_old-bukrs   "n443935
                             bwkey  =  g_s_mseg_old-bwkey   "n443935
                             matnr  =  g_s_mseg_old-matnr   "n443935
                             bwtar  =  g_s_mseg_old-bwtar   "n443935
                             shkzg  =  g_s_mseg_old-shkzg   "n443935
                             meins  =  g_s_mseg_old-meins   "n443935
                             budat  =  g_s_mseg_old-budat   "n443935
                             blart  =  g_s_mseg_old-blart   "n443935
                             awkey  =  matkey               "n443935
                             BINARY SEARCH.                 "n443935
                                                            "n443935
  IF sy-subrc IS INITIAL.                                   "n443935
    MOVE  sy-tabix           TO  g_f_tabix_start.           "n443935
                                                            "n443935
*   continue with sequential read of working table          "n443935
    LOOP AT g_t_bsim_lean    INTO  g_s_bsim_lean            "n443935
                             FROM  g_f_tabix_start.         "n443935
                                                            "n443935
      IF  g_s_bsim_lean-bukrs  =  g_s_mseg_old-bukrs  AND   "n443935
          g_s_bsim_lean-bwkey  =  g_s_mseg_old-bwkey  AND   "n443935
          g_s_bsim_lean-matnr  =  g_s_mseg_old-matnr  AND   "n443935
          g_s_bsim_lean-bwtar  =  g_s_mseg_old-bwtar  AND   "n443935
          g_s_bsim_lean-shkzg  =  g_s_mseg_old-shkzg  AND   "n443935
          g_s_bsim_lean-meins  =  g_s_mseg_old-meins  AND   "n443935
          g_s_bsim_lean-budat  =  g_s_mseg_old-budat  AND   "n443935
          g_s_bsim_lean-blart  =  g_s_mseg_old-blart  AND   "n443935
          g_s_bsim_lean-awkey  =  matkey.                   "n443935
*       select all matching entries                         "n443935
        ADD   1              TO  g_cnt_bsim_entries.        "n443935
        MOVE-CORRESPONDING  g_s_bsim_lean                   "n443935
                             TO  g_s_bsim_work.             "n443935
        MOVE  sy-tabix       TO  g_s_bsim_work-tabix.       "n443935
        APPEND g_s_bsim_work TO  g_t_bsim_work.             "n443935
      ELSE.                                                 "n443935
        EXIT.                                               "n443935
      ENDIF.                                                "n443935
    ENDLOOP.                                                "n443935
  ENDIF.                                                    "n443935


* how many matching entries from BSIM found ?               "n443935
  IF      g_cnt_bsim_entries IS INITIAL.                    "n443935
*   no BSIM entries found -> no action.                     "n443935
                                                            "n443935
  ELSEIF  g_cnt_bsim_entries = 1  AND                       "n443935
          g_cnt_mseg_entries = 1.                           "n443935
*   the ideal case 1 MM and 1 FI document;                  "n443935
*   mark this FI doc for deletion                           "n443935
    LOOP AT g_t_bsim_work    INTO  g_s_bsim_work.           "n443935
      READ  TABLE  g_t_bsim_lean  INTO  g_s_bsim_lean       "n443935
                             INDEX  g_s_bsim_work-tabix.    "n443935
                                                            "n443935
      CHECK : sy-subrc IS INITIAL.                          "n443935
      MOVE  : 'D'            TO  g_s_bsim_lean-accessed.    "n443935
      MODIFY  g_t_bsim_lean  FROM  g_s_bsim_lean            "n443935
                             INDEX  g_s_bsim_work-tabix     "n443935
                             TRANSPORTING  accessed.        "n451923
                                                            "n443935
*     set the FI doc number into the entry of the MM doc    "n443935
      READ  TABLE  g_t_mseg_work  INTO  g_s_mseg_work       "n443935
                             INDEX  1.                      "n443935
      CHECK : sy-subrc IS INITIAL.                          "n443935
                                                            "n443935
      MOVE : g_s_bsim_work-belnr                            "n443935
                             TO  g_s_mseg_work-belnr,       "n443935
             g_s_bsim_work-gjahr                            "n443935
                             TO  g_s_mseg_work-gjahr.       "n443935
      IF gv_switch_ehp6ru = abap_true.
        MOVE: g_s_bsim_work-buzei
                             TO  g_s_mseg_work-buzei.
        MOVE-CORRESPONDING g_s_bsim_work TO g_t_bseg_key.
        APPEND g_t_bseg_key.
      ENDIF.

*     consider special gain/loss-handling of IS-OIL         "n497992
**# IF EXIST OI001
**"    if  g_s_mseg_work-oiglcalc = 'L'  and            "n497992
**"        g_s_mseg_work-shkzg    = 'H'  and            "n497992
**"        g_s_mseg_work-dmbtr    = 0.                  "n497992
**"      move  g_s_bsim_work-dmbtr                      "n497992
**"                  to  g_s_mseg_work-dmbtr.           "n497992
**"    endif.                                           "n497992
**"                                                     "n497992
**"    MODIFY G_T_MSEG_work                             "n497992
**"                 FROM  G_S_MSEG_work                 "n497992
**"                 INDEX  1                            "n497992
**"                 TRANSPORTING BELNR GJAHR dmbtr.     "n497992
**# ELSE
*      MODIFY G_T_MSEG_work  FROM  G_S_MSEG_work        "n443935
*                            INDEX  1                   "n443935
*                            TRANSPORTING  BELNR GJAHR. "n443935
**# ENDIF

      MODIFY g_t_mseg_work  FROM  g_s_mseg_work             "n599218 A
                          INDEX  1                          "n599218 A
                          TRANSPORTING  belnr gjahr buzei.
                                                            "n599218 A

    ENDLOOP.                                                "n443935
                                                            "n443935
  ELSE.                                                     "n443935
*   there are a lot of MM docs                              "n443935
    PERFORM                  belege_ergaenzen_several_docs. "n443935
                                                            "n443935
  ENDIF.                                                    "n443935
                                                            "n443935
* copy the number and fiscal year into the matching         "n451923
* entry of the main table G_T_MSEG_LEAN                     "n451923
  LOOP AT g_t_mseg_work      INTO  g_s_mseg_work.           "n451923
*   only with useful FI doc data                            "n451923
    CHECK : NOT g_s_mseg_work-belnr IS INITIAL.             "n451923
                                                            "n443935
*   read the original entry and change it                   "n451923
    READ TABLE g_t_mseg_lean INTO  g_s_mseg_update          "n451923
                             INDEX g_s_mseg_work-tabix.     "n451923
                                                            "n443935
    CHECK : sy-subrc IS INITIAL.   "entry found ?           "n451923
    MOVE  : g_s_mseg_work-belnr                             "n451923
                             TO  g_s_mseg_update-belnr,     "n451923
            g_s_mseg_work-gjahr                             "n451923
                             TO  g_s_mseg_update-gjahr.     "n451923
    IF gv_switch_ehp6ru = abap_true.
      MOVE: g_s_mseg_work-buzei
                             TO  g_s_mseg_update-buzei.
      MOVE-CORRESPONDING g_s_mseg_work TO g_t_bseg_key.
      APPEND g_t_bseg_key.
    ENDIF.

*   consider special gain/loss-handling of IS-OIL           "n497992
**# IF EXIST OI001
**"  move  g_s_mseg_work-dmbtr                          "n497992
**"                 to  g_s_mseg_update-dmbtr.          "n497992
**"                                                     "n497992
**"  MODIFY G_T_MSEG_lean                               "n497992
**"                 FROM  G_S_MSEG_update               "n497992
**"                 index g_s_mseg_work-tabix           "n497992
**"                 TRANSPORTING BELNR GJAHR dmbtr.     "n497992
**# ELSE
*    modify  g_t_mseg_lean  from  g_s_mseg_update       "n451923
*                           index g_s_mseg_work-tabix   "n451923
*                           transporting  belnr gjahr.  "n451923
**# ENDIF
*   IS-OIL specific functions without ABAP preprocessor     "n599218 A
                                                            "n599218 A
    MODIFY g_t_mseg_lean FROM  g_s_mseg_update              "n599218 A
                         INDEX g_s_mseg_work-tabix          "n599218 A
                         TRANSPORTING  belnr gjahr buzei.

  ENDLOOP.                                                  "n451923

  PERFORM                    belege_ergaenzen_clear.        "n443935
ENDFORM.                    " BELEGE_ERGAENZEN_2
*&---------------------------------------------------------------------*
*&      Form  BELEGE_ERGAENZEN_CLEAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belege_ergaenzen_clear .
* clear working areas for the next group                    "n443935
  REFRESH : g_t_bsim_work,   g_t_mseg_work.                 "n443935
  CLEAR   : g_cnt_mseg_entries, g_cnt_mseg_done,            "n443935
            g_cnt_bsim_entries.                             "n443935
                                                            "n443935
ENDFORM.                    " BELEGE_ERGAENZEN_CLEAR
*&---------------------------------------------------------------------*
*&      Form  BELEGE_ERGAENZEN_SEVERAL_DOCS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belege_ergaenzen_several_docs .
                                                            "n443935
* first step : the entries must hit quantity and value      "n443935
  LOOP AT g_t_mseg_work    INTO  g_s_mseg_work.             "n443935
                                                            "n443935
*   look for a matching FI doc                              "n443935
    LOOP AT g_t_bsim_work  INTO  g_s_bsim_work.             "n443935
*     ingnore the entries for deletion                      "n443935
      CHECK : g_s_bsim_work-accessed NE 'D'.                "n443935
                                                            "n443935
      IF  g_s_bsim_work-menge = g_s_mseg_work-menge  AND    "n443935
          g_s_bsim_work-dmbtr = g_s_mseg_work-dmbtr.        "n443935
*       mark the entries                                    "n443935
        ADD  1               TO  g_cnt_mseg_done.           "n443935
        MOVE : g_s_bsim_work-belnr                          "n443935
                             TO  g_s_mseg_work-belnr,       "n443935
               g_s_bsim_work-gjahr                          "n443935
                             TO  g_s_mseg_work-gjahr.       "n443935
        IF gv_switch_ehp6ru = abap_true.
          MOVE: g_s_bsim_work-buzei
                             TO  g_s_mseg_work-buzei.
          MOVE-CORRESPONDING g_s_bsim_work TO g_t_bseg_key.
          APPEND g_t_bseg_key.
        ENDIF.

        MODIFY g_t_mseg_work  FROM  g_s_mseg_work           "n443935
                             TRANSPORTING  belnr gjahr buzei.
                                                            "n443935
*       mark the entries for deletion                       "n443935
        MOVE    'D'          TO  g_s_bsim_work-accessed.    "n443935
        MODIFY  g_t_bsim_work  FROM  g_s_bsim_work          "n443935
                             TRANSPORTING  accessed.        "n451923
        EXIT.                "Stop at the firts hit         "n443935
      ENDIF.                                                "n443935
    ENDLOOP.                                                "n443935
  ENDLOOP.                                                  "n443935
                                                            "n921164

  IF  g_cnt_mseg_entries  NE g_cnt_mseg_done.               "n443935
*   there are MM docs without FI doc left                   "n443935
                                                            "n443935
*     subtract the quantity and value from MM doc from      "n443935
*     the fields of the FI doc                              "n443935
    LOOP AT g_t_mseg_work  INTO  g_s_mseg_work.             "n443935
                                                            "n443935
*       take only the entries without FI doc number         "n443935
      CHECK : g_s_mseg_work-belnr IS INITIAL.               "n443935
                                                            "n443935
      LOOP AT g_t_bsim_work  INTO  g_s_bsim_work.           "n443935
*         ingnore the entries for deletion                  "n443935
        CHECK : g_s_bsim_work-accessed NE 'D'.              "n443935
                                                            "n443935
        IF g_s_bsim_work-menge GE g_s_mseg_work-menge AND   "n443935
           g_s_bsim_work-dmbtr GE g_s_mseg_work-dmbtr.      "n443935
                                                            "n443935
          SUBTRACT :                                        "n443935
            g_s_mseg_work-menge FROM  g_s_bsim_work-menge,  "n443935
            g_s_mseg_work-dmbtr FROM  g_s_bsim_work-dmbtr.  "n443935
                                                            "n443935
          IF  g_s_bsim_work-menge  IS INITIAL  AND          "n443935
              g_s_bsim_work-dmbtr  IS INITIAL.              "n443935
*           mark the entry for deletion                     "n443935
            MOVE    'D'      TO  g_s_bsim_work-accessed.    "n443935
          ELSE.                                             "n443935
*           set the flag for check the merge process        "n443935
            MOVE    'X'      TO  g_s_bsim_work-accessed.    "n443935
          ENDIF.                                            "n443935
                                                            "n443935
          MODIFY  g_t_bsim_work  FROM  g_s_bsim_work        "n443935
*           change quantity and value in working table, too  "n747306
            TRANSPORTING  accessed menge dmbtr.             "n747306
                                                            "n443935
*         mark the entries                                  "n443935
          ADD  1             TO  g_cnt_mseg_done.           "n443935
          MOVE : g_s_bsim_work-belnr                        "n443935
                             TO  g_s_mseg_work-belnr,       "n443935
                 g_s_bsim_work-gjahr                        "n443935
                             TO  g_s_mseg_work-gjahr.       "n443935
          IF gv_switch_ehp6ru = abap_true.
            MOVE: g_s_bsim_work-buzei
                             TO  g_s_mseg_work-buzei.
            MOVE-CORRESPONDING g_s_bsim_work TO g_t_bseg_key.
            APPEND g_t_bseg_key.
          ENDIF.

          MODIFY g_t_mseg_work  FROM  g_s_mseg_work         "n443935
                             TRANSPORTING  belnr gjahr buzei.
          EXIT.              "Stop at the first hit         "n443935
        ENDIF.                                              "n443935
      ENDLOOP.                                              "n443935
    ENDLOOP.                                                "n443935
  ENDIF.                                                    "n443935
                                                            "n443935
* mark the processed FI docs for deletion                   "n443935
  LOOP AT g_t_bsim_work    INTO  g_s_bsim_work.             "n443935
    CHECK   g_s_bsim_work-accessed = 'D'.                   "n443935
                                                            "n443935
    READ  TABLE  g_t_bsim_lean  INTO  g_s_bsim_lean         "n443935
                             INDEX  g_s_bsim_work-tabix.    "n443935
                                                            "n443935
    CHECK : sy-subrc IS INITIAL.                            "n443935
    MOVE  : 'D'              TO  g_s_bsim_lean-accessed.    "n443935
    MODIFY  g_t_bsim_lean    FROM   g_s_bsim_lean           "n443935
                             INDEX  g_s_bsim_work-tabix     "n443935
                             TRANSPORTING  accessed.        "n451923
  ENDLOOP.                                                  "n443935
                                                            "n443935

ENDFORM.                    " BELEGE_ERGAENZEN_SEVERAL_DOCS
*&---------------------------------------------------------------------*
*&      Form  BELEGE_SORTIEREN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM belege_sortieren .
  aktdat = sy-datlo + 30.
  IF NOT ( datum-high IS INITIAL OR datum-high > aktdat ).
    LOOP AT g_t_mseg_lean    INTO  g_s_mseg_lean
                             WHERE budat > datum-high.
      MOVE-CORRESPONDING g_s_mseg_lean TO imsweg.
      APPEND imsweg.
      DELETE                 g_t_mseg_lean.
    ENDLOOP.
  ENDIF.

  DESCRIBE TABLE imsweg LINES index_2.
ENDFORM.                    " BELEGE_SORTIEREN
*&---------------------------------------------------------------------*
*&      Form  GET_BKLAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_CS_ACCDET  text
*----------------------------------------------------------------------*
FORM get_bklas  CHANGING cs_accdet  TYPE stype_accdet.

  TYPES:
    BEGIN OF ltt_bklas,
      matnr     LIKE mbew-matnr,
      bwkey     LIKE mbew-bwkey,
      bwtar     LIKE mbew-bwtar,
      sobkz     LIKE qbew-sobkz,
      mat_pspnr LIKE qbew-pspnr,
      mat_kdauf LIKE ebew-vbeln,
      mat_kdpos LIKE ebew-posnr,
      lifnr     LIKE obew-lifnr,
      bklas     LIKE mbew-bklas,
    END OF ltt_bklas.

  STATICS:
    lt_bklas TYPE HASHED TABLE OF ltt_bklas WITH UNIQUE KEY matnr bwkey
      bwtar sobkz mat_pspnr mat_kdauf mat_kdpos lifnr.
  DATA:
    ls_bklas TYPE ltt_bklas.

  READ TABLE lt_bklas INTO ls_bklas
    WITH TABLE KEY matnr     = cs_accdet-matnr
                   bwkey     = cs_accdet-bwkey
                   bwtar     = cs_accdet-bwtar
                   sobkz     = cs_accdet-sobkz
                   mat_pspnr = cs_accdet-mat_pspnr
                   mat_kdauf = cs_accdet-mat_kdauf
                   mat_kdpos = cs_accdet-mat_kdpos
                   lifnr     = cs_accdet-lifnr.
  IF sy-subrc = 0.
    cs_accdet-bklas = ls_bklas-bklas.
  ELSE.
    CASE cs_accdet-sobkz.
      WHEN 'Q'.
*        PERFORM hdb_check_table USING 'QBEW' ''.            "n1710850
        SELECT SINGLE bklas FROM qbew" CONNECTION (dbcon)    "n1710850
          INTO cs_accdet-bklas
          WHERE matnr = cs_accdet-matnr
            AND bwkey = cs_accdet-bwkey
            AND bwtar = cs_accdet-bwtar
            AND sobkz = cs_accdet-sobkz
            AND pspnr = cs_accdet-mat_pspnr.
      WHEN 'E'.
*        PERFORM hdb_check_table USING 'EBEW' ''.            "n1710850
        SELECT SINGLE bklas FROM ebew" CONNECTION (dbcon)    "n1710850
          INTO cs_accdet-bklas
          WHERE matnr = cs_accdet-matnr
            AND bwkey = cs_accdet-bwkey
            AND bwtar = cs_accdet-bwtar
            AND sobkz = cs_accdet-sobkz
            AND vbeln = cs_accdet-mat_kdauf
            AND posnr = cs_accdet-mat_kdpos.
      WHEN 'O'.
*        PERFORM hdb_check_table USING 'OBEW' ''.            "n1710850
        SELECT SINGLE bklas FROM obew" CONNECTION (dbcon)    "n1710850
          INTO cs_accdet-bklas
          WHERE matnr = cs_accdet-matnr
            AND bwkey = cs_accdet-bwkey
            AND bwtar = cs_accdet-bwtar
            AND sobkz = cs_accdet-sobkz
            AND lifnr = cs_accdet-lifnr.
      WHEN OTHERS.
*        PERFORM hdb_check_table USING 'MBEW' ''.            "n1710850
        SELECT SINGLE bklas FROM mbew" CONNECTION (dbcon)    "n1710850
          INTO cs_accdet-bklas
          WHERE matnr = cs_accdet-matnr
            AND bwkey = cs_accdet-bwkey
            AND bwtar = cs_accdet-bwtar.
    ENDCASE.
    ls_bklas-matnr     = cs_accdet-matnr.
    ls_bklas-bwkey     = cs_accdet-bwkey.
    ls_bklas-bwtar     = cs_accdet-bwtar.
    ls_bklas-sobkz     = cs_accdet-sobkz.
    ls_bklas-mat_pspnr = cs_accdet-mat_pspnr.
    ls_bklas-mat_kdauf = cs_accdet-mat_kdauf.
    ls_bklas-mat_kdpos = cs_accdet-mat_kdpos.
    ls_bklas-lifnr     = cs_accdet-lifnr.
    ls_bklas-bklas     = cs_accdet-bklas.
    INSERT ls_bklas INTO TABLE lt_bklas.
  ENDIF.


ENDFORM.                    " GET_BKLAS

*&---------------------------------------------------------------------*
*&      Form  GET_ACC_DET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_ACCDET  text
*----------------------------------------------------------------------*
FORM get_acc_det  CHANGING cs_accdet  TYPE stype_accdet.
  TYPES:
    BEGIN OF ltt_acc,
      bklas LIKE t030-bklas,
      bwmod LIKE t030-bwmod,
      ktopl LIKE t030-ktopl,
      hkont LIKE t030-konts,
    END OF ltt_acc.

  STATICS:
    lt_acc TYPE HASHED TABLE OF ltt_acc WITH UNIQUE KEY bklas bwmod ktopl.
  DATA:
    ls_acc TYPE ltt_acc.

* get organizational data
  PERFORM f9300_read_organ
    USING c_werks cs_accdet-werks.
  CHECK g_s_organ-bukrs = cs_accdet-bukrs.
  cs_accdet-bwkey = g_s_organ-bwkey.
  cs_accdet-ktopl = g_s_organ-ktopl.
  cs_accdet-bwmod = g_s_organ-bwmod.

* check for special stock that is valuated in MBEW
  IF ( cs_accdet-sobkz = 'Q' OR cs_accdet-sobkz = 'E' ) AND
     cs_accdet-kzbws = 'A'.
    CLEAR: cs_accdet-sobkz.
  ENDIF.
  IF cs_accdet-sobkz = 'O' AND cs_accdet-xobew IS INITIAL.
    CLEAR: cs_accdet-sobkz.
  ENDIF.

* get special stock data
* (if not filled yet via customer's enhancement of type STYPE_MB5B_ADD)
  CASE cs_accdet-sobkz.
    WHEN 'Q'.
      IF cs_accdet-mat_pspnr IS INITIAL.
*        PERFORM hdb_check_table USING 'MSEG' ''.            "n1710850
        SELECT SINGLE mat_pspnr FROM mseg" CONNECTION (dbcon) "n1710850
          INTO cs_accdet-mat_pspnr
          WHERE mblnr = cs_accdet-mblnr
            AND mjahr = cs_accdet-mjahr
            AND zeile = cs_accdet-zeile.
      ENDIF.
      CLEAR: cs_accdet-mat_kdauf, cs_accdet-mat_kdpos, cs_accdet-lifnr.
    WHEN 'E'.
      IF cs_accdet-mat_kdauf IS INITIAL OR cs_accdet-mat_kdpos IS INITIAL.
*        PERFORM hdb_check_table USING 'MSEG' ''.            "n1710850
        SELECT SINGLE mat_kdauf mat_kdpos FROM mseg" CONNECTION (dbcon) "n1710850
          INTO (cs_accdet-mat_kdauf, cs_accdet-mat_kdpos)
          WHERE mblnr = cs_accdet-mblnr
            AND mjahr = cs_accdet-mjahr
            AND zeile = cs_accdet-zeile.
      ENDIF.
      CLEAR: cs_accdet-mat_pspnr, cs_accdet-lifnr.
    WHEN 'O'.
      IF cs_accdet-lifnr IS INITIAL.
*        PERFORM hdb_check_table USING 'MSEG' ''.            "n1710850
        SELECT SINGLE lifnr FROM mseg" CONNECTION (dbcon)    "n1710850
          INTO cs_accdet-lifnr
          WHERE mblnr = cs_accdet-mblnr
            AND mjahr = cs_accdet-mjahr
            AND zeile = cs_accdet-zeile.
      ENDIF.
      CLEAR: cs_accdet-mat_kdauf, cs_accdet-mat_kdpos, cs_accdet-mat_pspnr.
    WHEN OTHERS.
      CLEAR: cs_accdet-mat_kdauf, cs_accdet-mat_kdpos,
             cs_accdet-mat_pspnr, cs_accdet-lifnr.
  ENDCASE.

* get valuation class
  PERFORM get_bklas CHANGING cs_accdet.

* get G/L account
  READ TABLE lt_acc INTO ls_acc
    WITH TABLE KEY bklas = cs_accdet-bklas
                   bwmod = cs_accdet-bwmod
                   ktopl = cs_accdet-ktopl.
  IF sy-subrc = 0.
    cs_accdet-hkont = ls_acc-hkont.
  ELSE.
    CALL FUNCTION 'MR_ACCOUNT_ASSIGNMENT'
      EXPORTING
        bewertungsklasse       = cs_accdet-bklas
        bewertung_modif        = cs_accdet-bwmod
        kontenplan             = cs_accdet-ktopl
        soll_haben_kennzeichen = 'S'
        vorgangsschluessel     = 'BSX'
      IMPORTING
        konto                  = cs_accdet-hkont
      EXCEPTIONS
        OTHERS                 = 5.
    IF sy-subrc <> 0.
      CLEAR cs_accdet-hkont.
    ENDIF.
    ls_acc-bklas = cs_accdet-bklas.
    ls_acc-bwmod = cs_accdet-bwmod.
    ls_acc-ktopl = cs_accdet-ktopl.
    ls_acc-hkont = cs_accdet-hkont.
    INSERT ls_acc INTO TABLE lt_acc.
  ENDIF.
ENDFORM.                    " GET_ACC_DET

*&---------------------------------------------------------------------*
*&      Form  SUMMEN_BILDEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM summen_bilden .
* Some explanatory words on the strategy of material
* counting/valuation:
* ======================================================
* 1) Stock overview (no valuation):
*    The material document is accepted, if is has not been created
*    automatically or if it is not related to movements out of
*    the stock. For example, if a stock transfer is posted, the
*    system creates a material document with two lines: Out of
*    the old stock (accepted) and into the transfer stock (rejected,
*    because the material is not yet visible in the target location).
*    When the movement into the stock is posted, this is accepted.
* 2) Valuated stock:
*    a) Movements within a single plant (MA05, MA06 =
*       movement types 313-316) are ignored.
*    b) The moving of material out of a plant (303/304)
*       is counted and valuated in the emitting plant and
*       the target plant. The moving in
*       (305/306) is ignored, because
*       the valuated stock appears in the target at the
*       very moment of leaving the emitter.
*    c) Material documents without valuation string are ignored.
*------------- Summen von 'datum-high' bis Gegenwart ------------------*
* Performance Optimization:                                 "1784986
* Form is called from FORM create_table_for_detail!         "1784986
  IF gv_newdb = abap_true.                                  "1784986
    DELETE g_t_mseg_lean WHERE                              "1784986
             ( xauto IS NOT INITIAL ) AND                   "1784986
             ( bustm = 'MA02' OR                            "1784986
               bustm = 'MA05' OR                            "1784986
               bustm = 'MAUO' OR                            "1784986
               bustm = 'MA0L' OR                            "1784986
               bustm = 'MAVA' ).                            "1810543
    RETURN.                                                 "1784986
  ENDIF.                                                    "1784986
  IF NOT index_2 IS INITIAL.
    IF bwbst = ' '.

      SORT imsweg BY werks matnr shkzg.          "auf Materialebene
      LOOP AT imsweg.

        IF ( imsweg-xauto IS INITIAL ) OR
           ( imsweg-bustm <> 'MA02' AND
             imsweg-bustm <> 'MA05' AND
             imsweg-bustm <> 'MAUO' AND                     "1767021
             imsweg-bustm <> 'MA0L' AND                     "1767021
             imsweg-bustm <> 'MAVA' AND                     "1831441
             imsweg-bustm <> '' ).
          MOVE-CORRESPONDING imsweg TO weg_mat.
          COLLECT weg_mat.
        ELSE.
          DELETE imsweg.
        ENDIF.

      ENDLOOP.


    ELSEIF bwbst = 'X'.
      SORT imsweg BY werks matnr shkzg.
      LOOP AT imsweg.
                                                            "n599218 A
        MOVE-CORRESPONDING imsweg TO mat_weg.               "n599218 A
        COLLECT mat_weg.                                    "n599218 A

      ENDLOOP.

      LOOP AT mat_weg.
        IF curm = '1'.
          mat_weg-bwkey = mat_weg-werks.
        ELSEIF curm = '3'.
*
*         look for the corresponding valuation area
*         READ TABLE organ WITH KEY werks = mat_weg-werks.
*         mat_weg-bwkey = organ-bwkey.
          PERFORM  f9300_read_organ
                   USING     c_werks   mat_weg-werks.

          MOVE : g_s_organ-bwkey   TO  mat_weg-bwkey.
        ENDIF.
        MODIFY mat_weg.
      ENDLOOP.
      IF curm = '3'.
        SORT mat_weg BY bwkey matnr shkzg.
        LOOP AT mat_weg.
          MOVE-CORRESPONDING mat_weg TO mat_weg_buk.
          COLLECT mat_weg_buk.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.

*------------- Summen von 'datum-low' bis 'datum-high' ----------------*
  IF bwbst = ' '.


    SORT  g_t_mseg_lean    BY werks matnr shkzg DESCENDING.

    LOOP AT g_t_mseg_lean  INTO  g_s_mseg_lean.

      IF ( g_s_mseg_lean-xauto IS INITIAL ) OR
         ( g_s_mseg_lean-bustm <> 'MA02' AND
           g_s_mseg_lean-bustm <> 'MA05' AND
           g_s_mseg_lean-bustm <> 'MAUO' AND                "1767021
           g_s_mseg_lean-bustm <> 'MA0L' AND                "1767021
           g_s_mseg_lean-bustm <> 'MAVA'   ).               "1831441
        MOVE-CORRESPONDING g_s_mseg_lean   TO  sum_mat.
        COLLECT            sum_mat.
      ELSE.
        DELETE             g_t_mseg_lean.
      ENDIF.

    ENDLOOP.


  ELSEIF bwbst = 'X'.
    SORT  g_t_mseg_lean      BY werks matnr shkzg DESCENDING.
    LOOP AT g_t_mseg_lean    INTO  g_s_mseg_lean.
*       consider special gain/loss-handling of IS-OIL       "n497992
                                                            "n599218 A
      MOVE-CORRESPONDING  g_s_mseg_lean                     "n599218 A
                           TO  mat_sum.                     "n599218 A
      COLLECT              mat_sum.                         "n599218 A
                                                            "n599218 A
    ENDLOOP.

    LOOP AT mat_sum.
      IF curm = '1'.
        mat_sum-bwkey = mat_sum-werks.
      ELSEIF curm = '3'.
        PERFORM  f9300_read_organ
                   USING     c_werks   mat_sum-werks.

        MOVE : g_s_organ-bwkey     TO  mat_sum-bwkey.
      ENDIF.
      MODIFY mat_sum.
    ENDLOOP.

    IF curm = '3'.            "Materialbelege auf Buchungskreisebene
      SORT mat_sum BY bwkey matnr shkzg DESCENDING.
      LOOP AT mat_sum.
        MOVE-CORRESPONDING mat_sum TO mat_sum_buk.
        COLLECT mat_sum_buk.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.                    " SUMMEN_BILDEN
*&---------------------------------------------------------------------*
*&      Form  BESTAENDE_BERECHNEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM bestaende_berechnen .
*------------------- Bestände zu 'datum-high' -------------------------*
  IF bwbst = 'X'.
    SORT mat_weg     BY bwkey matnr shkzg.
    SORT mat_weg_buk BY bwkey matnr shkzg.

    LOOP AT g_t_mbew         INTO  g_s_mbew.
      CLEAR: mat_weg, mat_weg_buk.
*     table g_s_mbew contains already currency and qty unit
      MOVE-CORRESPONDING g_s_mbew      TO bestand.

      IF curm = '1'.
        READ TABLE mat_weg WITH KEY bwkey = g_s_mbew-bwkey
                                    matnr = g_s_mbew-matnr
                                    shkzg = 'S' BINARY SEARCH.
        bestand-endmenge = g_s_mbew-lbkum - mat_weg-menge.
        bestand-endwert  = g_s_mbew-salk3 - mat_weg-dmbtr.
      ELSEIF curm = '3'.
        READ TABLE mat_weg_buk
                   WITH KEY bwkey = g_s_mbew-bwkey
                            matnr = g_s_mbew-matnr
                                        shkzg = 'S' BINARY SEARCH.
        bestand-endmenge = g_s_mbew-lbkum - mat_weg_buk-menge.
        bestand-endwert  = g_s_mbew-salk3 - mat_weg_buk-dmbtr.
      ENDIF.
      CLEAR: mat_weg, mat_weg_buk.
      IF curm = '1'.
        READ TABLE mat_weg WITH KEY bwkey = g_s_mbew-bwkey
                                    matnr = g_s_mbew-matnr
                                    shkzg = 'H' BINARY SEARCH.
        bestand-endmenge = bestand-endmenge + mat_weg-menge.
        bestand-endwert  = bestand-endwert  + mat_weg-dmbtr.
      ELSEIF curm = '3'.
        READ TABLE mat_weg_buk
                   WITH KEY bwkey = g_s_mbew-bwkey
                            matnr = g_s_mbew-matnr
                                        shkzg = 'H' BINARY SEARCH.
        bestand-endmenge = bestand-endmenge + mat_weg_buk-menge.
        bestand-endwert  = bestand-endwert  + mat_weg_buk-dmbtr.
      ENDIF.
      COLLECT bestand.
    ENDLOOP.

    FREE                     g_s_mbew.

  ELSEIF lgbst = 'X'.
*-------------------- ... auf Materialebene ---------------------------*

    LOOP AT imard.
      CLEAR weg_mat-menge.
      MOVE-CORRESPONDING imard TO bestand.
* In 'bestand' wird über die Lagerorte summiert.
      READ TABLE weg_mat WITH KEY werks = imard-werks
                                  lgort = imard-lgort
                                  matnr = imard-matnr
                                  shkzg = 'S'.
      bestand-endmenge = imard-labst + imard-insme + imard-speme
                       + imard-einme +               imard-retme
                       - weg_mat-menge.

      CLEAR weg_mat-menge.
      READ TABLE weg_mat WITH KEY werks = imard-werks
                                  lgort = imard-lgort
                                  matnr = imard-matnr
                                  shkzg = 'H'.
      bestand-endmenge = bestand-endmenge + weg_mat-menge.
      READ TABLE imara WITH KEY matnr  = bestand-matnr.
      MOVE imara-meins TO bestand-meins.
      COLLECT bestand.
    ENDLOOP.
*-------------------- ... auf Chargenebene ----------------------------*

*------------------------ Sonderbestände ------------------------------*
  ELSEIF sbbst = 'X'.
    IF sobkz = 'O'.

      LOOP AT imslbx.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imslbx TO bestand.
        READ TABLE weg_mat WITH KEY werks = imslbx-werks
                                    matnr = imslbx-matnr
                                    shkzg = 'S'.
        bestand-endmenge = imslbx-lblab + imslbx-lbins + imslbx-lbein
                           + imslbx-lbuml - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imslbx-werks
                                    matnr = imslbx-matnr
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.

        COLLECT bestand.
      ENDLOOP.

    ELSEIF sobkz = 'V' OR sobkz = 'W'.

      LOOP AT imskux.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imskux TO bestand.
        READ TABLE weg_mat WITH KEY werks = imskux-werks
                                    matnr = imskux-matnr
                                    shkzg = 'S'.
        bestand-endmenge = imskux-kulab + imskux-kuins + imskux-kuein
                         - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imskux-werks
                                    matnr = imskux-matnr
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.


        COLLECT bestand.
      ENDLOOP.

    ELSEIF sobkz = 'K' OR sobkz = 'M'.

      LOOP AT imkolx.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imkolx TO bestand.
        READ TABLE weg_mat WITH KEY werks = imkolx-werks
                                    matnr = imkolx-matnr
                                    lgort = imkolx-lgort
                                    shkzg = 'S'.
        bestand-endmenge = imkolx-slabs + imkolx-sinsm + imkolx-seinm
                         + imkolx-sspem - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imkolx-werks
                                    matnr = imkolx-matnr
                                    lgort = imkolx-lgort
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.

        COLLECT bestand.
      ENDLOOP.

    ELSEIF sobkz = 'Q'.

      LOOP AT imsprx.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imsprx TO bestand.
        READ TABLE weg_mat WITH KEY werks = imsprx-werks
                                    matnr = imsprx-matnr
                                    lgort = imsprx-lgort
                                    shkzg = 'S'.
        bestand-endmenge = imsprx-prlab + imsprx-prins + imsprx-prspe
                         + imsprx-prein - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imsprx-werks
                                    matnr = imsprx-matnr
                                    lgort = imsprx-lgort
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.

        COLLECT bestand.
      ENDLOOP.

    ELSEIF sobkz = 'E'.

      LOOP AT imskax.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imskax TO bestand.
        READ TABLE weg_mat WITH KEY werks = imskax-werks
                                    matnr = imskax-matnr
                                    lgort = imskax-lgort
                                    shkzg = 'S'.
        bestand-endmenge = imskax-kalab + imskax-kains + imskax-kaspe
                         + imskax-kaein - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imskax-werks
                                    matnr = imskax-matnr
                                    lgort = imskax-lgort
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.

        COLLECT bestand.
      ENDLOOP.

    ELSEIF sobkz = 'T'.                                      "SIT

      LOOP AT imskax.
        CLEAR weg_mat-menge.
        MOVE-CORRESPONDING imskax TO bestand.
        READ TABLE weg_mat WITH KEY werks = imskax-werks
                                    matnr = imskax-matnr
                                    lgort = imskax-lgort
                                    shkzg = 'S'.
        bestand-endmenge = imskax-kalab + imskax-kains + imskax-kaspe
                         + imskax-kaein - weg_mat-menge.

        CLEAR weg_mat-menge.
        READ TABLE weg_mat WITH KEY werks = imskax-werks
                                    matnr = imskax-matnr
                                    lgort = imskax-lgort
                                    shkzg = 'H'.
        bestand-endmenge = bestand-endmenge + weg_mat-menge.
        READ TABLE imara WITH KEY matnr  = bestand-matnr.
        MOVE imara-meins TO bestand-meins.
        COLLECT bestand.
      ENDLOOP.

    ELSE.

    ENDIF.
  ENDIF.
*-------------------- Bestände zu 'datum-low' -------------------------*
  IF bwbst = 'X'.
    SORT mat_sum     BY bwkey matnr shkzg.
    SORT mat_sum_buk BY bwkey matnr shkzg.
    LOOP AT bestand.
      CLEAR: mat_sum, mat_sum_buk.
      IF curm = '1'.
        READ TABLE mat_sum WITH KEY bwkey = bestand-bwkey
                                    matnr = bestand-matnr
                                    shkzg = 'S' BINARY SEARCH.
        MOVE mat_sum-menge TO bestand-soll.
        MOVE mat_sum-dmbtr TO bestand-sollwert.
      ELSEIF curm = '3'.
        READ TABLE mat_sum_buk WITH KEY bwkey = bestand-bwkey
                                        matnr = bestand-matnr
                                        shkzg = 'S' BINARY SEARCH.
        MOVE mat_sum_buk-menge TO bestand-soll.
        MOVE mat_sum_buk-dmbtr TO bestand-sollwert.
      ENDIF.
      CLEAR: mat_sum, mat_sum_buk.
      IF curm = '1'.
        READ TABLE mat_sum WITH KEY bwkey = bestand-bwkey
                                    matnr = bestand-matnr
                                    shkzg = 'H' BINARY SEARCH.
        MOVE mat_sum-menge TO bestand-haben.
        MOVE mat_sum-dmbtr TO bestand-habenwert.
      ELSEIF curm = '3'.
        READ TABLE mat_sum_buk WITH KEY bwkey = bestand-bwkey
                                        matnr = bestand-matnr
                                        shkzg = 'H' BINARY SEARCH.
        MOVE mat_sum_buk-menge TO bestand-haben.
        MOVE mat_sum_buk-dmbtr TO bestand-habenwert.
      ENDIF.
      bestand-anfmenge = bestand-endmenge - bestand-soll
                                          + bestand-haben.
      bestand-anfwert = bestand-endwert - bestand-sollwert
                                        + bestand-habenwert.
      MODIFY bestand.
    ENDLOOP.
*-------------------- ... auf Materialebene ---------------------------*
  ELSEIF lgbst = 'X'.

    LOOP AT bestand.
      CLEAR sum_mat-menge.
      READ TABLE sum_mat WITH KEY werks = bestand-werks
                                  matnr = bestand-matnr
                                  shkzg = 'S'.
      MOVE sum_mat-menge TO bestand-soll.

      CLEAR sum_mat-menge.
      READ TABLE sum_mat WITH KEY werks = bestand-werks
                                  matnr = bestand-matnr
                                  shkzg = 'H'.
      MOVE sum_mat-menge TO bestand-haben.
      bestand-anfmenge = bestand-endmenge - bestand-soll
                                          + bestand-haben.

      MODIFY bestand.
    ENDLOOP.

  ELSEIF sbbst = 'X'.
    IF sobkz = 'O'.

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

    ELSEIF sobkz = 'V' OR sobkz = 'W'.

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

*   consider special stock M ,too
    ELSEIF sobkz = 'K' OR sobkz = 'M'.

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

    ELSEIF sobkz = 'Q'.

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

    ELSEIF sobkz = 'E'.

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

    ELSEIF sobkz = 'T'.                                      "SIT

      LOOP AT bestand.
        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'S'.
        MOVE sum_mat-menge TO bestand-soll.

        CLEAR sum_mat-menge.
        READ TABLE sum_mat WITH KEY werks = bestand-werks
                                    matnr = bestand-matnr
                                    shkzg = 'H'.
        MOVE sum_mat-menge TO bestand-haben.
        bestand-anfmenge = bestand-endmenge - bestand-soll
                                            + bestand-haben.

        MODIFY bestand.
      ENDLOOP.

    ELSE.

    ENDIF.
  ENDIF.
ENDFORM.                    " BESTAENDE_BERECHNEN
*&---------------------------------------------------------------------*
*&      Form  BESTAENDE_AUSGEBEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM bestaende_ausgeben .
  DATA lv_belege1 TYPE stab_belege WITH HEADER LINE.
*   show the wole list with the ALV

  LOOP AT bestand.
    MOVE-CORRESPONDING bestand TO bestand1.
    APPEND bestand1.

    CLEAR g_t_belege. REFRESH g_t_belege.

    IF bwbst IS INITIAL.
*     fill the data table for the ALV with the
*     corresponding MM documents for mode = stock
      PERFORM  fill_data_table
                             TABLES    g_t_belege1
                             USING     bestand-matnr
                                       bestand-werks
                                       bestand-charg.

      APPEND LINES OF lv_belege1 TO g_t_belege1.

    ELSEIF NOT bwbst IS INITIAL.
*     fill the data table for the ALV with the
*     corresponding MM documents for mode = valuated stock
      PERFORM  process_plants_of_bwkey
                             TABLES    g_t_belege1
                             USING     bestand-matnr
                                       bestand-bwkey.

*      APPEND LINES OF lv_belege1 TO g_t_belege1.

    ENDIF.

  ENDLOOP.

*
*  READ TABLE bestand INDEX 1.
*  MOVE-CORRESPONDING bestand TO bestand1.
*  APPEND bestand1.



  SORT g_t_belege1  BY budat mblnr zeile.

  events-name = 'TOP_OF_PAGE'.
  events-form = 'UEBERSCHRIFT1'.
  APPEND events.

*   set this event depending on the entries in working
*   table BESTAND
  DESCRIBE TABLE bestand LINES g_f_cnt_lines.

  IF  g_f_cnt_lines = 1.
    events-form  =  'PRINT_END_OF_LIST'.
  ELSE.
    events-form = 'LISTE'.
  ENDIF.

  events-name = 'END_OF_LIST'.
  APPEND events.
* Exportar tabla a excel
*  PERFORM exportar_excel.
*  IF p_vari IS NOT INITIAL.
  PERFORM exportar_excel.
*  ENDIF.

  PERFORM listausgabe1. " ALV

ENDFORM.                    " BESTAENDE_AUSGEBEN
*&---------------------------------------------------------------------*
*&      Form  FELDGRUPPEN_AUFBAUEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM feldgruppen_aufbauen .

* Gruppendefinitionen Positionsfelder
  gruppen-sp_group = 'M'.
  gruppen-text = text-050.
  APPEND gruppen.
  gruppen-sp_group = 'B'.
  gruppen-text = text-051.
  APPEND gruppen.
  gruppen-sp_group = 'D'.
  gruppen-text = text-052.
  APPEND gruppen.
  gruppen-sp_group = 'O'.
  gruppen-text = text-053.
  APPEND gruppen.
  gruppen-sp_group = 'K'.
  gruppen-text = text-054.
  APPEND gruppen.
  gruppen-sp_group = 'E'.
  gruppen-text = text-055.
  APPEND gruppen.
  gruppen-sp_group = 'V'.
  gruppen-text = text-056.
  APPEND gruppen.
  gruppen-sp_group = 'F'.
  gruppen-text = text-057.
  APPEND gruppen.
  gruppen-sp_group = 'S'.
  gruppen-text = text-058.
  APPEND gruppen.
  layout-group_buttons = ' '.

ENDFORM.                    " FELDGRUPPEN_AUFBAUEN
*&---------------------------------------------------------------------*
*&      Form  FILL_DATA_TABLE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_G_T_BELEGE1  text
*      -->P_BESTAND_MATNR  text
*      -->P_BESTAND_WERKS  text
*      -->P_BESTAND_CHARG  text
*----------------------------------------------------------------------*
FORM fill_data_table  TABLES    l_t_belege      TYPE  stab_belege
         USING     l_matnr         TYPE  mseg-matnr
                   l_werks         TYPE  mseg-werks
                   l_charg         TYPE  mseg-charg.

* define local data fields
  DATA : l_s_belege TYPE stype_belege.

* sort table with the MM docs only once
  IF  g_flag_sorted  IS INITIAL.
    MOVE  'X'                TO  g_flag_sorted.
    SORT  g_t_mseg_lean      BY  matnr  werks  charg.
  ENDIF.

* read the first matching line depending on the batch
  IF  l_charg IS INITIAL.
    READ  TABLE g_t_mseg_lean     ASSIGNING  <g_fs_mseg_lean>
      WITH KEY matnr = l_matnr
               werks = l_werks    BINARY SEARCH.
  ELSE.
    READ  TABLE g_t_mseg_lean     ASSIGNING  <g_fs_mseg_lean>
      WITH KEY matnr = l_matnr
               werks = l_werks
               charg = l_charg    BINARY SEARCH.
  ENDIF.

* the first entry found ? -> go on
  CHECK sy-subrc IS INITIAL.

  MOVE  sy-tabix             TO  g_tabix_set.

* go on with sequential reading
  LOOP AT g_t_mseg_lean     INTO  g_s_mseg_lean
    FROM g_tabix_set.

*   take this entry when the key fields match
    IF  g_s_mseg_lean-matnr = l_matnr   AND
        g_s_mseg_lean-werks = l_werks.

      MOVE-CORRESPONDING g_s_mseg_lean
                             TO  l_s_belege.

*     enrich some fields with color and numeric fields with sign
*     the negative sign was not set for GI postings
      PERFORM  f9500_set_color_and_sign
                       USING  l_s_belege  'L_S_BELEGE'.

      APPEND  l_s_belege     TO  l_t_belege.
    ELSE.
      EXIT.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " FILL_DATA_TABLE
*&---------------------------------------------------------------------*
*&      Form  F9500_SET_COLOR_AND_SIGN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_S_BELEGE  text
*      -->P_8066   text
*----------------------------------------------------------------------*
FORM f9500_set_color_and_sign   USING  l_s_belege   TYPE  stype_belege
                l_f_tabname  TYPE  stype_fields-fieldname.

  DATA : l_f_fieldname TYPE stype_fields-fieldname.
  FIELD-SYMBOLS : <l_fs_field>.

* clear the table with the color information
  REFRESH color. CLEAR color.

  LOOP AT g_t_color_fields.
    CONCATENATE  l_f_tabname
                 '-'
                 g_t_color_fields-fieldname
                             INTO l_f_fieldname.
    ASSIGN (l_f_fieldname)   TO  <l_fs_field>.

    CHECK sy-subrc IS INITIAL.

    MOVE : g_t_color_fields-fieldname
                             TO  color-fieldname,
           0                 TO  color-color-int.

*   the color and the sign of this numeric field depend on the
*   debit/credit-indicator
    CASE    l_s_belege-shkzg.
      WHEN  'H'.
        color-color-col = '6'.         "red
        APPEND color.

        IF  g_t_color_fields-type  <>  'C'.
          COMPUTE : <l_fs_field> = <l_fs_field> * -1.
        ENDIF.

      WHEN  'S'.
        color-color-col = '5'.         "green
        APPEND color.
    ENDCASE.
  ENDLOOP.

* customizing : set the color information
  IF  g_cust_color  = 'X'.
*   default : colorize the numeric fields
    MOVE  color[]            TO  l_s_belege-farbe_pro_feld.
  ELSE.
*   the performant way : colorize the line on when GI
    IF  l_s_belege-shkzg = 'H'.
      MOVE  'C21'  TO  l_s_belege-farbe_pro_zeile. "grey
    ELSE.
      MOVE  'C20'  TO  l_s_belege-farbe_pro_zeile. "light grey
    ENDIF.
  ENDIF.

ENDFORM.                    " F9500_SET_COLOR_AND_SIGN
*&---------------------------------------------------------------------*
*&      Form  LISTAUSGABE1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM listausgabe1 . " ALV
  IF  g_cust_color = 'X'.
    layout-coltab_fieldname = 'FARBE_PRO_FELD'.
  ELSE.
    layout-info_fieldname   = 'FARBE_PRO_ZEILE'.
  ENDIF.

  layout-f2code = '9PBP'.
  IF NOT bwbst IS INITIAL.
    layout-min_linesize = '92'.
  ENDIF.

  event_exit-ucomm = '&XP1'.
  event_exit-before = 'X'.
  APPEND event_exit.
* Si se quiere cambiar el formato de visualización de TABLA a ALV, usar la función REUSE_ALV_GRID_DISPLAY
*  CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      i_interface_check  = g_flag_i_check
      i_callback_program = repid
*     i_callback_pf_status_set = 'STATUS'
*     i_callback_user_command  = 'USER_COMMAND'
*     I_STRUCTURE_NAME   =
      is_layout          = layout
      it_fieldcat        = fieldcat[]
*     IT_EXCLUDING       =
      it_special_groups  = gruppen[]
      it_sort            = sorttab[]
      it_filter          = filttab[]
*     IS_SEL_HIDE        =
      i_default          = 'X'
      i_save             = 'A'
      is_variant         = variante
*     it_events          = events[]
*     it_event_exit      = event_exit[]
      is_print           = g_s_print
*     I_SCREEN_START_COLUMN    = 0
*     I_SCREEN_START_LINE      = 0
*     I_SCREEN_END_COLUMN      = 0
*     I_SCREEN_END_LINE  = 0
*      IMPORTING
*     e_exit_caused_by_caller  = 'X'
*     es_exit_caused_by_user   = 'X'
    TABLES
      t_outtab           = g_t_belege1 "Tabla con los datos que se muestran en el ALV
    EXCEPTIONS
*     program_error      = 1
      OTHERS             = 2.

  IF  NOT sy-subrc IS INITIAL.
    MESSAGE ID sy-msgid TYPE  'S'     NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
ENDFORM.                    " LISTAUSGABE1
*&---------------------------------------------------------------------*
*&      Form  PROCESS_PLANTS_OF_BWKEY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_G_T_BELEGE1  text
*      -->P_BESTAND_MATNR  text
*      -->P_BESTAND_BWKEY  text
*----------------------------------------------------------------------*
FORM process_plants_of_bwkey  TABLES    l2_t_belege  TYPE  stab_belege
         USING     l2_matnr     TYPE  mseg-matnr
                   l2_bwkey     TYPE  mbew-bwkey.

* define local working fields
  FIELD-SYMBOLS :
    <l_fs_organ> TYPE stype_organ.
  DATA : l_tabix_start TYPE sy-tabix.


  IF  curm = '1'.
*   valuation level is plant / process the MM docs
    PERFORM  fill_data_table TABLES    l2_t_belege
                             USING     l2_matnr
                                       l2_bwkey
                                       space.
    EXIT.                    " leave this routine
  ENDIF.

* valuation leve = company code : plenty of plants could
* be assigned to the valuation area, look for the assigned
* plants and look for the MM doc per plant

* look for the first valuation area
  READ TABLE g_t_organ       ASSIGNING  <l_fs_organ>
    WITH KEY keytype  = c_bwkey
             keyfield = l2_bwkey
                             BINARY SEARCH.

* go on when a valuation area was found
  CHECK sy-subrc IS INITIAL.

  MOVE  sy-tabix             TO  l_tabix_start.

* seq. read of all matching entries
  LOOP AT g_t_organ          ASSIGNING <l_fs_organ>
    FROM l_tabix_start.

    IF  <l_fs_organ>-keytype   = c_bwkey      AND
        <l_fs_organ>-keyfield  = l2_bwkey.
*     process the MM docs from this plant
      PERFORM  fill_data_table
                             TABLES    l2_t_belege
                             USING     l2_matnr
                                       <l_fs_organ>-werks
                                       space.
    ELSE.
      EXIT.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " PROCESS_PLANTS_OF_BWKEY
*&---------------------------------------------------------------------*
*&      Form  EXPORTAR_EXCEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM exportar_excel .
  DATA: lv_filename TYPE cgpl_object_text.
  DATA: lv_rutacompleta   TYPE rlgrap-filename,
        lv_fichero_correo TYPE rlgrap-filename.
  DATA: lt_tablconvertida TYPE truxs_t_text_data.
  DATA: lv_fname2      TYPE         string,
        lv_cabecera    LIKE LINE OF lt_tablconvertida,
        lt_emails      TYPE         zttpp0001,
        lv_icmdata     TYPE         icmdata,
        wa_email       TYPE         ad_smtpadr,
        lt_content_bin TYPE         solix_tab,
        lv_content     TYPE         string.

  DATA: wa_ltdx      TYPE                   ltdx,
        v_varkey     TYPE                   ltdxkey,
        it_fcat      TYPE STANDARD TABLE OF ltdxdata,
        it_sort_info TYPE STANDARD TABLE OF ltdxdata,
        it_filter    TYPE STANDARD TABLE OF ltdxdata.

  DATA: l_varkey       TYPE ltdxkey,
        wa_ltdxdata    TYPE ltdxdata,
        flag_no_out(1),
        wa_fieldcat    TYPE lvc_s_fcat,
        it_fieldcat    TYPE lvc_t_fcat,
*        l_variante     TYPE zrpt_hparam1-descripcion,
*        l_ruta         TYPE zrpt_hparam1-descripcion,
*        l_archivo      TYPE zrpt_hparam1-descripcion,
        l_path(120).

  DATA: l_r_structdescr TYPE REF TO cl_abap_structdescr.

  TYPE-POOLS : abap.
  FIELD-SYMBOLS: <dyn_table> TYPE STANDARD TABLE,
                 <dyn_wa>,
                 <dyn_field>.

  DATA: dy_table       TYPE REF TO  data,
        dy_line        TYPE REF TO  data,
        xfc            TYPE         lvc_s_fcat,
        ifc            TYPE         lvc_t_fcat,
        l_string(1024),
        f_flag         TYPE         xfeld,
        ls_fieldcat    TYPE LINE OF slis_t_fieldcat_alv,
        l_xls(1024).

  DATA: it_descriptivos TYPE STANDARD TABLE OF dfies,
        wa_desc         TYPE                   dfies.


  CONSTANTS: c_relid TYPE ltdx-relid VALUE 'LT'.


* Rellenar la tabla g_t_belege1_flat con la g_t_belege1 pero sin la tabla anidada

  MOVE-CORRESPONDING g_t_belege1[] TO g_t_belege1_flat[].

* >>> YTG Mover a una tabla dinámica las columnas que solo se necesitan según la variante.
* En esta tabla se almacenan los datos de la variante.
*Van en formato DATA por lo que hay que procesarlos con la función LT_DBDATA_READ_FROM_LTDX.
*En la tabla it_fcat se guradarán los datos ya procesados con las columnas visibles.
* https://archive.sap.com/discussions/thread/3384958

  SELECT SINGLE * FROM ltdx INTO wa_ltdx
         WHERE relid = c_relid
         AND report =  repid
         AND variant = variante-variant.
* Si se ha seleccionado una variante y existe, exportar solo sus columnas, si no exportar la del fieldcat por defecto
  IF sy-subrc = 0.
    MOVE-CORRESPONDING wa_ltdx TO  v_varkey.

*   Esta función convierte el LTDX de la select en un fieldcat, pero en un formato de fieldcat que es necesario convertir tambien.
    CALL FUNCTION 'LT_DBDATA_READ_FROM_LTDX'
      EXPORTING
        i_tool       = c_relid
        is_varkey    = v_varkey
      TABLES
        t_dbfieldcat = it_fcat               " Fieldcat
        t_dbsortinfo = it_sort_info          " Criterio ordenamiento
        t_dbfilter   = it_filter.            " Criterio filtrado

* Convertir el fieldcatalog de la función LT_DBDATA_READ_FROM_LTDX al formato de fieldcatalog de ALV
    IF sy-subrc = 0.
      LOOP AT it_fcat INTO wa_ltdxdata.
        AT NEW key1.
          CLEAR flag_no_out.
        ENDAT.
*       Rechazar aquellas columnas que están ocultas
        IF wa_ltdxdata-param = 'NO_OUT' AND wa_ltdxdata-value = 'X'.
          flag_no_out = 'X'.
        ENDIF.

        AT END OF key1.
          IF flag_no_out IS INITIAL.
            CLEAR wa_fieldcat.
*           Leer el fildcat global para obtener el nombre de la tabla estándar a la que hacer referencia cada columna (MARA, BKPF, etc)
            READ TABLE fieldcat WITH KEY fieldname =  wa_ltdxdata-key1 INTO ls_fieldcat.
            wa_fieldcat-fieldname = wa_ltdxdata-key1. "Asignar campo a la columna
            wa_fieldcat-ref_table = ls_fieldcat-ref_tabname. "Asignar tabla de referencia
            wa_fieldcat-ref_field = wa_ltdxdata-key1. "Asignar campo de la tabla de referencia. En todos los casos ref_field es el mismo que fieldname.

*           Obtener el descriptivo de la columna (Se le pasa el nombre de la tabla que contiene el campo y el nombre del campo en sí.
*           Retorna una tabla con los descriptivos corto, medio y largo)
            CALL FUNCTION 'DDIF_FIELDINFO_GET'
              EXPORTING
                tabname        = wa_fieldcat-ref_table "Tabla de la BBDD que contiene el campo
                fieldname      = wa_fieldcat-fieldname "Campo
              TABLES
                dfies_tab      = it_descriptivos "Tabla de retorno con los descriptivos
              EXCEPTIONS
                not_found      = 1
                internal_error = 2
                OTHERS         = 3.
            IF sy-subrc = 0.
*             Si la función OK, leer la primera linea y asignar los descriptivos corto, medio y largo al nuevo fieldcat
              READ TABLE it_descriptivos INTO wa_desc INDEX 1.
              wa_fieldcat-scrtext_s = wa_desc-scrtext_s.
              wa_fieldcat-scrtext_m = wa_desc-scrtext_m.
              wa_fieldcat-scrtext_l = wa_desc-scrtext_l.
            ENDIF.
            APPEND wa_fieldcat TO it_fieldcat.
          ENDIF.
        ENDAT.
      ENDLOOP.
    ENDIF.

* Con el fieldcatalog en formato ALV crear la tabla dinámica que contendrá solo las columnas de la variante.
    CALL METHOD cl_alv_table_create=>create_dynamic_table
      EXPORTING
        it_fieldcatalog  = it_fieldcat
        i_length_in_byte = 'X'
      IMPORTING
        ep_table         = dy_table.
    ASSIGN dy_table->* TO <dyn_table>.

*   Rellenar las cabeceras a partir del fieldcat generado con la variante (it_fieldcat). Se usa texto largo, se puede cambiar por scrtext_m (medio) o scrtext_s (corto)
    CLEAR f_flag.
    LOOP AT it_fieldcat INTO wa_fieldcat.
      IF sy-subrc = 0.
        IF f_flag IS INITIAL. "Si el flag está vacío, es la primera columna, asignarla directamente a la cabecera y marcar el flag
          lv_cabecera = wa_fieldcat-scrtext_l.
          f_flag = 'X'.
        ELSE. "Si el flag ya está relleno, no es la primera columna, concatenar la columna a lo que ya estaba en la cabecera y separarlo con ;
          CONCATENATE lv_cabecera wa_fieldcat-scrtext_l INTO lv_cabecera SEPARATED BY ';'.
        ENDIF.
      ENDIF.
    ENDLOOP.

*   Mover las columnas y filas de la tabla que las contiene todas a la tabla dinámica de la selección reducida
    MOVE-CORRESPONDING g_t_belege1_flat[] TO <dyn_table>.

  ELSE. "No se ha seleccionado ninguna variante o no existe, usar el fieldcat creado por defecto
* Mover los datos del fieldcatalog global (por defecto) al formato que se necesita en cl_alv_table_create=>create_dynamic_table
    LOOP AT fieldcat into ls_fieldcat.
      clear wa_fieldcat.
      MOVE-CORRESPONDING ls_fieldcat to wa_fieldcat.
      wa_fieldcat-ref_table = ls_fieldcat-ref_tabname. "Asignar tabla de referencia
      wa_fieldcat-ref_field = ls_fieldcat-fieldname. "Asignar campo de la tabla de referencia.
      APPEND wa_fieldcat to it_fieldcat.
    ENDLOOP.

    CALL METHOD cl_alv_table_create=>create_dynamic_table
      EXPORTING
        it_fieldcatalog  = it_fieldcat[]
        i_length_in_byte = 'X'
      IMPORTING
        ep_table         = dy_table.
    ASSIGN dy_table->* TO <dyn_table>.

*   Rellenar las cabeceras a partir del fieldcat generado con la variante (it_fieldcat). Se usa texto largo, se puede cambiar por scrtext_m (medio) o scrtext_s (corto)
    CLEAR f_flag.
    LOOP AT it_fieldcat INTO wa_fieldcat.
*       Obtener el descriptivo de la columna (Se le pasa el nombre de la tabla que contiene el campo y el nombre del campo en sí.
*       Retorna una tabla con los descriptivos corto, medio y largo)
      CALL FUNCTION 'DDIF_FIELDINFO_GET'
        EXPORTING
          tabname        = wa_fieldcat-ref_table "Tabla de la BBDD que contiene el campo
          fieldname      = wa_fieldcat-fieldname "Campo
        TABLES
          dfies_tab      = it_descriptivos "Tabla de retorno con los descriptivos
        EXCEPTIONS
          not_found      = 1
          internal_error = 2
          OTHERS         = 3.
      IF sy-subrc = 0.
*       Si la función OK, leer la primera linea y asignar el descriptivo largo
        READ TABLE it_descriptivos INTO wa_desc INDEX 1.
        IF sy-subrc = 0.
          IF f_flag IS INITIAL. "Si el flag está vacío, es la primera columna, asignarla directamente a la cabecera y marcar el flag
            lv_cabecera = wa_desc-scrtext_l.
            f_flag = 'X'.
          ELSE. "Si el flag ya está relleno, no es la primera columna, concatenar la columna a lo que ya estaba en la cabecera y separarlo con ;
            CONCATENATE lv_cabecera wa_desc-scrtext_l INTO lv_cabecera SEPARATED BY ';'.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

*   Mover las columnas y filas de la tabla que las contiene todas a la tabla dinámica de la selección reducida
    MOVE-CORRESPONDING g_t_belege1_flat[] TO <dyn_table>.
  ENDIF.
* <<< YTG Mover a una tabla dinámica las columnas que solo se necesitan según la variante.


  CONCATENATE 'STOCKS_' sy-datum sy-uzeit '.csv' INTO lv_filename.

  CALL FUNCTION 'SAP_CONVERT_TO_CSV_FORMAT'
    TABLES
      i_tab_sap_data       = <dyn_table> "Usar la tabla dinámica en vez de la g_t_belege1_flat
    CHANGING
      i_tab_converted_data = lt_tablconvertida "Tabla convertida a CSV
    EXCEPTIONS
      conversion_failed    = 1
      OTHERS               = 2.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.
*  lv_cabecera = 'Ámbito de valoración;Número de documento material; '.
*  lv_cabecera = 'BWKEY;MBLNR;MJAHR;VGART;BLART;BUDAT;CPUDT;CPUTM;USNAM;XABLN;LBBSA;BWAGR;BUKRS;BELNR;GJAHR;BUZEI;HKONT;WAERS;ZEILE;BWART;MATNR;WERKS;LGORT;CHARG;BWTAR;KZVBR;KZBEW;SOBKZ;KZZUG;BUSTM;BUSTW;MENGU;WERTU;SHKZG;MENGE;MEINS;DMBTR;DMBUM;XAUTO'.
**  'KZBWS;  XOBEW;RETAIL;OIGLCALC;OIGLSKU;INSMK;SMBLN;SJAHR;SMBLP;FARBE_PRO_ZEILE'.
*  lv_cabecera = ''.

* Insertar la cabecera en la primera posición de la tabla CSV
  INSERT lv_cabecera INTO lt_tablconvertida INDEX 1.

  MOVE lv_rutacompleta TO lv_fname2.
  CALL FUNCTION 'GUI_DOWNLOAD'
    EXPORTING
      filename = 'C:\excel_stock.csv'
    TABLES
      data_tab = lt_tablconvertida
    EXCEPTIONS
      OTHERS   = 1.

  IF s_excel IS NOT INITIAL.
    LOOP AT s_excel.
      CONCATENATE s_excel-low lv_filename INTO lv_rutacompleta.

      OPEN DATASET lv_rutacompleta FOR OUTPUT IN TEXT MODE ENCODING UTF-8.
      IF sy-subrc = 0.
        LOOP AT lt_tablconvertida INTO lv_cabecera.
          TRANSFER lv_cabecera TO lv_rutacompleta.
        ENDLOOP.
        CLOSE DATASET lv_rutacompleta.
      ENDIF.
    ENDLOOP.

  ENDIF.

  CALL FUNCTION 'SOTR_SERV_TABLE_TO_STRING'
    IMPORTING
      text     = lv_content
    TABLES
      text_tab = lt_tablconvertida.

  lv_icmdata = cl_abap_codepage=>convert_to( lv_content ).

  IF s_email IS NOT INITIAL.
    LOOP AT s_email.
      wa_email = s_email-low.
      APPEND wa_email TO lt_emails.
    ENDLOOP.

    CALL FUNCTION 'ZFM_EXCEL_SEND_EMAIL'
      EXPORTING
        i_excel       = lv_icmdata
        i_header      = 'Envío automático de Stocks'
        i_attach_name = lv_filename
*     IMPORTING
*       EV_SENT_STATUS       =
      TABLES
*       IT_BODYTX     =
        it_email      = lt_emails.

    IF  sy-subrc = 0.
*   Implementacion
    ENDIF.
  ENDIF.

ENDFORM.                    " EXPORTAR_EXCEL
*&---------------------------------------------------------------------*
*&      Form  VALIDACIONES_SELECC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM validaciones_selecc .

** check the entries only in releases >= 46B
  CALL FUNCTION 'MMIM_ENTRYCHECK_MAIN'
    TABLES
      it_matnr = matnr
      it_werks = werks
      it_lgort = lgort
      it_bwart = bwart
      it_bukrs = bukrs.

  IF sbbst = 'X' AND sobkz IS INITIAL.
    MESSAGE e113(zpp).
  ELSEIF sbbst = ' ' AND NOT sobkz IS INITIAL.
    CLEAR sobkz.
    MESSAGE w114(zpp).
  ENDIF.


*consider and prepare select-options depending on the required
* special stock indicator
  REFRESH                    g_ra_sobkz.
  CLEAR                      g_ra_sobkz.

  IF      lgbst = 'X'.       "only Storage loc./batch stock
*   create ranges table : select only sobkz = space
    PERFORM f0500_append_ra_sobkz   USING  c_space.

  ELSEIF  bwbst = 'X'.       "only valuated stocks
*   take all special stock indicators / the record selection
*   will be done after the database selection
*
  ELSEIF  sbbst = 'X'.       "only special stocks
    PERFORM f0500_append_ra_sobkz   USING  sobkz.
  ELSEIF   sobkz  =  'O'  OR
           sobkz  =  'V'  OR
           sobkz  =  'W'  OR
           sobkz  =  'E'  OR
           sobkz  =  'K'  OR
           sobkz  =  'M'  OR
           sobkz  =  'Q'  OR
           sobkz  =  'T'.
**     ok; no aktion taken
  ELSE.
    SET CURSOR     FIELD  'SOBKZ'.
**     Sonderbestandskennzeichen nicht vorhanden
    MESSAGE e115(zpp).
  ENDIF.

* VARIANTES

  IF NOT p_vari IS INITIAL.
    MOVE variante TO def_variante.
    MOVE p_vari TO def_variante-variant.

    CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
      EXPORTING
        i_save     = variant_save
      CHANGING
        cs_variant = def_variante.

    variante = def_variante.
  ELSE.
*   the user wants no initial display variant
    IF  NOT alv_default_variant  IS INITIAL.
*     but the SAP-LIST-VIEWER will apply the existing
*     initial display variant / emerge warning 393 ?
      CALL FUNCTION 'ME_CHECK_T160M'
        EXPORTING
          i_arbgb = 'ZPP'
          i_msgnr = '393'
        EXCEPTIONS
          nothing = 0
          OTHERS  = 1.

      IF sy-subrc <> 0.

        MESSAGE w116(zpp)     WITH  alv_default_variant.
      ENDIF.
    ENDIF.

    CLEAR variante.
    variante-report = repid.
  ENDIF.
ENDFORM.                    " VALIDACIONES_SELECC
*&---------------------------------------------------------------------*
*&      Form  F0500_APPEND_RA_SOBKZ
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_C_SPACE  text
*----------------------------------------------------------------------*
FORM f0500_append_ra_sobkz
                   USING  l_f_sobkz LIKE  mseg-sobkz.

* create ranges table with special stock indicator
  CLEAR                      g_ra_sobkz.
  MOVE : l_f_sobkz  TO  g_ra_sobkz-low,
         'I'        TO  g_ra_sobkz-sign,
         'EQ'       TO  g_ra_sobkz-option.

  APPEND  g_ra_sobkz.


ENDFORM.                    " F0500_APPEND_RA_SOBKZ
*&---------------------------------------------------------------------*
*&      Form  CHECK_RESTRICTIONS
*&---------------------------------------------------------------------*
FORM check_restrictions .

* rectricción según el tipo de movimiento
  IF NOT bwart[] IS INITIAL.
    CALL FUNCTION 'ME_CHECK_T160M'
      EXPORTING
        i_arbgb = 'ZPP'
        i_msgnr = '118'
      EXCEPTIONS
        nothing = 0
        OTHERS  = 1.

    IF sy-subrc <> 0.
      SET CURSOR  FIELD  'BWART_LOW'.
*     to restric the mov.type could cause wrong results
      MESSAGE                w118(zpp).
    ENDIF.
  ENDIF.

  IF  sy-ucomm  =  'ONLI'     OR
      sy-ucomm  =  'PRIN'.
*   only in dialog or online-print mode
    IF  matnr[] IS INITIAL AND
        bukrs[] IS INITIAL AND
        werks[] IS INITIAL AND
        lgort[] IS INITIAL AND
        charg[] IS INITIAL AND
        bwtar[] IS INITIAL.
      MESSAGE  w117(zpp).
    ENDIF.
  ENDIF.
ENDFORM.                    " CHECK_RESTRICTIONS

*&---------------------------------------------------------------------*
*&   PF_STATUS_SET_TOTALS
*&---------------------------------------------------------------------*

FORM pf_status_set_totals                                   "#EC CALLED
                   USING     extab TYPE slis_t_extab.

  SET PF-STATUS 'STANDARD'   EXCLUDING extab.

ENDFORM.


FORM initialisierung.

  repid = sy-repid.
  variant_save = 'A'.
  CLEAR variante.
  variante-report = repid.
* Default-Variante holen:
  def_variante = variante.

  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = variant_save
    CHANGING
      cs_variant = def_variante
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 0.
*   save the initial, e.g. default variant                  "n599218
    MOVE  def_variante-variant  TO  alv_default_variant.    "n599218
    p_vari = def_variante-variant.
  ENDIF.
*  print-no_print_listinfos = 'X'.

ENDFORM.                               " INITIALISIERUNG

*
**----------------------------------------------------------------------*
**    user_parameters_save
**----------------------------------------------------------------------*
*
*FORM user_parameters_save.
*
*  GET PARAMETER ID 'BUK'     FIELD  g_save_params-bukrs.
*  GET PARAMETER ID 'WRK'     FIELD  g_save_params-werks.
*  GET PARAMETER ID 'MAT'     FIELD  g_save_params-matnr.
*  GET PARAMETER ID 'CHA'     FIELD  g_save_params-charg.
*  GET PARAMETER ID 'BLN'     FIELD  g_save_params-belnr.
*  GET PARAMETER ID 'BUK'     FIELD  g_save_params-bukrs.
*  GET PARAMETER ID 'GJR'     FIELD  g_save_params-gjahr.
*
*ENDFORM.                     "user_parameters_save
*
**----------------------------------------------------------------------*
**    user_parameters_restore
**----------------------------------------------------------------------*
*
*FORM user_parameters_restore.
*
*  SET PARAMETER ID 'BUK'     FIELD  g_save_params-bukrs.
*  SET PARAMETER ID 'WRK'     FIELD  g_save_params-werks.
*  SET PARAMETER ID 'MAT'     FIELD  g_save_params-matnr.
*  SET PARAMETER ID 'CHA'     FIELD  g_save_params-charg.
*  GET PARAMETER ID 'BLN'     FIELD  g_save_params-belnr.
*  GET PARAMETER ID 'BUK'     FIELD  g_save_params-bukrs.
*  GET PARAMETER ID 'GJR'     FIELD  g_save_params-gjahr.
*
*ENDFORM.                     "user_parameters_restore
*
**&---------------------------------------------------------------------*
**&   USER_COMMAND_TOTALS
**&---------------------------------------------------------------------*
*
*FORM user_command_totals                                    "#EC CALLED
*                   USING     r_ucomm     LIKE  sy-ucomm
*                             rs_selfield TYPE  slis_selfield.
*
*  CLEAR                      g_s_bestand_key.
*
*  IF      rs_selfield-tabname = 'G_T_TOTALS_HEADER'.
**   get the selected entry from table G_T_TOTALS
*    READ TABLE g_t_totals_header
*      INTO  g_s_totals_header
*        INDEX rs_selfield-tabindex.
*
*    IF sy-subrc IS INITIAL.
*      MOVE-CORRESPONDING  g_s_totals_header
*                             TO  g_s_bestand_key.
*    ENDIF.
*
*  ELSEIF  rs_selfield-tabname = 'G_T_TOTALS_ITEM'.
**   get the selected entry from table G_T_TOTALS
*    READ TABLE g_t_totals_item
*      INTO  g_s_totals_item
*        INDEX rs_selfield-tabindex.
*
*    IF sy-subrc IS INITIAL.
*      MOVE-CORRESPONDING  g_s_totals_item
*                             TO  g_s_bestand_key.
*    ENDIF.
*
*  ELSEIF  rs_selfield-tabname = 'G_T_TOTALS_FLAT'.
**   get the selected entry from table G_T_TOTALS
*    READ TABLE g_t_totals_flat
*      INTO  g_s_totals_flat
*        INDEX rs_selfield-tabindex.
*
*    IF sy-subrc IS INITIAL.
*      MOVE-CORRESPONDING  g_s_totals_flat
*                             TO  g_s_bestand_key.
*    ENDIF.
*  ENDIF.
*
*  IF g_s_bestand_key IS INITIAL.   "notinh found ?
**   Place the cursor on a table line
*    MESSAGE                  s322(m7).
*    EXIT.
*  ENDIF.
*
** get the line from the main table BESTAND depending on the mode
*  IF bwbst IS INITIAL.
**   sort sequence = matnr werks charg
*    READ TABLE bestand
*      WITH KEY  matnr = g_s_bestand_key-matnr
*                werks = g_s_bestand_key-werks
*                charg = g_s_bestand_key-charg
*                             BINARY SEARCH.
*
*  ELSE.
**   sort sequence = matnr bwkey
*    READ TABLE bestand
*      WITH KEY  matnr = g_s_bestand_key-matnr
*                bwkey = g_s_bestand_key-bwkey
*                             BINARY SEARCH.
*  ENDIF.
*
*  IF sy-subrc IS INITIAL.
*    MOVE-CORRESPONDING bestand     TO  g_s_bestand_detail.
*    APPEND  g_s_bestand_detail     TO  g_t_bestand_detail.
*
*    PERFORM                  create_table_for_detail.
*
*    PERFORM                  list_output_detail.
*  ENDIF.
*
*ENDFORM.                     " USER_COMMAND_TOTALS
*
**&---------------------------------------------------------------------*
** list_output_detail
**&---------------------------------------------------------------------*
*
*FORM list_output_detail.
*
** build the auxiliary interface tables for the ALV
*
*  IF  g_cust_color = 'X'.              "colorize numeric fields ?
*    layout-coltab_fieldname = 'FARBE_PRO_FELD'.
*  ELSE.
*    layout-info_fieldname   = 'FARBE_PRO_ZEILE'.
*  ENDIF.
*
*  layout-f2code = '9PBP'.
*
*  IF NOT bwbst IS INITIAL.
*    layout-min_linesize = '92'.
*  ENDIF.
*
*  events-name = 'TOP_OF_PAGE'.
*  events-form = 'UEBERSCHRIFT_DETAIL'.
*  APPEND events.
*
*                                                   "n921164
*
**  IF gv_ui_opt_active = abap_false OR p_grid = abap_false   "1790231
**     OR pa_sumfl = space.                                   "1790231
*    CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
*      EXPORTING
*        i_interface_check        = g_flag_i_check             "n599218
*        i_callback_program       = repid
*        i_callback_pf_status_set = 'STATUS'
*        i_callback_user_command  = 'USER_COMMAND'
*        is_layout                = layout
*        it_fieldcat              = fieldcat[]
*        it_special_groups        = gruppen[]
*        it_sort                  = sorttab[]
*        i_default                = 'X'
*        i_save                   = 'A'
*        is_variant               = variante
*        it_events                = events[]
*        is_print                 = g_s_print
*      TABLES
*        t_outtab                 = g_t_belege1
*      EXCEPTIONS
*        OTHERS                   = 2.
*
**  ELSE.                                                     "1790231
**                                                            "1790231
**    CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'                  "1790231
**      EXPORTING                                             "1790231
**        i_interface_check        = g_flag_i_check
**        i_callback_program       = repid
**        i_callback_pf_status_set = 'STATUS'
**        i_callback_user_command  = 'USER_COMMAND'
**        is_layout                = layout
**        it_fieldcat              = fieldcat[]
**        it_special_groups        = gruppen[]
**        it_sort                  = sorttab[]
**        i_default                = 'X'
**        i_save                   = 'A'
**        is_variant               = variante
**        it_events                = events[]
**        is_print                 = g_s_print
**      TABLES
**        t_outtab                 = g_t_belege1
**      EXCEPTIONS
**        OTHERS                   = 2.                       "1790231
**                                                            "1790231
**  ENDIF.                                                    "1790231
*
** does the ALV return with an error ?
*  IF  NOT sy-subrc IS INITIAL.         "Fehler vom ALV ?
*    MESSAGE ID sy-msgid TYPE  'S'     NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*  ENDIF.
*
*ENDFORM.                     " list_output_detail
*
**&---------------------------------------------------------------------*
**&   TOP_OF_PAGE_TOTALS
**&---------------------------------------------------------------------*
*
*FORM top_of_page_totals.                                    "#EC CALLED
*
** go on when the report runs in print mode -> last line
*  CHECK NOT sy-prdsn IS INITIAL.
*
*  DATA: lr_content TYPE REF TO cl_salv_form_element.
*
**... (1) create the information to be displayed by using
**        the ALV Form elements
*  PERFORM top_of_page_totals_render  CHANGING lr_content.
*
**... (2) Sending the information to the ALV
**        Once the inforation to be displayed has been
**        created the information has to be sent to the ALV
**        This is done by calling the static method
**        CL_SALV_FORM_CONTENT=>SET( <content> ) with the content
**        which is to be displayed.
**        Alternativly the function module REUSE_ALV_COMMENTARY_WRITE
**        can still be used.
*  cl_salv_form_content=>set( lr_content ).
*
*ENDFORM.                     "TOP_OF_PAGE_TOTALS
*
**&---------------------------------------------------------------------*
**&   TOP_OF_PAGE_TOTALS_RENDER
**&---------------------------------------------------------------------*
*
*FORM top_of_page_totals_render
*         CHANGING cr_content TYPE REF TO cl_salv_form_element.
*
*  DATA: lr_grid      TYPE REF TO cl_salv_form_layout_grid,
*        lr_flow      TYPE REF TO cl_salv_form_layout_flow,
*        l_text(500)  TYPE c,
*        l_char(500)  TYPE c.
*
**... create a grid
*  CREATE OBJECT lr_grid.
*
*  lr_flow = lr_grid->create_flow( row = 1  column = 1 ).
*
*  IF  bwbst IS INITIAL.                                     "n599218
**   stocks only                                             "n599218
*    WRITE : sy-pagno NO-SIGN      TO  g_s_header_77-page.   "n599218
*    MOVE  : g_s_header_77         TO  l_text.
*  ELSE.                                                     "n599218
**   stocks and values                                       "n599218
*    WRITE : sy-pagno NO-SIGN      TO  g_s_header_91-page.   "n599218
*    MOVE  : g_s_header_91         TO  l_text.               "n599218
*  ENDIF.                                                    "n599218
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** copy whole header object
*  cr_content = lr_grid.
*
*ENDFORM.                     " TOP_OF_PAGE_TOTALS_RENDER
*
**----------------------------------------------------------------------*
** top_of_page_render.
**----------------------------------------------------------------------*
*
*FORM top_of_page_render.
*
** interface structurebegin of g_s_bestand.
*
*  DATA: lr_content TYPE REF TO cl_salv_form_element.
*
**... (1) create the information to be displayed by using
**        the ALV Form elements
*  PERFORM create_alv_form_content_top CHANGING lr_content.
*
**... (2) Sending the information to the ALV
**        Once the inforation to be displayed has been
**        created the information has to be sent to the ALV
**        This is done by calling the static method
**        CL_SALV_FORM_CONTENT=>SET( <content> ) with the content
**        which is to be displayed.
**        Alternativly the function module REUSE_ALV_COMMENTARY_WRITE
**        can still be used.
*  cl_salv_form_content=>set( lr_content ).
*
*ENDFORM.                     " top_of_page_render
*
**----------------------------------------------------------------------*
** create_alv_form_content_top
**----------------------------------------------------------------------*
** baustelle
*
*FORM create_alv_form_content_top
*                   CHANGING cr_content TYPE REF TO cl_salv_form_element.
*
*  DATA: lr_grid      TYPE REF TO cl_salv_form_layout_grid,
*        lr_flow      TYPE REF TO cl_salv_form_layout_flow,
*        l_text(500)  TYPE c,
*        l_char(500)  TYPE c.
*
*  DATA: l_row          TYPE i,
*        l_figure(24)   TYPE c,
*        l_flag_tied_empties(01)   TYPE c.
*
*  DATA: l_f_text(60)        TYPE  c.                        "n999530
*
**----------------------------------------------------------------------*
*
*
**... create a grid
*  CREATE OBJECT lr_grid.
*
** the current data are in interface structure g_s_bestand.
*
** in the case the report run in print or background mode
** --> print the old headlines
*
*  IF NOT sy-prdsn IS INITIAL.
*    ADD  1                    TO  l_row.
*    lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*    IF  bwbst IS INITIAL.
**     stocks only
*      WRITE : sy-pagno NO-SIGN    TO  g_s_header_77-page.
*      MOVE  : g_s_header_77       TO  l_text.
*    ELSE.
**     stocks and values
*      WRITE : sy-pagno NO-SIGN    TO  g_s_header_91-page.
*      MOVE  : g_s_header_91       TO  l_text.
*    ENDIF.
*
**   add line to object
*    lr_flow->create_text( text = l_text ).
*
*    ADD  1                    TO  l_row.
*  ENDIF.
*
** first line : plant or valuation area ---------------------------------
*  ADD  1                    TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  IF  bwbst IS INITIAL.
*    PERFORM  f2200_read_t001 USING g_s_bestand-werks.       "n999530
*
*    WRITE g_s_bestand-werks  TO l_f_text.                   "n999530
*    CONDENSE l_f_text.                                      "n999530
*    CONCATENATE l_f_text     t001w-name1                    "n999530
*                             INTO  l_f_text                 "n999530
*                             SEPARATED BY space.            "n999530
*
*    MOVE : text-020          TO  l_text,
*           l_f_text          TO  l_text+g_offset_header.    "n999530
*  ELSE.
**   show valuation area
*    MOVE : text-025          TO  l_text,
*           g_s_bestand-bwkey TO  l_text+g_offset_header.
*  ENDIF.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** second line : material number ----------------------------------------
*  ADD   1                    TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  MOVE  : text-021           TO  l_text.
*  WRITE : g_s_bestand-matnr  TO  l_text+g_offset_header.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** third line : material short text -------------------------------------
*  ADD   1                    TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  PERFORM  f2100_mat_text    USING  g_s_bestand-matnr.
*
*  MOVE : text-022            TO  l_text,
*         g_s_makt-maktx      TO  l_text+g_offset_header.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** fourth line : batch if required --------------------------------------
**  IF xchar = 'X'.
**    ADD   1                  TO  l_row.
**    lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
**
**    MOVE : text-023           TO  l_text,
**           g_s_bestand-charg  TO  l_text+g_offset_header.
**
***   add line to object
**    lr_flow->create_text( text = l_text ).
**  ENDIF.
*
** line : stock and value on start date ------------------------------
** with one empty line
*  ADD  2                     TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
** convert unit of measurement from internal to external format "n1018717
*  WRITE : g_s_bestand-meins       TO  l_f_meins_external.   "n1018717
*
*  CLEAR                           l_text.
*  IF bwbst IS INITIAL.
**   stock on start date
*    MOVE : g_date_line_from       TO  l_text.
*    WRITE  g_s_bestand-anfmenge   TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external     TO  l_text+g_offset_unit.  "n1018717
*
*  ELSE.
** stocks and values on start date
*    MOVE : g_date_line_from       TO  l_text.
*    WRITE  g_s_bestand-anfmenge   TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external     TO  l_text+g_offset_unit.  "n1018717
*
*
*    WRITE g_s_bestand-anfwert     TO l_figure
*                                  CURRENCY  g_s_bestand-waers.
*    MOVE  l_figure                TO  l_text+g_offset_value(24).
*    MOVE  g_s_bestand-waers       TO  l_text+g_offset_curr.
*  ENDIF.
*
**   add line to object
*  lr_flow->create_text( text = l_text ).
*
** line : total quantity and value of goods receipts --------------------
*  ADD  1                     TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  CLEAR                           l_text.
*
*  IF bwbst IS INITIAL.
**   total quantities of goods receipts
*    MOVE : text-005               TO  l_text+2.
*    WRITE  g_s_bestand-soll       TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*
*  ELSE.
**   total quantities and values of goods receipts
*    MOVE : text-030               TO  l_text+2.
*    WRITE  g_s_bestand-soll       TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*
*
*    WRITE g_s_bestand-sollwert     TO l_figure
*                                  CURRENCY  g_s_bestand-waers.
*    MOVE  l_figure                TO  l_text+g_offset_value(24).
*    MOVE  g_s_bestand-waers       TO  l_text+g_offset_curr.
*  ENDIF.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** line : total quantity and value of goods issues ----------------------
*  ADD  1                     TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  CLEAR                           l_text.
*
*  IF bwbst IS INITIAL.
**   total quantities of goods issues
*    MOVE : text-006               TO  l_text+2.
*    COMPUTE  g_s_bestand-haben    =  g_s_bestand-haben * -1.
*    WRITE  g_s_bestand-haben      TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*
*  ELSE.
**   total quantities of goods issues
*    MOVE : text-031               TO  l_text+2.
*    COMPUTE  g_s_bestand-haben    =  g_s_bestand-haben * -1.
*    WRITE  g_s_bestand-haben      TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*
*    COMPUTE g_s_bestand-habenwert  =  g_s_bestand-habenwert * -1.
*    WRITE g_s_bestand-habenwert   TO l_figure
*                                  CURRENCY  g_s_bestand-waers.
*    MOVE  l_figure                TO  l_text+g_offset_value(24).
*    MOVE  g_s_bestand-waers       TO  l_text+g_offset_curr.
*  ENDIF.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** line : stock and value on end date ------------------------------
*  ADD  1                     TO  l_row.
*  lr_flow = lr_grid->create_flow( row = l_row  column = 1 ).
*
*  CLEAR                           l_text.
*
*  IF bwbst IS INITIAL.
**   stock on end date
*    MOVE : g_date_line_to         TO  l_text.
*    WRITE  g_s_bestand-endmenge   TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*    ELSE.
** stocks and values on end date
*    MOVE : g_date_line_to         TO  l_text.
*    WRITE  g_s_bestand-endmenge   TO l_figure
*                                  UNIT  g_s_bestand-meins.
*    MOVE  l_figure                TO  l_text+g_offset_qty(24).
**   move  g_s_bestand-meins       to  l_text+g_offset_unit.    "n1018717
*    MOVE  l_f_meins_external      TO  l_text+g_offset_unit. "n1018717
*    WRITE g_s_bestand-endwert     TO l_figure
*                                  CURRENCY  g_s_bestand-waers.
*    MOVE  l_figure                TO  l_text+g_offset_value(24).
*    MOVE  g_s_bestand-waers       TO  l_text+g_offset_curr.
*  ENDIF.
*
** add line to object
*  lr_flow->create_text( text = l_text ).
*
** copy whole header object
*  cr_content = lr_grid.
*
*ENDFORM.                    " create_alv_form_content_top
*
*FORM create_table_for_detail.
*
*  STATICS : l_flag_sorted(01)     TYPE  c.
*  DATA    : l_tabix               LIKE  sy-tabix.
*
*  IF gv_newdb = abap_true.
**   read it134m from db in form kontiert_aussortieren      "1784986v2!
*    REFRESH g_t_mseg_lean.
*    REFRESH matnr.
*    matnr-sign = 'I'.
*    matnr-option = 'EQ'.
*    matnr-low = g_s_bestand_detail-matnr.
*    matnr-high = space.
*    APPEND matnr.
*    PERFORM f1000_select_mseg_mkpf.
*    PERFORM belege_sortieren.
*    PERFORM summen_bilden.                                  "1784986
*    SELECT matnr meins mtart FROM mara                      "1784986
*      INTO CORRESPONDING FIELDS OF TABLE imara              "1784986
*      WHERE  matnr  =  g_s_bestand_detail-matnr             "1784986
*      ORDER BY PRIMARY KEY.                                 "1858578
*    PERFORM kontiert_aussortieren.                          "1784986
*    CLEAR l_flag_sorted.
*  ENDIF.
*
** sort table with the documents
*  IF  l_flag_sorted IS INITIAL.
*    SORT  g_t_mseg_lean
*      BY matnr werks charg budat mblnr zeile belnr.
*    MOVE  'X'                TO  l_flag_sorted.
*  ENDIF.
*
*  REFRESH                    g_t_belege1.
*
** find the first entry with this material number
*  READ TABLE g_t_mseg_lean   INTO  g_s_mseg_lean
*    WITH KEY matnr = g_s_bestand_detail-matnr
*      BINARY SEARCH.
*
*  IF  sy-subrc IS INITIAL.
*    MOVE  sy-tabix           TO  l_tabix.
*
*    LOOP AT g_t_mseg_lean   INTO  g_s_mseg_lean
*                             FROM l_tabix.
*
**     leave this loop when the material number changes
*      IF  g_s_mseg_lean-matnr  NE  g_s_bestand_detail-matnr.
*        EXIT.
*      ENDIF.
*
*      IF  bwbst IS INITIAL.
*        CHECK : g_s_mseg_lean-werks = bestand-werks.        "n1390970
*        MOVE-CORRESPONDING g_s_mseg_lean
*                             TO  g_t_belege1.
*
**       enrich some fields with color and numeric fields with sign
*        PERFORM  f9500_set_color_and_sign
*                       USING  g_t_belege1  'G_T_BELEGE1'.
*        APPEND                g_t_belege1.
*      ELSE.
**       get the valuation area for this plant
*        PERFORM  f9300_read_organ
*                   USING     c_werks   g_s_mseg_lean-werks.
*
*        CHECK : g_s_organ-bwkey = bestand-bwkey.            "184465
*        MOVE-CORRESPONDING  g_s_mseg_lean
*                             TO  g_t_belege1.
*
**       enrich some fields with color and numeric fields with sign
*        PERFORM  f9500_set_color_and_sign
*                       USING  g_t_belege1  'G_T_BELEGE1'.
*
*        APPEND               g_t_belege1.
*      ENDIF.
*    ENDLOOP.
*  ENDIF.
*
*ENDFORM.                     " create_table_for_detail
*
*FORM f2100_mat_text
*                   USING     l_f_matnr TYPE stype_mat_key-matnr.
*
*  IF  l_f_matnr  NE  g_s_makt-matnr.                        "n451923
**   read in table imakt                                     "n451923
*    READ TABLE g_t_makt      INTO  g_s_makt                 "n451923
*                             WITH KEY matnr = l_f_matnr     "n451923
*                             BINARY SEARCH.                 "n451923
*                                                            "n451923
*    IF  sy-subrc <> 0.                                      "n451923
**     record not found                                      "n451923
*      CLEAR                  g_s_makt-maktx.                "n451923
*    ENDIF.                                                  "n451923
*  ENDIF.                                                    "n451923
*
*ENDFORM.                     "f2100_mat_text
*
**----------------------------------------------------------------------*
**    F2200_READ_T001
**----------------------------------------------------------------------*
*
*FORM f2200_read_t001
*                   USING     l_f_werks LIKE t001w-werks.
*
*  STATICS : BEGIN OF l_s_t001w,                             "n999530
*              werks          TYPE  t001w-werks,             "n999530
*              name1          TYPE  t001w-name1,             "n999530
*            END OF l_s_t001w.                               "n999530
*
** read name of this plant after the plant has changed       "n999530
*  IF  l_f_werks <> l_s_t001w-werks.                         "n999530
*    SELECT SINGLE werks name1                               "n999530
*      FROM t001w                                            "n999530
*        INTO CORRESPONDING FIELDS OF l_s_t001w              "n999530
*          WHERE werks = l_f_werks.                         "n1574925
*
*    IF NOT sy-subrc IS INITIAL.                             "n999530
*      CLEAR                  l_s_t001w.                     "n999530
*      MOVE  l_f_werks        TO  l_s_t001w-werks.           "n999530
*    ENDIF.                                                  "n999530
*  ENDIF.                                                    "n999530
*
*  MOVE  l_s_t001w-name1      TO  t001w-name1.               "n999530
*
*ENDFORM.                     "f2200_read_t001
*
*FORM alv_flat_list_sums_only.
*
*  DATA: lv_lvc_s_glay TYPE lvc_s_glay.                      "1790231
*
** assign the form routines to the events
*  MOVE :  'PF_STATUS_SET'         TO  g_t_events_totals_flat-name,
*          'PF_STATUS_SET_TOTALS'  TO  g_t_events_totals_flat-form.
*  APPEND                              g_t_events_totals_flat.
*
*  MOVE :  'USER_COMMAND'          TO  g_t_events_totals_flat-name,
*          'USER_COMMAND_TOTALS'   TO  g_t_events_totals_flat-form.
*  APPEND                              g_t_events_totals_flat.
*
*  MOVE : 'TOP_OF_PAGE'            TO  g_t_events_totals_flat-name,
*         'TOP_OF_PAGE_TOTALS'     TO  g_t_events_totals_flat-form.
*  APPEND                              g_t_events_totals_flat.
*
*  MOVE :       'END_OF_LIST'      TO  g_t_events_totals_flat-name,
*         'PRINT_END_OF_LIST'      TO  g_t_events_totals_flat-form.
*  APPEND                              g_t_events_totals_flat.
*
** handling for double click
*  g_s_layout_totals_flat-f2code           = '9PBP'.
*  g_s_layout_totals_flat-coltab_fieldname = 'COLOR'.
*
*                                               "n921164
*
** liste aufbauen
**  IF gv_ui_opt_active = abap_false OR p_grid = abap_false.  "1790231
*
*    CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
*      EXPORTING
*        i_interface_check  = g_flag_i_check
*        i_callback_program = repid
*        is_layout          = g_s_layout_totals_flat
*        it_fieldcat        = g_t_fieldcat_totals_flat[]
**        it_sort            = g_t_sorttab
*        i_default          = 'X'  "allow default variant
*        i_save             = 'A'
**        is_variant         = g_s_vari_sumfl
*        it_events          = g_t_events_totals_flat[]
*        is_print           = g_s_print
*      TABLES
*        t_outtab           = g_t_totals_flat
*      EXCEPTIONS
*        OTHERS             = 1.
*
**  ELSE.                                                     "1790231
**    lv_lvc_s_glay-coll_top_p = abap_true.                   "1790231
**    CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'                  "1790231
**      EXPORTING                                             "1790231
**        i_interface_check  = g_flag_i_check
**        i_callback_program = repid
**        i_grid_settings    = lv_lvc_s_glay
**        is_layout          = g_s_layout_totals_flat
**        it_fieldcat        = g_t_fieldcat_totals_flat[]
**        it_sort            = g_t_sorttab
**        i_default          = 'X'  "allow default variant
**        i_save             = 'A'
**        is_variant         = g_s_vari_sumfl
**        it_events          = g_t_events_totals_flat[]
**        is_print           = g_s_print
**      TABLES
**        t_outtab           = g_t_totals_flat
**      EXCEPTIONS
**        OTHERS             = 1.                             "1790231
**                                                            "1790231
**  ENDIF.                                                    "1790231
*
*
*  IF sy-subrc NE 0.
*    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*       WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*  ENDIF.
*
*ENDFORM.                     "alv_flat_list_sums_only
