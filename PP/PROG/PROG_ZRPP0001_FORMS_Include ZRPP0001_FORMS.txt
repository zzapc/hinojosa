*&---------------------------------------------------------------------*
*&  Include           ZRPP0001_FORMS
*&---------------------------------------------------------------------*

*&----------------------------------------------------------------*
*&      Form  CALC_FECH_FIN
*&----------------------------------------------------------------*
*       text
*-----------------------------------------------------------------*
*      -->P_LS_DATOS_PED_MBDAT  text
*      <--P_LS_DATOS_PED_FFIN  text
*-----------------------------------------------------------------*
FORM calc_fech_fin  USING    p_mbdat
                             p_ebeln
                             p_ebelp
                    CHANGING p_ffin.

  DATA: lv_route     TYPE route,
        lv_vstel     TYPE vstel,
        lv_fahztd    TYPE fahztd,
        lv_fahztd_s  TYPE i,
        lv_loadt     TYPE loadtn,
        lv_loadt_s   TYPE i,
        lv_pipatn    TYPE pipatn,
        lv_pipatn_s  TYPE i,
        lv_fabkl     TYPE fabkl,
        lv_fabkl_s   TYPE i,
        lv_time_sec  TYPE i,
        lv_time_days TYPE i.

  CLEAR: lv_route, lv_vstel, lv_fahztd, lv_loadt, lv_pipatn.
  CLEAR: lv_pipatn.
  CLEAR: lv_fahztd_s, lv_loadt_s, lv_pipatn_s, lv_pipatn_s.
  CLEAR: lv_time_days.

  SELECT SINGLE route vstel INTO (lv_route, lv_vstel)
    FROM ekpv
    WHERE ebeln = p_ebeln
    AND ebelp = p_ebelp.

  " Horas ruta:
  IF lv_route IS NOT INITIAL.
    SELECT SINGLE fahztd INTO lv_fahztd
      FROM tvro
      WHERE route = lv_route.
    PERFORM time_sec USING lv_fahztd
                     CHANGING lv_fahztd_s.
  ENDIF.

  " Horas de carga, picking y packing:
  IF lv_vstel IS NOT INITIAL.
    SELECT SINGLE loadtn pipatn fabkl
      INTO (lv_loadt, lv_pipatn, lv_fabkl)
      FROM tvst
      WHERE vstel = lv_vstel.
    PERFORM time_sec USING lv_loadt
                 CHANGING lv_loadt_s.
    PERFORM time_sec USING lv_pipatn
                 CHANGING lv_pipatn_s.
  ENDIF.

  " Pasar el tiempo en segundos:
  CLEAR lv_time_sec.
  lv_time_sec = lv_fahztd_s + lv_loadt_s + lv_pipatn_s.
  lv_time_days = lv_time_sec / ( 3600 * 24 ).

  p_ffin = p_mbdat - lv_time_days.

  IF lv_fabkl IS NOT INITIAL.
    CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
      EXPORTING
        i_date         = p_ffin
        i_calendar1    = lv_fabkl
*       I_CALENDAR2    =
      IMPORTING
        e_workday      = p_ffin
      EXCEPTIONS
        calendar_error = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
  ENDIF.

ENDFORM.                    " CALC_FECH_FIN
*&----------------------------------------------------------------*
*&      Form  TIME_SEC
*&----------------------------------------------------------------*
*       text
*-----------------------------------------------------------------*
*      -->P_LV_FAHZTD  text
*      <--P_LV_FAHZTD_S  text
*-----------------------------------------------------------------*
FORM time_sec  USING    p_horas
               CHANGING p_seg.

  DATA: lv_formato TYPE i,
        lv_horas   TYPE p DECIMALS 4,
        lv_horas_i TYPE i,
        lv_horas_d TYPE i,
        lv_min     TYPE p DECIMALS 2,
        lv_min_i   TYPE i,
        lv_seg     TYPE i.

  CLEAR: lv_horas, lv_horas_i, lv_horas_d, lv_min.
  CLEAR: lv_min_i, lv_seg, lv_formato.

  lv_formato = p_horas.

  " Horas:
  lv_horas = lv_formato / 10000.
  lv_horas_i = trunc( lv_horas ).
  lv_horas_d = frac( lv_horas ).

  " Minutos:
  lv_min = lv_horas_d / 100.
  lv_min_i = trunc( lv_min ).
  lv_seg = frac( lv_min ).

  " Cálculo en segundos:
  p_seg = lv_horas_i * 3600 + lv_min_i * 60 + lv_seg.

ENDFORM.                    " TIME_SEC
*&---------------------------------------------------------------------*
*&      Form  DATOS_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_PED_WMENG  text
*      -->P_LS_DATOS_PED_MATNR  text
*      -->P_LS_DATOS_PED_WERKS  text
*      <--P_LS_DATOS_PED_IDNRK  text
*      <--P_LS_DATOS_PED_MNGLG  text
*      <--P_LS_DATOS_PED_MMEIN  text
*      <--P_LS_DATOS_PED_ZZGRAMAJE  text
*      <--P_LS_DATOS_PED_ZZANCHO  text
*      <--P_LS_DATOS_PED_MATKL  text
*----------------------------------------------------------------------*
FORM datos_rollo  USING    p_wmeng
                           p_matnr
                           p_werks
                  CHANGING p_idnrk
                           p_mnglg
                           p_mmein
                           p_zzgramaje
                           p_zzancho
                           p_matkl
                           p_maktx.

  DATA: lt_stb   TYPE stpox OCCURS 0 WITH HEADER LINE,
        "type roij_stpox_t,
        ls_stb   TYPE stpox,
        lv_datuv LIKE stko-datuv,
        lv_emeng LIKE stko-bmeng,
        lv_mtnrv LIKE mara-matnr,
        lv_werks LIKE marc-werks.

  CLEAR: lt_stb, ls_stb.
  REFRESH: lt_stb.

  CLEAR: lv_datuv, lv_emeng, lv_mtnrv,lv_werks.
  lv_datuv = sy-datum.
  lv_emeng = p_wmeng.
  lv_mtnrv = p_matnr.
  lv_werks = p_werks.

  " Recuperar datos para la orden de rollo:

  CALL FUNCTION 'CS_BOM_EXPL_MAT_V2'
    EXPORTING
*     FTREL                 = ' '
*     ALEKZ                 = ' '
*     ALTVO                 = ' '
*     AUFSW                 = ' '
      aumgb                 = 'X'
*     AUMNG                 = 0
*     AUSKZ                 = ' '
*     AMIND                 = ' '
*     BAGRP                 = ' '
*     BEIKZ                 = ' '
*     BESSL                 = ' '
*     BGIXO                 = ' '
*     BREMS                 = ' '
      capid                 = 'PI01'
*     CHLST                 = ' '
*     COSPR                 = ' '
*     CUOBJ                 = 000000000000000
*     CUOVS                 = 0
*     CUOLS                 = ' '
      datuv                 = lv_datuv "sy-datum
*     DELNL                 = ' '
*     DRLDT                 = ' '
      ehndl                 = 'X'
      emeng                 = lv_emeng " p_wmeng
*     ERSKZ                 = ' '
*     ERSSL                 = ' '
*     FBSTP                 = ' '
*     KNFBA                 = ' '
*     KSBVO                 = ' '
*     MBWLS                 = ' '
*     MKTLS                 = 'X'
*     MDMPS                 = ' '
      mehrs                 = '1'
*     MKMAT                 = ' '
*     MMAPS                 = ' '
*     SALWW                 = ' '
*     SPLWW                 = ' '
      mmory                 = '1'
      mtnrv                 = lv_mtnrv "p_matnr
*     NLINK                 = ' '
*     POSTP                 = ' '
*     RNDKZ                 = ' '
*     RVREL                 = ' '
*     SANFR                 = ' '
*     SANIN                 = ' '
*     SANKA                 = ' '
*     SANKO                 = ' '
*     SANVS                 = ' '
*     SCHGT                 = ' '
*     STKKZ                 = ' '
      stlal                 = '01'
      stlan                 = '1'
      stpst                 = 0
      svwvo                 = 'X'
      werks                 = lv_werks "p_werks
*     NORVL                 = ' '
*     MDNOT                 = ' '
*     PANOT                 = ' '
*     QVERW                 = ' '
*     VERID                 = ' '
      vrsvo                 = 'X'
* IMPORTING
*     TOPMAT                =
*     DSTST                 =
    TABLES
      stb                   = lt_stb
*     MATCAT                =
    EXCEPTIONS
      alt_not_found         = 1
      call_invalid          = 2
      material_not_found    = 3
      missing_authorization = 4
      no_bom_found          = 5
      no_plant_data         = 6
      no_suitable_bom_found = 7
      conversion_error      = 8
      OTHERS                = 9.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ELSEIF lt_stb[] IS NOT INITIAL.
    LOOP AT lt_stb INTO ls_stb WHERE sortf = 'ROLLO'.
      p_idnrk = ls_stb-idnrk.
      p_mnglg = ls_stb-mnglg.
      p_mmein = ls_stb-mmein.
    ENDLOOP.
  ENDIF.

  " Recuperar datos de rollo para secuenciación:
  IF p_idnrk IS NOT INITIAL.
    SELECT SINGLE zzgramaje zzancho matkl
      INTO (p_zzgramaje, p_zzancho, p_matkl)
      FROM mara
      WHERE matnr = p_idnrk.
    SELECT SINGLE maktx INTO p_maktx
      FROM makt
      WHERE matnr =  p_idnrk
      AND spras = sy-langu.
  ENDIF.

ENDFORM.                    " DATOS_ROLLO
*&----------------------------------------------------------------*
*&      Form  SEC_TOTAL
*&----------------------------------------------------------------*
*       text
*-----------------------------------------------------------------*
*      <--P_LV_SENTIDO  text
*      <--P_LV_ESCALON  text
*-----------------------------------------------------------------*
FORM sec_actual USING p_esc_max
                      p_esc_min
                CHANGING p_sentido
                         p_escalon.

  DATA: lv_fini           TYPE budat,
        lv_ffin           TYPE budat,
        lv_escalon        TYPE zindice_prod,
        lv_escalon_aux    TYPE zindice_prod,
        lv_sentido_aux(1),
        lv_esc_max        TYPE zindice_prod,
        lv_esc_min        TYPE zindice_prod.

  DATA: BEGIN OF lt_aufm OCCURS 0,
          budat LIKE aufm-budat,
          mblnr LIKE aufm-mblnr,
          mjahr LIKE aufm-mjahr,
          bwart LIKE aufm-bwart,
          matnr LIKE aufm-matnr,
          aufnr LIKE aufm-aufnr,
          auart LIKE aufk-auart,
        END OF lt_aufm.
  DATA: ls_aufm LIKE LINE OF lt_aufm.

  " Seleccionamos todos los movimientos '101' de la última semana:

  CLEAR: lt_aufm, ls_aufm, lv_fini, lv_ffin, lv_sentido_aux.
  REFRESH: lt_aufm.

  lv_ffin = sy-datum.
  lv_fini = sy-datum - 7 + 1.

  SELECT a~budat a~mblnr a~mjahr a~bwart a~matnr a~aufnr b~auart
    INTO TABLE lt_aufm
    FROM aufm AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN jest AS c ON c~objnr = b~objnr
    WHERE b~auart = 'ZI01'
    AND a~bwart = '101'
    AND ( a~budat <= lv_ffin AND a~budat >= lv_fini )
    AND ( c~stat = 'I0002' OR c~stat = 'I0045' )
    AND c~inact = ' '.

  SORT lt_aufm BY budat DESCENDING
                  mblnr DESCENDING
                  mjahr DESCENDING.

  DELETE ADJACENT DUPLICATES FROM lt_aufm.

  " Recuperar valor de último escalón de producción:
  CLEAR lv_escalon.
  READ TABLE lt_aufm INTO ls_aufm INDEX 1.
  IF ls_aufm IS NOT INITIAL.
    PERFORM calc_escalon_2 USING ls_aufm-matnr
                       CHANGING lv_escalon.
    p_escalon = lv_escalon.
  ENDIF.

  LOOP AT lt_aufm INTO ls_aufm.
    CLEAR lv_escalon_aux.
    PERFORM calc_escalon_2 USING ls_aufm-matnr
                         CHANGING lv_escalon_aux.

    IF lv_escalon_aux < lv_escalon AND lv_escalon NE p_esc_max.
      " Ascendente
      p_sentido = 'A'.
      EXIT.
    ELSEIF lv_escalon_aux < lv_escalon AND lv_escalon EQ p_esc_max.
      " Descendente
      p_sentido = 'D'.
      EXIT.
    ELSEIF lv_escalon_aux > lv_escalon AND lv_escalon NE p_esc_min.
      " Descendente
      p_sentido = 'D'.
      EXIT.
    ELSEIF lv_escalon_aux > lv_escalon AND lv_escalon EQ p_esc_min.
      " Ascendente
      p_sentido = 'A'.
      EXIT.
    ELSE.
      p_sentido = 'A'.
    ENDIF.
  ENDLOOP.

  IF p_sentido IS INITIAL.
    p_sentido = 'A'.
  ENDIF.

  IF p_escalon IS INITIAL.
    p_escalon = '1'.
  ENDIF.

ENDFORM.                    " SEC_TOTAL
*&-------------------------------------------------------------------*
*&      Form  CALC_ESCALON
*&-------------------------------------------------------------------*
*       text
*--------------------------------------------------------------------*
*      -->P_LS_AUFM_MATNR  text
*      <--P_LV_ESCALON  text
*--------------------------------------------------------------------*
FORM calc_escalon  USING    p_idnrk
                            p_zzgramaje
                            p_zzancho
                            p_matkl
                   CHANGING p_escalon.

  DATA: lv_ind_prod TYPE zindice_prod.

  CLEAR lv_ind_prod.

  SELECT SINGLE indice_prod INTO lv_ind_prod
  FROM ztpp0001
  WHERE matkl = p_matkl
  AND gramaje = p_zzgramaje
  AND ancho = p_zzancho.

  p_escalon = lv_ind_prod.

ENDFORM.                    " CALC_ESCALON

*&---------------------------------------------------------------------*
*&      Form  CALC_ESCALON_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_AUFM_MATNR  text
*      <--P_LV_ESCALON  text
*----------------------------------------------------------------------*
FORM calc_escalon_2  USING    p_matnr
                     CHANGING p_escalon.

  DATA: lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho,
        lv_matkl     TYPE matkl.

  CLEAR: lv_zzgramaje, lv_zzancho, lv_matkl.

  SELECT SINGLE zzgramaje zzancho matkl INTO (lv_zzgramaje, lv_zzancho, lv_matkl)
  FROM mara
  WHERE matnr = p_matnr.

  SELECT SINGLE indice_prod INTO p_escalon
  FROM ztpp0001
  WHERE matkl = lv_matkl
  AND gramaje = lv_zzgramaje
  AND ancho = lv_zzancho.

ENDFORM.                    " CALC_ESCALON_2
*&---------------------------------------------------------------------*
*&      Form  MIN_MAX_SEC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_MAX  text
*      <--P_LV_MIN  text
*----------------------------------------------------------------------*
FORM min_max_sec  CHANGING p_max_esc
                           p_min_esc.

* Máximo escalón:

  SELECT MAX( indice_prod )
    FROM ztpp0001
    INTO p_max_esc.

* Mínimo escalón:

  SELECT MIN( indice_prod )
    FROM ztpp0001
    INTO p_min_esc.

ENDFORM.                    " MIN_MAX_SEC
*&---------------------------------------------------------------------*
*&      Form  DAT_ROLLO_TORN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_DATOS_PEDIDOS_WMENG  text
*      -->P_LV_ANCHO_BOB  text
*      <--P_LV_ROL1  text
*      <--P_LV_TOR1  text
*      <--P_LV_ROL2  text
*      <--P_LV_TOR2  text
*----------------------------------------------------------------------*
FORM dat_rollo_torn  USING    p_wmeng
                              p_ancho_bob
                     CHANGING p_rol1
                              p_tor1
                              p_rol2
                              p_tor2.

  DATA: ls_ztpp0002 TYPE ztpp0002.

  CLEAR ls_ztpp0002.
  SELECT SINGLE * INTO ls_ztpp0002
    FROM ztpp0002
    WHERE ancho = p_ancho_bob
    AND cantidad_de <= p_wmeng
    AND cantidad_hasta >= p_wmeng.

  p_rol1 = ls_ztpp0002-rollos1.
  p_tor1 = ls_ztpp0002-tor1.
  p_rol2 = ls_ztpp0002-rollos2.
  p_tor2 = ls_ztpp0002-tor2.

ENDFORM.                    " DAT_ROLLO_TORN
**&---------------------------------------------------------------------*
**&      Form  CALC_FEC_HORA
**&---------------------------------------------------------------------*
**       text
**----------------------------------------------------------------------*
**      -->P_PS_PEDIDOS_AUFNR_ROL  text
**      <--P_P_FECHA  text
**      <--P_P_HORA  text
**----------------------------------------------------------------------*
*FORM calc_fec_hora  USING    p_aufnr
*                    CHANGING p_fecha
*                             p_hora.
*
*  DATA: lv_fecha    TYPE co_gltrp,
*        lv_hora     TYPE co_gltrp,
*        lv_gltrp    TYPE co_gltrp,
*        lv_gluzp    TYPE co_gluzp,
*        lv_pedido   TYPE vbeln_va,
*        lv_posicion TYPE posnr_va,
*        lv_vstel    TYPE vstel,
*        lv_fabkl    TYPE fabkl.
*
*  CLEAR: lv_fecha, lv_hora, lv_gltrp, lv_gluzp, lv_pedido, lv_posicion, lv_vstel, lv_fabkl.
*
*  " Sacamos la fecha y hora fin extrema:
*
*  SELECT SINGLE gltrp gluzp INTO (lv_gltrp, lv_gluzp)
*    FROM caufv
*    WHERE aufnr = p_aufnr.
*
*  " Sacamos pedido/posición a que pertenece para sacar el calendario de fábrica:
*  SELECT SINGLE zebeln1 zebelp1 INTO (lv_pedido, lv_posicion)
*    FROM aufk
*    WHERE aufnr = p_aufnr.
*
*  IF lv_pedido IS NOT INITIAL AND lv_posicion IS NOT INITIAL.
*    SELECT SINGLE vstel INTO lv_vstel
*      FROM ekpv
*      WHERE ebeln = lv_pedido
*      AND ebelp = lv_posicion.
*
*    IF lv_vstel IS NOT INITIAL.
*      SELECT SINGLE fabkl INTO lv_fabkl
*        FROM tvst
*        WHERE vstel = lv_vstel.
*    ENDIF.
*  ENDIF.
*
*  " Cálculamos la siguiente fecha y hora de inicio disponibles:
*  IF lv_fabkl IS NOT INITIAL.
*    lv_hora = lv_gluzp + 1.
*    IF lv_hora = '000000'.
*      lv_fecha = lv_gltrp + 1.
*      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
*        EXPORTING
*          i_date         = lv_fecha
*          i_calendar1    = lv_fabkl
**         I_CALENDAR2    =
*        IMPORTING
*          e_workday      = lv_fecha
*        EXCEPTIONS
*          calendar_error = 1
*          OTHERS         = 2.
*      IF sy-subrc <> 0.
** Implement suitable error handling here
*      ENDIF.
*    ELSE.
*      lv_fecha = lv_gltrp.
*    ENDIF.
*  ELSE.
*    lv_hora = lv_gluzp + 1.
*    IF lv_hora = '000000'.
*      lv_fecha = lv_gltrp + 1.
*    ELSE.
*      lv_fecha = lv_gltrp.
*    ENDIF.
*  ENDIF.
*
*  " Pasamos los valores obtenidos a los parámetros:
*  p_fecha = lv_fecha.
*  p_hora = lv_hora.
*
*ENDFORM.                    " CALC_FEC_HORA
*&---------------------------------------------------------------------*
*&      Form  F_REC_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_datos .

  " Recuperar datos de pedidos:
  CLEAR: gt_datos_pedidos.
  REFRESH: gt_datos_pedidos.

  CLEAR: gt_listado1.
  REFRESH: gt_listado1.

  " DATOS PEDIDOS VENTAS:

  PERFORM f_recup_datos_ventas.

  " DATOS PEDIDOS COMPRAS:

  PERFORM f_recup_datos_compras.

  " Ordenación de la tabla por fecha de entrega/pedido/posición:

  SORT gt_datos_pedidos  BY mbdat ASCENDING
                            vbeln ASCENDING
                            posnr ASCENDING.

ENDFORM.                    " F_REC_DATOS
*&---------------------------------------------------------------------*
*&      Form  F_RECUP_DATOS_VENTAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_recup_datos_ventas .

  DATA: lt_vbep TYPE TABLE OF vbep.
  DATA: ls_vbep       TYPE vbep,
        ls_datos_ped  TYPE zspp_linea_pedidos,
        ls_datos_ped2 TYPE zspp_linea_pedidos,
        ls_vbap       TYPE vbap,
        ls_vbak       TYPE vbak.

  DATA: lv_spebe           TYPE spebe,
        lv_existe_rollo(1),
        lv_existe_bob(1),
        lv_aufnr_rol_aux   TYPE aufnr,
        lv_aufnr_bob_aux   TYPE aufnr,
        lv_seqnr           TYPE cy_seqnr.

  CLEAR lt_vbep.
  REFRESH lt_vbep.

  " Seleccionamos datos de ventas: (Sólo pongo que recoja el reparto '1')
  SELECT * FROM vbep INTO TABLE lt_vbep
    WHERE mbdat IN s_mbdat
    AND etenr = '1'.
  LOOP AT lt_vbep INTO ls_vbep.
    " Sólo se tendrá en cuenta el primer reparto para la planificación:
    CLEAR ls_datos_ped2.
    READ TABLE gt_datos_pedidos INTO ls_datos_ped2 WITH KEY vbeln = ls_vbep-vbeln
                                                            posnr = ls_vbep-posnr.
    IF ls_datos_ped2 IS NOT INITIAL.
      CONTINUE.
    ENDIF.
    " Comprobar bloqueo posición de reparto (VBEP):
    CLEAR lv_spebe.
    IF ls_vbep-lifsp IS NOT INITIAL.
      SELECT SINGLE spebe INTO lv_spebe
        FROM tvls
        WHERE lifsp = ls_vbep-lifsp.
    ENDIF.

    " Mirar si existe alguna orden de rollo/bobina relacionada a pedido:
    CLEAR: lv_existe_rollo, lv_existe_bob, lv_aufnr_rol_aux, lv_aufnr_bob_aux.
* GST - 05/03/2015 ->
*    PERFORM existe_orden_2 USING ls_vbep-vbeln
*                                 ls_vbep-posnr
*                           CHANGING lv_existe_rollo
*                                    lv_existe_bob
*                                    lv_aufnr_rol_aux
*                                    lv_aufnr_bob_aux.

    PERFORM existe_orden_3 USING ls_vbep-vbeln
                                 ls_vbep-posnr
                           CHANGING lv_existe_rollo
                                    lv_existe_bob
                                    lv_aufnr_rol_aux
                                    lv_aufnr_bob_aux.
* GST - 05/03/2015 <-

    IF lv_spebe <> 'X' AND ( lv_existe_rollo <> 'X' OR lv_existe_bob <> 'X' ).

      " Comprobar bloqueo posición de reparto (VBAK):
      CLEAR: ls_vbak, lv_spebe.
      SELECT SINGLE * INTO ls_vbak
        FROM vbak
        WHERE vbeln = ls_vbep-vbeln.
      IF ls_vbak-lifsk IS NOT INITIAL.
        SELECT SINGLE spebe INTO lv_spebe
          FROM tvls
          WHERE lifsp = ls_vbak-lifsk.
      ENDIF.

      IF lv_spebe <> 'X'.
        CLEAR: ls_vbap.
        SELECT SINGLE * INTO ls_vbap
          FROM vbap
          WHERE vbeln = ls_vbep-vbeln
          AND posnr = ls_vbep-posnr
          AND werks IN s_werks.

* GST - 21/05/2015 ->
*        IF ls_vbap IS NOT INITIAL.
*        IF ls_vbap IS NOT INITIAL AND ls_vbap-pstyv <> 'ZTAN'.
        IF ls_vbap IS NOT INITIAL AND ls_vbap-pstyv = 'TAN'.
* GST - 21/05/2015 <-
          CLEAR ls_datos_ped.
          MOVE-CORRESPONDING ls_vbep TO ls_datos_ped.
          MOVE-CORRESPONDING ls_vbap TO ls_datos_ped.
          CLEAR ls_datos_ped-matkl.
          ls_datos_ped-kunnr = ls_vbak-kunnr.
          IF lv_aufnr_rol_aux IS NOT INITIAL.
            ls_datos_ped-aufnr_rol = lv_aufnr_rol_aux.
            ls_datos_ped-auart_rol = 'ZI01'.
          ENDIF.
          IF lv_aufnr_bob_aux IS NOT INITIAL.
            ls_datos_ped-aufnr_bob = lv_aufnr_bob_aux.
            ls_datos_ped-auart_bob = 'ZI02'.
          ENDIF.
          ls_datos_ped-existe_rol = lv_existe_rollo.
          ls_datos_ped-existe_bob = lv_existe_bob.
*          " Cálculo fecha final orden:
*          PERFORM calc_fech_fin USING ls_datos_ped-mbdat
*                                      ls_datos_ped-vbeln
*                                      ls_datos_ped-posnr
*                                CHANGING ls_datos_ped-ffin.
          SELECT SINGLE maktx INTO ls_datos_ped-maktx
            FROM makt
            WHERE matnr = ls_datos_ped-matnr
            AND spras = sy-langu.
          " Obtener datos de rollo:
          PERFORM datos_rollo USING ls_datos_ped-wmeng
                                    ls_datos_ped-matnr
                                    ls_datos_ped-werks
                              CHANGING ls_datos_ped-idnrk
                                       ls_datos_ped-mnglg
                                       ls_datos_ped-mmein
                                       ls_datos_ped-zzgramaje
                                       ls_datos_ped-zzancho
                                       ls_datos_ped-matkl
                                       ls_datos_ped-maktx_rol.
*          " Escalón al que pertenece el material rollo:
*          PERFORM calc_escalon USING ls_datos_ped-idnrk
*                                     ls_datos_ped-zzgramaje
*                                     ls_datos_ped-zzancho
*                                     ls_datos_ped-matkl
*                               CHANGING ls_datos_ped-escalon.

          IF ls_datos_ped-idnrk IS NOT INITIAL.
            APPEND ls_datos_ped TO gt_datos_pedidos.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_RECUP_DATOS_VENTAS
*&---------------------------------------------------------------------*
*&      Form  EXISTE_ORDEN_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_VBEP_VBELN  text
*      -->P_LS_VBEP_POSNR  text
*      <--P_LV_EXISTE  text
*      <--P_LV_AUFNR_ROL_AUX  text
*      <--P_LV_AUFNR_BOB_AUX  text
*      <--P_LV_SEQNR  text
*----------------------------------------------------------------------*
FORM existe_orden_2  USING    p_vbeln
                              p_posnr
                     CHANGING p_existe_rollo
                              p_existe_bob
                              lv_aufnr_rollo
                              lv_aufnr_bob.

  " 1) Recuperamos la orden de rollo correspondiente si existe:
  CLEAR: lv_aufnr_rollo.
  CLEAR: p_existe_rollo.
  SELECT SINGLE aufnr INTO lv_aufnr_rollo
    FROM aufk
    WHERE zzebeln1 = p_vbeln
    AND zzebelp1 = p_posnr
    AND auart = 'ZI01'.

  IF lv_aufnr_rollo IS NOT INITIAL.
    p_existe_rollo = 'X'.
  ELSE.
    CLEAR p_existe_rollo.  " No existe y son órdenes nuevas a crear
    CLEAR: lv_aufnr_rollo.
  ENDIF.

  " 2) Recuperamos la orden de bobina correspondiente si existe:
  CLEAR: lv_aufnr_bob.
  CLEAR: p_existe_bob.
  SELECT SINGLE aufnr INTO lv_aufnr_bob
    FROM aufk
    WHERE zzebeln1 = p_vbeln
    AND zzebelp1 = p_posnr
    AND auart = 'ZI02'.

  IF lv_aufnr_bob IS NOT INITIAL.
    p_existe_bob = 'X'.
  ELSE.
    CLEAR p_existe_bob.  " No existe y son órdenes nuevas a crear
    CLEAR: lv_aufnr_bob.
  ENDIF.

ENDFORM.                    " EXISTE_ORDEN_2
*&---------------------------------------------------------------------*
*&      Form  F_RECUP_DATOS_COMPRAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_recup_datos_compras .

  DATA: lt_eket TYPE TABLE OF eket.

  DATA: ls_eket            TYPE eket,
        ls_ekpo            TYPE ekpo,
        ls_ekko            TYPE ekko,
        ls_datos_ped       TYPE zspp_linea_pedidos,
        ls_datos_ped2      TYPE zspp_linea_pedidos,
        lv_existe_rollo(1),
        lv_existe_bob(1),
        lv_aufnr_rol_aux2  TYPE aufnr,
        lv_aufnr_bob_aux2  TYPE aufnr,
        lv_reswk           TYPE reswk,
        lv_bsart           TYPE esart.

  CLEAR: lt_eket, ls_eket.
  REFRESH lt_eket.

  " Nos quedamos con el primer reparto para planificar:
  SELECT * FROM eket INTO TABLE lt_eket
    WHERE eindt IN s_mbdat
    AND etenr = '1'.

  LOOP AT lt_eket INTO ls_eket.

    CLEAR ls_datos_ped2.
    READ TABLE gt_datos_pedidos INTO ls_datos_ped2 WITH KEY vbeln = ls_eket-ebeln
                                                            posnr = ls_eket-ebelp.
    IF ls_datos_ped2 IS NOT INITIAL.
      CONTINUE.
    ENDIF.

    CLEAR: ls_ekko, lv_reswk, lv_bsart.
    SELECT SINGLE reswk bsart INTO (lv_reswk, lv_bsart)
      FROM ekko
      WHERE ebeln = ls_eket-ebeln
      AND reswk IN s_werks.

    IF lv_reswk IS INITIAL.
      CONTINUE.
    ENDIF.

    IF lv_bsart <> 'ZINT'.
      CONTINUE.
    ENDIF.

    CLEAR: ls_ekpo.
    SELECT SINGLE * INTO ls_ekpo
      FROM ekpo
      WHERE ebeln = ls_eket-ebeln
      AND ebelp = ls_eket-ebelp.

    IF ls_ekpo-zzbloq_plan = 'X'.
      CONTINUE.
    ENDIF.

* GST - 21/05/2015 ->
    IF ls_ekpo-zzbloq_fabr = 'X'.
      CONTINUE.
    ENDIF.
* GST - 21/05/2015 <-

    " Miramos si el pedido ya existe en alguna orden:
    CLEAR: lv_existe_rollo, lv_existe_bob, lv_aufnr_rol_aux2, lv_aufnr_bob_aux2.
* GST - 05/03/2015 ->
*    PERFORM existe_orden_2 USING ls_eket-ebeln
*                                 ls_eket-ebelp
*                         CHANGING lv_existe_rollo
*                                  lv_existe_bob
*                                  lv_aufnr_rol_aux2
*                                  lv_aufnr_bob_aux2.

    PERFORM existe_orden_3 USING ls_eket-ebeln
                                 ls_eket-ebelp
                         CHANGING lv_existe_rollo
                                  lv_existe_bob
                                  lv_aufnr_rol_aux2
                                  lv_aufnr_bob_aux2.
* GST - 05/03/2015 <-

    IF ls_ekpo IS NOT INITIAL AND ls_ekpo-loekz <> 'L' AND ls_ekpo-eglkz <> 'X' AND ls_ekpo-zzabgru IS INITIAL
      AND ls_ekpo-retpo <> 'X' AND ( lv_existe_rollo <> 'X' OR lv_existe_bob <> 'X').
      CLEAR ls_datos_ped.
      ls_datos_ped-mbdat = ls_eket-eindt.
      ls_datos_ped-vbeln = ls_eket-ebeln.
      ls_datos_ped-posnr = ls_eket-ebelp.
      ls_datos_ped-etenr = ls_eket-etenr.
      ls_datos_ped-wmeng = ls_eket-menge.
      SELECT SINGLE vrkme INTO ls_datos_ped-vrkme
        FROM vbep
        WHERE vbeln = ls_datos_ped-vbeln
        AND posnr = ls_datos_ped-posnr
        AND etenr = ls_datos_ped-etenr.
      ls_datos_ped-meins = ls_ekpo-meins.
      ls_datos_ped-matnr = ls_ekpo-matnr.
      SELECT SINGLE kunnr lprio INTO (ls_datos_ped-kunnr, ls_datos_ped-lprio)
        FROM ekpv
        WHERE ebeln = ls_eket-ebeln
        AND ebelp =  ls_eket-ebelp.
      CLEAR ls_datos_ped-matkl.
      IF lv_aufnr_rol_aux2 IS NOT INITIAL.
        ls_datos_ped-aufnr_rol = lv_aufnr_rol_aux2.
        ls_datos_ped-auart_rol = 'ZI01'.
      ENDIF.
      IF lv_aufnr_bob_aux2 IS NOT INITIAL.
        ls_datos_ped-aufnr_bob = lv_aufnr_bob_aux2.
        ls_datos_ped-auart_bob = 'ZI02'.
      ENDIF.
      ls_datos_ped-existe_rol = lv_existe_rollo.
      ls_datos_ped-existe_bob = lv_existe_bob.
      ls_datos_ped-werks = lv_reswk.
*      " Cálculo fecha final orden:
*      PERFORM calc_fech_fin USING ls_datos_ped-mbdat
*                                  ls_datos_ped-vbeln
*                                  ls_datos_ped-posnr
*                            CHANGING ls_datos_ped-ffin.
      SELECT SINGLE maktx INTO ls_datos_ped-maktx
        FROM makt
        WHERE matnr = ls_datos_ped-matnr
        AND spras = sy-langu.
      " Obtener datos de rollo:
      PERFORM datos_rollo USING ls_datos_ped-wmeng
                                ls_datos_ped-matnr
                                ls_datos_ped-werks
                          CHANGING ls_datos_ped-idnrk
                                   ls_datos_ped-mnglg
                                   ls_datos_ped-mmein
                                   ls_datos_ped-zzgramaje
                                   ls_datos_ped-zzancho
                                   ls_datos_ped-matkl
                                   ls_datos_ped-maktx_rol.
*      " Escalón al que pertenece el material rollo:
*      PERFORM calc_escalon USING ls_datos_ped-idnrk
*                                 ls_datos_ped-zzgramaje
*                                 ls_datos_ped-zzancho
*                                  ls_datos_ped-matkl
*                           CHANGING ls_datos_ped-escalon.

      IF ls_datos_ped-idnrk IS NOT INITIAL.
        APPEND ls_datos_ped TO gt_datos_pedidos.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_RECUP_DATOS_COMPRAS
*&---------------------------------------------------------------------*
*&      Form  F_CREAR_ORDENES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_crear_ordenes.

  DATA: ls_datos_pedidos TYPE zspp_linea_pedidos,
        lv_index         LIKE sy-tabix,
        lv_ok(1),
        ls_listado1      LIKE gt_listado1.

  CLEAR: ls_datos_pedidos, lv_ok.

  " Voy a crear las órdenes correspondientes a los pedidos seleccionados:
  LOOP AT gt_datos_pedidos INTO ls_datos_pedidos.
    lv_index = sy-tabix.

    " 1) Creo la orden de rollo/bobina:
    IF ls_datos_pedidos-existe_rol <> 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
      CLEAR lv_ok.
      PERFORM crear_orden_rollo_2 USING ls_datos_pedidos
                                CHANGING ls_datos_pedidos-aufnr_rol
                                         ls_datos_pedidos-auart_rol
                                         lv_ok.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
      IF lv_ok = 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
        PERFORM crear_orden_bobina_2 USING ls_datos_pedidos
                                   CHANGING ls_datos_pedidos-aufnr_bob
                                            ls_datos_pedidos-auart_bob.
        MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
      ELSEIF lv_ok <> 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
        CLEAR: ls_listado1.
        ls_listado1-vbeln = ls_datos_pedidos-vbeln.
        ls_listado1-posnr = ls_datos_pedidos-posnr.
        ls_listado1-matnr = ls_datos_pedidos-matnr.
        ls_listado1-maktx = ls_datos_pedidos-maktx.
        ls_listado1-auart = 'ZI02'.
        ls_listado1-kunnr = ls_datos_pedidos-kunnr.
        ls_listado1-werks = ls_datos_pedidos-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = 'No se ha podido crear la orden de rollo correspondiente'.
        ls_listado1-tipo = 'C'. " Error en creación
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.
    ENDIF.

    " 2) Sólo hay que crear orden rollo:
    IF ls_datos_pedidos-existe_rol <> 'X' AND ls_datos_pedidos-existe_bob = 'X'.
      CLEAR lv_ok.
      PERFORM crear_orden_rollo_2 USING ls_datos_pedidos
                                CHANGING ls_datos_pedidos-aufnr_rol
                                         ls_datos_pedidos-auart_rol
                                         lv_ok.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
    ENDIF.
    " 3) Sólo hay que crear orden bobina:
    IF ls_datos_pedidos-existe_rol = 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
      PERFORM crear_orden_bobina_2 USING ls_datos_pedidos
                                 CHANGING ls_datos_pedidos-aufnr_bob
                                          ls_datos_pedidos-auart_bob.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_CREAR_ORDENES
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_ROLLO_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_PEDIDOS  text
*      <--P_LS_DATOS_PEDIDOS_AUFNR_ROL  text
*      <--P_LS_DATOS_PEDIDOS_AUART_ROL  text
*      <--P_LV_OK  text
*----------------------------------------------------------------------*
FORM crear_orden_rollo_2  USING    ps_datos_pedidos TYPE zspp_linea_pedidos
                          CHANGING p_aufnr_rol
                                   p_auart_rol
                                   p_ok.

  DATA: ls_orderdata     TYPE bapi_pi_order_create,
        lt_return        TYPE bapiret2_t,
        ls_return        TYPE bapiret2,
        lv_aufnr         TYPE aufnr,
        lv_auart         TYPE aufart,
        ls_listado1      LIKE gt_listado1,
        lv_ancho_bob     TYPE zancho,
        lv_rol1          TYPE zrollos,
        lv_tor1          TYPE ztornada,
        lv_rol2          TYPE zrollos,
        lv_tor2          TYPE ztornada,
        lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10),
        lv_fecha_aux(10),
        lv_fecha         TYPE co_gstrp,
        lt_orders        TYPE tb_bapi_order_key,
        ls_orders        TYPE bapi_order_key.

  DATA: lv_ok        TYPE xflag,
        lv_cont      TYPE i,
        lv_aufnr_aux TYPE aufnr.

  DATA:   ls_messtab     LIKE i_messtab,
          ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, p_ok, ls_listado1.
  REFRESH lt_return.

  " Encontrar la fecha de inicio que tenemos que pasar para crear la
  " orden:

  CLEAR lv_fecha.
  PERFORM f_calc_fech USING ps_datos_pedidos-werks
                            ps_datos_pedidos-mbdat
                      CHANGING lv_fecha.


  ls_orderdata-material = ps_datos_pedidos-idnrk.
  ls_orderdata-plant = ps_datos_pedidos-werks.
  ls_orderdata-order_type = 'ZI01'.
  ls_orderdata-quantity = ps_datos_pedidos-mnglg.
  ls_orderdata-quantity_uom = ps_datos_pedidos-mmein.
  ls_orderdata-basic_start_date = lv_fecha.

* GST - 26/05/2015 ->
* Marcar prioridad de la orden como urgente:
  IF ps_datos_pedidos-lprio = '01'.
    ls_orderdata-order_priority = ps_datos_pedidos-lprio+1(1).
  ENDIF.
* GST - 26/05/2015 <-
*  ls_orderdata-basic_start_time = '000000'.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.


  IF lv_aufnr IS INITIAL.
    " Error
    CLEAR: p_ok, ls_listado1.
    IF ls_return-type = 'E'.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-idnrk.
      ls_listado1-maktx = ps_datos_pedidos-maktx_rol.
      ls_listado1-auart = 'ZI01'.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-type_ret = ls_return-type.
      ls_listado1-msg_ret = ls_return-message.
      ls_listado1-tipo = 'C'. " Error producido en creación
      APPEND ls_listado1 TO gt_listado1.
    ENDIF.
  ELSE.

    " Todo el proceso ha ido correctamente:
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

    p_ok = 'X'.
    p_aufnr_rol = lv_aufnr.
    p_auart_rol = 'ZI01'.

* GST - 11/09/2015 - 7000007795 ->
*    WAIT UP TO 1 SECONDS.

    " Controlar orden creada:
    CLEAR: lv_ok, lv_cont, lv_aufnr_aux.
    WHILE lv_ok IS INITIAL.
      WAIT UP TO 1 SECONDS.
      lv_cont = lv_cont + 1.

      SELECT SINGLE aufnr INTO lv_aufnr_aux
        FROM aufk
        WHERE aufnr = lv_aufnr.

      IF lv_aufnr_aux IS NOT INITIAL.
        lv_ok = 'X'.
      ENDIF.

      IF lv_cont = 15.
        lv_ok = 'X'.
      ENDIF.
    ENDWHILE.

* GST - 11/09/2015 - 7000007795 <-

    " Recuperar datos rollos y tornadas:
    CLEAR: lv_ancho_bob, lv_rol1, lv_rol2, lv_tor1, lv_tor2.
    SELECT SINGLE zzancho INTO lv_ancho_bob
      FROM mara
      WHERE matnr = ps_datos_pedidos-matnr.

    PERFORM dat_rollo_torn USING ps_datos_pedidos-wmeng
                                 lv_ancho_bob
                           CHANGING lv_rol1
                                    lv_tor1
                                    lv_rol2
                                    lv_tor2.

* GST - 22/09/2015 - 7000007795 ->
    CALL FUNCTION 'ENQUEUE_ESORDER'
      EXPORTING
        mode_aufk      = 'E'
        mandt          = sy-mandt
        aufnr          = lv_aufnr
*       X_AUFNR        = ' '
*       _SCOPE         = '2'
*       _WAIT          = ' '
*       _COLLECT       = ' '
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
* Implement suitable error handling here
      CLEAR: lv_cont.
      WHILE lv_cont < 30.
        WAIT UP TO 1 SECONDS.
        CALL FUNCTION 'ENQUEUE_ESORDER'
          EXPORTING
            mode_aufk      = 'E'
            mandt          = sy-mandt
            aufnr          = lv_aufnr
*           X_AUFNR        = ' '
*           _SCOPE         = '2'
*           _WAIT          = ' '
*           _COLLECT       = ' '
          EXCEPTIONS
            foreign_lock   = 1
            system_failure = 2
            OTHERS         = 3.

        IF sy-subrc <> 0.
          lv_cont = lv_cont + 1.
        ELSE.
          lv_cont = 30.
          CALL FUNCTION 'DEQUEUE_ESORDER'
            EXPORTING
              mode_aufk = 'E'
              mandt     = sy-mandt
              aufnr     = lv_aufnr
*             X_AUFNR   = ' '
*             _SCOPE    = '3'
*             _SYNCHRON = ' '
*             _COLLECT  = ' '
            .
        ENDIF.
      ENDWHILE.


    ELSE.
      CALL FUNCTION 'DEQUEUE_ESORDER'
        EXPORTING
          mode_aufk = 'E'
          mandt     = sy-mandt
          aufnr     = lv_aufnr
*         X_AUFNR   = ' '
*         _SCOPE    = '3'
*         _SYNCHRON = ' '
*         _COLLECT  = ' '
        .
    ENDIF.


* GST - 22/09/2015 - 7000007795 <-

**
    "Hacemos EXPORT a memoria con la orden para no tener problemas con el batch input y
    "los campos que se sombrean en pantalla en la COR2.
    EXPORT  gv_order_number FROM lv_aufnr TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:
    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  lv_aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    IF ps_datos_pedidos-kunnr IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZKUNNR1'.
      PERFORM bdc_field       USING 'AUFK-ZZKUNNR1'
                                    ps_datos_pedidos-kunnr.
    ENDIF.

    IF ps_datos_pedidos-vbeln IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZEBELN1'.
      PERFORM bdc_field       USING 'AUFK-ZZEBELN1'
                                    ps_datos_pedidos-vbeln.
    ENDIF.
    IF ps_datos_pedidos-posnr IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZEBELP1'.
      PERFORM bdc_field       USING 'AUFK-ZZEBELP1'
                                    ps_datos_pedidos-posnr.
    ENDIF.
    CLEAR lv_fecha_aux.
    IF ps_datos_pedidos-mbdat IS NOT INITIAL.
      CONCATENATE ps_datos_pedidos-mbdat+6(2) ps_datos_pedidos-mbdat+4(2) ps_datos_pedidos-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZFEC_ENTREG1'.
      PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG1'
                                    lv_fecha_aux.
    ENDIF.

* GST - 25/05/2015 ->
    IF ps_datos_pedidos-lprio = '01'.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZURGT1'.
      PERFORM bdc_field       USING 'AUFK-ZZURGT1'
                                    'X'.
    ENDIF.
* GST - 25/05/2015 <-

    CLEAR: lv_rol1_txt, lv_rol2_txt, lv_tor1_txt, lv_tor2_txt.
    IF lv_rol1 IS NOT INITIAL.
      lv_rol1_txt = lv_rol1.
      CONDENSE lv_rol1_txt.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZROLLOS1'.
      PERFORM bdc_field       USING 'AUFK-ZZROLLOS1'
                                    lv_rol1_txt.
    ENDIF.
    IF lv_tor1 IS NOT INITIAL.
      lv_tor1_txt = lv_tor1.
      CONDENSE lv_tor1_txt.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZTOR1'.
      PERFORM bdc_field       USING 'AUFK-ZZTOR1'
                                    lv_tor1_txt.
    ENDIF.
    IF lv_rol2 IS NOT INITIAL.
      lv_rol2_txt = lv_rol2.
      CONDENSE lv_rol2_txt.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZROLLOS2'.
      PERFORM bdc_field       USING 'AUFK-ZZROLLOS2'
                                    lv_rol2_txt.
    ENDIF.
    IF lv_tor2 IS NOT INITIAL.
      lv_tor2_txt = lv_tor2.
      CONDENSE lv_rol2_txt.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZTOR2'.
      PERFORM bdc_field       USING 'AUFK-ZZTOR2'
                                    lv_tor2_txt.
    ENDIF.

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.
      CLEAR: p_ok.

      " Error en el proceso de actualización de la orden:
      CLEAR: p_ok, ls_listado1.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-idnrk.
      ls_listado1-maktx = ps_datos_pedidos-maktx_rol.
      ls_listado1-auart = 'ZI01'.
      ls_listado1-aufnr = lv_aufnr.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-type_ret = 'E'.
      ls_listado1-tipo = 'C'. " Error en creación
      PERFORM mensajes_error
        TABLES i_messtab
        CHANGING ls_listado1-msg_ret.
      APPEND ls_listado1 TO gt_listado1.

* GST - 23/10/2014 ->
* Cerramos técnicamente las órdenes que se han creado y
* no se han actualizados la pestaña de datos Z:
      CLEAR: ls_return, lt_orders, ls_orders.
      REFRESH: lt_orders.

      ls_orders-order_number = lv_aufnr.
      APPEND ls_orders TO lt_orders.

* GST - 22/09/2015 - 7000007795 ->
      CALL FUNCTION 'ENQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = lv_aufnr
*         X_AUFNR        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
* Implement suitable error handling here
        CLEAR: lv_cont.
        WHILE lv_cont < 30.
          WAIT UP TO 1 SECONDS.
          CALL FUNCTION 'ENQUEUE_ESORDER'
            EXPORTING
              mode_aufk      = 'E'
              mandt          = sy-mandt
              aufnr          = lv_aufnr
*             X_AUFNR        = ' '
*             _SCOPE         = '2'
*             _WAIT          = ' '
*             _COLLECT       = ' '
            EXCEPTIONS
              foreign_lock   = 1
              system_failure = 2
              OTHERS         = 3.

          IF sy-subrc <> 0.
            lv_cont = lv_cont + 1.
          ELSE.
            lv_cont = 30.
            CALL FUNCTION 'DEQUEUE_ESORDER'
              EXPORTING
                mode_aufk = 'E'
                mandt     = sy-mandt
                aufnr     = lv_aufnr
*               X_AUFNR   = ' '
*               _SCOPE    = '3'
*               _SYNCHRON = ' '
*               _COLLECT  = ' '
              .
          ENDIF.
        ENDWHILE.
      ELSE.
        CALL FUNCTION 'DEQUEUE_ESORDER'
          EXPORTING
            mode_aufk = 'E'
            mandt     = sy-mandt
            aufnr     = lv_aufnr
*           X_AUFNR   = ' '
*           _SCOPE    = '3'
*           _SYNCHRON = ' '
*           _COLLECT  = ' '
          .
      ENDIF.

* GST - 22/09/2015 - 7000007795 <-


      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
*       EXPORTING
*         SCOPE_COMPL_TECH         = '1'
*         WORK_PROCESS_GROUP       = 'COWORK_BAPI'
*         WORK_PROCESS_MAX         = 99
        IMPORTING
          return = ls_return
        TABLES
          orders = lt_orders.
*         DETAIL_RETURN            =
*         APPLICATION_LOG          =

      IF ls_return-type = 'E'.
        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_datos_pedidos-vbeln.
        ls_listado1-posnr = ps_datos_pedidos-posnr.
        ls_listado1-matnr = ps_datos_pedidos-idnrk.
        ls_listado1-maktx = ps_datos_pedidos-maktx_rol.
        ls_listado1-auart = 'ZI01'.
        ls_listado1-aufnr = lv_aufnr.
        ls_listado1-kunnr = ps_datos_pedidos-kunnr.
        ls_listado1-werks = ps_datos_pedidos-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-type_ret = 'E'.
        ls_listado1-tipo = 'C'. " Error en creación
        ls_listado1-msg_ret = ls_return-message.
        APPEND ls_listado1 TO gt_listado1.
      ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND ls_return-number = '889'.
        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_datos_pedidos-vbeln.
        ls_listado1-posnr = ps_datos_pedidos-posnr.
        ls_listado1-matnr = ps_datos_pedidos-idnrk.
        ls_listado1-maktx = ps_datos_pedidos-maktx_rol.
        ls_listado1-auart = 'ZI01'.
        ls_listado1-aufnr = lv_aufnr.
        ls_listado1-kunnr = ps_datos_pedidos-kunnr.
        ls_listado1-werks = ps_datos_pedidos-werks.
        ls_listado1-icon = '@09@'. " Semaforito amarrillo
        ls_listado1-type_ret = 'I'.
        ls_listado1-tipo = 'C'. " Error en creación
        ls_listado1-msg_ret = ls_return-message.
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.
* GST - 23/10/2014 <-
    ELSE.
      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      p_ok = 'X'.
      p_aufnr_rol = lv_aufnr.
      p_auart_rol = 'ZI01'.

      " Pasarle al listado la orden que acabo de crear:
      " (También los procesos que han ido correctamente)
      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-idnrk.
      ls_listado1-maktx = ps_datos_pedidos-maktx_rol.
      ls_listado1-auart = 'ZI01'.
      ls_listado1-aufnr = lv_aufnr.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@08@'. " Semaforito verde
      ls_listado1-tipo = 'C'. " Error en creación
      APPEND ls_listado1 TO gt_listado1.
    ENDIF.
  ENDIF.


ENDFORM.                    " CREAR_ORDEN_ROLLO_2
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_BOBINA_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DATOS_PEDIDOS  text
*      <--P_LS_DATOS_PEDIDOS_AUFNR_BOB  text
*      <--P_LS_DATOS_PEDIDOS_AUART_BOB  text
*----------------------------------------------------------------------*
FORM crear_orden_bobina_2  USING    ps_datos_pedidos TYPE zspp_linea_pedidos
                           CHANGING p_aufnr_bob
                                    p_auart_bob.

  DATA: ls_orderdata     TYPE bapi_pi_order_create,
        lt_return        TYPE bapiret2_t,
        ls_return        TYPE bapiret2,
        lv_aufnr         TYPE aufnr,
        lv_auart         TYPE aufart,
        ls_listado1      LIKE gt_listado1,
        lv_fecha_aux(10),
        lv_fecha         TYPE co_gstrp,
        lt_orders        TYPE tb_bapi_order_key,
        ls_orders        TYPE bapi_order_key.

  DATA:   ls_messtab     LIKE i_messtab,
          ls_return_roll LIKE bapiret2.

  DATA: lv_ok        TYPE xflag,
        lv_aufnr_aux TYPE aufnr,
        lv_cont      TYPE i.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, ls_listado1.
  REFRESH: lt_return.

  " Buscamos la fecha de inicio extrema que tenemos que indicar en la orden:
  CLEAR lv_fecha.
  PERFORM f_calc_fech USING ps_datos_pedidos-werks
                            ps_datos_pedidos-mbdat
                      CHANGING lv_fecha.

  ls_orderdata-material = ps_datos_pedidos-matnr.
  ls_orderdata-plant = ps_datos_pedidos-werks.
  ls_orderdata-order_type = 'ZI02'.
  ls_orderdata-quantity = ps_datos_pedidos-wmeng.
  IF ps_datos_pedidos-vrkme IS NOT INITIAL.
    ls_orderdata-quantity_uom = ps_datos_pedidos-vrkme.
  ELSEIF ps_datos_pedidos-meins IS NOT INITIAL.
    ls_orderdata-quantity_uom = ps_datos_pedidos-meins.
  ELSE.
    ls_orderdata-quantity_uom = 'KG'.
  ENDIF.
  ls_orderdata-basic_start_date = lv_fecha.

* GST - 26/05/2015 ->
  IF ps_datos_pedidos-lprio = '01'.
    ls_orderdata-order_priority = ps_datos_pedidos-lprio+1(1).
  ENDIF.
* GST - 26/05/2015 <-
*  ls_orderdata-basic_start_time = p_hora.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.

  IF lv_aufnr IS INITIAL.
    " Error
    CLEAR: ls_listado1.
    IF ls_return-type = 'E'.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-matnr.
      ls_listado1-maktx = ps_datos_pedidos-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-type_ret = ls_return-type.
      ls_listado1-msg_ret = ls_return-message.
      ls_listado1-tipo = 'C'. " Error en creación
      APPEND ls_listado1 TO gt_listado1.
    ENDIF.
  ELSE.

    " Todo el proceso ha ido correctamente:
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

    p_aufnr_bob = lv_aufnr.
    p_auart_bob = 'ZI02'.

* GST - 11/09/2015 - 7000007795 ->
*    WAIT UP TO 1 SECONDS.

    " Controlar orden creada:
    CLEAR: lv_ok, lv_cont, lv_aufnr_aux.
    WHILE lv_ok IS INITIAL.
      WAIT UP TO 1 SECONDS.
      lv_cont = lv_cont + 1.

      SELECT SINGLE aufnr INTO lv_aufnr_aux
        FROM aufk
        WHERE aufnr = lv_aufnr.

      IF lv_aufnr_aux IS NOT INITIAL.
        lv_ok = 'X'.
      ENDIF.

      IF lv_cont = 15.
        lv_ok = 'X'.
      ENDIF.
    ENDWHILE.

* GST - 11/09/2015 - 7000007795 <-

* GST - 22/09/2015 - 7000007795 ->
    CALL FUNCTION 'ENQUEUE_ESORDER'
      EXPORTING
        mode_aufk      = 'E'
        mandt          = sy-mandt
        aufnr          = lv_aufnr
*       X_AUFNR        = ' '
*       _SCOPE         = '2'
*       _WAIT          = ' '
*       _COLLECT       = ' '
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
* Implement suitable error handling here
      CLEAR: lv_cont.
      WHILE lv_cont < 30.
        WAIT UP TO 1 SECONDS.
        CALL FUNCTION 'ENQUEUE_ESORDER'
          EXPORTING
            mode_aufk      = 'E'
            mandt          = sy-mandt
            aufnr          = lv_aufnr
*           X_AUFNR        = ' '
*           _SCOPE         = '2'
*           _WAIT          = ' '
*           _COLLECT       = ' '
          EXCEPTIONS
            foreign_lock   = 1
            system_failure = 2
            OTHERS         = 3.

        IF sy-subrc <> 0.
          lv_cont = lv_cont + 1.
        ELSE.
          lv_cont = 30.
          CALL FUNCTION 'DEQUEUE_ESORDER'
            EXPORTING
              mode_aufk = 'E'
              mandt     = sy-mandt
              aufnr     = lv_aufnr
*             X_AUFNR   = ' '
*             _SCOPE    = '3'
*             _SYNCHRON = ' '
*             _COLLECT  = ' '
            .
        ENDIF.
      ENDWHILE.
    ELSE.
      CALL FUNCTION 'DEQUEUE_ESORDER'
        EXPORTING
          mode_aufk = 'E'
          mandt     = sy-mandt
          aufnr     = lv_aufnr
*         X_AUFNR   = ' '
*         _SCOPE    = '3'
*         _SYNCHRON = ' '
*         _COLLECT  = ' '
        .
    ENDIF.

* GST - 22/09/2015 - 7000007795 <-


    "Hacemos EXPORT a memoria con la orden para no tener problemas con el batch input y
    "los campos que se sombrean en pantalla en la COR2.
    EXPORT  gv_order_number FROM lv_aufnr TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:
    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  lv_aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    IF ps_datos_pedidos-kunnr IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZKUNNR1'.
      PERFORM bdc_field       USING 'AUFK-ZZKUNNR1'
                                    ps_datos_pedidos-kunnr.
    ENDIF.
    IF ps_datos_pedidos-vbeln IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZEBELN1'.
      PERFORM bdc_field       USING 'AUFK-ZZEBELN1'
                                    ps_datos_pedidos-vbeln.
    ENDIF.
    IF ps_datos_pedidos-posnr IS NOT INITIAL.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZEBELP1'.
      PERFORM bdc_field       USING 'AUFK-ZZEBELP1'
                                    ps_datos_pedidos-posnr.
    ENDIF.
    CLEAR lv_fecha_aux.
    IF ps_datos_pedidos-mbdat IS NOT INITIAL.
      CONCATENATE ps_datos_pedidos-mbdat+6(2) ps_datos_pedidos-mbdat+4(2) ps_datos_pedidos-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZFEC_ENTREG1'.
      PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG1'
                                    lv_fecha_aux.
    ENDIF.

* GST - 25/05/2015 ->
    IF ps_datos_pedidos-lprio = '01'.
      PERFORM bdc_field       USING 'BDC_CURSOR'
                                    'AUFK-ZZURGT1'.
      PERFORM bdc_field       USING 'AUFK-ZZURGT1'
                                    'X'.
    ENDIF.
* GST - 25/05/2015 <-

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.

      CLEAR: ls_listado1.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-matnr.
      ls_listado1-maktx = ps_datos_pedidos-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-aufnr = lv_aufnr.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-type_ret = 'E'.
      ls_listado1-tipo = 'C'.
      PERFORM mensajes_error
        TABLES i_messtab
        CHANGING ls_listado1-msg_ret.
      APPEND ls_listado1 TO gt_listado1.

* GST - 23/10/2013 ->
* Cerrar técnicamente órdenes erróneas:

      CLEAR: ls_return, lt_orders, ls_orders.
      REFRESH: lt_orders.

      ls_orders-order_number = lv_aufnr.
      APPEND ls_orders TO lt_orders.

* GST - 22/09/2015 - 7000007795 ->
      CALL FUNCTION 'ENQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = lv_aufnr
*         X_AUFNR        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
* Implement suitable error handling here
        CLEAR: lv_cont.
        WHILE lv_cont < 30.
          WAIT UP TO 1 SECONDS.
          CALL FUNCTION 'ENQUEUE_ESORDER'
            EXPORTING
              mode_aufk      = 'E'
              mandt          = sy-mandt
              aufnr          = lv_aufnr
*             X_AUFNR        = ' '
*             _SCOPE         = '2'
*             _WAIT          = ' '
*             _COLLECT       = ' '
            EXCEPTIONS
              foreign_lock   = 1
              system_failure = 2
              OTHERS         = 3.

          IF sy-subrc <> 0.
            lv_cont = lv_cont + 1.
          ELSE.
            lv_cont = 30.
            CALL FUNCTION 'DEQUEUE_ESORDER'
              EXPORTING
                mode_aufk = 'E'
                mandt     = sy-mandt
                aufnr     = lv_aufnr
*               X_AUFNR   = ' '
*               _SCOPE    = '3'
*               _SYNCHRON = ' '
*               _COLLECT  = ' '
              .
          ENDIF.
        ENDWHILE.
      ELSE.
        CALL FUNCTION 'DEQUEUE_ESORDER'
          EXPORTING
            mode_aufk = 'E'
            mandt     = sy-mandt
            aufnr     = lv_aufnr
*           X_AUFNR   = ' '
*           _SCOPE    = '3'
*           _SYNCHRON = ' '
*           _COLLECT  = ' '
          .
      ENDIF.

* GST - 22/09/2015 - 7000007795 <-

      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
*       EXPORTING
*         SCOPE_COMPL_TECH         = '1'
*         WORK_PROCESS_GROUP       = 'COWORK_BAPI'
*         WORK_PROCESS_MAX         = 99
        IMPORTING
          return = ls_return
        TABLES
          orders = lt_orders.
*         DETAIL_RETURN            =
*         APPLICATION_LOG          =

      IF ls_return-type = 'E'.
        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_datos_pedidos-vbeln.
        ls_listado1-posnr = ps_datos_pedidos-posnr.
        ls_listado1-matnr = ps_datos_pedidos-matnr.
        ls_listado1-maktx = ps_datos_pedidos-maktx.
        ls_listado1-auart = 'ZI02'.
        ls_listado1-aufnr = lv_aufnr.
        ls_listado1-kunnr = ps_datos_pedidos-kunnr.
        ls_listado1-werks = ps_datos_pedidos-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-type_ret = 'E'.
        ls_listado1-tipo = 'C'. " Error en creación
        ls_listado1-msg_ret = ls_return-message.
        APPEND ls_listado1 TO gt_listado1.
      ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND ls_return-number = '889'.
        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_datos_pedidos-vbeln.
        ls_listado1-posnr = ps_datos_pedidos-posnr.
        ls_listado1-matnr = ps_datos_pedidos-matnr.
        ls_listado1-maktx = ps_datos_pedidos-maktx.
        ls_listado1-auart = 'ZI02'.
        ls_listado1-aufnr = lv_aufnr.
        ls_listado1-kunnr = ps_datos_pedidos-kunnr.
        ls_listado1-werks = ps_datos_pedidos-werks.
        ls_listado1-icon = '@09@'. " Semaforito amarrillo
        ls_listado1-type_ret = 'I'.
        ls_listado1-tipo = 'C'. " Error en creación
        ls_listado1-msg_ret = ls_return-message.
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.

* GST - 23/10/2013 <-
    ELSE.
      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      p_aufnr_bob = lv_aufnr.
      p_auart_bob = 'ZI02'.

      " Pasarle al listado la orden que acabo de crear:
      " (También los procesos que han ido correctamente)
      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_datos_pedidos-vbeln.
      ls_listado1-posnr = ps_datos_pedidos-posnr.
      ls_listado1-matnr = ps_datos_pedidos-matnr.
      ls_listado1-maktx = ps_datos_pedidos-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-aufnr = lv_aufnr.
      ls_listado1-kunnr = ps_datos_pedidos-kunnr.
      ls_listado1-werks = ps_datos_pedidos-werks.
      ls_listado1-icon = '@08@'. " Semaforito verde
      ls_listado1-tipo = 'C'. " Error en creación
      APPEND ls_listado1 TO gt_listado1.
    ENDIF.
  ENDIF.

ENDFORM.                    " CREAR_ORDEN_BOBINA_2
*&---------------------------------------------------------------------*
*&      Form  F_CALC_FECH
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_DATOS_PEDIDOS_VBELN  text
*      -->P_PS_DATOS_PEDIDOS_POSNR  text
*      -->P_PS_DATOS_PEDIDOS_MBDAT  text
*      <--P_LV_FECHA  text
*----------------------------------------------------------------------*
FORM f_calc_fech  USING    p_werks
                           p_mbdat
                  CHANGING p_fecha.

  DATA: lv_fabkl TYPE fabkl,
        lv_mbdat TYPE mbdat.

  CLEAR: lv_fabkl, lv_mbdat.

  " Buscamos el calendario de fábrica por centro:
  SELECT SINGLE fabkl INTO lv_fabkl
    FROM t001w
    WHERE werks = p_werks.
  IF lv_fabkl IS INITIAL.
    lv_fabkl = 'ES'.
  ENDIF.

  " Miramos si la fecha calculada corresponde al calendario de fábrica
  " y si no cogemos justo la anterior a esa:
  lv_mbdat = p_mbdat - 1.

  CALL FUNCTION 'BKK_GET_PRIOR_WORKDAY'
    EXPORTING
      i_date         = lv_mbdat
      i_calendar1    = lv_fabkl
*     I_CALENDAR2    =
    IMPORTING
      e_workday      = lv_mbdat
    EXCEPTIONS
      calendar_error = 1
      OTHERS         = 2.
  IF sy-subrc <> 0.
* Implement suitable error handling here
    p_fecha = p_mbdat - 1.
  ELSE.
    p_fecha = lv_mbdat.
  ENDIF.

ENDFORM.                    " F_CALC_FECH
*&---------------------------------------------------------------------*
*&      Form  F_REC_ORDENES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_ordenes .

  DATA: lt_dat_rol TYPE TABLE OF aufk,
        ls_dat_rol TYPE          aufk,
        lt_dat_bob TYPE TABLE OF aufk,
        ls_dat_bob TYPE          aufk,
        ls_dat_ord TYPE          zspp_linea_orden.

  CLEAR: lt_dat_rol, ls_dat_rol.
  REFRESH: lt_dat_rol.

  " 1) SECUENCIACIÓN ROLLOS:

  " Recuperamos los datos de las órdenes de rollos que no hayan sido liberadas:
  SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_dat_rol
  FROM aufk AS a
  INNER JOIN jest AS b ON b~objnr = a~objnr
  INNER JOIN caufv AS c ON c~aufnr = a~aufnr
  WHERE b~stat = 'I0001'
  AND b~inact = ' '
  AND a~auart = 'ZI01'.
  "  AND c~gltrp <= s_mbdat-high.

  " Seleccionamos datos de las órdenes de rollo a secuenciar:
  LOOP AT lt_dat_rol INTO ls_dat_rol WHERE zzebeln1 IS NOT INITIAL
                                     AND zzebelp1 IS NOT INITIAL.
    CLEAR ls_dat_ord.
    ls_dat_ord-mbdat = ls_dat_rol-zzfec_entreg1.
    ls_dat_ord-vbeln = ls_dat_rol-zzebeln1.
    ls_dat_ord-posnr = ls_dat_rol-zzebelp1.
    ls_dat_ord-kunnr = ls_dat_rol-zzkunnr1.
    ls_dat_ord-werks = ls_dat_rol-werks.
    SELECT SINGLE plnbez INTO ls_dat_ord-matnr
      FROM afko
      WHERE aufnr = ls_dat_rol-aufnr.
    SELECT SINGLE matkl zzgramaje zzancho INTO (ls_dat_ord-matkl, ls_dat_ord-zzgramaje, ls_dat_ord-zzancho)
      FROM mara
      WHERE matnr = ls_dat_ord-matnr.
    SELECT SINGLE maktx INTO ls_dat_ord-maktx
      FROM makt
      WHERE matnr = ls_dat_ord-matnr
      AND spras = sy-langu.
    PERFORM calc_escalon  USING  ls_dat_ord-matnr
                                 ls_dat_ord-zzgramaje
                                 ls_dat_ord-zzancho
                                 ls_dat_ord-matkl
                          CHANGING ls_dat_ord-escalon.
    ls_dat_ord-aufnr = ls_dat_rol-aufnr.
    ls_dat_ord-auart = ls_dat_rol-auart.
    IF ls_dat_ord-vbeln IS NOT INITIAL AND ls_dat_ord-posnr IS NOT INITIAL.
      APPEND ls_dat_ord TO gt_datos_rollos.
    ENDIF.
  ENDLOOP.

  SORT gt_datos_rollos BY escalon ASCENDING
                          mbdat ASCENDING
                          vbeln ASCENDING
                          posnr ASCENDING.

  " 2) SECUENCIACIÓN BOBINAS:

  CLEAR: lt_dat_bob, ls_dat_bob.
  REFRESH: lt_dat_bob.

  " Recuperamos los datos de las órdenes de bobinas que no hayan sido liberadas:
  SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_dat_bob
  FROM aufk AS a
  INNER JOIN jest AS b ON b~objnr = a~objnr
  INNER JOIN caufv AS c ON c~aufnr = a~aufnr
  WHERE b~stat = 'I0001'
  AND b~inact = ' '
  AND a~auart = 'ZI02'.
  "  AND c~gltrp <= s_mbdat-high.

  " Seleccionamos datos de las órdenes de bobina a secuenciar:
  LOOP AT lt_dat_bob INTO ls_dat_bob WHERE zzebeln1 IS NOT INITIAL
                                     AND zzebelp1 IS NOT INITIAL.
    CLEAR ls_dat_ord.
    ls_dat_ord-mbdat = ls_dat_bob-zzfec_entreg1.
    ls_dat_ord-vbeln = ls_dat_bob-zzebeln1.
    ls_dat_ord-posnr = ls_dat_bob-zzebelp1.
    ls_dat_ord-kunnr = ls_dat_bob-zzkunnr1.
    ls_dat_ord-werks = ls_dat_bob-werks.
    SELECT SINGLE plnbez INTO ls_dat_ord-matnr
      FROM afko
      WHERE aufnr = ls_dat_bob-aufnr.
*    SELECT SINGLE matkl zzgramaje zzancho INTO (ls_dat_ord-matkl, ls_dat_ord-zzgramaje, ls_dat_ord-zzancho)
*      FROM mara
*      WHERE matnr = ls_dat_ord-matnr.
*    PERFORM calc_escalon  USING  ls_dat_ord-matnr
*                                 ls_dat_ord-zzgramaje
*                                 ls_dat_ord-zzancho
*                                 ls_dat_ord-matkl
*                          CHANGING ls_dat_ord-escalon.
    SELECT SINGLE maktx INTO ls_dat_ord-maktx
      FROM makt
      WHERE matnr = ls_dat_ord-matnr
      AND spras = sy-langu.
    ls_dat_ord-aufnr = ls_dat_bob-aufnr.
    ls_dat_ord-auart = ls_dat_bob-auart.
    IF ls_dat_ord-vbeln IS NOT INITIAL AND ls_dat_ord-posnr IS NOT INITIAL.
      APPEND ls_dat_ord TO gt_datos_bobinas.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_REC_ORDENES
*&---------------------------------------------------------------------*
*&      Form  F_SECUENCIACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_secuenciacion .

  DATA: lv_sentido(1),
        lv_escalon    TYPE zindice_prod,
*        lv_tot_esc    type i,
        lv_sec        TYPE cy_seqnr,
        lv_max_esc    TYPE zindice_prod,
        lv_min_esc    TYPE zindice_prod,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp.

  CLEAR: lv_sentido, lv_escalon, lv_sec, lv_fecha_rol, lv_hora_rol, lv_fecha_bob, lv_hora_bob.
  CLEAR: lv_max_esc, lv_min_esc.

  " 0) Cálculo escalón máximo y mínimo de la tabla de secuenciación:
  PERFORM min_max_sec CHANGING lv_max_esc
                               lv_min_esc.

  " 1) Establecer secuenciación actual: Pto secuencia y si es ascendente/
  "    descendente:

  PERFORM sec_actual USING lv_max_esc
                           lv_min_esc
                     CHANGING lv_sentido
                             lv_escalon.
  " 2) Obtención de la secuencia a partir de la cuál se va a hacer la resecuenciación de las órdenes
  "    no liberadas, así como fecha y hora a partir de la cuál se pueden secuenciar las órdenes de
  "    rollo y bobina:
  PERFORM num_sec_actual_2 CHANGING lv_sec
                                lv_fecha_rol
                                lv_hora_rol
                                lv_fecha_bob
                                lv_hora_bob.


  " 3) Establecemos secuencia, fechas y creamos las órdenes:
  "    También llenamos una tabla interna con los resultados del proceso
  "    para pintar el ALV posterior de log

  PERFORM f_sec_ordenes USING lv_sentido
                                lv_escalon
                                lv_sec
                                lv_max_esc
                                lv_fecha_rol
                                lv_hora_rol
                                lv_fecha_bob
                                lv_hora_bob
                                lv_min_esc.

ENDFORM.                    " F_SECUENCIACION
*&---------------------------------------------------------------------*
*&      Form  NUM_SEC_ACTUAL_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_SEC  text
*      <--P_LV_FECHA_ROL  text
*      <--P_LV_HORA_ROL  text
*      <--P_LV_FECHA_BOB  text
*      <--P_LV_HORA_BOB  text
*----------------------------------------------------------------------*
FORM num_sec_actual_2  CHANGING p_sec
                                p_fecha_rol
                                p_hora_rol
                                p_fecha_bob
                                p_hora_bob.

  DATA: BEGIN OF lt_lib_rollo OCCURS 0,
          aufnr    TYPE aufnr,
          werks    TYPE werks_d,
          cy_seqnr TYPE cy_seqnr,
          gltrp    TYPE co_gltrp,
          gluzp    TYPE co_gluzp,
        END OF lt_lib_rollo.

  DATA: BEGIN OF lt_lib_bob OCCURS 0,
          aufnr TYPE aufnr,
          werks TYPE werks_d,
          gltrp TYPE co_gltrp,
          gluzp TYPE co_gluzp,
        END OF lt_lib_bob.


  DATA: ls_lib_rollo LIKE LINE OF lt_lib_rollo,
        ls_lib_bob   LIKE LINE OF lt_lib_bob.

  DATA: lv_fabkl TYPE fabkl.

  CLEAR: lt_lib_rollo, ls_lib_rollo.
  REFRESH: lt_lib_rollo.

* 1) SECUENCIA, FECHA Y HORA MÁXIMA DE ÓRDENES ROLLO:

  " Seleccionamos todas las órdenes en estado liberado (I0002)
  " que hay hasta la fecha máx de entrega indicada:

  SELECT a~aufnr b~werks a~cy_seqnr c~gltrp c~gluzp INTO CORRESPONDING FIELDS OF TABLE lt_lib_rollo
  FROM afko AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN caufv AS c ON c~aufnr = a~aufnr
    INNER JOIN jest AS d ON d~objnr = b~objnr
      WHERE d~stat = 'I0002'
      AND d~inact = ' '
      AND b~auart = 'ZI01'.
*      AND c~gltrp <= s_mbdat-high.

  " Me quedo con la secuencia máxima rollo para secuenciar las órdenes no liberadas:
  SORT lt_lib_rollo BY cy_seqnr DESCENDING
                       gltrp DESCENDING
                       gluzp DESCENDING.

  CLEAR ls_lib_rollo.
  READ TABLE lt_lib_rollo INTO ls_lib_rollo INDEX 1.
  IF ls_lib_rollo IS NOT INITIAL.
    p_sec = ls_lib_rollo-cy_seqnr + 1.
  ELSE.
    p_sec = 1.
  ENDIF.

  " Me quedo con la fecha y hora a partir de la cuál voy a ir secuenciando las órdenes rollo:
  SORT lt_lib_rollo BY gltrp DESCENDING
                       gluzp DESCENDING.
  CLEAR ls_lib_rollo.
  READ TABLE lt_lib_rollo INTO ls_lib_rollo INDEX 1.
  IF ls_lib_rollo IS NOT INITIAL.
    p_hora_rol = ls_lib_rollo-gluzp + 1.
    IF p_hora_rol = '000001'.
      p_fecha_rol = ls_lib_rollo-gltrp + 1.
      CLEAR lv_fabkl.
      SELECT SINGLE fabkl INTO lv_fabkl
        FROM t001w
        WHERE werks = ls_lib_rollo-werks.
      IF lv_fabkl IS INITIAL.
        lv_fabkl = 'ES'.
      ENDIF.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = p_fecha_rol
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = p_fecha_rol
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
*      IF sy-subrc <> 0.
** Implement suitable error handling here
*      ENDIF.
    ELSE.
      p_fecha_rol = ls_lib_rollo-gltrp.
    ENDIF.
  ENDIF.

* 2) FECHA Y HORA MÁXIMA DE ÓRDENES BOBINA:

  CLEAR: lt_lib_bob, ls_lib_bob.
  REFRESH: lt_lib_bob.

  " Seleccionamos todas las órdenes bobina en estado liberado (I0002)
  " que hay hasta la fecha máx de entrega indicada:

  SELECT a~aufnr b~werks c~gltrp c~gluzp INTO CORRESPONDING FIELDS OF TABLE lt_lib_bob
  FROM afko AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN caufv AS c ON c~aufnr = a~aufnr
    INNER JOIN jest AS d ON d~objnr = b~objnr
      WHERE d~stat = 'I0002'
      AND d~inact = ' '
      AND b~auart = 'ZI02'.
*      AND c~gltrp <= s_mbdat-high.

  " Me quedo con la fecha y hora a partir de la cuál voy a ir secuenciando las órdenes bobina:
  SORT lt_lib_bob BY gltrp DESCENDING
                       gluzp DESCENDING.
  CLEAR ls_lib_bob.
  READ TABLE lt_lib_bob INTO ls_lib_bob INDEX 1.
  IF ls_lib_bob IS NOT INITIAL.
    p_hora_bob = ls_lib_bob-gluzp + 1.
    IF p_hora_bob = '000001'.
      p_fecha_bob = ls_lib_bob-gltrp + 1.
      CLEAR lv_fabkl.
      SELECT SINGLE fabkl INTO lv_fabkl
        FROM t001w
        WHERE werks = ls_lib_bob-werks.
      IF lv_fabkl IS INITIAL.
        lv_fabkl = 'ES'.
      ENDIF.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = p_fecha_bob
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = p_fecha_bob
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
*      IF sy-subrc <> 0.
** Implement suitable error handling here
*      ENDIF.
    ELSE.
      p_fecha_bob = ls_lib_bob-gltrp.
    ENDIF.
  ENDIF.

ENDFORM.                    " NUM_SEC_ACTUAL_2
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORDENES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_SENTIDO  text
*      -->P_LV_ESCALON  text
*      -->P_LV_SEC  text
*      -->P_LV_MAX_ESC  text
*      -->P_LV_FECHA_ROL  text
*      -->P_LV_HORA_ROL  text
*      -->P_LV_FECHA_BOB  text
*      -->P_LV_HORA_BOB  text
*----------------------------------------------------------------------*
FORM f_sec_ordenes  USING    p_sentido
                             p_escalon
                             p_secuencia
                             p_total_esc
                             p_fecha_rol
                             p_hora_rol
                             p_fecha_bob
                             p_hora_bob
                             p_min_esc.

  IF p_sentido = 'A'.
    PERFORM f_sec_ord_ascending USING p_escalon
                                      p_secuencia
                                      p_total_esc
                                      p_fecha_rol
                                      p_hora_rol
                                      p_fecha_bob
                                      p_hora_bob
                                      p_sentido
                                      p_min_esc.
  ELSEIF p_sentido = 'D'.
    PERFORM f_sec_orden_descending USING p_escalon
                                         p_secuencia
                                         p_total_esc
                                         p_fecha_rol
                                         p_hora_rol
                                         p_fecha_bob
                                         p_hora_bob
                                         p_sentido
                                         p_min_esc.
  ENDIF.

ENDFORM.                    " F_SEC_ORDENES
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORD_ASCENDING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_ESCALON  text
*      -->P_P_SECUENCIA  text
*      -->P_P_TOTAL_ESC  text
*      -->P_P_FECHA_ROL  text
*      -->P_P_HORA_ROL  text
*      -->P_P_FECHA_BOB  text
*      -->P_P_HORA_BOB  text
*----------------------------------------------------------------------*
FORM f_sec_ord_ascending  USING    p_escalon
                                   p_secuencia
                                   p_total_esc
                                   p_fecha_rol
                                   p_hora_rol
                                   p_fecha_bob
                                   p_hora_bob
                                   p_sentido
                                   p_min_esc.


  DATA: lv_escalon    TYPE i,
        ls_dat_rollo  TYPE zspp_linea_orden,
        ls_dat_bob    TYPE zspp_linea_orden,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp,
        lv_ok(1),
        ls_listado1   LIKE gt_listado1,
        lv_aufnr      TYPE aufnr,
        lv_seqnr      TYPE cy_seqnr,
        lv_sentido(1),
        lv_vueltas    TYPE zindice_prod.

  CLEAR: lv_escalon, ls_dat_rollo, ls_dat_bob, lv_index, lv_fecha_rol, lv_hora_rol, lv_fecha_bob, lv_hora_bob, lv_index_2.
  CLEAR: lv_sentido, lv_vueltas.
  lv_escalon = p_escalon.
  lv_fecha_rol = p_fecha_rol.
  lv_hora_rol = p_hora_rol.
  lv_fecha_bob = p_fecha_bob.
  lv_hora_bob = p_hora_bob.
  lv_sentido = p_sentido.


  " 1) SECUENCIACIÓN DE ÓRDENES DE ROLLO:

* Vamos a dar tantas vueltas, como puntos esté compuesta una vuelta entera:
  lv_vueltas = 2 * p_total_esc.

*  DO p_total_esc TIMES.
  DO lv_vueltas TIMES.
    LOOP AT gt_datos_rollos INTO ls_dat_rollo WHERE escalon = lv_escalon
                                              AND procesado <> 'X'.
      lv_index = sy-tabix.
      " Secuenciamos orden de rollo:
      CLEAR lv_ok.
      PERFORM f_resec_orden_rollo USING ls_dat_rollo
                                        p_secuencia
                                  CHANGING ls_dat_rollo-cy_seqnr
                                           lv_ok
                                           lv_fecha_rol
                                           lv_hora_rol.
      IF lv_ok = 'X'.
* GST - 23/10/2014 ->
        ls_dat_rollo-procesado = 'X'.
* GST - 23/10/2014 <-
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.
        " Actualizamos la tabla de las ordenes de bobina a secuenciar
        " para indicar la secuencia que le corresponde:
        CLEAR ls_dat_bob.
        LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE vbeln = ls_dat_rollo-vbeln
                                                 AND posnr = ls_dat_rollo-posnr.
          lv_index_2 = sy-tabix.
          ls_dat_bob-cy_seqnr = ls_dat_rollo-cy_seqnr.
          MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index_2.
        ENDLOOP.
        " Pasamos a dar la siguiente secuencia:
        p_secuencia = p_secuencia + 1.
      ELSE.
        " Error en secuenciación de orden rollo:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_rollo-vbeln.
        ls_listado1-posnr = ls_dat_rollo-posnr.
        ls_listado1-matnr = ls_dat_rollo-matnr.
        ls_listado1-maktx = ls_dat_rollo-maktx.
        ls_listado1-auart = 'ZI01'.
        ls_listado1-aufnr = ls_dat_rollo-aufnr.
        ls_listado1-kunnr = ls_dat_rollo-kunnr.
        ls_listado1-werks = ls_dat_rollo-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = 'No se ha podido secuenciar orden rollo'.
        APPEND ls_listado1 TO gt_listado1.

        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Error en secuenciación de orden bobina y se borra de la tabla de bobinas:
        LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE vbeln = ls_dat_rollo-vbeln
                                                 AND posnr = ls_dat_rollo-posnr.
          lv_index_2 = sy-tabix.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_bob-vbeln.
          ls_listado1-posnr = ls_dat_bob-posnr.
          ls_listado1-matnr = ls_dat_bob-matnr.
          ls_listado1-maktx = ls_dat_bob-maktx.
          ls_listado1-auart = 'ZI02'.
          ls_listado1-aufnr = ls_dat_bob-aufnr.
          ls_listado1-kunnr = ls_dat_bob-kunnr.
          ls_listado1-werks = ls_dat_bob-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
          APPEND ls_listado1 TO gt_listado1.
          DELETE gt_datos_bobinas INDEX lv_index_2.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
* GST - 23/10/2014 ->
*    lv_escalon = lv_escalon + 1.
*    IF lv_escalon > p_total_esc.
*      lv_escalon = 1.
*    ENDIF.

    IF lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ELSE.
      lv_escalon = lv_escalon - 1.
    ENDIF.

    IF lv_sentido = 'A' AND  lv_escalon > p_total_esc.
      lv_sentido = 'D'.
      lv_escalon = lv_escalon - 1.
    ELSEIF lv_sentido = 'D' AND lv_escalon < p_min_esc.
      lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ENDIF.
* GST - 23/10/2014 <-
  ENDDO.

  " 2) SECUENCIACIÓN DE ÓRDENES DE BOBINA:

  " 2.1. Miramos de la tabla de órdenes de bobina las que no tienen secuencia
  " si corresponden a una orden de rollo ya liberada: En ese caso se le da
  " la secuencia de la orden de rollo liberada, pero se vuelve a secuenciar
  " se planifica con nuevas fechas. Las que no encuentren correspondencia
  " se eliminan de la secuenciación, pero se devuelve un error con todos
  " los datos posibles.

  CLEAR: ls_dat_bob, lv_index.
  LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE cy_seqnr IS INITIAL.
    lv_index = sy-tabix.
    CLEAR lv_aufnr.
    SELECT SINGLE aufnr INTO lv_aufnr
      FROM aufk
      WHERE zzebeln1 = ls_dat_bob-vbeln
      AND zzebelp1 = ls_dat_bob-posnr
      AND auart = 'ZI01'.
    IF lv_aufnr IS NOT INITIAL.
      CLEAR lv_seqnr.
      SELECT SINGLE cy_seqnr INTO lv_seqnr
        FROM afko
        WHERE aufnr = lv_aufnr.

      IF lv_seqnr IS NOT INITIAL.
        ls_dat_bob-cy_seqnr = lv_seqnr.
        MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index.
      ELSE.

        " Guardamos error y borramos registro:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_bob-vbeln.
        ls_listado1-posnr = ls_dat_bob-posnr.
        ls_listado1-matnr = ls_dat_bob-matnr.
        ls_listado1-maktx = ls_dat_bob-maktx.
        ls_listado1-auart = 'ZI02'.
        ls_listado1-aufnr = ls_dat_bob-aufnr.
        ls_listado1-kunnr = ls_dat_bob-kunnr.
        ls_listado1-werks = ls_dat_bob-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
        APPEND ls_listado1 TO gt_listado1.

        DELETE gt_datos_bobinas INDEX lv_index.

      ENDIF.

    ELSE.
      " Guardamos error y borramos registro:
      CLEAR ls_listado1.
      ls_listado1-vbeln = ls_dat_bob-vbeln.
      ls_listado1-posnr = ls_dat_bob-posnr.
      ls_listado1-matnr = ls_dat_bob-matnr.
      ls_listado1-maktx = ls_dat_bob-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-kunnr = ls_dat_bob-kunnr.
      ls_listado1-werks = ls_dat_bob-werks.
      ls_listado1-aufnr = ls_dat_bob-aufnr.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
      APPEND ls_listado1 TO gt_listado1.

      DELETE gt_datos_bobinas INDEX lv_index.
    ENDIF.

  ENDLOOP.

  " 2.2. Ordenamos la tabla de órdenes de bobina a secuenciar en base a
  " secuencia, fecha de entrega, pedido y posición:

  SORT gt_datos_bobinas BY cy_seqnr ASCENDING
                           mbdat ASCENDING
                           vbeln ASCENDING
                           posnr ASCENDING.

  LOOP AT gt_datos_bobinas INTO ls_dat_bob.
    PERFORM f_resec_orden_bob USING ls_dat_bob
                            CHANGING lv_fecha_bob
                                     lv_hora_bob.
  ENDLOOP.


ENDFORM.                    " F_SEC_ORD_ASCENDING
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORDEN_DESCENDING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_ESCALON  text
*      -->P_P_SECUENCIA  text
*      -->P_P_TOTAL_ESC  text
*      -->P_P_FECHA_ROL  text
*      -->P_P_HORA_ROL  text
*      -->P_P_FECHA_BOB  text
*      -->P_P_HORA_BOB  text
*----------------------------------------------------------------------*
FORM f_sec_orden_descending  USING    p_escalon
                                      p_secuencia
                                      p_total_esc
                                      p_fecha_rol
                                      p_hora_rol
                                      p_fecha_bob
                                      p_hora_bob
                                      p_sentido
                                      p_min_esc.

  DATA: lv_escalon    TYPE i,
        ls_dat_rollo  TYPE zspp_linea_orden,
        ls_dat_bob    TYPE zspp_linea_orden,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp,
        lv_ok(1),
        ls_listado1   LIKE gt_listado1,
        lv_aufnr      TYPE aufnr,
        lv_seqnr      TYPE cy_seqnr,
        lv_sentido(1),
        lv_vueltas    TYPE zindice_prod.

  CLEAR: lv_escalon, ls_dat_rollo, ls_dat_bob, lv_index, lv_fecha_rol, lv_hora_rol, lv_fecha_bob, lv_hora_bob, lv_index_2.
  CLEAR: lv_sentido, lv_vueltas.
  lv_escalon = p_escalon.
  lv_fecha_rol = p_fecha_rol.
  lv_hora_rol = p_hora_rol.
  lv_fecha_bob = p_fecha_bob.
  lv_hora_bob = p_hora_bob.
  lv_sentido = p_sentido.

  " 1) SECUENCIACIÓN DE ÓRDENES DE ROLLO:

* Vamos a dar tantas vueltas, como puntos esté compuesta una vuelta entera:
  lv_vueltas = 2 * p_total_esc.

*  DO p_total_esc TIMES.
  DO lv_vueltas TIMES.
    LOOP AT gt_datos_rollos INTO ls_dat_rollo WHERE escalon = lv_escalon
                                                    AND procesado <> 'X'.
      lv_index = sy-tabix.
      " Secuenciamos orden de rollo:
      CLEAR lv_ok.
      PERFORM f_resec_orden_rollo USING ls_dat_rollo
                                        p_secuencia
                                  CHANGING ls_dat_rollo-cy_seqnr
                                           lv_ok
                                           lv_fecha_rol
                                           lv_hora_rol.
      IF lv_ok = 'X'.
* GST - 23/10/2014 ->
        ls_dat_rollo-procesado = 'X'.
* GST - 23/10/2014 <-
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.
        " Actualizamos la tabla de las ordenes de bobina a secuenciar
        " para indicar la secuencia que le corresponde:
        CLEAR ls_dat_bob.
        LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE vbeln = ls_dat_rollo-vbeln
                                                 AND posnr = ls_dat_rollo-posnr.
          lv_index_2 = sy-tabix.
          ls_dat_bob-cy_seqnr = ls_dat_rollo-cy_seqnr.
          MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index_2.
        ENDLOOP.
        " Pasamos a dar la siguiente secuencia:
        p_secuencia = p_secuencia + 1.
      ELSE.
        " Error en secuenciación de orden rollo:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_rollo-vbeln.
        ls_listado1-posnr = ls_dat_rollo-posnr.
        ls_listado1-matnr = ls_dat_rollo-matnr.
        ls_listado1-maktx = ls_dat_rollo-maktx.
        ls_listado1-auart = 'ZI01'.
        ls_listado1-aufnr = ls_dat_rollo-aufnr.
        ls_listado1-kunnr = ls_dat_rollo-kunnr.
        ls_listado1-werks = ls_dat_rollo-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = 'No se ha podido secuenciar orden rollo'.
        APPEND ls_listado1 TO gt_listado1.

        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Error en secuenciación de orden bobina y se borra de la tabla de bobinas:
        LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE vbeln = ls_dat_rollo-vbeln
                                                 AND posnr = ls_dat_rollo-posnr.
          lv_index_2 = sy-tabix.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_bob-vbeln.
          ls_listado1-posnr = ls_dat_bob-posnr.
          ls_listado1-matnr = ls_dat_bob-matnr.
          ls_listado1-maktx = ls_dat_bob-maktx.
          ls_listado1-auart = 'ZI02'.
          ls_listado1-aufnr = ls_dat_bob-aufnr.
          ls_listado1-kunnr = ls_dat_bob-kunnr.
          ls_listado1-werks = ls_dat_bob-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
          APPEND ls_listado1 TO gt_listado1.
          DELETE gt_datos_bobinas INDEX lv_index_2.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

* GST - 23/10/2014 ->
*    lv_escalon = lv_escalon - 1.
*    IF lv_escalon = 0.
*      lv_escalon = p_total_esc.
*    ENDIF.

    IF lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ELSE.
      lv_escalon = lv_escalon - 1.
    ENDIF.

    IF lv_sentido = 'A' AND  lv_escalon > p_total_esc.
      lv_sentido = 'D'.
      lv_escalon = lv_escalon - 1.
    ELSEIF lv_sentido = 'D' AND lv_escalon < p_min_esc.
      lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ENDIF.

* GST - 23/10/2014 <-
  ENDDO.

  " 2) SECUENCIACIÓN DE ÓRDENES DE BOBINA:

  " 2.1. Miramos de la tabla de órdenes de bobina las que no tienen secuencia
  " si corresponden a una orden de rollo ya liberada: En ese caso se le da
  " la secuencia de la orden de rollo liberada, pero se vuelve a secuenciar
  " se planifica con nuevas fechas. Las que no encuentren correspondencia
  " se eliminan de la secuenciación, pero se devuelve un error con todos
  " los datos posibles.

  CLEAR: ls_dat_bob, lv_index.
  LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE cy_seqnr IS INITIAL.
    lv_index = sy-tabix.
    CLEAR lv_aufnr.
    SELECT SINGLE aufnr INTO lv_aufnr
      FROM aufk
      WHERE zzebeln1 = ls_dat_bob-vbeln
      AND zzebelp1 = ls_dat_bob-posnr
      AND auart = 'ZI01'.
    IF lv_aufnr IS NOT INITIAL.
      CLEAR lv_seqnr.
      SELECT SINGLE cy_seqnr INTO lv_seqnr
        FROM afko
        WHERE aufnr = lv_aufnr.

      IF lv_seqnr IS NOT INITIAL.
        ls_dat_bob-cy_seqnr = lv_seqnr.
        MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index.
      ELSE.

        " Guardamos error y borramos registro:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_bob-vbeln.
        ls_listado1-posnr = ls_dat_bob-posnr.
        ls_listado1-matnr = ls_dat_bob-matnr.
        ls_listado1-maktx = ls_dat_bob-maktx.
        ls_listado1-auart = 'ZI02'.
        ls_listado1-aufnr = ls_dat_bob-aufnr.
        ls_listado1-kunnr = ls_dat_bob-kunnr.
        ls_listado1-werks = ls_dat_bob-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
        APPEND ls_listado1 TO gt_listado1.

        DELETE gt_datos_bobinas INDEX lv_index.

      ENDIF.

    ELSE.
      " Guardamos error y borramos registro:
      CLEAR ls_listado1.
      ls_listado1-vbeln = ls_dat_bob-vbeln.
      ls_listado1-posnr = ls_dat_bob-posnr.
      ls_listado1-matnr = ls_dat_bob-matnr.
      ls_listado1-maktx = ls_dat_bob-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-kunnr = ls_dat_bob-kunnr.
      ls_listado1-werks = ls_dat_bob-werks.
      ls_listado1-aufnr = ls_dat_bob-aufnr.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      ls_listado1-msg_ret = 'No se ha encontrado correspondencia con orden rollo'.
      APPEND ls_listado1 TO gt_listado1.

      DELETE gt_datos_bobinas INDEX lv_index.
    ENDIF.

  ENDLOOP.

  " 2.2. Ordenamos la tabla de órdenes de bobina a secuenciar en base a
  " secuencia, fecha de entrega, pedido y posición:

  SORT gt_datos_bobinas BY cy_seqnr ASCENDING
                           mbdat ASCENDING
                           vbeln ASCENDING
                           posnr ASCENDING.

  LOOP AT gt_datos_bobinas INTO ls_dat_bob.
    PERFORM f_resec_orden_bob USING ls_dat_bob
                            CHANGING lv_fecha_bob
                                     lv_hora_bob.
  ENDLOOP.

ENDFORM.                    " F_SEC_ORDEN_DESCENDING
*&---------------------------------------------------------------------*
*&      Form  F_RESEC_ORDEN_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DAT_ROLLO  text
*      -->P_P_SECUENCIA  text
*      <--P_LS_DAT_ROLLO_CY_SEQNR  text
*      <--P_LV_OK  text
*      <--P_LV_FECHA_ROL  text
*      <--P_LV_HORA_ROL  text
*----------------------------------------------------------------------*
FORM f_resec_orden_rollo  USING    ps_dat_rollo TYPE zspp_linea_orden
                                   p_secuencia
                          CHANGING p_cy_seqnr
                                   p_ok
                                   p_fecha_rol
                                   p_hora_rol.

  DATA: ls_orderdata  TYPE bapi_pi_order_change,
        ls_orderdatax TYPE bapi_pi_order_changex,
        lt_return     TYPE bapiret2_tab,
        ls_return     TYPE bapiret2,
        ls_listado1   LIKE gt_listado1.

  DATA:   ls_messtab     LIKE i_messtab,
          ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_orderdatax, lt_return, ls_return, p_ok.
  REFRESH: lt_return.

  " Datos a modificar:
  ls_orderdata-sequence_number = p_secuencia.
  ls_orderdata-basic_start_date = p_fecha_rol.
  ls_orderdata-basic_start_time = p_hora_rol.


  ls_orderdatax-sequence_number = 'X'.
  ls_orderdatax-basic_start_date = 'X'.
  ls_orderdatax-basic_end_date = 'X'.

  CALL FUNCTION 'BAPI_PROCORD_CHANGE'
    EXPORTING
      number     = ps_dat_rollo-aufnr
      orderdata  = ls_orderdata
      orderdatax = ls_orderdatax
    IMPORTING
      return     = ls_return.
*   ORDER_TYPE             =
*   ORDER_STATUS           =
*   MASTER_DATA_READ       =

  IF ls_return-type = 'E'.
    CLEAR ls_listado1.
    ls_listado1-vbeln = ps_dat_rollo-vbeln.
    ls_listado1-posnr = ps_dat_rollo-posnr.
    ls_listado1-matnr = ps_dat_rollo-matnr.
    ls_listado1-maktx = ps_dat_rollo-maktx.
    ls_listado1-auart = 'ZI01'.
    ls_listado1-aufnr = ps_dat_rollo-aufnr.
    ls_listado1-kunnr = ps_dat_rollo-kunnr.
    ls_listado1-werks = ps_dat_rollo-werks.
    ls_listado1-cy_seqnr = p_secuencia.
    ls_listado1-icon = '@0A@'.
    ls_listado1-tipo = 'S'.
    ls_listado1-type_ret = ls_return-type.
    ls_listado1-msg_ret = ls_return-message.
    APPEND ls_listado1 TO gt_listado1.

  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
    p_ok = 'X'.
    p_cy_seqnr = p_secuencia.
    WAIT UP TO 1 SECONDS.

    PERFORM f_calc_fec_hora USING  ps_dat_rollo-aufnr
                                   ps_dat_rollo-werks
                          CHANGING p_fecha_rol
                                   p_hora_rol.

    "Hacemos EXPORT a memoria con la orden para no tener problemas con el batch input y
    "los campos que se sombrean en pantalla en la COR2.
    EXPORT  gv_order_number FROM ps_dat_rollo-aufnr TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:
    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  ps_dat_rollo-aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZSECUENCIA'.
    PERFORM bdc_field       USING 'AUFK-ZZSECUENCIA'
                                  p_secuencia.

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.
      p_ok = 'X'.
      p_cy_seqnr = p_secuencia.
*      CLEAR: p_ok, p_cy_seqnr.
*      clear: ls_return_roll, p_ok, p_cy_seqnr.
*      call function 'BAPI_TRANSACTION_ROLLBACK'
*        importing
*          return = ls_return_roll.

      CLEAR: ls_listado1.
      ls_listado1-vbeln = ps_dat_rollo-vbeln.
      ls_listado1-posnr = ps_dat_rollo-posnr.
      ls_listado1-matnr = ps_dat_rollo-matnr.
      ls_listado1-maktx = ps_dat_rollo-maktx.
      ls_listado1-auart = 'ZI01'.
      ls_listado1-aufnr = ps_dat_rollo-aufnr.
      ls_listado1-kunnr = ps_dat_rollo-kunnr.
      ls_listado1-werks = ps_dat_rollo-werks.
      ls_listado1-cy_seqnr = p_secuencia.
      ls_listado1-icon = '@0A@'.
      ls_listado1-type_ret = 'E'.
      ls_listado1-tipo = 'S'.
      PERFORM mensajes_error
        TABLES i_messtab
        CHANGING ls_listado1-msg_ret.
      APPEND ls_listado1 TO gt_listado1.
    ELSE.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      p_ok = 'X'.
      p_cy_seqnr = p_secuencia.
      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_rollo-vbeln.
      ls_listado1-posnr = ps_dat_rollo-posnr.
      ls_listado1-matnr = ps_dat_rollo-matnr.
      ls_listado1-maktx = ps_dat_rollo-maktx.
      ls_listado1-auart = 'ZI01'.
      ls_listado1-aufnr = ps_dat_rollo-aufnr.
      ls_listado1-kunnr = ps_dat_rollo-kunnr.
      ls_listado1-werks = ps_dat_rollo-werks.
      ls_listado1-cy_seqnr = p_secuencia.
      ls_listado1-icon = '@08@'. " Semaforito verde
      ls_listado1-tipo = 'S'.
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.

  ENDIF.



ENDFORM.                    " F_RESEC_ORDEN_ROLLO
*&---------------------------------------------------------------------*
*&      Form  F_CALC_FEC_HORA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_DAT_ROLLO_AUFNR  text
*      <--P_P_FECHA_ROL  text
*      <--P_P_HORA_ROL  text
*----------------------------------------------------------------------*
FORM f_calc_fec_hora  USING    p_aufnr
                               p_werks
                      CHANGING p_fecha
                               p_hora.

  DATA: lv_gltrp TYPE co_gltrp,
        lv_gluzp TYPE co_gluzp,
        lv_fabkl TYPE fabkl,
        lv_hora  TYPE co_gluzp,
        lv_fecha TYPE co_gltrp.


  CLEAR: lv_gltrp, lv_gluzp, lv_fabkl, lv_hora, lv_fecha.

  " Sacamos la fecha y hora fin extrema:

  SELECT SINGLE gltrp gluzp INTO (lv_gltrp, lv_gluzp)
    FROM caufv
    WHERE aufnr = p_aufnr.

  " Sacamos el calendario de fábrica:
  SELECT SINGLE fabkl INTO lv_fabkl
    FROM t001w
    WHERE werks = p_werks.
  IF lv_fabkl IS INITIAL.
    lv_fabkl = 'ES'.
  ENDIF.

  " Cálculamos la siguiente fecha y hora de inicio disponibles:
  IF lv_fabkl IS NOT INITIAL.
    lv_hora = lv_gluzp + 1.
    IF lv_hora = '000001'.
      lv_fecha = lv_gltrp + 1.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = lv_fecha
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = lv_fecha
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ENDIF.
    ELSE.
      lv_fecha = lv_gltrp.
    ENDIF.
  ELSE.
    lv_hora = lv_gluzp + 1.
    IF lv_hora = '000001'.
      lv_fecha = lv_gltrp + 1.
    ELSE.
      lv_fecha = lv_gltrp.
    ENDIF.
  ENDIF.

  " Pasamos los valores obtenidos a los parámetros:
  p_fecha = lv_fecha.
  p_hora = lv_hora.

ENDFORM.                    " F_CALC_FEC_HORA
*&---------------------------------------------------------------------*
*&      Form  F_RESEC_ORDEN_BOB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DAT_BOB  text
*      <--P_LV_FECHA_BOB  text
*      <--P_LV_HORA_BOB  text
*----------------------------------------------------------------------*
FORM f_resec_orden_bob  USING    ps_dat_bob TYPE zspp_linea_orden
                        CHANGING p_fecha_bob
                                 p_hora_bob.

  DATA: ls_orderdata  TYPE bapi_pi_order_change,
        ls_orderdatax TYPE bapi_pi_order_changex,
        lt_return     TYPE bapiret2_tab,
        ls_return     TYPE bapiret2,
        ls_listado1   LIKE gt_listado1.

  DATA:   ls_messtab     LIKE i_messtab,
          ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_orderdatax, lt_return, ls_return.
  REFRESH: lt_return.

  " Datos a modificar:
  ls_orderdata-sequence_number = ps_dat_bob-cy_seqnr.
  ls_orderdata-basic_start_date = p_fecha_bob.
  ls_orderdata-basic_start_time = p_hora_bob.

  ls_orderdatax-sequence_number = 'X'.
  ls_orderdatax-basic_start_date = 'X'.
  ls_orderdatax-basic_end_date = 'X'.

  CALL FUNCTION 'BAPI_PROCORD_CHANGE'
    EXPORTING
      number     = ps_dat_bob-aufnr
      orderdata  = ls_orderdata
      orderdatax = ls_orderdatax
    IMPORTING
      return     = ls_return.
*   ORDER_TYPE             =
*   ORDER_STATUS           =
*   MASTER_DATA_READ       =

  IF ls_return-type = 'E'.
    CLEAR ls_listado1.
    ls_listado1-vbeln = ps_dat_bob-vbeln.
    ls_listado1-posnr = ps_dat_bob-posnr.
    ls_listado1-matnr = ps_dat_bob-matnr.
    ls_listado1-maktx = ps_dat_bob-maktx.
    ls_listado1-auart = 'ZI02'.
    ls_listado1-aufnr = ps_dat_bob-aufnr.
    ls_listado1-kunnr = ps_dat_bob-kunnr.
    ls_listado1-werks = ps_dat_bob-werks.
    ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
    ls_listado1-icon = '@0A@'.
    ls_listado1-tipo = 'S'.
    ls_listado1-type_ret = ls_return-type.
    ls_listado1-msg_ret = ls_return-message.
    APPEND ls_listado1 TO gt_listado1.

  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
    WAIT UP TO 1 SECONDS.

    PERFORM f_calc_fec_hora USING  ps_dat_bob-aufnr
                                   ps_dat_bob-werks
                          CHANGING p_fecha_bob
                                   p_hora_bob.

    "Hacemos EXPORT a memoria con la orden para no tener problemas con el batch input y
    "los campos que se sombrean en pantalla en la COR2.
    EXPORT  gv_order_number FROM ps_dat_bob-aufnr TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:
    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  ps_dat_bob-aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZSECUENCIA'.
    PERFORM bdc_field       USING 'AUFK-ZZSECUENCIA'
                                  ps_dat_bob-cy_seqnr.

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.
*      clear: ls_return_roll.
*      call function 'BAPI_TRANSACTION_ROLLBACK'
*        importing
*          return = ls_return_roll.

      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_bob-vbeln.
      ls_listado1-posnr = ps_dat_bob-posnr.
      ls_listado1-matnr = ps_dat_bob-matnr.
      ls_listado1-maktx = ps_dat_bob-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-aufnr = ps_dat_bob-aufnr.
      ls_listado1-kunnr = ps_dat_bob-kunnr.
      ls_listado1-werks = ps_dat_bob-werks.
      ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
      ls_listado1-icon = '@0A@'.
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      PERFORM mensajes_error
        TABLES i_messtab
        CHANGING ls_listado1-msg_ret.
      APPEND ls_listado1 TO gt_listado1.
    ELSE.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_bob-vbeln.
      ls_listado1-posnr = ps_dat_bob-posnr.
      ls_listado1-matnr = ps_dat_bob-matnr.
      ls_listado1-maktx = ps_dat_bob-maktx.
      ls_listado1-auart = 'ZI02'.
      ls_listado1-aufnr = ps_dat_bob-aufnr.
      ls_listado1-kunnr = ps_dat_bob-kunnr.
      ls_listado1-werks = ps_dat_bob-werks.
      ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
      ls_listado1-tipo = 'S'.
      ls_listado1-icon = '@08@'. " Semaforito verde
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.

  ENDIF.




ENDFORM.                    " F_RESEC_ORDEN_BOB

* GST - 05/03/2015 ->

*&---------------------------------------------------------------------*
*&      Form  EXISTE_ORDEN_3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_VBEP_VBELN  text
*      -->P_LS_VBEP_POSNR  text
*      <--P_LV_EXISTE  text
*      <--P_LV_AUFNR_ROL_AUX  text
*      <--P_LV_AUFNR_BOB_AUX  text
*      <--P_LV_SEQNR  text
*----------------------------------------------------------------------*
FORM existe_orden_3  USING    p_vbeln
                              p_posnr
                     CHANGING p_existe_rollo
                              p_existe_bob
                              lv_aufnr_rollo
                              lv_aufnr_bob.

  " 1) Recuperamos la orden de rollo correspondiente si existe:
  CLEAR: lv_aufnr_rollo.
  CLEAR: p_existe_rollo.
* GST - 05/03/2015 ->
  SELECT SINGLE aufnr INTO lv_aufnr_rollo
    FROM aufk
    WHERE ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
    AND auart = 'ZI01'.

*  SELECT SINGLE a~aufnr INTO lv_aufnr_rollo
*  FROM aufk AS a
*  INNER JOIN jest AS b ON b~objnr = a~objnr
*  WHERE ( b~stat = 'I0001' OR b~stat = 'I0002' )
*  AND b~inact = ' '
*  AND a~auart = 'ZI01'
*  AND ( ( a~zebeln1 = p_vbeln AND a~zebelp1 = p_posnr ) OR
*        ( a~zebeln2 = p_vbeln AND a~zebelp2 = p_posnr ) OR
*        ( a~zebeln3 = p_vbeln AND a~zebelp3 = p_posnr ) ).
* GST - 05/03/2015 <-

  IF lv_aufnr_rollo IS NOT INITIAL.
    p_existe_rollo = 'X'.
  ELSE.
    CLEAR p_existe_rollo.  " No existe y son órdenes nuevas a crear
    CLEAR: lv_aufnr_rollo.
  ENDIF.

  " 2) Recuperamos la orden de bobina correspondiente si existe:
  CLEAR: lv_aufnr_bob.
  CLEAR: p_existe_bob.
* GST - 05/03/2015 ->
  SELECT SINGLE aufnr INTO lv_aufnr_bob
    FROM aufk
    WHERE ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
    AND auart = 'ZI02'.

*  SELECT SINGLE a~aufnr INTO lv_aufnr_bob
*  FROM aufk AS a
*  INNER JOIN jest AS b ON b~objnr = a~objnr
*  WHERE ( b~stat = 'I0001' OR b~stat = 'I0002' )
*  AND b~inact = ' '
*  AND a~auart = 'ZI02'
*  AND ( ( a~zebeln1 = p_vbeln AND a~zebelp1 = p_posnr ) OR
*        ( a~zebeln2 = p_vbeln AND a~zebelp2 = p_posnr ) OR
*        ( a~zebeln3 = p_vbeln AND a~zebelp3 = p_posnr ) ).

* GST - 05/03/2015 <-

  IF lv_aufnr_bob IS NOT INITIAL.
    p_existe_bob = 'X'.
  ELSE.
    CLEAR p_existe_bob.  " No existe y son órdenes nuevas a crear
    CLEAR: lv_aufnr_bob.
  ENDIF.

ENDFORM.                    " EXISTE_ORDEN_3

* GST - 05/03/2015 <-
