*&---------------------------------------------------------------------*
*&  Include           ZRPP0029_ALV
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mostrar_datos .

  DATA: lt_toolbar_excluding TYPE ui_functions,
        lt_fieldcat          TYPE lvc_t_fcat.

  DATA: ls_lvc_s_layo TYPE lvc_s_layo,
        ls_variant    TYPE disvariant.

*Variante
  PERFORM prepare_variant CHANGING ls_variant.
*Preparamos el catálogo de campos
  PERFORM prepare_fielcat CHANGING lt_fieldcat.
*Preparamos el layout
  PERFORM prepare_layout CHANGING ls_lvc_s_layo.
*Excluir toolbar
  PERFORM toolbar_excluding CHANGING lt_toolbar_excluding.

*SOTHIS - Ticket  64670 - Corregir ALV (asteriscado)
****
***** Events alv control
****  SET HANDLER G_APPLICATION->ALV_on_DRAG FOR g_grid.
****  SET HANDLER G_APPLICATION->ALV_on_DROP FOR g_grid.

* Mostramos el ALV
  CALL METHOD g_grid->set_table_for_first_display
    EXPORTING
      i_buffer_active      = ' '
      i_bypassing_buffer   = gc_true
      is_layout            = ls_lvc_s_layo
      it_toolbar_excluding = lt_toolbar_excluding
      i_structure_name     = 'GTI_DATOS'
      is_variant           = ls_variant
      i_save               = 'A'
    CHANGING
      it_outtab            = gti_datos[]
      it_fieldcatalog      = lt_fieldcat[].

  CALL METHOD g_grid->register_edit_event
    EXPORTING
      i_event_id = cl_gui_alv_grid=>mc_evt_enter.

  PERFORM refrescar_alv.

ENDFORM.                    " MOSTRAR_DATOS
*&---------------------------------------------------------------------*
*&      Form  prepare_fielcat
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM prepare_fielcat CHANGING ct_fieldcat TYPE lvc_t_fcat.

  DATA: lt_fieldcat TYPE lvc_t_fcat.

  DATA: ls_fcat TYPE lvc_s_fcat.

  DATA: lv_ind TYPE i.

* Recuperamos el catálogo de campos
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZSPP0009'
    CHANGING
      ct_fieldcat      = lt_fieldcat.

* Los cargamos en el catálogo de campos global
  ct_fieldcat[] = lt_fieldcat[].

* Recorremos el catálogo de campos modificandolo
  LOOP AT ct_fieldcat INTO ls_fcat.
    lv_ind = sy-tabix.
    CASE ls_fcat-fieldname.
      WHEN 'LISTA_CALIDAD' OR 'LISTA_GRAMAJE' OR 'LISTA_ANCHO'
           OR'OBJNR' OR 'ZINDEX' OR 'CONCATE_ORDEN'.
        ls_fcat-no_out = gc_true.
      WHEN 'ROLLOS'.
        ls_fcat-edit = gc_true.
*      WHEN 'AUFNR' OR 'PEDIDO_POS1' OR 'PEDIDO_POS2' OR 'PEDIDO_POS3' OR
      WHEN 'AUFNR' OR 'ZICON_OBS_POPE' OR 'ZICON_OBSERVA'.
        ls_fcat-hotspot = 'X'.
      WHEN 'ICON_ESTADO' OR 'ICON_CALIDAD' OR 'ICON_GRAMAJE' OR 'ICON_ANCHO'.
        ls_fcat-just = 'C'.
      WHEN 'ROLLOS' OR 'NUM_FABR'.
        ls_fcat-inttype = 'I'.
      WHEN 'ZZEBELN1' OR 'ZZEBELN2' OR 'ZZEBELN3'.
        ls_fcat-just    = 'R'.
        ls_fcat-hotspot = 'X'.
    ENDCASE.
* Modificamos el catálogo
    MODIFY ct_fieldcat FROM ls_fcat INDEX lv_ind.
  ENDLOOP.

ENDFORM.                    " prepare_fielcat
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR_ALV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM refrescar_alv.

  DATA: ls_layout TYPE lvc_s_layo,
        ls_stable TYPE lvc_s_stbl.

* Sacamos el layout del ALV
  CALL METHOD g_grid->get_frontend_layout
    IMPORTING
      es_layout = ls_layout.

* Ponemos de nuevo que optimice las columnas
  ls_layout-cwidth_opt = gc_true.

* Cargamos de nuevo el layout
  CALL METHOD g_grid->set_frontend_layout
    EXPORTING
      is_layout = ls_layout.

* Refrescamos el ALV
  ls_stable-row = gc_true.
  ls_stable-col = gc_true.

  CALL METHOD g_grid->refresh_table_display
    EXPORTING
      is_stable = ls_stable.

ENDFORM.                    " REFRESCAR_ALV
*&---------------------------------------------------------------------*
*&      Form  ALV_PREPARE_LAYOUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM prepare_layout CHANGING ls_lvc_s_layo TYPE lvc_s_layo.

* Para que muestre el ancho de las columnas optimizado
  ls_lvc_s_layo-cwidth_opt = gc_true.
*  ls_lvc_s_layo-sel_mode   = 'A'.
*  ls_lvc_s_layo-sel_mode   = 'C'.
  ls_lvc_s_layo-zebra = gc_true.
  ls_lvc_s_layo-ctab_fname = 'COLOR'.     "Enlazamos el campo en el layout

ENDFORM.                    " ALV_PREPARE_LAYOUT
*&---------------------------------------------------------------------*
*&      Form  alv_prepare_variant
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM prepare_variant CHANGING ps_variant TYPE disvariant .

  IF gs_variant IS NOT INITIAL.
    ps_variant = gs_variant.
  ELSE.
    CLEAR ps_variant.
    ps_variant-report = sy-repid.
  ENDIF.

ENDFORM.                    "alv_prepare_variant
*&---------------------------------------------------------------------*
*&      Form  alv_toolbar_excluding
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM toolbar_excluding CHANGING lt_toolbar TYPE ui_functions.

  DATA: ls_exclude TYPE ui_func.
  REFRESH: lt_toolbar.

*********************************************************************mc_fc_check
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_check.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_cut
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_copy
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_paste
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_paste_new_row
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_undo
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_append_row
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
  APPEND ls_exclude TO lt_toolbar.
*********************************************************************mc_fc_loc_insert_row
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_delete_row
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_loc_copy_row
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_sort_asc
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_mb_sum.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_subtot
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_subtot.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_print
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_print.
  APPEND ls_exclude TO lt_toolbar.
**********************************************************************mc_fc_views
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_views.
  APPEND ls_exclude TO lt_toolbar.
*********************************************************************mc_mb_export
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
  APPEND ls_exclude TO lt_toolbar.
*********************************************************************mc_fc_info
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_info.
  APPEND ls_exclude TO lt_toolbar.

*********************************************************************mc_fc_info
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
  APPEND ls_exclude TO lt_toolbar.

* 08/07/2021 - CMS - Quitar botones de ordenación ascendente y descendente.
*********************************************************************mc_fc_sort_asc
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_sort_asc.
  APPEND ls_exclude TO lt_toolbar.
*********************************************************************mc_fc_sort_dsc
  CLEAR ls_exclude.
  ls_exclude = cl_gui_alv_grid=>mc_fc_sort_dsc.
  APPEND ls_exclude TO lt_toolbar.

ENDFORM.                    "alv_toolbar_excluding
*&---------------------------------------------------------------------*
*&      Form  LIBERAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

FORM f_liberar USING p_datos TYPE tyt_alv.

  DATA: lti_return TYPE STANDARD TABLE OF bapi_order_return,
        ls_return  TYPE bapiret2.

* Validacion de num.fabr.
  LOOP       AT p_datos ASSIGNING FIELD-SYMBOL(<fs_datos>).

    IF <fs_datos>-stat    <> zcl_secuenciador=>gc_i0001_abierta AND
       <fs_datos>-ind_fin <> 'X'." para liberar, la orden debera estar abierta o finalizada.
      MESSAGE e309(zpp). " Para esta función, el estado de la fabricación no es correcto.
    ENDIF.

  ENDLOOP.

* Tratamiento de la liberación.
  LOOP AT p_datos INTO DATA(ls_reg).

    IF ls_reg-stat = zcl_secuenciador=>gc_i0001_abierta.

      PERFORM liberar_of_abierta CHANGING ls_reg.

    ELSEIF ls_reg-ind_fin <> 'X'.

      ls_reg-icon_estado = '@5Y@'. "Bandera verde-> orden liberada
      ls_reg-stat        = zcl_secuenciador=>gc_i0002_liberada.
      ls_reg-ind_fin     = ' '.

    ENDIF.

* Actualizamos registro de ALV.
    gti_datos[ werks    = ls_reg-werks
               aufnr    = ls_reg-aufnr
               num_fabr = ls_reg-num_fabr ] =  CORRESPONDING #( ls_reg ).

  ENDLOOP.

ENDFORM.                    " LIBERAR

FORM liberar_of_abierta CHANGING p_of_abierta TYPE ty_alv.

  DATA: lti_return TYPE STANDARD TABLE OF bapi_order_return,
        ls_return  TYPE bapiret2.
  DATA lt_aufnr TYPE STANDARD TABLE OF ty_aufnr.
  DATA: ls_orders TYPE bapi_order_key.

  CALL METHOD zcl_secuenciador=>obtener_of_bobina
    EXPORTING
      i_aufnr_rollo   = p_of_abierta-aufnr
    IMPORTING
      ot_aufnr_bobina = DATA(lt_ordenes_bob).

  IF lines( lt_ordenes_bob ) = 0.
    MESSAGE e317(zpp) WITH p_of_abierta-aufnr. "No se han encontrado las órdenes de bobina asociadas a la orden de fab. &
  ENDIF.


* Volcamos las OF de bobina
  CLEAR lt_aufnr.
  LOOP AT lt_ordenes_bob INTO DATA(ls_ordenes_bob).
    CLEAR ls_orders.
    ls_orders-order_number = ls_ordenes_bob-aufnr.
    APPEND ls_orders TO lt_aufnr.
  ENDLOOP.

* Añadimos la OF de rollo.
  CLEAR ls_orders.
  ls_orders-order_number = p_of_abierta-aufnr.
  APPEND ls_orders TO lt_aufnr.


* Añadimos la OF de Rollo a la tabla con las OF de bobina.
**  APPEND INITIAL LINE TO lt_aufnr ASSIGNING FIELD-SYMBOL(<reg_bob_rollo>).
**  <reg_bob_rollo> = p_of_abierta-aufnr.

* Llamada a la liberacion de OF's
  CALL FUNCTION 'BAPI_PROCORD_RELEASE'
    EXPORTING
      release_control    = '1'
      work_process_group = 'COWORK_BAPI'
      work_process_max   = 99
    IMPORTING
      return             = ls_return
    TABLES
      orders             = lt_aufnr
      detail_return      = lti_return.

  IF line_exists( lti_return[ type = 'E' ] ).
    LOOP AT lti_return ASSIGNING FIELD-SYMBOL(<fs_return>).
      CLEAR gs_msj.
      PERFORM rellenar_msj USING <fs_return> CHANGING gs_msj.
      APPEND gs_msj TO gti_msj.
    ENDLOOP.
    PERFORM mostrar_log.
    REFRESH gti_msj.
  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = gc_true.

*    p_of_abierta-icon_estado = '@5Y@'. "Bandera verde-> orden liberada
    p_of_abierta-stat        = zcl_secuenciador=>gc_i0002_liberada.
    p_of_abierta-ind_bloq    = 'X'. " cuando pasa de abierta a liberada, se deja bloqueada.
  ENDIF.


ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  BLOQ_DESB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_bloq_desb USING p_datos TYPE tyt_alv.

  LOOP AT p_datos ASSIGNING FIELD-SYMBOL(<fs_datos>).

    IF <fs_datos>-stat          = zcl_secuenciador=>gc_i0001_abierta OR " Solo des/bloquearemos cuando esté liberada
      <fs_datos>-ind_fin        = 'X' OR
      <fs_datos>-ind_calidad_ok = 'X'.
      MESSAGE e313(zpp).   " No se puede bloquear una fabricación abierta o finalizada
    ENDIF.
    READ TABLE gti_datos ASSIGNING FIELD-SYMBOL(<fs_datos_mod>) WITH KEY werks    = <fs_datos>-werks
                                                      aufnr    = <fs_datos>-aufnr
                                                      num_fabr = <fs_datos>-num_fabr.
    IF sy-subrc = 0.

      IF <fs_datos_mod>-ind_bloq IS INITIAL.
        <fs_datos_mod>-ind_bloq = 'X'.
        <fs_datos>-icon_estado = '@06@'. " Candado
      ELSE.
        <fs_datos_mod>-ind_bloq = ' '.
        <fs_datos>-icon_estado = '@5Y@'. " Bandera verde- Liberada
      ENDIF.

    ENDIF.

  ENDLOOP.

  gt_ztpp0009_upd[] = CORRESPONDING #( gti_datos ).
  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = zspp0009_pant_selec-centro.

ENDFORM.                    " BLOQ_DESB
*&---------------------------------------------------------------------*
*&      Form  CERRAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_cerrar USING pt_datos TYPE tyt_alv.

  DATA: lti_orders TYPE                   tb_bapi_order_key,
        lti_return TYPE STANDARD TABLE OF bapi_order_return.

  DATA: ls_orders TYPE bapi_order_key,
        ls_return TYPE bapiret2.

  DATA: lv_answer(1) TYPE c.

  DATA: l_msg  TYPE string,
        l_rc   TYPE char2,
        l_cont TYPE i.

* Validar la selección de 1 sola fila
*  IF lines( pt_datos ) > 1.
*    MESSAGE e298(zpp).  " Seleccionar solo una linea para tratar fabricación
*  ENDIF.

  DATA(seleccionado) = VALUE #( pt_datos[ 1 ] ).


* Selección múltiple, de cada registro seleccionado, validaremos que todas las fabr. de esa OF tengan el estado OK para cerrar.
  CLEAR l_cont.
  LOOP AT pt_datos INTO DATA(ls_datos).
    l_cont = l_cont + 1.


    CALL METHOD zcl_secuenciador=>validar_rollos_1020
      EXPORTING
        i_werks = p_werks
        i_aufnr = ls_datos-aufnr
      IMPORTING
        o_error = DATA(l_error).
    IF l_error = 'X'.
      MESSAGE 'Atención! No se permite cierre técnico de OFs con rollos pend.de bobinar.' TYPE 'I'.
      DATA(lw_error) = 'X'.
      EXIT.
    ENDIF.

    PERFORM validar_cogi USING ls_datos-aufnr
                      CHANGING lw_error.
    IF lw_error = 'X'.
      DATA(l_of) = |{ ls_datos-aufnr ALPHA = OUT }|.
      CONDENSE l_of NO-GAPS.

*      MESSAGE |No se permite cerrar OF { l_of } con entr.merc. pendiente. Avisar a MP.|
      MESSAGE |No se permite cerrar OF { l_of } con consumos pendientes(COGI) Avisar a MP.|
          TYPE 'I' DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.


    LOOP AT gti_datos INTO DATA(ls_fabrics) WHERE aufnr = ls_datos-aufnr.

* Validamos que TODAS las fabricación de la OF esten: abierta, bloqueada, finalizada o calidad OK.
      IF ls_fabrics-ind_bloq       = ' ' AND  "Bloqueada
         ls_fabrics-ind_fin        = ' ' AND  "Finalizada
         ls_fabrics-ind_calidad_ok = ' ' AND  "Finalizada
         ls_fabrics-stat           = zcl_secuenciador=>gc_i0002_liberada.
        MESSAGE e318(zpp) WITH ls_fabrics-aufnr ls_fabrics-num_fabr.  "No se permite cierre técnico de OF &. La fabr. & está en estado liberada.
      ENDIF.

* Chequeamos si hay fabricaciones en estado diferente a Calidad OK.
      IF ls_fabrics-ind_calidad_ok = ' '. " OR
*         ls_fabrics-stat            = zcl_secuenciador=>gc_i0001_abierta.
        DATA(sw_no_cal_ok) = abap_true.
      ENDIF.

    ENDLOOP.

  ENDLOOP.

* Si ha habido un error "Rollos pendientes de bobinar", salimos, no procesamos.
  CHECK lw_error = ' '.

  CASE 'X'.
    WHEN sw_no_cal_ok.
*      l_msg = text-012.
      l_msg = |Atención! Se han seleccionado { l_cont } fabricaciones. Alguna de ella no está en estado Calidad. ¿Desea continuar?|.

    WHEN OTHERS.
*      l_msg = |Se va a cerrar la orden { seleccionado-aufnr ALPHA = OUT }. ¿Desea continuar?|.
      l_msg = |Se van a cerrar { l_cont } fabricaciones. ¿Desea continuar?|.
  ENDCASE.

  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
      titlebar              = 'Cierre técnico'
      text_question         = l_msg
      text_button_1         = 'Aceptar'
      text_button_2         = 'Cancelar'
      default_button        = '2'
      display_cancel_button = ' '
    IMPORTING
      answer                = lv_answer
    EXCEPTIONS
      text_not_found        = 1
      OTHERS                = 2.

  IF lv_answer EQ 1.
    DATA lt_aufnr TYPE STANDARD TABLE OF ty_aufnr.

    LOOP AT pt_datos INTO ls_datos.
      CLEAR lt_aufnr.
      CALL METHOD zcl_secuenciador=>obtener_of_bobina
        EXPORTING
          i_aufnr_rollo   = ls_datos-aufnr
        IMPORTING
          ot_aufnr_bobina = DATA(lt_ordenes_bob).

* Volcamos las OF de bobina
      LOOP AT lt_ordenes_bob INTO DATA(ls_ordenes_bob).

* Para cada OF de bobina, validar que no hayan entr.merc.pendientes (COGI)
        PERFORM validar_cogi USING ls_ordenes_bob-aufnr
                        CHANGING lw_error.
        IF lw_error = 'X'.
          l_of = |{ ls_ordenes_bob-aufnr ALPHA = OUT }|.
          CONDENSE l_of NO-GAPS.
          MESSAGE |No se permite cerrar OF { l_of } con consumos pendientes(COGI) Avisar a MP.|
              TYPE 'I' DISPLAY LIKE 'E'.
          EXIT.
        ENDIF.

        CLEAR ls_orders.
        ls_orders-order_number = ls_ordenes_bob-aufnr.
        APPEND ls_orders TO lt_aufnr.
      ENDLOOP.

      CHECK lw_error = ' '.

* Añadimos la OF de rollo.
      CLEAR ls_orders.
      ls_orders-order_number = ls_datos-aufnr.
      APPEND ls_orders TO lt_aufnr.


      CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
        EXPORTING
          scope_compl_tech   = '1'
          work_process_group = 'COWORK_BAPI'
          work_process_max   = 99
        IMPORTING
          return             = ls_return
        TABLES
          orders             = lt_aufnr
          detail_return      = lti_return.
      IF line_exists( lti_return[ type = 'E' ] ).

        LOOP AT lti_return ASSIGNING FIELD-SYMBOL(<fs_return>).
          PERFORM rellenar_msj USING <fs_return> CHANGING gs_msj.
          APPEND gs_msj TO gti_msj.
        ENDLOOP.
        PERFORM mostrar_log.

      ELSE.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = gc_true.
      ENDIF.
    ENDLOOP.

    PERFORM f_actualizar .

  ELSE.
    g_dblclick = 'X'.
  ENDIF.


ENDFORM.                    " CERRAR

FORM validar_cogi USING p_aufnr TYPE aufnr
                  CHANGING p_rc .

  " validar cogi antes de cambiar estado a CTEC
  CLEAR p_rc.

*  SELECT SUM( erfmg )
  SELECT SINGLE aufnr
    INTO @DATA(l_of)
    FROM affw AS a
    INNER JOIN mara AS m ON a~matnr = m~matnr
    WHERE aufnr = @p_aufnr AND " se desea no tener en cuenta mandriles
          NOT ( mtart = 'ZAUX' AND  matkl = '42104' ).
  IF sy-subrc = 0.
    p_rc = 'X'.
  ENDIF.

ENDFORM.                    " validar cogi antes de cambiar estado a CTEC
*&---------------------------------------------------------------------*
*&      Form  ORDENAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_ordenar USING p_datos TYPE tyt_alv
                     p_zspp0009 TYPE zspp0009 .

  DATA: lti_datos         TYPE STANDARD TABLE OF ty_alv,    "ztpp0009,
        lti_ztpp0009      TYPE STANDARD TABLE OF ty_alv,
        lti_tipos_calidad TYPE TABLE OF ty_tipos_calidad,
        lti_tipos_gramaje TYPE TABLE OF ty_tipos_gramaje,
        lti_tipos_ancho   TYPE TABLE OF ty_tipos_ancho,
        lti_datos_aux     TYPE TABLE OF ty_alv,
        lti_datos_aux2    TYPE TABLE OF ty_alv,
        lti_datos_aux3    TYPE TABLE OF ty_alv,
        lti_cal_gram      TYPE TABLE OF ty_cal_gram.

  DATA: ls_tipos_calidad TYPE ty_tipos_calidad,
        ls_tipos_gramaje TYPE ty_tipos_gramaje,
        ls_tipos_ancho   TYPE ty_tipos_ancho,
        ls_cal_gram      TYPE ty_cal_gram.

  DATA: lv_cont TYPE i.

  DATA: lt_seq TYPE STANDARD TABLE OF zindex.

  CLEAR lt_seq[].
* Guardaremos los items seleccionados para posteriormente mover datos ordenados.
  LOOP AT p_datos INTO DATA(ls_datos_seq).
    APPEND INITIAL LINE TO lt_seq ASSIGNING FIELD-SYMBOL(<fs_seq>).
    <fs_seq> = ls_datos_seq-zindex.
  ENDLOOP.

*************************************************************
********Si el usuario elige 1 criterio de ordenación*********
*************************************************************

*****Por calidad****************************************************************
  IF p_zspp0009-lista_calidad IS NOT INITIAL AND p_zspp0009-lista_gramaje IS INITIAL
    AND p_zspp0009-lista_ancho IS INITIAL.
    LOOP AT p_datos ASSIGNING FIELD-SYMBOL(<fs_datos>).
      CONCATENATE <fs_datos>-matkl <fs_datos>-zzgramaje <fs_datos>-zzancho
      INTO <fs_datos>-concate_orden.
    ENDLOOP.

    CASE p_zspp0009-lista_calidad.
      WHEN 'ASCEN'.
        SORT p_datos BY concate_orden ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY concate_orden DESCENDING.
    ENDCASE.

  ENDIF.
*****Por gramaje****************************************************************
  IF p_zspp0009-lista_calidad IS INITIAL AND p_zspp0009-lista_gramaje IS NOT INITIAL
    AND p_zspp0009-lista_ancho IS INITIAL.
    LOOP AT p_datos ASSIGNING <fs_datos>.
      CONCATENATE <fs_datos>-zzgramaje <fs_datos>-matkl <fs_datos>-zzancho
      INTO <fs_datos>-concate_orden.
    ENDLOOP.

    CASE p_zspp0009-lista_gramaje.
      WHEN 'ASCEN'.
        SORT p_datos BY concate_orden ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY concate_orden DESCENDING.
    ENDCASE.
  ENDIF.
*****Por ancho****************************************************************
  IF p_zspp0009-lista_calidad IS INITIAL AND p_zspp0009-lista_gramaje IS INITIAL
    AND p_zspp0009-lista_ancho IS NOT INITIAL.
    LOOP AT p_datos ASSIGNING <fs_datos>.
      CONCATENATE <fs_datos>-zzancho <fs_datos>-matkl <fs_datos>-zzgramaje
      INTO <fs_datos>-concate_orden.
    ENDLOOP.

    CASE p_zspp0009-lista_ancho.
      WHEN 'ASCEN'.
        SORT p_datos BY concate_orden ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY concate_orden DESCENDING.
    ENDCASE.
  ENDIF.

*************************************************************
********Si el usuario elige 2 criterios de ordenación********
*************************************************************

*Primero ordenamos por el primer criterio y luego partimos la tabla
*interna por cada uno de los diferentes tipos del primer criterio
*****Por calidad y gramaje****************************************************************
  IF p_zspp0009-lista_calidad IS NOT INITIAL AND p_zspp0009-lista_gramaje IS NOT INITIAL
  AND p_zspp0009-lista_ancho IS INITIAL.


*Primero se ordena por calidad
    CASE p_zspp0009-lista_calidad.
      WHEN 'ASCEN'.
        SORT p_datos BY matkl ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY matkl DESCENDING.
    ENDCASE.

*Obtenemos los diferentes calidades que hay
    CLEAR: lti_tipos_calidad[], lti_datos_aux[].
    LOOP AT p_datos ASSIGNING <fs_datos>.
      READ TABLE lti_tipos_calidad INTO ls_tipos_calidad WITH KEY matkl = <fs_datos>-matkl.
      IF sy-subrc NE 0.
        APPEND <fs_datos>-matkl TO lti_tipos_calidad.
      ENDIF.
    ENDLOOP.

    CLEAR lti_datos_aux2[].
    LOOP AT lti_tipos_calidad INTO ls_tipos_calidad.
      LOOP AT p_datos ASSIGNING <fs_datos> WHERE matkl EQ ls_tipos_calidad-matkl.
        APPEND <fs_datos> TO lti_datos_aux.
      ENDLOOP.

*Ordenamos el resultado por gramaje
      CASE p_zspp0009-lista_gramaje.
        WHEN 'ASCEN'.
          SORT lti_datos_aux BY zzgramaje ASCENDING.
        WHEN 'DESCEN'.
          SORT lti_datos_aux BY zzgramaje DESCENDING.
      ENDCASE.

      INSERT LINES OF lti_datos_aux INTO TABLE lti_datos_aux2.
      CLEAR: lti_datos_aux[], ls_tipos_calidad.
    ENDLOOP.
    CLEAR p_datos[].

    INSERT LINES OF lti_datos_aux2 INTO TABLE p_datos.
    CLEAR lti_datos_aux2[].
  ENDIF. "Por calidad y gramaje

*****Por calidad y ancho****************************************************************
  IF p_zspp0009-lista_calidad IS NOT INITIAL AND p_zspp0009-lista_gramaje IS INITIAL
  AND p_zspp0009-lista_ancho IS NOT INITIAL.
*Primero se ordena por calidad
    CASE p_zspp0009-lista_calidad.
      WHEN 'ASCEN'.
        SORT p_datos BY matkl ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY matkl DESCENDING.
    ENDCASE.

*Obtenemos los diferentes calidades que hay
    CLEAR: lti_tipos_calidad[], lti_datos_aux[].
    LOOP AT p_datos ASSIGNING <fs_datos>.
      READ TABLE lti_tipos_calidad INTO ls_tipos_calidad WITH KEY matkl = <fs_datos>-matkl.
      IF sy-subrc NE 0.
        APPEND <fs_datos>-matkl TO lti_tipos_calidad.
      ENDIF.
    ENDLOOP.

    CLEAR lti_datos_aux2[].
    LOOP AT lti_tipos_calidad INTO ls_tipos_calidad.
      LOOP AT p_datos ASSIGNING <fs_datos> WHERE matkl EQ ls_tipos_calidad-matkl.
        APPEND <fs_datos> TO lti_datos_aux.
      ENDLOOP.

*Ordenamos el resultado por ancho
      CASE p_zspp0009-lista_ancho.
        WHEN 'ASCEN'.
          SORT lti_datos_aux BY zzancho ASCENDING.
        WHEN 'DESCEN'.
          SORT lti_datos_aux BY zzancho DESCENDING.
      ENDCASE.

      INSERT LINES OF lti_datos_aux INTO TABLE lti_datos_aux2.
      CLEAR: lti_datos_aux[],ls_tipos_calidad.
    ENDLOOP.
    CLEAR p_datos[].

    INSERT LINES OF lti_datos_aux2 INTO TABLE p_datos.
    CLEAR lti_datos_aux2[].
  ENDIF. "Por calidad y ancho

*****Por gramaje y ancho****************************************************************
  IF p_zspp0009-lista_calidad IS INITIAL AND p_zspp0009-lista_gramaje IS NOT INITIAL
  AND p_zspp0009-lista_ancho IS NOT INITIAL.
*Primero se ordena por calidad
    CASE p_zspp0009-lista_gramaje.
      WHEN 'ASCEN'.
        SORT p_datos BY zzgramaje ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY zzgramaje DESCENDING.
    ENDCASE.

*Obtenemos los diferentes calidades que hay
    CLEAR: lti_tipos_gramaje[],lti_datos_aux[].
    LOOP AT p_datos ASSIGNING <fs_datos>.
      READ TABLE lti_tipos_gramaje INTO ls_tipos_gramaje WITH KEY zzgramaje = <fs_datos>-zzgramaje.
      IF sy-subrc NE 0.
        APPEND <fs_datos>-zzgramaje TO lti_tipos_gramaje.
      ENDIF.
    ENDLOOP.

    CLEAR lti_datos_aux2[].
    LOOP AT lti_tipos_gramaje INTO ls_tipos_gramaje.
      LOOP AT p_datos ASSIGNING <fs_datos> WHERE zzgramaje EQ ls_tipos_gramaje-zzgramaje.
        APPEND <fs_datos> TO lti_datos_aux.
      ENDLOOP.

*Ordenamos el resultado por ancho
      CASE p_zspp0009-lista_ancho.
        WHEN 'ASCEN'.
          SORT lti_datos_aux BY zzancho ASCENDING.
        WHEN 'DESCEN'.
          SORT lti_datos_aux BY zzancho DESCENDING.
      ENDCASE.

      INSERT LINES OF lti_datos_aux INTO TABLE lti_datos_aux2.
      CLEAR: lti_datos_aux[], ls_tipos_gramaje.
    ENDLOOP.
    CLEAR p_datos[].

    INSERT LINES OF lti_datos_aux2 INTO TABLE p_datos.
    CLEAR lti_datos_aux2[].
  ENDIF. "Por gramaje y ancho

*************************************************************
********Si el usuario elige 3 criterios de ordenación********
*************************************************************

  IF p_zspp0009-lista_calidad IS NOT INITIAL AND p_zspp0009-lista_gramaje IS NOT INITIAL
  AND p_zspp0009-lista_ancho IS NOT INITIAL.
*Primero se ordena por calidad
    CASE p_zspp0009-lista_calidad.
      WHEN 'ASCEN'.
        SORT p_datos BY matkl ASCENDING.
      WHEN 'DESCEN'.
        SORT p_datos BY matkl DESCENDING.
    ENDCASE.

*Obtenemos los diferentes calidades que hay
    CLEAR: lti_tipos_calidad[], lti_datos_aux[].
    LOOP AT p_datos ASSIGNING <fs_datos>.
      READ TABLE lti_tipos_calidad INTO ls_tipos_calidad WITH KEY matkl = <fs_datos>-matkl.
      IF sy-subrc NE 0.
        APPEND <fs_datos>-matkl TO lti_tipos_calidad.
      ENDIF.
    ENDLOOP.

    CLEAR lti_datos_aux2[].
    LOOP AT lti_tipos_calidad INTO ls_tipos_calidad.
      LOOP AT p_datos ASSIGNING <fs_datos> WHERE matkl EQ ls_tipos_calidad-matkl.
        APPEND <fs_datos> TO lti_datos_aux.
      ENDLOOP.

*Ordenamos el resultado por gramaje
      CASE p_zspp0009-lista_gramaje.
        WHEN 'ASCEN'.
          SORT lti_datos_aux BY zzgramaje ASCENDING.
        WHEN 'DESCEN'.
          SORT lti_datos_aux BY zzgramaje DESCENDING.
      ENDCASE.

      INSERT LINES OF lti_datos_aux INTO TABLE lti_datos_aux2.
      CLEAR: lti_datos_aux[], ls_tipos_calidad.
    ENDLOOP.

*Finalmente, ordenamos por ancho
    LOOP AT lti_datos_aux2 ASSIGNING <fs_datos>.

      ls_cal_gram-matkl = <fs_datos>-matkl.
      ls_cal_gram-zzgramaje = <fs_datos>-zzgramaje.
*Metemos en la tabla lti_cal_gram las combinaciones de calidad+gramaje
      READ TABLE lti_cal_gram INTO ls_cal_gram WITH KEY matkl = <fs_datos>-matkl
                                                        zzgramaje = <fs_datos>-zzgramaje.
      IF sy-subrc NE 0.
        APPEND ls_cal_gram TO lti_cal_gram.
        CLEAR ls_cal_gram.
      ENDIF.
    ENDLOOP.

    CLEAR lti_datos_aux3[].
    LOOP AT lti_cal_gram INTO ls_cal_gram.
      LOOP AT lti_datos_aux2 ASSIGNING <fs_datos> WHERE matkl EQ ls_cal_gram-matkl
                                                  AND   zzgramaje EQ ls_cal_gram-zzgramaje.
        APPEND <fs_datos> TO lti_datos_aux.
      ENDLOOP.

      CASE p_zspp0009-lista_ancho.
        WHEN 'ASCEN'.
          SORT lti_datos_aux BY zzancho ASCENDING.
        WHEN 'DESCEN'.
          SORT lti_datos_aux BY zzancho DESCENDING.
      ENDCASE.

      INSERT LINES OF lti_datos_aux INTO TABLE lti_datos_aux3.
      CLEAR lti_datos_aux[].
      CLEAR ls_cal_gram.
    ENDLOOP.

    CLEAR p_datos[].
    INSERT LINES OF lti_datos_aux3 INTO TABLE p_datos.
    CLEAR lti_datos_aux3[].
  ENDIF. "Por calidad y gramaje

*******FIN ORDENACIÓN POR CRITERIOS

*Ordenamos la tabla que muestra los datos del ALV
  lti_datos[] = gti_datos[].

  REFRESH gti_datos.

  PERFORM ordenar USING    lti_datos p_datos
                  CHANGING gti_datos.

*  gt_ztpp0009_upd = CORRESPONDING #( gti_datos ).
*  CALL METHOD zcl_secuenciador=>set_icons
*    EXPORTING
*      it_ztpp0009 = gt_ztpp0009_upd
*    IMPORTING
*      ot_ztpp0009 = data(it_with_icons)
*      .

*Debemos hacer el mismo proceso para la tabla ZTPP0009,ya que, deben de grabarse
*en la tabla Z todos los registros en el mismo orden que en el ALV
  CLEAR: lti_ztpp0009.
  REFRESH lti_ztpp0009.

  SELECT * FROM ztpp0009
    INTO TABLE @DATA(l_ztpp0009)
    WHERE werks = @zspp0009_pant_selec-centro.

  CLEAR lti_ztpp0009[].
  lti_ztpp0009[] = CORRESPONDING #( l_ztpp0009[] ).

  PERFORM ordenar USING    lti_ztpp0009 p_datos
                  CHANGING gti_ztpp0009.


*Una vez que ya tenemos todos los registros ordenados según lo ha hecho el usuario,
*borramos la tabla Z e insertamos los registros con la ordenación nueva
  IF gti_ztpp0009[] IS NOT INITIAL.


    CLEAR gt_ztpp0009_upd[].
    gt_ztpp0009_upd[] = CORRESPONDING #( gti_ztpp0009 ).

    CALL METHOD zcl_secuenciador=>set_icons
      EXPORTING
        it_ztpp0009 = gt_ztpp0009_upd
      IMPORTING
        ot_ztpp0009 = gt_ztpp0009_upd.

    gti_ztpp0009[] = CORRESPONDING #( gt_ztpp0009_upd ).

    CLEAR gt_ztpp0009_upd.
    gt_ztpp0009_upd = CORRESPONDING #( gti_ztpp0009 ).
    CALL METHOD zcl_secuenciador=>guardar_ztpp0009
      EXPORTING
        it_ztpp0009 = gt_ztpp0009_upd
        i_werks     = zspp0009_pant_selec-centro.

    PERFORM cambios_colores. " TABLES gti_ztpp0009.

  ENDIF.

*Refrescamos los campos de ordenación para no confundirse con la ordenación
*hecha previamente
  CLEAR: zspp0009-lista_calidad,zspp0009-lista_gramaje,zspp0009-lista_ancho.

ENDFORM.                    " F_ORDENAR
*&---------------------------------------------------------------------*
*&      Form  F_MOVER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_actualizar.

  DATA: lt_ztpp0009 TYPE STANDARD TABLE OF ztpp0009.

  lt_ztpp0009[] = CORRESPONDING #( gti_datos ).

  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = lt_ztpp0009
      i_werks     = zspp0009_pant_selec-centro.

  PERFORM obtener_datos_3.

ENDFORM.                    " F_MOVER
*&---------------------------------------------------------------------*
*&      Form  PROGRAMAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM programar. " TABLES p_datos STRUCTURE ztpp0009.
*               USING  p_zspp0009 TYPE zspp0009.

  DATA: lti_fecha    TYPE TABLE OF sval.
*        lti_ztpp0009 TYPE TABLE OF ztpp0009.

  DATA: ls_fecha    TYPE sval.

  DATA: w_uzeit TYPE sy-uzeit.
  DATA: l_subrc TYPE subrc VALUE 0.

*  CLEAR lti_ztpp0009[].
*  SELECT * FROM ztpp0009
*  INTO TABLE lti_ztpp0009 where werks = .

  ls_fecha-tabname = 'ZSPP0009'.
  ls_fecha-fieldname = 'FECHA_PROG'.
  ls_fecha-value = sy-datum.
  APPEND ls_fecha TO lti_fecha.

  ls_fecha-tabname = 'ZSPP0009'.
  ls_fecha-fieldname = 'HORA_PROG'.
  w_uzeit = sy-uzeit + 3600.
  CONCATENATE w_uzeit(2) '0000' INTO ls_fecha-value.
  APPEND ls_fecha TO lti_fecha.

  CALL FUNCTION 'POPUP_GET_VALUES_DB_CHECKED'
    EXPORTING
      check_existence = ' '
      popup_title     = 'Fecha y hora programada'
      start_column    = '5'
      start_row       = '5'
    TABLES
      fields          = lti_fecha
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.

  CHECK sy-ucomm <> 'CANC'.

  TRY.
      CHECK lti_fecha[ fieldname = 'FECHA_PROG' ]-value IS NOT INITIAL.
      CHECK lti_fecha[ fieldname = 'HORA_PROG'  ]-value IS NOT INITIAL.

    CATCH cx_root .
      MESSAGE s303(zpp). " Es obligatorio informar fecha y hora de programación
  ENDTRY.

*            data(l_fecha_prog_ant) = it_values_fecha_hora[ fieldname = 'FECHA_PROG' ]-value.
*            data(l_hora_prog_ant)  = it_values_fecha_hora[ fieldname = 'HORA_PROG' ]-value.



  gt_ztpp0009_upd[] = CORRESPONDING #( gti_datos ).
  CALL METHOD zcl_secuenciador=>programar_secuenciador
    EXPORTING
      it_ztpp0009          = gt_ztpp0009_upd
      it_values_fecha_hora = lti_fecha
      i_werks              = zspp0009_pant_selec-centro
    IMPORTING
      ot_ztpp0009          = gt_ztpp0009_upd
      ot_return            = l_subrc.

  gti_datos[] = CORRESPONDING #( gt_ztpp0009_upd ).

  CHECK l_subrc = 0.

  CASE l_subrc.
    WHEN 0.       MESSAGE s302(zpp).
*    WHEN OTHERS.  MESSAGE s303(zpp).
  ENDCASE.


ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  OBSERVACIONES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM observaciones "TABLES p_datos STRUCTURE ztpp0009
*                   USING  p_zspp0009 TYPE zspp0009.
                   USING  p_datos TYPE tyt_alv.

  DATA: lti_textlines TYPE TABLE OF ty_textline.
  DATA: ls_textlines TYPE ty_textline.
  FIELD-SYMBOLS: <fs_ztpp0009> TYPE ztpp0009.
  DATA: lv_observaciones TYPE zobservaciones.

  IF lines( p_datos ) <> 1.
    MESSAGE e298(zpp).
  ENDIF.

*  ASSIGN p_datos[ 1 ] TO FIELD-SYMBOL(<sele>).

  LOOP AT p_datos ASSIGNING FIELD-SYMBOL(<fs_datos>).
    CLEAR lti_textlines.
    IF <fs_datos>-observaciones IS NOT INITIAL.
      MOVE  <fs_datos>-observaciones TO ls_textlines.
      APPEND ls_textlines TO lti_textlines.
      CLEAR ls_textlines.
    ENDIF.

    CALL FUNCTION 'TERM_CONTROL_EDIT'
      EXPORTING
        titel          = 'Observaciones'
      TABLES
        textlines      = lti_textlines
      EXCEPTIONS
        user_cancelled = 1
        OTHERS         = 2.

    IF lti_textlines[] IS NOT INITIAL.
      CLEAR: lv_observaciones.
      LOOP AT lti_textlines INTO ls_textlines.
        CONCATENATE lv_observaciones ls_textlines INTO lv_observaciones SEPARATED BY space.
        CLEAR ls_textlines.
      ENDLOOP.
      CONDENSE lv_observaciones.

      <fs_datos>-observaciones = lv_observaciones.
    ELSE.
      CLEAR: <fs_datos>-observaciones,<fs_datos>-zicon_observa.
    ENDIF.

*    READ TABLE gti_datos INTO DATA(ls_datos) WITH KEY aufnr   = <fs_datos>-aufnr
*                                                num_fabr = <fs_datos>-num_fabr.
*    MODIFY gti_datos FROM <fs_datos> INDEX ls_datos-zindex.

* 67866 - 08/07/2021 - CMS Corregir duplidos al crear registros con el MODIFY anterior.
    ASSIGN gti_datos[ aufnr    = <fs_datos>-aufnr
                      num_fabr = <fs_datos>-num_fabr ]-observaciones TO FIELD-SYMBOL(<fs_observ_reg>).
    IF sy-subrc = 0.
      <fs_observ_reg> = <fs_datos>-observaciones.
    ENDIF.

    gt_ztpp0009_upd = CORRESPONDING #( gti_datos ).
    CALL METHOD zcl_secuenciador=>guardar_ztpp0009
      EXPORTING
        it_ztpp0009 = gt_ztpp0009_upd
        i_werks     = zspp0009_pant_selec-centro.

  ENDLOOP.

ENDFORM.

FORM paro_programado USING p_datos TYPE tyt_alv.

* Validar la selección de 1 sola fila
  IF lines( p_datos ) > 1.
    MESSAGE e298(zpp).
  ENDIF.

  ASSIGN p_datos[ 1 ]   TO FIELD-SYMBOL(<seleccionado>).

  IF p_datos[ 1 ]-ind_fin  = 'X' OR
     p_datos[ 1 ]-stat     = zcl_secuenciador=>gc_i0001_abierta ."Abierta
    MESSAGE e309(zpp). " Para esta función, el estado de la fabricación no es correcto.
  ENDIF.

  ASSIGN gti_datos[ aufnr    = <seleccionado>-aufnr
                    num_fabr = <seleccionado>-num_fabr ]
        TO FIELD-SYMBOL(<fs_reg_sel>).

  PERFORM mostrar_popup_paro  CHANGING <fs_reg_sel>-horas_paro.

  CASE <fs_reg_sel>-horas_paro.
    WHEN 0.
      CLEAR <fs_reg_sel>-icon_paro.
    WHEN OTHERS.
      <fs_reg_sel>-icon_paro = '@3U@'.
  ENDCASE.

* Grabacion BBDD
  gt_ztpp0009_upd[] = CORRESPONDING #( gti_datos ).
  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = <fs_reg_sel>-werks.


ENDFORM.

FORM calidad_ok USING p_datos TYPE tyt_alv.

* Validación.
  LOOP AT p_datos INTO DATA(ls_selecion).

    ASSIGN gti_datos[ aufnr    = ls_selecion-aufnr
                      num_fabr = ls_selecion-num_fabr ] TO FIELD-SYMBOL(<fs_reg_sel>).

    IF <fs_reg_sel>-ind_fin         = ' ' AND
       <fs_reg_sel>-ind_calidad_ok  = ' '.
      MESSAGE e309(zpp). " Para esta función, el estado de la fabricación no es correcto.
    ENDIF.

  ENDLOOP.

* Procesando registros.
  LOOP AT p_datos INTO ls_selecion.

    ASSIGN gti_datos[ aufnr    = ls_selecion-aufnr
                      num_fabr = ls_selecion-num_fabr ] TO <fs_reg_sel>.

    IF <fs_reg_sel>-ind_fin         = ' ' AND
       <fs_reg_sel>-ind_calidad_ok  = 'X'.
      <fs_reg_sel>-ind_fin         = 'X'.
      <fs_reg_sel>-ind_calidad_ok  = ' '.

    ELSEIF <fs_reg_sel>-ind_fin         = 'X' AND
       <fs_reg_sel>-ind_calidad_ok  = ' '.
      <fs_reg_sel>-ind_fin         = ' '.
      <fs_reg_sel>-ind_calidad_ok  = 'X'.
    ENDIF.


  ENDLOOP.

* Grabacion BBDD
  gt_ztpp0009_upd[] = CORRESPONDING #( gti_datos ).
  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = <fs_reg_sel>-werks.


ENDFORM.


FORM navegar_zpp0004 USING p_datos TYPE tyt_alv.

  IF lines( p_datos ) > 1.
    MESSAGE e298(zpp).
  ENDIF.

  DATA:    lr_datum        TYPE trgr_date.
  DATA:    lr_aufnr        TYPE RANGE OF aufnr.

  CALL METHOD zcl_secuenciador=>obtener_of_bobina
    EXPORTING
      i_aufnr_rollo   = p_datos[ 1 ]-aufnr
    IMPORTING
      ot_aufnr_bobina = DATA(ls_of_bobinas).

  lr_datum  = VALUE #( ( sign = 'I' option = 'BT'  low = '20190101' high = '99991231' ) ).

  lr_aufnr = VALUE #( FOR <ls_itab> IN ls_of_bobinas ( sign = 'I' option = 'EQ' low = <ls_itab>-aufnr ) ).

  SUBMIT zrpp0014_bis
    WITH pwerks EQ zspp0009_pant_selec-centro
    WITH sbudat EQ lr_datum
    WITH saufnr IN lr_aufnr
    WITH pvari  EQ '/NETA_SECDOR'
    AND RETURN.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mostrar_log.

  CALL FUNCTION 'C14Z_MESSAGES_SHOW_AS_POPUP'
    TABLES
      i_message_tab = gti_msj.

ENDFORM.                    " MOSTRAR_LOG
*&---------------------------------------------------------------------*
*&      Form  RELLENAR_MSJ
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM rellenar_msj  USING    p_return TYPE bapi_order_return
                   CHANGING p_msj TYPE esp1_message_wa_type.

  p_msj-msgid = p_return-id.
  p_msj-msgty = p_return-type.
  p_msj-msgno = p_return-number.
  p_msj-msgv1 = p_return-message_v1.
  p_msj-msgv2 = p_return-message_v2.
  p_msj-msgv3 = p_return-message_v3.
  p_msj-msgv4 = p_return-message_v4.

ENDFORM.                    " RELLENAR_MSJ
*&---------------------------------------------------------------------*
*&      Form  RELLENAR_MSJ2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM rellenar_msj2 USING p_return TYPE bapiret2
                  CHANGING p_msj TYPE esp1_message_wa_type.

  p_msj-msgid = p_return-id.
  p_msj-msgty = p_return-type.
  p_msj-msgno = p_return-number.
  p_msj-msgv1 = p_return-message_v1.
  p_msj-msgv2 = p_return-message_v2.
  p_msj-msgv3 = p_return-message_v3.
  p_msj-msgv4 = p_return-message_v4.

ENDFORM.                    " RELLENAR_MSJ2
*&---------------------------------------------------------------------*
*&      Form  MENSAJE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mensaje USING p_aufnr p_type p_id p_num.
  DATA: lv_aufnr TYPE aufnr.

  lv_aufnr = p_aufnr.
  PERFORM quitar_ceros USING lv_aufnr.

  CLEAR gs_msj.
  gs_msj-msgty = p_type.
  gs_msj-msgid = p_id.
  gs_msj-msgno = p_num.
  gs_msj-msgv1 = lv_aufnr.
  gs_msj-msgv2 = ''.
  gs_msj-msgv3 = ''.
  gs_msj-msgv4 = ''.

  IF gs_msj IS NOT INITIAL.
    APPEND gs_msj TO gti_msj.
  ENDIF.

ENDFORM.                    " MENSAJE
*&---------------------------------------------------------------------*
*&      Form  MENSAJE_SIN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mensaje_sin USING p_type p_id p_num.

  CLEAR gs_msj.
  gs_msj-msgty = p_type.
  gs_msj-msgid = p_id.
  gs_msj-msgno = p_num.
  gs_msj-msgv1 = ''.
  gs_msj-msgv2 = ''.
  gs_msj-msgv3 = ''.
  gs_msj-msgv4 = ''.

  IF gs_msj IS NOT INITIAL.
    APPEND gs_msj TO gti_msj.
  ENDIF.

ENDFORM.                    " MENSAJE_SIN
*&---------------------------------------------------------------------*
*&      Form  ORDENAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM ordenar USING    p_tabla TYPE tyt_alv "datos totales de la tabla
                      p_datos TYPE tyt_alv "datos seleccionados y ordenados
             CHANGING p_result TYPE tyt_alv. "será gti_datos o gti_ztpp0009
  DATA: lv_cont TYPE i.

  REFRESH p_result.
  CLEAR: p_result,gv_ordenar,gv_add.

  LOOP AT p_tabla ASSIGNING FIELD-SYMBOL(<fs_datos>).

    lv_cont = lv_cont + 1.
    <fs_datos>-zindex = lv_cont.

*Si en la tabla z existen los registros seleccionados, en lugar de borrar,
*añadimos a una auxiliar todos los registros menos los seleccionados
    READ TABLE p_datos INTO DATA(ls_datos_aux) WITH KEY secuencia = <fs_datos>-secuencia.

    IF sy-subrc NE 0.
      APPEND <fs_datos> TO p_result.
    ELSE.
*El índice podría no ser el mismo que el de la tabla gti_datos, ya que la
*tabla z puede tener más registros grabados. La tabla gti_datos sólo contiene
*aquellos restringidos por la pantalla de selección
*En cuanto encuentra el primer registro del bloque, inserta el bloque entero

      IF gv_add NE gc_true. "No se ha añadido el bloque aún
        CLEAR: ls_datos_aux.
        LOOP AT p_datos INTO ls_datos_aux.
          MOVE-CORRESPONDING ls_datos_aux TO <fs_datos>.
          <fs_datos>-zindex = lv_cont.
          APPEND <fs_datos> TO p_result.
          lv_cont = lv_cont + 1.
          CLEAR: ls_datos_aux.
        ENDLOOP.

        gv_add = gc_true.
        lv_cont = lv_cont - 1.
      ELSE.
        lv_cont = lv_cont - 1.
      ENDIF.
    ENDIF.
    CLEAR: ls_datos_aux.

  ENDLOOP.

  gv_ordenar = gc_true.

  UNASSIGN <fs_datos>.
ENDFORM.                    " ORDENAR
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM refrescar .
  CLEAR: gv_orden,
         gv_repid,
         gv_add,
         gv_ordenar.
ENDFORM.                    " REFRESCAR
*&---------------------------------------------------------------------*
*&      Form  ORDENAR_INDEX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM ordenar_index.

  DATA: lv_cont TYPE i.

*  LOOP AT p_ztpp0009 ASSIGNING <fs_datos>.
  LOOP AT gti_datos ASSIGNING FIELD-SYMBOL(<fs_datos>).
    IF <fs_datos>-zindex EQ 0.
      READ TABLE gti_datos INTO DATA(ls_datos) WITH KEY aufnr = <fs_datos>-aufnr.
      <fs_datos>-zindex = ls_datos-zindex.
    ELSE.
      lv_cont = lv_cont + 1.
      <fs_datos>-zindex = lv_cont.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " ORDENAR_INDEX
*&---------------------------------------------------------------------*
*&      Form  F_UCOMM_REFRESCAR_ALVS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_ucomm_refrescar_alvs .
* Datos para el informe
  PERFORM obtener_datos_3.

*Mostramos el ALV
  PERFORM mostrar_datos.
ENDFORM.                    " F_UCOMM_REFRESCAR_ALVS

FORM f_desdoblar  USING p_datos TYPE tyt_alv.

  DATA: l_kg_desdoblar TYPE zgamng,
        l_num_fabr_max TYPE znum_fabr.
  DATA l_kg_fabr_ori TYPE zgamng.

* Validar la selección de 1 sola fila
  IF lines( p_datos ) > 1.
    MESSAGE e298(zpp).
*        MESSAGE s298(zpp) DISPLAY LIKE 'I' .
  ENDIF.

  ASSIGN p_datos[ 1 ]   TO FIELD-SYMBOL(<seleccionado>).
*  data(wa) = value #( p_datos[ 1 ] ).

* Validamos que la fabricación esté bloqueada.
  IF <seleccionado>-ind_bloq <> 'X'.
    MESSAGE e314(zpp).  " Para desdoblar una fabricación, debe estar bloqueada
  ENDIF.

  IF <seleccionado>-num_fabr > 99.
    MESSAGE e312(zpp).  "No se puede desdoblar una repetición
  ENDIF.


*  ASSIGN gti_datos[ aufnr = p_datos[ 1 ]-aufnr num_fabr = p_datos[ 1 ]-num_fabr ]
*        TO FIELD-SYMBOL(<desdoblado>).

  ASSIGN gti_datos[ aufnr = <seleccionado>-aufnr num_fabr = <seleccionado>-num_fabr ]
        TO FIELD-SYMBOL(<desdoblado>).

  CLEAR l_kg_fabr_ori.
* Si se trata de un registro desdoblado, tomamos kg.fabricacion, sino kg.teoricos de la OF.
  IF <desdoblado>-num_fabr = 0.
    l_kg_fabr_ori = <desdoblado>-gamng.
  ELSE.
    l_kg_fabr_ori = <desdoblado>-kg_fabricacion.
  ENDIF.

  IF l_kg_fabr_ori < 20000. "Si hi ha menys de 20.000kg no es pot desdoblar
    MESSAGE e304(zpp).
*    MESSAGE s304(zpp) DISPLAY LIKE 'I' .
  ENDIF.

  PERFORM mostrar_popup_kg_desdoblar  USING l_kg_fabr_ori
                                            '1'
                                   CHANGING l_kg_desdoblar.

* Validar kg informados.
  IF  l_kg_desdoblar IS INITIAL.
    MESSAGE e299(zpp).
  ENDIF.

* Validar kg informados.
  IF  l_kg_desdoblar => l_kg_fabr_ori.
    MESSAGE e300(zpp).
*    MESSAGE s300(zpp) DISPLAY LIKE 'I' .
  ENDIF.

* Validar que los num.fabr. sean siempre superiores a 10.000Kg
  IF l_kg_desdoblar < 10000 OR
     ( l_kg_fabr_ori - l_kg_desdoblar ) < 10000.
    MESSAGE e300(zpp). "Cantidad incorrecta.
  ENDIF.

* Incrementamos 1 a los registros posteriores al desdoblado
  LOOP AT gti_datos ASSIGNING FIELD-SYMBOL(<wa_datos>) WHERE zindex > <desdoblado>-zindex.
    <wa_datos>-zindex = <wa_datos>-zindex + 1.
  ENDLOOP.

* Obtenemos el nº de fabricación máximo para esa OF.
  CLEAR l_num_fabr_max.
  LOOP AT gti_datos INTO DATA(ls_datos) WHERE aufnr    = <desdoblado>-aufnr AND
                                              num_fabr < 100.
    IF ls_datos-num_fabr > l_num_fabr_max.
      l_num_fabr_max = ls_datos-num_fabr.
    ENDIF.
  ENDLOOP.

* Actualizamos los quilos restándole los desdoblados.
  <desdoblado>-kg_fabricacion     = l_kg_fabr_ori - l_kg_desdoblar.

  PERFORM calcular_rollos USING <desdoblado>-werks
                                <desdoblado>-kg_fabricacion
                       CHANGING <desdoblado>-rollos
                                <desdoblado>-tornadas.
  IF l_num_fabr_max = 0.
    <desdoblado>-num_fabr =  1.
    l_num_fabr_max        =  1.
  ENDIF.

* Generamos nuevo registro con los kg desdoblados.
  APPEND INITIAL LINE TO gti_datos ASSIGNING FIELD-SYMBOL(<new_line>).
  <new_line> = CORRESPONDING #( <desdoblado> ).
  CLEAR: <new_line>-observaciones ,
         <new_line>-zicon_observa,
         <new_line>-kg_fabricados,
         <new_line>-icon_paro,
         <new_line>-horas_paro.

  <new_line>-kg_fabricacion    = l_kg_desdoblar.
  <new_line>-zindex            = <desdoblado>-zindex + 1 .
  <new_line>-num_fabr          = l_num_fabr_max      + 1 .

  PERFORM calcular_rollos USING <new_line>-werks
                                <new_line>-kg_fabricacion
                       CHANGING <new_line>-rollos
                                <new_line>-tornadas.

  SORT gti_datos ASCENDING BY zindex.

  gt_ztpp0009_upd = CORRESPONDING #( gti_datos ).

  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = zspp0009_pant_selec-centro.

ENDFORM.

FORM f_repetir_fabr  USING p_datos TYPE tyt_alv.
  DATA: l_num_fab_recep TYPE znum_fabr,
        l_num_fabr_max  TYPE znum_fabr.

  DATA: l_kg_repetir TYPE zgamng.

* Validar la selección de 1 sola fila
  IF lines( p_datos ) > 1.
    MESSAGE e298(zpp).
  ENDIF.

  ASSIGN p_datos[ 1 ]   TO FIELD-SYMBOL(<seleccionado>).

* Validamos que la fabricación esté bloqueada.
  IF <seleccionado>-ind_fin <> 'X'.
    MESSAGE e307(zpp). "Para repetir una fabricación, debe estar finalizada
  ENDIF.

  ASSIGN gti_datos[ aufnr =   <seleccionado>-aufnr num_fabr = <seleccionado>-num_fabr ]
        TO FIELD-SYMBOL(<original>).

  PERFORM mostrar_popup_kg_desdoblar  USING <original>-kg_fabricacion
                                            '2'
                                   CHANGING l_kg_repetir.

  CHECK l_kg_repetir > 0.
* Obtenemos el nº de fabricación máximo para esa OF.
  CLEAR l_num_fabr_max.
  LOOP AT gti_datos INTO DATA(ls_datos) WHERE aufnr    = <original>-aufnr AND
                                              num_fabr > 99.
    IF ls_datos-num_fabr > l_num_fabr_max.
      l_num_fabr_max = ls_datos-num_fabr.
    ENDIF.
  ENDLOOP.

* Incrementamos 1 a los registros posteriores al desdoblado
  LOOP AT gti_datos ASSIGNING FIELD-SYMBOL(<incrementamos>) WHERE zindex > <original>-zindex.
    <incrementamos>-zindex = <incrementamos>-zindex + 1.
  ENDLOOP.

* Generamos nuevo registro con los kg adicionales de la repeticion
  APPEND INITIAL LINE TO gti_datos ASSIGNING FIELD-SYMBOL(<new_line>).
  <new_line> = CORRESPONDING #( <original> ).
  CLEAR: <new_line>-observaciones ,
         <new_line>-zicon_observa,
         <new_line>-kg_fabricados,
         <new_line>-icon_paro,
         <new_line>-horas_paro,
         <new_line>-kg_fabricados,
         <new_line>-rollos_notif.

  <new_line>-kg_fabricacion    = l_kg_repetir.
  <new_line>-zindex            = <original>-zindex + 1 .
  <new_line>-ind_fin           = ' '.
  <new_line>-ind_bloq          = 'X'.

  IF l_num_fabr_max = 0.
    <new_line>-num_fabr = 100.
  ELSE.
    <new_line>-num_fabr = l_num_fabr_max + 1.
  ENDIF.

  PERFORM calcular_rollos USING <new_line>-werks
                                <new_line>-kg_fabricacion
                       CHANGING <new_line>-rollos
                                <new_line>-tornadas.

  SORT gti_datos ASCENDING BY zindex.

  gt_ztpp0009_upd = CORRESPONDING #( gti_datos ).

  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = zspp0009_pant_selec-centro.

ENDFORM.


FORM f_delete_fabr  USING p_datos TYPE tyt_alv.
  DATA: l_num_fab_recep   TYPE znum_fabr.


* Validar que solo se haya seleccionado un registro.
  IF lines( p_datos ) > 1.
    MESSAGE e298(zpp). "Seleccionar solo una linea para tratar fabricación
  ENDIF.

  DATA(ls_datos_sel) = p_datos[ 1 ].

  IF ls_datos_sel-ind_bloq <> 'X'.
    MESSAGE e308(zpp).  " Para eliminarar una fabricación, debe estar bloqueada
  ENDIF.

* Error, num de fabricación no valido
  IF ls_datos_sel-num_fabr = 0 .
*    OR      ls_datos_sel-num_fabr > 99.
    MESSAGE e306(zpp).   "No se puede eliminar, seleccione un número de fabricación válido

  ENDIF.

* Contamos cuanta Fabricaciones hay, y nos quedamos con la primera.
  DATA(l_cont_fabr) = 0.
  LOOP AT gti_datos INTO DATA(ls_datos) WHERE aufnr     = ls_datos_sel-aufnr AND
                                              num_fabr NE ls_datos_sel-num_fabr AND
                                              num_fabr < 100.
    ADD 1 TO l_cont_fabr.
    IF l_num_fab_recep = 0. " la primera que encontremos será la fabr.receptora.
      l_num_fab_recep = ls_datos-num_fabr.
    ENDIF.

  ENDLOOP.

* Obtenemos el registro receptor.
  ASSIGN gti_datos[ aufnr    = ls_datos_sel-aufnr
                    num_fabr = l_num_fab_recep   ]  TO FIELD-SYMBOL(<reg_receptor_kg>).

  IF l_cont_fabr = 1.  " Si solo quedará una fabricación limpiamos campo NUM_FABR
    CLEAR: <reg_receptor_kg>-num_fabr .
    <reg_receptor_kg>-kg_fabricacion     = <reg_receptor_kg>-kg_fabricacion + ls_datos_sel-kg_fabricacion.
    PERFORM calcular_rollos USING <reg_receptor_kg>-werks
                                  <reg_receptor_kg>-gamng
                         CHANGING <reg_receptor_kg>-rollos
                                  <reg_receptor_kg>-tornadas.
  ELSE.
* Acumulamos Kgs y calculamos rollos y tornadas para el reg.receptor.
    <reg_receptor_kg>-kg_fabricacion     = <reg_receptor_kg>-kg_fabricacion + ls_datos_sel-kg_fabricacion.
    PERFORM calcular_rollos USING <reg_receptor_kg>-werks
                                  <reg_receptor_kg>-kg_fabricacion
                         CHANGING <reg_receptor_kg>-rollos
                                  <reg_receptor_kg>-tornadas.
  ENDIF.

* Una vez trasladados los datos al registro receptor, procedemos a borrar fabr.seleccionada.
  DELETE gti_datos WHERE aufnr    = ls_datos_sel-aufnr AND
                         num_fabr = ls_datos_sel-num_fabr.


* Grabación BBDD
  gt_ztpp0009_upd = CORRESPONDING #( gti_datos ).

  CALL METHOD zcl_secuenciador=>guardar_ztpp0009
    EXPORTING
      it_ztpp0009 = gt_ztpp0009_upd
      i_werks     = zspp0009_pant_selec-centro.

ENDFORM.

FORM mostrar_popup_kg_desdoblar USING    p_kg_orden TYPE zgamng
                                         p_tipo     TYPE c
                                CHANGING p_kg       TYPE zgamng.

  DATA: sfields   TYPE sval,
        lt_fields TYPE STANDARD TABLE OF sval,
        l_kg.

  sfields-tabname    = 'ZTPP0009'.
  sfields-fieldname  = 'GAMNG'.
  sfields-comp_field = 'GAMNG'.
  sfields-field_attr = '01'.
  sfields-field_obl  = 'X'.
  sfields-fieldtext  = 'Cantidad a fabricar:  '.
  APPEND sfields TO lt_fields.

  CASE p_tipo.
*    WHEN '1'. DATA(l_title) = |Kg. del nº de fabricación original: { p_kg_orden }|.
    WHEN '1'. DATA(l_title) = |Desdoblar fabricación|.
    WHEN '2'. l_title = |Introduzca Kg. para la fabr.repetida (min 10000Kg)|.
    WHEN OTHERS.
  ENDCASE.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = l_title
*     START_COLUMN    = '5'
*     START_ROW       = '5'
*   IMPORTING
*     RETURNCODE      =
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
  IF sy-subrc = 0.
    p_kg = lt_fields[ tabname = 'ZTPP0009' fieldname = 'GAMNG' ]-value.
  ENDIF.


ENDFORM.

FORM mostrar_popup_paro CHANGING    p_horas_paro TYPE zhoras_paro.

  DATA: sfields   TYPE sval,
        lt_fields TYPE STANDARD TABLE OF sval,
        l_kg.


  sfields-tabname    = 'ZTPP0009'.
  sfields-fieldname  = 'HORAS_PARO'.
*  sfields-comp_tab   = 'ZTPP0009'.
  sfields-comp_field = 'ZHORAS_PARO'.
  sfields-field_attr = '01'.
  sfields-field_obl  = 'X'.
  APPEND sfields TO lt_fields.

  DATA(l_title) = |Informar horas de paro programado|.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = l_title
*     START_COLUMN    = '5'
*     START_ROW       = '5'
*   IMPORTING
*     RETURNCODE      =
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
  IF sy-subrc = 0.
    p_horas_paro = lt_fields[ tabname = 'ZTPP0009' fieldname = 'HORAS_PARO' ]-value.
  ENDIF.


ENDFORM.

FORM dequeue_secuenciador.

  CALL FUNCTION 'DEQUEUE_EZPP0030_QUEUE'
    EXPORTING
      mode_ztpp0009 = 'E'
      werks         = zspp0009_pant_selec-centro
      x_werks       = ' '
      _scope        = '3'
      _synchron     = ' '
      _collect      = ' '.

  SET SCREEN 0.
  LEAVE SCREEN.



ENDFORM.
