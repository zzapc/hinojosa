*&---------------------------------------------------------------------*
*&  Include           ZRPP0002_FORMS
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  F_REPT_CONS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rept_cons.

  " 0. Inicializar variables:
  PERFORM f_inicializacion.
  " 1. Recuperar fechas de selección:
  PERFORM f_rec_fechas.
  " 2. Recuperación datos materiales fabricado y a consumir:
  PERFORM f_rec_datos.
  " 3. Explosión datos materiales fabricados y totales de cantidad:
  PERFORM f_expl_datos.
  " 4. Cálculo de repartos:
  PERFORM f_calc_repartos.
* GST - 02/01/2015 ->
  PERFORM f_calc_repartos_2.


* INI CGIJON - 13.03.17 - TICKET Ticket ## 25719
* ponemos la columna PORC_FSC = 100%
*  PERFORM mod_porc_fsc. "UDEFINEDES Nuevo calculo FSC
* FIN CGIJON - 13.03.17 - TICKET Ticket ## 25719

* GST - 02/01/2015 <-
  " 5. Mostrar datos ALV:
  CALL SCREEN 0100.


ENDFORM.                    " F_REPT_CONS
*&---------------------------------------------------------------------*
*&      Form  F_REC_FECHAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_fechas .

  " Fecha final-hora final para selección fabricación:
  IF p_d_fin IS NOT INITIAL AND p_h_fin IS NOT INITIAL.
    gv_ff_fin = p_d_fin. "sy-datum.
    gv_hf_fin = p_h_fin. "sy-uzeit.
  ELSE.
    gv_ff_fin = sy-datum.
    gv_hf_fin = sy-uzeit.
  ENDIF.

  " Fecha inicio-hora inicio para selección fabricación:
  SELECT SINGLE fecha hora INTO (gv_ff_ini , gv_hf_ini)
    FROM ztpp0003
* GST - 07/07/2016 ->
    WHERE werks = p_werks
* GST - 07/07/2016 <-
    AND progname = c_progname.

  gv_hf_ini = gv_hf_ini + 1.

  IF gv_hf_ini = '000000'.
    gv_ff_ini = gv_ff_ini + 1.
  ENDIF.

  " Fecha inicio-hora inicio para selección consumir:
  " Hora inicio selección fabricación menos dos horas

* GST - 30/06/2015 ->
* En vez de 4 horas atrás, va a mirar 12 horas atrás:
*  gv_hc_ini = gv_hf_ini - 14400.
  gv_hc_ini = gv_hf_ini - 43200.
* GST - 30/06/2015 <-

  IF gv_hc_ini > gv_hf_ini.
    gv_fc_ini = gv_ff_ini - 1.
  ELSE.
    gv_fc_ini = gv_ff_ini.
  ENDIF.

  " Fecha fin - hora fin para selección consumir:
  " Hora fin selección fabricación menos 1 hora y 45 min.
  " (Damos un margen de 15 min)

*  gv_hc_fin = gv_hf_fin - 13500.
  gv_hc_fin = gv_hf_ini - 14400. " Modif CMS  Cambiar calculo de hora de referencia para tomar mat.prima 29/05/2019

  IF gv_hc_fin > gv_hf_fin.
    gv_fc_fin = gv_ff_fin - 1.
  ELSE.
    gv_fc_fin = gv_ff_fin.
  ENDIF.

*gv_hf_ini = '000001'.
*gv_ff_ini = '20150108'.
*gv_hf_fin = '240000'.
*gv_ff_fin = '20150108'.
*gv_hc_ini = '000001'.
*gv_fc_ini = '20150108'.
*gv_hc_fin = '240000'.
*gv_fc_fin = '20150108'.

ENDFORM.                    " F_REC_FECHAS
*&---------------------------------------------------------------------*
*&      Form  F_INICIALIZACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_inicializacion .

  " Inicialización de variables:
  CLEAR: gv_ff_ini, gv_ff_fin, gv_hf_ini, gv_hf_fin.
  CLEAR: gv_fc_ini, gv_fc_fin, gv_hc_ini, gv_hc_fin.

  " Inicialización de tablas internas:
  CLEAR: gt_mat_fab, gt_mat_cons, gt_mat_fab_expl, gt_tot_mat, gt_consumo, gt_ord_cons, gt_ref_pos.
  REFRESH: gt_mat_fab,gt_mat_cons, gt_mat_fab_expl, gt_tot_mat, gt_consumo, gt_ord_cons, gt_ref_pos.

* GST - 14/01/2016 - ZREC y PULPER ->
  CLEAR: gt_no_resb_cons, gt_fab_aufnr.
  REFRESH: gt_no_resb_cons, gt_fab_aufnr.
* GST - 14/01/2016 - ZREC y PULPER <-

ENDFORM.                    " F_INICIALIZACION
*&---------------------------------------------------------------------*
*&      Form  F_REPT_CONS_FONDO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rept_cons_fondo .

  DATA: ls_consumo    LIKE LINE OF gt_consumo,
        lv_no_act_tab TYPE         xflag.


  " 0. Inicializar variables:
  PERFORM f_inicializacion.
  " 1. Recuperar fechas de selección:
  PERFORM f_rec_fechas.
  " 2. Recuperación datos materiales fabricado y a consumir:
  PERFORM f_rec_datos.
  " 3. Explosión datos materiales fabricados y totales de cantidad:
  PERFORM f_expl_datos.
  " 4. Cálculo de repartos:
  PERFORM f_calc_repartos.
* GST - 02/01/2015 ->
  PERFORM f_calc_repartos_2.
* GST - 02/01/2015 <-
  " 5. Consumos:
  PERFORM f_consumos.
  " 6. Cálculo % FSC y act. características:
  PERFORM f_act_porcentajes.
  " 7. Mostrar log:
  PERFORM f_grabar_log.

* INI CGIJON - 13.03.17 - TICKET Ticket ## 25719
* ponemos la columna PORC_FSC = 100%
*  PERFORM mod_porc_fsc. "UDEFINEDES Nuevo calculo FSC
* FIN CGIJON - 13.03.17 - TICKET Ticket ## 25719

* GST - 13/03/2015 ->
  " Actualizar sólo la tabla Z cuando todo el proceso ha ido bien:
  CLEAR: ls_consumo, lv_no_act_tab.
  READ TABLE gt_consumo INTO ls_consumo WITH KEY tipo = 'E'.
  IF ls_consumo IS NOT INITIAL.
    lv_no_act_tab = 'X'.
  ENDIF.

  CLEAR ls_consumo.
  READ TABLE gt_consumo INTO ls_consumo WITH KEY tipo_act = 'E'.
  IF ls_consumo IS NOT INITIAL.
    lv_no_act_tab = 'X'.
  ENDIF.

  PERFORM act_tabla_z. "CMS Grabar siempre tabla 53598  19/02/2019

  IF lv_no_act_tab <> 'X'.
    " 8. Actualizar tabla fechas ejecución programa:
*    PERFORM act_tabla_z. "CMS Grabar siempre tabla 53598
  ELSE.
    "Existe algun tipo de error. Se envia un email  19/02/2019
    PERFORM f_enviar_mail_error.

  ENDIF.

* GST - 13/03/2015 <-

ENDFORM.                    " F_REPT_CONS_FONDO
*&---------------------------------------------------------------------*
*&      Form  F_REC_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_datos .

* 1. Recuperamos y acumulamos movimientos de mat. fabricado
* GST - 23/04/2015 ->
* Eliminar cantidades negativas fabricadas
*  PERFORM f_rec_mat_fabricados.
  PERFORM f_rec_mat_fabricados_cant_neg.
* GST - 23/04/2015 <-

* 2. Recuperamos y acumulamos movimientos de mat. consumir
* IEG - 10.10.2016 - Modificamos la lógica del consumo para consumir
* todos los lotes que haya en el almacén trasladados antes de
* la fecha y la hora. Así consumimos también la cantidad de posibles
* errores que se hayan producido en ejecuciones anteriores y por tanto
* se hayan quedado en el almacén sin consumir
*  PERFORM f_rec_mat_consumir.
  PERFORM f_rec_mat_consumir_v2.
* IEG - 10.10.2016

* GST - 27/05/2015 ->
* 3. Recuperamos materiales residuo (para cálculo % FSC):
  PERFORM f_rec_mat_residuo.
* GST - 27/05/2015 <-

ENDFORM.                    " F_REC_DATOS
*&---------------------------------------------------------------------*
*&      Form  F_REC_MAT_FABRICADOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_mat_fabricados .

*  " Tablas locales:
*  DATA: lt_mkpf TYPE TABLE OF mkpf,
  DATA: lt_mseg TYPE TABLE OF mseg.

*  DATA: lt_mkpf_mseg TYPE TABLE OF zvpp_pulper,
*        ls_mkpf_mseg TYPE          zvpp_pulper.

  " Estructuras locales:
  DATA: ls_mat_fab    LIKE gt_mat_fab,
        ls_mseg       TYPE mseg,
        ls_ord_cons   LIKE gt_ord_cons,
        ls_ord_cons_2 LIKE gt_ord_cons_2,
        lv_mtart      TYPE mtart,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_maktx      TYPE maktx,
        lv_stat       TYPE flag.


*  " Seleccionamos doc. material dentro de las fechas de fabricación seleccionadas:
*  REFRESH: lt_mkpf, lt_mseg.
*   REFRESH: lt_mkpf_mseg.
  REFRESH lt_mseg.

* GST - 13/03/2015 ->
** GST - 10/03/2015 ->
*  IF gv_ff_ini = gv_ff_fin.
*    SELECT * FROM mkpf INTO TABLE lt_mkpf
*      WHERE ( budat = gv_ff_ini AND cputm >= gv_hf_ini AND cputm <= gv_hf_fin ).
*  ELSE.
*    SELECT * FROM mkpf INTO TABLE lt_mkpf
*      WHERE ( ( budat = gv_ff_ini AND cputm >= gv_hf_ini )
*      OR    ( budat = gv_ff_fin AND cputm <= gv_hf_fin )
*      OR    ( budat < gv_ff_fin AND budat > gv_ff_ini ) ).
*  ENDIF.
** GST - 10/03/2015 <-
*
*  IF lt_mkpf[] IS NOT INITIAL.
*    " Seleccionamos las clases de movimiento 101 y 102:
*    SELECT * FROM mseg INTO TABLE lt_mseg
*      FOR ALL ENTRIES IN lt_mkpf
*      WHERE mblnr = lt_mkpf-mblnr
*      AND mjahr = lt_mkpf-mjahr
*      AND kzbew = 'F'
*      AND ( bwart = '101' OR bwart = '102' ).
*  ENDIF.

  IF gv_ff_ini = gv_ff_fin.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                      AND  mkpf~mjahr = mseg~mjahr
WHERE ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini AND mkpf~cputm <= gv_hf_fin )
AND mseg~kzbew = 'F'
AND mseg~werks = p_werks
AND mseg~lgort IN s_lgort1
AND ( mseg~bwart = '101' OR mseg~bwart = '102' ).

  ELSE.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                      AND  mkpf~mjahr = mseg~mjahr
      WHERE ( ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini ) OR
              ( mkpf~budat = gv_ff_fin AND mkpf~cputm <= gv_hf_fin ) OR
              ( mkpf~budat < gv_ff_fin AND mkpf~budat > gv_ff_ini ) )
      AND mseg~kzbew = 'F'
      AND mseg~werks = p_werks
      AND mseg~lgort IN s_lgort1
      AND ( mseg~bwart = '101' OR mseg~bwart = '102' ).

  ENDIF.

* GST - 13/03/2015 <-

  LOOP AT lt_mseg INTO ls_mseg.
    CLEAR: lv_mtart, ls_mat_fab, lv_maktx.

    " Revisar que la orden de fabricación esté en status liberado (I0002):
    CLEAR lv_stat.
    PERFORM f_stat_ord USING ls_mseg-aufnr
                       CHANGING lv_stat.

    IF lv_stat <> 'X'.
      CONTINUE.
    ENDIF.

    " Revisar que el material sea del tipo ZROL:
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = ls_mseg-matnr.

    SELECT SINGLE maktx INTO lv_maktx
      FROM makt
      WHERE matnr = ls_mseg-matnr
      AND spras = sy-langu.

    IF lv_mtart = 'ZROL'.

      CLEAR: lv_index, ls_mat_fab.
      READ TABLE gt_mat_fab INTO ls_mat_fab WITH KEY matnr = ls_mseg-matnr
                                                    charg = ls_mseg-charg
                                                    aufnr = ls_mseg-aufnr.
      lv_index = sy-tabix.

      IF ls_mat_fab IS NOT INITIAL.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_mat_fab-menge = ls_mat_fab-menge + ls_mseg-menge.
            ls_mat_fab-meins = ls_mseg-meins.
          WHEN '102'.
            ls_mat_fab-menge = ls_mat_fab-menge - ls_mseg-menge.
            ls_mat_fab-meins = ls_mseg-meins.
        ENDCASE.
        MODIFY gt_mat_fab FROM ls_mat_fab INDEX lv_index.
      ELSE.
        ls_mat_fab-matnr = ls_mseg-matnr.
        ls_mat_fab-maktx_fab = lv_maktx.
        ls_mat_fab-charg = ls_mseg-charg.
        ls_mat_fab-aufnr = ls_mseg-aufnr.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_mat_fab-menge = ls_mseg-menge.
          WHEN '102'.
            ls_mat_fab-menge = ( -1 ) * ls_mseg-menge.
        ENDCASE.
        ls_mat_fab-meins = ls_mseg-meins.
        APPEND ls_mat_fab TO gt_mat_fab.

      ENDIF.

      "  Añadir a una tabla dónde sólo estén contenidas las órdenes
      "  contra las que se va a hacer consumo y buscar sus referencias:
      CLEAR: ls_ord_cons, lv_index_2.
      READ TABLE gt_ord_cons INTO ls_ord_cons WITH KEY aufnr = ls_mseg-aufnr
                                                      charg = ls_mseg-charg.
      lv_index_2 = sy-tabix.
      IF ls_ord_cons IS INITIAL.
        ls_ord_cons-aufnr = ls_mseg-aufnr.
        ls_ord_cons-charg = ls_mseg-charg.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
        ENDIF.
        SELECT SINGLE rsnum INTO ls_ord_cons-rsnum
          FROM caufv
          WHERE aufnr = ls_mseg-aufnr.
        APPEND ls_ord_cons TO gt_ord_cons.
      ELSE.
        IF ls_ord_cons-budat IS INITIAL AND ls_mseg-bwart = '101'.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons FROM ls_ord_cons INDEX lv_index_2.
        ELSEIF ls_ord_cons-budat IS NOT INITIAL AND ls_mseg-bwart = '101' AND ls_mseg-budat_mkpf < ls_ord_cons-budat.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons FROM ls_ord_cons INDEX lv_index_2.
        ENDIF.
      ENDIF.

* GST - 02/01/2015 ->
      CLEAR: ls_ord_cons_2, lv_index_2.
      READ TABLE gt_ord_cons_2 INTO ls_ord_cons_2 WITH KEY aufnr = ls_mseg-aufnr.
*                                                           charg = ls_mseg-charg.
      lv_index_2 = sy-tabix.
      IF ls_ord_cons_2 IS INITIAL.
        ls_ord_cons_2-aufnr = ls_mseg-aufnr.
*        ls_ord_cons_2-charg = ls_mseg-charg.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
        ENDIF.
*        SELECT SINGLE rsnum INTO ls_ord_cons-rsnum
*          FROM caufv
*          WHERE aufnr = ls_mseg-aufnr.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge + ls_mseg-menge.
          gv_tot_fab = gv_tot_fab + ls_mseg-menge.
        ELSE.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge - ls_mseg-menge.
          gv_tot_fab = gv_tot_fab - ls_mseg-menge.
        ENDIF.
        APPEND ls_ord_cons_2 TO gt_ord_cons_2.
      ELSE.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge + ls_mseg-menge.
          gv_tot_fab = gv_tot_fab + ls_mseg-menge.
        ELSE.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge - ls_mseg-menge.
          gv_tot_fab = gv_tot_fab - ls_mseg-menge.
        ENDIF.
        IF ls_ord_cons_2-budat IS INITIAL AND ls_mseg-bwart = '101'.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ELSEIF ls_ord_cons_2-budat IS NOT INITIAL AND ls_mseg-bwart = '101' AND ls_mseg-budat_mkpf < ls_ord_cons_2-budat.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ELSE.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ENDIF.
      ENDIF.

* GST - 02/01/2015 <-

    ENDIF.
  ENDLOOP.

  " Recuperamos las posiciones de los distintos materiales en las reservas
  " de la orden:
  SELECT rsnum rspos matnr rgekz INTO CORRESPONDING FIELDS OF TABLE gt_ref_pos
  FROM resb
  FOR ALL ENTRIES IN gt_ord_cons
  WHERE rsnum = gt_ord_cons-rsnum.
*    AND rgekz <> 'X'.


ENDFORM.                    " F_REC_MAT_FABRICADOS
*&---------------------------------------------------------------------*
*&      Form  F_REC_MAT_CONSUMIR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_mat_consumir .

  " Tablas locales:
*  DATA: lt_mkpf TYPE TABLE OF mkpf,
  DATA: lt_mseg TYPE TABLE OF mseg.

  " Estructuras locales:
  DATA: ls_mat_cons LIKE gt_mat_cons,
        ls_mseg     TYPE mseg,
        lv_index    LIKE sy-tabix,
        lv_maktx    TYPE maktx.

  DATA: lv_no_stock TYPE xflag,
        lv_clabs    TYPE labst.

  " Seleccionamos doc. material dentro de las fechas de consumo seleccionadas:

*  REFRESH: lt_mkpf, lt_mseg.
  REFRESH: lt_mseg.


* GST - 13/03/2015 ->
** GST - 10/03/2015 ->
*  IF gv_fc_ini = gv_fc_fin.
*    SELECT * FROM mkpf INTO TABLE lt_mkpf
*      WHERE ( budat = gv_fc_ini AND cputm >= gv_hc_ini AND cputm <= gv_hc_fin ).
*
*  ELSE.
*    SELECT * FROM mkpf INTO TABLE lt_mkpf
*      WHERE ( ( budat = gv_fc_ini AND cputm >= gv_hc_ini )
*      OR    ( budat = gv_fc_fin AND cputm <= gv_hc_fin )
*      OR    ( budat < gv_fc_fin AND budat > gv_fc_ini ) ).
*  ENDIF.
** GST - 10/03/2015 <-
*
*  IF lt_mkpf[] IS NOT INITIAL.
*    " Seleccionamos las clases de movimiento 101 y 102:
*    SELECT * FROM mseg INTO TABLE lt_mseg
*      FOR ALL ENTRIES IN lt_mkpf
*      WHERE mblnr = lt_mkpf-mblnr
*      AND mjahr = lt_mkpf-mjahr
*      AND lgort = '4002' " Almacén PULPER
*      AND xauto = 'X'
*      AND ( bwart = '311' OR bwart = '312' ).
*  ENDIF.

  IF gv_fc_ini = gv_fc_fin.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
     FROM mseg
     INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                     AND  mkpf~mjahr = mseg~mjahr
WHERE ( mkpf~budat = gv_fc_ini AND mkpf~cputm >= gv_hc_ini AND mkpf~cputm <= gv_hc_fin )
AND mseg~werks = p_werks
AND mseg~lgort = p_lgort2
AND mseg~xauto = 'X'
AND ( mseg~bwart = '311' OR mseg~bwart = '312' ).

  ELSE.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
     FROM mseg
     INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                     AND  mkpf~mjahr = mseg~mjahr
     WHERE ( ( mkpf~budat = gv_fc_ini AND mkpf~cputm >= gv_hc_ini ) OR
             ( mkpf~budat = gv_fc_fin AND mkpf~cputm <= gv_hc_fin ) OR
             ( mkpf~budat < gv_fc_fin AND mkpf~budat > gv_fc_ini ) )
     AND mseg~werks = p_werks
     AND mseg~lgort = p_lgort2
     AND mseg~xauto = 'X'
     AND ( mseg~bwart = '311' OR mseg~bwart = '312' ).

  ENDIF.

* GST - 13/03/2015 <-

  " Acumulamos los movimientos:
  LOOP AT lt_mseg INTO ls_mseg.
    CLEAR: lv_index, ls_mat_cons.

* GST - 13/03/2015 ->
    " Chequear que hay stock para consumir:
    CLEAR: lv_no_stock, lv_clabs.
    PERFORM chequeo_stock USING ls_mseg-matnr
                                ls_mseg-charg
                                ls_mseg-werks
                                ls_mseg-lgort
                          CHANGING lv_no_stock
                                   lv_clabs.
    IF lv_no_stock = 'X'.
      CONTINUE.
    ENDIF.
* GST - 13/03/2015 <-

    READ TABLE gt_mat_cons INTO ls_mat_cons WITH KEY matnr = ls_mseg-matnr
                                                    charg = ls_mseg-charg.
    lv_index = sy-tabix.

* GST - 30/06/2015 ->
* Tomamos la cantidad de stock a repartir del stock libre disposición y no
* de los movimientos como se estaba haciendo hasta ahora:
    IF ls_mat_cons IS INITIAL.
* Recuperamos la descripción del material a consumir:
      CLEAR lv_maktx.
      SELECT SINGLE maktx INTO lv_maktx
        FROM makt
        WHERE matnr = ls_mseg-matnr
        AND spras = sy-langu.
      ls_mat_cons-matnr = ls_mseg-matnr.
      ls_mat_cons-maktx_cons = lv_maktx.
      ls_mat_cons-charg = ls_mseg-charg.
      ls_mat_cons-meins = ls_mseg-meins.
      ls_mat_cons-menge = lv_clabs.
      APPEND ls_mat_cons TO gt_mat_cons.
    ENDIF.

* GST - 30/06/2015 <-

** GST - 30/06/2015 ->
* Comentamos este funcionamiento porque a partir de ahora
* la cantidad que vamos a consumir es la de libre disposición
*  y no la de los movimientos seleccionados.
*    IF ls_mat_cons IS NOT INITIAL.
*      CASE ls_mseg-bwart.
*        WHEN '311'.
*          ls_mat_cons-menge = ls_mat_cons-menge + ls_mseg-menge.
*          ls_mat_cons-meins = ls_mseg-meins.
*        WHEN '312'.
*          ls_mat_cons-menge = ls_mat_cons-menge - ls_mseg-menge.
*          ls_mat_cons-meins = ls_mseg-meins.
*      ENDCASE.
*      MODIFY gt_mat_cons FROM ls_mat_cons INDEX lv_index.
*    ELSE.
** Recuperamos la descripción del material a consumir:
*      CLEAR lv_maktx.
*      SELECT SINGLE maktx INTO lv_maktx
*        FROM makt
*        WHERE matnr = ls_mseg-matnr
*        AND spras = sy-langu.
*      ls_mat_cons-matnr = ls_mseg-matnr.
*      ls_mat_cons-maktx_cons = lv_maktx.
*      ls_mat_cons-charg = ls_mseg-charg.
*      ls_mat_cons-meins = ls_mseg-meins.
*      CASE ls_mseg-bwart.
*        WHEN '311'.
*          ls_mat_cons-menge = ls_mseg-menge.
*        WHEN '312'.
*          ls_mat_cons-menge = ( - 1 ) * ls_mseg-menge.
*      ENDCASE.
*      APPEND ls_mat_cons TO gt_mat_cons.
*    ENDIF.
*
** GST - 30/06/2015 <-
  ENDLOOP.

ENDFORM.                    " F_REC_MAT_CONSUMIR
*&---------------------------------------------------------------------*
*&      Form  F_EXPL_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_expl_datos.


  DATA: lt_stb TYPE stpox OCCURS 0 WITH HEADER LINE.
  DATA: ls_mat_fab      LIKE gt_mat_fab,
        ls_mat_fab_expl LIKE gt_mat_fab_expl,
        ls_tot_mat      LIKE gt_tot_mat,
        ls_stb          TYPE stpox,
        lv_index        LIKE sy-tabix,
        lv_index_aux    LIKE sy-tabix,
        lv_maktx        TYPE maktx,
        lv_desbl(1).

* INI UDEFINEDES 27.11.2017
  DATA: lv_atflv TYPE atflv,
        lv_atinn TYPE atinn.
* FIN UDEFINEDES

* GST - 14/01/2016 - ZREC y PULPER ->
  DATA: ls_fab_aufnr LIKE LINE OF gt_fab_aufnr.
* GST - 14/01/2016 - ZREC y PULPER <-

* INI UDEFINEDES 27.11.2017
* Nuevo calculo FSC, seleccionamos cod.caracteristica Z_FSC_PROCENTAJE
  SELECT SINGLE atinn INTO lv_atinn FROM cabn WHERE atnam = 'Z_FSC_PORCENTAJE'.
* FIN UDEFINEDES

  LOOP AT gt_mat_fab INTO ls_mat_fab.

    " Explosionamos los datos:
    CLEAR: ls_stb, lt_stb.
    REFRESH: lt_stb.

    CALL FUNCTION 'CS_BOM_EXPL_MAT_V2'
      EXPORTING
*       FTREL                 = ' '
*       ALEKZ                 = ' '
*       ALTVO                 = ' '
*       AUFSW                 = ' '
        aumgb                 = 'X'
*       AUMNG                 = 0
*       AUSKZ                 = ' '
*       AMIND                 = ' '
*       BAGRP                 = ' '
*       BEIKZ                 = ' '
*       BESSL                 = ' '
*       BGIXO                 = ' '
*       BREMS                 = ' '
        capid                 = 'PI01'
*       CHLST                 = ' '
*       COSPR                 = ' '
*       CUOBJ                 = 000000000000000
*       CUOVS                 = 0
*       CUOLS                 = ' '
        datuv                 = sy-datum
*       DELNL                 = ' '
*       DRLDT                 = ' '
        ehndl                 = 'X'
        emeng                 = ls_mat_fab-menge
*       ERSKZ                 = ' '
*       ERSSL                 = ' '
*       FBSTP                 = ' '
*       KNFBA                 = ' '
*       KSBVO                 = ' '
*       MBWLS                 = ' '
*       MKTLS                 = 'X'
*       MDMPS                 = ' '
        mehrs                 = '1'
*       MKMAT                 = ' '
*       MMAPS                 = ' '
*       SALWW                 = ' '
*       SPLWW                 = ' '
        mmory                 = '1'
        mtnrv                 = ls_mat_fab-matnr
*       NLINK                 = ' '
*       POSTP                 = ' '
*       RNDKZ                 = ' '
*       RVREL                 = ' '
*       SANFR                 = ' '
*       SANIN                 = ' '
*       SANKA                 = ' '
*       SANKO                 = ' '
*       SANVS                 = ' '
*       SCHGT                 = ' '
*       STKKZ                 = ' '
        stlal                 = '01'
        stlan                 = '1'
        stpst                 = 0
        svwvo                 = 'X'
        werks                 = p_werks "'3000'
*       NORVL                 = ' '
*       MDNOT                 = ' '
*       PANOT                 = ' '
*       QVERW                 = ' '
*       VERID                 = ' '
        vrsvo                 = 'X'
*     IMPORTING
*       TOPMAT                =
*       DSTST                 =
      TABLES
        stb                   = lt_stb
*       MATCAT                =
      EXCEPTIONS
        alt_not_found         = 1
        call_invalid          = 2
        material_not_found    = 3
        missing_authorization = 4
        no_bom_found          = 5
        no_plant_data         = 6
        no_suitable_bom_found = 7
        conversion_error      = 8
        OTHERS                = 9.

    IF sy-subrc <> 0.
* Implement suitable error handling here
    ELSE.

* INI UDEFINEDES 27.11.2017
* Nuevo calculo del FSC
* Se substituye la consulta a la lista de materiales por una consulta
* a la característica Z_FSC_PORCENTAJE del material recorte...
      LOOP AT lt_stb INTO ls_stb." WHERE ( sortf = 'FSC' OR sortf = 'RC' ). UDEFINDES 27.11.2017

        " Rellenamos la tabla con los componentes explosionados:
        CLEAR ls_mat_fab_expl.
        MOVE-CORRESPONDING ls_mat_fab TO ls_mat_fab_expl.
        ls_mat_fab_expl-idnrk = ls_stb-idnrk.

        " Miramos si el material tiene el movimiento desbloqueado en la RESB:
        PERFORM f_mov_desb USING ls_mat_fab_expl-aufnr
                                 ls_mat_fab_expl-charg
                                 ls_stb-idnrk
                           CHANGING lv_desbl.

        IF lv_desbl = 'X'.

          " Recuperamos la descripción del material del componente:
          CLEAR lv_maktx.
          SELECT SINGLE maktx INTO lv_maktx
            FROM makt
            WHERE matnr = ls_stb-idnrk
            AND spras = sy-langu.
          ls_mat_fab_expl-maktx_cons = lv_maktx.
          ls_mat_fab_expl-mnglg = ls_stb-mnglg.
          ls_mat_fab_expl-mmein = ls_stb-mmein.
* INI UDEFINES 27.11.2017
          SELECT SINGLE atflv INTO lv_atflv FROM ausp
            WHERE objek = ls_mat_fab_expl-idnrk AND atinn = lv_atinn.
          IF sy-subrc = 0.
*          ls_mat_fab_expl-sortf = ls_stb-sortf.
            ls_mat_fab_expl-sortf = 'FSC'.
            ls_mat_fab_expl-fsc = lv_atflv.
          ELSE.
            ls_mat_fab_expl-sortf = 'RC'.
            ls_mat_fab_expl-fsc = 0.
          ENDIF.
* FIN UDEFINEDES 27.11.2017
          APPEND ls_mat_fab_expl TO gt_mat_fab_expl.

          " Rellenamos la tabla con los totalizados de los componentes:
          CLEAR: ls_tot_mat, lv_index.
          READ TABLE gt_tot_mat INTO ls_tot_mat WITH KEY idnrk = ls_stb-idnrk.
          lv_index = sy-tabix.
          IF ls_tot_mat IS NOT INITIAL.
            ls_tot_mat-mnglg = ls_tot_mat-mnglg + ls_stb-mnglg.
            MODIFY gt_tot_mat FROM ls_tot_mat INDEX lv_index.
          ELSE.
            MOVE-CORRESPONDING ls_stb TO ls_tot_mat.
            ls_tot_mat-maktx_cons = lv_maktx.
            APPEND ls_tot_mat TO gt_tot_mat.
          ENDIF.
        ENDIF.

      ENDLOOP.

    ENDIF.

* GST - 14/01/2016 - ZREC y PULPER ->

    CLEAR: ls_fab_aufnr, lv_index_aux.
    READ TABLE gt_fab_aufnr INTO ls_fab_aufnr
       WITH KEY aufnr = ls_mat_fab-aufnr.
    lv_index_aux = sy-tabix.
    IF ls_fab_aufnr IS INITIAL.
      ls_fab_aufnr-aufnr = ls_mat_fab-aufnr.
      ls_fab_aufnr-menge = ls_mat_fab-menge.
      APPEND ls_fab_aufnr TO gt_fab_aufnr.

    ELSE.
      ls_fab_aufnr-menge = ls_fab_aufnr-menge +
                           ls_mat_fab-menge.
      MODIFY gt_fab_aufnr FROM ls_fab_aufnr
             INDEX lv_index_aux.

    ENDIF.

* GST - 14/01/2016 - ZREC y PULPER <-

  ENDLOOP.

ENDFORM.                    " F_EXPL_DATOS
*&---------------------------------------------------------------------*
*&      Form  F_CALC_REPARTOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_calc_repartos.

  DATA: ls_mat_fab_expl LIKE gt_mat_fab_expl,
        ls_consumo      TYPE zstpp_consumo_pulper,
        ls_tot_mat      LIKE gt_tot_mat,
        ls_mat_cons     LIKE gt_mat_cons,
        lv_menge        TYPE menge_d,
        lv_index        LIKE sy-tabix,
        lv_index2       LIKE sy-tabix,
        lv_index3       LIKE sy-tabix.

  " Cálculo de porcentajes de reparto y cantidades a consumir:
* GST - Eliminar picos ->
  SORT gt_mat_fab_expl BY idnrk ASCENDING
                          aufnr ASCENDING
                          charg ASCENDING.
* GST - Eliminar picos <-
  LOOP AT gt_mat_fab_expl INTO ls_mat_fab_expl.
    CLEAR ls_consumo.
    ls_consumo-matnr_fab = ls_mat_fab_expl-matnr.
    ls_consumo-desc_matnr_fab = ls_mat_fab_expl-maktx_fab.
    ls_consumo-charg_fab = ls_mat_fab_expl-charg.
    ls_consumo-menge_fab = ls_mat_fab_expl-menge.
    ls_consumo-meins_fab = ls_mat_fab_expl-meins.
    ls_consumo-aufnr = ls_mat_fab_expl-aufnr.
    ls_consumo-comp_cons = ls_mat_fab_expl-idnrk.
    ls_consumo-desc_comp_cons = ls_mat_fab_expl-maktx_cons.
    ls_consumo-sortf = ls_mat_fab_expl-sortf.
    ls_consumo-comp_menge_fab = ls_mat_fab_expl-mnglg.
    ls_consumo-comp_meins_fab = ls_mat_fab_expl-mmein.
    ls_consumo-icono = '@09@'.
    ls_consumo-porc_fsc = ls_mat_fab_expl-fsc. "UDEFINEDES 28.11.2017

    " Seleccionamos la cantidad total fabricada del componente:
    CLEAR ls_tot_mat.
    READ TABLE gt_tot_mat INTO ls_tot_mat WITH KEY idnrk = ls_consumo-comp_cons.
    ls_consumo-comp_menge_tot = ls_tot_mat-mnglg.
    ls_consumo-comp_meins_tot = ls_tot_mat-mmein.

    " Cálculo de porcentaje de consumo del material:
    IF ls_consumo-comp_menge_tot NE 0.
      ls_consumo-comp_porcentaje = ( ls_consumo-comp_menge_fab / ls_consumo-comp_menge_tot ) * 100.
    ENDIF.

    CLEAR lv_index.
    " Repartos del porcentaje entre los lotes del material a consumir:
    LOOP AT gt_mat_cons INTO ls_mat_cons WHERE matnr = ls_consumo-comp_cons.
* GST - Eliminar picos ->
      lv_index = sy-tabix.
* GST - Eliminar picos <-
      ls_consumo-comp_charg_cons = ls_mat_cons-charg.
      IF ls_consumo-comp_menge_tot NE 0.
        ls_consumo-comp_menge_cons = ( ls_consumo-comp_menge_fab / ls_consumo-comp_menge_tot ) * ls_mat_cons-menge.
      ENDIF.
* GST - Eliminar picos ->
*      CLEAR lv_menge.
*      lv_menge = ls_mat_cons-menge - ls_mat_cons-menge_cons.
*      IF ls_consumo-comp_menge_cons > lv_menge.
*        ls_consumo-comp_menge_cons = lv_menge.
*      ENDIF.
      ls_mat_cons-menge_cons = ls_mat_cons-menge_cons + ls_consumo-comp_menge_cons.
      ls_mat_cons-procesado = 'X'.
      MODIFY gt_mat_cons FROM ls_mat_cons INDEX lv_index.
* GST - Eliminar picos <-
      ls_consumo-comp_meins_cons = ls_mat_cons-meins.
      APPEND ls_consumo TO gt_consumo.

    ENDLOOP.

** GST - Eliminar picos ->
    CLEAR lv_index2.
    AT END OF idnrk.
      LOOP AT gt_consumo INTO ls_consumo WHERE comp_cons = ls_consumo-comp_cons
                                      AND charg_fab = ls_consumo-charg_fab
                                      AND aufnr =  ls_consumo-aufnr
                                      AND no_resb <> 'X'.
*                                         AND matnr_fab = ls_consumo-desc_matnr_fab.
        lv_index2 = sy-tabix.
        CLEAR ls_mat_cons.
        READ TABLE gt_mat_cons INTO ls_mat_cons WITH KEY matnr = ls_consumo-comp_cons
                                   charg = ls_consumo-comp_charg_cons.

        IF ls_mat_cons IS NOT INITIAL.
          ls_consumo-comp_menge_cons = ls_consumo-comp_menge_cons + ( ls_mat_cons-menge - ls_mat_cons-menge_cons ).
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index2.
        ENDIF.
      ENDLOOP.
    ENDAT.
** GST - Eliminar picos <-
  ENDLOOP.

ENDFORM.                    " F_CALC_REPARTOS


*&---------------------------------------------------------------------*
*&      Form  MOV_CONSUMO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_CONSUMO  text
*----------------------------------------------------------------------*
FORM mov_consumo TABLES lt_return STRUCTURE bapiret2
                 USING ps_ord_cons LIKE LINE OF gt_ord_cons
                 CHANGING lc_error
                          lv_materialdocument
                          lv_matdocumentyear.

  DATA: lt_goodsmvt_item TYPE TABLE OF bapi2017_gm_item_create.

  DATA: ls_goodsmvt_header TYPE         bapi2017_gm_head_01,
        ls_goodsmvt_code   TYPE         bapi2017_gm_code,
        ls_goodsmvt_item   TYPE         bapi2017_gm_item_create,
        ls_return          TYPE         bapiret2,
        ls_ref_pos         LIKE         gt_ref_pos,
        ls_consumo         LIKE LINE OF gt_consumo,
        ls_consumo_aux     LIKE LINE OF gt_consumo.

  REFRESH: lt_goodsmvt_item, lt_return.
* GST - 22/10/2014 ->
* Resolver DUMP TABLE_FREE_IN_LOOP:
  CLEAR: gt_consumo_aux, ls_consumo_aux.
  REFRESH: gt_consumo_aux.
* GST - 22/10/2014 <-

  " 1) Cabecera:


  " 2) Tipo de movimiento:
  CLEAR ls_goodsmvt_code.
  ls_goodsmvt_code-gm_code       = '06'.

  " 3) Posiciones:
  LOOP AT gt_consumo INTO ls_consumo WHERE aufnr     = ps_ord_cons-aufnr
                                       AND charg_fab = ps_ord_cons-charg
                                       AND procesado <> 'X'
                                       AND no_resb   <> 'X'.
    CLEAR: ls_goodsmvt_item.
* GST - 22/10/2014 ->
    CLEAR: ls_consumo_aux.
* GST - 22/10/2014 <-
    ls_goodsmvt_item-material = ls_consumo-comp_cons.
    ls_goodsmvt_item-plant = p_werks. "'3000'.
    ls_goodsmvt_item-stge_loc = p_lgort2. "'4002'.
    ls_goodsmvt_item-batch = ls_consumo-comp_charg_cons.
    ls_goodsmvt_item-move_type = '261'.
    ls_goodsmvt_item-stck_type = ' '. " Libre utilización
    ls_goodsmvt_item-entry_qnt = ls_consumo-comp_menge_cons.
    ls_goodsmvt_item-entry_uom = ls_consumo-comp_meins_cons.
    ls_goodsmvt_item-reserv_no = ps_ord_cons-rsnum.
    CLEAR ls_ref_pos.
    READ TABLE gt_ref_pos INTO ls_ref_pos WITH KEY rsnum = ps_ord_cons-rsnum
                                                   matnr = ls_consumo-comp_cons.
    IF ls_ref_pos IS NOT INITIAL.
      ls_goodsmvt_item-res_item = ls_ref_pos-rspos.
    ENDIF.
    APPEND ls_goodsmvt_item TO lt_goodsmvt_item.
* GST - 22/10/2014 ->
    ls_consumo_aux = ls_consumo.
    APPEND ls_consumo_aux TO gt_consumo_aux.
* GST - 22/10/2014 <-
  ENDLOOP.

  CLEAR ls_goodsmvt_header.
* uDefine Ticket 47148 se cambia la fecha de contabilizacion para evitar el problema
* de consumos antes de existencias de material
  ls_goodsmvt_header-pstng_date  = sy-datum." ps_ord_cons-budat.
  ls_goodsmvt_header-doc_date    = sy-datum."ps_ord_cons-budat.
  ls_goodsmvt_header-header_txt  = text-003.

  IF lt_goodsmvt_item[] IS NOT INITIAL.

    " 4) Creamos documento de material: Llamada a la BAPI
    CLEAR: lv_materialdocument, lv_matdocumentyear.
    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = ls_goodsmvt_header
        goodsmvt_code    = ls_goodsmvt_code
      IMPORTING
        materialdocument = lv_materialdocument
        matdocumentyear  = lv_matdocumentyear
      TABLES
        goodsmvt_item    = lt_goodsmvt_item
        return           = lt_return.

    CLEAR: ls_return, lc_error.
    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
    IF NOT ls_return IS INITIAL.
      IF ( ls_return-number = 897 AND ls_return-id = 'M3' ) OR
         ( ls_return-number = 682 AND ls_return-id = 'M3' ) OR
         ( ls_return-number = 024 AND ls_return-id = 'M3' )."Materia bloqueado
        lc_error = 'B'.
      ELSE.
        lc_error = 'X'.
      ENDIF.
    ENDIF.

  ELSE.
    lc_error = 'D'.
  ENDIF.

ENDFORM.                    " MOV_CONSUMO
*&---------------------------------------------------------------------*
*&      Form  F_CONSUMOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_consumos .

  DATA: lt_return TYPE bapiret2_t.
  DATA: ls_ord_cons    LIKE         gt_ord_cons,
        ls_ord_cons_2  LIKE         gt_ord_cons_2,
        ls_consumo_aux LIKE LINE OF gt_consumo,
        ls_return_roll LIKE         bapiret2,
        ls_return      TYPE         bapiret2,
        ls_consumo     LIKE LINE OF gt_consumo.
  DATA: lv_error            TYPE flag,
        lv_materialdocument TYPE bapi2017_gm_head_ret-mat_doc,
        lv_matdocumentyear  TYPE bapi2017_gm_head_ret-doc_year,
        lv_index            LIKE sy-tabix.

********************************************************************************
** CONSUMOS CONTRA RESERVA DE LA ORDEN *****************************************
********************************************************************************
  " Vamos a hacer un documento de material por orden (reserva):
  CLEAR ls_ord_cons.
  LOOP AT gt_ord_cons INTO ls_ord_cons.
    CLEAR: lt_return, lv_error, lv_materialdocument, lv_matdocumentyear.
    REFRESH lt_return.
    " Creación documento material:
    CLEAR lv_error.
    PERFORM mov_consumo TABLES lt_return
                        USING ls_ord_cons
                        CHANGING lv_error
                                 lv_materialdocument
                                 lv_matdocumentyear.

    IF lv_error IS NOT INITIAL . " Error en la creación del documento de material
      CLEAR ls_return_roll.
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
        IMPORTING
          return = ls_return_roll.
      CLEAR ls_return.
      READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
* GST - 24/10/2014 ->
* Eliminar dumps:
      CLEAR ls_consumo_aux.
      LOOP AT gt_consumo_aux INTO ls_consumo_aux WHERE no_resb <> 'X'.  "WHERE aufnr = ls_ord_cons-aufnr
        "AND charg_fab = ls_ord_cons-charg
        "AND procesado <> 'X'.
        CLEAR ls_consumo.
        READ TABLE gt_consumo INTO ls_consumo WITH KEY matnr_fab = ls_consumo_aux-matnr_fab
                      charg_fab = ls_consumo_aux-charg_fab
                      aufnr = ls_consumo_aux-aufnr
                      comp_cons = ls_consumo_aux-comp_cons
         comp_charg_cons = ls_consumo_aux-comp_charg_cons.
        lv_index = sy-tabix.
        IF ls_consumo IS NOT INITIAL AND ls_consumo-no_resb <> 'X'.
          ls_consumo-icono = '@0A@'. " Icono rojo -> Tratamiento erróneo
          ls_consumo-tipo = ls_return-type.
          ls_consumo-mensaje = ls_return-message.
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index.
        ENDIF.
      ENDLOOP.
* GST - 24/10/2014 <-
*      LOOP AT gt_consumo INTO ls_consumo WHERE aufnr = ls_ord_cons-aufnr
*                                         AND charg_fab = ls_ord_cons-charg.
*        WRITE:/ ls_consumo-matnr_fab,
*                ls_consumo-desc_matnr_fab,
*                ls_consumo-charg_fab,
*                ls_consumo-menge_fab,
*                ls_consumo-meins_fab,
*                ls_consumo-aufnr,
*                ls_consumo-comp_cons,
*                ls_consumo-desc_comp_cons,
*                ls_consumo-comp_charg_cons,
*                ls_consumo-comp_menge_cons,
*                ls_consumo-comp_meins_cons,
*                ls_return-type,
*                20 ls_return-message.
*      ENDLOOP.

    ELSEIF lv_error IS  INITIAL . " No ha habido error en la creación del documento de material
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
* GST - 24/10/2014 ->
* Eliminar dumps:
      CLEAR ls_consumo_aux.
      LOOP AT gt_consumo_aux INTO ls_consumo_aux WHERE no_resb <> 'X'.  "WHERE aufnr = ls_ord_cons-aufnr
        "AND charg_fab = ls_ord_cons-charg
        "AND procesado <> 'X'.
        CLEAR ls_consumo.
        READ TABLE gt_consumo INTO ls_consumo WITH KEY matnr_fab = ls_consumo_aux-matnr_fab
                      charg_fab = ls_consumo_aux-charg_fab
                      aufnr = ls_consumo_aux-aufnr
                      comp_cons = ls_consumo_aux-comp_cons
         comp_charg_cons = ls_consumo_aux-comp_charg_cons.
        lv_index = sy-tabix.
        IF ls_consumo IS NOT INITIAL AND ls_consumo-no_resb <> 'X'.
          ls_consumo-procesado = 'X'.
          ls_consumo-icono = '@08@'. " Icono verde -> Tratamiento correcto
          ls_consumo-tipo = 'S'.
          CONCATENATE 'Se ha creado doc. material' lv_materialdocument ', Año' lv_matdocumentyear INTO ls_consumo-mensaje
          SEPARATED BY space.
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index.
        ENDIF.
      ENDLOOP.
* GST - 24/10/2014 <-
*      LOOP AT gt_consumo INTO ls_consumo WHERE aufnr = ls_ord_cons-aufnr
*                                   AND charg_fab = ls_ord_cons-charg.
*        ls_consumo-tipo = 'S'.
*        CONCATENATE 'Se ha creado doc. material' lv_materialdocument ', Año' lv_matdocumentyear INTO ls_consumo-mensaje
*                    SEPARATED BY space.
*        WRITE:/ ls_consumo-matnr_fab,
*                ls_consumo-desc_matnr_fab,
*                ls_consumo-charg_fab,
*                ls_consumo-menge_fab,
*                ls_consumo-meins_fab,
*                ls_consumo-aufnr,
*                ls_consumo-comp_cons,
*                ls_consumo-desc_comp_cons,
*                ls_consumo-comp_charg_cons,
*                ls_consumo-comp_menge_cons,
*                ls_consumo-comp_meins_cons,
*                ls_consumo-tipo,
*                20 ls_consumo-mensaje.
*      ENDLOOP.
    ENDIF.

  ENDLOOP.

*******************************************************************************
** CONSUMOS CONTRA ORDEN ******************************************************
*******************************************************************************

  " Vamos a hacer un documento de material por orden (reserva):
  CLEAR ls_ord_cons_2.
  LOOP AT gt_ord_cons_2 INTO ls_ord_cons_2.
    CLEAR: lt_return, lv_error, lv_materialdocument, lv_matdocumentyear.
    REFRESH lt_return.
    " Creación documento material:

    CLEAR lv_error.
    PERFORM mov_consumo_2 TABLES lt_return
                          USING ls_ord_cons_2
                          CHANGING lv_error
                                   lv_materialdocument
                                   lv_matdocumentyear.

    IF lv_error IS NOT INITIAL. " Error en la creación del documento de material
      CLEAR ls_return_roll.
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
        IMPORTING
          return = ls_return_roll.
      CLEAR ls_return.
      READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
* GST - 24/10/2014 ->
* Eliminar dumps:
      CLEAR ls_consumo_aux.
      LOOP AT gt_consumo_aux INTO ls_consumo_aux WHERE no_resb = 'X'.  "WHERE aufnr = ls_ord_cons-aufnr
        "AND charg_fab = ls_ord_cons-charg
        "AND procesado <> 'X'.
        CLEAR ls_consumo.
        READ TABLE gt_consumo INTO ls_consumo WITH KEY aufnr = ls_consumo_aux-aufnr
                                      charg_fab = ls_consumo_aux-charg_fab
                                      comp_cons = ls_consumo_aux-comp_cons
                         comp_charg_cons = ls_consumo_aux-comp_charg_cons.
        lv_index = sy-tabix.
        IF ls_consumo IS NOT INITIAL AND ls_consumo-no_resb = 'X'.
          ls_consumo-icono = '@0A@'. " Icono rojo -> Tratamiento erróneo
          ls_consumo-tipo = ls_return-type.
          ls_consumo-mensaje = ls_return-message.
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index.
        ENDIF.
      ENDLOOP.
* GST - 24/10/2014 <-
*      LOOP AT gt_consumo INTO ls_consumo WHERE aufnr = ls_ord_cons-aufnr
*                                         AND charg_fab = ls_ord_cons-charg.
*        WRITE:/ ls_consumo-matnr_fab,
*                ls_consumo-desc_matnr_fab,
*                ls_consumo-charg_fab,
*                ls_consumo-menge_fab,
*                ls_consumo-meins_fab,
*                ls_consumo-aufnr,
*                ls_consumo-comp_cons,
*                ls_consumo-desc_comp_cons,
*                ls_consumo-comp_charg_cons,
*                ls_consumo-comp_menge_cons,
*                ls_consumo-comp_meins_cons,
*                ls_return-type,
*                20 ls_return-message.
*      ENDLOOP.

    ELSEIF lv_error IS INITIAL . " No ha habido error en la creación del documento de material
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
* GST - 24/10/2014 ->
* Eliminar dumps:
      CLEAR ls_consumo_aux.
      LOOP AT gt_consumo_aux INTO ls_consumo_aux WHERE no_resb = 'X'.  "WHERE aufnr = ls_ord_cons-aufnr
        "AND charg_fab = ls_ord_cons-charg
        "AND procesado <> 'X'.
        CLEAR ls_consumo.
        READ TABLE gt_consumo INTO ls_consumo WITH KEY aufnr = ls_consumo_aux-aufnr
                                      charg_fab = ls_consumo_aux-charg_fab
                                      comp_cons = ls_consumo_aux-comp_cons
                         comp_charg_cons = ls_consumo_aux-comp_charg_cons.
        lv_index = sy-tabix.
        IF ls_consumo IS NOT INITIAL AND ls_consumo-no_resb = 'X'.
          ls_consumo-procesado = 'X'.
          ls_consumo-icono = '@08@'. " Icono verde -> Tratamiento correcto
          ls_consumo-tipo = 'S'.
          CONCATENATE 'Se ha creado doc. material' lv_materialdocument ', Año' lv_matdocumentyear INTO ls_consumo-mensaje
          SEPARATED BY space.
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index.

        ENDIF.
      ENDLOOP.
* GST - 24/10/2014 <-
*      LOOP AT gt_consumo INTO ls_consumo WHERE aufnr = ls_ord_cons-aufnr
*                                   AND charg_fab = ls_ord_cons-charg.
*        ls_consumo-tipo = 'S'.
*        CONCATENATE 'Se ha creado doc. material' lv_materialdocument ', Año' lv_matdocumentyear INTO ls_consumo-mensaje
*                    SEPARATED BY space.
*        WRITE:/ ls_consumo-matnr_fab,
*                ls_consumo-desc_matnr_fab,
*                ls_consumo-charg_fab,
*                ls_consumo-menge_fab,
*                ls_consumo-meins_fab,
*                ls_consumo-aufnr,
*                ls_consumo-comp_cons,
*                ls_consumo-desc_comp_cons,
*                ls_consumo-comp_charg_cons,
*                ls_consumo-comp_menge_cons,
*                ls_consumo-comp_meins_cons,
*                ls_consumo-tipo,
*                20 ls_consumo-mensaje.
*      ENDLOOP.
    ENDIF.

  ENDLOOP.



ENDFORM.                    " F_CONSUMOS
*&---------------------------------------------------------------------*
*&      Form  ACT_TABLA_Z
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM act_tabla_z .

  UPDATE ztpp0003 SET fecha = gv_ff_fin
                      hora =  gv_hf_fin
* GST - 07/07/2016 ->
                  WHERE werks = p_werks
* GST - 07/07/2016 <-
                  AND progname = sy-repid.

ENDFORM.                    " ACT_TABLA_Z
*&---------------------------------------------------------------------*
*&      Form  F_STAT_ORD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_MSEG_AUFNR  text
*      <--P_LV_STAT  text
*----------------------------------------------------------------------*
FORM f_stat_ord  USING    p_aufnr
                 CHANGING p_stat.

  DATA: lv_objnr TYPE j_objnr,
        lv_stat  TYPE j_status.

* INI CMS Optimizacion para evitar accesos a BBDD innecesarios.
  READ TABLE gt_aufnr INTO DATA(wa_aufnr) WITH TABLE KEY aufnr = p_aufnr.
  IF sy-subrc = 0.
    p_stat = wa_aufnr-stat.
  ELSE.
* FIN CMS Optimizacion para evitar accesos a BBDD innecesarios.

    CLEAR: p_stat, lv_objnr, lv_stat.
    SELECT SINGLE objnr INTO lv_objnr
      FROM aufk
      WHERE aufnr = p_aufnr.

    IF lv_objnr IS NOT INITIAL.
      SELECT SINGLE stat INTO lv_stat
        FROM jest
        WHERE objnr = lv_objnr
        AND ( stat = 'I0002' or  " Liberada
              stat = 'I0045' )   " Cerrada Técnicamente
        AND inact = ' '.
      IF lv_stat IS NOT INITIAL.
        p_stat = 'X'.
      ELSE.
        CLEAR p_stat.
      ENDIF.

      CLEAR wa_aufnr.
      wa_aufnr-aufnr = p_aufnr.
      wa_aufnr-stat  = p_stat.
      INSERT wa_aufnr INTO TABLE gt_aufnr.

    ELSE.

      CLEAR wa_aufnr.
      wa_aufnr-aufnr = p_aufnr.
      wa_aufnr-stat  = ' '.
      INSERT wa_aufnr INTO TABLE gt_aufnr.

    ENDIF.
  ENDIF. " CMS Optimizacion para evitar accesos a BBDD innecesarios.

ENDFORM.                    " F_STAT_ORD
*&---------------------------------------------------------------------*
*&      Form  F_MOV_DESB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_MAT_FAB_EXPL_AUFNR  text
*      -->P_LS_MAT_FAB_EXPL_CHARG  text
*      -->P_LS_STB_IDNRK  text
*      <--P_LV_DESBL  text
*----------------------------------------------------------------------*
FORM f_mov_desb  USING    p_aufnr
                          p_charg
                          p_idnrk
                 CHANGING p_desbl.

  DATA: ls_ord_cons LIKE LINE OF gt_ord_cons,
        ls_ref_pos  LIKE LINE OF gt_ref_pos.

  CLEAR: p_desbl, ls_ord_cons, ls_ref_pos.
  READ TABLE gt_ord_cons INTO ls_ord_cons WITH KEY aufnr = p_aufnr
                                                   charg = p_charg.
  IF ls_ord_cons IS NOT INITIAL.
** GST - 02/01/2014 ->
*    IF ls_ord_cons-rsnum IS INITIAL.
*      p_desbl = 'R'. " Sin reserva
*    ELSE.
** GST - 02/01/2014 <-
    READ TABLE gt_ref_pos INTO ls_ref_pos WITH KEY rsnum = ls_ord_cons-rsnum
                                                   matnr = p_idnrk.
    IF ls_ref_pos IS NOT INITIAL AND ls_ref_pos-rgekz <> 'X'.
      p_desbl = 'X'.
    ELSE.
      p_desbl = 'B'.
*      ENDIF.
** GST - 02/01/2015 ->
    ENDIF.
*  ELSE.
*    p_desbl = 'R'. " Sin reserva.
** GST - 02/01/2015 <-
  ENDIF.

ENDFORM.                    " F_MOV_DESB
*&---------------------------------------------------------------------*
*&      Form  F_ACT_PORCENTAJES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_act_porcentajes .
  DATA: ls_porc_cons        LIKE gt_porc_cons,
        ls_consumo          LIKE gt_consumo,
        lv_index            LIKE sy-tabix,
        lv_index2           LIKE sy-tabix,
        lv_porc_fsc         TYPE i,
        lv_porc_rst         TYPE i,
        lv_object           TYPE objnum,
        ls_alloc_values_num TYPE bapi1003_alloc_values_num,
        ls_return           TYPE bapiret2.

  DATA: lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab.

  DATA: lv_tot_cant_prod TYPE         zmenge_cons,
        ls_mat_fab_aux   LIKE LINE OF gt_mat_fab,
        lv_porc_prod     TYPE         zmenge_cons.

* GST - 14/01/2016 - ZREC Y PULPER ->
  DATA: ls_mat_fab_2    LIKE LINE OF gt_mat_fab,
        ls_fab_aufnr    LIKE LINE OF gt_fab_aufnr,
        ls_no_resb_cons LIKE LINE OF gt_no_resb_cons.
* GST - 14/01/2016 - ZREC y PULPER <-

  CLEAR: ls_porc_cons, ls_consumo, gt_porc_cons, lv_index.
  REFRESH: gt_porc_cons.

  " 1) Calculamos los porcentajes a transpasar:
  LOOP AT gt_consumo INTO ls_consumo WHERE procesado = 'X'
                                     AND no_resb <> 'X'.
    CLEAR: lv_index, ls_porc_cons.
    READ TABLE gt_porc_cons INTO ls_porc_cons WITH KEY matnr_fab = ls_consumo-matnr_fab
                     charg_fab = ls_consumo-charg_fab.
    lv_index = sy-tabix.
    IF ls_porc_cons IS INITIAL. " Nuevo registro
      ls_porc_cons-matnr_fab = ls_consumo-matnr_fab.
      ls_porc_cons-charg_fab = ls_consumo-charg_fab.
      ls_porc_cons-cant_cons = ls_consumo-comp_menge_cons.

      IF ls_consumo-sortf = 'FSC'.
        ls_porc_cons-cant_fsc = ls_consumo-comp_menge_cons * ls_consumo-porc_fsc / 100. "UDEFINEDES 28.11.2017
      ELSE.
        ls_porc_cons-cant_rst = ls_consumo-comp_menge_cons.
      ENDIF.


* GST - 12/11/2015 - Redondeo porcentaje FSC a la baja ->
*      IF ls_porc_cons-cant_cons IS NOT INITIAL.
*        ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*        ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
*        CLEAR: lv_porc_fsc, lv_porc_rst.
*        lv_porc_fsc = ls_porc_cons-porc_fsc.
*        ls_porc_cons-pnum_fsc = lv_porc_fsc.
*        lv_porc_rst = 100 - lv_porc_fsc.
*        ls_porc_cons-pnum_rst = lv_porc_rst.
*        APPEND ls_porc_cons TO gt_porc_cons.
*      ENDIF.

      IF ls_porc_cons-cant_cons IS NOT INITIAL.
        ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*        ls_porc_cons-porc_fsc = trunc( ls_porc_cons-porc_fsc ).
        ls_porc_cons-porc_fsc = |{ round( val = ls_porc_cons-porc_fsc
                                          dec = 0
                                          mode = 3 ) }|.
        ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
        CLEAR: lv_porc_fsc, lv_porc_rst.
        lv_porc_fsc = trunc( ls_porc_cons-porc_fsc ).
        ls_porc_cons-pnum_fsc = lv_porc_fsc.
        lv_porc_rst = 100 - lv_porc_fsc.
        ls_porc_cons-pnum_rst = lv_porc_rst.
        APPEND ls_porc_cons TO gt_porc_cons.
      ENDIF.

* GST - 12/11/2015 - Redondeo porcentaje FSC a la baja <-

    ELSE.
      ls_porc_cons-cant_cons = ls_porc_cons-cant_cons + ls_consumo-comp_menge_cons.

      IF ls_consumo-sortf = 'FSC'.
        ls_porc_cons-cant_fsc = ls_porc_cons-cant_fsc + ( ls_consumo-comp_menge_cons * ls_consumo-porc_fsc / 100 ). "UDEFINEDES 28.11.2017.
      ELSE.
        ls_porc_cons-cant_rst = ls_porc_cons-cant_rst + ls_consumo-comp_menge_cons.
      ENDIF.

* GST - 12/11/2015 - Redondeo porcentaje FSC a la baja ->
*      IF ls_porc_cons-cant_cons IS NOT INITIAL.
*        ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*        ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
*        CLEAR: lv_porc_fsc, lv_porc_rst.
*        lv_porc_fsc = ls_porc_cons-porc_fsc.
*        ls_porc_cons-pnum_fsc = lv_porc_fsc.
*        lv_porc_rst = 100 - lv_porc_fsc.
*        ls_porc_cons-pnum_rst = lv_porc_rst.
*        MODIFY gt_porc_cons FROM ls_porc_cons INDEX lv_index.
*      ENDIF.

      IF ls_porc_cons-cant_cons IS NOT INITIAL.
        ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*        ls_porc_cons-porc_fsc = trunc( ls_porc_cons-porc_fsc ).
        ls_porc_cons-porc_fsc = |{ round( val = ls_porc_cons-porc_fsc
                                          dec = 0
                                          mode = 3 ) }|.
        ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
        CLEAR: lv_porc_fsc, lv_porc_rst.
        lv_porc_fsc = trunc( ls_porc_cons-porc_fsc ).
        ls_porc_cons-pnum_fsc = lv_porc_fsc.
        lv_porc_rst = 100 - lv_porc_fsc.
        ls_porc_cons-pnum_rst = lv_porc_rst.
        MODIFY gt_porc_cons FROM ls_porc_cons INDEX lv_index.
      ENDIF.

* GST - 12/11/2015 - Redondeo porcentaje FSC a la baja <-

    ENDIF.
  ENDLOOP.


* GST - 14/01/2016 - ZREC y PULPER ->

* Añadir a la tabla de consumi los materiales que no están en la resb:

  LOOP AT gt_mat_fab INTO ls_mat_fab_2.

* Leemos el total fabricado por orden:
    CLEAR ls_fab_aufnr.
    READ TABLE gt_fab_aufnr INTO ls_fab_aufnr
               WITH KEY aufnr = ls_mat_fab_2-aufnr.

    IF ls_fab_aufnr IS NOT INITIAL.

* Repartimos los materiales que no están en la resb entre los distintos
* materiales/lotes fabricados par hacer el cálculo del FSC:

      LOOP AT gt_no_resb_cons INTO ls_no_resb_cons
        WHERE aufnr = ls_mat_fab_2-aufnr.

        CLEAR: lv_index, ls_porc_cons.
        READ TABLE gt_porc_cons INTO ls_porc_cons WITH KEY matnr_fab = ls_mat_fab_2-matnr
                               charg_fab = ls_mat_fab_2-charg.

        lv_index = sy-tabix.
        IF ls_porc_cons IS INITIAL. " Nuevo registro
          ls_porc_cons-matnr_fab = ls_mat_fab_2-matnr.
          ls_porc_cons-charg_fab = ls_mat_fab_2-charg.

          IF ls_fab_aufnr-menge IS NOT INITIAL.
            ls_porc_cons-cant_cons = ( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons.
          ELSE.
            CLEAR ls_porc_cons-cant_cons.
          ENDIF.

          IF ls_no_resb_cons-sortf = 'FSC'.
            ls_porc_cons-cant_fsc = ( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons * ls_no_resb_cons-fsc / 100. "UDEFINEDES 28.11.2017
          ELSE.
            ls_porc_cons-cant_rst = ( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons.
          ENDIF.

          IF ls_porc_cons-cant_cons IS NOT INITIAL.
            ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*            ls_porc_cons-porc_fsc = trunc( ls_porc_cons-porc_fsc ).
            ls_porc_cons-porc_fsc = |{ round( val = ls_porc_cons-porc_fsc
                                              dec = 0
                                              mode = 3 ) }|.
            ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
            CLEAR: lv_porc_fsc, lv_porc_rst.
            lv_porc_fsc = trunc( ls_porc_cons-porc_fsc ).
            ls_porc_cons-pnum_fsc = lv_porc_fsc.
            lv_porc_rst = 100 - lv_porc_fsc.
            ls_porc_cons-pnum_rst = lv_porc_rst.
            APPEND ls_porc_cons TO gt_porc_cons.
          ENDIF.

        ELSE.
          IF ls_fab_aufnr-menge IS NOT INITIAL.
            ls_porc_cons-cant_cons = ls_porc_cons-cant_cons +
( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons.
          ENDIF.

          IF ls_no_resb_cons-sortf = 'FSC'.
            ls_porc_cons-cant_fsc = ls_porc_cons-cant_fsc +
( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons * ls_no_resb_cons-fsc / 100.
          ELSE.
            ls_porc_cons-cant_rst = ls_porc_cons-cant_rst +
( ls_mat_fab_2-menge / ls_fab_aufnr-menge ) * ls_no_resb_cons-menge_cons.
          ENDIF.

          IF ls_porc_cons-cant_cons IS NOT INITIAL.
            ls_porc_cons-porc_fsc = ( ls_porc_cons-cant_fsc / ls_porc_cons-cant_cons ) * 100.
*            ls_porc_cons-porc_fsc = trunc( ls_porc_cons-porc_fsc ).
            ls_porc_cons-porc_fsc = |{ round( val = ls_porc_cons-porc_fsc
                                              dec = 0
                                              mode = 3 ) }|.
            ls_porc_cons-porc_rst = 100 - ls_porc_cons-porc_fsc.
            CLEAR: lv_porc_fsc, lv_porc_rst.
            lv_porc_fsc = trunc( ls_porc_cons-porc_fsc ).
            ls_porc_cons-pnum_fsc = lv_porc_fsc.
            lv_porc_rst = 100 - lv_porc_fsc.
            ls_porc_cons-pnum_rst = lv_porc_rst.
            MODIFY gt_porc_cons FROM ls_porc_cons INDEX lv_index.
          ENDIF.
        ENDIF.

      ENDLOOP.
    ENDIF.
  ENDLOOP.

* GST - 14/01/2016 - ZREC y PULPER <-

* GST - 27/05/2015 ->
  DATA: ls_mat_fab LIKE LINE OF gt_mat_fab,
        ls_mat_res LIKE LINE OF gt_mat_res.

  DATA: ls_ztpp0004 TYPE ztpp0004,
        lv_porc_res TYPE zporc_humedad,
        lv_cant_res TYPE zmenge_cons.

* INI UDEFINEDES 27.11.2017
* No se va a tener en cuenta a partir de ahora el %humedad
* en el calculo del FSC
*	Se obviará el cálculo de la cantidad total de kg de residuos
* (movimientos 531/532) y el ajuste conforme al grado de humedad definido en la tabla ZTPP0004...

* Recuperamos % Humedad:
*  CLEAR: ls_ztpp0004, lv_porc_res.
*  SELECT SINGLE * INTO ls_ztpp0004
*    FROM ztpp0004
** GST - 07/07/2016 ->
*    WHERE werks = p_werks
** GST - 07/07/2016 <-
*    AND fec_ini <= sy-datum
*    AND fec_fin >= sy-datum.
*
** Porcentaje de residuo que me queda sera 100% - % Humedad:
*  IF ls_ztpp0004 IS NOT INITIAL.
*    lv_porc_res = 100 - ls_ztpp0004-porc_humedad.
*  ELSE.
*    lv_porc_res = 100.
*  ENDIF.
*
** Nuevo cálculo %FSC:
*  LOOP AT gt_porc_cons INTO ls_porc_cons.
*    lv_index = sy-tabix.
*    IF ls_porc_cons-cant_fsc IS NOT INITIAL.
*
*      " Leemos la cantidad total producida:
*      CLEAR ls_mat_fab.
*      LOOP AT gt_mat_fab INTO ls_mat_fab WHERE matnr = ls_porc_cons-matnr_fab
*                                         AND charg = ls_porc_cons-charg_fab.
*        ls_porc_cons-cant_prod = ls_porc_cons-cant_prod + ls_mat_fab-menge.
*
*        " Leemos la cantidad de residuos:
*        CLEAR ls_mat_res.
*        LOOP AT gt_mat_res INTO ls_mat_res WHERE aufnr = ls_mat_fab-aufnr.
*          ls_porc_cons-cant_res = ls_porc_cons-cant_res + ls_mat_res-menge.
*        ENDLOOP.
*      ENDLOOP.
*
** GST - 09/06/2015 ->
*      " Repartir el residuo en función cantidad producida por orden:
*      CLEAR: lv_tot_cant_prod, ls_mat_fab_aux.
*      LOOP AT gt_mat_fab INTO ls_mat_fab_aux WHERE aufnr = ls_mat_fab-aufnr.
*        lv_tot_cant_prod = lv_tot_cant_prod + ls_mat_fab_aux-menge.
*      ENDLOOP.
** GST - 09/06/2015 <-
*
*      " Cálculamos nuevo porcentaje:
**        ls_porc_cons-porc_fsc_2 = ( ( ls_porc_cons-cant_fsc - ls_porc_cons-cant_res ) / ls_porc_cons-cant_prod ) * 100.
*      CLEAR: lv_cant_res, lv_porc_prod.
** GST - 09/06/2015 ->
*      lv_porc_prod = ls_porc_cons-cant_prod / lv_tot_cant_prod.
*      ls_porc_cons-cant_res = ls_porc_cons-cant_res * lv_porc_prod.
** GST - 09/06/2015 <-
*      lv_cant_res = ls_porc_cons-cant_res * ( lv_porc_res / 100 ).
*
** GST - 28/01/2016 ->
**      IF ls_porc_cons-cant_fsc > lv_cant_res AND ls_porc_cons-cant_prod IS NOT INITIAL.
**        ls_porc_cons-porc_fsc_2 = ( ( ls_porc_cons-cant_fsc -  lv_cant_res ) / ls_porc_cons-cant_prod ) * 100.
*
*      IF ls_porc_cons-cant_fsc > lv_cant_res AND ls_porc_cons-cant_cons IS NOT INITIAL.
*        ls_porc_cons-porc_fsc_2 = ( ( ls_porc_cons-cant_fsc -  lv_cant_res ) / ls_porc_cons-cant_cons ) * 100.
*
** GST - 28/01/2016 <-
*      ELSE.
*        ls_porc_cons-porc_fsc_2 = 0.
*      ENDIF.
*      CLEAR: lv_porc_fsc.
** GST - 12/11/2015 - Redondeo porcentaje FSC a la baja ->
**        lv_porc_fsc = ls_porc_cons-porc_fsc_2.
*      lv_porc_fsc = trunc( ls_porc_cons-porc_fsc_2 ).
** GST - 12/11/2015 - Redondeo porcentaje FSC a la baja <-
*      ls_porc_cons-pnum_fsc_2 = lv_porc_fsc.
*      MODIFY gt_porc_cons FROM ls_porc_cons INDEX lv_index.
*    ENDIF.
*  ENDLOOP.
*
** GST - 27/05/2015 <-
* FIN UDEFINEDES 27.11.2017

  " 2) Transpasar el % FSC a la característica:
  LOOP AT gt_porc_cons INTO ls_porc_cons.
    CLEAR: lv_object, ls_alloc_values_num, ls_return.
    CLEAR: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr.
    REFRESH: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr.
    REFRESH: lt_return.

    CONCATENATE ls_porc_cons-matnr_fab ls_porc_cons-charg_fab INTO lv_object.

* GST - 04/03/2015 ->

    CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
      EXPORTING
        objectkey       = lv_object
        objecttable     = 'MCH1'
        classnum        = 'Z_ROLLO'
        classtype       = '023'
*       KEYDATE         = SY-DATUM
*       UNVALUATED_CHARS       = ' '
*       LANGUAGE        = SY-LANGU
* IMPORTING
*       STATUS          =
*       STANDARDCLASS   =
      TABLES
        allocvaluesnum  = lt_alloc_values_num
        allocvalueschar = lt_alloc_values_char
        allocvaluescurr = lt_alloc_values_curr
        return          = lt_return.

    REFRESH: lt_return.
    CLEAR: lt_return, ls_alloc_values_num, lv_index2.

    READ TABLE lt_alloc_values_num INTO ls_alloc_values_num
                                  WITH KEY charact = 'Z_FSC_PORCENTAJE'.
    lv_index2 = sy-tabix.

    IF ls_alloc_values_num IS INITIAL.
      ls_alloc_values_num-charact = 'Z_FSC_PORCENTAJE'.
* GST - 27/05/2015 ->
*      IF ls_porc_cons-pnum_fsc = 100.
*        ls_alloc_values_num-value_from = 99.
*      ELSE.
*        ls_alloc_values_num-value_from = ls_porc_cons-pnum_fsc.
*      ENDIF.

*      IF ls_porc_cons-pnum_fsc_2 >= 100.
*        ls_alloc_values_num-value_from = 99.
*      ELSE.
      ls_alloc_values_num-value_from = ls_porc_cons-pnum_fsc. "UDEFINEDES 28.11.2017
*      ENDIF.

      IF ls_alloc_values_num-value_from IS NOT INITIAL.
* GST - 27/05/2015 <-
        APPEND ls_alloc_values_num TO lt_alloc_values_num.
* GST - 27/05/2015 ->
      ENDIF.
* GST - 27/05/2015 <-
*    ELSEIF ls_alloc_values_num IS NOT INITIAL AND ls_alloc_values_num-value_from IS INITIAL.
*      ls_alloc_values_num-value_from = ls_porc_cons-pnum_fsc.
*      MODIFY lt_alloc_values_num FROM ls_alloc_values_num INDEX lv_index2.
    ENDIF.

*    ls_alloc_values_num-charact = 'Z_FSC_PORCENTAJE'.
*    ls_alloc_values_num-value_from = ls_porc_cons-pnum_fsc.
*    APPEND ls_alloc_values_num TO lt_alloc_values_num.

* GST - 04/03/2015 <-

    CALL FUNCTION 'BAPI_OBJCL_CHANGE'
      EXPORTING
        objectkey          = lv_object
        objecttable        = 'MCH1'
        classnum           = 'Z_ROLLO'
        classtype          = '023'
*       STATUS             = '1'
*       STANDARDCLASS      =
*       CHANGENUMBER       =
*       KEYDATE            = SY-DATUM
*       NO_DEFAULT_VALUES  = ' '
*   IMPORTING
*       CLASSIF_STATUS     =
      TABLES
        allocvaluesnumnew  = lt_alloc_values_num
        allocvaluescharnew = lt_alloc_values_char
        allocvaluescurrnew = lt_alloc_values_curr
        return             = lt_return.


    CLEAR ls_return.
    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
    IF ls_return IS NOT INITIAL. " Error act. característica
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
*       IMPORTING
*         RETURN        =
        .

      PERFORM f_act_consumos USING ls_return
                                   ls_porc_cons-matnr_fab
                                   ls_porc_cons-charg_fab
* GST - 27/05/2015 ->
                                   ls_porc_cons-pnum_fsc.
*                                   ls_porc_cons-pnum_fsc_2.
* GST - 27/05/2015 <-

    ELSE. " Se ha act. característica

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      PERFORM f_act_consumos USING ls_return
                                   ls_porc_cons-matnr_fab
                                   ls_porc_cons-charg_fab
* GST - 27/05/2015 ->
                                   ls_porc_cons-pnum_fsc.
*                                   ls_porc_cons-pnum_fsc_2.
* GST - 27/05/2015 <-

    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_ACT_PORCENTAJES
*&---------------------------------------------------------------------*
*&      Form  F_ACT_CONSUMOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_RETURN  text
*----------------------------------------------------------------------*
FORM f_act_consumos  USING    ps_return TYPE bapiret2
                              p_matnr
                              p_charg
                              p_fsc.

  DATA: BEGIN OF lt_consumo_aux OCCURS 0.
          INCLUDE STRUCTURE zstpp_consumo_pulper.
  DATA: END OF lt_consumo_aux.

  DATA: ls_consumo_aux LIKE LINE OF gt_consumo,
        ls_consumo     LIKE LINE OF gt_consumo,
        lv_index       LIKE         sy-tabix.

  CLEAR: ls_consumo_aux, gt_consumo_aux.
  REFRESH: gt_consumo_aux.

  " 1) Recorrer la tabla de consumos para saber qué líneas hay que
  " actualizar (llevarlas a una tabla auxiliar):

  LOOP AT gt_consumo INTO ls_consumo_aux WHERE matnr_fab = p_matnr
                                         AND   charg_fab = p_charg
                                         AND procesado = 'X'
                                         AND no_resb <> 'X'.

    ls_consumo_aux-porc_fsc = p_fsc.
    IF ps_return-type = 'E'.
      ls_consumo_aux-icono_act = '@0A@'. " Semáforo rojo
      ls_consumo_aux-tipo_act = ps_return-type.
      ls_consumo_aux-mensaje_act = ps_return-message.
    ELSE.
      ls_consumo_aux-icono_act = '@08@'. " Semáforo verde
      ls_consumo_aux-tipo_act = 'S'.
      ls_consumo_aux-mensaje_act = 'Característica actualizada'.
    ENDIF.

    APPEND ls_consumo_aux TO gt_consumo_aux.

  ENDLOOP.

  " 2) Actualizar la tabla gt_consumos: porcentaje fsc, icono,
  " tipo y mensaje de actualización de la característica:

  LOOP AT gt_consumo_aux INTO ls_consumo_aux.
    CLEAR: ls_consumo, lv_index.
    READ TABLE gt_consumo INTO ls_consumo WITH KEY matnr_fab = ls_consumo_aux-matnr_fab
                  charg_fab = ls_consumo_aux-charg_fab
                  aufnr = ls_consumo_aux-aufnr
                  comp_cons = ls_consumo_aux-comp_cons
      comp_charg_cons = ls_consumo_aux-comp_charg_cons
      procesado = 'X'.
    lv_index = sy-tabix.

    IF ls_consumo IS NOT INITIAL AND ls_consumo-no_resb <> 'X'.
      ls_consumo-porc_fsc = ls_consumo_aux-porc_fsc.
      ls_consumo-icono_act = ls_consumo_aux-icono_act.
      ls_consumo-tipo_act = ls_consumo_aux-tipo_act.
      ls_consumo-mensaje_act = ls_consumo_aux-mensaje_act.
      MODIFY gt_consumo FROM ls_consumo INDEX lv_index.
    ENDIF.
  ENDLOOP.

* INI UDEFINEDES 28.11.2017
  LOOP AT gt_consumo WHERE matnr_fab = p_matnr
                       AND charg_fab = space.

    ls_consumo-porc_fsc = 0.
    MODIFY gt_consumo FROM ls_consumo INDEX sy-tabix.
  ENDLOOP.
* FIN UDEFINEDES

ENDFORM.                    " F_ACT_CONSUMOS
*&---------------------------------------------------------------------*
*&      Form  F_GRABAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_grabar_log .

*  DATA: ls_consumo LIKE LINE OF gt_consumo.
*
*  LOOP AT gt_consumo INTO ls_consumo.
*
*    WRITE:/ ls_consumo-matnr_fab,
*            ls_consumo-desc_matnr_fab,
*            ls_consumo-charg_fab,
*            ls_consumo-menge_fab,
*            ls_consumo-meins_fab,
*            ls_consumo-aufnr,
*            ls_consumo-comp_cons,
*            ls_consumo-desc_comp_cons,
*            ls_consumo-sortf,
*            ls_consumo-comp_charg_cons,
*            ls_consumo-comp_menge_cons,
*            ls_consumo-comp_meins_cons,
*            ls_consumo-tipo,
*            20 ls_consumo-mensaje,
*            ls_consumo-porc_fsc,
*            ls_consumo-tipo_act,
*            20 ls_consumo-mensaje_act.
*  ENDLOOP.

  DATA: t_variant TYPE disvariant.


* Variante ALV
  CLEAR t_variant.
  t_variant-report = sy-repid.

  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = 'U'
    CHANGING
      cs_variant = t_variant
    EXCEPTIONS
      not_found  = 2.
*
* Genero las Columnas
  PERFORM col_alv.


* Llamo a la Función que visualiza el ALV
  CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
    EXPORTING
*     i_structure_name = i_structure_name
      it_fieldcat = gt_fieldcat_ant
      i_save      = 'U'
      is_variant  = t_variant
    TABLES
      t_outtab    = gt_consumo.

ENDFORM.                    " F_GRABAR_LOG
*&---------------------------------------------------------------------*
*&      Form  F_CALC_REPARTOS_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_calc_repartos_2 .

  DATA: ls_ord_cons_2  LIKE gt_ord_cons_2,
        ls_consumo     LIKE gt_consumo,
        ls_mat_cons    LIKE gt_mat_cons,
        lv_no_resb(1),
        ls_mat_no_resb LIKE gt_mat_no_resb,
        lv_index       LIKE sy-tabix,
        lv_index_2     LIKE sy-tabix,
        lv_menge_cons  TYPE zmenge_cons,
        ls_ref_pos     LIKE gt_ref_pos,
        lv_aufnr       TYPE aufnr,
        lv_charg       TYPE charg_d,
        lv_atinn       TYPE atinn,
        lv_atflv       TYPE atflv.

  CLEAR: gt_mat_no_resb.
  REFRESH: gt_mat_no_resb.

* INI UDEFINEDES 28.11.2017 Nuevo calculo FSC
  SELECT SINGLE atinn INTO lv_atinn FROM cabn WHERE atnam = 'Z_FSC_PORCENTAJE'.
* FIN UDEFINEDES

* 1) Nos quedamos con los materiales a repartir:
  LOOP AT gt_mat_cons INTO ls_mat_cons WHERE procesado <> 'X'.
    CLEAR ls_ref_pos.
    READ TABLE gt_ref_pos INTO ls_ref_pos WITH KEY matnr = ls_mat_cons-matnr.
    IF ls_ref_pos IS INITIAL.
      MOVE-CORRESPONDING ls_mat_cons TO ls_mat_no_resb.
      APPEND ls_mat_no_resb TO gt_mat_no_resb.
    ENDIF.
  ENDLOOP.

* 2) Cálculo de repartos:

  CLEAR: ls_ord_cons_2.
  LOOP AT gt_ord_cons_2 INTO ls_ord_cons_2.
    CLEAR ls_consumo.
    ls_consumo-aufnr = ls_ord_cons_2-aufnr.
*    ls_consumo-charg_fab = ls_ord_cons_2-charg.
    ls_consumo-icono = '@09@'.
    ls_consumo-no_resb = 'X'.
    IF gv_tot_fab NE 0.
      ls_consumo-comp_porcentaje = ( ls_ord_cons_2-menge / gv_tot_fab ) * 100.
    ENDIF.

    " 2) Cálculo las proporciones de los materiales que quedan por repartir:
    CLEAR lv_index.
    LOOP AT gt_mat_no_resb INTO ls_mat_no_resb.
      lv_index = sy-tabix.
      ls_consumo-comp_cons = ls_mat_no_resb-matnr.
      ls_consumo-desc_comp_cons = ls_mat_no_resb-maktx_cons.
      ls_consumo-comp_charg_cons = ls_mat_no_resb-charg.
      IF gv_tot_fab IS NOT INITIAL.
        ls_consumo-comp_menge_cons = ( ls_ord_cons_2-menge / gv_tot_fab ) * ls_mat_no_resb-menge.
        ls_consumo-comp_meins_cons = ls_mat_no_resb-meins.
      ENDIF.

      ls_mat_no_resb-menge_cons = ls_mat_no_resb-menge_cons + ls_consumo-comp_menge_cons.
      MODIFY gt_mat_no_resb FROM ls_mat_no_resb INDEX lv_index.

* INI UDEFINEDES 28.11.2017 Nuevo calculo FSC
      SELECT SINGLE atflv INTO lv_atflv FROM ausp
        WHERE objek = ls_mat_no_resb-matnr AND atinn = lv_atinn.

      ls_consumo-porc_fsc = lv_atflv.
      APPEND ls_consumo TO gt_consumo.
    ENDLOOP.

    CLEAR: lv_aufnr, lv_charg.
    lv_aufnr = ls_ord_cons_2-aufnr.

    " 3) Eliminar los picos:
    AT LAST.
      CLEAR: lv_index, lv_index_2.
      LOOP AT gt_mat_no_resb INTO ls_mat_no_resb.
        lv_index = sy-tabix.
        CLEAR ls_consumo.
        READ TABLE gt_consumo INTO ls_consumo WITH KEY aufnr = lv_aufnr
                                                    charg_fab = lv_charg
                                        comp_cons = ls_mat_no_resb-matnr
                                  comp_charg_cons = ls_mat_no_resb-charg
                                  no_resb = 'X'.
        lv_index_2 = sy-tabix.
        IF ls_consumo IS NOT INITIAL.
          ls_consumo-comp_menge_cons = ls_consumo-comp_menge_cons + ( ls_mat_no_resb-menge - ls_mat_no_resb-menge_cons ).
          MODIFY gt_consumo FROM ls_consumo INDEX lv_index_2.
        ENDIF.
      ENDLOOP.
    ENDAT.
  ENDLOOP.

*  " Eliminar los picos:
*
*  SORT gt_mat_no_resb by matnr ascending
*                         charg ascending.
*
*  loop at gt_mat_no_resb into ls_mat_no_resb.
*    clear: lv_menge_cons, lv_index.
*    loop at gt_consumo into ls_consumo where comp_cons = ls_mat_no_resb-matnr
*                                       and   comp_charg_cons = ls_mat_no_resb-charg
*                                       and   no_resb = 'X'.
*    lv_index = sy-tabix.
*    lv_menge_cons = lv_menge_cons + ls_consumo-comp_menge_cons.
*    if lv_menge_cons = ls_mat_no_resb-menge_cons.
*      ls_consumo-comp_menge_cons = ls_consumo-comp_menge_cons + ( ls_mat_no_resb-menge - ls_mat_no_resb-menge_cons ).
*      modify gt_consumo from ls_consumo index lv_index.
*    endif.
*
*    endloop.
*  endloop.


ENDFORM.                    " F_CALC_REPARTOS_2
*&---------------------------------------------------------------------*
*&      Form  F_MAT_RESB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_ORD_CONS_2_AUFNR  text
*      -->P_LS_ORD_CONS_2_CHARG  text
*      -->P_LS_MAT_CONS_MATNR  text
*      <--P_LV_NO_RESB  text
*----------------------------------------------------------------------*
FORM f_mat_resb  USING    p_aufnr
                          p_charg
                          p_matnr
                 CHANGING p_no_resb.

  DATA: ls_ord_cons LIKE LINE OF gt_ord_cons,
        ls_ref_pos  LIKE LINE OF gt_ref_pos.

  CLEAR: p_no_resb, ls_ord_cons, ls_ref_pos.
  READ TABLE gt_ord_cons INTO ls_ord_cons WITH KEY aufnr = p_aufnr
                                                   charg = p_charg.

  IF ls_ord_cons IS NOT INITIAL.
    READ TABLE gt_ref_pos INTO ls_ref_pos WITH KEY rsnum = ls_ord_cons-rsnum
                                                  matnr = p_matnr.

    IF ls_ref_pos IS NOT INITIAL AND ls_ref_pos-rgekz <> 'X'.
      CLEAR p_no_resb.
    ELSEIF ls_ref_pos IS NOT INITIAL AND ls_ref_pos-rgekz = 'X'.
      CLEAR p_no_resb.
    ELSE.
      p_no_resb = 'X'.
    ENDIF.

  ELSE.
    p_no_resb = 'X'.
  ENDIF.


ENDFORM.                    " F_MAT_RESB

*&---------------------------------------------------------------------*
*&      Form  MOV_CONSUMO_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LS_CONSUMO  text
*----------------------------------------------------------------------*
FORM mov_consumo_2 TABLES lt_return STRUCTURE bapiret2
                   USING ps_ord_cons LIKE LINE OF gt_ord_cons_2
                   CHANGING lc_error
                            lv_materialdocument
                            lv_matdocumentyear.

  DATA: lt_goodsmvt_item TYPE TABLE OF bapi2017_gm_item_create.

  DATA: ls_goodsmvt_header TYPE         bapi2017_gm_head_01,
        ls_goodsmvt_code   TYPE         bapi2017_gm_code,
        ls_goodsmvt_item   TYPE         bapi2017_gm_item_create,
        ls_return          TYPE         bapiret2,
        ls_ref_pos         LIKE         gt_ref_pos,
        ls_consumo         LIKE LINE OF gt_consumo,
        ls_consumo_aux     LIKE LINE OF gt_consumo.

* GST - 14/01/2016 - ZREC y PULPER ->
  DATA: ls_no_resb_cons LIKE LINE OF gt_no_resb_cons.
  DATA: lv_index TYPE sy-tabix.
  DATA: lv_mtart TYPE mtart.
* GST - 14/01/2016 - ZREC y PULPER <-

  DATA: lv_atflv TYPE atflv,
        lv_atinn TYPE atinn. "UDEFINEDES 27.11.2017

  REFRESH: lt_goodsmvt_item, lt_return.
* GST - 22/10/2014 ->
* Resolver DUMP TABLE_FREE_IN_LOOP:
  CLEAR: gt_consumo_aux, ls_consumo_aux.
  REFRESH: gt_consumo_aux.
* GST - 22/10/2014 <-

* INI UDEFINEDES 27.11.2017
* Nuevo calculo FSC, seleccionamos cod.caracteristica Z_FSC_PROCENTAJE
  SELECT SINGLE atinn INTO lv_atinn FROM cabn WHERE atnam = 'Z_FSC_PORCENTAJE'.
* FIN UDEFINEDES


  " 2) Tipo de movimiento:
  CLEAR ls_goodsmvt_code.
  ls_goodsmvt_code-gm_code       = '06'.

  " 3) Posiciones:
  LOOP AT gt_consumo INTO ls_consumo WHERE aufnr = ps_ord_cons-aufnr
*                                     AND charg_fab = ps_ord_cons-charg
                                     AND procesado <> 'X'
                                     AND no_resb = 'X'.
    CLEAR: ls_goodsmvt_item.
* GST - 22/10/2014 ->
    CLEAR: ls_consumo_aux.
* GST - 22/10/2014 <-
    ls_goodsmvt_item-material = ls_consumo-comp_cons.
    ls_goodsmvt_item-plant = p_werks. "'3000'.
    ls_goodsmvt_item-stge_loc = p_lgort2. "'4002'.
    ls_goodsmvt_item-batch = ls_consumo-comp_charg_cons.
    ls_goodsmvt_item-move_type = '261'.
    ls_goodsmvt_item-stck_type = ' '. " Libre utilización
    ls_goodsmvt_item-entry_qnt = ls_consumo-comp_menge_cons.
    ls_goodsmvt_item-entry_uom = ls_consumo-comp_meins_cons.
*    ls_goodsmvt_item-reserv_no = ps_ord_cons-rsnum.
*    CLEAR ls_ref_pos.
*    READ TABLE gt_ref_pos INTO ls_ref_pos WITH KEY rsnum = ps_ord_cons-rsnum
*                                                   matnr = ls_consumo-comp_cons.
*    IF ls_ref_pos IS NOT INITIAL.
*      ls_goodsmvt_item-res_item = ls_ref_pos-rspos.
*    ENDIF.
    ls_goodsmvt_item-orderid = ls_consumo-aufnr.
    APPEND ls_goodsmvt_item TO lt_goodsmvt_item.
* GST - 22/10/2014 ->
    ls_consumo_aux = ls_consumo.
    APPEND ls_consumo_aux TO gt_consumo_aux.
* GST - 22/10/2014 <-
  ENDLOOP.

* uDefine Ticket 47148 se cambia la fecha de contabilizacion para evitar el problema
* de consumos antes de existencias de material
  " 1) Cabecera:
  CLEAR ls_goodsmvt_header.
  ls_goodsmvt_header-pstng_date  = sy-datum.
  ls_goodsmvt_header-doc_date    = sy-datum.
  ls_goodsmvt_header-header_txt  = text-003.

  IF lt_goodsmvt_item[] IS NOT INITIAL.

    " 4) Creamos documento de material: Llamada a la BAPI
    CLEAR: lv_materialdocument, lv_matdocumentyear.
    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = ls_goodsmvt_header
        goodsmvt_code    = ls_goodsmvt_code
      IMPORTING
        materialdocument = lv_materialdocument
        matdocumentyear  = lv_matdocumentyear
      TABLES
        goodsmvt_item    = lt_goodsmvt_item
        return           = lt_return.

    CLEAR: ls_return, lc_error.
    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
    IF NOT ls_return IS INITIAL.
      IF ( ls_return-number = 897 AND ls_return-id = 'M3' ) OR
         ( ls_return-number = 682 AND ls_return-id = 'M3' ) OR
         ( ls_return-number = 024 AND ls_return-id = 'M3' )."Materia bloqueado
        lc_error = 'B'.
      ELSE.
        lc_error = 'X'.
      ENDIF.
    ENDIF.

  ELSE.
    lc_error = 'D'.
  ENDIF.

* GST - 14/01/2016 - ZREC y BOBINA ->
  IF lc_error <> 'X' AND lc_error <> 'D'.
    LOOP AT lt_goodsmvt_item INTO ls_goodsmvt_item.

      CLEAR: ls_no_resb_cons, lv_index.
      READ TABLE gt_no_resb_cons INTO ls_no_resb_cons
                 WITH KEY aufnr = ls_goodsmvt_item-orderid
                          matnr_cons = ls_goodsmvt_item-material.
      lv_index = sy-tabix.
      IF ls_no_resb_cons IS INITIAL.
        ls_no_resb_cons-aufnr = ls_goodsmvt_item-orderid.
        ls_no_resb_cons-matnr_cons = ls_goodsmvt_item-material.
        ls_no_resb_cons-menge_cons = ls_goodsmvt_item-entry_qnt.
        ls_no_resb_cons-meins_cons = ls_goodsmvt_item-entry_uom.

* INI UDEFINEDES 27.11.2017
* Nuevo calculo recorte, ahora chequeamos caracteristica de material
* para ver si aplica FSC...
        SELECT SINGLE atflv INTO lv_atflv FROM ausp
          WHERE objek = ls_no_resb_cons-matnr_cons AND atinn = lv_atinn.
*        CLEAR lv_mtart.
*        SELECT SINGLE mtart INTO lv_mtart
*          FROM mara
*          WHERE matnr = ls_no_resb_cons-matnr_cons.
*
*        IF lv_mtart = 'ZREC' OR
*          ls_no_resb_cons-matnr_cons = '000000000002001764'.
        IF sy-subrc = 0.
          ls_no_resb_cons-sortf = 'FSC'.
          ls_no_resb_cons-fsc = lv_atflv.
        ELSE.
          ls_no_resb_cons-sortf = 'RC'.
          ls_no_resb_cons-fsc = 0.
        ENDIF.

        APPEND ls_no_resb_cons TO gt_no_resb_cons.
      ELSE.

        ls_no_resb_cons-menge_cons = ls_no_resb_cons-menge_cons +
                                     ls_goodsmvt_item-entry_qnt.

        MODIFY gt_no_resb_cons FROM ls_no_resb_cons INDEX lv_index.

      ENDIF.

    ENDLOOP.
  ENDIF.

* GST - 14/01/2016 - ZREC y BOBINA <-


ENDFORM.                    " MOV_CONSUMO_2
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  COL_ALV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM col_alv .

  DATA: ls_fcat TYPE slis_fieldcat_alv.
  DATA: lv_tabix TYPE sytabix.


  REFRESH: gt_fieldcat_ant.

* Pasar tabla interna al formato del fieldcat
  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = sy-repid
      i_internal_tabname     = 'GT_CONSUMO'
      i_inclname             = sy-repid
      i_bypassing_buffer     = 'X'
    CHANGING
      ct_fieldcat            = gt_fieldcat_ant
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

** Pasar el anterior fieldcat al formato del nuevo
*  CALL FUNCTION 'LVC_TRANSFER_FROM_SLIS'
*    EXPORTING
*      it_fieldcat_alv = gt_fieldcat_ant
*    IMPORTING
*      et_fieldcat_lvc = gt_fieldcat
*    TABLES
*      it_data         = gt_consumo
*    EXCEPTIONS
*      it_data_missing = 1
*      OTHERS          = 2.

** Recorremos el catálogo de campos modificandolo

  LOOP AT gt_fieldcat_ant INTO ls_fcat.
    lv_tabix = sy-tabix.
    CASE ls_fcat-fieldname.
*      WHEN 'VBELN'.
*        ls_fcat-seltext   = text-t01.
*        ls_fcat-scrtext_l = text-t01.
*        ls_fcat-scrtext_m = text-t01.
*        ls_fcat-scrtext_s = text-t01.
*        ls_fcat-reptext   = text-t01.
*        ls_fcat-hotspot = 'X'.
*        MODIFY gt_fieldcat FROM ls_fcat INDEX lv_tabix.
      WHEN 'COMP_MENGE_FAB'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'COMP_MEINS_FAB'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'COMP_MENGE_TOT'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'COMP_MEINS_TOT'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'COMP_PORCENTAJE'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'ICON'.
*        ls_fcat-seltext   = text-t01.
        ls_fcat-seltext_l = text-t01.
        ls_fcat-seltext_m = text-t01.
        ls_fcat-seltext_s = text-t01.
        ls_fcat-reptext_ddic   = text-t01.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'TYPE_RET'.
*        ls_fcat-seltext   = text-t02.
        ls_fcat-seltext_l = text-t02.
        ls_fcat-seltext_m = text-t02.
        ls_fcat-seltext_s = text-t02.
        ls_fcat-reptext_ddic   = text-t02.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'MSG_RET'.
*        ls_fcat-seltext   = text-t03.
        ls_fcat-seltext_l = text-t03.
        ls_fcat-seltext_m  = text-t03.
        ls_fcat-seltext_s = text-t03.
        ls_fcat-reptext_ddic   = text-t03.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
      WHEN 'NO_RESB'.
        ls_fcat-no_out = 'X'.
        MODIFY gt_fieldcat_ant FROM ls_fcat INDEX lv_tabix.
    ENDCASE.
  ENDLOOP.

  LOOP AT gt_fieldcat_ant INTO ls_fcat WHERE fieldname = 'PROCESADO'.
    lv_tabix = sy-tabix.
    DELETE gt_fieldcat_ant INDEX lv_tabix.
  ENDLOOP.

ENDFORM.                    " COL_ALV
*&---------------------------------------------------------------------*
*&      Form  CHEQUEO_STOCK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_MSEG_MATNR  text
*      -->P_LS_MSEG_CHARG  text
*      -->P_LS_MSEG_WERKS  text
*      -->P_LS_MSEG_LGORT  text
*      <--P_LV_NO_STOCK  text
*----------------------------------------------------------------------*
FORM chequeo_stock  USING    p_matnr
                             p_charg
                             p_werks
                             p_lgort
                    CHANGING p_no_stock
                             p_clabs.

  DATA: lv_clabs TYPE labst.

  CLEAR: p_no_stock, lv_clabs.

  SELECT SINGLE clabs INTO lv_clabs
    FROM mchb
    WHERE matnr = p_matnr
    AND werks = p_werks
    AND lgort = p_lgort
    AND charg = p_charg.

  IF lv_clabs <= 0.
    p_no_stock = 'X'.
    CLEAR lv_clabs.
  ELSE.
    CLEAR p_no_stock.
    p_clabs = lv_clabs.
  ENDIF.

ENDFORM.                    " CHEQUEO_STOCK

* GST - 27/05/2015 ->
*&---------------------------------------------------------------------*
*&      Form  F_REC_MAT_RESIDUO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_mat_residuo .

*  " Tablas locales:
  DATA: lt_mseg TYPE TABLE OF mseg.

  " Estructuras locales:
  DATA: ls_mat_res LIKE gt_mat_res,
        ls_mseg    TYPE mseg,
        lv_mtart   TYPE mtart,
        lv_maktx   TYPE maktx,
        lv_stat    TYPE flag,
        lv_index   LIKE sy-tabix.

  REFRESH lt_mseg.

  IF gv_ff_ini = gv_ff_fin.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                      AND  mkpf~mjahr = mseg~mjahr
WHERE ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini AND mkpf~cputm <= gv_hf_fin )
*      AND mseg~kzbew = 'F'
AND mseg~werks = p_werks
AND mseg~lgort = '1021'
AND ( mseg~bwart = '531' OR mseg~bwart = '532' ).

  ELSE.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
                      AND  mkpf~mjahr = mseg~mjahr
      WHERE ( ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini ) OR
              ( mkpf~budat = gv_ff_fin AND mkpf~cputm <= gv_hf_fin ) OR
              ( mkpf~budat < gv_ff_fin AND mkpf~budat > gv_ff_ini ) )
*      AND mseg~kzbew = 'F'
      AND mseg~werks = p_werks
      AND mseg~lgort = '1021'
      AND ( mseg~bwart = '531' OR mseg~bwart = '532' ).

  ENDIF.

  LOOP AT lt_mseg INTO ls_mseg.
    CLEAR: lv_mtart, ls_mat_res, lv_maktx.

    " Revisar que la orden de fabricación esté en status liberado (I0002):
    CLEAR lv_stat.
    PERFORM f_stat_ord USING ls_mseg-aufnr
                       CHANGING lv_stat.

    IF lv_stat <> 'X'.
      CONTINUE.
    ENDIF.

    " Revisar que el material sea del tipo ZROL:
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = ls_mseg-matnr.

    SELECT SINGLE maktx INTO lv_maktx
      FROM makt
      WHERE matnr = ls_mseg-matnr
      AND spras = sy-langu.

    IF lv_mtart = 'ZRES'.
      CLEAR: lv_index, ls_mat_res.
      READ TABLE gt_mat_res INTO ls_mat_res WITH KEY matnr = ls_mseg-matnr
                                                    charg = ls_mseg-charg
                                                    aufnr = ls_mseg-aufnr.
      lv_index = sy-tabix.

      IF ls_mat_res IS NOT INITIAL.
        CASE ls_mseg-bwart.
          WHEN '531'.
            ls_mat_res-menge = ls_mat_res-menge + ls_mseg-menge.
            ls_mat_res-meins = ls_mseg-meins.
          WHEN '532'.
            ls_mat_res-menge = ls_mat_res-menge - ls_mseg-menge.
            ls_mat_res-meins = ls_mseg-meins.
        ENDCASE.
        MODIFY gt_mat_res FROM ls_mat_res INDEX lv_index.
      ELSE.
        ls_mat_res-matnr = ls_mseg-matnr.
        ls_mat_res-maktx_res = lv_maktx.
        ls_mat_res-charg = ls_mseg-charg.
        ls_mat_res-aufnr = ls_mseg-aufnr.
        CASE ls_mseg-bwart.
          WHEN '531'.
            ls_mat_res-menge = ls_mseg-menge.
          WHEN '532'.
            ls_mat_res-menge = ( -1 ) * ls_mseg-menge.
        ENDCASE.
        ls_mat_res-meins = ls_mseg-meins.
        APPEND ls_mat_res TO gt_mat_res.

      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_REC_MAT_RESIDUO

* GST - 27/05/2015 <-

* GST - 23/04/2015 ->
* Eliminar cantidades negativas fabricadas para el reparto:

*&---------------------------------------------------------------------*
*&      Form  F_REC_MAT_FABRICADOS_CANT_NEG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_mat_fabricados_cant_neg.

*  " Tablas locales:
  DATA: lt_mseg TYPE TABLE OF mseg.

  DATA: BEGIN OF lt_cant_neg OCCURS 0,
          matnr TYPE matnr,
          charg TYPE charg_d,
          aufnr TYPE aufnr,
          menge TYPE menge_d,
          meins TYPE meins,
        END OF lt_cant_neg.

  DATA: ls_cant_neg LIKE LINE OF lt_cant_neg.

  " Estructuras locales:
  DATA: ls_mat_fab    LIKE gt_mat_fab,
        ls_mseg       TYPE mseg,
        ls_ord_cons   LIKE gt_ord_cons,
        ls_ord_cons_2 LIKE gt_ord_cons_2,
        lv_mtart      TYPE mtart,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_maktx      TYPE maktx,
        lv_stat       TYPE flag.


*  " Seleccionamos doc. material dentro de las fechas de fabricación seleccionadas:
  REFRESH lt_mseg.

  IF gv_ff_ini = gv_ff_fin.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
*      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
*                      AND  mkpf~mjahr = mseg~mjahr
*WHERE ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini AND mkpf~cputm <= gv_hf_fin )
WHERE ( budat_mkpf = gv_ff_ini AND cputm_mkpf >= gv_hf_ini AND cputm_mkpf <= gv_hf_fin )
AND kzbew = 'F'
AND werks = p_werks
AND lgort IN s_lgort1
AND ( bwart = '101' OR bwart = '102' ).

  ELSE.

    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_mseg
      FROM mseg
*      INNER JOIN mkpf ON mkpf~mblnr = mseg~mblnr
*                      AND  mkpf~mjahr = mseg~mjahr
*      WHERE ( ( mkpf~budat = gv_ff_ini AND mkpf~cputm >= gv_hf_ini ) OR
*              ( mkpf~budat = gv_ff_fin AND mkpf~cputm <= gv_hf_fin ) OR
*              ( mkpf~budat < gv_ff_fin AND mkpf~budat > gv_ff_ini ) )

            WHERE ( ( budat_mkpf = gv_ff_ini AND cputm_mkpf >= gv_hf_ini ) OR
                    ( budat_mkpf = gv_ff_fin AND cputm_mkpf <= gv_hf_fin ) OR
                    ( budat_mkpf < gv_ff_fin AND budat_mkpf > gv_ff_ini ) )


      AND mseg~kzbew = 'F'
      AND mseg~werks = p_werks
      AND mseg~lgort IN s_lgort1
      AND ( mseg~bwart = '101' OR mseg~bwart = '102' ).

  ENDIF.

* GST - 23/04/2015 ->
* Eliminar cantidades negativas fabricadas:

  CLEAR: lt_cant_neg.
  REFRESH: lt_cant_neg.

  LOOP AT lt_mseg INTO ls_mseg.
    CLEAR: lv_mtart, ls_cant_neg.

    " Revisar que la orden de fabricación esté en status liberado (I0002):
    CLEAR lv_stat.
    PERFORM f_stat_ord USING ls_mseg-aufnr
                       CHANGING lv_stat.

    IF lv_stat <> 'X'.
      CONTINUE.
    ENDIF.

    " Revisar que el material sea del tipo ZROL:
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = ls_mseg-matnr.

    IF lv_mtart = 'ZROL'.

      CLEAR: lv_index, ls_cant_neg.
      READ TABLE lt_cant_neg INTO ls_cant_neg WITH KEY matnr = ls_mseg-matnr
                                                       charg = ls_mseg-charg
                                                      aufnr = ls_mseg-aufnr.
      lv_index = sy-tabix.

      IF ls_cant_neg IS NOT INITIAL.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_cant_neg-menge = ls_cant_neg-menge + ls_mseg-menge.
            ls_cant_neg-meins = ls_mseg-meins.
          WHEN '102'.
            ls_cant_neg-menge = ls_cant_neg-menge - ls_mseg-menge.
            ls_cant_neg-meins = ls_mseg-meins.
        ENDCASE.
        MODIFY lt_cant_neg FROM ls_cant_neg INDEX lv_index.
      ELSE.
        ls_cant_neg-matnr = ls_mseg-matnr.
        ls_cant_neg-charg = ls_mseg-charg.
        ls_cant_neg-aufnr = ls_mseg-aufnr.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_cant_neg-menge = ls_mseg-menge.
          WHEN '102'.
            ls_cant_neg-menge = ( -1 ) * ls_mseg-menge.
        ENDCASE.
        ls_cant_neg-meins = ls_mseg-meins.
        APPEND ls_cant_neg TO lt_cant_neg.
      ENDIF.
    ENDIF.
  ENDLOOP.
* GST - 23/04/2015 <-

  LOOP AT lt_mseg INTO ls_mseg.
    CLEAR: lv_mtart, ls_mat_fab, lv_maktx.

    " Revisar que la orden de fabricación esté en status liberado (I0002):
    CLEAR lv_stat.
    PERFORM f_stat_ord USING ls_mseg-aufnr
                       CHANGING lv_stat.

    IF lv_stat <> 'X'.
      CONTINUE.
    ENDIF.

    " Revisar que el material sea del tipo ZROL:
    SELECT SINGLE mtart INTO lv_mtart
      FROM mara
      WHERE matnr = ls_mseg-matnr.

    SELECT SINGLE maktx INTO lv_maktx
      FROM makt
      WHERE matnr = ls_mseg-matnr
      AND spras = sy-langu.

    IF lv_mtart = 'ZROL'.

* GST - 23/04/2015 ->
      " Comprobar que la cantidad total de ese material, lote y orden
      " no es negativo:
      CLEAR ls_cant_neg.
      READ TABLE lt_cant_neg INTO ls_cant_neg WITH KEY matnr = ls_mseg-matnr
                                                       charg = ls_mseg-charg
                                                      aufnr = ls_mseg-aufnr.

      IF ls_cant_neg IS NOT INITIAL AND ls_cant_neg-menge LE 0. "uDefine - problema consumos con 0 KG , se cambia a LE no LT
        CONTINUE.
      ENDIF.
* GST - 23/04/2015 <-

      CLEAR: lv_index, ls_mat_fab.
      READ TABLE gt_mat_fab INTO ls_mat_fab WITH KEY matnr = ls_mseg-matnr
                                                    charg = ls_mseg-charg
                                                    aufnr = ls_mseg-aufnr.
      lv_index = sy-tabix.

      IF ls_mat_fab IS NOT INITIAL.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_mat_fab-menge = ls_mat_fab-menge + ls_mseg-menge.
            ls_mat_fab-meins = ls_mseg-meins.
          WHEN '102'.
            ls_mat_fab-menge = ls_mat_fab-menge - ls_mseg-menge.
            ls_mat_fab-meins = ls_mseg-meins.
        ENDCASE.
        MODIFY gt_mat_fab FROM ls_mat_fab INDEX lv_index.
      ELSE.
        ls_mat_fab-matnr = ls_mseg-matnr.
        ls_mat_fab-maktx_fab = lv_maktx.
        ls_mat_fab-charg = ls_mseg-charg.
        ls_mat_fab-aufnr = ls_mseg-aufnr.
        CASE ls_mseg-bwart.
          WHEN '101'.
            ls_mat_fab-menge = ls_mseg-menge.
          WHEN '102'.
            ls_mat_fab-menge = ( -1 ) * ls_mseg-menge.
        ENDCASE.
        ls_mat_fab-meins = ls_mseg-meins.
        APPEND ls_mat_fab TO gt_mat_fab.

      ENDIF.

      "  Añadir a una tabla dónde sólo estén contenidas las órdenes
      "  contra las que se va a hacer consumo y buscar sus referencias:
      CLEAR: ls_ord_cons, lv_index_2.
      READ TABLE gt_ord_cons INTO ls_ord_cons WITH KEY aufnr = ls_mseg-aufnr
                                                      charg = ls_mseg-charg.
      lv_index_2 = sy-tabix.
      IF ls_ord_cons IS INITIAL.
        ls_ord_cons-aufnr = ls_mseg-aufnr.
        ls_ord_cons-charg = ls_mseg-charg.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
        ENDIF.
        SELECT SINGLE rsnum INTO ls_ord_cons-rsnum
          FROM caufv
          WHERE aufnr = ls_mseg-aufnr.
        APPEND ls_ord_cons TO gt_ord_cons.
      ELSE.
        IF ls_ord_cons-budat IS INITIAL AND ls_mseg-bwart = '101'.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons FROM ls_ord_cons INDEX lv_index_2.
        ELSEIF ls_ord_cons-budat IS NOT INITIAL AND ls_mseg-bwart = '101' AND ls_mseg-budat_mkpf < ls_ord_cons-budat.
          ls_ord_cons-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons FROM ls_ord_cons INDEX lv_index_2.
        ENDIF.
      ENDIF.

      CLEAR: ls_ord_cons_2, lv_index_2.
      READ TABLE gt_ord_cons_2 INTO ls_ord_cons_2 WITH KEY aufnr = ls_mseg-aufnr.
*                                                           charg = ls_mseg-charg.
      lv_index_2 = sy-tabix.
      IF ls_ord_cons_2 IS INITIAL.
        ls_ord_cons_2-aufnr = ls_mseg-aufnr.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
        ENDIF.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge + ls_mseg-menge.
          gv_tot_fab = gv_tot_fab + ls_mseg-menge.
        ELSE.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge - ls_mseg-menge.
          gv_tot_fab = gv_tot_fab - ls_mseg-menge.
        ENDIF.
        APPEND ls_ord_cons_2 TO gt_ord_cons_2.
      ELSE.
        IF ls_mseg-bwart = '101'.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge + ls_mseg-menge.
          gv_tot_fab = gv_tot_fab + ls_mseg-menge.
        ELSE.
          ls_ord_cons_2-menge = ls_ord_cons_2-menge - ls_mseg-menge.
          gv_tot_fab = gv_tot_fab - ls_mseg-menge.
        ENDIF.
        IF ls_ord_cons_2-budat IS INITIAL AND ls_mseg-bwart = '101'.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ELSEIF ls_ord_cons_2-budat IS NOT INITIAL AND ls_mseg-bwart = '101' AND ls_mseg-budat_mkpf < ls_ord_cons_2-budat.
          ls_ord_cons_2-budat = ls_mseg-budat_mkpf.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ELSE.
          MODIFY gt_ord_cons_2 FROM ls_ord_cons_2 INDEX lv_index_2.
        ENDIF.
      ENDIF.

    ENDIF.
  ENDLOOP.


  " Recuperamos las posiciones de los distintos materiales en las reservas
  " de la orden:
  SELECT rsnum rspos matnr rgekz INTO CORRESPONDING FIELDS OF TABLE gt_ref_pos
  FROM resb
  FOR ALL ENTRIES IN gt_ord_cons
  WHERE rsnum = gt_ord_cons-rsnum.

ENDFORM.                    " F_REC_MAT_FABRICADOS_CANT_NEG

* GST - 23/04/2015 <-
*&---------------------------------------------------------------------*
*&      Form  INICIALIZACIÓN_SEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM inicializacion_sel .

  IF sy-batch <> 'X'.
    SELECT SINGLE parva FROM usr05
          INTO p_werks
          WHERE bname = sy-uname AND
          parid = 'WRK'.
  ENDIF.

  LOOP AT SCREEN.
    IF screen-name = 'P_WERKS'
       AND sy-batch <> 'X'.
      screen-required = '1'.
      MODIFY SCREEN.
    ENDIF.
*YTG 24102016- MOD.
    IF sy-tcode = 'ZPP0002'.
      IF screen-name = 'P_WERKS'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'S_LGORT1-LOW'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'S_LGORT1-HIGH'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'P_LGORT2'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
*      IF screen-name = 'P_D_FIN'.
*        screen-input = '0'.
*        MODIFY SCREEN.
*      ENDIF.
*      IF screen-name = 'P_H_FIN'.
*        screen-input = '0'.
*        MODIFY SCREEN.
*      ENDIF.
    ENDIF.
  ENDLOOP.
***YTG 24102016- MOD.
ENDFORM.                    " INICIALIZACIÓN_SEL


*&---------------------------------------------------------------------*
*&      Form  F_REC_MAT_CONSUMIR_V2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_mat_consumir_v2 .

  DATA: lti_mchb TYPE TABLE OF mchb.

  DATA: ls_mchb     TYPE mchb,
        ls_mat_cons LIKE gt_mat_cons.

  DATA: lv_mblnr TYPE mblnr,
        lv_mjahr TYPE mjahr,
        lv_ind   TYPE i.

  DATA lt_mseg TYPE TABLE OF mseg.

  DATA lt_mseg_hash TYPE HASHED TABLE OF mseg WITH UNIQUE KEY charg.

  RANGES:s_matnr FOR mara-matnr,s_charg FOR mcha-charg.

* Sacamos todo el stock de lotes del almacén
  SELECT * INTO TABLE lti_mchb
      FROM  mchb
      WHERE werks = p_werks
      AND   lgort = p_lgort2
      AND   lvorm = space
      AND   clabs > 0.

  CHECK sy-subrc EQ 0.

  LOOP AT lti_mchb INTO ls_mchb.
    CLEAR s_matnr.
    CLEAR s_charg.
    s_matnr-sign = s_charg-sign = 'I'.
    s_matnr-option = s_charg-option = 'EQ'.
    s_matnr-low = ls_mchb-matnr.
    s_charg-low = ls_mchb-charg.
    APPEND s_matnr.
    APPEND s_charg.
  ENDLOOP.





  IF p_new EQ abap_true.

    SELECT * FROM mseg INTO TABLE lt_mseg WHERE werks EQ p_werks AND

                                               matnr IN s_matnr AND
                                               lgort EQ p_lgort2 AND
                                               bwart IN ('311', '312') AND
                                               sobkz EQ space AND
                                             ( ( budat_mkpf EQ gv_fc_fin AND cputm_mkpf LE gv_hc_fin ) OR  budat_mkpf LT gv_fc_fin ) AND
                                               charg IN s_charg.

    SORT lt_mseg BY charg ASCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING charg.

    lt_mseg_hash[] = lt_mseg[].


* Recorremos los lotes comprobando si ha habido un traslado anterior
* a la fecha/hora calculada
    LOOP AT lti_mchb INTO ls_mchb.
      CLEAR: lv_mblnr, lv_mjahr.
      lv_ind = sy-tabix.
*   Comprobamos si ha habido algún movimiento de ese lote
*    SELECT SINGLE a~mblnr a~mjahr INTO (lv_mblnr, lv_mjahr)
*       FROM mseg AS a INNER JOIN mkpf AS b
*                      ON ( a~mblnr = b~mblnr AND
*                           a~mjahr = b~mjahr )
*       WHERE ( ( b~budat = gv_fc_fin AND b~cputm <= gv_hc_fin ) OR
*               ( b~budat < gv_fc_fin ) )
*       AND a~matnr  = ls_mchb-matnr
*       AND a~charg  = ls_mchb-charg
*       AND a~werks  = p_werks
*       AND a~lgort  = p_lgort2
*       AND a~xauto  = 'X'
*       AND a~bwart IN ('311', '312').
      READ TABLE lt_mseg_hash WITH TABLE KEY charg = ls_mchb-charg TRANSPORTING NO FIELDS.
*   Si no ha habido ningún movimiento, quitamos el lote de la tabla interna
      IF sy-subrc <> 0.
        DELETE lti_mchb INDEX lv_ind.
      ENDIF.
    ENDLOOP.

  ELSE.
    LOOP AT lti_mchb INTO ls_mchb.
      CLEAR: lv_mblnr, lv_mjahr.
      lv_ind = sy-tabix.
*   Comprobamos si ha habido algún movimiento de ese lote
      SELECT SINGLE a~mblnr a~mjahr INTO (lv_mblnr, lv_mjahr)
         FROM mseg AS a INNER JOIN mkpf AS b
                        ON ( a~mblnr = b~mblnr AND
                             a~mjahr = b~mjahr )
         WHERE ( ( b~budat = gv_fc_fin AND b~cputm <= gv_hc_fin ) OR
                 ( b~budat < gv_fc_fin ) )
         AND a~matnr  = ls_mchb-matnr
         AND a~charg  = ls_mchb-charg
         AND a~werks  = p_werks
         AND a~lgort  = p_lgort2
         AND a~xauto  = 'X'
         AND a~bwart IN ('311', '312').
*   Si no ha habido ningún movimiento, quitamos el lote de la tabla interna
      IF sy-subrc <> 0.
        DELETE lti_mchb INDEX lv_ind.
      ENDIF.
    ENDLOOP.

  ENDIF.

* Recorremos la tabla de lotes añadiendolos a la tabla de consumos
  LOOP AT lti_mchb INTO ls_mchb.
    CLEAR ls_mat_cons.
    ls_mat_cons-matnr = ls_mchb-matnr.
    ls_mat_cons-charg = ls_mchb-charg.
    ls_mat_cons-menge = ls_mchb-clabs.
*   Descripción y UMB
    SELECT SINGLE a~meins b~maktx
        INTO (ls_mat_cons-meins, ls_mat_cons-maktx_cons)
        FROM  mara AS a INNER JOIN makt AS b
                        ON a~matnr = b~matnr
        WHERE a~matnr = ls_mchb-matnr
        AND   b~spras = sy-langu.
    APPEND ls_mat_cons TO gt_mat_cons.
  ENDLOOP.

ENDFORM.                    " F_REC_MAT_CONSUMIR_V2
*&---------------------------------------------------------------------*
*&      Form  INICIALIZAR_SEL2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM inicializar_sel2 .
  LOOP AT SCREEN.
*YTG 24102016- MOD.
    IF sy-tcode = 'ZPP0002'.
      IF screen-name = 'P_WERKS'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'S_LGORT1-LOW'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'S_LGORT1-HIGH'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'P_LGORT2'.
        screen-input = '0'.
        MODIFY SCREEN.
      ENDIF.

      IF screen-name = 'P_D_FIN'.
        screen-input = '0'.
*        screen-invisible = '1'.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = 'P_H_FIN'.
        screen-input = '0'.
*        screen-invisible = '1'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.
  ENDLOOP.
***YTG 24102016- MOD.
ENDFORM.                    " INICIALIZAR_SEL2
*&---------------------------------------------------------------------*
*&      Form  MOD_PORC_FSC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_GT_CONSUMO  text
*----------------------------------------------------------------------*
FORM mod_porc_fsc.
  FIELD-SYMBOLS: <ls_consumo> TYPE zstpp_consumo_pulper.

  IF p_werks = '3000' OR p_werks = '3020'.
    LOOP AT gt_consumo ASSIGNING <ls_consumo>.
      <ls_consumo>-porc_fsc = 100.
    ENDLOOP.
  ENDIF.
ENDFORM.                    " MOD_PORC_FSC
*&---------------------------------------------------------------------*
*&      Form  F_ENVIAR_MAIL_ERROR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_enviar_mail_error .

  SELECT SINGLE * FROM ztpp0003 INTO @DATA(ls_03) WHERE werks = @p_werks
                                                 AND progname = @sy-repid.
  CHECK sy-subrc EQ 0.

  IF ls_03-mail_sistemas IS INITIAL AND ls_03-mail_negocio IS INITIAL.
    RETURN.
  ENDIF.


  DATA: send_request TYPE REF TO cl_bcs,
        document     TYPE REF TO cl_document_bcs,
        recipient    TYPE REF TO if_recipient_bcs,
        li_sender2   TYPE REF TO cl_sapuser_bcs,
        l_count_mail TYPE so_obj_len,
        t_attach     TYPE solix_tab,
        wa_attach    TYPE solix.

  DATA l_text TYPE so_text255.

  DATA: lt_bodytext    TYPE bcsy_text,
        l_bodytext_row TYPE soli.

  DATA: li_sender TYPE REF TO cl_cam_address_bcs,
        l_new.


  TRY.
      CALL METHOD cl_bcs=>create_persistent
        RECEIVING
          result = send_request.
  ENDTRY.

  l_text = 'IMPORTANTE: Se ha producido un error en el reparto de consumos de pulper en el centro &.'.
  REPLACE '&' IN l_text WITH p_werks.
  APPEND VALUE soli( line = l_text ) TO lt_bodytext.

*  l_text = 'La fecha y hora de ejecución no se ha actualizado.'.
*  APPEND VALUE soli( line = l_text ) TO lt_bodytext.
  l_text = 'Por favor, revisar los lotes existentes en el pulper para determinar el error.'.
  APPEND VALUE soli( line = l_text ) TO lt_bodytext.

  DATA(l_subject) = |Error reparto consumo pulper|.

  TRY.
      CALL METHOD cl_document_bcs=>create_document
        EXPORTING
          i_type    = 'HTM'
          i_subject = CONV so_obj_des( l_subject )
          i_text    = lt_bodytext
        RECEIVING
          result    = document.
    CATCH cx_document_bcs .
  ENDTRY.


  CALL METHOD send_request->set_document( document ).


  li_sender ?= cl_cam_address_bcs=>create_internet_address( i_address_string = CONV adr6-smtp_addr('remitente@hinojosa.es' ) ).

  CALL METHOD send_request->set_sender
    EXPORTING
      i_sender = li_sender.

  IF ls_03-mail_negocio IS NOT INITIAL.

    recipient = cl_cam_address_bcs=>create_internet_address( ls_03-mail_negocio ).

    CALL METHOD send_request->add_recipient( i_recipient = recipient ).

  ENDIF.

  IF ls_03-mail_sistemas IS NOT INITIAL AND ( ls_03-mail_sistemas NE ls_03-mail_negocio ).

    recipient = cl_cam_address_bcs=>create_internet_address( ls_03-mail_sistemas ).

    CALL METHOD send_request->add_recipient( i_recipient = recipient ).

  ENDIF.


  CALL METHOD send_request->send( ).


  COMMIT WORK AND WAIT.


ENDFORM.


FORM control_solape_job CHANGING p_stop TYPE flag.

  DATA: lt_btcjob TYPE STANDARD TABLE OF btcjob.
  DATA: l_btcjob TYPE btcjob.

  CLEAR:  p_stop , lt_btcjob[].

  CASE p_werks.
    WHEN '3000'. l_btcjob = 'Z_PP_CONSUMO_PULPER_H4_3000'.
    WHEN '3020'. l_btcjob = 'Z_PP_CONSUMO_PULPER_H4_3020'.
    WHEN OTHERS.
  ENDCASE.

  SELECT jobname
    FROM tbtco
    APPENDING TABLE @lt_btcjob
    WHERE jobname = @l_btcjob
       AND status = 'R'.  " running

  IF lines( lt_btcjob ) > 1  .
    p_stop = 'X'.
  ENDIF.


ENDFORM.
