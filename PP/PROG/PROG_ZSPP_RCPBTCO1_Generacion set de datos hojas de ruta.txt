REPORT zspp_rcpbtco1 MESSAGE-ID cp.

********************************************************************
*** Dieser Report liest Daten zur Plangruppe aus einem System
*** zur BTCI-Übernahme in ein anders System mit Programm RCPTRA01.
********************************************************************

*___________________________________________________________________
*   DDIC-Strukturen
*___________________________________________________________________
TABLES:
  bimpl,                               "Material-Planzuordnung
  bipko,                               "Kopf
  bipfl,                               "Folge
  bippo,                               "Vorgang
  bipfh,                               "Fertigungshilfsmittel
  bipmk,                               "Prüfmerkmal
*  bipmw,                               "Prüfmerkmalswert
  bipmz,                               "Materialkomponente
  biptx,                               "Langtext
  bi000,                               "Mappenvorsatz
  bi001,                               "Transaktions-Kopfsatz
  rcr01,                               "Arbeitsplatzdaten
  plko,
  plfl,
  plpo,
  plas,
  mast,
  mapl,
  stpo,                                " Stücklistenpositionen
  thead,                               " Struktur
  tcn01,                               " Benutzerfelder
  tca01,                               " für Langtexte
  tca09.                               " für Langtexte
*_______________________________________________________________________
*   KONSTANTEN
*_______________________________________________________________________

* Konstanten Pläne
INCLUDE fc270t04.

* Datumskonstanten
INCLUDE fc27date.

* Verschlüsselung der Plan-Objekte
DATA:
  BEGIN OF rectype,
    head(2)   VALUE '00',
    mapl(2)   VALUE '01',
    eapl(2)   VALUE '02',
    plko(2)   VALUE '03',
    plkotx(2) VALUE '04',
    plfl(2)   VALUE '05',
    plfltx(2) VALUE '06',
    plab(2)   VALUE '07',
    pltx(2)   VALUE '08',
    plpo(2)   VALUE '09',
    plpotx(2) VALUE '10',
    plfh(2)   VALUE '11',
    plfhtx(2) VALUE '12',
    plmz(2)   VALUE '13',
    plph(2)   VALUE '14',
    plft(2)   VALUE '15',
    plfv(2)   VALUE '16',
    plwp(2)   VALUE '17',
    plmk(2)   VALUE '18',
    plmw(2)   VALUE '19',                               "#EC NO_M_RISC3
    plmktx(2) VALUE '20',              "Prüfmerkmalslangtext
    next(2)   VALUE '99',
  END OF rectype.
* Variablen zur Stücklistenauflösung/Mat.-Komponentenzuordnung
DATA topmat LIKE cstmat.
DATA dstst LIKE csdata-xfeld.
*
DATA  BEGIN OF stpox_tab OCCURS 0.
        INCLUDE STRUCTURE stpox.
DATA:   "stlty_w like      plmzd-stlty_w,
  "stlnr_w like      plmzd-stlnr_w,
  stlal_w LIKE      plmzd-stlal_w,
  kante   LIKE      plmzd-kante,
  END   OF stpox_tab.


DATA: BEGIN OF mapl_auf OCCURS 0,
        matnr LIKE mapl-matnr,
        werks LIKE mapl-werks,
        stlty LIKE stas-stlal,
        stlnr LIKE stas-stlnr,
        stlal LIKE stas-stlal,
        stlan LIKE mast-stlan,
      END OF mapl_auf.


CONSTANTS:                                                           "Note_1796578
* logical file name used with data load programs for routings        "Note_1796578
  gc_logical_filename   TYPE fileintern  VALUE 'CP_RTG_DATA_LOAD'.   "Note_1796578
*______________________________________________________________________
*   SELEKTIONSBILD
*______________________________________________________________________

* Ausgabeparameter
SELECTION-SCREEN BEGIN OF BLOCK ausgabe WITH FRAME TITLE text-027.
* Seq. Ausgabedatei
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-028.                        "N744242
SELECTION-SCREEN COMMENT (31) text-028 FOR FIELD outfile .  "N744242
PARAMETERS:
  outfile(255) TYPE c
              LOWER CASE
              DEFAULT 'RCPTRA00'.
SELECTION-SCREEN END OF LINE.
* Mappenname
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-029.                        "N744242
SELECTION-SCREEN COMMENT (31) text-029 FOR FIELD map_nam.   "N744242
PARAMETERS:
  map_nam(10) TYPE c
              LOWER CASE
              DEFAULT 'BTHO_PLAN'.
SELECTION-SCREEN END OF LINE.
* Freigabe-Datum
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-034.                        "N744242
SELECTION-SCREEN COMMENT (31) text-034 FOR FIELD  free_dat. "N744242
PARAMETERS free_dat LIKE plko-datuv DEFAULT sy-datum.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK ausgabe.

* Planauswahlparameter
SELECTION-SCREEN BEGIN OF BLOCK auswahl WITH FRAME TITLE text-030.
* Plantyp
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-031.                        "N744242
SELECTION-SCREEN COMMENT (31) text-031 FOR FIELD plty_sel.  "N744242
PARAMETERS plty_sel LIKE plko-plnty DEFAULT 'N'.
SELECTION-SCREEN END OF LINE.
* Plannummern
SELECT-OPTIONS plnr_all FOR plko-plnnr MATCHCODE OBJECT plks
               OBLIGATORY.
SELECTION-SCREEN SKIP.
* Stichtag
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-032.                        "N744242
SELECTION-SCREEN COMMENT (31) text-032 FOR FIELD stag_sel.  "N744242
PARAMETERS stag_sel LIKE rc271-sttag DEFAULT sy-datum.
SELECTION-SCREEN END OF LINE.
*
SELECTION-SCREEN END OF BLOCK auswahl.
*
SELECTION-SCREEN BEGIN OF BLOCK umbenennen WITH FRAME TITLE text-040.
SELECTION-SCREEN BEGIN OF BLOCK zielsystem WITH FRAME TITLE text-051.
* Neuer Mandant
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-036.                        "N744242
SELECTION-SCREEN COMMENT (31) text-036 FOR FIELD  mand_new. "N744242
PARAMETERS mand_new LIKE plko-mandt.
SELECTION-SCREEN END OF LINE.
* Neues Profil
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT (31) text-035.                        "N744242
SELECTION-SCREEN COMMENT (31) text-035 FOR FIELD prof_new.  "N744242
PARAMETERS prof_new LIKE plko-profidnetz OBLIGATORY.
SELECTION-SCREEN END OF LINE.
* Neuer Name Plangruppe
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS new_flag AS CHECKBOX DEFAULT ''.
*SELECTION-SCREEN COMMENT (69) text-041.                        "N744242
SELECTION-SCREEN COMMENT (69) text-041 FOR FIELD new_flag.  "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK zielsystem.
SELECTION-SCREEN BEGIN OF BLOCK objekte WITH FRAME TITLE text-052.
* Material
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS mat_flag AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-042.                        "N744242
SELECTION-SCREEN COMMENT (69) text-042 FOR FIELD mat_flag.  "N744242
SELECTION-SCREEN END OF LINE.
* Fertigungshilfsmittel
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS fhm_flag AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-043.                        "N744242
SELECTION-SCREEN COMMENT (69) text-043 FOR FIELD fhm_flag.  "N744242
SELECTION-SCREEN END OF LINE.
* Prüfmerkmale
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS cha_flag AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-055.                        "N744242
SELECTION-SCREEN COMMENT (69) text-055 FOR FIELD cha_flag.  "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK objekte.

* --------- TEXTE
SELECTION-SCREEN BEGIN OF BLOCK texte WITH FRAME TITLE text-053.
* Langtext zum Plankopf
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS koptx_fl AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-046.                        "N744242
SELECTION-SCREEN COMMENT (69) text-046 FOR FIELD koptx_fl . "N744242
SELECTION-SCREEN END OF LINE.
* Langtext zu Folgen
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS foltx_fl AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-047.                        "N744242
SELECTION-SCREEN COMMENT (69) text-047 FOR FIELD foltx_fl . "N744242
SELECTION-SCREEN END OF LINE.
* Langtext zum Fertigungshilfsmittel
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS fhmtx_fl AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-044.                        "N744242
SELECTION-SCREEN COMMENT (69) text-044 FOR FIELD fhmtx_fl . "N744242
SELECTION-SCREEN END OF LINE.
* Langtext zum Prüfmerkmal
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS chatx_fl AS CHECKBOX DEFAULT 'X'.
*SELECTION-SCREEN COMMENT (69) text-056.                        "N744242
SELECTION-SCREEN COMMENT (69) text-056 FOR FIELD chatx_fl . "N744242
SELECTION-SCREEN END OF LINE.

* Texte zu Vorgängen
SELECTION-SCREEN BEGIN OF BLOCK vorgang WITH FRAME TITLE text-050.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS vortx_fl DEFAULT 'X' RADIOBUTTON GROUP stex.
*SELECTION-SCREEN COMMENT (35) text-048.                        "N744242
SELECTION-SCREEN COMMENT (35) text-048 FOR FIELD  vortx_fl. "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS ktsch_fl RADIOBUTTON GROUP stex.
*SELECTION-SCREEN COMMENT (35) text-049.                        "N744242
SELECTION-SCREEN COMMENT (35) text-049 FOR FIELD  ktsch_fl. "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK vorgang.
* Texte zu FHM
SELECTION-SCREEN BEGIN OF BLOCK fhmtx WITH FRAME TITLE text-043.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS prt_ltxt DEFAULT 'X' RADIOBUTTON GROUP sfhm.
*SELECTION-SCREEN COMMENT (35) text-048.                        "N744242
SELECTION-SCREEN COMMENT (35) text-048 FOR FIELD prt_ltxt . "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  prt_ktsc RADIOBUTTON GROUP sfhm.
*SELECTION-SCREEN COMMENT (35) text-049.                        "N744242
SELECTION-SCREEN COMMENT (35) text-049 FOR FIELD  prt_ktsc. "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK fhmtx.

SELECTION-SCREEN END OF BLOCK texte.
*
SELECTION-SCREEN END OF BLOCK umbenennen.
* RCPTRA01 automatisch ausführen
SELECTION-SCREEN BEGIN OF BLOCK automat WITH FRAME TITLE text-060.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS auto_flg AS CHECKBOX DEFAULT ''.
*SELECTION-SCREEN COMMENT (69) text-061.                        "N744242
SELECTION-SCREEN COMMENT (69) text-061 FOR FIELD  auto_flg. "N744242
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK automat.
*______________________________________________________________________
*   VERARBEITUNGSZÄHLER
*______________________________________________________________________

DATA:
  BEGIN OF cnt,
* Zähler ausgegebene Sätze
    mapl_out(6)   TYPE n,
    eapl_out(6)   TYPE n,
    plko_out(6)   TYPE n,
    plkotx_out(6) TYPE n,
    plfl_out(6)   TYPE n,
    plfltx_out(6) TYPE n,
    plab_out(6)   TYPE n,
    pltx_out(6)   TYPE n,
    plpo_out(6)   TYPE n,
    plpotx_out(6) TYPE n,
    plfh_out(6)   TYPE n,
    plfhtx_out(6) TYPE n,
    plmz_out(6)   TYPE n,
    plph_out(6)   TYPE n,
    plft_out(6)   TYPE n,
    plfv_out(6)   TYPE n,
    plwp_out(6)   TYPE n,
    plmk_out(6)   TYPE n,
    plmw_out(6)   TYPE n,
    plmktx_out(6) TYPE n,
  END OF cnt.

*_______________________________________________________________________
*   Ausgabe-Datei
*_______________________________________________________________________

DATA:
  BEGIN OF out_record,
    type(2)    TYPE c,
    DATA(1498),
  END OF out_record.
* Tabelle für Langtexte
DATA: BEGIN OF txt_tab OCCURS 10.
        INCLUDE STRUCTURE tline.
      DATA: END OF txt_tab.

* Satz pro Transaktion
DATA:
  BEGIN OF next_trans_rec,
    type(2)  TYPE c,
    tcode(4),
  END OF next_trans_rec.

* Mappenvorsatz enthält Mappen-Infos
DATA:
  BEGIN OF head_rec,
    type(2) TYPE c.
    INCLUDE STRUCTURE bgr00.
  DATA:
  END OF head_rec.

DATA:
  plnr_sel LIKE plko-plnnr,                      "Plangruppe aus Range
  plnr_act LIKE plpo-plnnr.                      "Plangruppenname

DATA: BEGIN OF mapl_tab OCCURS 0.                "Material-Plan-Zuord.
        INCLUDE STRUCTURE maplb.
      DATA: END OF mapl_tab.

DATA: BEGIN OF plnr_tab OCCURS 0,                "Selektierte Plannr.
        plnnr LIKE plko-plnnr,
        plnal LIKE plko-plnal.
DATA: END OF plnr_tab.

DATA: BEGIN OF plfh_tab OCCURS 0.                "Fertigungshilfsmittel
        INCLUDE STRUCTURE plfhb.
      DATA: END OF plfh_tab.

DATA: BEGIN OF plfhd_tab OCCURS 0.               "Fertigungshilfsmittel
        INCLUDE STRUCTURE plfhd.
      DATA: END OF plfhd_tab.

DATA BEGIN OF plmk_tab OCCURS 0.       " Merkmal (characteristic)
        INCLUDE STRUCTURE plmkb.
DATA END OF plmk_tab.

DATA BEGIN OF plmw_tab OCCURS 0.  " Merkmalswert (characteristic value)
        INCLUDE STRUCTURE plmwb.       "???bipmw
DATA END OF plmw_tab.

DATA: BEGIN OF plfl_tab OCCURS 0.                "Folgen
        INCLUDE STRUCTURE plflb.
      DATA: END OF plfl_tab.

DATA: BEGIN OF plfld_tab OCCURS 0.               "Folgen
        INCLUDE STRUCTURE plfld.
      DATA: END OF plfld_tab.

DATA: BEGIN OF plmz_tab OCCURS 0.                "Komponentenzuord.
        INCLUDE STRUCTURE plmzb.
      DATA: END OF plmz_tab.

DATA: BEGIN OF plmzd_tab OCCURS 0.               "Komponentenzuord.
        INCLUDE STRUCTURE plmzd.
      DATA: END OF plmzd_tab.

DATA: BEGIN OF plas_tab OCCURS 0.                "Vorgänge
        INCLUDE STRUCTURE plasb.
      DATA: END OF plas_tab.

DATA: BEGIN OF plpo_tab OCCURS 0.                "Vorgänge
        INCLUDE STRUCTURE plpob.
      DATA: END OF plpo_tab.

DATA: BEGIN OF plpod_tab OCCURS 0.               "Vorgänge
        INCLUDE STRUCTURE plpod.
      DATA: END OF plpod_tab.

DATA: BEGIN OF plko_tab OCCURS 0.                "Plankopf
        INCLUDE STRUCTURE plkob.
      DATA: END OF plko_tab.

DATA: BEGIN OF plpo_lst OCCURS 0.                "PLPO Feldliste
        INCLUDE STRUCTURE dfies.
      DATA: END OF plpo_lst.

DATA: BEGIN OF bippo_lst OCCURS 0.               "BIPPO Feldliste
        INCLUDE STRUCTURE dfies.
      DATA: END OF bippo_lst.

DATA: BEGIN OF plmk_lst OCCURS 0.                "PLMK Feldliste
        INCLUDE STRUCTURE dfies.
      DATA: END OF plmk_lst.

DATA: BEGIN OF bipmk_lst OCCURS 0.               "BIPMK Feldliste
        INCLUDE STRUCTURE dfies.
      DATA: END OF bipmk_lst.


*_______________________________________________________________________
INITIALIZATION.

*______________________________________________________________________
AT SELECTION-SCREEN.

* Eingabeparameter prüfen
  PERFORM check_paras.
*______________________________________________________________________
START-OF-SELECTION.

* Ausgabe-File öffnen
  PERFORM open_file.

* Ausgabe-Datei erzeugen
  PERFORM create_outfile.

* Verarbeitungszähler auf Liste ausgeben
  PERFORM print_counters.

*______________________________________________________________________
END-OF-SELECTION.
* RCPTRA01 ausführen, falls AUTO_FLG gesetzt
  IF NOT auto_flg IS INITIAL.
    SUBMIT rcptra01 WITH inpfile EQ outfile.
  ENDIF.

************************************************************************
*** hier kommen die verwendeten FORM-Routinen alphabet. aufsteigend  ***
************************************************************************


*----------------------------------------------------------------------*
*   FORM CHECK_PARAS                                                   *
*----------------------------------------------------------------------*
*   Eingabeparameter prüfen                                            *
*----------------------------------------------------------------------*
FORM check_paras.
* Parameter prüfen.
  CASE plty_sel.
    WHEN 'N'.
      next_trans_rec-tcode = 'CA01'.
    WHEN 'S'.
      next_trans_rec-tcode = 'CA11'.
    WHEN 'Q'.
      next_trans_rec-tcode = 'QP01'.
    WHEN OTHERS.
      MESSAGE e666 WITH text-133.                      "Typ pflegen
  ENDCASE.
  IF NOT plnr_all[] IS INITIAL.
    SELECT * FROM plko WHERE
           plnnr      IN plnr_all AND
           plnty      =  plty_sel AND
           loekz      EQ ' '.
    ENDSELECT.
    IF NOT sy-subrc IS INITIAL.
      MESSAGE e666 WITH text-132.                  "Plan ex. nicht
    ENDIF.
  ENDIF.
  IF mand_new IS INITIAL.                               "Mandant
    mand_new = sy-mandt.
  ENDIF.
ENDFORM.                    "CHECK_PARAS

*----------------------------------------------------------------------*
*   FORM CREATE_HEADER                                                 *
*----------------------------------------------------------------------*
*   Mappenvorsatz
*----------------------------------------------------------------------*
FORM create_header.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CLEAR bi000.
  bi000-recty = rectype-head.
  bi000-group = map_nam.
  bi000-mandt = mand_new.
  bi000-usnam = sy-uname.
  bi000-start = free_dat - 1.
  bi000-xkeep = 'X'.
*  out_record = bi000.
  ASSIGN out_record TO <x_obj_line> CASTING.
  ASSIGN bi000      TO <x_obj> CASTING.
  <x_obj_line> = <x_obj>.

  TRANSFER out_record TO outfile.

ENDFORM.                    "CREATE_HEADER
*----------------------------------------------------------------------*
*   FORM CREATE_MAPL                                                   *
*----------------------------------------------------------------------*
*   Material-Plan-Zuordnung                                            *
*----------------------------------------------------------------------*
FORM create_mapl.
* Material-Planzuordnung

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CALL FUNCTION 'CP_DB_MAPL_READ_BY_PLNNR'
    EXPORTING
      plnnr      = plnr_sel
      plnty      = plty_sel
      datuv      = stag_sel
      datub      = stag_sel
    TABLES
      matpl      = mapl_tab
    EXCEPTIONS
      no_records = 01.

  CALL FUNCTION 'CM_DB_PLMZ_READ'
    EXPORTING
      plnnr      = plnr_sel
      plnty      = plty_sel
      datuv      = stag_sel
      datub      = stag_sel
    TABLES
      planmz     = plmz_tab
    EXCEPTIONS
      no_records = 01.

  LOOP AT mapl_tab.
    CHECK mapl_tab-loekz IS INITIAL.
    CLEAR bimpl.
    MOVE-CORRESPONDING mapl_tab TO bimpl.
    WRITE mapl_tab-matnr TO bimpl-matnr.
    WRITE mapl_tab-posnr TO bimpl-posnr NO-ZERO.
    WRITE mapl_tab-pspnr TO bimpl-pspnr NO-ZERO.
    bimpl-recty = rectype-mapl.
    bimpl-plnnr = plnr_act.
*    out_record = bimpl.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bimpl      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-mapl_out.
    SELECT * FROM mast WHERE matnr EQ mapl_tab-matnr AND
                             werks EQ mapl_tab-werks.
      MOVE-CORRESPONDING mast TO mapl_auf.
      APPEND mapl_auf.
    ENDSELECT.
  ENDLOOP.
* Für Einträge in der MAPL_AUF wird die Stückliste aufgelöst
  DELETE ADJACENT DUPLICATES FROM mapl_auf.              "#EC CI_SORTED
  SORT mapl_auf BY stlal.
* Bzgl. Dummy-Baugruppen muß das MAPL-Material bekannt sein. Daher
* Stücklistenauflösung und abgleich der PLMZ-Sätze mit dem
* Auflösungsergebnis
  LOOP AT mapl_auf.
* Prüfen, ob noch Einträge in der PLMZ_TAB zuzuordnen sind
    CHECK NOT plmz_tab[] IS INITIAL.
* Stückliste auflösen
    CLEAR stpox_tab.
    REFRESH stpox_tab.
    PERFORM bom_explosion.
    PERFORM create_plmz.
  ENDLOOP.
ENDFORM.                    "CREATE_MAPL

*----------------------------------------------------------------------*
*   FORM CREATE_NEXT                                                   *
*----------------------------------------------------------------------*
*   nächster Plan                                                      *
*----------------------------------------------------------------------*
FORM create_next USING VALUE(tcode).

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CLEAR bi001.
  bi001-recty = rectype-next.
  bi001-tcode = tcode.
*  out_record = bi001.
  ASSIGN out_record TO <x_obj_line> CASTING.
  ASSIGN bi001      TO <x_obj> CASTING.
  <x_obj_line> = <x_obj>.

  TRANSFER out_record TO outfile.

ENDFORM.                    "CREATE_NEXT

*----------------------------------------------------------------------*
*   FORM CREATE_OUTFILE                                                *
*----------------------------------------------------------------------*
*   Ausgabe-Datei erzeugen
*----------------------------------------------------------------------*
FORM create_outfile.

  PERFORM init_fieldtabs.
  PERFORM create_header.
  PERFORM init_txtkey.
* Alle selektierten Plangruppen abarbeiten
  SELECT DISTINCT plnnr INTO CORRESPONDING FIELDS OF
     TABLE plnr_tab FROM plko
     WHERE plnty EQ plty_sel AND         " Hier wird noch keine
           plnnr IN plnr_all AND         " Gültigkeit berücksichtigt
           NOT loekz EQ 'X'.
  LOOP AT plnr_tab.

    CLEAR:   mapl_tab, plfh_tab, plfhd_tab, plfl_tab, plfld_tab,
             plmz_tab, plmzd_tab, plas_tab, plpo_tab, plpod_tab,
             plko_tab, plmk_tab, plmw_tab, mapl_auf.
    REFRESH: mapl_tab, plfh_tab, plfhd_tab, plfl_tab, plfld_tab,
             plmz_tab, plmzd_tab, plas_tab, plpo_tab, plpod_tab,
             plko_tab, plmk_tab, plmw_tab, mapl_auf.

    MOVE plnr_tab-plnnr TO plnr_sel.
*       PLAN SPERREN
    CALL FUNCTION 'ENQUEUE_EPPLKO'
      EXPORTING
        plnnr          = plnr_sel
        plnty          = plty_sel
      EXCEPTIONS
        foreign_lock   = 01
        system_failure = 02.
    CASE sy-subrc.
      WHEN 01.
        MESSAGE e666 WITH text-130.
      WHEN 02.
        MESSAGE e666 WITH text-131.
    ENDCASE.
* Umschießen Plangruppenname, falls gewünscht
    IF NOT new_flag IS INITIAL.
      CLEAR plnr_act.                       "Neuer Name
    ELSE.
      MOVE plnr_sel TO plnr_act.            "Alter Name
    ENDIF.
    PERFORM create_next USING next_trans_rec-tcode.
    IF NOT mat_flag IS INITIAL.
      PERFORM create_mapl.                  "Material-Plan-Zuord.
    ENDIF.
    PERFORM create_plko.                     "Plankopf
    PERFORM create_plpo.                     "Vorgänge
    PERFORM create_plfl.                     "Planfolgen
    IF NOT fhm_flag IS INITIAL.
      PERFORM create_plfh.                  "Fertigungshilfsmittel
    ENDIF.
    IF NOT cha_flag IS INITIAL.
      PERFORM create_plmk.                   "Prüfmerkmal
    ENDIF.

*   Plan entsperren
    CALL FUNCTION 'DEQUEUE_EPPLKO'
      EXPORTING
        plnty = plty_sel
        plnnr = plnr_sel.

  ENDLOOP.


  CLOSE DATASET outfile.
ENDFORM.                    "CREATE_OUTFILE

*----------------------------------------------------------------------*
*   FORM CREATE_PLFH                                                   *
*----------------------------------------------------------------------*
*   Fertigungshilfsmittel                                              *
*----------------------------------------------------------------------*
FORM create_plfh.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Fertigungshilfsmittel
  CALL FUNCTION 'CF_DB_PLFH_READ'
    EXPORTING
      plnnr  = plnr_sel
      plnty  = plty_sel
      datuv  = stag_sel
      datub  = stag_sel
    TABLES
      planfh = plfh_tab
    EXCEPTIONS
      OTHERS = 01.

  LOOP AT plfh_tab.
    CHECK plfh_tab-loekz IS INITIAL.
    CLEAR bipfh.

    CALL FUNCTION 'CF_BT_ROUT_FHM_FROM_PLFHB_FILL'
      EXPORTING
        plfhb_imp            = plfh_tab
      IMPORTING
        plfhd_exp            = plfhd_tab
      EXCEPTIONS
        fhm_master_not_found = 1
        OTHERS               = 2.

*    move-corresponding plfhd_tab to bipfh.
*    move-corresponding plfh_tab to bipfh.
    PERFORM move_corresponding
      USING
        plfhd_tab
        'PLFHD'
        'BIPFH'
       CHANGING
        bipfh.
    PERFORM move_corresponding
      USING
        plfh_tab
        'PLFHB'
        'BIPFH'
       CHANGING
        bipfh.

    WRITE plfhd_tab-matnr TO bipfh-matnr.
    bipfh-recty = rectype-plfh.
    bipfh-plnnr = plnr_act.
*   bipfh-plnfl = const-stammfolge.
* Angabe zur VORNR aus PLPO holen
    LOOP AT plpo_tab
       WHERE plnty = plfh_tab-plnty AND
             plnnr = plfh_tab-plnnr AND
             plnkn = plfh_tab-plnkn.
      bipfh-vornr = plpo_tab-vornr.
      EXIT.
    ENDLOOP.

* Prüfung, ob Kurztext und Langtext oder Vorlagenschlüssel
    IF NOT prt_ktsc IS INITIAL.
      MOVE plfh_tab-ktsch TO bipfh-ktsch.
      MOVE '/' TO bipfh-txtz1.
    ELSE.
      MOVE '/' TO bipfh-ktsch.
    ENDIF.
    IF NOT bipfh-vornr IS INITIAL.                  "Note 878162
*    out_record = bipfh.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN bipfh      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plfh_out.
      IF NOT fhmtx_fl IS INITIAL AND
         NOT plfh_tab-txtsp IS INITIAL AND
         NOT prt_ltxt IS INITIAL.
        PERFORM create_plfhtx.
      ENDIF.
    ENDIF.                                          "Note 878162
  ENDLOOP.

ENDFORM.                    "CREATE_PLFH

*----------------------------------------------------------------------*
*   FORM CREATE_PLFHTX                                                 *
*----------------------------------------------------------------------*
*   Langtext Fertigungshilfsmittel                                     *
*----------------------------------------------------------------------*
FORM create_plfhtx.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  DATA: plpo_main LIKE plpo_tab.

* Langtext Fertigungshilfsmittel
  PERFORM textkey_plfh(saplcftx)
          USING plfh_tab-mandt
                plfh_tab-plnty
                plfh_tab-plnnr
                plfh_tab-pzlfh
                plfh_tab-zaehl
                thead-tdname.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = tca09-idfhm
      language                = plfh_tab-txtsp
      name                    = thead-tdname
      object                  = tca09-objfhm
    IMPORTING
      header                  = thead
    TABLES
      lines                   = txt_tab
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc = 0.
    CLEAR biptx.
    biptx-recty = rectype-plfhtx.
    biptx-plnty = plfh_tab-plnty.
    biptx-plnnr = plnr_act.
    biptx-plnal = plfh_tab-plnal.
    biptx-plnfl = plfh_tab-plnfl.
    biptx-vornr = bipfh-vornr.
    biptx-psnfh = plfh_tab-psnfh.
    biptx-zaehl = plfh_tab-zaehl.
    LOOP AT txt_tab.
      biptx-text = txt_tab-tdline.
      biptx-txpargraph = txt_tab-tdformat.
*      out_record = biptx.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN biptx      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plfhtx_out.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "CREATE_PLFHTX

*----------------------------------------------------------------------*
*   FORM CREATE_PLFL                                                   *
*----------------------------------------------------------------------*
*   Folge                                                              *
*----------------------------------------------------------------------*
FORM create_plfl.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CALL FUNCTION 'CP_DB_PLFL_READ'
    EXPORTING
      plnnr      = plnr_sel
      plnty      = plty_sel
      datuv      = stag_sel
      datub      = stag_sel
    TABLES
      planfl     = plfl_tab
    EXCEPTIONS
      no_records = 01.

  LOOP AT plfl_tab.
    CHECK plfl_tab-loekz IS INITIAL.
    CLEAR bipfl.
* Absprung- und Rücksprungvorgangsnummer ermitteln
    IF NOT plfl_tab-bknt2 IS INITIAL.
      READ TABLE plpo_tab WITH KEY plnkn = plfl_tab-bknt1.
      IF sy-subrc IS INITIAL.
        MOVE plpo_tab-vornr TO bipfl-vornr1.
      ENDIF.
      READ TABLE plpo_tab WITH KEY plnkn = plfl_tab-bknt2.
      MOVE plpo_tab-vornr TO bipfl-vornr2.
    ENDIF.
    MOVE-CORRESPONDING plfl_tab TO bipfl.
    bipfl-recty = rectype-plfl.
    bipfl-plnnr = plnr_act.
    WRITE plfl_tab-losvn TO bipfl-losvn UNIT plko_tab-plnme.
    WRITE plfl_tab-losbs TO bipfl-losbs UNIT plko_tab-plnme.
*    out_record = bipfl.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bipfl      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-plfl_out.
* Langtext zur Folge
    IF NOT foltx_fl IS INITIAL AND
       NOT plfl_tab-txtsp IS INITIAL.
      PERFORM create_plfltx.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "CREATE_PLFL

*----------------------------------------------------------------------*
*   FORM CREATE_PLFLTX                                                 *
*----------------------------------------------------------------------*
*   Langtext Folge                                                     *
*----------------------------------------------------------------------*
FORM create_plfltx.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Langtext Folge
  PERFORM textkey_plfl(saplcptx)
          USING plfl_tab-plnty
                plfl_tab-plnnr
                plfl_tab-plnal
                plfl_tab-plnfl
                plfl_tab-zaehl
          CHANGING
                thead-tdname.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = tca09-idseq
      language                = plfl_tab-txtsp
      name                    = thead-tdname
      object                  = tca09-objseq
    IMPORTING
      header                  = thead
    TABLES
      lines                   = txt_tab
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc = 0.
    CLEAR biptx.
    biptx-recty = rectype-plfltx.
    biptx-plnty = plfl_tab-plnty.
    biptx-plnnr = plnr_act.
    biptx-plnal = plfl_tab-plnal.
    biptx-plnfl = plfl_tab-plnfl.
    LOOP AT txt_tab.
      biptx-text = txt_tab-tdline.
      biptx-txpargraph = txt_tab-tdformat.
*      out_record = biptx.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN biptx      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plfltx_out.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "CREATE_PLFLTX

*----------------------------------------------------------------------*
*   FORM CREATE_PLKO                                                   *
*----------------------------------------------------------------------*
*   Kopf                                                               *
*----------------------------------------------------------------------*
FORM create_plko.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CALL FUNCTION 'CP_DB_PLKO_READ'
    EXPORTING
      plnnr      = plnr_sel
      plnty      = plty_sel
      datuv      = stag_sel
      datub      = stag_sel
    TABLES
      planko     = plko_tab
    EXCEPTIONS
      no_records = 1
      OTHERS     = 2.

  LOOP AT plko_tab.
    CHECK plko_tab-loekz IS INITIAL.
    CLEAR bipko.
    MOVE-CORRESPONDING plko_tab TO bipko.
    bipko-profidnetz = prof_new.
    bipko-recty = rectype-plko.
    bipko-plnnr = plnr_act.
    WRITE sy-datum TO bipko-datuv.             "wg. Format
    WRITE plko_tab-losvn TO bipko-losvn UNIT plko_tab-plnme.  "wg. Format
    WRITE plko_tab-losbs TO bipko-losbs UNIT plko_tab-plnme.  "wg. Format
    WRITE plko_tab-plnme TO bipko-plnme.
    MOVE '/' TO bipko-extnum.
    IF NOT plko_tab-extnum IS INITIAL.
      MOVE plko_tab-extnum TO bipko-extnum.
    ENDIF.
*    out_record = bipko.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bipko      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-plko_out.
* Langtext
    IF NOT koptx_fl IS INITIAL AND
       NOT plko_tab-txtsp IS INITIAL.
      PERFORM create_plkotx.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "CREATE_PLKO

*----------------------------------------------------------------------*
*   FORM CREATE_PLKOTX                                                 *
*----------------------------------------------------------------------*
*   Langtext Kopf
*----------------------------------------------------------------------*
FORM create_plkotx.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Langtext Kopf
  PERFORM textkey_plko(saplcptx)
          USING plko_tab-plnty
                plko_tab-plnnr
                plko_tab-plnal
                plko_tab-zaehl
          CHANGING
                thead-tdname.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = tca09-idalt
      language                = plko_tab-txtsp
      name                    = thead-tdname
      object                  = tca09-objalt
    IMPORTING
      header                  = thead
    TABLES
      lines                   = txt_tab
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc = 0.
    CLEAR biptx.
    biptx-recty = rectype-plkotx.
    biptx-plnty = plko_tab-plnty.
    biptx-plnnr = plnr_act.
    biptx-plnal = plko_tab-plnal.
    LOOP AT txt_tab.
      biptx-text = txt_tab-tdline.
      biptx-txpargraph = txt_tab-tdformat.
*      out_record = biptx.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN biptx      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plkotx_out.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "CREATE_PLKOTX

*----------------------------------------------------------------------*
*   FORM CREATE_PLMZ                                                   *
*----------------------------------------------------------------------*
*   Materialkomponenten auslesen                                       *
*----------------------------------------------------------------------*
FORM create_plmz.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  LOOP AT plmz_tab."  WHERE STLTY_W = TOPMAT-STLTY   wird unten
    "    AND STLNR_W = TOPMAT-STLNR   abgeprüft und
    "    AND STLAL_W = TOPMAT-STLAL.  stört bei
    "                                 Altdaten
    CLEAR bipmz.
* Prüfen, ob die Komponente zum aktuellen MAPL-Satz gehört
    CHECK plmz_tab-loekz IS INITIAL.

    IF plmz_tab-stlty_w NE space AND
       plmz_tab-stlnr_w NE space AND
       plmz_tab-stlal_w NE space.
      READ TABLE stpox_tab WITH KEY stlty   = plmz_tab-stlty
                                    stlnr   = plmz_tab-stlnr
                                    stlal   = plmz_tab-stlal
                                    stvkn   = plmz_tab-stlkn
                                    stlty_w = plmz_tab-stlty_w
                                    stlnr_w = plmz_tab-stlnr_w
                                    stlal_w = plmz_tab-stlal_w
                                    kante   = plmz_tab-kante.
    ELSE.
      READ TABLE stpox_tab WITH KEY stlty = plmz_tab-stlty
                                    stlnr = plmz_tab-stlnr
                                    stlal = plmz_tab-stlal
                                    stvkn = plmz_tab-stlkn
                                    aufst = plmz_tab-stlst
                                    aufwg = plmz_tab-stlwg.
    ENDIF.

    CHECK sy-subrc IS INITIAL.

* Komponentennamen in die BIPMZ schieben
    WRITE stpox_tab-idnrk TO bipmz-matnr.

* Alles Bekannte in die BIPMZ schieben
    MOVE-CORRESPONDING plmz_tab TO bipmz.
*  WRITE PLMZ_TAB-STLST TO BIPMZ-AUFST.
*  WRITE PLMZ_TAB-STLWG TO BIPMZ-AUFWG.
    WRITE stpox_tab-aufst TO bipmz-aufst.
    WRITE stpox_tab-aufwg TO bipmz-aufwg.

    WRITE mapl_auf-matnr TO bipmz-bomat.
    WRITE topmat-stlty   TO bipmz-bomty.
* wird automatisch ermittelt, da anders im ext.System
* write mapl_auf-stlnr to bipmz-bomnr.
    MOVE  mapl_auf-stlal TO bipmz-bomal.
    WRITE mapl_auf-stlan TO bipmz-boman.
    bipmz-recty = rectype-plmz.
    bipmz-plnnr = plnr_act.
    MOVE mapl_auf-werks TO bipmz-werks.
* Ermittlung Vorgangsnummer mithilfe von PLPO.
    SELECT * FROM plpo
       WHERE plnty = plmz_tab-plnty AND
             plnnr = plmz_tab-plnnr AND
             plnkn = plmz_tab-plnkn.
      bipmz-vornr = plpo-vornr.
    ENDSELECT.
* Wegen automatischer Ermittlung im Zielsystem STLNR, STLAL initial
* setzen und STLKN entsprechend vorbelegen
    CLEAR bipmz-stlnr.
    WRITE '*POS' TO bipmz-stlkn.
* Positionsnummer auch angeben, wichtig wenn eine Komponente zweimal
* in der Stückliste verwendet wird
    CONCATENATE '*POS' stpox_tab-posnr INTO bipmz-stlkn.

* Write to dataset
*    out_record = bipmz.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bipmz      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-plmz_out.
    DELETE plmz_tab.
  ENDLOOP.
ENDFORM.                    "CREATE_PLMZ

*----------------------------------------------------------------------*
*   FORM CREATE_PLPO                                                   *
*----------------------------------------------------------------------*
*   Vorgang                                                            *
*----------------------------------------------------------------------*
FORM create_plpo.

  DATA:
    l_plko-slwbez             LIKE plko-slwbez.   "QM
  DATA rcr01_tmp LIKE  rcr01.

  FIELD-SYMBOLS <p>.
  FIELD-SYMBOLS <b>.
  FIELD-SYMBOLS <c>.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

  CALL FUNCTION 'CP_DB_PLAS_READ'
    EXPORTING
      datub      = stag_sel
      datuv      = stag_sel
      plnnr      = plnr_sel
      plnty      = plty_sel
    TABLES
      planas     = plas_tab
    EXCEPTIONS
      no_records = 1
      OTHERS     = 2.

  DELETE plas_tab WHERE NOT loekz IS INITIAL.

  CALL FUNCTION 'CP_DB_PLPO_READ_BY_PLAS_EXT'
    EXPORTING
      plnnr    = plnr_sel
      plnty    = plty_sel
      sttag    = stag_sel
    TABLES
      plas_imp = plas_tab
      plpo_exp = plpo_tab
    EXCEPTIONS
      OTHERS   = 1.

  LOOP AT plpo_tab.
    CHECK plpo_tab-loekz IS INITIAL.

    IF NOT plpo_tab-vplnr IS INITIAL.
* Prüfung, ob Referenz existiert

      CALL FUNCTION 'CP_BT_PLAN_READ_FROM_DB_EXT'
        EXPORTING
          plnal_imp = plpo_tab-vplal
          plnnr_imp = plpo_tab-vplnr
          plnty_imp = 'S'
          sttag_imp = stag_sel
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.

      CHECK sy-subrc IS INITIAL.
    ENDIF.
    CLEAR bippo.
* PLPOD notwendig, da PLPOB keine Angaben zu ARBPL, UVORN, etc.
* enthält.
    CALL FUNCTION 'CP_00_PLPOB_PLPOD_TRANSFER'
      EXPORTING
        plpob_imp = plpo_tab
        sttag_imp = stag_sel
      IMPORTING
        plpod_exp = plpod_tab
        rcr01_exp = rcr01_tmp
      EXCEPTIONS
        OTHERS    = 1.
    MOVE-CORRESPONDING plpo_tab TO bippo.
    LOOP AT plpo_lst
         WHERE datatype = 'QUAN'  OR
               datatype = 'DEC'   OR
               datatype = 'CHAR'  OR
               datatype = 'WAERS' OR
               datatype = 'NUMC'  OR
               datatype = 'CURR'  OR
               datatype = 'DATS'  OR
               datatype = 'UNIT'.
      READ TABLE bippo_lst WITH KEY fieldname = plpo_lst-fieldname.
      IF sy-subrc IS INITIAL.
        ASSIGN COMPONENT plpo_lst-fieldname
               OF STRUCTURE plpo_tab TO <p>.
        ASSIGN COMPONENT bippo_lst-fieldname
               OF STRUCTURE bippo TO <b>.
        IF NOT <p> IS INITIAL.
          WRITE <p> TO <b>.
        ELSE.
          CLEAR <b>.
          WRITE '/' TO <b>.
        ENDIF.
      ENDIF.
    ENDLOOP.

* Vorgabewerte, Leistungsarten, etc.
    IF plpo_tab-lar01 IS INITIAL. MOVE '/' TO bippo-lar01. ENDIF.
    IF plpo_tab-vge01 IS INITIAL. MOVE '/' TO bippo-vge01. ENDIF.
    IF plpo_tab-vgw01 IS INITIAL. MOVE '/' TO bippo-vgw01. ENDIF.
    IF plpo_tab-lar02 IS INITIAL. MOVE '/' TO bippo-lar02. ENDIF.
    IF plpo_tab-vge02 IS INITIAL. MOVE '/' TO bippo-vge02. ENDIF.
    IF plpo_tab-vgw02 IS INITIAL. MOVE '/' TO bippo-vgw02. ENDIF.
    IF plpo_tab-lar03 IS INITIAL. MOVE '/' TO bippo-lar03. ENDIF.
    IF plpo_tab-vge03 IS INITIAL. MOVE '/' TO bippo-vge03. ENDIF.
    IF plpo_tab-vgw03 IS INITIAL. MOVE '/' TO bippo-vgw03. ENDIF.
    IF plpo_tab-lar04 IS INITIAL. MOVE '/' TO bippo-lar04. ENDIF.
    IF plpo_tab-vge04 IS INITIAL. MOVE '/' TO bippo-vge04. ENDIF.
    IF plpo_tab-vgw04 IS INITIAL. MOVE '/' TO bippo-vgw04. ENDIF.
    IF plpo_tab-lar05 IS INITIAL. MOVE '/' TO bippo-lar05. ENDIF.
    IF plpo_tab-vge05 IS INITIAL. MOVE '/' TO bippo-vge05. ENDIF.
    IF plpo_tab-vgw05 IS INITIAL. MOVE '/' TO bippo-vgw05. ENDIF.
    IF plpo_tab-lar06 IS INITIAL. MOVE '/' TO bippo-lar06. ENDIF.
    IF plpo_tab-vge06 IS INITIAL. MOVE '/' TO bippo-vge06. ENDIF.
    IF plpo_tab-vgw06 IS INITIAL. MOVE '/' TO bippo-vgw06. ENDIF.

* Wenn Referenzkennzeichen im Arbeitsplatz gesetzt, dann auch
* keine Werte übernehmen.

    IF rcr01_tmp-ktsch_ref = const-flg_yes.
      MOVE '/' TO bippo-ktsch.
    ENDIF.
    IF rcr01_tmp-lar01_ref = const-flg_yes.
      MOVE '/' TO bippo-lar01.
    ENDIF.
    IF rcr01_tmp-lar02_ref = const-flg_yes.
      MOVE '/' TO bippo-lar02.
    ENDIF.
    IF rcr01_tmp-lar03_ref = const-flg_yes.
      MOVE '/' TO bippo-lar03.
    ENDIF.
    IF rcr01_tmp-lar04_ref = const-flg_yes.
      MOVE '/' TO bippo-lar04.
    ENDIF.
    IF rcr01_tmp-lar05_ref = const-flg_yes.
      MOVE '/' TO bippo-lar05.
    ENDIF.
    IF rcr01_tmp-lar06_ref = const-flg_yes.
      MOVE '/' TO bippo-lar06.
    ENDIF.
*  IF RCR01_TMP-LARN1_REF = CONST-FLG_YES.               "nicht in BIPPO
*   MOVE '/' TO BIPPO-LARN1. ENDIF.
    IF rcr01_tmp-loanz_ref = const-flg_yes.
      MOVE '/' TO bippo-loanz.
    ENDIF.
    IF rcr01_tmp-loart_ref = const-flg_yes.
      MOVE '/' TO bippo-loart.
    ENDIF.
    IF rcr01_tmp-logrp_ref = const-flg_yes.
      MOVE '/' TO bippo-logrp.
    ENDIF.
    IF rcr01_tmp-qualf_ref = const-flg_yes.
      MOVE '/' TO bippo-qualf.
    ENDIF.
    IF rcr01_tmp-rasch_ref = const-flg_yes.
      MOVE '/' TO bippo-rasch.
    ENDIF.
    IF rcr01_tmp-rsanz_ref = const-flg_yes.
      MOVE '/' TO bippo-rsanz.
    ENDIF.
    IF rcr01_tmp-steus_ref = const-flg_yes.
      MOVE '/' TO bippo-steus.
    ENDIF.
*  IF RCR01_TMP-ZGR01_REF = CONST-FLG_YES.               "nicht in BIPPO
*    MOVE '/' TO BIPPO-ZGR01. ENDIF.
*  IF RCR01_TMP-ZGR02_REF = CONST-FLG_YES.
*    MOVE '/' TO BIPPO-ZGR02. ENDIF.
*  IF RCR01_TMP-ZGR03_REF = CONST-FLG_YES.
*    MOVE '/' TO BIPPO-ZGR03. ENDIF.
*  IF RCR01_TMP-ZGR04_REF = CONST-FLG_YES.
*    MOVE '/' TO BIPPO-ZGR04. ENDIF.
*  IF RCR01_TMP-ZGR05_REF = CONST-FLG_YES.
*    MOVE '/' TO BIPPO-ZGR05. ENDIF.
*  IF RCR01_TMP-ZGR06_REF = CONST-FLG_YES.
*    MOVE '/' TO BIPPO-ZGR06. ENDIF.
    IF rcr01_tmp-slwid_ref = const-flg_yes.
      MOVE '/' TO bippo-slwid.
    ENDIF.
    IF rcr01_tmp-lifnr_ref = const-flg_yes.
      MOVE '/' TO bippo-lifnr.
    ENDIF.
    IF rcr01_tmp-prz01_ref = const-flg_yes.
      MOVE '/' TO bippo-prz01.
    ENDIF.

    bippo-vplnnr = plpo_tab-vplnr.
    bippo-vplnal = plpo_tab-vplal.
    IF NOT bippo-vplnal IS INITIAL.
      bippo-vplflg = 'X'.
    ELSE.
      bippo-vplflg = ''.
    ENDIF.
    bippo-recty = rectype-plpo.
    bippo-plnnr = plnr_act.
* Angaben zur Planalternative und -folge aus PLAS holen
    SELECT * FROM plas WHERE
       plnty = plpo_tab-plnty AND
       plnnr = plpo_tab-plnnr AND
       ( plnkn = plpo_tab-plnkn OR plnkn = plpo_tab-sumnr ).
      bippo-plnal = plas-plnal.
      bippo-plnfl = plas-plnfl.
    ENDSELECT.
    bippo-arbpl = plpod_tab-arbpl.
    bippo-uvorn = plpod_tab-uvorn.
* Prüfung, ob Kurztext und Langtext oder Vorlagenschlüssel
    IF NOT ktsch_fl IS INITIAL.
      MOVE plpo_tab-ktsch TO bippo-ktsch.
      MOVE '/' TO bippo-ltxa1.
    ELSE.
      MOVE '/' TO bippo-ktsch.
    ENDIF.
* Check ob Untervorgang: Falls ja, holen Hauptvorgangsnummer und
* Nodata-Kennzeichen in alle nicht relevanten Dynprofelder
    IF NOT plpo_tab-sumnr IS INITIAL.
      MOVE '/' TO bippo-uemus.
      MOVE '/' TO bippo-uekan.
      MOVE '/' TO bippo-flies.
      MOVE '/' TO bippo-zeimu.
      MOVE '/' TO bippo-zminu.
      MOVE '/' TO bippo-minwe.
      MOVE '/' TO bippo-spmus.
      MOVE '/' TO bippo-splim.
      MOVE '/' TO bippo-zeimb.
      MOVE '/' TO bippo-zminb.
      MOVE '/' TO bippo-zeilm.
      MOVE '/' TO bippo-zlmax.
      MOVE '/' TO bippo-zeilp.
      MOVE '/' TO bippo-zlpro.
      MOVE '/' TO bippo-zeiwn.
      MOVE '/' TO bippo-zwnor.
      MOVE '/' TO bippo-zeiwm.
      MOVE '/' TO bippo-zwmin.
      MOVE '/' TO bippo-zeitn.
      MOVE '/' TO bippo-ztnor.
      MOVE '/' TO bippo-zeitm.
      MOVE '/' TO bippo-ztmin.
      MOVE '/' TO bippo-ablipkz.
      MOVE '/' TO bippo-rstra.
      MOVE '/' TO bippo-verdart.
      MOVE '/' TO bippo-uavo_aufl.
      SELECT vornr FROM plpo
             INTO bippo-vornr
             WHERE plnty = plpo_tab-plnty AND
                   plnnr = plpo_tab-plnnr AND
                   plnkn = plpo_tab-sumnr.
      ENDSELECT.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-bzoffb IS INITIAL.
      MOVE '/' TO bippo-bzoffb.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-offstb IS INITIAL.
      MOVE '/' TO bippo-offstb.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-ehoffb IS INITIAL.
      MOVE '/' TO bippo-ehoffb.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-bzoffe IS INITIAL.
      MOVE '/' TO bippo-bzoffe.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-offste IS INITIAL.
      MOVE '/' TO bippo-offste.
    ENDIF.
    IF plpo_tab-sumnr IS INITIAL OR plpo_tab-ehoffe IS INITIAL.
      MOVE '/' TO bippo-ehoffe.
    ENDIF.
    MOVE '/' TO bippo-uenicht.
    IF NOT plpod_tab-uenicht IS INITIAL AND plpod_tab-sumnr IS INITIAL.
      bippo-uenicht = plpod_tab-uenicht.
    ENDIF.
* Check der Benutzerfelder
    MOVE: '/' TO bippo-usr00,
          '/' TO bippo-usr01,
          '/' TO bippo-usr02,
          '/' TO bippo-usr03,
          '/' TO bippo-usr04, '/' TO bippo-use04,
          '/' TO bippo-usr05, '/' TO bippo-use05,
          '/' TO bippo-usr06, '/' TO bippo-use06,
          '/' TO bippo-usr07, '/' TO bippo-use07,
          '/' TO bippo-usr08,
          '/' TO bippo-usr09,
          '/' TO bippo-usr10,
          '/' TO bippo-usr11.
    IF NOT plpo_tab-slwid IS INITIAL.
      SELECT * FROM tcn01 WHERE slwid EQ plpo_tab-slwid AND
                                spras EQ sy-langu.
        EXIT.
      ENDSELECT.
      IF sy-subrc IS INITIAL.
        IF NOT tcn01-swrt0  IS INITIAL.
          WRITE plpo_tab-usr00 TO bippo-usr00.
        ENDIF.
        IF NOT tcn01-swrt1  IS INITIAL.
          WRITE plpo_tab-usr01 TO bippo-usr01.
        ENDIF.
        IF NOT tcn01-swrt2  IS INITIAL.
          WRITE plpo_tab-usr02 TO bippo-usr02.
        ENDIF.
        IF NOT tcn01-swrt3  IS INITIAL.
          WRITE plpo_tab-usr03 TO bippo-usr03.
        ENDIF.
        IF NOT tcn01-swrt4  IS INITIAL.
          WRITE plpo_tab-usr04 TO bippo-usr04 UNIT plpo_tab-use04.
          WRITE plpo_tab-use04 TO bippo-use04.
        ENDIF.
        IF NOT tcn01-swrt5  IS INITIAL.
          WRITE plpo_tab-usr05 TO bippo-usr05 UNIT plpo_tab-use05.
          WRITE plpo_tab-use05 TO bippo-use05.
        ENDIF.
        IF NOT tcn01-swrt6  IS INITIAL.
          MOVE plpo_tab-usr06 TO bippo-usr06.
          WRITE plpo_tab-use06 TO bippo-use06.
        ENDIF.
        IF NOT tcn01-swrt7  IS INITIAL.
          MOVE plpo_tab-usr07 TO bippo-usr07.
          WRITE plpo_tab-use07 TO bippo-use07.
        ENDIF.
        IF NOT tcn01-swrt8  IS INITIAL.
          WRITE plpo_tab-usr08 TO bippo-usr08.
          IF plpo_tab-usr08 IS INITIAL. MOVE ' ' TO bippo-usr08. ENDIF.
        ENDIF.
        IF NOT tcn01-swrt9  IS INITIAL.
          WRITE plpo_tab-usr09 TO bippo-usr09.
          IF plpo_tab-usr09 IS INITIAL. MOVE ' ' TO bippo-usr09. ENDIF.
        ENDIF.
        IF NOT tcn01-swrt10 IS INITIAL.
          WRITE plpo_tab-usr10 TO bippo-usr10.
        ENDIF.
        IF NOT tcn01-swrt11 IS INITIAL.
          WRITE plpo_tab-usr11 TO bippo-usr11.
        ENDIF.
      ENDIF.
    ENDIF.
* allg. Sicht
    WRITE plpo_tab-aufak TO bippo-aufak.


* Nicht eingabebereite Dynprofelder ausfiltern:
* Daten zur Dynamisierung aus PLKO holen
    LOOP AT plko_tab
       WHERE plnty = plpo_tab-plnty AND
             plnnr = plpo_tab-plnnr AND
             plnal = plas-plnal.
      l_plko-slwbez   = plko_tab-slwbez.
      EXIT.
    ENDLOOP.
    IF l_plko-slwbez IS INITIAL. bippo-qppktabs = '/'. ENDIF.


* Check der Nodata-Kennzeichen
    LOOP AT bippo_lst.
      ASSIGN COMPONENT bippo_lst-fieldname
             OF STRUCTURE bippo TO <c>.
      IF <b> IS INITIAL.
        WRITE '/' TO <c>.
      ENDIF.
    ENDLOOP.

*      out_record = bippo.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bippo      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-plpo_out.
* Langtext zum Vorgang
    IF NOT vortx_fl IS INITIAL AND
       NOT plpo_tab-txtsp IS INITIAL.
      PERFORM create_plpotx.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "CREATE_PLPO

*----------------------------------------------------------------------*
*   FORM CREATE_PLPOTX                                                 *
*----------------------------------------------------------------------*
*   Langtext Vorgang                                                   *
*----------------------------------------------------------------------*
FORM create_plpotx.

  DATA: plpo_main LIKE plpo_tab.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Langtext Vorgang
  PERFORM textkey_plpo(saplcptx)
          USING plpo_tab-plnty
                plpo_tab-plnnr
                plpo_tab-plnkn
                plpo_tab-zaehl
          CHANGING
                thead-tdname.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = tca09-idopr
      language                = plpo_tab-txtsp
      name                    = thead-tdname
      object                  = tca09-objopr
    IMPORTING
      header                  = thead
    TABLES
      lines                   = txt_tab
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc = 0.
    CLEAR biptx.
    biptx-recty = rectype-plpotx.
    biptx-plnty = plpo_tab-plnty.
    biptx-plnnr = plnr_act.
    biptx-plnal = bippo-plnal.
    biptx-plnfl = bippo-plnfl.
    biptx-vornr = plpo_tab-vornr.
    IF NOT plpo_tab-sumnr IS INITIAL.
      biptx-uvorn = plpo_tab-vornr.
      READ TABLE plpo_tab WITH KEY
                           plnty = plpo_tab-plnty
                           plnnr = plpo_tab-plnnr
                           plnkn = plpo_tab-sumnr
                         INTO plpo_main.
      biptx-vornr = plpo_main-vornr.
    ENDIF.
    LOOP AT txt_tab.
      biptx-text = txt_tab-tdline.
      biptx-txpargraph = txt_tab-tdformat.
*      out_record = biptx.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN biptx      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plpotx_out.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "CREATE_PLPOTX


*----------------------------------------------------------------------*
*   FORM INIT_FIELDTABS.
*----------------------------------------------------------------------*
*   Initialisierung der Feldlisten
*----------------------------------------------------------------------*
FORM init_fieldtabs.

  CALL FUNCTION 'GET_FIELDTAB'
    EXPORTING
      tabname             = 'PLPO'
    TABLES
      fieldtab            = plpo_lst
    EXCEPTIONS
      internal_error      = 1
      no_texts_found      = 2
      table_has_no_fields = 3
      table_not_activ     = 4
      OTHERS              = 5.

  CALL FUNCTION 'GET_FIELDTAB'
    EXPORTING
      tabname             = 'BIPPO'
    TABLES
      fieldtab            = bippo_lst
    EXCEPTIONS
      internal_error      = 1
      no_texts_found      = 2
      table_has_no_fields = 3
      table_not_activ     = 4
      OTHERS              = 5.

* get field names of structure plmk (characteristics)
  CALL FUNCTION 'GET_FIELDTAB'
    EXPORTING
      tabname             = 'PLMK'
    TABLES
      fieldtab            = plmk_lst
    EXCEPTIONS
      internal_error      = 1
      no_texts_found      = 2
      table_has_no_fields = 3
      table_not_activ     = 4
      OTHERS              = 5.

* get field names of structure bipmk (characteristics from Batch input)
  CALL FUNCTION 'GET_FIELDTAB'
    EXPORTING
      tabname             = 'BIPMK'
    TABLES
      fieldtab            = bipmk_lst
    EXCEPTIONS
      internal_error      = 1
      no_texts_found      = 2
      table_has_no_fields = 3
      table_not_activ     = 4
      OTHERS              = 5.

ENDFORM.                    "INIT_FIELDTABS
*----------------------------------------------------------------------*
*   FORM INIT_TXTKEY
*----------------------------------------------------------------------*
*   Initialisierung der Werte zur Langtextselektion
*----------------------------------------------------------------------*
FORM init_txtkey.

  CALL FUNCTION 'TCA01_READ'
    EXPORTING
      plnty    = plty_sel
    IMPORTING
      struct   = tca01
    EXCEPTIONS
      no_entry = 1
      OTHERS   = 2.
  IF sy-subrc = 0.
    CALL FUNCTION 'TCA09_READ'
      EXPORTING
        plnaw    = tca01-plnaw
      IMPORTING
        struct   = tca09
      EXCEPTIONS
        no_entry = 1
        OTHERS   = 2.
  ENDIF.
ENDFORM.                    "INIT_TXTKEY
*----------------------------------------------------------------------*
*   FORM OPEN_FILE
*----------------------------------------------------------------------*
*   seq. Ausgabedatei öffnen
*----------------------------------------------------------------------*
FORM open_file.

* Begin of Note_1796578
*  CALL FUNCTION 'FILE_VALIDATE_NAME'
*    EXPORTING
*      LOGICAL_FILENAME                 = gc_logical_filename
*    CHANGING
*      PHYSICAL_FILENAME                = outfile
*    EXCEPTIONS
*      LOGICAL_FILENAME_NOT_FOUND       = 1
*      VALIDATION_FAILED                = 2.
*
*  IF sy-subrc <> 0.
*    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
*      RAISING open_error.
*  ENDIF.

  DATA: l_dirname TYPE dirname_al11.

  CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'DIR_GLOBAL'
                     ID 'VALUE' FIELD l_dirname.

  outfile = l_dirname && '/prueba.txt'.
* End of Note_1796578

  OPEN DATASET outfile FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
  IF sy-subrc NE 0.
    MESSAGE a894 WITH outfile.
  ENDIF.

ENDFORM.                    "OPEN_FILE

*----------------------------------------------------------------------*
*   FORM PRINT_COUNTERS                                                *
*                                                                      *
*   Verarbeitungszähler auf Liste ausgeben                             *
*----------------------------------------------------------------------*
FORM print_counters.

  NEW-PAGE.
  WRITE /1 text-001.
  ULINE.
  WRITE: /1 text-002,
            cnt-mapl_out.
  WRITE: /1 text-003,
            cnt-eapl_out.
  WRITE: /1 text-004,
            cnt-plko_out.
  WRITE: /1 text-005,
            cnt-plkotx_out.
  WRITE: /1 text-006,
            cnt-plfl_out.
  WRITE: /1 text-007,
            cnt-plfltx_out.
  WRITE: /1 text-008,
            cnt-plab_out.
  WRITE: /1 text-009,
            cnt-pltx_out.
  WRITE: /1 text-010,
            cnt-plpo_out.
  WRITE: /1 text-011,
            cnt-plpotx_out.
  WRITE: /1 text-012,
            cnt-plfh_out.
  WRITE: /1 text-013,
            cnt-plfhtx_out.
  WRITE: /1 text-014,
            cnt-plmz_out.
  WRITE: /1 text-015,
            cnt-plph_out.
  WRITE: /1 text-016,
            cnt-plft_out.
  WRITE: /1 text-017,
            cnt-plfv_out.
  WRITE: /1 text-018,
            cnt-plwp_out.
  WRITE: /1 text-019,
            cnt-plmk_out.
*  write: /1 text-020,
*            cnt-plmw_out.
  WRITE: /1 text-021,
            cnt-plmktx_out.

ENDFORM.                    "PRINT_COUNTERS

*&---------------------------------------------------------------------*
*&      Form  CREATE_PLMK
*&---------------------------------------------------------------------*
*       Prüfmerkmal
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM create_plmk.

  DATA: l_plko-slwbez   LIKE plko-slwbez,
        l_plko-qdynhead LIKE plko-qdynhead,
        l_qmkst         LIKE qmkst,
        l_qdynkrit      LIKE qdynkrit.
  FIELD-SYMBOLS: <plmk_field>,
                 <bipmk_field> .

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Merkmal
  CALL FUNCTION 'CQ_DB_PLMK_READ'
    EXPORTING
      datub      = stag_sel
      datuv      = stag_sel
*     plnal      = ' '
      plnnr      = plnr_sel
      plnty      = plty_sel
*    IMPORTING
*     FLG_NOT_FOUND  =
*     ZAEHL_MAX_PLMK =
    TABLES
      planmk     = plmk_tab
    EXCEPTIONS
      no_records = 1
      OTHERS     = 2.

  IF sy-subrc <> 0.
*  message id sy-msgid type sy-msgty number sy-msgno
*          with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.


  LOOP AT plmk_tab.
    CHECK plmk_tab-loekz IS INITIAL.
    CLEAR bipmk.

*   move-corresponding plmk_tab to bipmk.   geht nicht wegen Domänen

    LOOP AT plmk_lst.
*     gibt es ein namensgleiches Feld in BIPMK ?
      READ TABLE bipmk_lst WITH KEY fieldname = plmk_lst-fieldname.
      IF sy-subrc IS INITIAL.
*       es gibt ein namensgleiches Feld
        ASSIGN COMPONENT plmk_lst-fieldname
                   OF STRUCTURE plmk_tab TO <plmk_field>.
        ASSIGN COMPONENT bipmk_lst-fieldname
                   OF STRUCTURE bipmk TO <bipmk_field>.
        IF NOT <plmk_field> IS INITIAL.
          WRITE <plmk_field> TO <bipmk_field>(bipmk_lst-leng).
        ELSE.
*         initial fields are not relevant for batch input
          CLEAR <bipmk_field>.
          WRITE '/' TO <bipmk_field>.
        ENDIF.
      ELSE.
*     es gibt kein namensgleiches Feld in bipmk
      ENDIF.
    ENDLOOP. "at plmk_lst.


*   special cases: unit conversion
    IF NOT plmk_tab-masseinhsw IS INITIAL.
      WRITE plmk_tab-masseinhsw TO bipmk-masseinhsw
            USING EDIT MASK '==LUNIT'.
    ELSE.
      WRITE '/' TO bipmk-masseinhsw.
    ENDIF.

*   special cases: initial fields that are relevant for batch input
    IF plmk_tab-steuerkz(1) EQ 'X'.
*     quantitative characteristic
*     special logic for floating point fields

      IF ( plmk_tab-sollwert IS INITIAL AND     "target value
         NOT plmk_tab-sollwni IS INITIAL ) .
        MOVE '0' TO bipmk-sollwert.
      ENDIF.
      IF ( plmk_tab-toleranzun IS INITIAL AND   "lower limit
         NOT plmk_tab-tolunni IS INITIAL ) .
        MOVE '0' TO bipmk-toleranzun.
      ENDIF.
      IF ( plmk_tab-toleranzob IS INITIAL AND   "upper limit
         NOT plmk_tab-tolobni IS INITIAL ) .
        MOVE '0' TO bipmk-toleranzob.
      ENDIF.
      IF ( plmk_tab-klasmitte IS INITIAL AND    "class midpoint
         NOT plmk_tab-klasmini IS INITIAL ) .
        MOVE '0' TO bipmk-klasmitte.
      ENDIF.
      IF ( plmk_tab-klasbreite IS INITIAL AND   "class width
         NOT plmk_tab-klasbrni IS INITIAL ) .
        MOVE '0' TO bipmk-klasbreite.
      ENDIF.
      IF ( plmk_tab-grenzeob1 IS INITIAL AND    "upper limit 1
         NOT plmk_tab-grenzob1ni IS INITIAL ) .
        MOVE '0' TO bipmk-grenzeob1.
      ENDIF.
      IF ( plmk_tab-grenzeun1 IS INITIAL AND    "lower limit 1
         NOT plmk_tab-grenzun1ni IS INITIAL ) .
        MOVE '0' TO bipmk-grenzeun1.
      ENDIF.
      IF ( plmk_tab-grenzeun2 IS INITIAL AND    "lower limit 2
         NOT plmk_tab-grenzun2ni IS INITIAL ) .
        MOVE '0' TO bipmk-grenzeun2.
      ENDIF.
      IF ( plmk_tab-grenzeob2 IS INITIAL AND    "upper limit 2
         NOT plmk_tab-grenzob2ni IS INITIAL ) .
        MOVE '0' TO bipmk-grenzeob2.
      ENDIF.
      IF ( plmk_tab-plausiunte IS INITIAL AND   "lower plausi limit
         NOT plmk_tab-plausiunni IS INITIAL ) .
        MOVE '0' TO bipmk-plausiunte.
      ENDIF.
      IF ( plmk_tab-plausioben IS INITIAL AND   "upper plausi limit
         NOT plmk_tab-plausiobni IS INITIAL ) .
        MOVE '0' TO bipmk-plausioben.
      ENDIF.
      IF ( plmk_tab-tolerweiun IS INITIAL AND   "lower limit extension
         NOT plmk_tab-tolwunni IS INITIAL ) .
        MOVE '0' TO bipmk-tolerweiun.
      ENDIF.
      IF ( plmk_tab-tolerweiob IS INITIAL AND   "upper limit extension
         NOT plmk_tab-tolwobni IS INITIAL ) .
        MOVE '0' TO bipmk-tolerweiob.
      ENDIF.

    ENDIF. " PLMK_TAB-STEUERKZ(1) EQ 'X'.


* Übernehme nicht namensgleiche Felder
    MOVE plmk_tab-steuerkz TO l_qmkst.
    MOVE-CORRESPONDING l_qmkst TO bipmk.
* FHM übernehmen
    IF plmk_tab-pzlfh IS INITIAL.
      bipmk-psnfh = '/'.
    ELSE.
      READ TABLE plfh_tab WITH KEY pzlfh = plmk_tab-pzlfh.
      IF sy-subrc IS INITIAL.
        bipmk-psnfh = plfh_tab-psnfh.
      ENDIF.
    ENDIF.

    bipmk-recty = rectype-plmk.
    bipmk-plnnr = plnr_act.
    bipmk-plnfl = const-stammfolge.

    bipmk-vsteuerkz = '/'.


* Angabe zur VORNR aus PLPO holen
    LOOP AT plpo_tab
       WHERE plnty = plmk_tab-plnty AND
             plnnr = plmk_tab-plnnr AND
             plnkn = plmk_tab-plnkn.
      bipmk-vornr = plpo_tab-vornr.
      EXIT.
    ENDLOOP.

* Angabe zur PLNAL aus PLAS holen
    LOOP AT plas_tab
       WHERE plnty = plmk_tab-plnty AND
             plnnr = plmk_tab-plnnr AND
             plnkn = plmk_tab-plnkn.
      bipmk-plnal = plas_tab-plnal.
      bipmk-plnfl = plas_tab-plnfl.                         "N_1949001
      EXIT.
    ENDLOOP.

* Daten zur Dynamisierung aus PLKO holen
    LOOP AT plko_tab
       WHERE plnty = plmk_tab-plnty AND
             plnnr = plmk_tab-plnnr AND
             plnal = plas_tab-plnal.
      l_plko-qdynhead = plko_tab-qdynhead.
      EXIT.
    ENDLOOP.

* Dynamisierungskriterien: liefkz, herstkz, kundkz (tq39_read)
    IF l_plko-qdynhead = '3'.
      MOVE plmk_tab-dynkrit TO l_qdynkrit.
    ELSE.
      MOVE '//////' TO l_qdynkrit.
    ENDIF.
    MOVE-CORRESPONDING l_qdynkrit TO bipmk.

* Kennzeichen: Nicht initial auswerten bei numerischen Zahlen.
    IF plmk_tab-sollwni    <> 'X'. bipmk-sollwert   = '/'. ENDIF.
    IF plmk_tab-tolobni    <> 'X'. bipmk-toleranzob = '/'. ENDIF.
    IF plmk_tab-tolunni    <> 'X'. bipmk-toleranzun = '/'. ENDIF.
    IF plmk_tab-klasbrni   <> 'X'. bipmk-klasbreite = '/'. ENDIF.
    IF plmk_tab-klasmini   <> 'X'. bipmk-klasmitte  = '/'. ENDIF.
    IF plmk_tab-grenzob1ni <> 'X'. bipmk-grenzeob1  = '/'. ENDIF.
    IF plmk_tab-grenzun1ni <> 'X'. bipmk-grenzeun1  = '/'. ENDIF.
    IF plmk_tab-grenzob2ni <> 'X'. bipmk-grenzeob2  = '/'. ENDIF.
    IF plmk_tab-grenzun2ni <> 'X'. bipmk-grenzeun2  = '/'. ENDIF.
    IF plmk_tab-plausiobni <> 'X'. bipmk-plausioben = '/'. ENDIF.
    IF plmk_tab-plausiunni <> 'X'. bipmk-plausiunte = '/'. ENDIF.
    IF plmk_tab-tolwobni   <> 'X'. bipmk-tolerweiob = '/'. ENDIF.
    IF plmk_tab-tolwunni   <> 'X'. bipmk-tolerweiun = '/'. ENDIF.

* Nicht eingabereit:

* Nicht eingabebereite Felder:
    bipmk-katab1 = '/'.
    bipmk-txtsp = plmk_tab-ltextkz.

*    out_record = bipmk.
    ASSIGN out_record TO <x_obj_line> CASTING.
    ASSIGN bipmk      TO <x_obj> CASTING.
    <x_obj_line> = <x_obj>.

    TRANSFER out_record TO outfile.
    ADD 1 TO cnt-plmk_out.
    IF NOT chatx_fl IS INITIAL.
      PERFORM create_plmktx.
    ENDIF.
  ENDLOOP.

ENDFORM.                               " CREATE_PLMK
*&---------------------------------------------------------------------*
*&      Form  CREATE_PLMKTX
*&---------------------------------------------------------------------*
*       Text zum Planmerkmal
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM create_plmktx.

  DATA:
        l_plmk_textkey     LIKE thead-tdname.
  CONSTANTS:
    plmk_txt_object LIKE thead-tdobject      VALUE 'QSS       ',
    textid_mk       LIKE thead-tdid           VALUE 'QM'.

  FIELD-SYMBOLS: <x_obj_line> TYPE x,
                 <x_obj>      TYPE x.

* Langtext Planmerkmal

  CALL FUNCTION 'CQ_BM_PLMK_TEXT_FILL'
    EXPORTING
      plmkb_imp    = plmk_tab
    IMPORTING
      ltextkey_exp = l_plmk_textkey
    EXCEPTIONS
      OTHERS       = 1.

  IF sy-subrc <> 0.
*  message id sy-msgid type sy-msgty number sy-msgno
*          with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.


  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = textid_mk
      language                = plmk_tab-ltextspr
      name                    = l_plmk_textkey
      object                  = plmk_txt_object
    IMPORTING
      header                  = thead
    TABLES
      lines                   = txt_tab
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc = 0.
    CLEAR biptx.
    biptx-recty  = rectype-plmktx.
    biptx-plnty  = bipmk-plnty.
    biptx-plnnr  = plnr_act.
    biptx-plnal  = bipmk-plnal.
    biptx-plnfl  = bipmk-plnfl.
    biptx-vornr  = bipmk-vornr.
    biptx-merknr = plmk_tab-merknr.
    LOOP AT txt_tab.
      biptx-text = txt_tab-tdline.
      biptx-txpargraph = txt_tab-tdformat.
*      out_record = biptx.
      ASSIGN out_record TO <x_obj_line> CASTING.
      ASSIGN biptx      TO <x_obj> CASTING.
      <x_obj_line> = <x_obj>.

      TRANSFER out_record TO outfile.
      ADD 1 TO cnt-plmktx_out.
    ENDLOOP.
  ENDIF.

ENDFORM.                               " CREATE_PLMKTX

*&---------------------------------------------------------------------*
*&      Form  bom_explosion
*&---------------------------------------------------------------------*
*       explodes bill of material and determines KANTE
*----------------------------------------------------------------------*
FORM bom_explosion.

* local fields
*=======================================================================

  DATA BEGIN OF stpox_tab_tmp OCCURS 0.
          INCLUDE STRUCTURE stpox.
  DATA END OF stpox_tab_tmp.
  DATA: BEGIN OF parent_stack OCCURS 5,
          aufst LIKE stpox-aufst,
          aufwg LIKE stpox-aufwg,
        END   OF parent_stack.
  DATA: BEGIN OF path OCCURS 5,
          aufst   LIKE stpox-aufst,
          aufwg   LIKE stpox-aufwg,
          stlty_w LIKE plmzd-stlty_w,
          stlnr_w LIKE plmzd-stlnr_w,
          stlal_w LIKE plmzd-stlal_w,
          kante   LIKE plmzd-kante,
        END   OF path.

* für Lagertypen (konfigurierte Materialien) wird die Stückliste
* nicht mit dem konfigurierten Material als Kopfmaterial aufgelöst,
* sondern mit dem ursprügnlichen nicht konfigurierten Material.
* Falls nötig wird dieses Material hier ermittelt
*=======================================================================
  DATA: e_bomat LIKE bipmz-bomat,
        e_werks LIKE bipmz-werks,
        e_boman LIKE bipmz-boman,
        e_bomal LIKE bipmz-bomal.

  DATA: l_flg_ftrel TYPE xfeld.

* get customer settings for BOM explosion (flag FTREL)
  CALL FUNCTION 'CM_DI_GET_FTREL_FLAG'
    IMPORTING
      e_flg_ftrel = l_flg_ftrel.

  CALL FUNCTION 'CM_DI_DET_BOMAT_BTCI'
    EXPORTING
      i_bomat = mapl_auf-matnr
      i_werks = mapl_auf-werks
      i_boman = mapl_auf-stlan
      i_bomal = mapl_auf-stlal
    IMPORTING
      e_bomat = e_bomat
      e_werks = e_werks
      e_boman = e_boman
      e_bomal = e_bomal.


* BOM explosion
*=======================================================================

  CALL FUNCTION 'CS_BOM_EXPL_MAT_V2'
    EXPORTING
      aufsw                 = 'X'
      capid                 = ''
      mdmps                 = 'X'
      mehrs                 = 'X'
      datuv                 = stag_sel
      mtnrv                 = e_bomat " MAPL_AUF-MATNR
      werks                 = e_werks " MAPL_AUF-WERKS
      stlal                 = e_bomal " MAPL_AUF-STLAL
      stlan                 = e_boman " MAPL_AUF-STLAN
      mdnot                 = 'X'
      rndkz                 = '1'
      ftrel                 = l_flg_ftrel
    IMPORTING
      topmat                = topmat
      dstst                 = dstst
    TABLES
      stb                   = stpox_tab_tmp
    EXCEPTIONS
      alt_not_found         = 1
      call_invalid          = 2
      material_not_found    = 3
      missing_authorization = 4
      no_bom_found          = 5
      no_plant_data         = 6
      no_suitable_bom_found = 7
      OTHERS                = 8.

* determination of KANTE
*=======================================================================
  REFRESH: parent_stack,
           path.

  CLEAR   path.
  MOVE:   topmat-stlty TO path-stlty_w,
          topmat-stlnr TO path-stlnr_w,
          topmat-stlal TO path-stlal_w.


  REFRESH: parent_stack,                                       "tree
           path.                                               "tree
  "tree
  CLEAR   path.                                                "tree
  MOVE:   topmat-stlty TO path-stlty_w,                        "tree
          topmat-stlnr TO path-stlnr_w,                        "tree
          topmat-stlal TO path-stlal_w.                        "tree
  "tree
  LOOP AT stpox_tab_tmp.                                       "tree
    "tree
    IF stpox_tab_tmp-aufst NE path-aufst OR                    "tree
       stpox_tab_tmp-aufwg NE path-aufwg.                      "tree
      "tree
      IF stpox_tab_tmp-dumps IS INITIAL.                       "tree
        READ TABLE path WITH KEY aufst = stpox_tab_tmp-aufst   "tree
                                 aufwg = stpox_tab_tmp-aufwg   "tree
                                 BINARY SEARCH.                "tree
        IF NOT sy-subrc IS INITIAL.                            "tree
          CLEAR path-kante.
          CLEAR path-aufst.
          CLEAR path-aufwg.
        ENDIF.                                                 "tree
      ELSE.                                                    "tree
        READ TABLE parent_stack INDEX 1.                       "tree
        WHILE   sy-subrc           IS INITIAL              AND "tree
              ( parent_stack-aufst GT stpox_tab_tmp-aufst  OR  "tree
                parent_stack-aufst EQ stpox_tab_tmp-aufst  AND "tree
                parent_stack-aufwg NE stpox_tab_tmp-aufwg ).   "tree
          DELETE parent_stack INDEX 1.                         "tree
          CLEAR parent_stack.                                  "tree
          READ TABLE parent_stack INDEX 1.                     "tree
        ENDWHILE.                                              "tree

        CALL FUNCTION 'CS_EX_S_NODE_PROVIDE'                   "tree
          EXPORTING                                         "tree
            i_stlty_w         = topmat-stlty                "tree
            i_stlnr_w         = topmat-stlnr                "tree
            i_stlal_w         = topmat-stlal                "tree
            i_stlty           = stpox_tab_tmp-stlty         "tree
            i_stlnr           = stpox_tab_tmp-stlnr         "tree
            i_stlal           = stpox_tab_tmp-stlal         "tree
            i_stvkn           = stpox_tab_tmp-stvkn         "tree
            i_stlst           = stpox_tab_tmp-aufst         "tree
            i_stlwg           = stpox_tab_tmp-aufwg         "tree
            i_stlwg_v         = parent_stack-aufwg          "tree
          IMPORTING                                         "tree
            e_kante_k         = path-kante                  "tree
          EXCEPTIONS                                        "tree
            key_incomplete    = 1                           "tree
            no_path_tab       = 2                           "tree
            no_path_available = 3                           "tree
            OTHERS            = 4.                          "tree
        "tree
        IF NOT sy-subrc IS INITIAL.                            "tree
          CLEAR path-kante.
          CLEAR path-aufst.
          CLEAR path-aufwg.
        ENDIF.                                                 "tree

        MOVE: stpox_tab_tmp-aufst TO path-aufst,               "tree
              stpox_tab_tmp-aufwg TO path-aufwg.               "tree
        READ TABLE path WITH KEY aufst = path-aufst            "tree
                                 aufwg = path-aufwg            "tree
                                 BINARY SEARCH                 "tree
                                 TRANSPORTING NO FIELDS.       "tree
        IF NOT sy-subrc IS INITIAL.                            "tree
          INSERT path INTO path INDEX sy-tabix.                "tree
        ENDIF.                                                 "tree
        "tree
        IF NOT stpox_tab_tmp-dumps IS INITIAL.                 "tree
          MOVE: stpox_tab_tmp-aufst TO parent_stack-aufst,     "tree
                stpox_tab_tmp-aufwg TO parent_stack-aufwg.     "tree
          INSERT parent_stack INDEX 1.                         "tree
        ENDIF.                                                 "tree
        "tree
      ENDIF.                "if stpox_tab_tmp-dumps is initial   "tree
      "tree
    ENDIF.                                                     "tree
    MOVE stpox_tab_tmp      TO stpox_tab.                      "tree
    MOVE-CORRESPONDING path TO stpox_tab.                      "tree
    APPEND stpox_tab.                                          "tree

    "tree
  ENDLOOP.                   "loop at stpox_tab_tmp.           "tree

ENDFORM.                    " bom_explosion


*&---------------------------------------------------------------------*
*&      Form  move_corresponding
*&---------------------------------------------------------------------*
*       move corresponding mit Konvertierung von Mengenfeldern
*       in die Benutzerdarstellung
*----------------------------------------------------------------------*
*      -->I_FIELD1  Quellstruktur
*      -->I_NAME1   Name Quellstruktur
*      -->I_NAME2   Name Zielstruktur
*      <--I_FIELD2  Zielstruktur
*----------------------------------------------------------------------*
FORM move_corresponding
  USING
    i_field1
    i_name1
    i_name2
  CHANGING
    e_field2.

  DATA: lt_fields1 TYPE dfies OCCURS 0,
        lt_fields2 TYPE dfies OCCURS 0,
        l_field1   TYPE dfies,
        l_field2   TYPE dfies.
  FIELD-SYMBOLS: <f1>,<f2>.

* Feldkatalog Quellstruktur
  PERFORM get_structure_info
    TABLES
      lt_fields1
    USING
      i_name1.

* Feldkatalog Zielstruktur
  PERFORM get_structure_info
    TABLES
      lt_fields2
    USING
      i_name2.

  LOOP AT lt_fields2 INTO l_field2.
    ASSIGN COMPONENT l_field2-fieldname OF STRUCTURE e_field2 TO <f2>.
    CHECK sy-subrc IS INITIAL.
    ASSIGN COMPONENT l_field2-fieldname OF STRUCTURE i_field1 TO <f1>.
    CHECK sy-subrc IS INITIAL.
    READ TABLE lt_fields1 WITH KEY fieldname = l_field2-fieldname
      INTO l_field1 BINARY SEARCH.
    CHECK sy-subrc IS INITIAL.
    CASE l_field1-datatype.
      WHEN 'QUAN'  OR
           'WAERS' OR
           'CURR'  OR
           'UNIT'.
        WRITE <f1> TO <f2>.
      WHEN OTHERS.
        MOVE <f1> TO <f2>.
    ENDCASE.
  ENDLOOP.

ENDFORM.                    " move_corresponding

*&---------------------------------------------------------------------*
*&      Form  get_structure_info
*&---------------------------------------------------------------------*
*       Felder einer Struktur holen /gepuffert
*----------------------------------------------------------------------*
*      <--ET_FIELDS Felder der Struktur
*      -->I_NAME    Name der Struktur
*----------------------------------------------------------------------*
FORM get_structure_info
  TABLES
    et_fields STRUCTURE dfies
  USING
    i_name.

  TYPES: BEGIN OF structure_info_type,
           name(20) TYPE c,
           fields   TYPE dfies OCCURS 0,
         END OF structure_info_type.

  STATICS: st_structures TYPE STANDARD TABLE OF structure_info_type.
  DATA: l_tabix          LIKE sy-tabix,
        l_structure_info TYPE structure_info_type.

  REFRESH et_fields.

  READ TABLE st_structures INTO l_structure_info
    WITH KEY name = i_name
    BINARY SEARCH.
  l_tabix = sy-tabix.
  IF sy-subrc <> 0.
    CALL FUNCTION 'GET_FIELDTAB'
      EXPORTING
        tabname             = i_name
      TABLES
        fieldtab            = l_structure_info-fields
      EXCEPTIONS
        internal_error      = 1
        no_texts_found      = 2
        table_has_no_fields = 3
        table_not_activ     = 4
        OTHERS              = 5.
    SORT l_structure_info-fields BY fieldname.
    l_structure_info-name = i_name.
    INSERT l_structure_info INTO st_structures INDEX l_tabix.
  ENDIF.
  et_fields[] = l_structure_info-fields[].

ENDFORM.                    " get_structure_info
