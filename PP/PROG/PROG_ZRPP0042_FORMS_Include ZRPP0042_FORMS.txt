*&---------------------------------------------------------------------*
*&  Include           ZRPP0042_FORMS
*&---------------------------------------------------------------------*

*&----------------------------------------------------------------*
*&      Form  CALC_FECH_FIN
*&----------------------------------------------------------------*
FORM calc_fech_fin  USING    p_mbdat
                             p_ebeln
                             p_ebelp
                    CHANGING p_ffin.

  DATA: lv_route     TYPE route,
        lv_vstel     TYPE vstel,
        lv_fahztd    TYPE fahztd,
        lv_fahztd_s  TYPE i,
        lv_loadt     TYPE loadtn,
        lv_loadt_s   TYPE i,
        lv_pipatn    TYPE pipatn,
        lv_pipatn_s  TYPE i,
        lv_fabkl     TYPE fabkl,
        lv_fabkl_s   TYPE i,
        lv_time_sec  TYPE i,
        lv_time_days TYPE i.

  CLEAR: lv_route, lv_vstel, lv_fahztd, lv_loadt, lv_pipatn.
  CLEAR: lv_pipatn.
  CLEAR: lv_fahztd_s, lv_loadt_s, lv_pipatn_s, lv_pipatn_s.
  CLEAR: lv_time_days.

  SELECT SINGLE route vstel INTO (lv_route, lv_vstel)
    FROM ekpv
    WHERE ebeln = p_ebeln
    AND ebelp = p_ebelp.

  " Horas ruta:
  IF lv_route IS NOT INITIAL.
    SELECT SINGLE fahztd INTO lv_fahztd
      FROM tvro
      WHERE route = lv_route.
    PERFORM time_sec USING lv_fahztd
                     CHANGING lv_fahztd_s.
  ENDIF.

  " Horas de carga, picking y packing:
  IF lv_vstel IS NOT INITIAL.
    SELECT SINGLE loadtn pipatn fabkl
      INTO (lv_loadt, lv_pipatn, lv_fabkl)
      FROM tvst
      WHERE vstel = lv_vstel.
    PERFORM time_sec USING lv_loadt
                 CHANGING lv_loadt_s.
    PERFORM time_sec USING lv_pipatn
                 CHANGING lv_pipatn_s.
  ENDIF.

  " Pasar el tiempo en segundos:
  CLEAR lv_time_sec.
  lv_time_sec = lv_fahztd_s + lv_loadt_s + lv_pipatn_s.
  lv_time_days = lv_time_sec / ( 3600 * 24 ).

  p_ffin = p_mbdat - lv_time_days.

  IF lv_fabkl IS NOT INITIAL.
    CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
      EXPORTING
        i_date         = p_ffin
        i_calendar1    = lv_fabkl
*       I_CALENDAR2    =
      IMPORTING
        e_workday      = p_ffin
      EXCEPTIONS
        calendar_error = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
  ENDIF.

ENDFORM.                    " CALC_FECH_FIN
*&----------------------------------------------------------------*
*&      Form  TIME_SEC
*&----------------------------------------------------------------*
FORM time_sec  USING    p_horas
               CHANGING p_seg.

  DATA: lv_formato TYPE i,
        lv_horas   TYPE p DECIMALS 4,
        lv_horas_i TYPE i,
        lv_horas_d TYPE i,
        lv_min     TYPE p DECIMALS 2,
        lv_min_i   TYPE i,
        lv_seg     TYPE i.

  CLEAR: lv_horas, lv_horas_i, lv_horas_d, lv_min.
  CLEAR: lv_min_i, lv_seg, lv_formato.

  lv_formato = p_horas.

  " Horas:
  lv_horas = lv_formato / 10000.
  lv_horas_i = trunc( lv_horas ).
  lv_horas_d = frac( lv_horas ).

  " Minutos:
  lv_min = lv_horas_d / 100.
  lv_min_i = trunc( lv_min ).
  lv_seg = frac( lv_min ).

  " Cálculo en segundos:
  p_seg = lv_horas_i * 3600 + lv_min_i * 60 + lv_seg.

ENDFORM.                    " TIME_SEC
*&---------------------------------------------------------------------*
*&      Form  DATOS_ROLLO
*&---------------------------------------------------------------------*
FORM datos_rollo  USING    p_wmeng
                           p_matnr
                           p_werks
                  CHANGING p_idnrk
                           p_mnglg
                           p_mmein
                           p_zzgramaje
                           p_zzancho
                           p_matkl
                           p_maktx.

  DATA: lt_stb   TYPE stpox OCCURS 0 WITH HEADER LINE,
        ls_stb   TYPE stpox,
        lv_datuv LIKE stko-datuv,
        lv_emeng LIKE stko-bmeng,
        lv_mtnrv LIKE mara-matnr,
        lv_werks LIKE marc-werks.

* CGIJON - INI 07.02.17
  DATA: lv_ancho_trim      TYPE i,
        lv_ancho_min_bob   TYPE i,
        lv_zzgramaje       TYPE zgramaje,
        lv_zzancho         TYPE zancho,
        lv_zzancho_min_bob TYPE zancho,
        lv_matkl           TYPE matkl,
        lv_error.
* CGIJON - FIN 07.02.17

  CLEAR: lt_stb, ls_stb.
  REFRESH: lt_stb.

  CLEAR: lv_datuv, lv_emeng, lv_mtnrv,lv_werks.
  lv_datuv = sy-datum.
  lv_emeng = p_wmeng.
  lv_mtnrv = p_matnr.
  lv_werks = p_werks.

  " Recuperar datos para la orden de rollo:

  CALL FUNCTION 'CS_BOM_EXPL_MAT_V2'
    EXPORTING
      aumgb                 = 'X'
      capid                 = 'PI01'
      datuv                 = lv_datuv "sy-datum
      ehndl                 = 'X'
      emeng                 = lv_emeng " p_wmeng
      mehrs                 = '1'
      mmory                 = '1'
      mtnrv                 = lv_mtnrv "p_matnr
      stlal                 = '01'
      stlan                 = '1'
      stpst                 = 0
      svwvo                 = 'X'
      werks                 = lv_werks "p_werks
      vrsvo                 = 'X'
    TABLES
      stb                   = lt_stb
    EXCEPTIONS
      alt_not_found         = 1
      call_invalid          = 2
      material_not_found    = 3
      missing_authorization = 4
      no_bom_found          = 5
      no_plant_data         = 6
      no_suitable_bom_found = 7
      conversion_error      = 8
      OTHERS                = 9.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ELSEIF lt_stb[] IS NOT INITIAL.

  ENDIF.

* CGIJON - RECUPERAMOS EL MATERIAL ROLLO
  PERFORM recuperar_ancho_trim USING  p_werks
                                      p_matnr
                             CHANGING lv_ancho_trim
                                      lv_ancho_min_bob.

  CLEAR: lv_zzgramaje, lv_zzancho, lv_matkl, lv_zzancho.
  SELECT SINGLE zzgramaje zzancho matkl
        INTO (lv_zzgramaje, lv_zzancho, lv_matkl)
        FROM mara
        WHERE matnr = p_matnr.


  DATA: l_ancho_5mm TYPE zancho.
  PERFORM determinar_si_5mm USING lv_zzancho
                         CHANGING l_ancho_5mm.

  lv_zzancho = l_ancho_5mm + lv_ancho_trim.


  lv_zzancho_min_bob = lv_ancho_min_bob.

  IF lv_zzancho < lv_zzancho_min_bob.
    PERFORM buscar_rollo USING lv_zzancho_min_bob
                               lv_zzgramaje
                               lv_matkl
                        CHANGING p_idnrk
                                 lv_error.
  ELSE.
    PERFORM buscar_rollo USING lv_zzancho
                               lv_zzgramaje
                               lv_matkl
                        CHANGING p_idnrk
                                 lv_error.
  ENDIF.

  CHECK p_idnrk IS NOT INITIAL.

  SELECT SINGLE maktx INTO p_maktx
      FROM makt
      WHERE matnr =  p_idnrk
      AND spras = sy-langu.


  READ TABLE lt_stb INTO ls_stb WITH KEY sortf = 'ROLLO'.
  IF sy-subrc = 0.
    p_mnglg = ls_stb-mnglg.
    p_mmein = ls_stb-mmein.
  ELSE.
    p_mnglg = p_wmeng.
    SELECT SINGLE meins FROM mara
      INTO ls_stb-mmein
      WHERE matnr = p_matnr.
  ENDIF.

* CGIJON - FIN

ENDFORM.                    " DATOS_ROLLO
*&----------------------------------------------------------------*
*&      Form  SEC_TOTAL
*&----------------------------------------------------------------*
FORM sec_actual USING p_esc_max
                      p_esc_min
                CHANGING p_sentido
                         p_escalon.

  DATA: lv_fini           TYPE budat,
        lv_ffin           TYPE budat,
        lv_escalon        TYPE zindice_prod,
        lv_escalon_aux    TYPE zindice_prod,
        lv_sentido_aux(1),
        lv_esc_max        TYPE zindice_prod,
        lv_esc_min        TYPE zindice_prod.

  DATA: BEGIN OF lt_aufm OCCURS 0,
          budat LIKE aufm-budat,
          mblnr LIKE aufm-mblnr,
          mjahr LIKE aufm-mjahr,
          bwart LIKE aufm-bwart,
          matnr LIKE aufm-matnr,
          aufnr LIKE aufm-aufnr,
          auart LIKE aufk-auart,
        END OF lt_aufm.
  DATA: ls_aufm LIKE LINE OF lt_aufm.

  " Seleccionamos todos los movimientos '101' de la última semana:

  CLEAR: lt_aufm, ls_aufm, lv_fini, lv_ffin, lv_sentido_aux.
  REFRESH: lt_aufm.

  lv_ffin = sy-datum.
  lv_fini = sy-datum - 7 + 1.

  SELECT a~budat a~mblnr a~mjahr a~bwart a~matnr a~aufnr b~auart
    INTO TABLE lt_aufm
    FROM aufm AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN jest AS c ON c~objnr = b~objnr
    WHERE b~auart = gc_aufa_rol
    AND a~bwart = '101'
    AND ( a~budat <= lv_ffin AND a~budat >= lv_fini )
    AND ( c~stat = 'I0002' OR c~stat = 'I0045' )
    AND c~inact = ' '.

  SORT lt_aufm BY budat DESCENDING
                  mblnr DESCENDING
                  mjahr DESCENDING.

  DELETE ADJACENT DUPLICATES FROM lt_aufm.

  " Recuperar valor de último escalón de producción:
  CLEAR lv_escalon.
  READ TABLE lt_aufm INTO ls_aufm INDEX 1.
  IF ls_aufm IS NOT INITIAL.
    PERFORM calc_escalon_2 USING ls_aufm-matnr
                       CHANGING lv_escalon.
    p_escalon = lv_escalon.
  ENDIF.

  LOOP AT lt_aufm INTO ls_aufm.
    CLEAR lv_escalon_aux.
    PERFORM calc_escalon_2 USING ls_aufm-matnr
                         CHANGING lv_escalon_aux.

    IF lv_escalon_aux < lv_escalon AND lv_escalon NE p_esc_max.
      " Ascendente
      p_sentido = 'A'.
      EXIT.
    ELSEIF lv_escalon_aux < lv_escalon AND lv_escalon EQ p_esc_max.
      " Descendente
      p_sentido = 'D'.
      EXIT.
    ELSEIF lv_escalon_aux > lv_escalon AND lv_escalon NE p_esc_min.
      " Descendente
      p_sentido = 'D'.
      EXIT.
    ELSEIF lv_escalon_aux > lv_escalon AND lv_escalon EQ p_esc_min.
      " Ascendente
      p_sentido = 'A'.
      EXIT.
    ELSE.
      p_sentido = 'A'.
    ENDIF.
  ENDLOOP.

  IF p_sentido IS INITIAL.
    p_sentido = 'A'.
  ENDIF.

  IF p_escalon IS INITIAL.
    p_escalon = '1'.
  ENDIF.

ENDFORM.                    " SEC_TOTAL
*&-------------------------------------------------------------------*
*&      Form  CALC_ESCALON
*&-------------------------------------------------------------------*
*       text
*--------------------------------------------------------------------*
*      -->P_LS_AUFM_MATNR  text
*      <--P_LV_ESCALON  text
*--------------------------------------------------------------------*
FORM calc_escalon  USING    p_idnrk
                            p_zzgramaje
                            p_zzancho
                            p_matkl
                   CHANGING p_escalon.

  DATA: lv_ind_prod TYPE zindice_prod.

  CLEAR lv_ind_prod.

  SELECT SINGLE indice_prod INTO lv_ind_prod
  FROM ztpp0001
  WHERE matkl = p_matkl
  AND gramaje = p_zzgramaje
  AND ancho = p_zzancho.

  p_escalon = lv_ind_prod.

ENDFORM.                    " CALC_ESCALON

*&---------------------------------------------------------------------*
*&      Form  CALC_ESCALON_2
*&---------------------------------------------------------------------*
FORM calc_escalon_2  USING    p_matnr
                     CHANGING p_escalon.

  DATA: lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho,
        lv_matkl     TYPE matkl.

  CLEAR: lv_zzgramaje, lv_zzancho, lv_matkl.

  SELECT SINGLE zzgramaje zzancho matkl
    INTO (lv_zzgramaje, lv_zzancho, lv_matkl)
    FROM mara
    WHERE matnr = p_matnr.

  SELECT SINGLE indice_prod INTO p_escalon
  FROM ztpp0001
  WHERE matkl = lv_matkl
  AND gramaje = lv_zzgramaje
  AND ancho = lv_zzancho.

ENDFORM.                    " CALC_ESCALON_2
*&---------------------------------------------------------------------*
*&      Form  MIN_MAX_SEC
*&---------------------------------------------------------------------*
FORM min_max_sec  CHANGING p_max_esc
                           p_min_esc.

* Máximo escalón:

  SELECT MAX( indice_prod )
    FROM ztpp0001
    INTO p_max_esc.

* Mínimo escalón:

  SELECT MIN( indice_prod )
    FROM ztpp0001
    INTO p_min_esc.

ENDFORM.                    " MIN_MAX_SEC
*&---------------------------------------------------------------------*
*&      Form  DAT_ROLLO_TORN
*&---------------------------------------------------------------------*
FORM dat_rollo_torn  USING    p_wmeng
                              p_ancho_bob
                     CHANGING p_rol1
                              p_tor1
                              p_rol2
                              p_tor2.

  DATA: ls_ztpp0002 TYPE ztpp0002.

  CLEAR ls_ztpp0002.
  SELECT SINGLE * INTO ls_ztpp0002
    FROM ztpp0002
    WHERE ancho = p_ancho_bob
    AND cantidad_de <= p_wmeng
    AND cantidad_hasta >= p_wmeng.

  p_rol1 = ls_ztpp0002-rollos1.
  p_tor1 = ls_ztpp0002-tor1.
  p_rol2 = ls_ztpp0002-rollos2.
  p_tor2 = ls_ztpp0002-tor2.

ENDFORM.                    " DAT_ROLLO_TORN
*&---------------------------------------------------------------------*
*&      Form  F_REC_DATOS
*&---------------------------------------------------------------------*
FORM f_rec_datos .

  " Recuperar datos de pedidos:
  CLEAR: gt_datos_pedidos.
  REFRESH: gt_datos_pedidos.

  CLEAR: gt_listado1, gt_ordenes.
  REFRESH: gt_listado1, gt_ordenes.

  " DATOS PEDIDOS VENTAS:

  PERFORM f_recup_datos_ventas.

  " DATOS PEDIDOS COMPRAS:

  PERFORM f_recup_datos_compras.

  " Ordenación de la tabla por fecha de entrega/pedido/posición:

  SORT gt_datos_pedidos  BY mbdat ASCENDING
                            vbeln ASCENDING
                            posnr ASCENDING.

ENDFORM.                    " F_REC_DATOS
*&---------------------------------------------------------------------*
*&      Form  F_RECUP_DATOS_VENTAS
*&---------------------------------------------------------------------*
FORM f_recup_datos_ventas .

  DATA: lt_vbep TYPE TABLE OF vbep.
  DATA: ls_vbep       TYPE vbep,
        ls_datos_ped  TYPE zspp_linea_pedidos,
        ls_datos_ped2 TYPE zspp_linea_pedidos,
        ls_vbap       TYPE vbap,
        ls_vbak       TYPE vbak,
        lt_vbak       TYPE TABLE OF vbak.

  DATA: lv_spebe           TYPE spebe,
        lv_existe_rollo(1),
        lv_existe_bob(1),
        lv_aufnr_rol_aux   TYPE aufnr,
        lv_aufnr_bob_aux   TYPE aufnr,
        lv_seqnr           TYPE cy_seqnr.

  DATA: BEGIN OF lt_vkorg OCCURS 0,
          vkorg TYPE vkorg.
  DATA: END OF lt_vkorg.

  DATA: BEGIN OF lt_bwkey OCCURS 0,
          bwkey TYPE bwkey.
  DATA: END OF lt_bwkey.

  DATA: BEGIN OF lt_bukrs OCCURS 0,
          bukrs TYPE bukrs.
  DATA: END OF lt_bukrs.

  RANGES: r_vkorg FOR vbak-vkorg.

  CLEAR lt_vbep.
  REFRESH lt_vbep.

  SELECT bwkey FROM t001w INTO TABLE lt_bwkey WHERE werks IN s_werks.
  IF NOT lt_bwkey[] IS INITIAL.

    SELECT bukrs INTO TABLE lt_bukrs FROM t001k
      FOR ALL ENTRIES IN lt_bwkey WHERE bwkey = lt_bwkey-bwkey.

    IF NOT lt_bukrs[] IS INITIAL.

      SELECT vkorg FROM tvko INTO TABLE lt_vkorg
        FOR ALL ENTRIES IN lt_bukrs WHERE bukrs = lt_bukrs-bukrs.

      LOOP AT lt_vkorg.
        r_vkorg-sign = 'I'.
        r_vkorg-option = 'EQ'.
        r_vkorg-low = lt_vkorg-vkorg.
        APPEND r_vkorg.
      ENDLOOP.

    ENDIF.
  ENDIF.

  "Seleccionamos datos de ventas: (Sólo pongo que recoja el reparto '1')
  SELECT * FROM vbak INTO TABLE lt_vbak
    WHERE vkorg IN r_vkorg AND auart EQ gc_zta "OR auart EQ gc_ztas )
      AND lifsk EQ space AND vdatu IN s_vdatu
      AND zzsegcal = ' '. " CMS 51237 ZPP0001 no considerar pedidos de cabos de 2ª


  CHECK NOT lt_vbak[] IS INITIAL.
  SELECT * FROM vbep INTO TABLE lt_vbep
    FOR ALL ENTRIES IN lt_vbak
      WHERE vbeln = lt_vbak-vbeln AND etenr = '1'.

* uDefine ticket 45868 no considerar posiciones ped. venta con motivo rechazo o status de entrega completo o concluido
  SELECT * FROM vbup INTO TABLE @DATA(lt_vbup)
                     FOR ALL ENTRIES IN @lt_vbak
                     WHERE vbeln = @lt_vbak-vbeln AND lfsta EQ 'C'. "estatus de entrega de la posicion
  IF sy-subrc EQ 0.
    LOOP AT lt_vbup INTO DATA(ls_vbup).
      DELETE lt_vbep WHERE vbeln = ls_vbup-vbeln AND posnr = ls_vbup-posnr.
    ENDLOOP.
  ENDIF.
* fin uDefine ticket 45868

  REFRESH gt_aufnr.

  SELECT a~aufnr a~auart b~inact c~wemng
         a~zzebeln1 a~zzebelp1  a~zzurgt1
         a~zzebeln2 a~zzebelp2  a~zzurgt2
         a~zzebeln3 a~zzebelp3  a~zzurgt3
         b~stat
    INTO TABLE gt_aufnr
      FROM aufk AS a INNER JOIN jest AS b ON b~objnr = a~objnr
         INNER JOIN afpo AS c ON a~aufnr = c~aufnr
          FOR ALL ENTRIES IN lt_vbep
            WHERE ( a~auart = gc_aufa_rol OR a~auart = gc_aufa_bob )
              AND ( ( a~zzebeln1 = lt_vbep-vbeln AND a~zzebelp1 = lt_vbep-posnr ) OR
                    ( a~zzebeln2 = lt_vbep-vbeln AND a~zzebelp2 = lt_vbep-posnr ) OR
                    ( a~zzebeln3 = lt_vbep-vbeln AND a~zzebelp3 = lt_vbep-posnr ) ).

  LOOP AT lt_vbep INTO ls_vbep.
    " Sólo se tendrá en cuenta el primer reparto para la planificación:
    CLEAR ls_datos_ped2.
    READ TABLE gt_datos_pedidos INTO ls_datos_ped2
                                WITH KEY vbeln = ls_vbep-vbeln
                                         posnr = ls_vbep-posnr.
    IF ls_datos_ped2 IS NOT INITIAL.
      CONTINUE.
    ENDIF.
    " Comprobar bloqueo posición de reparto (VBEP):
    CLEAR lv_spebe.
    IF ls_vbep-lifsp IS NOT INITIAL.
      SELECT SINGLE spebe INTO lv_spebe
        FROM tvls
        WHERE lifsp = ls_vbep-lifsp.
    ENDIF.

    " Mirar si existe alguna orden de rollo/bobina relacionada a pedido:
    CLEAR: lv_existe_rollo, lv_existe_bob, lv_aufnr_rol_aux,
           lv_aufnr_bob_aux.

    PERFORM existe_orden_3 USING ls_vbep-vbeln
                                 ls_vbep-posnr
                           CHANGING lv_existe_rollo
                                    lv_existe_bob
                                    lv_aufnr_rol_aux
                                    lv_aufnr_bob_aux.

    IF lv_spebe <> 'X' AND
      ( lv_existe_rollo <> 'X' OR lv_existe_bob <> 'X' ).

      " Comprobar bloqueo posición de reparto (VBAK):
      CLEAR: ls_vbak, lv_spebe.
      SELECT SINGLE * INTO ls_vbak
        FROM vbak
        WHERE vbeln = ls_vbep-vbeln.
      IF ls_vbak-lifsk IS NOT INITIAL.
        SELECT SINGLE spebe INTO lv_spebe
          FROM tvls
          WHERE lifsp = ls_vbak-lifsk.
      ENDIF.

      IF lv_spebe <> 'X'.
        CLEAR: ls_vbap.
        SELECT SINGLE * INTO ls_vbap
          FROM vbap
          WHERE vbeln = ls_vbep-vbeln
          AND posnr = ls_vbep-posnr
          AND werks IN s_werks
          AND abgru EQ space. "uDefine ticket 45868 - no considerar posiciones con motivo de rechazo

* GST - 21/05/2015 ->
        IF ls_vbap IS NOT INITIAL AND ls_vbap-pstyv = 'TAN'.
* GST - 21/05/2015 <-
          CLEAR ls_datos_ped.
          MOVE-CORRESPONDING ls_vbep TO ls_datos_ped.
          MOVE-CORRESPONDING ls_vbap TO ls_datos_ped.
          CLEAR ls_datos_ped-matkl.

* 09/12/2021 - CMS - Obtener destinatario de mercancias como cliente dentro de la aplicación.
          SELECT SINGLE kunnr
            INTO @DATA(l_kunwe)
            FROM vbpa
            WHERE vbeln = @ls_vbep-vbeln AND
                  parvw = 'WE'.
          IF sy-subrc <> 0.
            ls_datos_ped-kunnr = ls_vbak-kunnr.
          ELSE.
            ls_datos_ped-kunnr = l_kunwe.
          ENDIF.
*          ls_datos_ped-kunnr = ls_vbak-kunnr.


          IF lv_aufnr_rol_aux IS NOT INITIAL.
            ls_datos_ped-aufnr_rol = lv_aufnr_rol_aux.
            ls_datos_ped-auart_rol = gc_aufa_rol.
          ENDIF.
          IF lv_aufnr_bob_aux IS NOT INITIAL.
            ls_datos_ped-aufnr_bob = lv_aufnr_bob_aux.
            ls_datos_ped-auart_bob = gc_aufa_bob.
          ENDIF.
          ls_datos_ped-existe_rol = lv_existe_rollo.
          ls_datos_ped-existe_bob = lv_existe_bob.
*          " Cálculo fecha final orden:
          SELECT SINGLE maktx INTO ls_datos_ped-maktx
            FROM makt
            WHERE matnr = ls_datos_ped-matnr
            AND spras = sy-langu.
          " Obtener datos de rollo:
          PERFORM datos_rollo USING ls_datos_ped-wmeng
                                    ls_datos_ped-matnr
                                    ls_datos_ped-werks
                              CHANGING ls_datos_ped-idnrk
                                       ls_datos_ped-mnglg
                                       ls_datos_ped-mmein
                                       ls_datos_ped-zzgramaje
                                       ls_datos_ped-zzancho
                                       ls_datos_ped-matkl
                                       ls_datos_ped-maktx_rol.

          IF ls_datos_ped-idnrk IS NOT INITIAL.
            APPEND ls_datos_ped TO gt_datos_pedidos.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_RECUP_DATOS_VENTAS
*&---------------------------------------------------------------------*
*&      Form  F_RECUP_DATOS_COMPRAS
*&---------------------------------------------------------------------*
FORM f_recup_datos_compras .

  DATA: lt_eket TYPE TABLE OF eket.

  DATA: ls_eket            TYPE eket,
        ls_ekpo            TYPE ekpo,
        ls_ekko            TYPE ekko,
        ls_datos_ped       TYPE zspp_linea_pedidos,
        ls_datos_ped2      TYPE zspp_linea_pedidos,
        lv_existe_rollo(1),
        lv_existe_bob(1),
        lv_aufnr_rol_aux2  TYPE aufnr,
        lv_aufnr_bob_aux2  TYPE aufnr,
        lv_reswk           TYPE reswk,
        lv_bsart           TYPE esart,
        lv_zzsegcal        TYPE zzsegcal.

  DATA: BEGIN OF lt_lifnr OCCURS 0,
          lifnr TYPE lifnr.
  DATA: END OF lt_lifnr.

  DATA: BEGIN OF lt_ekko OCCURS 0,
          ebeln TYPE ebeln,
          ebelp TYPE ebelp.
  DATA: END OF lt_ekko.

  DATA: BEGIN OF lt_eket_aux OCCURS 0,
          ebeln TYPE ebeln,
          ebelp TYPE posnr,
          etenr TYPE etenr.
  DATA: END OF lt_eket_aux.

  RANGES: r_lifnr FOR lfa1-lifnr.

  CLEAR: lt_eket, ls_eket.
  REFRESH lt_eket.

  IF NOT s_werks[] IS INITIAL.
    SELECT lifnr INTO TABLE lt_lifnr FROM lfa1 WHERE werks IN s_werks.
    IF sy-subrc = 0.
      LOOP AT lt_lifnr.
        r_lifnr-sign = 'I'.
        r_lifnr-option = 'EQ'.
        r_lifnr-low = lt_lifnr-lifnr.
        APPEND r_lifnr.
      ENDLOOP.
    ENDIF.
  ENDIF.

  " Nos quedamos con el primer reparto para planificar:
  SELECT a~ebeln b~ebelp INTO TABLE lt_ekko
    FROM ekko AS a INNER JOIN ekpo AS b ON a~ebeln = b~ebeln
      WHERE a~lifnr IN r_lifnr AND a~bsart EQ gc_zint
        AND b~elikz EQ space AND b~loekz EQ space
        AND b~zzbloq_plan EQ space AND b~zzsegcal EQ space.

  CHECK NOT lt_ekko[] IS INITIAL.
  SELECT * FROM eket INTO TABLE lt_eket
    FOR ALL ENTRIES IN lt_ekko
      WHERE ebeln = lt_ekko-ebeln AND ebelp = lt_ekko-ebelp
        AND eindt IN s_vdatu. " AND etenr = '1'.

  LOOP AT lt_eket INTO ls_eket.
    lt_eket_aux-ebeln = ls_eket-ebeln.
    lt_eket_aux-ebelp = ls_eket-ebelp.
    lt_eket_aux-etenr = ls_eket-etenr.
    APPEND lt_eket_aux.
  ENDLOOP.

  SELECT a~aufnr a~auart b~inact c~wemng
         a~zzebeln1 a~zzebelp1  a~zzurgt1
         a~zzebeln2 a~zzebelp2  a~zzurgt2
         a~zzebeln3 a~zzebelp3  a~zzurgt3
         b~stat
    APPENDING TABLE gt_aufnr
      FROM aufk AS a INNER JOIN jest AS b ON b~objnr = a~objnr
         INNER JOIN afpo AS c ON a~aufnr = c~aufnr
          FOR ALL ENTRIES IN lt_eket_aux
            WHERE ( a~auart = gc_aufa_rol OR a~auart = gc_aufa_bob )
              AND ( ( a~zzebeln1 = lt_eket_aux-ebeln AND a~zzebelp1 = lt_eket_aux-ebelp  AND a~zzurgt1 = lt_eket_aux-etenr ) OR
                    ( a~zzebeln2 = lt_eket_aux-ebeln AND a~zzebelp2 = lt_eket_aux-ebelp  AND a~zzurgt2 = lt_eket_aux-etenr ) OR
                    ( a~zzebeln3 = lt_eket_aux-ebeln AND a~zzebelp3 = lt_eket_aux-ebelp  AND a~zzurgt3 = lt_eket_aux-etenr ) ).

  LOOP AT lt_eket INTO ls_eket.

    CLEAR ls_datos_ped2.
    READ TABLE gt_datos_pedidos INTO ls_datos_ped2
                                WITH KEY vbeln = ls_eket-ebeln
                                         posnr = ls_eket-ebelp
                                         etenr = ls_eket-etenr.
    IF ls_datos_ped2 IS NOT INITIAL.
      CONTINUE.
    ENDIF.

    CLEAR: ls_ekko, lv_reswk, lv_bsart, lv_zzsegcal.
    SELECT SINGLE reswk bsart zzsegcal INTO (lv_reswk, lv_bsart, lv_zzsegcal) " EDIEGO 20/07/2017 controlamos segunda calidad
      FROM ekko
      WHERE ebeln = ls_eket-ebeln
      AND reswk IN s_werks.

*   EDIEGO 20/07/2017 controlamos segunda calidad -->
    IF lv_zzsegcal EQ '2' OR ".
       lv_zzsegcal EQ '3'.
      CONTINUE.
    ENDIF.
*   EDIEGO 20/07/2017 controlamos segunda calidad <--

    IF lv_reswk IS INITIAL.
      CONTINUE.
    ENDIF.

    IF lv_bsart <> 'ZINT'.
      CONTINUE.
    ENDIF.

    CLEAR: ls_ekpo.
    SELECT SINGLE * INTO ls_ekpo
      FROM ekpo
      WHERE ebeln = ls_eket-ebeln
      AND ebelp = ls_eket-ebelp.

    IF ls_ekpo-zzbloq_plan = 'X'.
      CONTINUE.
    ENDIF.

* GST - 21/05/2015 ->
    IF ls_ekpo-zzbloq_fabr = 'X'.
      CONTINUE.
    ENDIF.
* GST - 21/05/2015 <-

    " Miramos si el pedido ya existe en alguna orden:
    CLEAR: lv_existe_rollo, lv_existe_bob, lv_aufnr_rol_aux2,
           lv_aufnr_bob_aux2.
* GST - 05/03/2015 ->

    PERFORM existe_orden_com USING ls_eket-ebeln
                                   ls_eket-ebelp
                                   ls_eket-etenr
                         CHANGING "lv_existe_rollo
                                  lv_existe_bob
                                  "lv_aufnr_rol_aux2
                                  lv_aufnr_bob_aux2.
* GST - 05/03/2015 <-

    IF ls_ekpo IS NOT INITIAL AND ls_ekpo-loekz <> 'L'
                              AND ls_ekpo-eglkz <> 'X'
                              AND ls_ekpo-zzabgru IS INITIAL
                              AND ls_ekpo-retpo <> 'X'
                              AND ( " lv_existe_rollo <> 'X' OR
                                    lv_existe_bob <> 'X').
      CLEAR ls_datos_ped.
      ls_datos_ped-mbdat = ls_eket-eindt.
      ls_datos_ped-vbeln = ls_eket-ebeln.
      ls_datos_ped-posnr = ls_eket-ebelp.
      ls_datos_ped-etenr = ls_eket-etenr.
      ls_datos_ped-wmeng = ls_eket-menge.
      SELECT SINGLE vrkme INTO ls_datos_ped-vrkme
        FROM vbep
        WHERE vbeln = ls_datos_ped-vbeln
        AND posnr = ls_datos_ped-posnr
        AND etenr = ls_datos_ped-etenr.
      ls_datos_ped-meins = ls_ekpo-meins.
      ls_datos_ped-matnr = ls_ekpo-matnr.
      SELECT SINGLE kunnr lprio INTO (ls_datos_ped-kunnr,
      ls_datos_ped-lprio)
        FROM ekpv
        WHERE ebeln = ls_eket-ebeln
        AND ebelp =  ls_eket-ebelp.
      CLEAR ls_datos_ped-matkl.
***      IF lv_aufnr_rol_aux2 IS NOT INITIAL.
***        ls_datos_ped-aufnr_rol = lv_aufnr_rol_aux2.
***        ls_datos_ped-auart_rol = gc_aufa_rol.
***      ENDIF.
      IF lv_aufnr_bob_aux2 IS NOT INITIAL.
        ls_datos_ped-aufnr_bob = lv_aufnr_bob_aux2.
        ls_datos_ped-auart_bob = gc_aufa_bob.
      ENDIF.
***      ls_datos_ped-existe_rol = lv_existe_rollo.
      ls_datos_ped-existe_bob = lv_existe_bob.
      ls_datos_ped-werks = lv_reswk.

      SELECT SINGLE maktx INTO ls_datos_ped-maktx
        FROM makt
        WHERE matnr = ls_datos_ped-matnr
        AND spras = sy-langu.
      " Obtener datos de rollo:
      PERFORM datos_rollo USING ls_datos_ped-wmeng
                                ls_datos_ped-matnr
                                ls_datos_ped-werks
                          CHANGING ls_datos_ped-idnrk
                                   ls_datos_ped-mnglg
                                   ls_datos_ped-mmein
                                   ls_datos_ped-zzgramaje
                                   ls_datos_ped-zzancho
                                   ls_datos_ped-matkl
                                   ls_datos_ped-maktx_rol.

      IF ls_datos_ped-idnrk IS NOT INITIAL.
        APPEND ls_datos_ped TO gt_datos_pedidos.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_RECUP_DATOS_COMPRAS
*&---------------------------------------------------------------------*
*&      Form  F_CREAR_ORDENES
*&---------------------------------------------------------------------*
FORM f_crear_ordenes.

  DATA: ls_datos_pedidos TYPE zspp_linea_pedidos,
        lv_index         LIKE sy-tabix,
        lv_ok(1),
        ls_listado1      LIKE gt_listado1.

  CLEAR: ls_datos_pedidos, lv_ok.

  "Voy a crear las órdenes correspondientes a los pedidos seleccionados:
  LOOP AT gt_datos_pedidos INTO ls_datos_pedidos.
    lv_index = sy-tabix.

    " 1) Creo la orden de rollo/bobina:
    IF ls_datos_pedidos-existe_rol <> 'X' AND
    ls_datos_pedidos-existe_bob <> 'X'.
      CLEAR lv_ok.
      PERFORM crear_orden_rollo_2 USING ls_datos_pedidos
                                CHANGING ls_datos_pedidos-aufnr_rol
                                         ls_datos_pedidos-auart_rol
                                         lv_ok.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
      IF lv_ok = 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
        PERFORM crear_orden_bobina_2 USING ls_datos_pedidos
                                   CHANGING ls_datos_pedidos-aufnr_bob
                                            ls_datos_pedidos-auart_bob.
        MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
      ELSEIF lv_ok <> 'X' AND ls_datos_pedidos-existe_bob <> 'X'.
        CLEAR: ls_listado1.
        ls_listado1-vbeln = ls_datos_pedidos-vbeln.
        ls_listado1-posnr = ls_datos_pedidos-posnr.
        ls_listado1-matnr = ls_datos_pedidos-matnr.
        ls_listado1-maktx = ls_datos_pedidos-maktx.
        ls_listado1-auart = gc_aufa_bob.
        ls_listado1-kunnr = ls_datos_pedidos-kunnr.
        ls_listado1-werks = ls_datos_pedidos-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret =
        'No se ha podido crear la orden de rollo correspondiente'.
        ls_listado1-tipo = 'C'. " Error en creación
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.
    ENDIF.

    " 2) Sólo hay que crear orden rollo:
    IF ls_datos_pedidos-existe_rol <> 'X' AND
    ls_datos_pedidos-existe_bob = 'X'.
      CLEAR lv_ok.
      PERFORM crear_orden_rollo_2 USING ls_datos_pedidos
                                CHANGING ls_datos_pedidos-aufnr_rol
                                         ls_datos_pedidos-auart_rol
                                         lv_ok.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
    ENDIF.
    " 3) Sólo hay que crear orden bobina:
    IF ls_datos_pedidos-existe_rol = 'X' AND
       ls_datos_pedidos-existe_bob <> 'X'.
      PERFORM crear_orden_bobina_2 USING ls_datos_pedidos
                                 CHANGING ls_datos_pedidos-aufnr_bob
                                          ls_datos_pedidos-auart_bob.
      MODIFY gt_datos_pedidos FROM ls_datos_pedidos INDEX lv_index.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_CREAR_ORDENES
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_ROLLO_2
*&---------------------------------------------------------------------*
FORM crear_orden_rollo_2 USING ps_datos_pedidos TYPE zspp_linea_pedidos
                         CHANGING p_aufnr_rol
                                  p_auart_rol
                                  p_ok.

  DATA: ls_ordenes TYPE ty_ordenes.

  p_ok = 'X'.

  CLEAR ls_ordenes.
  ls_ordenes-vbeln    = ps_datos_pedidos-vbeln.
  ls_ordenes-posnr    = ps_datos_pedidos-posnr.
  ls_ordenes-matnr    = ps_datos_pedidos-idnrk.
  ls_ordenes-maktx    = ps_datos_pedidos-maktx_rol.
  ls_ordenes-auart    = gc_aufa_rol.
  ls_ordenes-kunnr    = ps_datos_pedidos-kunnr.
  ls_ordenes-werks    = ps_datos_pedidos-werks.
  ls_ordenes-cantidad = ps_datos_pedidos-mnglg.
  ls_ordenes-unidad   = ps_datos_pedidos-mmein.
  ls_ordenes-mbdat    = ps_datos_pedidos-mbdat.
  ls_ordenes-wmeng    = ps_datos_pedidos-wmeng.
  ls_ordenes-vrkme    = ps_datos_pedidos-vrkme.
*  ls_ordenes-lprio    = ps_datos_pedidos-lprio.
  APPEND ls_ordenes TO gt_ordenes.

ENDFORM.                    " CREAR_ORDEN_ROLLO_2
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_BOBINA_2
*&---------------------------------------------------------------------*
FORM crear_orden_bobina_2 USING ps_datos_pedidos TYPE zspp_linea_pedidos
                          CHANGING p_aufnr_bob
                                   p_auart_bob.

  DATA: ls_ordenes TYPE ty_ordenes.

  CLEAR ls_ordenes.
  ls_ordenes-vbeln    = ps_datos_pedidos-vbeln.
  ls_ordenes-posnr    = ps_datos_pedidos-posnr.
  ls_ordenes-matnr    = ps_datos_pedidos-matnr.
  ls_ordenes-maktx    = ps_datos_pedidos-maktx.
  ls_ordenes-auart    = gc_aufa_bob.
  ls_ordenes-kunnr    = ps_datos_pedidos-kunnr.
  ls_ordenes-werks    = ps_datos_pedidos-werks.
  ls_ordenes-cantidad = ps_datos_pedidos-wmeng.
  IF ps_datos_pedidos-vrkme IS NOT INITIAL.
    ls_ordenes-unidad = ps_datos_pedidos-vrkme.
  ELSEIF ps_datos_pedidos-meins IS NOT INITIAL.
    ls_ordenes-unidad = ps_datos_pedidos-meins.
  ELSE.
    ls_ordenes-unidad = 'KG'.
  ENDIF.
  APPEND ls_ordenes TO gt_ordenes.

ENDFORM.                    " CREAR_ORDEN_BOBINA_2
*&---------------------------------------------------------------------*
*&      Form  F_CALC_FECH
*&---------------------------------------------------------------------*
FORM f_calc_fech  USING    p_werks
                           p_mbdat
                  CHANGING p_fecha.

  DATA: lv_fabkl TYPE fabkl,
        lv_mbdat TYPE mbdat.

  CLEAR: lv_fabkl, lv_mbdat.

  " Buscamos el calendario de fábrica por centro:
  SELECT SINGLE fabkl INTO lv_fabkl
    FROM t001w
    WHERE werks = p_werks.
  IF lv_fabkl IS INITIAL.
    lv_fabkl = 'ES'.
  ENDIF.

  " Miramos si la fecha calculada corresponde al calendario de fábrica
  " y si no cogemos justo la anterior a esa:
  lv_mbdat = p_mbdat - 1.

  CALL FUNCTION 'BKK_GET_PRIOR_WORKDAY'
    EXPORTING
      i_date         = lv_mbdat
      i_calendar1    = lv_fabkl
*     I_CALENDAR2    =
    IMPORTING
      e_workday      = lv_mbdat
    EXCEPTIONS
      calendar_error = 1
      OTHERS         = 2.
  IF sy-subrc <> 0.
* Implement suitable error handling here
    p_fecha = p_mbdat - 1.
  ELSE.
    p_fecha = lv_mbdat.
  ENDIF.

ENDFORM.                    " F_CALC_FECH
* GST - 05/03/2015 ->
FORM existe_orden_com  USING    p_vbeln
                              p_posnr
                              p_etenr
                     CHANGING "p_existe_rollo
                              p_existe_bob
                              " lv_aufnr_rollo
                              lv_aufnr_bob.

* CMS 21-04-2020 No miramos OF Rollo, únicamente bobina.

  " 1) Recuperamos la orden de rollo correspondiente si existe:
***  CLEAR: lv_aufnr_rollo.
***  CLEAR: p_existe_rollo.
***
***
***  LOOP AT gt_aufnr
***    WHERE auart = gc_aufa_rol
***      AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
***            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
***            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) )
***      AND ( ( stat = 'I0045' AND inact = space AND wemng <> 0 ) OR
***            ( stat = 'I0046' AND inact = space ) OR "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
***            ( stat = 'I0002' AND inact = space ) OR
***            ( stat = 'I0001' AND inact = space ) ).
***
***    lv_aufnr_rollo = gt_aufnr-aufnr.
***    p_existe_rollo = 'X'.
***    EXIT.
***  ENDLOOP.
***
***  IF sy-subrc <> 0.
***
***    LOOP AT gt_aufnr
***      WHERE auart = gc_aufa_rol
***        AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
***              ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
***              ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) )
***        AND ( ( stat = 'I0045' AND inact = space AND wemng = 0 ) OR
***              ( stat = 'I0046' AND inact = space ) "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
***            ).
***
***      CLEAR: p_existe_rollo, lv_aufnr_rollo.
***      EXIT.
***    ENDLOOP.
***
***    IF sy-subrc <> 0.
***
***      LOOP AT gt_aufnr
***        WHERE auart = gc_aufa_rol
***          AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
***                ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
***                ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) ).
***
***        lv_aufnr_rollo = gt_aufnr-aufnr.
***        p_existe_rollo = 'X'.
***        EXIT.
***      ENDLOOP.
***      IF sy-subrc <> 0.
***        CLEAR p_existe_rollo.  " No existe y son órdenes nuevas a crear
***        CLEAR: lv_aufnr_rollo.
***      ENDIF.
***    ENDIF.
***  ENDIF.

  " 2) Recuperamos la orden de bobina correspondiente si existe:
  CLEAR: lv_aufnr_bob.
  CLEAR: p_existe_bob.

  LOOP AT gt_aufnr
    WHERE auart = gc_aufa_bob
      AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) )
      AND ( ( stat = 'I0045' AND inact = space AND wemng <> 0 ) OR
            ( stat = 'I0046' AND inact = space ) OR "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ( stat = 'I0002' AND inact = space ) OR
            ( stat = 'I0001' AND inact = space ) ).

    lv_aufnr_bob = gt_aufnr-aufnr.
    p_existe_bob = 'X'.
    EXIT.
  ENDLOOP.

  IF sy-subrc <> 0.

    LOOP AT gt_aufnr
      WHERE auart = gc_aufa_bob
        AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
              ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
              ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) )
        AND ( ( stat = 'I0045' AND inact = space AND wemng = 0 ) OR
              ( stat = 'I0046' AND inact = space ) "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ).

      CLEAR: p_existe_bob, lv_aufnr_bob.
      EXIT.
    ENDLOOP.
    IF sy-subrc <> 0.

      LOOP AT gt_aufnr
        WHERE auart = gc_aufa_bob
          AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr AND zzurgt1 = p_etenr ) OR
                ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr AND zzurgt2 = p_etenr ) OR
                ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr AND zzurgt3 = p_etenr ) ).

        lv_aufnr_bob = gt_aufnr-aufnr.
        p_existe_bob = 'X'.
        EXIT.
      ENDLOOP.

      IF sy-subrc <> 0.
        CLEAR p_existe_bob.  " No existe y son órdenes nuevas a crear
        CLEAR: lv_aufnr_bob.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  EXISTE_ORDEN_3
*&---------------------------------------------------------------------*
FORM existe_orden_3  USING    p_vbeln
                              p_posnr
                     CHANGING p_existe_rollo
                              p_existe_bob
                              lv_aufnr_rollo
                              lv_aufnr_bob.

  " 1) Recuperamos la orden de rollo correspondiente si existe:
  CLEAR: lv_aufnr_rollo.
  CLEAR: p_existe_rollo.


  LOOP AT gt_aufnr
    WHERE auart = gc_aufa_rol
      AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
      AND ( ( stat = 'I0045' AND inact = space AND wemng <> 0 ) OR
            ( stat = 'I0046' AND inact = space ) OR "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ( stat = 'I0002' AND inact = space ) OR
            ( stat = 'I0001' AND inact = space ) ).

    lv_aufnr_rollo = gt_aufnr-aufnr.
    p_existe_rollo = 'X'.
    EXIT.
  ENDLOOP.

  IF sy-subrc <> 0.

    LOOP AT gt_aufnr
      WHERE auart = gc_aufa_rol
        AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
              ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
              ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
        AND ( ( stat = 'I0045' AND inact = space AND wemng = 0 ) OR
              ( stat = 'I0046' AND inact = space ) "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ).

      CLEAR: p_existe_rollo, lv_aufnr_rollo.
      EXIT.
    ENDLOOP.

    IF sy-subrc <> 0.

      LOOP AT gt_aufnr
        WHERE auart = gc_aufa_rol
          AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
                ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
                ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) ).

        lv_aufnr_rollo = gt_aufnr-aufnr.
        p_existe_rollo = 'X'.
        EXIT.
      ENDLOOP.
      IF sy-subrc <> 0.
        CLEAR p_existe_rollo.  " No existe y son órdenes nuevas a crear
        CLEAR: lv_aufnr_rollo.
      ENDIF.
    ENDIF.
  ENDIF.

  " 2) Recuperamos la orden de bobina correspondiente si existe:
  CLEAR: lv_aufnr_bob.
  CLEAR: p_existe_bob.

  LOOP AT gt_aufnr
    WHERE auart = gc_aufa_bob
      AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
            ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
            ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
      AND ( ( stat = 'I0045' AND inact = space AND wemng <> 0 ) OR
            ( stat = 'I0046' AND inact = space ) OR "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ( stat = 'I0002' AND inact = space ) OR
            ( stat = 'I0001' AND inact = space ) ).

    lv_aufnr_bob = gt_aufnr-aufnr.
    p_existe_bob = 'X'.
    EXIT.
  ENDLOOP.

  IF sy-subrc <> 0.

    LOOP AT gt_aufnr
      WHERE auart = gc_aufa_bob
        AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
              ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
              ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) )
        AND ( ( stat = 'I0045' AND inact = space AND wemng = 0 ) OR
              ( stat = 'I0046' AND inact = space ) "uDefine - Ticket 45747 - Cosiderar CERR como CTEC
            ).

      CLEAR: p_existe_bob, lv_aufnr_bob.
      EXIT.
    ENDLOOP.
    IF sy-subrc <> 0.

      LOOP AT gt_aufnr
        WHERE auart = gc_aufa_bob
          AND ( ( zzebeln1 = p_vbeln AND zzebelp1 = p_posnr ) OR
                ( zzebeln2 = p_vbeln AND zzebelp2 = p_posnr ) OR
                ( zzebeln3 = p_vbeln AND zzebelp3 = p_posnr ) ).

        lv_aufnr_bob = gt_aufnr-aufnr.
        p_existe_bob = 'X'.
        EXIT.
      ENDLOOP.

      IF sy-subrc <> 0.
        CLEAR p_existe_bob.  " No existe y son órdenes nuevas a crear
        CLEAR: lv_aufnr_bob.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " EXISTE_ORDEN_3

* GST - 05/03/2015 <-
*&---------------------------------------------------------------------*
*&      Form  F_CREAR_TABLA_ALV
*&---------------------------------------------------------------------*
FORM f_crear_tabla_alv .
  DATA: ls_alv     TYPE                   zspp0026_alv,
        ls_ordenes TYPE                   ty_ordenes,
        lt_bobina  TYPE STANDARD TABLE OF ty_ordenes,
        lt_rollo   TYPE STANDARD TABLE OF ty_ordenes,
        ls_bobina  TYPE                   ty_ordenes,
        ls_rollo   TYPE                   ty_ordenes.


  CLEAR: gt_alv, lt_bobina, lt_rollo.

* separamos bobinas y rollos
  LOOP AT gt_ordenes INTO ls_ordenes.
    IF ls_ordenes-auart = gc_aufa_rol.
      APPEND ls_ordenes TO lt_rollo.
    ELSE.
      APPEND ls_ordenes TO lt_bobina.
    ENDIF.
  ENDLOOP.

* montamos tabla ALV de trabajo
  LOOP AT lt_bobina INTO ls_bobina.
    READ TABLE lt_rollo INTO ls_rollo WITH KEY vbeln = ls_bobina-vbeln
                                               posnr = ls_bobina-posnr.
    IF sy-subrc = 0.
      CLEAR ls_alv.
      ls_alv-kunnr = ls_bobina-kunnr.
      ls_alv-werks = ls_bobina-werks.
      ls_alv-vbeln = ls_bobina-vbeln.
      ls_alv-posnr = ls_bobina-posnr.
      ls_alv-mbdat = ls_rollo-mbdat.
      ls_alv-wmeng = ls_rollo-wmeng.
      ls_alv-vrkme = ls_rollo-vrkme.
      ls_alv-lprio = ls_rollo-lprio.
*
      ls_alv-cant_bob = ls_bobina-cantidad.
      ls_alv-unid_bob = ls_bobina-unidad.
      ls_alv-mate_bob = ls_bobina-matnr.
      ls_alv-desc_bob = ls_bobina-maktx.
      SELECT SINGLE matkl zzgramaje zzancho
        INTO (ls_alv-matk_bob,ls_alv-gram_bob,ls_alv-anch_bob)
        FROM mara WHERE matnr = ls_bobina-matnr.
      ls_alv-aufa_bob = ls_bobina-auart.
*
      ls_alv-cant_rol = ls_rollo-cantidad.
      ls_alv-unid_rol = ls_rollo-unidad.
      ls_alv-mate_rol = ls_rollo-matnr.
      ls_alv-desc_rol = ls_rollo-maktx.
      SELECT SINGLE matkl zzgramaje zzancho
        INTO (ls_alv-matk_rol,ls_alv-gram_rol,ls_alv-anch_rol)
        FROM mara WHERE matnr = ls_rollo-matnr.
      ls_alv-aufa_rol = ls_rollo-auart.

      APPEND ls_alv TO gt_alv.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " F_CREAR_TABLA_ALV
*&---------------------------------------------------------------------*
*&      Form  LINEAS_MARCADAS_CREAR
*&---------------------------------------------------------------------*
FORM lineas_marcadas_crear CHANGING pv_error.
  DATA: lti_rows     TYPE lvc_t_roid,
        ls_row       TYPE lvc_s_roid,
        ls_alv       TYPE zspp0026_alv,
        ls_agrup     TYPE ty_agrup,
        ls_agrup_max TYPE ty_agrup,
        lv_lines     TYPE i.

  CLEAR gt_selec.
  CLEAR: gt_agrup, gt_agrup_max.
  REFRESH: gt_agrup, gt_agrup_max.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* Cargamos tabla de lineas seleccionadas y agupaciones
  LOOP AT lti_rows INTO ls_row.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv IS NOT INITIAL.
      IF ls_alv-procesado = 'X'.
        pv_error = 'X'.
        EXIT.
      ELSE.
        APPEND ls_alv TO gt_selec.
        IF ls_alv-agru_bob IS NOT INITIAL.
          IF ls_alv-ancho_max_flag <> 'X'.
            ls_agrup-agru_bob = ls_alv-agru_bob.
            COLLECT ls_agrup INTO gt_agrup.
          ELSE.
            ls_agrup-agru_bob = ls_alv-agru_bob.
            COLLECT ls_agrup INTO gt_agrup_max.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF pv_error = 'X'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    CLEAR: gt_agrup. REFRESH: gt_agrup.
    CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
    MESSAGE w083(zpp).
    EXIT.
  ENDIF.

* Si hay agrupaciones verificamos que están
* todas las lineas de cada agrupación
  LOOP AT gt_agrup INTO ls_agrup.
    LOOP AT gt_alv INTO ls_alv WHERE agru_bob = ls_agrup-agru_bob.
      READ TABLE gt_selec TRANSPORTING NO FIELDS
                          WITH KEY vbeln = ls_alv-vbeln
                                   posnr = ls_alv-posnr.
      IF sy-subrc NE 0.
        pv_error = 'X'.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF pv_error = 'X'.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w076(zpp).
    EXIT.
  ENDIF.

* Verificamos que están marcadas todas las líneas de agrupaciones
* de ancho máximo:
  LOOP AT gt_agrup_max INTO ls_agrup_max.
    LOOP AT gt_alv INTO ls_alv WHERE agru_bob = ls_agrup_max-agru_bob
                               AND ancho_max_flag = 'X'.
      READ TABLE gt_selec TRANSPORTING NO FIELDS
                          WITH KEY vbeln = ls_alv-vbeln
                                   posnr = ls_alv-posnr
                                   num_cabo = ls_alv-num_cabo.
      IF sy-subrc NE 0.
        pv_error = 'X'.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w076(zpp).
    EXIT.
  ENDIF.

ENDFORM.                    " LINEAS_MARCADAS_CREAR
*&---------------------------------------------------------------------*
*&      Form  CREACION_ORDENES
*&---------------------------------------------------------------------*
FORM creacion_ordenes CHANGING pv_error.

  DATA: ls_selec     TYPE zspp0026_alv,
        ls_agrup     TYPE ty_agrup,
        ls_agrup_max TYPE ty_agrup,
        lv_aufnr_rol TYPE aufnr,
        lv_auart_rol TYPE aufart,
        lv_aufnr_bob TYPE aufnr,
        lv_auart_bob TYPE aufart,
        lv_ok,
        ls_alv       TYPE zspp0026_alv,
        lv_index     TYPE syst_tabix,
        lv_vbeln     TYPE vbeln_va,
        lv_posnr     TYPE posnr_va.

  DATA: ls_ped_agrup TYPE ty_ped_agrup,
        lt_ped_agrup TYPE ty_t_ped_agrup.


* ini cgijon - 25.05.17
* informar en las órdenes de bobina, la orden de rollo en los siguientes casos:
*         OF a ample màxim
*         OF amb canvi de rotllo
  TYPES: BEGIN OF tipo_orden_bobina,
           aufnr TYPE aufnr.
  TYPES: END OF tipo_orden_bobina.
  TYPES: tty_orden_bobina TYPE TABLE OF tipo_orden_bobina.
  DATA: t_orden_bobina  TYPE         tty_orden_bobina,
        wa_orden_bobina TYPE LINE OF tty_orden_bobina.
* ini cgijon - 25.05.17

  CLEAR: lv_ok, lv_vbeln, lv_posnr.
  CLEAR pv_error.

************************************************************************
* 1. Creamos las ordenes sin AGRUPAR
************************************************************************
  LOOP AT gt_selec INTO ls_selec WHERE agru_bob IS INITIAL
                                 AND cambio_rollo_flag <> 'X'.
    CLEAR ls_alv.
    IF ls_selec-aufnr_rol IS INITIAL.
* INI CMS 27/01/2021 Verificar costes antes de crear OF's
**NLC.14.12.23.Añadimos clear a lv_ok porque no permite crear más de una OF a la vez.
      CLEAR: lv_ok.
**Fin.NLC.14.12.23.Añadimos clear a lv_ok porque no permite crear más de una OF a la vez.
      PERFORM verificar_calculo_costes USING ls_selec-mate_bob
                                       ls_selec-werks_fab
                                       ls_selec-aufa_bob
                                 CHANGING lv_ok.
      CHECK lv_ok <> 'X'.
* FIN CMS


      PERFORM crear_orden_rollo USING    ls_selec
                                CHANGING lv_aufnr_rol
                                         lv_auart_rol
                                         lv_ok.

      " Se ha creado la orden correctamente:
      IF lv_aufnr_rol IS NOT INITIAL AND lv_ok = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_rol = lv_aufnr_rol.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@08@'. "Green light; positive
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

        " Se ha creado la orden y no se ha podido cerrar automáticamente:
      ELSEIF lv_aufnr_rol IS NOT INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_rol = lv_aufnr_rol.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

      ELSEIF lv_aufnr_rol IS INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.
      ENDIF.
    ENDIF.

    IF ls_selec-aufnr_bob IS INITIAL AND ( ls_alv IS INITIAL OR ls_alv-icon <> '@0A@' ).
      PERFORM crear_orden_bobina CHANGING ls_selec
                                          lv_aufnr_bob
                                          lv_auart_bob
                                          lv_ok
                                          lv_vbeln
                                          lv_posnr
                                          lv_aufnr_rol.

      " Se ha creado la orden correctamente:
      IF lv_aufnr_bob IS NOT INITIAL AND lv_ok = 'X'.

        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@08@'. "'@08@'."  Green light; positive
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

        " Se ha creado la orden y no se ha podido cerrar automáticamente:
      ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

      ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

      ENDIF.

    ENDIF.
  ENDLOOP.

************************************************************************
* 2. Creamos las órdenes sin AGRUPAR con cambio rollo - Ancho máximo:
************************************************************************
  LOOP AT gt_selec INTO ls_selec WHERE agru_bob IS INITIAL
                                 AND cambio_rollo_flag = 'X'.

*   verificamos si el material bobina tiene la determinación de costes hecha.
    CLEAR: lv_ok.
    PERFORM verificar_calculo_costes USING ls_selec-mate_bob
                                           ls_selec-werks_fab
                                           ls_selec-aufa_bob
                                     CHANGING lv_ok.

    CHECK lv_ok IS INITIAL.

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                           werks = ls_selec-werks
                                           vbeln = ls_selec-vbeln
                                           posnr = ls_selec-posnr
                                           etenr = ls_selec-etenr
                                           cambio_rollo_flag = 'X'.
    lv_index = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      CLEAR: lv_aufnr_bob, lv_auart_bob, lv_ok, lv_vbeln, lv_posnr.

      " Creamos la orden de rollo:
      IF ls_alv-aufnr_rol IS INITIAL AND ls_alv-icon <> '@0A@'. "Red light; negative
        CLEAR: lv_ok, lv_aufnr_rol, lv_auart_rol.

        PERFORM crear_orden_rollo_cambio USING ls_selec
                                         CHANGING lv_aufnr_rol
                                                  lv_auart_rol
                                                  lv_ok.

        " Se ha creado la orden de rollo correctamente:
        IF lv_aufnr_rol IS NOT INITIAL AND lv_ok = 'X'.
          ls_alv-aufnr_rol = lv_aufnr_rol.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@08@'. "'@08@'."  Green light; positive
          MODIFY gt_alv FROM ls_alv INDEX lv_index.

          " Se ha creado la orden de rollo y no se ha podido cerrar técnicamente:
        ELSEIF lv_aufnr_rol IS NOT INITIAL AND lv_ok <> 'X'.
          pv_error = 'X'.
          ls_alv-aufnr_rol = lv_aufnr_rol.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.

          " Se ha podido cerrar la orden técnicamente:
        ELSEIF lv_aufnr_rol IS INITIAL AND lv_ok <> 'X'.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.
      ENDIF.

      " Creamos la orden de bobina:
      IF ls_alv-aufnr_bob IS INITIAL.
        PERFORM crear_orden_bobina CHANGING ls_selec
                                            lv_aufnr_bob
                                            lv_auart_bob
                                            lv_ok
                                            lv_vbeln
                                            lv_posnr
                                            lv_aufnr_rol.

        IF lv_aufnr_bob IS NOT INITIAL AND lv_ok = 'X'.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          IF ls_alv-aufnr_rol IS NOT INITIAL.
            ls_alv-procesado = 'X'.
            ls_alv-icon = '@08@'. "'@08@'."  Green light; positive
          ENDIF.
          MODIFY gt_alv FROM ls_alv INDEX lv_index.

          " Error: Se ha creado orden de bobina y no se ha podido cerrar técnicamente
        ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.
          pv_error = 'X'.
          " Actualizamos en el listado la orden creada:
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          ls_alv-aufnr_bob = lv_aufnr_bob.
          MODIFY gt_alv FROM ls_alv INDEX lv_index.

        ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
          pv_error = 'X'.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.
      ENDIF.


    ENDIF.
  ENDLOOP.

************************************************************************
* 3. Creamos las ordenes AGRUPADAS
************************************************************************

  CLEAR: t_orden_bobina. REFRESH: t_orden_bobina.

  LOOP AT gt_agrup INTO ls_agrup.

    CLEAR: lt_ped_agrup. REFRESH: lt_ped_agrup.
    CLEAR: t_orden_bobina. REFRESH: t_orden_bobina. FREE t_orden_bobina.

    LOOP AT gt_selec INTO ls_selec WHERE agru_bob = ls_agrup-agru_bob.
*     verificamos si el material bobina tiene la determinación de costes hecha.
      CLEAR: lv_ok.
      PERFORM verificar_calculo_costes USING ls_selec-mate_bob
                                             ls_selec-werks_fab
                                             ls_selec-aufa_bob
                                       CHANGING lv_ok.

      CHECK lv_ok IS INITIAL.

      " Creamos las órdenes de bobinas:
      CLEAR: lv_ok, lv_aufnr_bob, lv_auart_bob.
      PERFORM crear_orden_bobina CHANGING ls_selec
                                          lv_aufnr_bob
                                          lv_auart_bob
                                          lv_ok
                                          lv_vbeln
                                          lv_posnr
                                          lv_aufnr_rol.

      " La orden de bobina se ha creado correctamente:
      IF lv_aufnr_bob IS NOT INITIAL AND lv_ok = 'X'.

*       ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
        wa_orden_bobina-aufnr = lv_aufnr_bob.
        APPEND wa_orden_bobina TO t_orden_bobina.
*       fin cgijon - 25.05.17

        " Guardamos pedido a indicar en datos adicionales orden rollo:
        CLEAR ls_ped_agrup.
        ls_ped_agrup-agru_bob = ls_agrup-agru_bob.
        ls_ped_agrup-kunnr = ls_selec-kunnr.
        ls_ped_agrup-werks = ls_selec-werks.
        ls_ped_agrup-vbeln = ls_selec-vbeln.
        ls_ped_agrup-posnr = ls_selec-posnr.
        ls_ped_agrup-etenr = ls_selec-etenr.
        ls_ped_agrup-mbdat = ls_selec-mbdat.
        ls_ped_agrup-lprio = ls_selec-lprio.
        APPEND ls_ped_agrup TO lt_ped_agrup.

        " Actualizamos listado con orden creada:
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

        " Error: Se ha creado orden de bobina y no se ha podido
        " cerrar técnicamente
      ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.

*       ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
        wa_orden_bobina-aufnr = lv_aufnr_bob.
        APPEND wa_orden_bobina TO t_orden_bobina.
*       fin cgijon - 25.05.17

        pv_error = 'X'.

        " Actualizamos en el listado la orden creada:
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.


      ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               vbeln = ls_selec-vbeln
                                               etenr = ls_selec-etenr
                                               posnr = ls_selec-posnr.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'.
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.
      ENDIF.

    ENDLOOP.


** INI Creacion OF Rollo CMS
    " Creamos la orden de rollo con agrupación:
    CLEAR: lv_ok, lv_aufnr_rol, lv_auart_rol.

    IF lt_ped_agrup[] IS NOT INITIAL.
      CLEAR ls_ped_agrup.
      READ TABLE lt_ped_agrup INTO ls_ped_agrup INDEX 1.
      IF ls_ped_agrup IS NOT INITIAL.
        ls_selec-vbeln = ls_ped_agrup-vbeln.
        ls_selec-posnr = ls_ped_agrup-posnr.
        ls_selec-etenr = ls_ped_agrup-etenr.
        ls_selec-kunnr = ls_ped_agrup-kunnr.
        ls_selec-werks = ls_ped_agrup-werks.
      ENDIF.
    ENDIF.

    PERFORM crear_orden_rollo_agrup TABLES lt_ped_agrup
                                    USING    ls_selec
                                    CHANGING lv_aufnr_rol
                                             lv_auart_rol
                                             lv_ok.

    " Se ha creado la orden de rollo correctamente:
    IF lv_aufnr_rol IS NOT INITIAL AND lv_ok = 'X'.
      " Actualizamos listado con la orden creada:
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup-agru_bob
                                 AND procesado <> 'X'
                                 AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-aufnr_rol = lv_aufnr_rol.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@08@'. "Green light; positive
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.

      " Se ha creado la orden de rollo y no se ha podido cerrar técnicamente:
    ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.
      pv_error = 'X'.
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup-agru_bob
                                 AND procesado <> 'X'
                                 AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-aufnr_rol = lv_aufnr_rol.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@0A@'.  "Red light; negative
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.

      "   Se ha podido cerrar la orden técnicamente:
    ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
      pv_error = 'X'.
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup-agru_bob
                                   AND procesado <> 'X'
                                   AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@0A@'. "Red light; negative
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.
    ENDIF.
** END Creacion OF Rollo

*   ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
    IF lv_aufnr_bob IS NOT INITIAL.
      LOOP AT t_orden_bobina INTO  wa_orden_bobina.
        PERFORM inf_ordrollo_en_ordenbobina USING wa_orden_bobina-aufnr
                                                  lv_aufnr_rol
                                            CHANGING lv_ok.

      ENDLOOP.
    ENDIF.
*   fin cgijon - 25.05.17
  ENDLOOP.

************************************************************************
* 4. Creamos las ordenes AGRUPADAS ANCHO MÁXIMO
************************************************************************
  CLEAR: t_orden_bobina. REFRESH: t_orden_bobina.

  LOOP AT gt_agrup_max INTO ls_agrup_max.
    CLEAR: lt_ped_agrup, lv_vbeln, lv_posnr.
    REFRESH: lt_ped_agrup.

    LOOP AT gt_selec INTO ls_selec WHERE agru_bob = ls_agrup_max-agru_bob.
*     verificamos si el material bobina tiene la determinación de costes hecha.
      CLEAR: lv_ok.
      PERFORM verificar_calculo_costes USING ls_selec-mate_bob
                                             ls_selec-werks_fab
                                             ls_selec-aufa_bob
                                       CHANGING lv_ok.

      CHECK lv_ok IS INITIAL.

      " Creamos las órdenes de bobinas:
      PERFORM crear_orden_bobina CHANGING ls_selec
                                          lv_aufnr_bob
                                          lv_auart_bob
                                          lv_ok
                                          lv_vbeln
                                          lv_posnr
                                          lv_aufnr_rol.

      " La orden de bobina se ha creado correctamente:
      IF lv_aufnr_bob IS NOT INITIAL AND lv_ok = 'X'.

*       ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
        wa_orden_bobina-aufnr = lv_aufnr_bob.
        APPEND wa_orden_bobina TO t_orden_bobina.
*       fin cgijon - 25.05.17

        " Guardamos pedido a indicar en datos adicionales orden rollo:
        CLEAR ls_ped_agrup.
        ls_ped_agrup-agru_bob = ls_agrup_max-agru_bob.
        ls_ped_agrup-kunnr = ls_selec-kunnr.
        ls_ped_agrup-werks = ls_selec-werks.
        ls_ped_agrup-vbeln = ls_selec-vbeln.
        ls_ped_agrup-posnr = ls_selec-posnr.
        ls_ped_agrup-etenr = ls_selec-etenr.
        ls_ped_agrup-mbdat = ls_selec-mbdat.
        ls_ped_agrup-lprio = ls_selec-lprio.
        APPEND ls_ped_agrup TO lt_ped_agrup.

        " Actualizamos listado con orden creada:
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               agru_bob = ls_agrup_max-agru_bob
                                               ancho_max_flag = 'X'
                                               num_cabo = ls_selec-num_cabo.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          ls_alv-vbeln = ls_selec-vbeln.
          ls_alv-posnr = ls_selec-posnr.
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

        " Error: Se ha creado orden de bobina y no se ha podido cerrar técnicamente
      ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.
*       ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
        wa_orden_bobina-aufnr = lv_aufnr_bob.
        APPEND wa_orden_bobina TO t_orden_bobina.
*       fin cgijon - 25.05.17

        pv_error = 'X'.

        " Actualizamos en el listado la orden creada:
        CLEAR ls_alv.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               agru_bob = ls_agrup_max-agru_bob
                                               ancho_max_flag = 'X'
                                               num_cabo = ls_selec-num_cabo.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-aufnr_bob = lv_aufnr_bob.
          ls_alv-vbeln = ls_selec-vbeln.
          ls_alv-posnr = ls_selec-posnr.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.

      ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
        pv_error = 'X'.
        READ TABLE gt_alv INTO ls_alv WITH KEY kunnr = ls_selec-kunnr
                                               werks = ls_selec-werks
                                               agru_bob = ls_agrup_max-agru_bob
                                               ancho_max_flag = 'X'
                                               num_cabo = ls_selec-num_cabo.
        lv_index = sy-tabix.
        IF ls_alv IS NOT INITIAL.
          ls_alv-procesado = 'X'.
          ls_alv-icon = '@0A@'. "Red light; negative
          MODIFY gt_alv FROM ls_alv INDEX lv_index.
        ENDIF.
      ENDIF.
    ENDLOOP.

    " Creamos la orden de rollo con agrupación:
    CLEAR: lv_ok, lv_aufnr_rol, lv_auart_rol.

    IF lt_ped_agrup[] IS NOT INITIAL.
      CLEAR ls_ped_agrup.
      READ TABLE lt_ped_agrup INTO ls_ped_agrup INDEX 1.
      IF ls_ped_agrup IS NOT INITIAL.
        ls_selec-vbeln = ls_ped_agrup-vbeln.
        ls_selec-posnr = ls_ped_agrup-posnr.
        ls_selec-kunnr = ls_ped_agrup-kunnr.
        ls_selec-etenr = ls_ped_agrup-etenr.
        ls_selec-werks = ls_ped_agrup-werks.
      ENDIF.
    ENDIF.

    PERFORM crear_orden_rollo_agrup TABLES lt_ped_agrup
                                    USING    ls_selec
                                    CHANGING lv_aufnr_rol
                                             lv_auart_rol
                                             lv_ok.

    " Se ha creado la orden de rollo correctamente:
    IF lv_aufnr_rol IS NOT INITIAL AND lv_ok = 'X'.
      " Actualizamos listado con la orden creada:
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup_max-agru_bob
                                   AND procesado <> 'X'
                                   AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-aufnr_rol = lv_aufnr_rol.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@08@'. "Green light; positive
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.


      " Se ha creado la orden de rollo y no se ha podido cerrar técnicamente:
    ELSEIF lv_aufnr_bob IS NOT INITIAL AND lv_ok <> 'X'.
      pv_error = 'X'.
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup_max-agru_bob
                                   AND procesado <> 'X'
                                   AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-aufnr_rol = lv_aufnr_rol.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@0A@'.
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.

      " Se ha podido cerrar la orden técnicamente:
    ELSEIF lv_aufnr_bob IS INITIAL AND lv_ok <> 'X'.
      pv_error = 'X'.
      LOOP AT gt_alv INTO ls_alv WHERE agru_bob =  ls_agrup_max-agru_bob
                                   AND procesado <> 'X'
                                   AND icon <> '@0A@'.
        lv_index = sy-tabix.
        ls_alv-procesado = 'X'.
        ls_alv-icon = '@0A@'.
        MODIFY gt_alv FROM ls_alv INDEX lv_index.
      ENDLOOP.

    ENDIF.

*   ini cgijon - 25.05.17: informar en las órdenes de bobina, la orden de rollo
    IF lv_aufnr_bob IS NOT INITIAL.
      LOOP AT t_orden_bobina INTO  wa_orden_bobina.
        PERFORM inf_ordrollo_en_ordenbobina USING wa_orden_bobina-aufnr
                                                  lv_aufnr_rol
                                            CHANGING lv_ok.

      ENDLOOP.
    ENDIF.
*   fin cgijon - 25.05.17
  ENDLOOP.

  CLEAR: gt_selec. REFRESH: gt_selec.
  CLEAR: gt_agrup. REFRESH: gt_agrup.
  CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.

ENDFORM.                    " CREACION_ORDENES

*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_ROLLO
*&---------------------------------------------------------------------*
FORM crear_orden_rollo  USING    ps_selec TYPE zspp0026_alv
                        CHANGING pv_aufnr_rol
                                 pv_auart_rol
                                 pv_ok.

  DATA: ls_orderdata     TYPE bapi_pi_order_create,
        lt_return        TYPE bapiret2_t,
        ls_return        TYPE bapiret2,
        lv_aufnr         TYPE aufnr,
        lv_auart         TYPE aufart,
        ls_listado1      LIKE gt_listado1,
        lv_rol1          TYPE zrollos,
        lv_tor1          TYPE ztornada,
        lv_rol2          TYPE zrollos,
        lv_tor2          TYPE ztornada,
        lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10),
        lv_fecha_aux(10),
        lv_fecha         TYPE co_gstrp,
        lt_orders        TYPE tb_bapi_order_key,
        ls_orders        TYPE bapi_order_key.

  DATA: lv_ok        TYPE xflag,
        lv_cont      TYPE i,
        lv_aufnr_aux TYPE aufnr.

  DATA: lv_tipo(1),
        lv_error   TYPE xfeld.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, pv_ok,
         ls_listado1.
  REFRESH lt_return.

  " Encontrar la fecha de inicio que tenemos que pasar para crear la
  " orden:
  CLEAR lv_fecha.
  PERFORM f_calc_fech USING ps_selec-werks
                            ps_selec-mbdat
                      CHANGING lv_fecha.


  ls_orderdata-material         = ps_selec-mate_rol.
*  ls_orderdata-plant            = ps_selec-werks.
  ls_orderdata-plant            = ps_selec-werks_fab.
  ls_orderdata-order_type       = ps_selec-aufa_rol.
  ls_orderdata-quantity         = ps_selec-cant_rol.
  ls_orderdata-quantity_uom     = ps_selec-unid_rol.
*  ls_orderdata-basic_start_date = lv_fecha.
  ls_orderdata-basic_end_date = lv_fecha.

* Marcar prioridad de la orden como urgente:
  IF ps_selec-lprio = '01'.
    ls_orderdata-order_priority = ps_selec-lprio+1(1).
  ENDIF.

  " Tipo: Creación
  CLEAR lv_tipo.
  lv_tipo = 'C'.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.


  IF lv_aufnr IS INITIAL.
    " Error
    CLEAR: pv_ok, pv_aufnr_rol, pv_auart_rol.
    PERFORM registrar_log USING ps_selec
                                ls_return
                                lv_tipo
                                ps_selec-aufa_rol
                                ' '.

  ELSE.
*   CGIJON: INI 13.02.17 - SI LA ORDEN SE CREA CON ESTATUS I0045 Ó I0115
*   NO HACEMOS EL COMMIT Y EMITIMOS UN MENSAJE DE ERROR EN EL LOG.

* 28/01/2021 - CMS espera antes de obtener los estados de OF
    PERFORM validar_estado_of_edet USING    lv_aufnr
                                         ps_selec
                                CHANGING lv_error.
    IF lv_error = 'X'.
      CLEAR: pv_aufnr_rol, pv_auart_rol, pv_ok.  "Al limpiar "pv_aufnr_rol", luego no sigue procesando.
      EXIT.
    ELSE.

*   CGIJON: FIN 13.02.17 - SI LA ORDEN SE CREA CON ESTATUS I0045 Ó I0115
*   NO HACEMOS EL COMMIT Y EMITIMOS UN MENSAJE DE ERROR EN EL LOG.

      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      pv_aufnr_rol = lv_aufnr.
      pv_auart_rol = ps_selec-aufa_rol.

      PERFORM espera_orden_creada USING lv_aufnr.

      " Recuperar datos rollos y tornadas:
      CLEAR: lv_rol1, lv_rol2, lv_tor1, lv_tor2.
      PERFORM dat_rollo_torn USING ps_selec-wmeng
                                   ps_selec-anch_bob
                             CHANGING lv_rol1
                                      lv_tor1
                                      lv_rol2
                                      lv_tor2.

      PERFORM espera_bloqueo_orden USING lv_aufnr.

      CLEAR lv_error.
      PERFORM datos_adic_rol USING lv_aufnr
                                   ps_selec
                                   lv_rol1
                                   lv_tor1
                                   lv_rol2
                                   lv_tor2
                             CHANGING lv_error.

      IF lv_error = 'X'.

        CLEAR: ls_listado1.

        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.

        CLEAR ls_return.
        ls_return-type = 'E'.
        ls_return-message = ls_listado1-msg_ret.

        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.

        PERFORM espera_bloqueo_orden USING lv_aufnr.
        PERFORM cerrar_tec_orden USING lv_aufnr
                                 CHANGING ls_return.

        IF ls_return-type = 'E'.

          CLEAR: pv_ok.
          pv_aufnr_rol = lv_aufnr.
          pv_auart_rol = ps_selec-aufa_rol.

          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_rol
                                      lv_aufnr.

        ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND
        ls_return-number = '889'.

          CLEAR: pv_aufnr_rol, pv_auart_rol, pv_ok.
          PERFORM registrar_log USING ps_selec
                              ls_return
                              lv_tipo
                              ps_selec-aufa_rol
                              lv_aufnr.

        ENDIF.
      ELSE.
        " Todo el proceso ha ido correctamente:
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.

        pv_ok = 'X'.
        pv_aufnr_rol = lv_aufnr.
        pv_auart_rol = ps_selec-aufa_rol.

        CLEAR ls_return.
        ls_return-type = 'S'.
        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.
      ENDIF.
    ENDIF. "CGIJON: FIN 13.02.17
  ENDIF.


ENDFORM.                    " CREAR_ORDEN_ROLLO

FORM validar_estado_of_edet USING    p_aufnr
                                     ps_selec TYPE zspp0026_alv
                            CHANGING pv_ok.

  DATA: lv_objnr  TYPE jest-objnr,
        ls_return TYPE bapiret2.

  CONCATENATE  'OR' p_aufnr INTO lv_objnr .

  PERFORM espera_orden_creada USING p_aufnr.

  SELECT SINGLE *
     INTO @DATA(wa_jest)
     FROM jest
     WHERE objnr = @lv_objnr AND
          ( stat = 'I0045' OR stat = 'I0115' ) AND
          inact = ' '.

  IF sy-subrc = 0.
    PERFORM cerrar_tec_orden USING p_aufnr
                             CHANGING ls_return.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

*    ROLLBACK WORK.

    ls_return-type = 'E'.
    ls_return-id = 'ZPP'.
    ls_return-number = '121'.
    ls_return-message = 'Error en la determinación de costes'.

*    CLEAR: pv_aufnr_rol, pv_auart_rol, pv_ok.
    PERFORM registrar_log USING ps_selec
                        ls_return
                        'C'
                        ps_selec-aufa_rol
                        p_aufnr.

    CALL FUNCTION 'ZPP_PANTALLA_AVISO'
      EXPORTING
        titulo   = 'Error en la creación de OF'
        tp_icono = 'E'
        text1    = 'OF CON ERROR DE COSTES.'
        text2    = 'No se crea la OF.'.
    pv_ok = 'X'.
  ELSE.
    pv_ok = ' '.
  ENDIF.

ENDFORM.                    " CREAR_ORDEN_ROLLO
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_BOBINA
*&---------------------------------------------------------------------*
FORM crear_orden_bobina  CHANGING ps_selec TYPE zspp0026_alv
                                  pv_aufnr_bob
                                  pv_auart_bob
                                  pv_ok
                                  pv_vbeln
                                  pv_posnr
                                  pv_aufnr_rol.


  DATA: ls_orderdata TYPE bapi_pi_order_create,
        lt_return    TYPE bapiret2_t,
        ls_return    TYPE bapiret2,
        lv_aufnr     TYPE aufnr,
        lv_auart     TYPE aufart,
        ls_listado1  LIKE gt_listado1,
        lv_fecha     TYPE co_gstrp.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2,
        ls_resb        TYPE resb.

  DATA: lv_tipo(1),
        lv_error    TYPE xfeld,
        lv_mod_comp TYPE flag.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, ls_listado1.
  REFRESH: lt_return.

  "Buscamos la fecha de inicio extrema que tenemos que indicar en la
  "orden:
  CLEAR: lv_fecha, lv_tipo.
  PERFORM f_calc_fech USING ps_selec-werks
                            ps_selec-mbdat
                      CHANGING lv_fecha.

  " Buscamos el nº de pedido y posición ( si no existe ):
  IF ( ps_selec-vbeln IS INITIAL AND ps_selec-posnr IS INITIAL )
    AND ( pv_vbeln IS INITIAL AND pv_posnr IS INITIAL ).
    " Buscamos nº de pedido y posición:
    CALL FUNCTION 'NUMBER_GET_NEXT'
      EXPORTING
        nr_range_nr             = '01'
        object                  = 'ZPPCABOPED'
      IMPORTING
        number                  = pv_vbeln
      EXCEPTIONS
        interval_not_found      = 1
        number_range_not_intern = 2
        object_not_found        = 3
        quantity_is_0           = 4
        quantity_is_not_1       = 5
        interval_overflow       = 6
        buffer_overflow         = 7
        OTHERS                  = 8.

    IF sy-subrc <> 0.
      CLEAR: pv_aufnr_bob, pv_auart_bob, pv_ok.
      " Registrar Error
      lv_tipo = 'C'.
      CLEAR ls_return.
      ls_return-type = 'E'.
      ls_return-message = text-013.

      PERFORM registrar_log USING ps_selec
                                  ls_return
                                  lv_tipo
                                  ps_selec-aufa_bob
                                  ' '.
    ELSE.
      pv_posnr = pv_posnr + '000010'.
      ps_selec-vbeln = pv_vbeln.
      ps_selec-posnr = pv_posnr.
    ENDIF.

  ELSEIF ( ps_selec-vbeln IS INITIAL AND ps_selec-posnr IS INITIAL )
    AND pv_vbeln IS NOT INITIAL.
    " Buscamos sólamente nº posición:
    pv_posnr = pv_posnr + '000010'.
    ps_selec-vbeln = pv_vbeln.
    ps_selec-posnr = pv_posnr.
  ENDIF.

  ls_orderdata-material         = ps_selec-mate_bob.
*  ls_orderdata-plant            = ps_selec-werks.
  ls_orderdata-plant            = ps_selec-werks_fab.
  ls_orderdata-order_type       = ps_selec-aufa_bob.
  ls_orderdata-quantity         = ps_selec-cant_bob.
  ls_orderdata-quantity_uom     = ps_selec-unid_bob.
*  ls_orderdata-basic_start_date = lv_fecha.
  ls_orderdata-basic_end_date = lv_fecha.

  IF ps_selec-lprio = '01'.
    ls_orderdata-order_priority = ps_selec-lprio+1(1).
  ENDIF.

  " Creación orden:
  lv_tipo = 'C'.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.

  IF lv_aufnr IS INITIAL.

    CLEAR: pv_aufnr_bob, pv_auart_bob, pv_ok.

    " Registrar Error
    PERFORM registrar_log USING ps_selec
                                ls_return
                                lv_tipo
                                ps_selec-aufa_bob
                                ' '.
  ELSE.


* 28/01/2021 - CMS espera antes de obtener los estados de OF
    PERFORM validar_estado_of_edet USING    lv_aufnr
                                         ps_selec
                                CHANGING lv_error.
    IF lv_error = 'X'.
*      CL EAR: pv_aufnr_rol, pv_auart_rol, pv_ok.  "Al limpiar "pv_aufnr_rol", luego no sigue procesando.
      CLEAR: pv_aufnr_bob, pv_auart_bob, pv_ok.
      EXIT.
    ELSE.



      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      pv_aufnr_bob = lv_aufnr.
      pv_auart_bob = ps_selec-aufa_bob.

      PERFORM espera_orden_creada USING lv_aufnr.
      PERFORM espera_bloqueo_orden USING lv_aufnr.
      CLEAR lv_error.
      PERFORM datos_adic_bob USING lv_aufnr
                                   pv_aufnr_rol
                                   ps_selec
                             CHANGING lv_error.

      IF lv_error = 'X'.

        CLEAR ls_listado1.
        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.
        CLEAR ls_return.
        ls_return-type = 'E'.
        ls_return-message = ls_listado1-msg_ret.

        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_bob
                                    lv_aufnr.

* Cerrar técnicamente órdenes erróneas:
        PERFORM espera_bloqueo_orden USING lv_aufnr.
        PERFORM cerrar_tec_orden USING lv_aufnr
                                 CHANGING ls_return.

        IF ls_return-type = 'E'.

          CLEAR: pv_ok.
          pv_aufnr_bob = lv_aufnr.
          pv_auart_bob = ps_selec-aufa_bob.

          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_bob
                                      lv_aufnr.

        ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND
        ls_return-number = '889'.

          CLEAR: pv_aufnr_bob, pv_auart_bob, pv_ok.

          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_bob
                                      lv_aufnr.
        ENDIF.

      ELSE.
        " Se han grabado los datos adicionales correctamente:
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.

        pv_aufnr_bob = lv_aufnr.
        pv_auart_bob = ps_selec-aufa_bob.

*     IEG - 29.03.2017: Modificación para cambiar el componente
        CLEAR lv_mod_comp.
        IF ps_selec-agru_bob IS INITIAL AND
           ps_selec-cambio_rollo_flag IS INITIAL.

*       Sacamos el componente de la reserva de rollo
          SELECT SINGLE * INTO ls_resb
              FROM  resb
              WHERE aufnr = lv_aufnr
              AND   sortf = 'ROLLO'.
          IF sy-subrc = 0.
*         Si cambia el material de rollo, tenemos que modificar el componente de la orden
            IF ls_resb-matnr <> ps_selec-mate_rol.
*           Forzamos que entre en el IF siguiente para modificar el componente
              ps_selec-cambio_rollo_flag = 'X'.
*           Cargamos las variables para que realice el cambio
              ps_selec-mate_rol_agrup = ps_selec-mate_rol.
              ps_selec-cant_rol_agrup = ls_resb-bdmng.
              ps_selec-unid_rol = ls_resb-meins.
*           Cargamos un flag para saber que hemos forzado esto
              lv_mod_comp = 'X'.
            ENDIF.
          ENDIF.
        ENDIF.
*     IEG - 29.03.2017: Fin modificación

        IF ps_selec-agru_bob IS NOT INITIAL
           OR ps_selec-cambio_rollo_flag = 'X'.
          " Se modifica el componente de rollo de la resb:
          PERFORM espera_orden_creada USING lv_aufnr.
          PERFORM espera_bloqueo_orden USING lv_aufnr.

          PERFORM mod_comp_zrol_bob USING lv_aufnr
                                          ps_selec
                                    CHANGING lv_error
                                             ls_return.

*       IEG - 29.03.2017: Modificación para cambiar el componente
*       Si hemos modificado el componente forzándolo, volvemos a dejar los datos
*       de la PS_SELECT como estaban
          IF lv_mod_comp = 'X'.
            CLEAR: lv_mod_comp, ps_selec-mate_rol_agrup, ps_selec-cant_rol_agrup.
          ENDIF.
*       IEG - 29.03.2017: Fin modificación

          IF lv_error = 'X'.

            " Cerrar técnicamente órdenes erróneas:

            PERFORM cerrar_tec_orden USING lv_aufnr
                                     CHANGING ls_return.

            IF ls_return-type = 'E'.

              pv_aufnr_bob = lv_aufnr.
              pv_auart_bob = ps_selec-aufa_bob.
              CLEAR pv_ok.

              PERFORM registrar_log USING ps_selec
                                          ls_return
                                          lv_tipo
                                          ps_selec-aufa_bob
                                          lv_aufnr.

            ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND
            ls_return-number = '889'.

              CLEAR: pv_aufnr_bob, pv_auart_bob, pv_ok.
              PERFORM registrar_log USING ps_selec
                                          ls_return
                                          lv_tipo
                                          ps_selec-aufa_bob
                                          lv_aufnr.
            ENDIF.

          ELSE.

            pv_aufnr_bob = lv_aufnr.
            pv_auart_bob = ps_selec-aufa_bob.
            pv_ok = 'X'.


            " Grabar mensaje de éxito en log
            CLEAR ls_return.
            ls_return-type = 'S'.
            PERFORM registrar_log USING ps_selec
                                        ls_return
                                        lv_tipo
                                        ps_selec-aufa_bob
                                        lv_aufnr.

          ENDIF.

        ELSE.

          pv_aufnr_bob = lv_aufnr.
          pv_auart_bob = ps_selec-aufa_bob.
          pv_ok = 'X'.

          CLEAR ls_return.
          ls_return-type = 'S'.
          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_bob
                                      lv_aufnr.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " CREAR_ORDEN_BOBINA
*&---------------------------------------------------------------------*
*&      Form  SACAR_LOG
*&---------------------------------------------------------------------*
*& Sacamos un listado de todo los que se ha creado, así como los errores
*& tanto en la creación de órdenes nuevas de pedido, como en la
*& secuenciación
*&---------------------------------------------------------------------*
FORM sacar_log .

  CALL SCREEN 0100.

ENDFORM.                    " SACAR_LOG
*&---------------------------------------------------------------------*
*&      Form  LINEAS_MARCADAS_AGRUPAR
*&---------------------------------------------------------------------*
FORM lineas_marcadas_agrupar  CHANGING  pv_error
                                        pv_peso_rollo.
  DATA: lti_rows TYPE lvc_t_roid,
        ls_row   TYPE lvc_s_roid,
        ls_alv   TYPE zspp0026_alv,
        lv_lines TYPE i.

  DATA: pv_error2        TYPE xfeld,
        pv_error3        TYPE xfeld,
        pv_error4        TYPE xfeld,
        pv_error5        TYPE xfeld,
        lv_verid_bob     TYPE verid,
        lv_verid_rol     TYPE verid,
        lv_ancho_trim    TYPE i,
        lv_ancho_min_bob TYPE i, "cgijon: 13/02/17
        l_ancho_5mm      TYPE zancho.
  CLEAR gt_selec.
  CLEAR: gv_rollo, gv_zzgramaje, gv_zzancho, gv_matkl.
  CLEAR: gv_werks_fab.
  CLEAR: pv_peso_rollo.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* Si sólo hay una línea marcada -> ERROR
  IF lv_lines = 1.
    pv_error = 'X'.
    MESSAGE w078(zpp).
    EXIT.
  ENDIF.

* Si se han seleccionado más de tres líneas para agrupar:
  IF lv_lines > 3.
    pv_error = 'X'.
    MESSAGE w081(zpp).
    EXIT.
  ENDIF.

* Verificamos que no estén ya en una agrupación
* Verificamos que las líneas no estén procesadas
* Verificamos que no tengan ni orden de rollo, ni de bobina
* creadas
  CLEAR: pv_error2, pv_error3, pv_error4, pv_error5.
  LOOP AT lti_rows INTO ls_row.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv-agru_bob IS NOT INITIAL.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ELSEIF ls_alv-procesado = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error2 = 'X'.
      EXIT.
    ELSEIF ls_alv-aufnr_bob IS NOT INITIAL
           OR ls_alv-aufnr_rol IS NOT INITIAL.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error3 = 'X'.
      EXIT.
    ELSEIF ls_alv-cambio_rollo_flag = 'X'.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error5 = 'X'.
      EXIT.
    ELSE.

      CLEAR lv_verid_bob.
      SELECT SINGLE verid INTO lv_verid_bob
        FROM mkal
        WHERE matnr = ls_alv-mate_bob
        AND werks = ls_alv-werks_fab
        AND verid = gc_verid.

      IF lv_verid_bob IS NOT INITIAL.
        pv_peso_rollo = pv_peso_rollo + ls_alv-cant_rol.
        APPEND ls_alv TO gt_selec.
      ELSE.
        CLEAR: gt_selec. REFRESH: gt_selec.
        pv_error4 = 'X'.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w077(zpp).
    EXIT.
  ELSEIF pv_error2 = 'X'.
    pv_error = 'X'.
    MESSAGE w083(zpp).
    EXIT.
  ELSEIF pv_error3 = 'X'.
    pv_error = 'X'.
    MESSAGE w084(zpp).
    EXIT.
  ELSEIF pv_error4 = 'X'.
    pv_error = 'X'.
    MESSAGE w103(zpp) WITH ls_alv-mate_bob ls_alv-werks_fab.
    EXIT.
  ELSEIF pv_error5 = 'X'.
    pv_error = 'X'.
    MESSAGE w108(zpp).
    EXIT.
  ENDIF.

* Verificamos que todas las bobinas tengan el mismo:
* Gramaje, Grupo de artículos y Centro de fabricación
  LOOP AT gt_selec INTO ls_alv.

* 69669 - CMS - 22/12/2021
* Verificar si el ancho acaba en 5mm (DS Smith)
    PERFORM determinar_si_5mm USING ls_alv-anch_bob
                           CHANGING l_ancho_5mm.

    ADD l_ancho_5mm TO gv_zzancho.
*    ADD ls_alv-anch_bob TO gv_zzancho.

    IF gv_zzgramaje IS INITIAL AND
       gv_matkl     IS INITIAL AND
       gv_werks_fab IS INITIAL.
      gv_zzgramaje = ls_alv-gram_bob.
      gv_matkl     = ls_alv-matk_bob.
      gv_werks_fab = ls_alv-werks_fab.
*      pv_peso_rollo = pv_peso_rollo + ls_alv-cant_rol.
    ELSEIF  gv_zzgramaje NE ls_alv-gram_bob OR
            gv_matkl     NE ls_alv-matk_bob OR
            gv_werks_fab NE ls_alv-werks_fab.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w079(zpp).
    EXIT.
  ENDIF.

* IEG - 27.12.2016: Recuperamos el ANCHO TRIM tabla ZTPP0008
  PERFORM recuperar_ancho_trim USING    ls_alv-werks_fab
                                        ls_alv-mate_bob
                               CHANGING lv_ancho_trim
                                        lv_ancho_min_bob.
* IEG - 27.12.2016 - Fin modificación

* Buscamos el ROLLO
* Debe ser un ZROL con el mismo gramaje y GR.Articulos
* y con un ancho igual a la suma de anchos más 40
  ADD lv_ancho_trim TO gv_zzancho.
  PERFORM buscar_rollo USING gv_zzancho
                             gv_zzgramaje
                             gv_matkl
                       CHANGING gv_rollo
                                pv_error.
  IF pv_error = 'X'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    MESSAGE w080(zpp).
    EXIT.
  ENDIF.

  " Chequeamos que el material rollo tiene versión de fabricación:
  CLEAR lv_verid_rol.
  SELECT SINGLE verid INTO lv_verid_rol
    FROM mkal
    WHERE matnr = gv_rollo
    AND werks = gv_werks_fab
    AND verid = gc_verid.

  IF lv_verid_rol IS INITIAL.
    pv_error = 'X'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    MESSAGE i103(zpp) WITH gv_rollo gv_werks_fab DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.


ENDFORM.                    " LINEAS_MARCADAS_AGRUPAR

* 69669 - CMS - 22/12/2021
* Verificar si el ancho acaba en 5mm (DS Smith)
FORM determinar_si_5mm USING p_ancho     TYPE zancho
                    CHANGING p_ancho_out TYPE zancho.

  DATA: l_ult_pos TYPE char1.
  DATA: l_pos TYPE n.
  DATA: l_string TYPE string.

*Calcular ancho, y restar 1.
  l_pos = strlen( p_ancho ).
  l_pos     = l_pos - 1.

  l_string  = p_ancho.

* Obtener la última posición.
  l_ult_pos = l_string+l_pos(1).

  IF l_ult_pos = '5'.
    p_ancho_out = p_ancho + 5.
  ELSE.
    p_ancho_out = p_ancho.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  BUSCAR_ROLLO
*&---------------------------------------------------------------------*
FORM buscar_rollo USING    pv_zzancho   TYPE zancho
                           pv_zzgramaje TYPE zgramaje
                           pv_matkl     TYPE matkl
                  CHANGING pv_rollo     TYPE matnr
                           pv_error.
  DATA: lv_mtart TYPE mtart VALUE 'ZROL'.
  CLEAR pv_rollo.

  SELECT SINGLE matnr INTO pv_rollo
    FROM mara
    WHERE matkl     = pv_matkl
    AND   lvorm     = abap_false  "uDefine - orden HEDK907392 ticket 45541
    AND   mtart     = lv_mtart
    AND   ( mstae   = abap_false OR mstae = '00' )  "uDefine - orden HEDK907392 ticket 45541
    AND   zzgramaje = pv_zzgramaje
    AND   zzancho   = pv_zzancho.
  IF sy-subrc NE 0.
    pv_error = 'X'.
    EXIT.
  ENDIF.

ENDFORM.                    " BUSCAR_ROLLO
*&---------------------------------------------------------------------*
*&      Form  MARCAR_AGRUPACION
*&---------------------------------------------------------------------*
FORM marcar_agrupacion USING pv_peso_rollo.

  DATA: ls_alv       TYPE zspp0026_alv,
        ls_selec     TYPE zspp0026_alv,
        lv_agru      TYPE char3,
        lv_ind       TYPE i,
        lv_maktx     TYPE maktx,
        lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho.

* Recuperar datos de material de rollo:
  CLEAR: lv_maktx, lv_zzgramaje, lv_zzancho.
  SELECT SINGLE maktx INTO lv_maktx
    FROM makt
    WHERE matnr = gv_rollo
    AND spras = sy-langu.

  SELECT SINGLE zzgramaje zzancho
    INTO (lv_zzgramaje, lv_zzancho )
    FROM mara
    WHERE matnr = gv_rollo.

* Indicador de agrupacion
  ADD 1 TO gv_agru_bob.
  WRITE gv_agru_bob TO lv_agru RIGHT-JUSTIFIED.

  LOOP AT gt_selec INTO ls_selec.

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv WITH KEY vbeln = ls_selec-vbeln
                                           posnr = ls_selec-posnr
                                           etenr = ls_selec-etenr.
    lv_ind = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      ls_alv-agru_bob = lv_agru.
      ls_alv-cant_rol_agrup = pv_peso_rollo.
      ls_alv-mate_rol_agrup = gv_rollo.
      ls_alv-desc_rol_agrup = lv_maktx.
      ls_alv-gram_rol = lv_zzgramaje.
*      ls_alv-anch_rol = lv_zzancho.
      ls_alv-anch_rol_agrup = lv_zzancho.
      MODIFY gt_alv FROM ls_alv INDEX lv_ind.
    ENDIF.

  ENDLOOP.

  CLEAR: gt_selec. REFRESH: gt_selec.

ENDFORM.                    " MARCAR_AGRUPACION
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR_LISTADO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM refrescar_listado .

  DATA: ls_stable TYPE lvc_s_stbl.

  " Refrescamos el listado:
  CLEAR ls_stable.
  ls_stable-row = 'X'.
  ls_stable-col = 'X'.
  CALL METHOD gcl_grid->refresh_table_display
    EXPORTING
      is_stable = ls_stable
    EXCEPTIONS
      finished  = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
  ENDIF.


ENDFORM.                    " REFRESCAR_LISTADO
*&---------------------------------------------------------------------*
*&      Form  REGISTRAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_SELEC  text
*      -->P_LS_RETURN  text
*----------------------------------------------------------------------*
FORM registrar_log  USING    ps_selec TYPE zspp0026_alv
                             ps_return TYPE bapiret2
                             p_tipo
                             p_auart
                             p_aufnr.

  DATA: ls_log TYPE ty_log.

  CLEAR ls_log.

  ls_log-vbeln = ps_selec-vbeln.
  ls_log-posnr = ps_selec-posnr.
  ls_log-mbdat = ps_selec-mbdat.
  ls_log-etenr = ps_selec-etenr.
  IF p_auart = gc_aufa_bob.
    ls_log-matnr = ps_selec-mate_bob.
    ls_log-maktx = ps_selec-desc_bob.
  ELSEIF p_auart = gc_aufa_rol.
    IF ps_selec-agru_bob IS NOT INITIAL
    OR ps_selec-cambio_rollo_flag IS NOT INITIAL . " Visualización correcta del material en el log 51237

      ls_log-matnr = ps_selec-mate_rol_agrup.
      ls_log-maktx = ps_selec-desc_rol_agrup.
    ELSE.
      ls_log-matnr = ps_selec-mate_rol.
      ls_log-maktx = ps_selec-desc_rol.
    ENDIF.
  ENDIF.
  ls_log-auart = p_auart.
  IF p_aufnr IS NOT INITIAL.
    ls_log-aufnr = p_aufnr.
  ENDIF.
  ls_log-kunnr = ps_selec-kunnr.
  ls_log-werks = ps_selec-werks_fab.
  CASE ps_return-type.
    WHEN 'E'.
      ls_log-icon = '@0A@'. " Semaforito rojo
    WHEN 'I'.
      IF ps_return-id = 'CO' AND ps_return-number = '889'.
        ls_log-icon = '@09@'. " Semaforito amarrillo
      ENDIF.
    WHEN 'S'.
      ls_log-icon = '@08@'. " Semaforito verde
  ENDCASE.

  ls_log-type_ret = ps_return-type.
  ls_log-msg_ret = ps_return-message.
  ls_log-tipo = p_tipo.
  APPEND ls_log TO gt_listado1.

ENDFORM.                    " REGISTRAR_LOG
*&---------------------------------------------------------------------*
*&      Form  ESPERA_ORDEN_CREADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*----------------------------------------------------------------------*
FORM espera_orden_creada  USING    p_aufnr.

  DATA: lv_ok        TYPE xflag,
        lv_aufnr_aux TYPE aufnr,
        lv_cont      TYPE i.

  CLEAR: lv_ok, lv_cont, lv_aufnr_aux.
  WHILE lv_ok IS INITIAL.
    WAIT UP TO 1 SECONDS.
    lv_cont = lv_cont + 1.

    SELECT SINGLE aufnr INTO lv_aufnr_aux
      FROM aufk
      WHERE aufnr = p_aufnr.

    IF lv_aufnr_aux IS NOT INITIAL.
      lv_ok = 'X'.
    ENDIF.

    IF lv_cont = 15.
      lv_ok = 'X'.
    ENDIF.
  ENDWHILE.

ENDFORM.                    " ESPERA_ORDEN_CREADA
*&---------------------------------------------------------------------*
*&      Form  ESPERA_BLOQUEO_ORDEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*----------------------------------------------------------------------*
FORM espera_bloqueo_orden  USING    p_aufnr.

  DATA: lv_cont TYPE i.

  CALL FUNCTION 'ENQUEUE_ESORDER'
    EXPORTING
      mode_aufk      = 'E'
      mandt          = sy-mandt
      aufnr          = p_aufnr
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.
  IF sy-subrc <> 0.
* Implement suitable error handling here
    CLEAR: lv_cont.
    WHILE lv_cont < 30.
      WAIT UP TO 1 SECONDS.
      CALL FUNCTION 'ENQUEUE_ESORDER'
        EXPORTING
          mode_aufk      = 'E'
          mandt          = sy-mandt
          aufnr          = p_aufnr
*         X_AUFNR        = ' '
*         _SCOPE         = '2'
*         _WAIT          = ' '
*         _COLLECT       = ' '
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

      IF sy-subrc <> 0.
        lv_cont = lv_cont + 1.
      ELSE.
        lv_cont = 30.
        CALL FUNCTION 'DEQUEUE_ESORDER'
          EXPORTING
            mode_aufk = 'E'
            mandt     = sy-mandt
            aufnr     = p_aufnr.
      ENDIF.
    ENDWHILE.
  ELSE.
    CALL FUNCTION 'DEQUEUE_ESORDER'
      EXPORTING
        mode_aufk = 'E'
        mandt     = sy-mandt
        aufnr     = p_aufnr.
  ENDIF.


ENDFORM.                    " ESPERA_BLOQUEO_ORDEN
*&---------------------------------------------------------------------*
*&      Form  DATOS_ADIC_BOB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*      -->P_PS_SELEC  text
*----------------------------------------------------------------------*
FORM datos_adic_bob  USING    p_aufnr
                              p_aufnr_rol
                              ps_selec TYPE zspp0026_alv
                     CHANGING p_error.

  DATA: lv_fecha_aux(10).


  "Hacemos EXPORT a memoria con la orden para no tener problemas con el
  "batch input y los campos que se sombrean en pantalla en la COR2.
  EXPORT  gv_order_number FROM p_aufnr TO MEMORY ID 'ORDER'.

  " Ahora hacemos el batch-input para modificar campos de cliente:
  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-AUFNR'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '/00'.
  PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                p_aufnr.
  PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                'X'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=+COI'.

  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-GAMNG'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=BU'.

  IF ps_selec-kunnr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZKUNNR1'.
    PERFORM bdc_field       USING 'AUFK-ZZKUNNR1'
                                  ps_selec-kunnr.
  ENDIF.
  IF ps_selec-vbeln IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZEBELN1'.
    PERFORM bdc_field       USING 'AUFK-ZZEBELN1'
                                  ps_selec-vbeln.
  ENDIF.
  IF ps_selec-posnr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZEBELP1'.
    PERFORM bdc_field       USING 'AUFK-ZZEBELP1'
                                  ps_selec-posnr.
  ENDIF.
  CLEAR lv_fecha_aux.
  IF ps_selec-mbdat IS NOT INITIAL.
    CONCATENATE ps_selec-mbdat+6(2) ps_selec-mbdat+4(2)
    ps_selec-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZFEC_ENTREG1'.
    PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG1'
                                  lv_fecha_aux.
  ENDIF.

* CMS Tratar reparto
*  IF ps_selec-lprio = '01'.
  IF ps_selec-etenr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZURGT1'.
    PERFORM bdc_field       USING 'AUFK-ZZURGT1'
                                  ps_selec-etenr.
  ENDIF.

* INI CGIJON - 04.05.17 - INSERTAMOS EN EL CAMP ZAUFNR_ROLLO, LA ORDEN
* DE ROLLO CREADA
  PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZAUFNR_ROLLO'.
  PERFORM bdc_field       USING 'AUFK-ZZAUFNR_ROLLO'
                                 p_aufnr_rol.
* FIN CGIJON - 04.05.17

  IF ps_selec-num_bobinas > 1.
    DATA: l_num_bob_n TYPE numc2.
    l_num_bob_n = ps_selec-num_bobinas.



    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZSECUENCIA'.
    PERFORM bdc_field       USING 'AUFK-ZZSECUENCIA'
                                  l_num_bob_n.

  ENDIF.


  CLEAR: i_messtab.
  REFRESH: i_messtab.

  CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                          MESSAGES INTO i_messtab
                          UPDATE 'S'.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ENDIF.

ENDFORM.                    " DATOS_ADIC_BOB
*&---------------------------------------------------------------------*
*&      Form  MOD_COMP_ZROL_BOB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*      -->P_PS_SELEC  text
*----------------------------------------------------------------------*
FORM mod_comp_zrol_bob  USING    p_aufnr
                                 ps_selec TYPE zspp0026_alv
                        CHANGING p_error
                                 ps_return TYPE bapiret2.

  CALL METHOD zclpp_creacion_ofs=>cambiar_rollo_lista_mat_bobina
    EXPORTING
      i_of          = p_aufnr
      i_menge       = ps_selec-cant_rol_agrup
      i_matnr_rollo = ps_selec-mate_rol_agrup
    IMPORTING
      o_rc          = DATA(l_rc)
      os_ret        = DATA(ls_return).
  IF l_rc <> '00'. " Se ha producido error
    ps_return = ls_return.
    p_error = 'X'.
  ELSE. " Éxito
    CLEAR: p_error, ps_return.
  ENDIF.


*  ls_comp_data-matnr = ps_selec-mate_rol_agrup.
*  ls_comp_data-menge = ps_selec-cant_rol_agrup.
*
*  DATA: lt_return TYPE bapiret2_t,
*        ls_return TYPE bapiret2.
*  DATA: lv_rsnum TYPE rsnum,
*        lv_rspos TYPE rspos,
*        lv_rsart TYPE rsart,
*        lv_charg TYPE charg_d.
*
*  DATA: ls_comp_key  TYPE coxt_s_ord_comp_key,
*        ls_comp_data TYPE zstpp_comp_orden.
*
*  CLEAR: p_error, ps_return.
*  CLEAR: lv_rsnum, lv_rspos, lv_rsart, lv_charg.
*  SELECT SINGLE rsnum INTO lv_rsnum
*    FROM afko
*    WHERE aufnr = p_aufnr.
*
*  IF lv_rsnum IS NOT INITIAL.
*    SELECT SINGLE rspos rsart charg
*      INTO (lv_rspos, lv_rsart, lv_charg)
*      FROM resb
*      WHERE rsnum = lv_rsnum
*      AND sortf = 'ROLLO'.
*  ENDIF.
*
*  CLEAR: ls_comp_key, ls_comp_data.
*  CLEAR: lt_return. REFRESH: lt_return.
*
*  " Datos de componente a cambiar:
*  ls_comp_key-rsnum = lv_rsnum.
*  ls_comp_key-rspos = lv_rspos.
*  ls_comp_key-rsart = lv_rsart.
*
*  " Datos del componente que se va a añadir:
*  ls_comp_data-matnr = ps_selec-mate_rol_agrup.
*  ls_comp_data-menge = ps_selec-cant_rol_agrup.
*  ls_comp_data-meins = ps_selec-unid_rol.
*  ls_comp_data-charg = lv_charg.
*
*
*  CALL FUNCTION 'ZMFPP_CHANGE_COMP_ORDEN'
*    EXPORTING
*      i_aufnr      = p_aufnr
*      is_comp_key  = ls_comp_key
*      is_comp_data = ls_comp_data
*    TABLES
*      et_return    = lt_return.
*
*
*  CLEAR ls_return.
*  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
*
*  IF ls_return IS NOT INITIAL. " Se ha producido error
*    ps_return = ls_return.
*    p_error = 'X'.
*  ELSE. " Éxito
*    CLEAR: p_error, ps_return.
*  ENDIF.

ENDFORM.                    " MOD_COMP_ZROL_BOB
*&---------------------------------------------------------------------*
*&      Form  CERRAR_TEC_ORDEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*----------------------------------------------------------------------*
FORM cerrar_tec_orden  USING    p_aufnr
                       CHANGING ps_return TYPE bapiret2.

  DATA: lt_orders TYPE tb_bapi_order_key,
        ls_orders TYPE bapi_order_key.

  CLEAR: ps_return, lt_orders, ls_orders.
  REFRESH: lt_orders.

  ls_orders-order_number = p_aufnr.
  APPEND ls_orders TO lt_orders.

  PERFORM espera_bloqueo_orden USING p_aufnr.

  CALL FUNCTION 'BAPI_PROCORD_COMPLETE_TECH'
    IMPORTING
      return = ps_return
    TABLES
      orders = lt_orders.

ENDFORM.                    " CERRAR_TEC_ORDEN
*&---------------------------------------------------------------------*
*&      Form  DATOS_ADIC_ROL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*      -->P_PS_SELEC  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM datos_adic_rol  USING    p_aufnr
                              ps_selec TYPE zspp0026_alv
                              p_rol1
                              p_tor1
                              p_rol2
                              p_tor2
                     CHANGING p_error.

  DATA: lv_fecha_aux(10).

  DATA: lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10).

**
  "Hacemos EXPORT a memoria con la orden para no tener problemas con el
  "batch input y los campos que se sombrean en pantalla en la COR2.
  EXPORT  gv_order_number FROM p_aufnr TO MEMORY ID 'ORDER'.

  " Ahora hacemos el batch-input para modificar campos de cliente:
  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-AUFNR'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '/00'.
  PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                p_aufnr.
  PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                'X'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=+COI'.

  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-GAMNG'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=BU'.

  IF ps_selec-kunnr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZKUNNR1'.
    PERFORM bdc_field       USING 'AUFK-ZZKUNNR1'
                                  ps_selec-kunnr.
  ENDIF.

  IF ps_selec-vbeln IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZEBELN1'.
    PERFORM bdc_field       USING 'AUFK-ZZEBELN1'
                                  ps_selec-vbeln.
  ENDIF.
  IF ps_selec-posnr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZEBELP1'.
    PERFORM bdc_field       USING 'AUFK-ZZEBELP1'
                                  ps_selec-posnr.
  ENDIF.
* INI CMS Tratar repartos
  IF ps_selec-etenr IS NOT INITIAL.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZURGT1'.
    PERFORM bdc_field       USING 'AUFK-ZZURGT1'
                                  ps_selec-etenr.
  ENDIF.

  CLEAR lv_fecha_aux.
  IF ps_selec-mbdat IS NOT INITIAL.
    CONCATENATE ps_selec-mbdat+6(2) ps_selec-mbdat+4(2)
    ps_selec-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZFEC_ENTREG1'.
    PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG1'
                                  lv_fecha_aux.
  ENDIF.

  CLEAR: lv_rol1_txt, lv_rol2_txt, lv_tor1_txt, lv_tor2_txt.
  IF p_rol1 IS NOT INITIAL.
    lv_rol1_txt = p_rol1.
    CONDENSE lv_rol1_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZROLLOS1'.
    PERFORM bdc_field       USING 'AUFK-ZZROLLOS1'
                                  lv_rol1_txt.
  ENDIF.
  IF p_tor1 IS NOT INITIAL.
    lv_tor1_txt = p_tor1.
    CONDENSE lv_tor1_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZTOR1'.
    PERFORM bdc_field       USING 'AUFK-ZZTOR1'
                                  lv_tor1_txt.
  ENDIF.
  IF p_rol2 IS NOT INITIAL.
    lv_rol2_txt = p_rol2.
    CONDENSE lv_rol2_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZROLLOS2'.
    PERFORM bdc_field       USING 'AUFK-ZZROLLOS2'
                                  lv_rol2_txt.
  ENDIF.
  IF p_tor2 IS NOT INITIAL.
    lv_tor2_txt = p_tor2.
    CONDENSE lv_rol2_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZTOR2'.
    PERFORM bdc_field       USING 'AUFK-ZZTOR2'
                                  lv_tor2_txt.
  ENDIF.

  CLEAR: i_messtab.
  REFRESH: i_messtab.

  CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                          MESSAGES INTO i_messtab
                          UPDATE 'S'.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ENDIF.

ENDFORM.                    " DATOS_ADIC_ROL
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_ROLLO_AGRUP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_SELEC  text
*      <--P_LV_AUFNR_ROL  text
*      <--P_LV_AUART_ROL  text
*      <--P_LV_OK  text
*----------------------------------------------------------------------*
FORM crear_orden_rollo_agrup  TABLES pt_ped_agrup TYPE ty_t_ped_agrup
                        USING    ps_selec TYPE zspp0026_alv
                        CHANGING pv_aufnr_rol
                                 pv_auart_rol
                                 pv_ok.

  DATA: ls_orderdata     TYPE bapi_pi_order_create,
        lt_return        TYPE bapiret2_t,
        ls_return        TYPE bapiret2,
        lv_aufnr         TYPE aufnr,
        lv_auart         TYPE aufart,
        ls_listado1      LIKE gt_listado1,
        lv_rol1          TYPE zrollos,
        lv_tor1          TYPE ztornada,
        lv_rol2          TYPE zrollos,
        lv_tor2          TYPE ztornada,
        lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10),
        lv_fecha_aux(10),
        lv_fecha         TYPE co_gstrp,
        lt_orders        TYPE tb_bapi_order_key,
        ls_orders        TYPE bapi_order_key.

  DATA: lv_ok        TYPE xflag,
        lv_cont      TYPE i,
        lv_aufnr_aux TYPE aufnr.

  DATA: lv_tipo(1),
        lv_error   TYPE xfeld.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, pv_ok,
         ls_listado1.
  REFRESH lt_return.

  " Encontrar la fecha de inicio que tenemos que pasar para crear la
  " orden:
  CLEAR lv_fecha.
  PERFORM f_calc_fech USING ps_selec-werks
                            ps_selec-mbdat
                      CHANGING lv_fecha.


  ls_orderdata-material         = ps_selec-mate_rol_agrup.
  ls_orderdata-plant             = ps_selec-werks_fab.
  ls_orderdata-order_type       = ps_selec-aufa_rol.
  ls_orderdata-quantity         = ps_selec-cant_rol_agrup.
  ls_orderdata-quantity_uom     = ps_selec-unid_rol.
*  ls_orderdata-basic_start_date = lv_fecha.
  ls_orderdata-basic_end_date = lv_fecha.

* Marcar prioridad de la orden como urgente:
*  IF ps_selec-lprio = '01'.
*    ls_orderdata-order_priority = ps_selec-lprio+1(1).
*  ENDIF.

  " Tipo: Creación
  CLEAR lv_tipo.
  lv_tipo = 'C'.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.


  IF lv_aufnr IS INITIAL.
    " Error
    CLEAR: pv_ok, pv_aufnr_rol, pv_auart_rol.
    PERFORM registrar_log USING ps_selec
                                ls_return
                                lv_tipo
                                ps_selec-aufa_rol
                                ' '.
  ELSE.

* 28/01/2021 - CMS espera antes de obtener los estados de OF
    PERFORM validar_estado_of_edet USING    lv_aufnr
                                         ps_selec
                                CHANGING lv_error.
    IF lv_error = 'X'.
*      CL EAR: pv_aufnr_rol, pv_auart_rol, pv_ok.  "Al limpiar "pv_aufnr_rol", luego no sigue procesando.
      CLEAR: ps_selec-aufa_rol,  pv_ok , pv_aufnr_rol , pv_aufnr_rol.
*      CLEAR: ps_selec-aufa_rol, pv_auart_bob, pv_ok , pv_aufnr_rol.
      EXIT.
    ELSE.



      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      pv_aufnr_rol = lv_aufnr.
      pv_auart_rol = ps_selec-aufa_rol.

      PERFORM espera_orden_creada USING lv_aufnr.

      " Recuperar datos rollos y tornadas:
      CLEAR: lv_rol1, lv_rol2, lv_tor1, lv_tor2.
      PERFORM dat_rollo_torn USING ps_selec-cant_rol_agrup
                                   ps_selec-anch_bob
                             CHANGING lv_rol1
                                      lv_tor1
                                      lv_rol2
                                      lv_tor2.

      PERFORM espera_bloqueo_orden USING lv_aufnr.

      CLEAR lv_error.

      PERFORM datos_adic_rol_agrup TABLES pt_ped_agrup
                                   USING lv_aufnr
                                         ps_selec
                                         lv_rol1
                                         lv_tor1
                                         lv_rol2
                                         lv_tor2
                                   CHANGING lv_error.

      IF lv_error = 'X'.

        CLEAR: ls_listado1.

        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.

        CLEAR ls_return.
        ls_return-type = 'E'.
        ls_return-message = ls_listado1-msg_ret.

        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.

        PERFORM espera_bloqueo_orden USING lv_aufnr.
        PERFORM cerrar_tec_orden USING lv_aufnr
                                 CHANGING ls_return.

        IF ls_return-type = 'E'.

          CLEAR: pv_ok.
          pv_aufnr_rol = lv_aufnr.
          pv_auart_rol = ps_selec-aufa_rol.

          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_rol
                                      lv_aufnr.

        ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND
        ls_return-number = '889'.

          CLEAR: pv_aufnr_rol, pv_auart_rol, pv_ok.
          PERFORM registrar_log USING ps_selec
                              ls_return
                              lv_tipo
                              ps_selec-aufa_rol
                              lv_aufnr.

        ENDIF.
      ELSE.
        " Todo el proceso ha ido correctamente:
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.

        pv_ok = 'X'.
        pv_aufnr_rol = lv_aufnr.
        pv_auart_rol = ps_selec-aufa_rol.

        CLEAR ls_return.
        ls_return-type = 'S'.
        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " CREAR_ORDEN_ROLLO_AGRUP
*&---------------------------------------------------------------------*
*&      Form  DATOS_ADIC_ROL_AGRUP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_AUFNR  text
*      -->P_PS_SELEC  text
*      -->P_LV_ROL1  text
*      -->P_LV_TOR1  text
*      -->P_LV_ROL2  text
*      -->P_LV_TOR2  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM datos_adic_rol_agrup TABLES pt_ped_agrup TYPE ty_t_ped_agrup
                     USING    p_aufnr
                              ps_selec TYPE zspp0026_alv
                              p_rol1
                              p_tor1
                              p_rol2
                              p_tor2
                     CHANGING p_error.

  DATA: lv_fecha_aux(10).

  DATA: lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10),
        lv_cont         TYPE i.

  DATA: ls_ped_agrup TYPE ty_ped_agrup.

**
  "Hacemos EXPORT a memoria con la orden para no tener problemas con el
  "batch input y los campos que se sombrean en pantalla en la COR2.
  EXPORT  gv_order_number FROM p_aufnr TO MEMORY ID 'ORDER'.

  " Ahora hacemos el batch-input para modificar campos de cliente:
  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-AUFNR'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '/00'.
  PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                p_aufnr.
  PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                'X'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=+COI'.

  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-GAMNG'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=BU'.

  CLEAR lv_cont.
  LOOP AT pt_ped_agrup INTO ls_ped_agrup.
    lv_cont = lv_cont + 1.
    PERFORM rellenar_camp_ped_rol USING ls_ped_agrup
                                        lv_cont.

  ENDLOOP.

  CLEAR: lv_rol1_txt, lv_rol2_txt, lv_tor1_txt, lv_tor2_txt.
  IF p_rol1 IS NOT INITIAL.
    lv_rol1_txt = p_rol1.
    CONDENSE lv_rol1_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZROLLOS1'.
    PERFORM bdc_field       USING 'AUFK-ZZROLLOS1'
                                  lv_rol1_txt.
  ENDIF.
  IF p_tor1 IS NOT INITIAL.
    lv_tor1_txt = p_tor1.
    CONDENSE lv_tor1_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZTOR1'.
    PERFORM bdc_field       USING 'AUFK-ZZTOR1'
                                  lv_tor1_txt.
  ENDIF.
  IF p_rol2 IS NOT INITIAL.
    lv_rol2_txt = p_rol2.
    CONDENSE lv_rol2_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZROLLOS2'.
    PERFORM bdc_field       USING 'AUFK-ZZROLLOS2'
                                  lv_rol2_txt.
  ENDIF.
  IF p_tor2 IS NOT INITIAL.
    lv_tor2_txt = p_tor2.
    CONDENSE lv_rol2_txt.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZTOR2'.
    PERFORM bdc_field       USING 'AUFK-ZZTOR2'
                                  lv_tor2_txt.
  ENDIF.

  CLEAR: i_messtab.
  REFRESH: i_messtab.

  CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                          MESSAGES INTO i_messtab
                          UPDATE 'S'.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ENDIF.


ENDFORM.                    " DATOS_ADIC_ROL_AGRUP
*&---------------------------------------------------------------------*
*&      Form  RELLENAR_CAMP_PED_ROL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_PED_AGRUP  text
*      -->P_LV_CONT  text
*----------------------------------------------------------------------*
FORM rellenar_camp_ped_rol  USING    ps_ped_agrup TYPE ty_ped_agrup
                                     p_cont.


  DATA: lv_fecha_aux(10).

  CASE p_cont.
    WHEN 1.

      IF ps_ped_agrup-kunnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZKUNNR1'.
        PERFORM bdc_field       USING 'AUFK-ZZKUNNR1'
                                      ps_ped_agrup-kunnr.
      ENDIF.

      IF ps_ped_agrup-vbeln IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELN1'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELN1'
                                      ps_ped_agrup-vbeln.
      ENDIF.
      IF ps_ped_agrup-posnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELP1'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELP1'
                                      ps_ped_agrup-posnr.
      ENDIF.
      CLEAR lv_fecha_aux.
      IF ps_ped_agrup-mbdat IS NOT INITIAL.
        CONCATENATE ps_ped_agrup-mbdat+6(2) ps_ped_agrup-mbdat+4(2)
        ps_ped_agrup-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZFEC_ENTREG1'.
        PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG1'
                                      lv_fecha_aux.
      ENDIF.

*      IF ps_ped_agrup-lprio = '01'.
      IF ps_ped_agrup-etenr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZURGT1'.
        PERFORM bdc_field       USING 'AUFK-ZZURGT1'
*                                      'X'.
                                      ps_ped_agrup-etenr.
      ENDIF.

    WHEN 2.

      IF ps_ped_agrup-kunnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZKUNNR2'.
        PERFORM bdc_field       USING 'AUFK-ZZKUNNR2'
                                      ps_ped_agrup-kunnr.
      ENDIF.

      IF ps_ped_agrup-vbeln IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELN2'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELN2'
                                      ps_ped_agrup-vbeln.
      ENDIF.
      IF ps_ped_agrup-posnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELP2'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELP2'
                                      ps_ped_agrup-posnr.
      ENDIF.
      CLEAR lv_fecha_aux.
      IF ps_ped_agrup-mbdat IS NOT INITIAL.
        CONCATENATE ps_ped_agrup-mbdat+6(2) ps_ped_agrup-mbdat+4(2)
        ps_ped_agrup-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZFEC_ENTREG2'.
        PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG2'
                                      lv_fecha_aux.
      ENDIF.

*      IF ps_ped_agrup-lprio = '01'.
*        PERFORM bdc_field       USING 'BDC_CURSOR'
*                                      'AUFK-ZZURGT2'.
*        PERFORM bdc_field       USING 'AUFK-ZZURGT2'
*                                      'X'.
*      ENDIF.
      IF ps_ped_agrup-etenr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZURGT2'.
        PERFORM bdc_field       USING 'AUFK-ZZURGT2'
*                                      'X'.
                                      ps_ped_agrup-etenr.
      ENDIF.

    WHEN 3.

      IF ps_ped_agrup-kunnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZKUNNR3'.
        PERFORM bdc_field       USING 'AUFK-ZZKUNNR3'
                                      ps_ped_agrup-kunnr.
      ENDIF.

      IF ps_ped_agrup-vbeln IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELN3'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELN3'
                                      ps_ped_agrup-vbeln.
      ENDIF.
      IF ps_ped_agrup-posnr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZEBELP3'.
        PERFORM bdc_field       USING 'AUFK-ZZEBELP3'
                                      ps_ped_agrup-posnr.
      ENDIF.
      CLEAR lv_fecha_aux.
      IF ps_ped_agrup-mbdat IS NOT INITIAL.
        CONCATENATE ps_ped_agrup-mbdat+6(2) ps_ped_agrup-mbdat+4(2)
        ps_ped_agrup-mbdat+0(4) INTO lv_fecha_aux SEPARATED BY '.'.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZFEC_ENTREG3'.
        PERFORM bdc_field       USING 'AUFK-ZZFEC_ENTREG3'
                                      lv_fecha_aux.
      ENDIF.

      IF ps_ped_agrup-etenr IS NOT INITIAL.
        PERFORM bdc_field       USING 'BDC_CURSOR'
                                      'AUFK-ZZURGT3'.
        PERFORM bdc_field       USING 'AUFK-ZZURGT3'
*                                      'X'.
                                      ps_ped_agrup-etenr.
      ENDIF.

*      IF ps_ped_agrup-lprio = '01'.
*        PERFORM bdc_field       USING 'BDC_CURSOR'
*                                      'AUFK-ZZURGT3'.
*        PERFORM bdc_field       USING 'AUFK-ZZURGT3'
*                                      'X'.
*      ENDIF.

  ENDCASE.


ENDFORM.                    " RELLENAR_CAMP_PED_ROL
*&---------------------------------------------------------------------*
*&      Form  F_CREAR_TABLA_ALV_NEW
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_crear_tabla_alv_new .

  DATA: ls_datos_pedidos TYPE zspp_linea_pedidos,
        ls_alv           TYPE zspp0026_alv.

  " Voy a mostrar en el listado las órdenes a crear según los
  " pedidos seleccionados:

  LOOP AT gt_datos_pedidos INTO ls_datos_pedidos.
    CLEAR ls_alv.
    ls_alv-kunnr = ls_datos_pedidos-kunnr.
    ls_alv-werks = ls_datos_pedidos-werks.
    ls_alv-werks_fab = ls_datos_pedidos-werks.
    ls_alv-vbeln = ls_datos_pedidos-vbeln.
    ls_alv-posnr = ls_datos_pedidos-posnr.
    ls_alv-mbdat = ls_datos_pedidos-mbdat.
    ls_alv-etenr = ls_datos_pedidos-etenr.
    ls_alv-wmeng = ls_datos_pedidos-wmeng.
    ls_alv-vrkme = ls_datos_pedidos-vrkme.
    ls_alv-lprio = ls_datos_pedidos-lprio.
    ls_alv-cant_bob = ls_datos_pedidos-wmeng.

    IF ls_datos_pedidos-vrkme IS NOT INITIAL.
      ls_alv-unid_bob = ls_datos_pedidos-vrkme.
    ELSEIF ls_datos_pedidos-meins IS NOT INITIAL.
      ls_alv-unid_bob = ls_datos_pedidos-meins.
    ELSE.
      ls_alv-unid_bob = 'KG'.
    ENDIF.
    ls_alv-mate_bob = ls_datos_pedidos-matnr.
    ls_alv-desc_bob = ls_datos_pedidos-maktx.
    SELECT SINGLE matkl zzgramaje zzancho
      INTO (ls_alv-matk_bob,ls_alv-gram_bob,ls_alv-anch_bob)
      FROM mara WHERE matnr = ls_alv-mate_bob.
    ls_alv-aufa_bob = gc_aufa_bob.
    ls_alv-cant_rol = ls_datos_pedidos-mnglg.
    ls_alv-unid_rol = ls_datos_pedidos-mmein.
    ls_alv-mate_rol = ls_datos_pedidos-idnrk.
    ls_alv-desc_rol = ls_datos_pedidos-maktx_rol.
    SELECT SINGLE matkl zzgramaje zzancho
        INTO (ls_alv-matk_rol,ls_alv-gram_rol,ls_alv-anch_rol)
        FROM mara WHERE matnr = ls_alv-mate_rol.
    ls_alv-aufa_rol = gc_aufa_rol.
    ls_alv-aufnr_bob = ls_datos_pedidos-aufnr_bob.
    ls_alv-aufnr_rol = ls_datos_pedidos-aufnr_rol.
    ls_alv-icon = '@09@'.

    APPEND ls_alv TO gt_alv.
  ENDLOOP.

ENDFORM.                    " F_CREAR_TABLA_ALV_NEW
*&---------------------------------------------------------------------*
*&      Form  LINEAS_AGRUPAR_ANCHO_MAX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM lineas_agrupar_ancho_max  TABLES pt_cabos TYPE ty_t_cabos
                               CHANGING pv_error
                                        pv_exit.

  DATA: lti_rows TYPE lvc_t_roid,
        ls_row   TYPE lvc_s_roid,
        ls_alv   TYPE zspp0026_alv,
        lv_lines TYPE i.

  DATA: lv_mat_rollo_ok TYPE xfeld,
        lv_mat_cabos_ok TYPE xfeld,
        lv_exit         TYPE xfeld.
  DATA: pv_error2        TYPE xfeld,
        pv_error3        TYPE xfeld,
        pv_error4        TYPE xfeld,
        pv_error5        TYPE xfeld,
        lv_peso_bob      TYPE gamng,
        lv_ancho_bob     TYPE zancho,
        lv_verid_bob     TYPE verid,
        lv_verid_rol     TYPE verid,
        lv_ancho_trim    TYPE i,
        lv_ancho_min_bob TYPE i, "cgijon: 19.02.17
        l_ancho_5mm      TYPE zancho.

  CLEAR gt_selec.
  CLEAR: gv_rollo, gv_zzancho_max, gv_peso_max.
  CLEAR: gv_zzgramaje, gv_matkl, gv_zzancho, gv_werks_fab.
  CLEAR: lv_peso_bob, pv_error, pv_exit, lv_ancho_bob.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* No se pueden marcar más de dos líneas en ancho máximo:
  IF lv_lines > 2.
    pv_error = 'X'.
    MESSAGE w085(zpp).
    EXIT.
  ENDIF.

* Verificamos que no estén ya en una agrupación
* Verificamos que las líneas no estén procesadas
* Verificamos que no tengan ni orden de rollo, ni de bobina
* creadas
  CLEAR: pv_error2, pv_error3, pv_error4, pv_error5.
  LOOP AT lti_rows INTO ls_row.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv-agru_bob IS NOT INITIAL.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ELSEIF ls_alv-procesado = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error2 = 'X'.
      EXIT.
    ELSEIF ls_alv-aufnr_bob IS NOT INITIAL
           OR ls_alv-aufnr_rol IS NOT INITIAL.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error3 = 'X'.
      EXIT.
    ELSEIF ls_alv-cambio_rollo_flag = 'X'.
      CLEAR gt_selec. REFRESH gt_selec.
      pv_error5 = 'X'.
      EXIT.
    ELSE.

      CLEAR lv_verid_bob.
      SELECT SINGLE verid INTO lv_verid_bob
        FROM mkal
        WHERE matnr = ls_alv-mate_bob
        AND werks = ls_alv-werks_fab
        AND verid = gc_verid.

      IF lv_verid_bob IS NOT INITIAL.
        lv_peso_bob = lv_peso_bob + ls_alv-cant_bob.
        lv_ancho_bob = lv_ancho_bob + ls_alv-anch_bob.
        APPEND ls_alv TO gt_selec.
      ELSE.
        CLEAR: gt_selec. REFRESH: gt_selec.
        pv_error4 = 'X'.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w077(zpp).
    CLEAR gt_selec. REFRESH gt_selec.
    EXIT.
  ELSEIF pv_error2 = 'X'.
    pv_error = 'X'.
    MESSAGE w083(zpp).
    CLEAR gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error3 = 'X'.
    pv_error = 'X'.
    MESSAGE w084(zpp).
    CLEAR gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error4 = 'X'.
    pv_error = 'X'.
    MESSAGE i103(zpp) WITH ls_alv-mate_bob ls_alv-werks_fab
            DISPLAY LIKE 'E'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error5 = 'X'.
    pv_error = 'X'.
    MESSAGE i108(zpp) DISPLAY LIKE 'E'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    EXIT.
  ENDIF.

* Verificamos que todas las bobinas tengan el mismo:
* Gramaje, Grupo de artículos y Centro de Fabricación
  LOOP AT gt_selec INTO ls_alv.

* 69669 - CMS - 22/12/2021
* Verificar si el ancho acaba en 5mm (DS Smith)
    PERFORM determinar_si_5mm USING ls_alv-anch_bob
                           CHANGING l_ancho_5mm.

    ADD l_ancho_5mm TO gv_zzancho.
*    ADD ls_alv-anch_bob TO gv_zzancho.

    IF gv_zzgramaje IS INITIAL AND
       gv_matkl     IS INITIAL AND
       gv_werks_fab IS INITIAL.
      gv_zzgramaje = ls_alv-gram_bob.
      gv_matkl     = ls_alv-matk_bob.
      gv_werks_fab = ls_alv-werks_fab.
*      lv_peso_bob = lv_peso_bob + ls_alv-cant_bob.
*      lv_ancho_bob = lv_ancho_bob + ls_alv-anch_bob.
    ELSEIF  gv_zzgramaje NE ls_alv-gram_bob OR
            gv_matkl     NE ls_alv-matk_bob OR
            gv_werks_fab NE ls_alv-werks_fab.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    MESSAGE w079(zpp).
    CLEAR gt_selec. REFRESH: gt_selec.
    EXIT.
  ENDIF.

* IEG - 27.12.2016: Recuperamos el ANCHO TRIM tabla ZTPP0008
  PERFORM recuperar_ancho_trim USING    ls_alv-werks_fab
                                        ls_alv-mate_bob
                               CHANGING lv_ancho_trim
                                        lv_ancho_min_bob.
* IEG - 27.12.2016 - Fin modificación

* DTM
  lv_ancho_bob = gv_zzancho + lv_ancho_trim.
**  lv_ancho_bob = lv_ancho_bob + lv_ancho_trim.
* DTM

* Búsqueda de material ZROL de ancho máximo:
  CLEAR lv_mat_rollo_ok.
  WHILE ( lv_mat_rollo_ok <> 'X').
    CLEAR: lv_mat_rollo_ok, lv_exit.
    PERFORM get_mat_rol_ancho_max  USING gv_zzgramaje
                                         gv_matkl
                                         lv_peso_bob
                                         lv_ancho_bob
                                   CHANGING lv_mat_rollo_ok
                                            pv_exit.

    IF pv_exit = 'X'.
      CLEAR: gt_selec. REFRESH: gt_selec.
      EXIT.
    ENDIF.

  ENDWHILE.

  IF pv_exit = 'X'.
    EXIT.
  ENDIF.


  CLEAR lv_mat_cabos_ok.
  CLEAR: pt_cabos. REFRESH: pt_cabos.
  WHILE ( lv_mat_cabos_ok <> 'X').
    PERFORM get_datos_cabos TABLES pt_cabos
                            USING gv_zzgramaje
                                  gv_matkl
                                  lv_lines
                                  lv_peso_bob
                                  lv_ancho_bob
                            CHANGING lv_mat_cabos_ok
                                     pv_exit.

    IF pv_exit = 'X'.
      CLEAR: gt_selec. REFRESH: gt_selec.
      EXIT.
    ENDIF.
  ENDWHILE.

  IF pv_exit = 'X'.
    EXIT.
  ENDIF.

ENDFORM.                    " LINEAS_AGRUPAR_ANCHO_MAX
*&---------------------------------------------------------------------*
*&      Form  GET_MAT_ROL_ANCHO_MAX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_ZZGRAMAJE  text
*      -->P_GV_MATKL  text
*      <--P_LV_MAT_ROLLO_OK  text
*----------------------------------------------------------------------*
FORM get_mat_rol_ancho_max  USING    p_zzgramaje
                                     p_matkl
                                     p_peso_bob
                                     p_ancho_bob
                            CHANGING p_mat_rollo_ok
                                     p_exit.


  DATA: lv_returncode TYPE c.

  DATA: lt_fields TYPE TABLE OF sval,
        ls_fields TYPE          sval.
  DATA: lv_verid_rol TYPE verid.
* GST - 10/11/2016 - SAT 7000012677 ->
  DATA: ls_mat_rollo TYPE ty_matnr,
        lt_mat_rollo TYPE ty_t_matnr.
* GST - 10/11/2016 - SAT 7000012677 <-

  CLEAR: lt_fields. REFRESH: lt_fields.
  CLEAR: lv_returncode, p_mat_rollo_ok, p_exit.
  CLEAR: gv_zzancho_max, gv_peso_max, gv_rollo.

* 1) Ancho máximo:
  CLEAR ls_fields.
  ls_fields-tabname   = 'MARA'.
  ls_fields-fieldname = 'ZZANCHO'.
  ls_fields-fieldtext = text-002.
  ls_fields-field_obl = 'X'.
  APPEND ls_fields TO lt_fields.

* 2) Peso máximo:
  CLEAR ls_fields.
  ls_fields-tabname   = 'AFKO'.
  ls_fields-fieldname = 'GAMNG'.
  ls_fields-fieldtext = text-016.
  ls_fields-field_obl = 'X'.
  APPEND ls_fields TO lt_fields.


  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-003
      start_column    = '5'
      start_row       = '5'
    IMPORTING
      returncode      = lv_returncode
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.

  IF sy-subrc <> 0.
    lv_returncode = 'E'.
  ENDIF.

  IF lv_returncode <> 'E' AND lv_returncode <> 'A'.
    CLEAR p_exit.
    " Ancho máximo:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 1.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0000'.
      gv_zzancho_max = ls_fields-value.
    ELSE.
      CLEAR: p_mat_rollo_ok, p_exit.
      MESSAGE i086(zpp) DISPLAY LIKE 'E'.
    ENDIF.

    " Peso máximo:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 2.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0.000'.
      gv_peso_max = ls_fields-value.
    ELSE.
      CLEAR: p_mat_rollo_ok, p_exit.
      MESSAGE i087(zpp) DISPLAY LIKE 'E'.
    ENDIF.

  ELSE.
    p_exit = 'X'.
    EXIT.
  ENDIF.

  IF gv_zzancho_max IS NOT INITIAL AND gv_peso_max IS NOT INITIAL.
    CLEAR gv_rollo.
* GST - 10/11/2016 - SAT 7000012677 ->
    CLEAR: ls_mat_rollo, lt_mat_rollo.
    REFRESH: lt_mat_rollo.

    SELECT a~matnr
      INTO CORRESPONDING FIELDS OF TABLE lt_mat_rollo
      FROM mara AS a
      INNER JOIN marc AS b ON ( a~matnr = b~matnr )
      WHERE a~mtart = 'ZROL'
      AND a~matkl = p_matkl
      AND a~zzgramaje = p_zzgramaje
      AND a~zzancho = gv_zzancho_max
      AND b~werks = gv_werks_fab.

    IF lt_mat_rollo[] IS NOT INITIAL.
      READ TABLE lt_mat_rollo INTO ls_mat_rollo INDEX 1.
      gv_rollo = ls_mat_rollo-matnr.
    ENDIF.

* GST - 10/11/2016 - SAT 7000012677 <-
    IF gv_rollo IS INITIAL.
      CLEAR: p_mat_rollo_ok, p_exit.
      MESSAGE i088(zpp) DISPLAY LIKE 'E'.
    ELSE.
      CLEAR lv_verid_rol.
      SELECT SINGLE verid INTO lv_verid_rol
        FROM mkal
        WHERE matnr = gv_rollo
        AND werks = gv_werks_fab
        AND verid = gc_verid.

      IF lv_verid_rol IS NOT INITIAL.
        CLEAR p_exit.
        p_mat_rollo_ok = 'X'.
      ELSE.
        CLEAR: p_mat_rollo_ok, p_exit.
        MESSAGE i103(zpp) WITH gv_rollo gv_werks_fab
                DISPLAY LIKE 'E'.
      ENDIF.
    ENDIF.

    " Peso máximo no supera al peso de las bobinas:
    IF gv_peso_max <= p_peso_bob.
      CLEAR: p_mat_rollo_ok, p_exit.
      MESSAGE i089(zpp) DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.


    " Ancho máximo no supera al de las bobinas:
    IF gv_zzancho_max <= p_ancho_bob.
      CLEAR: p_mat_rollo_ok, p_exit.
      MESSAGE i090(zpp) DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.

  ENDIF.

ENDFORM.                    " GET_MAT_ROL_ANCHO_MAX
*&---------------------------------------------------------------------*
*&      Form  GET_DATOS_CABOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PT_CABOS  text
*      -->P_GV_ZZGRAMAJE  text
*      -->P_GV_MATKL  text
*      -->P_LV_LINES  text
*      <--P_LV_MAT_CABOS_OK  text
*      <--P_PV_EXIT  text
*----------------------------------------------------------------------*
FORM get_datos_cabos  TABLES   pt_cabos TYPE ty_t_cabos
                      USING    p_zzgramaje
                               p_matkl
                               p_lines
                               p_peso_bob
                               p_ancho_bob
                      CHANGING p_mat_cabos_ok
                               p_exit.

  CLEAR: pt_cabos. REFRESH: pt_cabos.

  CASE p_lines.
    WHEN 1.
      PERFORM solic_datos_cabos TABLES pt_cabos
                                USING p_zzgramaje
                                      p_matkl
                                      p_peso_bob
                                      p_ancho_bob
                                CHANGING p_mat_cabos_ok
                                         p_exit.

    WHEN 2.
      PERFORM solic_datos_cabo TABLES pt_cabos
                               USING p_zzgramaje
                                     p_matkl
                                     p_peso_bob
                                     p_ancho_bob
                               CHANGING p_mat_cabos_ok
                                        p_exit.

  ENDCASE.

ENDFORM.                    " GET_DATOS_CABOS
*&---------------------------------------------------------------------*
*&      Form  SOLIC_DATOS_CABOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PT_CABOS  text
*      -->P_P_ZZGRAMAJE  text
*      -->P_P_MATKL  text
*      <--P_P_MAT_CABOS_OK  text
*      <--P_P_EXIT  text
*----------------------------------------------------------------------*
FORM solic_datos_cabos  TABLES   pt_cabos TYPE ty_t_cabos
                        USING    p_zzgramaje
                                 p_matkl
                                 p_peso_bob
                                 p_ancho_bob
                        CHANGING p_mat_cabos_ok
                                 p_exit.

  DATA: lv_returncode TYPE c.

  DATA: lt_fields TYPE TABLE OF sval,
        ls_fields TYPE          sval,
        ls_cabos  TYPE          ty_cabos.
  DATA: lv_ancho_cabo            TYPE zancho,
        lv_ancho_cabo_2          TYPE zancho,
        lv_peso_cabo             TYPE gamng,
        lv_peso_cabo_2           TYPE gamng,
        lv_peso_cabo_txt(20),
        lv_peso_cabo_def         TYPE gamng,
        lv_peso_cabo_def_2       TYPE gamng,
        lv_peso_cabo_def_tot     TYPE gamng,
        lv_peso_cabo_def_txt(20),
        lv_ancho_cabo_def        TYPE zancho,
        lv_ancho_cabo_def_2      TYPE zancho,
        lv_ancho_cabo_def_tot    TYPE zancho,
        lv_matnr                 TYPE matnr,
        lv_matnr_2               TYPE matnr,
        lv_text_question         TYPE string,
        lv_answer(1).

  DATA: lv_verid_cabo1 TYPE verid,
        lv_verid_cabo2 TYPE verid.

* GST - 10/11/2016 - SAT 7000012677 ->
  DATA: ls_mat_bob TYPE ty_matnr,
        lt_mat_bob TYPE ty_t_matnr.
* GST - 10/11/2016 - SAT 7000012677 <-

  CLEAR: lt_fields. REFRESH: lt_fields.
  CLEAR: lv_returncode.
  CLEAR: gt_cabos. REFRESH: gt_cabos.

  CLEAR: lv_ancho_cabo, lv_peso_cabo, lv_ancho_cabo_2, lv_peso_cabo_2.
  CLEAR: lv_ancho_cabo_def, lv_peso_cabo_def.
  CLEAR: lv_ancho_cabo_def_2, lv_peso_cabo_def_2.

  lv_ancho_cabo = gv_zzancho_max - p_ancho_bob.
  lv_peso_cabo = gv_peso_max - p_peso_bob.

  " Miramos si existe un material ZPAP con ese ancho:
  CLEAR lv_matnr.

* GST - 10/11/2016 - SAT 7000012677 ->

  CLEAR: ls_mat_bob, lt_mat_bob.
  REFRESH: lt_mat_bob.

  SELECT a~matnr
    INTO  CORRESPONDING FIELDS OF TABLE lt_mat_bob
    FROM mara AS a
    INNER JOIN marc AS b ON ( a~matnr = b~matnr )
    WHERE a~mtart = 'ZPAP'
    AND a~matkl = p_matkl
    AND a~zzgramaje = p_zzgramaje
    AND a~zzancho = lv_ancho_cabo
    AND b~werks = gv_werks_fab.

  IF lt_mat_bob[] IS NOT INITIAL.
    READ TABLE lt_mat_bob INTO ls_mat_bob INDEX 1.
    lv_matnr = ls_mat_bob-matnr.
  ENDIF.

  IF lv_matnr IS INITIAL.
    CLEAR lv_ancho_cabo.
  ENDIF.

* 1) Ancho cabo 1:
  CLEAR ls_fields.
  ls_fields-tabname   = 'MARA'.
  ls_fields-fieldname = 'ZZANCHO'.
  ls_fields-fieldtext = text-008.
  ls_fields-field_obl = 'X'.
  ls_fields-value = lv_ancho_cabo.
  APPEND ls_fields TO lt_fields.

* 2) Peso cabo 1:
  CLEAR ls_fields.
  ls_fields-tabname   = 'AFKO'.
  ls_fields-fieldname = 'GAMNG'.
  ls_fields-fieldtext = text-009.
  ls_fields-field_obl = 'X'.
  ls_fields-value = lv_peso_cabo.
  APPEND ls_fields TO lt_fields.

* 3) Ancho cabo 2:
  CLEAR ls_fields.
  ls_fields-tabname   = 'ZTMM0004'.
  ls_fields-fieldname = 'ZZANCHO'.
  ls_fields-fieldtext = text-010.
  ls_fields-value = lv_ancho_cabo_2.
  APPEND ls_fields TO lt_fields.

* 4) Peso cabo 2:
  CLEAR ls_fields.
  ls_fields-tabname   = 'MCSFIS'.
  ls_fields-fieldname = 'GAMNG'.
  ls_fields-fieldtext = text-011.
  ls_fields-value = lv_peso_cabo_2.
  APPEND ls_fields TO lt_fields.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-012
      start_column    = '5'
      start_row       = '5'
    IMPORTING
      returncode      = lv_returncode
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.

  IF sy-subrc <> 0.
    lv_returncode = 'E'.
  ENDIF.

  IF lv_returncode <> 'E' AND lv_returncode <> 'A'.

    " Ancho del cabo 1:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 1.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0000'.
      lv_ancho_cabo_def = ls_fields-value.
    ELSE.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i091(zpp) DISPLAY LIKE 'E'.
    ENDIF.

    " Peso del cabo 1:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 2.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0.000'.
      lv_peso_cabo_def = ls_fields-value.
    ELSE.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i092(zpp) DISPLAY LIKE 'E'.
    ENDIF.

    " Ancho del cabo 2:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 3.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0000'.
      lv_ancho_cabo_def_2 = ls_fields-value.
    ENDIF.

    " Peso del cabo 2:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 4.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0.000'.
      lv_peso_cabo_def_2 = ls_fields-value.
    ENDIF.

    " Los dos datos del cabo 2 deben estar rellenos, si existe:
    IF lv_ancho_cabo_def_2 IS NOT INITIAL
       AND lv_peso_cabo_def_2 IS INITIAL.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i097(zpp) DISPLAY LIKE 'E'.
    ELSEIF lv_ancho_cabo_def_2 IS INITIAL
           AND lv_peso_cabo_def_2 IS NOT INITIAL.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i098(zpp) DISPLAY LIKE 'E'.
    ENDIF.
  ELSE.
    p_exit = 'X'.
    EXIT.
  ENDIF.

  " Encontrar materiales con los datos seleccionados:
  CLEAR: lv_matnr, lv_matnr_2.

  " Chequeo existe material cabo 1:
  IF lv_ancho_cabo_def IS NOT INITIAL AND
    lv_ancho_cabo_def <> '0000'.

* GST - 10/11/2016 - SAT 7000012677 ->

    CLEAR: ls_mat_bob, lt_mat_bob.
    REFRESH: lt_mat_bob.

    SELECT a~matnr
      INTO  CORRESPONDING FIELDS OF TABLE lt_mat_bob
      FROM mara AS a
      INNER JOIN marc AS b ON ( a~matnr = b~matnr )
      WHERE a~mtart = 'ZPAP'
      AND a~matkl = p_matkl
      AND a~zzgramaje = p_zzgramaje
      AND a~zzancho = lv_ancho_cabo_def
      AND b~werks = gv_werks_fab.

    IF lt_mat_bob[] IS NOT INITIAL.
      READ TABLE lt_mat_bob INTO ls_mat_bob INDEX 1.
      lv_matnr = ls_mat_bob-matnr.
    ENDIF.

  ENDIF.

  IF lv_matnr IS INITIAL.
    MESSAGE i096(zpp) WITH lv_ancho_cabo_def p_matkl p_zzgramaje
                      DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ELSE.
    CLEAR lv_verid_cabo1.
    SELECT SINGLE verid INTO lv_verid_cabo1
      FROM mkal
      WHERE matnr = lv_matnr
      AND werks = gv_werks_fab
      AND verid = gc_verid.

    IF lv_verid_cabo1 IS INITIAL.
      MESSAGE i103(zpp) WITH lv_matnr gv_werks_fab
              DISPLAY LIKE 'E'.
      CLEAR: p_mat_cabos_ok, p_exit.
      EXIT.
    ENDIF.
  ENDIF.

  " Chequeo existe material cabo 2:
  IF lv_ancho_cabo_def_2 IS NOT INITIAL AND
    lv_ancho_cabo_def_2 <> '0000'.

* GST - 10/11/2016 - SAT 7000012677 ->

    CLEAR: ls_mat_bob, lt_mat_bob.
    REFRESH: lt_mat_bob.

    SELECT a~matnr
      INTO  CORRESPONDING FIELDS OF TABLE lt_mat_bob
      FROM mara AS a
      INNER JOIN marc AS b ON ( a~matnr = b~matnr )
      WHERE a~mtart = 'ZPAP'
      AND a~matkl = p_matkl
      AND a~zzgramaje = p_zzgramaje
      AND a~zzancho = lv_ancho_cabo_def_2
      AND b~werks = gv_werks_fab.

    IF lt_mat_bob[] IS NOT INITIAL.
      READ TABLE lt_mat_bob INTO ls_mat_bob INDEX 1.
      lv_matnr_2 = ls_mat_bob-matnr.
    ENDIF.

    IF lv_matnr_2 IS INITIAL.
      MESSAGE i096(zpp) WITH lv_ancho_cabo_def_2 p_matkl p_zzgramaje
                        DISPLAY LIKE 'E'.
      CLEAR: p_mat_cabos_ok, p_exit.
      EXIT.

    ELSE.
      CLEAR lv_verid_cabo2.
      SELECT SINGLE verid INTO lv_verid_cabo2
        FROM mkal
        WHERE matnr = lv_matnr_2
        AND werks = gv_werks_fab
        AND verid = gc_verid.
      IF lv_verid_cabo2 IS INITIAL.
        MESSAGE i103(zpp) WITH lv_matnr_2 gv_werks_fab
                DISPLAY LIKE 'E'.
        CLEAR: p_mat_cabos_ok, p_exit.
        EXIT.
      ENDIF.
    ENDIF.

  ENDIF.


* Chequeo ancho cabo: No puede ser mayor que el ancho total permitido
  CLEAR lv_ancho_cabo_def_tot.
  lv_ancho_cabo_def_tot = lv_ancho_cabo_def + lv_ancho_cabo_def_2.
  lv_ancho_cabo = gv_zzancho_max - p_ancho_bob.
  IF lv_ancho_cabo_def_tot > lv_ancho_cabo.
    MESSAGE i099(zpp) WITH lv_ancho_cabo DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ENDIF.

* Chequeo peso cabo: No puede ser mayor del total peso permitido
  CLEAR lv_peso_cabo_def_tot.
  lv_peso_cabo_def_tot = lv_peso_cabo_def + lv_peso_cabo_def_2.
  IF lv_peso_cabo_def_tot > lv_peso_cabo.
    MESSAGE i100(zpp) WITH lv_peso_cabo DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ENDIF.

* Chequeo peso cabo: Peso menor que el exigido
  IF lv_peso_cabo_def_tot < lv_peso_cabo.
    CLEAR: lv_peso_cabo_def_txt, lv_peso_cabo_txt.
    WRITE lv_peso_cabo_def_tot TO lv_peso_cabo_def_txt.
    WRITE lv_peso_cabo TO lv_peso_cabo_txt.

    CLEAR: lv_text_question, lv_answer.
    CONCATENATE 'La suma de los cabos tiene un peso de'
                lv_peso_cabo_def_txt 'y es menor'
                'que el permitido' lv_peso_cabo_txt '.'
                '¿Desea continuar?'
                INTO lv_text_question SEPARATED BY space.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar       = text-007
        text_question  = lv_text_question
        text_button_1  = 'Sí'
        text_button_2  = 'No'
      IMPORTING
        answer         = lv_answer
      EXCEPTIONS
        text_not_found = 1
        OTHERS         = 2.

    IF sy-subrc <> 0.
      lv_answer = '2'.
    ENDIF.

    IF lv_answer = '2' AND lv_answer = 'A'.
      CLEAR: p_mat_cabos_ok.
      p_exit = 'X'.
      EXIT.
    ENDIF.

  ENDIF.

  " Guardar datos de los cabos en la tabla interna:
  CLEAR: gt_cabos. REFRESH: gt_cabos.
  p_mat_cabos_ok = 'X'.
  CLEAR p_exit.

  " Cabo 1:
  IF lv_matnr IS NOT INITIAL.
    CLEAR ls_cabos.
    ls_cabos-matnr = lv_matnr.
    SELECT SINGLE maktx INTO ls_cabos-matkx
      FROM makt
      WHERE matnr = lv_matnr
      AND spras = sy-langu.

    ls_cabos-matkl = p_matkl.
    ls_cabos-cantidad = lv_peso_cabo_def.
    ls_cabos-zzgramaje = p_zzgramaje.
    ls_cabos-zzancho = lv_ancho_cabo_def.
    APPEND ls_cabos TO gt_cabos.
  ENDIF.

  " Cabo 2:
  IF lv_matnr_2 IS NOT INITIAL.
    CLEAR ls_cabos.
    ls_cabos-matnr = lv_matnr_2.
    SELECT SINGLE maktx INTO ls_cabos-matkx
      FROM makt
      WHERE matnr = lv_matnr_2
      AND spras = sy-langu.

    ls_cabos-matkl = p_matkl.
    ls_cabos-cantidad = lv_peso_cabo_def_2.
    ls_cabos-zzgramaje = p_zzgramaje.
    ls_cabos-zzancho = lv_ancho_cabo_def_2.
    APPEND ls_cabos TO gt_cabos.
  ENDIF.

ENDFORM.                    " SOLIC_DATOS_CABOS
*&---------------------------------------------------------------------*
*&      Form  SOLIC_DATOS_CABO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PT_CABOS  text
*      -->P_P_ZZGRAMAJE  text
*      -->P_P_MATKL  text
*      <--P_P_MAT_CABOS_OK  text
*      <--P_P_EXIT  text
*----------------------------------------------------------------------*
FORM solic_datos_cabo  TABLES   pt_cabos TYPE ty_t_cabos
                       USING    p_zzgramaje
                                p_matkl
                                p_peso_bob
                                p_ancho_bob
                       CHANGING p_mat_cabos_ok
                                p_exit.

  DATA: lv_returncode TYPE c.

  DATA: lt_fields TYPE TABLE OF sval,
        ls_fields TYPE          sval,
        ls_cabos  TYPE          ty_cabos.
  DATA: lv_ancho_cabo            TYPE zancho,
        lv_peso_cabo             TYPE gamng,
        lv_peso_cabo_txt(20),
        lv_peso_cabo_def         TYPE gamng,
        lv_peso_cabo_def_txt(20),
        lv_ancho_cabo_def        TYPE zancho,
        lv_matnr                 TYPE matnr,
        lv_text_question         TYPE string,
        lv_answer(1).

  DATA: lv_verid_cabo1 TYPE verid.

* GST - 10/11/2016 - SAT 7000012677 ->
  DATA: ls_mat_bob TYPE ty_matnr,
        lt_mat_bob TYPE ty_t_matnr.
* GST - 10/11/2016 - SAT 7000012677 <-

  CLEAR: lt_fields. REFRESH: lt_fields.
  CLEAR: lv_returncode.
  CLEAR: gt_cabos. REFRESH: gt_cabos.
  CLEAR: p_mat_cabos_ok, p_exit.

  CLEAR: lv_ancho_cabo, lv_peso_cabo.
  CLEAR: lv_ancho_cabo_def, lv_peso_cabo_def.
  lv_ancho_cabo = gv_zzancho_max - p_ancho_bob.
  lv_peso_cabo = gv_peso_max - p_peso_bob.

  " Miramos si existe un material ZPAP con ese ancho:
  CLEAR lv_matnr.

* GST - 10/11/2016 - SAT 7000012677 ->
  CLEAR: ls_mat_bob, lt_mat_bob.
  REFRESH: lt_mat_bob.

  SELECT a~matnr
    INTO  CORRESPONDING FIELDS OF TABLE lt_mat_bob
    FROM mara AS a
    INNER JOIN marc AS b ON ( a~matnr = b~matnr )
    WHERE a~mtart = 'ZPAP'
    AND a~matkl = p_matkl
    AND a~zzgramaje = p_zzgramaje
    AND a~zzancho = lv_ancho_cabo
    AND b~werks = gv_werks_fab.

  IF lt_mat_bob[] IS NOT INITIAL.
    READ TABLE lt_mat_bob INTO ls_mat_bob INDEX 1.
    lv_matnr = ls_mat_bob-matnr.
  ENDIF.


  IF lv_matnr IS INITIAL.
    CLEAR lv_ancho_cabo.
  ENDIF.


* 1) Ancho cabo:
  CLEAR ls_fields.
  ls_fields-tabname   = 'MARA'.
  ls_fields-fieldname = 'ZZANCHO'.
  ls_fields-fieldtext = text-005.
  ls_fields-field_obl = 'X'.
  ls_fields-value = lv_ancho_cabo.
  APPEND ls_fields TO lt_fields.

* 2) Peso cabo:
  CLEAR ls_fields.
  ls_fields-tabname   = 'AFKO'.
  ls_fields-fieldname = 'GAMNG'.
  ls_fields-fieldtext = text-006.
  ls_fields-field_obl = 'X'.
  ls_fields-value = lv_peso_cabo.
  APPEND ls_fields TO lt_fields.

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-004
      start_column    = '5'
      start_row       = '5'
    IMPORTING
      returncode      = lv_returncode
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.

  IF sy-subrc <> 0.
    lv_returncode = 'E'.
  ENDIF.

  IF lv_returncode <> 'E' AND lv_returncode <> 'A'.

    " Ancho cabo:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 1.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0000'.
      lv_ancho_cabo_def = ls_fields-value.
    ELSE.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i091(zpp) DISPLAY LIKE 'E'.
    ENDIF.

    " Peso cabo:
    CLEAR ls_fields.
    READ TABLE lt_fields INTO ls_fields INDEX 2.
    IF ls_fields-value IS NOT INITIAL
      AND ls_fields-value <> '0.000'.
      lv_peso_cabo_def = ls_fields-value.
    ELSE.
      CLEAR: p_mat_cabos_ok, p_exit.
      MESSAGE i092(zpp) DISPLAY LIKE 'E'.
    ENDIF.

  ELSE.
    p_exit = 'X'.
    EXIT.
  ENDIF.

* Encontrar material con los datos seleccionados:
  CLEAR lv_matnr.

  IF lv_ancho_cabo_def IS NOT INITIAL
    AND lv_ancho_cabo_def <> '0000'.

* GST - 10/11/2016 - SAT 7000012677 ->

    CLEAR: ls_mat_bob, lt_mat_bob.
    REFRESH: lt_mat_bob.

    SELECT a~matnr
      INTO  CORRESPONDING FIELDS OF TABLE lt_mat_bob
      FROM mara AS a
      INNER JOIN marc AS b ON ( a~matnr = b~matnr )
      WHERE a~mtart = 'ZPAP'
      AND a~matkl = p_matkl
      AND a~zzgramaje = p_zzgramaje
      AND a~zzancho = lv_ancho_cabo_def
      AND b~werks = gv_werks_fab.

    IF lt_mat_bob[] IS NOT INITIAL.
      READ TABLE lt_mat_bob INTO ls_mat_bob INDEX 1.
      lv_matnr = ls_mat_bob-matnr.
    ENDIF.

  ENDIF.

* Chequeo existe material cabo:
  IF lv_matnr IS INITIAL.
    MESSAGE i096(zpp) WITH lv_ancho_cabo_def p_matkl p_zzgramaje
                      DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ELSE.
    CLEAR lv_verid_cabo1.
    SELECT SINGLE verid INTO lv_verid_cabo1
      FROM mkal
      WHERE matnr = lv_matnr
      AND werks = gv_werks_fab
      AND verid = gc_verid.
    IF lv_verid_cabo1 IS INITIAL.
      MESSAGE i103(zpp) WITH  lv_matnr gv_werks_fab
              DISPLAY LIKE 'E'.
      CLEAR: p_mat_cabos_ok, p_exit.
      EXIT.
    ENDIF.
  ENDIF.

* Chequeo ancho cabo: No puede ser mayor que el ancho total permitido
  lv_ancho_cabo = gv_zzancho_max - p_ancho_bob.
  IF lv_ancho_cabo_def > lv_ancho_cabo.
    MESSAGE i122(zpp) WITH lv_ancho_cabo DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ENDIF.

* Chequeo peso cabo: No puede ser mayor del total peso permitido
  IF lv_peso_cabo_def > lv_peso_cabo.
    MESSAGE i094(zpp) WITH lv_peso_cabo DISPLAY LIKE 'E'.
    CLEAR: p_mat_cabos_ok, p_exit.
    EXIT.
  ENDIF.

* Chequeo peso cabo: Peso menor que el exigido
  IF lv_peso_cabo_def < lv_peso_cabo.

    CLEAR: lv_peso_cabo_def_txt, lv_peso_cabo_txt.
    WRITE lv_peso_cabo_def TO lv_peso_cabo_def_txt.
    WRITE lv_peso_cabo TO lv_peso_cabo_txt.

    CLEAR: lv_text_question, lv_answer.
    CONCATENATE 'El cabo tiene peso' lv_peso_cabo_def_txt 'y es menor'
                'que el permitido' lv_peso_cabo_txt '.'
                '¿Desea continuar?'
                INTO lv_text_question SEPARATED BY space.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar       = text-007
        text_question  = lv_text_question
        text_button_1  = 'Sí'
        text_button_2  = 'No'
      IMPORTING
        answer         = lv_answer
      EXCEPTIONS
        text_not_found = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      lv_answer = '2'.
    ENDIF.

    IF lv_answer = '2' AND lv_answer = 'A'.
      CLEAR: p_mat_cabos_ok.
      p_exit = 'X'.
      EXIT.
    ENDIF.
  ENDIF.

* Guradar cabo encontrado en la tabla interna:
  CLEAR: gt_cabos. REFRESH: gt_cabos.
  p_mat_cabos_ok = 'X'.
  CLEAR p_exit.

  IF lv_matnr IS NOT INITIAL.
    CLEAR ls_cabos.
    ls_cabos-matnr = lv_matnr.
    SELECT SINGLE maktx INTO ls_cabos-matkx
      FROM makt
      WHERE matnr = lv_matnr
      AND spras = sy-langu.

    ls_cabos-matkl = p_matkl.
    ls_cabos-cantidad = lv_peso_cabo_def.
    ls_cabos-zzgramaje = p_zzgramaje.
    ls_cabos-zzancho = lv_ancho_cabo_def.
    APPEND ls_cabos TO gt_cabos.

  ENDIF.

ENDFORM.                    " SOLIC_DATOS_CABO
*&---------------------------------------------------------------------*
*&      Form  MARCAR_AGRUP_ANCHO_MAX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GT_CABOS  text
*----------------------------------------------------------------------*
FORM marcar_agrup_ancho_max  TABLES   pt_cabos TYPE ty_t_cabos.

  DATA: ls_alv       TYPE zspp0026_alv,
        ls_selec     TYPE zspp0026_alv,
        lv_agru      TYPE char3,
        lv_ind       TYPE i,
        lv_maktx     TYPE maktx,
        lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho,
        ls_cabos     TYPE ty_cabos.

* Recuperar datos de material de rollo:
  CLEAR: lv_maktx, lv_zzgramaje, lv_zzancho.
  SELECT SINGLE maktx INTO lv_maktx
    FROM makt
    WHERE matnr = gv_rollo
    AND spras = sy-langu.

  SELECT SINGLE zzgramaje zzancho
    INTO (lv_zzgramaje, lv_zzancho )
    FROM mara
    WHERE matnr = gv_rollo.

* Indicador de agrupación:
  ADD 1 TO gv_agru_bob.
  WRITE gv_agru_bob TO lv_agru RIGHT-JUSTIFIED.

  LOOP AT gt_selec INTO ls_selec.

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv WITH KEY vbeln = ls_selec-vbeln
                                           posnr = ls_selec-posnr
                                           etenr = ls_selec-etenr.
    lv_ind = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      ADD 1 TO gv_num_cabo.
      ls_alv-agru_bob = lv_agru.
      ls_alv-ancho_max_flag = 'X'.
      ls_alv-cant_rol_agrup = gv_peso_max.
      ls_alv-mate_rol_agrup = gv_rollo.
      ls_alv-desc_rol_agrup = lv_maktx.
      ls_alv-gram_rol = lv_zzgramaje.
*      ls_alv-anch_rol = lv_zzancho.
      ls_alv-anch_rol_agrup = gv_zzancho_max.
      ls_alv-num_cabo = gv_num_cabo.
      ls_alv-icon = '@09@'. " Amarillo
      MODIFY gt_alv FROM ls_alv INDEX lv_ind.
    ENDIF.

  ENDLOOP.

  " Agregar líneas a lineas:
  LOOP AT pt_cabos INTO ls_cabos.
    ADD 1 TO gv_num_cabo.
    CLEAR ls_alv.
*    ls_alv-kunnr = ls_selec-kunnr. " Poner cliente ficticio
    IF ls_selec-werks = '3020'.
      ls_alv-kunnr = gc_kunnr2.
    ELSE.
      ls_alv-kunnr = gc_kunnr.
    ENDIF.
    ls_alv-werks = ls_selec-werks.
    ls_alv-werks_fab = ls_selec-werks_fab.
    CLEAR: ls_alv-vbeln, ls_alv-posnr.
    ls_alv-mbdat = ls_selec-mbdat.
    ls_alv-wmeng = ls_cabos-cantidad.
    ls_alv-vrkme = ls_selec-vrkme.
    ls_alv-lprio = ls_selec-lprio.
    ls_alv-cant_bob = ls_cabos-cantidad.
    ls_alv-unid_bob = ls_selec-unid_bob.
    ls_alv-mate_bob = ls_cabos-matnr.
    ls_alv-desc_bob = ls_cabos-matkx.
    ls_alv-gram_bob = ls_cabos-zzgramaje.
    ls_alv-anch_bob = ls_cabos-zzancho.
    ls_alv-matk_bob = ls_cabos-matkl.
    ls_alv-aufa_bob = gc_aufa_bob.
    ls_alv-agru_bob = lv_agru.
    ls_alv-ancho_max_flag = 'X'.
    ls_alv-cant_rol_agrup = gv_peso_max.
    ls_alv-unid_rol = ls_selec-unid_rol.
    ls_alv-mate_rol_agrup = gv_rollo.
    ls_alv-desc_rol_agrup = lv_maktx.
    ls_alv-gram_rol = lv_zzgramaje.
    ls_alv-anch_rol_agrup = lv_zzancho.
    ls_alv-matk_rol = ls_selec-matk_rol.
    ls_alv-aufa_rol = gc_aufa_rol.
    ls_alv-num_cabo = gv_num_cabo.
    ls_alv-icon = '@09@'. " Amarillo

* CMS Añadir reparto 1 para cabos creados
    ls_alv-etenr = 1.
    APPEND ls_alv TO gt_alv.
  ENDLOOP.

  CLEAR: gt_selec. REFRESH: gt_selec.
  CLEAR: pt_cabos. REFRESH: pt_cabos.

ENDFORM.                    " MARCAR_AGRUP_ANCHO_MAX
*&---------------------------------------------------------------------*
*&      Form  F_REC_ORDENES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_rec_ordenes .

  DATA: lt_dat_rol TYPE TABLE OF aufk,
        ls_dat_rol TYPE          aufk,
        lt_dat_bob TYPE TABLE OF aufk,
        ls_dat_bob TYPE          aufk,
        ls_dat_ord TYPE          zspp0026_linea_orden.


  CLEAR: gt_datos_rollos, gt_datos_bobinas.
  REFRESH: gt_datos_rollos, gt_datos_bobinas.

  CLEAR: lt_dat_rol, ls_dat_rol.
  REFRESH: lt_dat_rol.

  " 1) SECUENCIACIÓN ROLLOS:

  " Recuperamos los datos de las órdenes de rollos que no
  " hayan sido liberadas:

  SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_dat_rol
  FROM aufk AS a
  INNER JOIN jest AS b ON b~objnr = a~objnr
  INNER JOIN caufv AS c ON c~aufnr = a~aufnr
  WHERE b~stat = 'I0001'
  AND b~inact = ' '
  AND a~auart = gc_aufa_rol.

  " Seleccionamos datos de las órdenes de rollo a secuenciar:
  LOOP AT lt_dat_rol INTO ls_dat_rol
       WHERE ( ( zzebeln1 IS NOT INITIAL AND zzebelp1 IS NOT INITIAL )
       OR ( zzebeln2 IS NOT INITIAL AND zzebelp2 IS NOT INITIAL )
       OR ( zzebeln3 IS NOT INITIAL AND zzebelp3 IS NOT INITIAL ) ) .

    CLEAR ls_dat_ord.
    ls_dat_ord-mbdat = ls_dat_rol-zzfec_entreg1.
    ls_dat_ord-vbeln = ls_dat_rol-zzebeln1.
    ls_dat_ord-posnr = ls_dat_rol-zzebelp1.
    ls_dat_ord-kunnr = ls_dat_rol-zzkunnr1.
    ls_dat_ord-mbdat2 = ls_dat_rol-zzfec_entreg2.
    ls_dat_ord-vbeln2 = ls_dat_rol-zzebeln2.
    ls_dat_ord-posnr2 = ls_dat_rol-zzebelp2.
    ls_dat_ord-kunnr2 = ls_dat_rol-zzkunnr2.
    ls_dat_ord-mbdat3 = ls_dat_rol-zzfec_entreg3.
    ls_dat_ord-vbeln3 = ls_dat_rol-zzebeln3.
    ls_dat_ord-posnr3 = ls_dat_rol-zzebelp3.
    ls_dat_ord-kunnr3 = ls_dat_rol-zzkunnr3.
    ls_dat_ord-werks = ls_dat_rol-werks.
    SELECT SINGLE plnbez INTO ls_dat_ord-matnr
      FROM afko
      WHERE aufnr = ls_dat_rol-aufnr.
    SELECT SINGLE matkl zzgramaje zzancho
      INTO (ls_dat_ord-matkl, ls_dat_ord-zzgramaje, ls_dat_ord-zzancho)
      FROM mara
      WHERE matnr = ls_dat_ord-matnr.
    SELECT SINGLE maktx INTO ls_dat_ord-maktx
      FROM makt
      WHERE matnr = ls_dat_ord-matnr
      AND spras = sy-langu.
    PERFORM calc_escalon  USING  ls_dat_ord-matnr
                                 ls_dat_ord-zzgramaje
                                 ls_dat_ord-zzancho
                                 ls_dat_ord-matkl
                          CHANGING ls_dat_ord-escalon.

    ls_dat_ord-aufnr = ls_dat_rol-aufnr.
    ls_dat_ord-auart = ls_dat_rol-auart.
    IF ( ls_dat_ord-vbeln IS NOT INITIAL
         AND ls_dat_ord-posnr IS NOT INITIAL )
      OR ( ls_dat_ord-vbeln2 IS NOT INITIAL
         AND ls_dat_ord-posnr2 IS NOT INITIAL )
      OR ( ls_dat_ord-vbeln3 IS NOT INITIAL
         AND ls_dat_ord-posnr3 IS NOT INITIAL ).
      APPEND ls_dat_ord TO gt_datos_rollos.
    ENDIF.
  ENDLOOP.

  SORT gt_datos_rollos BY escalon ASCENDING
                          mbdat ASCENDING
                          vbeln ASCENDING
                          posnr ASCENDING.

  " 2) SECUENCIACIÓN BOBINAS:
  CLEAR: lt_dat_bob, ls_dat_bob.
  REFRESH: lt_dat_bob.

  " Recuperamos los datos de las órdenes de bobinas que no hayan sido
  " liberadas:
  SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_dat_bob
  FROM aufk AS a
  INNER JOIN jest AS b ON b~objnr = a~objnr
  INNER JOIN caufv AS c ON c~aufnr = a~aufnr
  WHERE b~stat = 'I0001'
  AND b~inact = ' '
  AND a~auart = gc_aufa_bob.

  " Seleccionamos datos de las órdenes de bobina a secuenciar:
  LOOP AT lt_dat_bob INTO ls_dat_bob WHERE zzebeln1 IS NOT INITIAL
                                     AND zzebelp1 IS NOT INITIAL.

    CLEAR ls_dat_ord.
    ls_dat_ord-mbdat = ls_dat_bob-zzfec_entreg1.
    ls_dat_ord-vbeln = ls_dat_bob-zzebeln1.
    ls_dat_ord-posnr = ls_dat_bob-zzebelp1.
    ls_dat_ord-kunnr = ls_dat_bob-zzkunnr1.
    ls_dat_ord-werks = ls_dat_bob-werks.

    SELECT SINGLE plnbez INTO ls_dat_ord-matnr
      FROM afko
      WHERE aufnr = ls_dat_bob-aufnr.

    SELECT SINGLE maktx INTO ls_dat_ord-maktx
      FROM makt
      WHERE matnr = ls_dat_ord-matnr
      AND spras = sy-langu.

    ls_dat_ord-aufnr = ls_dat_bob-aufnr.
    ls_dat_ord-auart = ls_dat_bob-auart.
    IF ls_dat_ord-vbeln IS NOT INITIAL
       AND ls_dat_ord-posnr IS NOT INITIAL.
      APPEND ls_dat_ord TO gt_datos_bobinas.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_REC_ORDENES
*&---------------------------------------------------------------------*
*&      Form  F_SECUENCIACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_secuenciacion .

  DATA: lv_sentido(1),
        lv_escalon    TYPE zindice_prod,
        lv_sec        TYPE cy_seqnr,
        lv_max_esc    TYPE zindice_prod,
        lv_min_esc    TYPE zindice_prod,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp.

  CLEAR: lv_sentido, lv_escalon, lv_sec, lv_fecha_rol, lv_hora_rol.
  CLEAR: lv_fecha_bob, lv_hora_bob.
  CLEAR: lv_max_esc, lv_min_esc.

  " 0) Cálculo escalón máximo y mínimo de la tabla de secuenciación:
  PERFORM min_max_sec CHANGING lv_max_esc
                               lv_min_esc.

  " 1) Establecer secuenciación actual: Pto secuencia y
  "    si es ascendente / descendente:

  PERFORM sec_actual USING lv_max_esc
                           lv_min_esc
                     CHANGING lv_sentido
                             lv_escalon.

  " 2) Obtención de la secuencia a partir de la cuál se va a hacer
  "    la resecuenciación de las órdenes no liberadas, así como fecha
  "    y hora a partir de la cúal se pueden secuenciar las órdenes de
  "    rollo y bobina:

  PERFORM num_sec_actual_2 CHANGING lv_sec
                                lv_fecha_rol
                                lv_hora_rol
                                lv_fecha_bob
                                lv_hora_bob.

  " 3) Establecemos secuencia, fechas y creamos las órdenes:
  " También llenamos una tabla interna con los resultados del proceso
  " para pintar el ALV posterior de log

  PERFORM f_sec_ordenes USING lv_sentido
                                lv_escalon
                                lv_sec
                                lv_max_esc
                                lv_fecha_rol
                                lv_hora_rol
                                lv_fecha_bob
                                lv_hora_bob
                                lv_min_esc.

ENDFORM.                    " F_SECUENCIACION
*&---------------------------------------------------------------------*
*&      Form  NUM_SEC_ACTUAL_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_SEC  text
*      <--P_LV_FECHA_ROL  text
*      <--P_LV_HORA_ROL  text
*      <--P_LV_FECHA_BOB  text
*      <--P_LV_HORA_BOB  text
*----------------------------------------------------------------------*
FORM num_sec_actual_2  CHANGING p_sec
                                p_fecha_rol
                                p_hora_rol
                                p_fecha_bob
                                p_hora_bob.

  DATA: BEGIN OF lt_lib_rollo OCCURS 0,
          aufnr    TYPE aufnr,
          werks    TYPE werks_d,
          cy_seqnr TYPE cy_seqnr,
          gltrp    TYPE co_gltrp,
          gluzp    TYPE co_gluzp,
        END OF lt_lib_rollo.

  DATA: BEGIN OF lt_lib_bob OCCURS 0,
          aufnr TYPE aufnr,
          werks TYPE werks_d,
          gltrp TYPE co_gltrp,
          gluzp TYPE co_gluzp,
        END OF lt_lib_bob.

  DATA: ls_lib_rollo LIKE LINE OF lt_lib_rollo,
        ls_lib_bob   LIKE LINE OF lt_lib_bob.

  DATA: lv_fabkl TYPE fabkl.

  CLEAR: lt_lib_rollo, ls_lib_rollo.
  REFRESH: lt_lib_rollo.

* 1) SECUENCIA, FECHA Y HORA MÁXIMA DE ÓRDENES ROLLO:

  " Seleccionamos todas las órdenes en estado liberado (I0002)
  " que hay hasta la fecha máx de entrega indicada:

  SELECT a~aufnr b~werks a~cy_seqnr c~gltrp c~gluzp
    INTO CORRESPONDING FIELDS OF TABLE lt_lib_rollo
    FROM afko AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN caufv AS c ON c~aufnr = a~aufnr
    INNER JOIN jest AS d ON d~objnr = b~objnr
      WHERE d~stat = 'I0002'
      AND d~inact = ' '
      AND b~auart = gc_aufa_rol.

  " Me quedo con la secuencia máxima rollo para secuenciar
  " las órdenes no liberadas:
  SORT lt_lib_rollo BY cy_seqnr DESCENDING
                       gltrp DESCENDING
                       gluzp DESCENDING.

  CLEAR ls_lib_rollo.
  READ TABLE lt_lib_rollo INTO ls_lib_rollo INDEX 1.
  IF ls_lib_rollo IS NOT INITIAL.
    p_sec = ls_lib_rollo-cy_seqnr + 1.
  ELSE.
    p_sec = 1.
  ENDIF.

  " Me quedo con la fecha y hora a partir de la cuál voy
  " a ir secuenciando las órdenes rollo:

  SORT lt_lib_rollo BY gltrp DESCENDING
                       gluzp DESCENDING.

  CLEAR ls_lib_rollo.
  READ TABLE lt_lib_rollo INTO ls_lib_rollo INDEX 1.

  IF ls_lib_rollo IS NOT INITIAL.
    p_hora_rol = ls_lib_rollo-gluzp + 1.
    IF p_hora_rol = '000001'.
      p_fecha_rol = ls_lib_rollo-gltrp + 1.
      CLEAR lv_fabkl.
      SELECT SINGLE fabkl INTO lv_fabkl
        FROM t001w
        WHERE werks = ls_lib_rollo-werks.
      IF lv_fabkl IS INITIAL.
        lv_fabkl = 'ES'.
      ENDIF.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = p_fecha_rol
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = p_fecha_rol
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
*      IF sy-subrc <> 0.
** Implement suitable error handling here
*      ENDIF.
    ELSE.
      p_fecha_rol = ls_lib_rollo-gltrp.
    ENDIF.
  ENDIF.

* 2) FECHA Y HORA MÁXIMA DE ÓRDENES BOBINA:

  CLEAR: lt_lib_bob, ls_lib_bob.
  REFRESH: lt_lib_bob.

  " Seleccionamos todas las órdenes bobina en estado liberado (I0002)
  " que hay hasta la fecha máx de entrega indicada:
  SELECT a~aufnr b~werks c~gltrp c~gluzp
    INTO CORRESPONDING FIELDS OF TABLE lt_lib_bob
    FROM afko AS a
    INNER JOIN aufk AS b ON b~aufnr = a~aufnr
    INNER JOIN caufv AS c ON c~aufnr = a~aufnr
    INNER JOIN jest AS d ON d~objnr = b~objnr
      WHERE d~stat = 'I0002'
      AND d~inact = ' '
      AND b~auart = gc_aufa_bob.

  " Me quedo con la fecha y hora a partir de la cuál voy
  " a ir secuenciando las órdenes bobina:
  SORT lt_lib_bob BY gltrp DESCENDING
                       gluzp DESCENDING.
  CLEAR ls_lib_bob.
  READ TABLE lt_lib_bob INTO ls_lib_bob INDEX 1.

  IF ls_lib_bob IS NOT INITIAL.
    p_hora_bob = ls_lib_bob-gluzp + 1.
    IF p_hora_bob = '000001'.
      p_fecha_bob = ls_lib_bob-gltrp + 1.
      CLEAR lv_fabkl.
      SELECT SINGLE fabkl INTO lv_fabkl
        FROM t001w
        WHERE werks = ls_lib_bob-werks.
      IF lv_fabkl IS INITIAL.
        lv_fabkl = 'ES'.
      ENDIF.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = p_fecha_bob
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = p_fecha_bob
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
*      IF sy-subrc <> 0.
** Implement suitable error handling here
*      ENDIF.
    ELSE.
      p_fecha_bob = ls_lib_bob-gltrp.
    ENDIF.
  ENDIF.

ENDFORM.                    " NUM_SEC_ACTUAL_2
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORDENES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_SENTIDO  text
*      -->P_LV_ESCALON  text
*      -->P_LV_SEC  text
*      -->P_LV_MAX_ESC  text
*      -->P_LV_FECHA_ROL  text
*      -->P_LV_HORA_ROL  text
*      -->P_LV_FECHA_BOB  text
*      -->P_LV_HORA_BOB  text
*      -->P_LV_MIN_ESC  text
*----------------------------------------------------------------------*
FORM f_sec_ordenes  USING    p_sentido
                             p_escalon
                             p_secuencia
                             p_total_esc
                             p_fecha_rol
                             p_hora_rol
                             p_fecha_bob
                             p_hora_bob
                             p_min_esc.


  IF p_sentido = 'A'.
    PERFORM f_sec_ord_ascending USING p_escalon
                                      p_secuencia
                                      p_total_esc
                                      p_fecha_rol
                                      p_hora_rol
                                      p_fecha_bob
                                      p_hora_bob
                                      p_sentido
                                      p_min_esc.
  ELSEIF p_sentido = 'D'.
    PERFORM f_sec_orden_descending USING p_escalon
                                         p_secuencia
                                         p_total_esc
                                         p_fecha_rol
                                         p_hora_rol
                                         p_fecha_bob
                                         p_hora_bob
                                         p_sentido
                                         p_min_esc.
  ENDIF.

ENDFORM.                    " F_SEC_ORDENES
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORD_ASCENDING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_ESCALON  text
*      -->P_P_SECUENCIA  text
*      -->P_P_TOTAL_ESC  text
*      -->P_P_FECHA_ROL  text
*      -->P_P_HORA_ROL  text
*      -->P_P_FECHA_BOB  text
*      -->P_P_HORA_BOB  text
*      -->P_P_SENTIDO  text
*      -->P_P_MIN_ESC  text
*----------------------------------------------------------------------*
FORM f_sec_ord_ascending  USING    p_escalon
                                   p_secuencia
                                   p_total_esc
                                   p_fecha_rol
                                   p_hora_rol
                                   p_fecha_bob
                                   p_hora_bob
                                   p_sentido
                                   p_min_esc.


  DATA: lv_escalon    TYPE i,
        ls_dat_rollo  TYPE zspp0026_linea_orden,
        ls_dat_bob    TYPE zspp0026_linea_orden,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp,
        lv_ok(1),
        ls_listado1   LIKE gt_listado1,
        lv_aufnr      TYPE aufnr,
        lv_seqnr      TYPE cy_seqnr,
        lv_sentido(1),
        lv_vueltas    TYPE zindice_prod.

  CLEAR: lv_escalon, ls_dat_rollo, ls_dat_bob, lv_index, lv_fecha_rol.
  CLEAR: lv_hora_rol, lv_fecha_bob, lv_hora_bob, lv_index_2.
  CLEAR: lv_sentido, lv_vueltas.
  lv_escalon = p_escalon.
  lv_fecha_rol = p_fecha_rol.
  lv_hora_rol = p_hora_rol.
  lv_fecha_bob = p_fecha_bob.
  lv_hora_bob = p_hora_bob.
  lv_sentido = p_sentido.

  " 1) SECUENCIACIÓN DE ÓRDENES DE ROLLO:

* Vamos a dar tantas vueltas, como puntos
* esté compuesta una vuelta entera:
  lv_vueltas = 2 * p_total_esc.

  DO lv_vueltas TIMES.
    LOOP AT gt_datos_rollos INTO ls_dat_rollo WHERE escalon = lv_escalon
                                              AND procesado <> 'X'.

      lv_index = sy-tabix.
      " Secuenciamos orden de rollo:
      CLEAR lv_ok.

      PERFORM f_resec_orden_rollo USING ls_dat_rollo
                                        p_secuencia
                                  CHANGING ls_dat_rollo-cy_seqnr
                                           lv_ok
                                           lv_fecha_rol
                                           lv_hora_rol.
      IF lv_ok = 'X'.
        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Actualizamos la tabla de las ordenes de bobina a secuenciar
        " para indicar la secuencia que le corresponde:
        CLEAR ls_dat_bob.
        LOOP AT gt_datos_bobinas INTO ls_dat_bob
             WHERE ( ( vbeln = ls_dat_rollo-vbeln
                     AND posnr = ls_dat_rollo-posnr )
             OR ( vbeln = ls_dat_rollo-vbeln2
                     AND posnr = ls_dat_rollo-posnr2 )
             OR ( vbeln = ls_dat_rollo-vbeln3
                     AND posnr = ls_dat_rollo-posnr3 ) ).
          lv_index_2 = sy-tabix.
          ls_dat_bob-cy_seqnr = ls_dat_rollo-cy_seqnr.
          MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index_2.
        ENDLOOP.
        " Pasamos a dar la siguiente secuencia:
        p_secuencia = p_secuencia + 1.

      ELSE.

        " Error en secuenciación de orden rollo:

        IF ls_dat_rollo-vbeln IS NOT INITIAL AND
           ls_dat_rollo-posnr IS NOT INITIAL AND
           ls_dat_rollo-kunnr IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln.
          ls_listado1-posnr = ls_dat_rollo-posnr.
          ls_listado1-etenr = ls_dat_rollo-etenr.
          ls_listado1-mbdat = ls_dat_rollo-mbdat.
          ls_listado1-kunnr = ls_dat_rollo-kunnr.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        IF ls_dat_rollo-vbeln2 IS NOT INITIAL AND
           ls_dat_rollo-posnr2 IS NOT INITIAL AND
           ls_dat_rollo-kunnr2 IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln2.
          ls_listado1-posnr = ls_dat_rollo-posnr2.
          ls_listado1-etenr = ls_dat_rollo-etenr.
          ls_listado1-mbdat = ls_dat_rollo-mbdat.
          ls_listado1-kunnr = ls_dat_rollo-kunnr2.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        IF ls_dat_rollo-vbeln3 IS NOT INITIAL AND
           ls_dat_rollo-posnr3 IS NOT INITIAL AND
           ls_dat_rollo-kunnr3 IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln3.
          ls_listado1-posnr = ls_dat_rollo-posnr3.
          ls_listado1-etenr = ls_dat_rollo-etenr.
          ls_listado1-mbdat = ls_dat_rollo-mbdat.
          ls_listado1-kunnr = ls_dat_rollo-kunnr3.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Error en secuenciación de orden bobina
        " y se borra de la tabla de bobinas:

        LOOP AT gt_datos_bobinas INTO ls_dat_bob
          WHERE ( ( vbeln = ls_dat_rollo-vbeln
                  AND posnr = ls_dat_rollo-posnr )
          OR ( vbeln = ls_dat_rollo-vbeln2
                  AND posnr = ls_dat_rollo-posnr2 )
          OR ( vbeln = ls_dat_rollo-vbeln3
                  AND posnr = ls_dat_rollo-posnr3 ) ).

          lv_index_2 = sy-tabix.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_bob-vbeln.
          ls_listado1-posnr = ls_dat_bob-posnr.
          ls_listado1-etenr = ls_dat_rollo-etenr.
          ls_listado1-mbdat = ls_dat_rollo-mbdat.
          ls_listado1-matnr = ls_dat_bob-matnr.
          ls_listado1-maktx = ls_dat_bob-maktx.
          ls_listado1-auart = gc_aufa_bob.
          ls_listado1-aufnr = ls_dat_bob-aufnr.
          ls_listado1-kunnr = ls_dat_bob-kunnr.
          ls_listado1-werks = ls_dat_bob-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-015.
          APPEND ls_listado1 TO gt_listado1.
          DELETE gt_datos_bobinas INDEX lv_index_2.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

    IF lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ELSE.
      lv_escalon = lv_escalon - 1.
    ENDIF.

    IF lv_sentido = 'A' AND  lv_escalon > p_total_esc.
      lv_sentido = 'D'.
      lv_escalon = lv_escalon - 1.
    ELSEIF lv_sentido = 'D' AND lv_escalon < p_min_esc.
      lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ENDIF.

  ENDDO.

  " 2) SECUENCIACIÓN DE ÓRDENES DE BOBINA:

  " 2.1. Miramos de la tabla de órdenes de
  " bobina las que no tienen secuencia
  " si corresponden a una orden de rollo ya liberada:
  " En ese caso se le da
  " la secuencia de la orden de rollo liberada,
  " pero se vuelve a secuenciar
  " se planifica con nuevas fechas.
  " Las que no encuentren correspondencia
  " se eliminan de la secuenciación,
  " pero se devuelve un error con todos
  " los datos posibles.

  CLEAR: ls_dat_bob, lv_index.
  LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE cy_seqnr IS INITIAL.
    lv_index = sy-tabix.
    CLEAR lv_aufnr.
    SELECT SINGLE aufnr INTO lv_aufnr
      FROM aufk
      WHERE ( ( zzebeln1 = ls_dat_bob-vbeln
              AND zzebelp1 = ls_dat_bob-posnr
              AND zzurgt1 = ls_dat_bob-etenr )
             OR  ( zzebeln2 = ls_dat_bob-vbeln
              AND zzebelp2 = ls_dat_bob-posnr
              AND zzurgt2 = ls_dat_bob-etenr )
             OR ( zzebeln3 = ls_dat_bob-vbeln
              AND zzebelp3 = ls_dat_bob-posnr
              AND zzurgt1 = ls_dat_bob-etenr ) )
      AND auart = gc_aufa_rol.
    IF lv_aufnr IS NOT INITIAL.
      CLEAR lv_seqnr.
      SELECT SINGLE cy_seqnr INTO lv_seqnr
        FROM afko
        WHERE aufnr = lv_aufnr.

      IF lv_seqnr IS NOT INITIAL.
        ls_dat_bob-cy_seqnr = lv_seqnr.
        MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index.
      ELSE.

        " Guardamos error y borramos registro:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_bob-vbeln.
        ls_listado1-posnr = ls_dat_bob-posnr.
        ls_listado1-etenr = ls_dat_bob-etenr.
        ls_listado1-mbdat = ls_dat_bob-mbdat.
        ls_listado1-matnr = ls_dat_bob-matnr.
        ls_listado1-maktx = ls_dat_bob-maktx.
        ls_listado1-auart = gc_aufa_bob.
        ls_listado1-aufnr = ls_dat_bob-aufnr.
        ls_listado1-kunnr = ls_dat_bob-kunnr.
        ls_listado1-werks = ls_dat_bob-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = text-015.
        APPEND ls_listado1 TO gt_listado1.

        DELETE gt_datos_bobinas INDEX lv_index.

      ENDIF.

    ELSE.
      " Guardamos error y borramos registro:
      CLEAR ls_listado1.
      ls_listado1-vbeln = ls_dat_bob-vbeln.
      ls_listado1-posnr = ls_dat_bob-posnr.
      ls_listado1-etenr = ls_dat_bob-etenr.
      ls_listado1-mbdat = ls_dat_bob-mbdat.
      ls_listado1-matnr = ls_dat_bob-matnr.
      ls_listado1-maktx = ls_dat_bob-maktx.
      ls_listado1-auart = gc_aufa_bob.
      ls_listado1-kunnr = ls_dat_bob-kunnr.
      ls_listado1-werks = ls_dat_bob-werks.
      ls_listado1-aufnr = ls_dat_bob-aufnr.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      ls_listado1-msg_ret = text-015.
      APPEND ls_listado1 TO gt_listado1.

      DELETE gt_datos_bobinas INDEX lv_index.
    ENDIF.

  ENDLOOP.

  " 2.2. Ordenamos la tabla de órdenes de bobina a secuenciar en base a
  " secuencia, fecha de entrega, pedido y posición:

  SORT gt_datos_bobinas BY cy_seqnr ASCENDING
                           mbdat ASCENDING
                           vbeln ASCENDING
                           posnr ASCENDING
                           etenr ASCENDING.

  LOOP AT gt_datos_bobinas INTO ls_dat_bob.
    PERFORM f_resec_orden_bob USING ls_dat_bob
                            CHANGING lv_fecha_bob
                                     lv_hora_bob.
  ENDLOOP.


ENDFORM.                    " F_SEC_ORD_ASCENDING
*&---------------------------------------------------------------------*
*&      Form  F_SEC_ORDEN_DESCENDING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_ESCALON  text
*      -->P_P_SECUENCIA  text
*      -->P_P_TOTAL_ESC  text
*      -->P_P_FECHA_ROL  text
*      -->P_P_HORA_ROL  text
*      -->P_P_FECHA_BOB  text
*      -->P_P_HORA_BOB  text
*      -->P_P_SENTIDO  text
*      -->P_P_MIN_ESC  text
*----------------------------------------------------------------------*
FORM f_sec_orden_descending  USING    p_escalon
                                      p_secuencia
                                      p_total_esc
                                      p_fecha_rol
                                      p_hora_rol
                                      p_fecha_bob
                                      p_hora_bob
                                      p_sentido
                                      p_min_esc.

  DATA: lv_escalon    TYPE i,
        ls_dat_rollo  TYPE zspp0026_linea_orden,
        ls_dat_bob    TYPE zspp0026_linea_orden,
        lv_index      LIKE sy-tabix,
        lv_index_2    LIKE sy-tabix,
        lv_fecha_rol  TYPE co_gltrp,
        lv_hora_rol   TYPE co_gluzp,
        lv_fecha_bob  TYPE co_gltrp,
        lv_hora_bob   TYPE co_gluzp,
        lv_ok(1),
        ls_listado1   LIKE gt_listado1,
        lv_aufnr      TYPE aufnr,
        lv_seqnr      TYPE cy_seqnr,
        lv_sentido(1),
        lv_vueltas    TYPE zindice_prod.

  CLEAR: lv_escalon, ls_dat_rollo, ls_dat_bob, lv_index, lv_fecha_rol.
  CLEAR: lv_hora_rol, lv_fecha_bob, lv_hora_bob, lv_index_2.
  CLEAR: lv_sentido, lv_vueltas.
  lv_escalon = p_escalon.
  lv_fecha_rol = p_fecha_rol.
  lv_hora_rol = p_hora_rol.
  lv_fecha_bob = p_fecha_bob.
  lv_hora_bob = p_hora_bob.
  lv_sentido = p_sentido.

  " 1) SECUENCIACIÓN DE ÓRDENES DE ROLLO:

* Vamos a dar tantas vueltas, como puntos
* esté compuesta una vuelta entera:
  lv_vueltas = 2 * p_total_esc.

  DO lv_vueltas TIMES.
    LOOP AT gt_datos_rollos INTO ls_dat_rollo
         WHERE escalon = lv_escalon
         AND procesado <> 'X'.

      lv_index = sy-tabix.
      " Secuenciamos orden de rollo:
      CLEAR lv_ok.
      PERFORM f_resec_orden_rollo USING ls_dat_rollo
                                        p_secuencia
                                  CHANGING ls_dat_rollo-cy_seqnr
                                           lv_ok
                                           lv_fecha_rol
                                           lv_hora_rol.

      IF lv_ok = 'X'.
        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Actualizamos la tabla de las ordenes de bobina a secuenciar
        " para indicar la secuencia que le corresponde:

        CLEAR ls_dat_bob.
        LOOP AT gt_datos_bobinas INTO ls_dat_bob
             WHERE ( ( vbeln = ls_dat_rollo-vbeln
                      AND posnr = ls_dat_rollo-posnr )
                  OR ( vbeln = ls_dat_rollo-vbeln2
                      AND posnr = ls_dat_rollo-posnr2 )
                  OR ( vbeln = ls_dat_rollo-vbeln3
                      AND posnr = ls_dat_rollo-posnr3 ) ).
          lv_index_2 = sy-tabix.
          ls_dat_bob-cy_seqnr = ls_dat_rollo-cy_seqnr.
          MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index_2.
        ENDLOOP.
        " Pasamos a dar la siguiente secuencia:
        p_secuencia = p_secuencia + 1.
      ELSE.

        " Error en secuenciación de orden rollo:
        IF ls_dat_rollo-vbeln IS NOT INITIAL AND
           ls_dat_rollo-posnr IS NOT INITIAL AND
           ls_dat_rollo-kunnr IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln.
          ls_listado1-posnr = ls_dat_rollo-posnr.
          ls_listado1-kunnr = ls_dat_rollo-kunnr.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        IF ls_dat_rollo-vbeln2 IS NOT INITIAL AND
           ls_dat_rollo-posnr2 IS NOT INITIAL AND
           ls_dat_rollo-kunnr2 IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln2.
          ls_listado1-posnr = ls_dat_rollo-posnr2.
          ls_listado1-kunnr = ls_dat_rollo-kunnr2.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        IF ls_dat_rollo-vbeln3 IS NOT INITIAL AND
           ls_dat_rollo-posnr3 IS NOT INITIAL AND
           ls_dat_rollo-kunnr3 IS NOT INITIAL.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_rollo-vbeln3.
          ls_listado1-posnr = ls_dat_rollo-posnr3.
          ls_listado1-kunnr = ls_dat_rollo-kunnr3.
          ls_listado1-matnr = ls_dat_rollo-matnr.
          ls_listado1-maktx = ls_dat_rollo-maktx.
          ls_listado1-auart = gc_aufa_rol.
          ls_listado1-aufnr = ls_dat_rollo-aufnr.
          ls_listado1-werks = ls_dat_rollo-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-014.
          APPEND ls_listado1 TO gt_listado1.
        ENDIF.

        ls_dat_rollo-procesado = 'X'.
        MODIFY gt_datos_rollos FROM ls_dat_rollo INDEX lv_index.

        " Error en secuenciación de orden bobina y se borra de la
        " tabla de bobinas:
        LOOP AT gt_datos_bobinas INTO ls_dat_bob
             WHERE ( ( vbeln = ls_dat_rollo-vbeln
                       AND posnr = ls_dat_rollo-posnr )
                    OR ( vbeln = ls_dat_rollo-vbeln2
                       AND posnr = ls_dat_rollo-posnr2 )
                    OR ( vbeln = ls_dat_rollo-vbeln3
                       AND posnr = ls_dat_rollo-posnr3 ) ).
          lv_index_2 = sy-tabix.
          CLEAR ls_listado1.
          ls_listado1-vbeln = ls_dat_bob-vbeln.
          ls_listado1-posnr = ls_dat_bob-posnr.
          ls_listado1-matnr = ls_dat_bob-matnr.
          ls_listado1-maktx = ls_dat_bob-maktx.
          ls_listado1-auart = gc_aufa_bob.
          ls_listado1-aufnr = ls_dat_bob-aufnr.
          ls_listado1-kunnr = ls_dat_bob-kunnr.
          ls_listado1-werks = ls_dat_bob-werks.
          ls_listado1-icon = '@0A@'. " Semaforito rojo
          ls_listado1-tipo = 'S'.
          ls_listado1-type_ret = 'E'.
          ls_listado1-msg_ret = text-015.
          APPEND ls_listado1 TO gt_listado1.
          DELETE gt_datos_bobinas INDEX lv_index_2.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

    IF lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ELSE.
      lv_escalon = lv_escalon - 1.
    ENDIF.

    IF lv_sentido = 'A' AND  lv_escalon > p_total_esc.
      lv_sentido = 'D'.
      lv_escalon = lv_escalon - 1.
    ELSEIF lv_sentido = 'D' AND lv_escalon < p_min_esc.
      lv_sentido = 'A'.
      lv_escalon = lv_escalon + 1.
    ENDIF.

  ENDDO.


  " 2) SECUENCIACIÓN DE ÓRDENES DE BOBINA:

  " 2.1. Miramos de la tabla de órdenes de
  " bobina las que no tienen secuencia
  " si corresponden a una orden de rollo ya liberada:
  " En ese caso se le da
  " la secuencia de la orden de rollo liberada,
  " pero se vuelve a secuenciar
  " se planifica con nuevas fechas.
  " Las que no encuentren correspondencia
  " se eliminan de la secuenciación,
  " pero se devuelve un error con todos
  " los datos posibles.

  CLEAR: ls_dat_bob, lv_index.
  LOOP AT gt_datos_bobinas INTO ls_dat_bob WHERE cy_seqnr IS INITIAL.
    lv_index = sy-tabix.
    CLEAR lv_aufnr.
    SELECT SINGLE aufnr INTO lv_aufnr
      FROM aufk
      WHERE ( ( zzebeln1 = ls_dat_bob-vbeln
                AND zzebelp1 = ls_dat_bob-posnr )
              OR ( zzebeln2 = ls_dat_bob-vbeln
                AND zzebelp2 = ls_dat_bob-posnr )
              OR ( zzebeln3 = ls_dat_bob-vbeln
                AND zzebelp3 = ls_dat_bob-posnr ) )
      AND auart = gc_aufa_rol.
    IF lv_aufnr IS NOT INITIAL.
      CLEAR lv_seqnr.
      SELECT SINGLE cy_seqnr INTO lv_seqnr
        FROM afko
        WHERE aufnr = lv_aufnr.

      IF lv_seqnr IS NOT INITIAL.
        ls_dat_bob-cy_seqnr = lv_seqnr.
        MODIFY gt_datos_bobinas FROM ls_dat_bob INDEX lv_index.
      ELSE.

        " Guardamos error y borramos registro:
        CLEAR ls_listado1.
        ls_listado1-vbeln = ls_dat_bob-vbeln.
        ls_listado1-posnr = ls_dat_bob-posnr.
        ls_listado1-matnr = ls_dat_bob-matnr.
        ls_listado1-maktx = ls_dat_bob-maktx.
        ls_listado1-auart = gc_aufa_bob.
        ls_listado1-aufnr = ls_dat_bob-aufnr.
        ls_listado1-kunnr = ls_dat_bob-kunnr.
        ls_listado1-werks = ls_dat_bob-werks.
        ls_listado1-icon = '@0A@'. " Semaforito rojo
        ls_listado1-tipo = 'S'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-msg_ret = text-015.
        APPEND ls_listado1 TO gt_listado1.

        DELETE gt_datos_bobinas INDEX lv_index.

      ENDIF.

    ELSE.
      " Guardamos error y borramos registro:
      CLEAR ls_listado1.
      ls_listado1-vbeln = ls_dat_bob-vbeln.
      ls_listado1-posnr = ls_dat_bob-posnr.
      ls_listado1-matnr = ls_dat_bob-matnr.
      ls_listado1-maktx = ls_dat_bob-maktx.
      ls_listado1-auart = gc_aufa_bob.
      ls_listado1-kunnr = ls_dat_bob-kunnr.
      ls_listado1-werks = ls_dat_bob-werks.
      ls_listado1-aufnr = ls_dat_bob-aufnr.
      ls_listado1-icon = '@0A@'. " Semaforito rojo
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      ls_listado1-msg_ret = text-015.
      APPEND ls_listado1 TO gt_listado1.

      DELETE gt_datos_bobinas INDEX lv_index.
    ENDIF.

  ENDLOOP.

  " 2.2. Ordenamos la tabla de órdenes de bobina a secuenciar en base a
  " secuencia, fecha de entrega, pedido y posición:

  SORT gt_datos_bobinas BY cy_seqnr ASCENDING
                           mbdat ASCENDING
                           vbeln ASCENDING
                           posnr ASCENDING.

  LOOP AT gt_datos_bobinas INTO ls_dat_bob.
    PERFORM f_resec_orden_bob USING ls_dat_bob
                            CHANGING lv_fecha_bob
                                     lv_hora_bob.
  ENDLOOP.

ENDFORM.                    " F_SEC_ORDEN_DESCENDING
*&---------------------------------------------------------------------*
*&      Form  F_RESEC_ORDEN_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DAT_ROLLO  text
*      -->P_P_SECUENCIA  text
*      <--P_LS_DAT_ROLLO_CY_SEQNR  text
*      <--P_LV_OK  text
*      <--P_LV_FECHA_ROL  text
*      <--P_LV_HORA_ROL  text
*----------------------------------------------------------------------*
FORM f_resec_orden_rollo  USING ps_dat_rollo TYPE zspp0026_linea_orden
                                p_secuencia
                          CHANGING p_cy_seqnr
                                   p_ok
                                   p_fecha_rol
                                   p_hora_rol.

  DATA: ls_orderdata  TYPE bapi_pi_order_change,
        ls_orderdatax TYPE bapi_pi_order_changex,
        lt_return     TYPE bapiret2_tab,
        ls_return     TYPE bapiret2,
        ls_listado1   LIKE gt_listado1.
  DATA: ls_selec TYPE zspp0026_alv.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_orderdatax, lt_return, ls_return, p_ok.
  REFRESH: lt_return.

  " Datos a modificar:
  ls_orderdata-sequence_number = p_secuencia.
  ls_orderdata-basic_start_date = p_fecha_rol.
  ls_orderdata-basic_start_time = p_hora_rol.


  ls_orderdatax-sequence_number = 'X'.
  ls_orderdatax-basic_start_date = 'X'.
  ls_orderdatax-basic_end_date = 'X'.

  CALL FUNCTION 'BAPI_PROCORD_CHANGE'
    EXPORTING
      number     = ps_dat_rollo-aufnr
      orderdata  = ls_orderdata
      orderdatax = ls_orderdatax
    IMPORTING
      return     = ls_return.

  IF ls_return-type = 'E'.

    IF ps_dat_rollo-vbeln IS NOT INITIAL
      AND ps_dat_rollo-posnr IS NOT INITIAL
      AND ps_dat_rollo-kunnr IS NOT INITIAL.

      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_rollo-vbeln.
      ls_listado1-posnr = ps_dat_rollo-posnr.
      ls_listado1-kunnr = ps_dat_rollo-kunnr.
      ls_listado1-matnr = ps_dat_rollo-matnr.
      ls_listado1-maktx = ps_dat_rollo-maktx.
      ls_listado1-auart = gc_aufa_rol.
      ls_listado1-aufnr = ps_dat_rollo-aufnr.
      ls_listado1-werks = ps_dat_rollo-werks.
      ls_listado1-cy_seqnr = p_secuencia.
      ls_listado1-icon = '@0A@'.
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = ls_return-type.
      ls_listado1-msg_ret = ls_return-message.
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.


    IF ps_dat_rollo-vbeln2 IS NOT INITIAL
      AND ps_dat_rollo-posnr2 IS NOT INITIAL
       AND ps_dat_rollo-kunnr2 IS NOT INITIAL.

      CLEAR ls_listado1.

      ls_listado1-vbeln = ps_dat_rollo-vbeln2.
      ls_listado1-posnr = ps_dat_rollo-posnr2.
      ls_listado1-kunnr = ps_dat_rollo-kunnr2.
      ls_listado1-matnr = ps_dat_rollo-matnr.
      ls_listado1-maktx = ps_dat_rollo-maktx.
      ls_listado1-auart = gc_aufa_rol.
      ls_listado1-aufnr = ps_dat_rollo-aufnr.
      ls_listado1-werks = ps_dat_rollo-werks.
      ls_listado1-cy_seqnr = p_secuencia.
      ls_listado1-icon = '@0A@'.
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = ls_return-type.
      ls_listado1-msg_ret = ls_return-message.
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.

    IF ps_dat_rollo-vbeln3 IS NOT INITIAL
      AND ps_dat_rollo-posnr3 IS NOT INITIAL
       AND ps_dat_rollo-kunnr3 IS NOT INITIAL.

      ls_listado1-vbeln = ps_dat_rollo-vbeln3.
      ls_listado1-posnr = ps_dat_rollo-posnr3.
      ls_listado1-kunnr = ps_dat_rollo-kunnr3.
      ls_listado1-matnr = ps_dat_rollo-matnr.
      ls_listado1-maktx = ps_dat_rollo-maktx.
      ls_listado1-auart = gc_aufa_rol.
      ls_listado1-aufnr = ps_dat_rollo-aufnr.
      ls_listado1-werks = ps_dat_rollo-werks.
      ls_listado1-cy_seqnr = p_secuencia.
      ls_listado1-icon = '@0A@'.
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = ls_return-type.
      ls_listado1-msg_ret = ls_return-message.
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.

  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
    p_ok = 'X'.
    p_cy_seqnr = p_secuencia.
    WAIT UP TO 1 SECONDS.

    PERFORM f_calc_fec_hora USING  ps_dat_rollo-aufnr
                                   ps_dat_rollo-werks
                          CHANGING p_fecha_rol
                                   p_hora_rol.

    "Hacemos EXPORT a memoria con la orden para no
    " tener problemas con el batch input y
    "los campos que se sombrean en pantalla en la COR2.

    EXPORT  gv_order_number FROM ps_dat_rollo-aufnr
            TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:

    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  ps_dat_rollo-aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZSECUENCIA'.
    PERFORM bdc_field       USING 'AUFK-ZZSECUENCIA'
                                  p_secuencia.

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.
      p_ok = 'X'.
      p_cy_seqnr = p_secuencia.

      IF ps_dat_rollo-vbeln IS NOT INITIAL
        AND ps_dat_rollo-posnr IS NOT INITIAL
        AND ps_dat_rollo-kunnr IS NOT INITIAL.

        CLEAR: ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln.
        ls_listado1-posnr = ps_dat_rollo-posnr.
        ls_listado1-kunnr = ps_dat_rollo-kunnr.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@0A@'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-tipo = 'S'.
        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.

      IF ps_dat_rollo-vbeln2 IS NOT INITIAL
        AND ps_dat_rollo-posnr2 IS NOT INITIAL
        AND ps_dat_rollo-kunnr2 IS NOT INITIAL.

        CLEAR: ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln2.
        ls_listado1-posnr = ps_dat_rollo-posnr2.
        ls_listado1-kunnr = ps_dat_rollo-kunnr2.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@0A@'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-tipo = 'S'.
        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.

      IF ps_dat_rollo-vbeln3 IS NOT INITIAL
        AND ps_dat_rollo-posnr3 IS NOT INITIAL
        AND ps_dat_rollo-kunnr3 IS NOT INITIAL.

        CLEAR: ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln3.
        ls_listado1-posnr = ps_dat_rollo-posnr3.
        ls_listado1-kunnr = ps_dat_rollo-kunnr3.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@0A@'.
        ls_listado1-type_ret = 'E'.
        ls_listado1-tipo = 'S'.
        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.
        APPEND ls_listado1 TO gt_listado1.
      ENDIF.

    ELSE.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      p_ok = 'X'.
      p_cy_seqnr = p_secuencia.

      IF ps_dat_rollo-vbeln IS NOT INITIAL
        AND ps_dat_rollo-posnr IS NOT INITIAL
        AND ps_dat_rollo-kunnr IS NOT INITIAL.

        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln.
        ls_listado1-posnr = ps_dat_rollo-posnr.
        ls_listado1-kunnr = ps_dat_rollo-kunnr.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@08@'. " Semaforito verde
        ls_listado1-tipo = 'S'.
        APPEND ls_listado1 TO gt_listado1.

      ENDIF.

      IF ps_dat_rollo-vbeln2 IS NOT INITIAL
        AND ps_dat_rollo-posnr2 IS NOT INITIAL
        AND ps_dat_rollo-kunnr2 IS NOT INITIAL.

        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln2.
        ls_listado1-posnr = ps_dat_rollo-posnr2.
        ls_listado1-kunnr = ps_dat_rollo-kunnr2.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@08@'. " Semaforito verde
        ls_listado1-tipo = 'S'.
        APPEND ls_listado1 TO gt_listado1.

      ENDIF.

      IF ps_dat_rollo-vbeln3 IS NOT INITIAL
        AND ps_dat_rollo-posnr3 IS NOT INITIAL
        AND ps_dat_rollo-kunnr3 IS NOT INITIAL.

        CLEAR ls_listado1.
        ls_listado1-vbeln = ps_dat_rollo-vbeln3.
        ls_listado1-posnr = ps_dat_rollo-posnr3.
        ls_listado1-kunnr = ps_dat_rollo-kunnr3.
        ls_listado1-matnr = ps_dat_rollo-matnr.
        ls_listado1-maktx = ps_dat_rollo-maktx.
        ls_listado1-auart = gc_aufa_rol.
        ls_listado1-aufnr = ps_dat_rollo-aufnr.
        ls_listado1-werks = ps_dat_rollo-werks.
        ls_listado1-cy_seqnr = p_secuencia.
        ls_listado1-icon = '@08@'. " Semaforito verde
        ls_listado1-tipo = 'S'.
        APPEND ls_listado1 TO gt_listado1.

      ENDIF.

    ENDIF.

  ENDIF.

ENDFORM.                    " F_RESEC_ORDEN_ROLLO
*&---------------------------------------------------------------------*
*&      Form  F_CALC_FEC_HORA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_DAT_ROLLO_AUFNR  text
*      -->P_PS_DAT_ROLLO_WERKS  text
*      <--P_P_FECHA_ROL  text
*      <--P_P_HORA_ROL  text
*----------------------------------------------------------------------*
FORM f_calc_fec_hora  USING    p_aufnr
                               p_werks
                      CHANGING p_fecha
                               p_hora.

  DATA: lv_gltrp TYPE co_gltrp,
        lv_gluzp TYPE co_gluzp,
        lv_fabkl TYPE fabkl,
        lv_hora  TYPE co_gluzp,
        lv_fecha TYPE co_gltrp.

  CLEAR: lv_gltrp, lv_gluzp, lv_fabkl, lv_hora, lv_fecha.

  " Sacamos la fecha y hora fin extrema:

  SELECT SINGLE gltrp gluzp INTO (lv_gltrp, lv_gluzp)
    FROM caufv
    WHERE aufnr = p_aufnr.

  " Sacamos el calendario de fábrica:
  SELECT SINGLE fabkl INTO lv_fabkl
    FROM t001w
    WHERE werks = p_werks.
  IF lv_fabkl IS INITIAL.
    lv_fabkl = 'ES'.
  ENDIF.

  " Cálculamos la siguiente fecha y hora de inicio disponibles:
  IF lv_fabkl IS NOT INITIAL.
    lv_hora = lv_gluzp + 1.
    IF lv_hora = '000001'.
      lv_fecha = lv_gltrp + 1.
      CALL FUNCTION 'BKK_GET_NEXT_WORKDAY'
        EXPORTING
          i_date         = lv_fecha
          i_calendar1    = lv_fabkl
*         I_CALENDAR2    =
        IMPORTING
          e_workday      = lv_fecha
        EXCEPTIONS
          calendar_error = 1
          OTHERS         = 2.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ENDIF.
    ELSE.
      lv_fecha = lv_gltrp.
    ENDIF.
  ELSE.
    lv_hora = lv_gluzp + 1.
    IF lv_hora = '000001'.
      lv_fecha = lv_gltrp + 1.
    ELSE.
      lv_fecha = lv_gltrp.
    ENDIF.
  ENDIF.

  " Pasamos los valores obtenidos a los parámetros:
  p_fecha = lv_fecha.
  p_hora = lv_hora.

ENDFORM.                    " F_CALC_FEC_HORA
*&---------------------------------------------------------------------*
*&      Form  F_RESEC_ORDEN_BOB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_DAT_BOB  text
*      <--P_LV_FECHA_BOB  text
*      <--P_LV_HORA_BOB  text
*----------------------------------------------------------------------*
FORM f_resec_orden_bob  USING    ps_dat_bob TYPE zspp0026_linea_orden
                        CHANGING p_fecha_bob
                                 p_hora_bob.

  DATA: ls_orderdata  TYPE bapi_pi_order_change,
        ls_orderdatax TYPE bapi_pi_order_changex,
        lt_return     TYPE bapiret2_tab,
        ls_return     TYPE bapiret2,
        ls_listado1   LIKE gt_listado1.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_orderdatax, lt_return, ls_return.
  REFRESH: lt_return.

  " Datos a modificar:
  ls_orderdata-sequence_number = ps_dat_bob-cy_seqnr.
  ls_orderdata-basic_start_date = p_fecha_bob.
  ls_orderdata-basic_start_time = p_hora_bob.

  ls_orderdatax-sequence_number = 'X'.
  ls_orderdatax-basic_start_date = 'X'.
  ls_orderdatax-basic_end_date = 'X'.

  CALL FUNCTION 'BAPI_PROCORD_CHANGE'
    EXPORTING
      number     = ps_dat_bob-aufnr
      orderdata  = ls_orderdata
      orderdatax = ls_orderdatax
    IMPORTING
      return     = ls_return.
*   ORDER_TYPE             =
*   ORDER_STATUS           =
*   MASTER_DATA_READ       =

  IF ls_return-type = 'E'.
    CLEAR ls_listado1.
    ls_listado1-vbeln = ps_dat_bob-vbeln.
    ls_listado1-posnr = ps_dat_bob-posnr.
    ls_listado1-etenr = ps_dat_bob-etenr.
    ls_listado1-mbdat = ps_dat_bob-mbdat.
    ls_listado1-matnr = ps_dat_bob-matnr.
    ls_listado1-maktx = ps_dat_bob-maktx.
    ls_listado1-auart = gc_aufa_bob.
    ls_listado1-aufnr = ps_dat_bob-aufnr.
    ls_listado1-kunnr = ps_dat_bob-kunnr.
    ls_listado1-werks = ps_dat_bob-werks.
    ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
    ls_listado1-icon = '@0A@'.
    ls_listado1-tipo = 'S'.
    ls_listado1-type_ret = ls_return-type.
    ls_listado1-msg_ret = ls_return-message.
    APPEND ls_listado1 TO gt_listado1.

  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
    WAIT UP TO 1 SECONDS.

    PERFORM f_calc_fec_hora USING  ps_dat_bob-aufnr
                                   ps_dat_bob-werks
                          CHANGING p_fecha_bob
                                   p_hora_bob.

    " Hacemos EXPORT a memoria con la orden para
    " no tener problemas con el batch input y
    " los campos que se sombrean en pantalla en la COR2.
    EXPORT  gv_order_number FROM ps_dat_bob-aufnr TO MEMORY ID 'ORDER'.

    " Ahora hacemos el batch-input para modificar campos de cliente:
    REFRESH bdcdata.
    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-AUFNR'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '/00'.
    PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                  ps_dat_bob-aufnr.
    PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                  'X'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=+COI'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'CAUFVD-GAMNG'.

    PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
    PERFORM bdc_field       USING 'BDC_OKCODE'
                                  '=BU'.

    PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZSECUENCIA'.
    PERFORM bdc_field       USING 'AUFK-ZZSECUENCIA'
                                  ps_dat_bob-cy_seqnr.

    CLEAR: i_messtab.
    REFRESH: i_messtab.

    CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                            MESSAGES INTO i_messtab
                            UPDATE 'S'.

    IF sy-subrc <> 0.

      CLEAR ls_messtab.

      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_bob-vbeln.
      ls_listado1-posnr = ps_dat_bob-posnr.
      ls_listado1-etenr = ps_dat_bob-etenr.
      ls_listado1-mbdat = ps_dat_bob-mbdat.
      ls_listado1-matnr = ps_dat_bob-matnr.
      ls_listado1-maktx = ps_dat_bob-maktx.
      ls_listado1-auart = gc_aufa_bob.
      ls_listado1-aufnr = ps_dat_bob-aufnr.
      ls_listado1-kunnr = ps_dat_bob-kunnr.
      ls_listado1-werks = ps_dat_bob-werks.
      ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
      ls_listado1-icon = '@0A@'.
      ls_listado1-tipo = 'S'.
      ls_listado1-type_ret = 'E'.
      PERFORM mensajes_error
        TABLES i_messtab
        CHANGING ls_listado1-msg_ret.
      APPEND ls_listado1 TO gt_listado1.
    ELSE.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
      CLEAR ls_listado1.
      ls_listado1-vbeln = ps_dat_bob-vbeln.
      ls_listado1-posnr = ps_dat_bob-posnr.
      ls_listado1-etenr = ps_dat_bob-etenr.
      ls_listado1-mbdat = ps_dat_bob-mbdat.
      ls_listado1-matnr = ps_dat_bob-matnr.
      ls_listado1-maktx = ps_dat_bob-maktx.
      ls_listado1-auart = gc_aufa_bob.
      ls_listado1-aufnr = ps_dat_bob-aufnr.
      ls_listado1-kunnr = ps_dat_bob-kunnr.
      ls_listado1-werks = ps_dat_bob-werks.
      ls_listado1-cy_seqnr = ps_dat_bob-cy_seqnr.
      ls_listado1-tipo = 'S'.
      ls_listado1-icon = '@08@'. " Semaforito verde
      APPEND ls_listado1 TO gt_listado1.

    ENDIF.

  ENDIF.

ENDFORM.                    " F_RESEC_ORDEN_BOB
*&---------------------------------------------------------------------*
*&      Form  LINEAS_MARCADAS_DESAGRUPAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM lineas_marcadas_desagrupar  CHANGING pv_error.

  DATA: lti_rows     TYPE lvc_t_roid,
        ls_row       TYPE lvc_s_roid,
        ls_alv       TYPE zspp0026_alv,
        lv_lines     TYPE i,
        ls_agrup     TYPE ty_agrup,
        ls_agrup_max TYPE ty_agrup.

  DATA: pv_error2 TYPE xfeld,
        pv_error3 TYPE xfeld,
        pv_error5 TYPE xfeld.

  CLEAR: gt_selec. REFRESH: gt_selec.
  CLEAR: gt_agrup. REFRESH: gt_agrup.
  CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* Si sólo hay una línea marcada -> ERROR
  IF lv_lines = 1.
    pv_error = 'X'.
    MESSAGE w078(zpp).
    EXIT.
  ENDIF.

* Verificamos que están en una agrupación
* Verificamos que las líneas no estén procesadas
* Verificamos que no tengan ni orden de rollo, ni de bobina
* creadas

  CLEAR: pv_error2, pv_error3, pv_error5.
  LOOP AT lti_rows INTO ls_row.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv-agru_bob IS INITIAL.
      CLEAR: gt_selec. REFRESH: gt_selec.
      CLEAR: gt_agrup. REFRESH: gt_agrup.
      CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
      pv_error = 'X'.
      EXIT.
    ELSEIF ls_alv-procesado = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      CLEAR: gt_agrup. REFRESH: gt_agrup.
      CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
      pv_error2 = 'X'.
      EXIT.
    ELSEIF ls_alv-aufnr_bob IS NOT INITIAL
           OR ls_alv-aufnr_rol IS NOT INITIAL.
      CLEAR gt_selec. REFRESH: gt_selec.
      CLEAR: gt_agrup. REFRESH: gt_agrup.
      CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
      pv_error3 = 'X'.
      EXIT.
    ELSEIF ls_alv-cambio_rollo_flag = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      CLEAR: gt_agrup. REFRESH: gt_agrup.
      CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
      pv_error5 = 'X'.
      EXIT.
    ELSE.
      APPEND ls_alv TO gt_selec.
      IF ls_alv-ancho_max_flag <> 'X'.
        CLEAR ls_agrup.
        ls_agrup-agru_bob = ls_alv-agru_bob.
        COLLECT ls_agrup INTO gt_agrup.
      ELSE.
        CLEAR ls_agrup_max.
        ls_agrup_max-agru_bob = ls_alv-agru_bob.
        COLLECT ls_agrup_max INTO gt_agrup_max.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF pv_error = 'X'.
    MESSAGE w102(zpp).
    EXIT.
  ELSEIF pv_error2 = 'X'.
    pv_error = 'X'.
    MESSAGE w083(zpp).
    EXIT.
  ELSEIF pv_error3 = 'X'.
    pv_error = 'X'.
    MESSAGE w084(zpp).
    EXIT.
  ELSEIF pv_error5 = 'X'.
    pv_error = 'X'.
    MESSAGE w109(zpp).
    EXIT.
  ENDIF.

* Verificar que se han marcado todas las líneas de la agrupación:
  LOOP AT gt_agrup INTO ls_agrup.
    LOOP AT gt_alv INTO ls_alv WHERE agru_bob = ls_agrup-agru_bob.
      READ TABLE gt_selec TRANSPORTING NO FIELDS
                          WITH KEY vbeln = ls_alv-vbeln
                                   posnr = ls_alv-posnr
                                   etenr = ls_alv-etenr.
      IF sy-subrc NE 0.
        pv_error = 'X'.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF pv_error = 'X'.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF pv_error = 'X'.
    CLEAR gt_selec. REFRESH: gt_selec.
    CLEAR: gt_agrup. REFRESH: gt_agrup.
    CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
    MESSAGE w076(zpp).
    EXIT.
  ENDIF.

  LOOP AT gt_agrup_max INTO ls_agrup_max.
    LOOP AT gt_alv INTO ls_alv WHERE agru_bob = ls_agrup_max-agru_bob
                               AND ancho_max_flag = 'X'.
      READ TABLE gt_selec TRANSPORTING NO FIELDS
                          WITH KEY vbeln = ls_alv-vbeln
                                   posnr = ls_alv-posnr
                                   etenr = ls_alv-etenr
                                   num_cabo = ls_alv-num_cabo.
      IF sy-subrc NE 0.
        pv_error = 'X'.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDLOOP.
  IF pv_error = 'X'.
    CLEAR gt_selec. REFRESH: gt_selec.
    CLEAR: gt_agrup. REFRESH: gt_agrup.
    CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
    MESSAGE w076(zpp).
    EXIT.
  ENDIF.


ENDFORM.                    " LINEAS_MARCADAS_DESAGRUPAR
*&---------------------------------------------------------------------*
*&      Form  DESAGRUPAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM desagrupar .


  DATA: ls_alv       TYPE zspp0026_alv,
        ls_selec     TYPE zspp0026_alv,
        ls_agrup     TYPE ty_agrup,
        ls_agrup_max TYPE ty_agrup,
        lv_ind       TYPE i,
        lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho.


  " Desagrupar órdenes normales:
  LOOP AT gt_agrup INTO ls_agrup.
    LOOP AT gt_selec INTO ls_selec WHERE agru_bob = ls_agrup-agru_bob
                                   AND ancho_max_flag <> 'X'.

      CLEAR ls_alv.
      READ TABLE gt_alv INTO ls_alv WITH KEY vbeln = ls_selec-vbeln
                                             posnr = ls_selec-posnr
                                             etenr = ls_selec-etenr.
      lv_ind = sy-tabix.
      IF ls_alv IS NOT INITIAL.
        CLEAR: ls_alv-agru_bob, ls_alv-cant_rol_agrup.
        CLEAR: ls_alv-mate_rol_agrup, ls_alv-desc_rol_agrup.
        CLEAR: ls_alv-anch_rol_agrup.

        CLEAR: lv_zzgramaje, lv_zzancho.
        SELECT SINGLE zzgramaje zzancho
               INTO (lv_zzgramaje, lv_zzancho)
               FROM mara
               WHERE matnr = ls_alv-mate_rol.

        ls_alv-gram_rol = lv_zzgramaje.
        ls_alv-anch_rol = lv_zzancho.
        MODIFY gt_alv FROM ls_alv INDEX lv_ind.

      ENDIF.
    ENDLOOP.
  ENDLOOP.

  " Desagrupar órdenes de ancho máximo:
  LOOP AT gt_agrup_max INTO ls_agrup_max.
    LOOP AT gt_selec INTO ls_selec
          WHERE agru_bob = ls_agrup_max-agru_bob
          AND ancho_max_flag = 'X'.

      CLEAR ls_alv.
      READ TABLE gt_alv INTO ls_alv
                 WITH KEY agru_bob = ls_selec-agru_bob
                          ancho_max_flag = 'X'
                          num_cabo = ls_selec-num_cabo.
      lv_ind = sy-tabix.
      IF ls_alv IS NOT INITIAL.
        IF ls_alv-vbeln IS INITIAL AND ls_alv-posnr IS INITIAL.
          DELETE gt_alv INDEX lv_ind.
        ELSE.
          CLEAR: ls_alv-agru_bob, ls_alv-ancho_max_flag.
          CLEAR: ls_alv-cant_rol_agrup, ls_alv-mate_rol_agrup.
          CLEAR: ls_alv-desc_rol_agrup, ls_alv-anch_rol_agrup.
          CLEAR: ls_alv-num_cabo.

          CLEAR: lv_zzgramaje, lv_zzancho.
          SELECT SINGLE zzgramaje zzancho
            INTO (lv_zzgramaje, lv_zzancho)
            FROM mara
            WHERE matnr = ls_alv-mate_rol.
          ls_alv-gram_rol = lv_zzgramaje.
          ls_alv-anch_rol = lv_zzancho.

          MODIFY gt_alv FROM ls_alv INDEX lv_ind.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  CLEAR: gt_agrup. REFRESH: gt_agrup.
  CLEAR: gt_agrup_max. REFRESH: gt_agrup_max.
  CLEAR: gt_selec. REFRESH: gt_selec.

ENDFORM.                    " DESAGRUPAR
*&---------------------------------------------------------------------*
*&      Form  F_GET_MODIFIED_ROWS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_ER_DATA_CHANGED  text
*----------------------------------------------------------------------*
FORM f_get_modified_rows  USING    pr_data_changed
                          TYPE REF TO cl_alv_changed_data_protocol.

  DATA: ls_stable    TYPE lvc_s_stbl,
        lv_verid_bob TYPE verid,
        lv_verid_rol TYPE verid,
        lv_error(1).

  FIELD-SYMBOLS: <fs1> TYPE any,
                 <fs2> TYPE table.

  DATA: ls_data      TYPE REF TO data,
        ls_datos     TYPE        zspp0026_alv,
        ls_datos_old TYPE        zspp0026_alv,
        lv_index     TYPE        sytabix,
        lv_index2    TYPE        sytabix.

*Obtenemos el registro modificado en el ALV
  ASSIGN pr_data_changed->mp_mod_rows->* TO <fs2>.

*Lo recorremos
  LOOP AT <fs2> INTO ls_datos.

    lv_index2 = sy-tabix.

    CLEAR: ls_datos_old, lv_error.
    READ TABLE gt_alv INTO ls_datos_old
         WITH KEY kunnr =  ls_datos-kunnr
                  werks = ls_datos-werks
                  vbeln = ls_datos-vbeln
                  posnr = ls_datos-posnr
                  etenr = ls_datos-etenr
                  mbdat = ls_datos-mbdat
                  agru_bob = ls_datos-agru_bob
                  ancho_max_flag = ls_datos-ancho_max_flag
                  num_cabo = ls_datos-num_cabo.

    lv_index = sy-tabix.

    IF ls_datos-werks_fab <> ls_datos_old-werks_fab.

      IF ls_datos-agru_bob IS NOT INITIAL.

        " Verificamos material de bobina:
        CLEAR: lv_verid_bob, lv_verid_rol.
        SELECT SINGLE verid INTO lv_verid_bob
          FROM mkal
          WHERE matnr = ls_datos-mate_bob
          AND werks = ls_datos-werks_fab
          AND verid = gc_verid.

        " Verificamos material de rollo:
        SELECT SINGLE verid INTO lv_verid_rol
          FROM mkal
          WHERE matnr = ls_datos-mate_rol_agrup
          AND werks = ls_datos-werks_fab
          AND verid = gc_verid.

        IF lv_verid_bob IS INITIAL.
          lv_error = 'X'.
          MODIFY gt_alv FROM ls_datos_old INDEX lv_index.
          MODIFY <fs2> FROM ls_datos_old INDEX lv_index2.
          MESSAGE i103(zpp) WITH ls_datos-mate_bob ls_datos-werks_fab
                  DISPLAY LIKE 'E'.
        ENDIF.

        IF lv_verid_rol IS INITIAL.
          lv_error = 'X'.
          MODIFY gt_alv FROM ls_datos_old INDEX lv_index.
          MODIFY <fs2> FROM ls_datos_old INDEX lv_index2.
          MESSAGE i103(zpp) WITH ls_datos-mate_rol_agrup
                  ls_datos-werks_fab
                  DISPLAY LIKE 'E'.

        ENDIF.

      ELSE.

        " Verificamos material de bobina:
        CLEAR: lv_verid_bob, lv_verid_rol.
        SELECT SINGLE verid INTO lv_verid_bob
          FROM mkal
          WHERE matnr = ls_datos-mate_bob
          AND werks = ls_datos-werks_fab
          AND verid = gc_verid.

        " Verificamos material de rollo:
        SELECT SINGLE verid INTO lv_verid_rol
          FROM mkal
          WHERE matnr = ls_datos-mate_rol
          AND werks = ls_datos-werks_fab
          AND verid = gc_verid.

        IF lv_verid_bob IS INITIAL.
          lv_error = 'X'.
          MODIFY gt_alv FROM ls_datos_old INDEX lv_index.
          MODIFY <fs2> FROM ls_datos_old INDEX lv_index2.
          MESSAGE i103(zpp) WITH ls_datos-mate_bob ls_datos-werks_fab
                  DISPLAY LIKE 'E'.
        ENDIF.

        IF lv_verid_rol IS INITIAL.
          lv_error = 'X'.
          MODIFY gt_alv FROM ls_datos_old INDEX lv_index.
          MODIFY <fs2> FROM ls_datos_old INDEX lv_index2.
          MESSAGE i103(zpp) WITH ls_datos-mate_rol
                  ls_datos-werks_fab
                  DISPLAY LIKE 'E'.

        ENDIF.

      ENDIF.

      IF lv_error = 'X'.
        MODIFY <fs2> FROM ls_datos_old INDEX lv_index2.
        MODIFY gt_alv FROM ls_datos_old INDEX lv_index.
      ELSE.

        MODIFY gt_alv FROM ls_datos INDEX  lv_index.

      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " F_GET_MODIFIED_ROWS
*&---------------------------------------------------------------------*
*&      Form  ALV_REFRESH_TABLE_DISPLAY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM alv_refresh_table_display .

  DATA: ls_stable TYPE lvc_s_stbl,
        ls_layout	TYPE lvc_s_layo.

*Refresh layout
  CLEAR ls_layout.
  CALL METHOD gcl_grid->get_frontend_layout
    IMPORTING
      es_layout = ls_layout.

  PERFORM alv_prepare_layout CHANGING ls_layout.

  CALL METHOD gcl_grid->set_frontend_layout
    EXPORTING
      is_layout = ls_layout.

*Refresh data
  CLEAR ls_stable.
  ls_stable-row = 'X'.
  ls_stable-col = 'X'.
  CALL METHOD gcl_grid->refresh_table_display
    EXPORTING
      is_stable = ls_stable
    EXCEPTIONS
      finished  = 1
      OTHERS    = 2.
  IF sy-subrc <> 0.
  ENDIF.

ENDFORM.                    " ALV_REFRESH_TABLE_DISPLAY
*&---------------------------------------------------------------------*
*&      Form  INICIALIZACION_SEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM inicializacion_sel .

  DATA: ls_werks LIKE LINE OF s_werks,
        lv_werks TYPE         werks_d.

  CLEAR: ls_werks, lv_werks.

  SELECT SINGLE parva FROM usr05
         INTO lv_werks
         WHERE bname = sy-uname AND
               parid = 'WRK'.

  IF lv_werks IS NOT INITIAL.
    ls_werks-sign = 'I'.
    ls_werks-option = 'EQ'.
    ls_werks-low = lv_werks.
    APPEND ls_werks TO s_werks.
  ENDIF.

ENDFORM.                    " INICIALIZACION_SEL
*&---------------------------------------------------------------------*
*&      Form  REFRESCAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM refrescar .

  DATA: gt_alv_aux TYPE zttpp0026_alv,
        ls_alv_aux TYPE zspp0026_alv,
        ls_alv     TYPE zspp0026_alv,
        lv_index   TYPE syst_tabix.

  CLEAR: gt_alv_aux. REFRESH: gt_alv_aux.

  gt_alv_aux[] = gt_alv[].

  LOOP AT gt_alv_aux INTO ls_alv_aux WHERE procesado = 'X' " Procesado
                                     AND icon = '@08@'. " OK

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv
         WITH KEY kunnr = ls_alv_aux-kunnr
                  werks = ls_alv_aux-werks
                  vbeln = ls_alv_aux-vbeln
                  posnr = ls_alv_aux-posnr
                  etenr = ls_alv_aux-etenr
                  mbdat = ls_alv_aux-mbdat
                  werks_fab = ls_alv_aux-werks_fab
                  procesado = ls_alv_aux-procesado
                  icon = ls_alv_aux-icon.
    lv_index = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      DELETE gt_alv INDEX lv_index.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " REFRESCAR
*&---------------------------------------------------------------------*
*&      Form  CAMBIO_ROLLO_CHEQUEOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*      <--P_LV_EXIT  text
*----------------------------------------------------------------------*
FORM cambio_rollo_chequeos  CHANGING pv_error
                                     pv_exit
                                     gt_cabos "CGIJON.
                                     p_num_bob TYPE int1.

  DATA: lti_rows        TYPE lvc_t_roid,
        ls_row          TYPE lvc_s_roid,
        ls_alv          TYPE zspp0026_alv,
        lv_lines        TYPE i,
        ls_selec        TYPE zspp0026_alv,
        lv_verid_bob    TYPE verid,
*        lv_num_bob      TYPE int1,
        lv_mat_rollo_ok TYPE xfeld.

  DATA: lv_exit TYPE xfeld.
  DATA: pv_error2 TYPE xfeld,
        pv_error3 TYPE xfeld,
        pv_error4 TYPE xfeld,
        pv_error5 TYPE xfeld.

* CGIJON - INI
  DATA: lv_peso_bob  TYPE gamng,
        lv_ancho_bob TYPE zancho.
* CGIJON - FIN

  CLEAR: gt_selec. REFRESH: gt_selec.
  CLEAR: gv_rollo, gv_zzgramaje, gv_matkl, gv_zzancho, gv_werks_fab.
  CLEAR: pv_error, pv_exit, gv_zzancho_max.
  CLEAR: lv_mat_rollo_ok.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* No se pueden marcar más de una línea:
  IF lv_lines > 1.
    pv_error = 'X'.
    MESSAGE w105(zpp).
    EXIT.
  ENDIF.

* Verificamos que la línea no está en una agrupación
* Verificamos que la línea no está procesada
* Verificamos que no hay ni orden de rollo, ni de bobina creada

  CLEAR: pv_error2, pv_error3, pv_error4, pv_error5.
  LOOP AT lti_rows INTO ls_row.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv-agru_bob IS NOT INITIAL.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ELSEIF ls_alv-procesado = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error2 = 'X'.
      EXIT.
    ELSEIF ls_alv-aufnr_bob IS NOT INITIAL
           OR ls_alv-aufnr_rol IS NOT INITIAL.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error3 = 'X'.
      EXIT.
    ELSEIF ls_alv-cambio_rollo_flag = 'X'.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error5 = 'X'.
      EXIT.
    ELSE.
      CLEAR lv_verid_bob.
      SELECT SINGLE verid INTO lv_verid_bob
        FROM mkal
        WHERE matnr = ls_alv-mate_bob
        AND werks = ls_alv-werks_fab
        AND verid = gc_verid.
      IF lv_verid_bob IS NOT INITIAL.
        APPEND ls_alv TO gt_selec.

*       CGIJON - INI
        lv_peso_bob = lv_peso_bob + ls_alv-cant_bob.
        lv_ancho_bob = lv_ancho_bob + ls_alv-anch_bob.
*       CGIJON - FIN
      ELSE.
        CLEAR: gt_selec. REFRESH: gt_selec.
        pv_error4 = 'X'.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF pv_error = 'X'.
    MESSAGE w077(zpp).
    CLEAR gt_selec. REFRESH gt_selec.
    EXIT.
  ELSEIF pv_error2 = 'X'.
    pv_error = 'X'.
    MESSAGE w083(zpp).
    CLEAR gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error3 = 'X'.
    pv_error = 'X'.
    MESSAGE w084(zpp).
    CLEAR gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error4 = 'X'.
    pv_error = 'X'.
    MESSAGE i103(zpp) WITH ls_alv-mate_bob ls_alv-werks_fab
            DISPLAY LIKE 'E'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    EXIT.
  ELSEIF pv_error5 = 'X'.
    pv_error = 'X'.
    MESSAGE i108(zpp) DISPLAY LIKE 'E'.
    CLEAR gt_selec. REFRESH gt_selec.
    EXIT.
  ENDIF.

  " Recuperar gramaje, tipo material, centro fabricación y ancho:
  CLEAR ls_selec.
  IF gt_selec[] IS NOT INITIAL.
    READ TABLE gt_selec INTO ls_selec INDEX 1.
    gv_zzgramaje = ls_selec-gram_bob.
    gv_matkl = ls_selec-matk_bob.
    gv_werks_fab = ls_selec-werks_fab.
    gv_zzancho = ls_selec-anch_bob.
  ENDIF.

  " Seleccionar el nº de bobinas:
  CLEAR: p_num_bob, lv_mat_rollo_ok.
  PERFORM num_bobinas USING    ls_alv-mate_bob
                               ls_alv-werks_fab
                               ls_alv-gram_bob
                               ls_alv-matk_bob
                               lv_peso_bob  "CGIJON
                               lv_ancho_bob "CGIJON
                      CHANGING p_num_bob
                               lv_mat_rollo_ok
                               pv_exit
                               gt_cabos. "CGIJON

  IF pv_exit = 'X' OR lv_mat_rollo_ok <> 'X'.
    CLEAR: gt_selec. REFRESH: gt_selec.
    EXIT.
  ENDIF.

ENDFORM.                    " CAMBIO_ROLLO_CHEQUEOS
*&---------------------------------------------------------------------*
*&      Form  NUM_BOBINAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_NUM_BOB  text
*      <--P_PV_EXIT  text
*----------------------------------------------------------------------*
FORM num_bobinas  USING    pi_matnr
                           pi_werks
                           pi_gram_bob
                           pi_matk_bob
                           p_peso_bob "CGIJON
                           p_ancho_bob "CGIJON
                  CHANGING p_num_bob
                           p_mat_rollo_ok
                           pv_exit
                           gt_cabos.

  DATA: lv_verid_rol TYPE verid.
  DATA: lv_returncode TYPE c.
  DATA: lt_fields TYPE TABLE OF sval,
        ls_fields TYPE          sval.

  DATA: lv_ancho_trim    TYPE i,
        lv_ancho_min_bob TYPE i. "cgijon: 13.02.17

* CGIJON - INI
  DATA: lv_mat_cabos_ok TYPE xfeld,
        pt_cabos        TYPE ty_t_cabos,
        lv_lines        TYPE i,
        lv_peso_cabo    TYPE gamng.

* CGIJON - FIN

  CLEAR: lt_fields. REFRESH: lt_fields.
  CLEAR: lv_returncode, p_num_bob, pv_exit.
  CLEAR: gv_zzancho_max, p_mat_rollo_ok.

  " 1) Nº bobinas, ancho máximo y peso de rollo:
  CLEAR ls_fields.
  ls_fields-tabname   = 'OIGSH'.
  ls_fields-fieldname = 'SEQ_NR'.
  ls_fields-fieldtext = text-017.
  ls_fields-field_obl = 'X'.
  APPEND ls_fields TO lt_fields.

* CGIJON - INI 06.02.17 - AÑADIMOS EL ANCHO MÁXIMO DEL ROLLO Y EL PESO
  CLEAR ls_fields.
  ls_fields-tabname   = 'ZTPP0002'.
  ls_fields-fieldname = 'ANCHO'.
  ls_fields-fieldtext = text-041.
  APPEND ls_fields TO lt_fields.

  CLEAR ls_fields.
  ls_fields-tabname   = 'AFKO'.
  ls_fields-fieldname = 'GAMNG'.
  ls_fields-fieldtext = text-016.
  ls_fields-field_obl = 'X'.
  ls_fields-value     = |{ p_peso_bob }|.  " Mostrar kg.bobina en POPUP CMS 01/04/2020
  APPEND ls_fields TO lt_fields.
* CGIJON - FIN 06.02.17

  CALL FUNCTION 'POPUP_GET_VALUES'
    EXPORTING
*     NO_VALUE_CHECK  = ' '
      popup_title     = text-018
      start_column    = '5'
      start_row       = '5'
    IMPORTING
      returncode      = lv_returncode
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.

  IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    lv_returncode = 'E'.
  ENDIF.

* IEG - 27.12.2016: Recuperamos el ANCHO TRIM tabla ZTPP0008
  PERFORM recuperar_ancho_trim USING    pi_werks
                                        pi_matnr
                               CHANGING lv_ancho_trim
                                        lv_ancho_min_bob.
* IEG - 27.12.2016 - Fin modificación


*  p_ancho_bob = p_ancho_bob + lv_ancho_trim. "CGIJON


  IF lv_returncode <> 'E' AND lv_returncode <> 'A'.

    CLEAR: pv_exit, ls_fields.

    " Nº Bobinas:
    READ TABLE lt_fields INTO ls_fields INDEX 1.
    IF ls_fields-value IS NOT INITIAL AND ls_fields-value <> 0.
      p_num_bob = ls_fields-value.

*     CGIJON - INI 06.02.17 - TENEMOS EN CUENTA DE SI SE HA INFORMADO EL
*     ANCHO DE LA BOBINA EN EL POP UP. SI NO SE HA INFORMADO, SE CÁLCULA
*     COMO LO HACÍA ANTERIORMENTE
      READ TABLE lt_fields INTO ls_fields WITH KEY fieldname  = 'ANCHO'.
      IF ls_fields-value IS NOT INITIAL.
        gv_zzancho_max = ls_fields-value.
        gv_ancho_popup = 'X'.
      ELSE.
        gv_zzancho_max = gv_zzancho * p_num_bob + lv_ancho_trim. "40.
      ENDIF.

      READ TABLE lt_fields INTO ls_fields WITH KEY fieldname  = 'GAMNG'.
      IF ls_fields-value IS NOT INITIAL AND ls_fields-value <> '0.000'.
        gv_peso_max = ls_fields-value.
      ENDIF.
*     CGIJON - FIN 06.02.17
    ELSE.
      CLEAR: p_num_bob, p_mat_rollo_ok, pv_exit.
      MESSAGE i106(zpp) DISPLAY LIKE 'E'.
    ENDIF.

  ELSE.
    CLEAR p_mat_rollo_ok.
    pv_exit = 'X'.
    EXIT.
  ENDIF.


  " Buscamos material rollo:
  IF gv_zzancho_max IS NOT INITIAL.
    CLEAR gv_rollo.
*   CGIJON - INI
    SELECT SINGLE a~matnr INTO gv_rollo
      FROM mara AS a
      INNER JOIN marc AS b ON ( a~matnr = b~matnr )
      WHERE a~mtart = 'ZROL'
        AND a~matkl = gv_matkl
        AND a~zzgramaje = gv_zzgramaje
        AND a~zzancho = gv_zzancho_max
        AND b~werks = gv_werks_fab.
*   CGIJON - FIN

    IF gv_rollo IS INITIAL.
      CLEAR: p_mat_rollo_ok, pv_exit.
      MESSAGE i107(zpp) WITH gv_zzancho_max  DISPLAY LIKE 'E'.
    ELSE.

      CLEAR lv_verid_rol.
      SELECT SINGLE verid INTO lv_verid_rol
        FROM mkal
        WHERE matnr = gv_rollo
          AND werks = gv_werks_fab
          AND verid = gc_verid.

      IF lv_verid_rol IS NOT INITIAL.
        CLEAR pv_exit.
        p_mat_rollo_ok = 'X'.
      ELSE.
        CLEAR: p_mat_rollo_ok, pv_exit.
        MESSAGE i103(zpp) WITH gv_rollo gv_werks_fab
                DISPLAY LIKE 'E'.
      ENDIF.
    ENDIF.

*   CGIJON - INI
*   El ancho máximo no supera al de las bobinas:
    p_ancho_bob = ( p_ancho_bob * p_num_bob ) + lv_ancho_trim.

    IF gv_zzancho_max < p_ancho_bob.
      CLEAR: p_mat_rollo_ok, pv_exit.
      MESSAGE i090(zpp) DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.

*   Peso máximo no supera al peso de las bobinas:
    CASE gv_ancho_popup.
      WHEN 'X'. " SI se informa ancho máximo
        IF gv_peso_max =< p_peso_bob.
          CLEAR: p_mat_rollo_ok, pv_exit.
          MESSAGE i089(zpp) DISPLAY LIKE 'E'.
          EXIT.
        ELSE.
          lv_peso_cabo =  gv_peso_max - p_peso_bob.
        ENDIF.
      WHEN ' '. "NO se informa ancho máximo
        IF gv_peso_max < p_peso_bob.
          CLEAR: p_mat_rollo_ok, pv_exit.
          MESSAGE i089(zpp) DISPLAY LIKE 'E'.
          EXIT.
        ELSE.
          lv_peso_cabo =  gv_peso_max - p_peso_bob.
        ENDIF.
      WHEN OTHERS.
    ENDCASE.



    IF gv_peso_max < p_peso_bob.
      CLEAR: p_mat_rollo_ok, pv_exit.
      MESSAGE i089(zpp) DISPLAY LIKE 'E'.
      EXIT.
    ELSE.
      lv_peso_cabo =  gv_peso_max - p_peso_bob.
    ENDIF.
*   CGIJON - FIN
  ENDIF.


* CGIJON - INI CABOS
  CHECK gv_zzancho_max <> p_ancho_bob.

  PERFORM cabos USING pi_werks
                      gv_zzancho_max
                      p_ancho_bob
                      lv_peso_cabo
                      pi_matk_bob
                      pi_gram_bob
                CHANGING gt_cabos.
* CGIJON - FIN CABOS


ENDFORM.                    " NUM_BOBINAS
*&---------------------------------------------------------------------*
*&      Form  MARCAR_CAMBIO_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM marcar_cambio_rollo USING p_num_bobinas TYPE int1 .

  DATA: ls_alv       TYPE zspp0026_alv,
        ls_selec     TYPE zspp0026_alv,
        lv_ind       TYPE i,
        lv_maktx     TYPE maktx,
        lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho.

  DATA: lv_agru TYPE char3. "CGIJON.
  DATA: ls_cabos TYPE LINE OF ty_t_cabos."CGIJON.

* Recuperar datos de material de rollo:
  CLEAR: lv_maktx, lv_zzgramaje, lv_zzancho.
  SELECT SINGLE maktx INTO lv_maktx
    FROM makt
    WHERE matnr = gv_rollo
    AND spras = sy-langu.

  SELECT SINGLE zzgramaje zzancho
    INTO (lv_zzgramaje, lv_zzancho )
    FROM mara
    WHERE matnr = gv_rollo.

* CGIJON - INI
* Indicador de agrupación:
  ADD 1 TO gv_agru_bob.
  WRITE gv_agru_bob TO lv_agru RIGHT-JUSTIFIED.
* CGIJON - FIN

  LOOP AT gt_selec INTO ls_selec.
    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv WITH KEY vbeln = ls_selec-vbeln
                                           posnr = ls_selec-posnr
                                           etenr = ls_selec-etenr.
    lv_ind = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      ls_alv-cambio_rollo_flag = 'X'.
      ls_alv-cant_rol_agrup = ls_alv-cant_rol.
      ls_alv-mate_rol_agrup = gv_rollo.
      ls_alv-desc_rol_agrup = lv_maktx.
      ls_alv-gram_rol = lv_zzgramaje.
      ls_alv-anch_rol_agrup = gv_zzancho_max.
      ls_alv-icon = '@09@'. " Amarillo
      IF p_num_bobinas > 1.
        ls_alv-num_bobinas = p_num_bobinas.
      ENDIF.

*     CGIJON - INI
      IF gt_cabos[] IS NOT INITIAL.
        ADD 1 TO gv_num_cabo.
        ls_alv-agru_bob = lv_agru.
        ls_alv-ancho_max_flag = 'X'.
        ls_alv-num_cabo = gv_num_cabo.
      ENDIF.
*     CGIJON - FIN

      MODIFY gt_alv FROM ls_alv INDEX lv_ind.
    ENDIF.
  ENDLOOP.


* CGIJON - INI - Agregar CABO a lineas
  LOOP AT gt_cabos INTO ls_cabos.
    ADD 1 TO gv_num_cabo.
    CLEAR ls_alv.

    IF ls_selec-werks = '3020'.
      ls_alv-kunnr = gc_kunnr2.
    ELSE.
      ls_alv-kunnr = gc_kunnr.
    ENDIF.

    ls_alv-werks = ls_selec-werks.
    ls_alv-werks_fab = ls_selec-werks_fab.

    CLEAR: ls_alv-vbeln, ls_alv-posnr.

    ls_alv-mbdat = ls_selec-mbdat.
    ls_alv-wmeng = ls_cabos-cantidad.
    ls_alv-vrkme = ls_selec-vrkme.
    ls_alv-lprio = ls_selec-lprio.
    ls_alv-cant_bob = ls_cabos-cantidad.
    ls_alv-unid_bob = ls_selec-unid_bob.
    ls_alv-mate_bob = ls_cabos-matnr.
    ls_alv-desc_bob = ls_cabos-matkx.
    ls_alv-gram_bob = ls_cabos-zzgramaje.
    ls_alv-anch_bob = ls_cabos-zzancho.
    ls_alv-matk_bob = ls_cabos-matkl.
    ls_alv-aufa_bob = gc_aufa_bob.
    ls_alv-agru_bob = lv_agru.
    ls_alv-ancho_max_flag = 'X'.
    ls_alv-cant_rol_agrup = gv_peso_max.
    ls_alv-unid_rol = ls_selec-unid_rol.
    ls_alv-mate_rol_agrup = gv_rollo.
    ls_alv-desc_rol_agrup = lv_maktx.
    ls_alv-gram_rol = lv_zzgramaje.
    ls_alv-anch_rol_agrup = lv_zzancho.
    ls_alv-matk_rol = ls_selec-matk_rol.
    ls_alv-aufa_rol = gc_aufa_rol.
    ls_alv-num_cabo = gv_num_cabo.
    ls_alv-icon = '@09@'. " Amarillo

* CMS Añadir reparto para cabos.
    ls_alv-etenr = 1.

    APPEND ls_alv TO gt_alv.
  ENDLOOP.
* CGIJON - FIN

  CLEAR: gt_selec. REFRESH: gt_selec.

ENDFORM.                    " MARCAR_CAMBIO_ROLLO
*&---------------------------------------------------------------------*
*&      Form  CREAR_ORDEN_ROLLO_CAMBIO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_SELEC  text
*      <--P_LV_AUFNR_ROL  text
*      <--P_LV_AUART_ROL  text
*      <--P_LV_OK  text
*----------------------------------------------------------------------*
FORM crear_orden_rollo_cambio  USING    ps_selec TYPE zspp0026_alv
                        CHANGING pv_aufnr_rol
                                 pv_auart_rol
                                 pv_ok.

  DATA: ls_orderdata     TYPE bapi_pi_order_create,
        lt_return        TYPE bapiret2_t,
        ls_return        TYPE bapiret2,
        lv_aufnr         TYPE aufnr,
        lv_auart         TYPE aufart,
        ls_listado1      LIKE gt_listado1,
        lv_rol1          TYPE zrollos,
        lv_tor1          TYPE ztornada,
        lv_rol2          TYPE zrollos,
        lv_tor2          TYPE ztornada,
        lv_rol1_txt(10),
        lv_rol2_txt(10),
        lv_tor1_txt(10),
        lv_tor2_txt(10),
        lv_fecha_aux(10),
        lv_fecha         TYPE co_gstrp,
        lt_orders        TYPE tb_bapi_order_key,
        ls_orders        TYPE bapi_order_key.

  DATA: lv_ok        TYPE xflag,
        lv_cont      TYPE i,
        lv_aufnr_aux TYPE aufnr.

  DATA: lv_tipo(1),
        lv_error   TYPE xfeld.

  DATA: ls_messtab     LIKE i_messtab,
        ls_return_roll LIKE bapiret2.

  CLEAR: ls_orderdata, ls_return, lv_aufnr, lv_auart, pv_ok,
         ls_listado1.
  REFRESH lt_return.

  " Encontrar la fecha de inicio que tenemos que pasar para crear la
  " orden:
  CLEAR lv_fecha.
  PERFORM f_calc_fech USING ps_selec-werks
                            ps_selec-mbdat
                      CHANGING lv_fecha.


  ls_orderdata-material         = ps_selec-mate_rol_agrup.
*  ls_orderdata-plant            = ps_selec-werks.
  ls_orderdata-plant            = ps_selec-werks_fab.
  ls_orderdata-order_type       = ps_selec-aufa_rol.
  ls_orderdata-quantity         = ps_selec-cant_rol_agrup.
  ls_orderdata-quantity_uom     = ps_selec-unid_rol.
*  ls_orderdata-basic_start_date = lv_fecha.
  ls_orderdata-basic_end_date = lv_fecha.

* Marcar prioridad de la orden como urgente:
*  IF ps_selec-lprio = '01'.
*    ls_orderdata-order_priority = ps_selec-lprio+1(1).
*  ENDIF.

  " Tipo: Creación
  CLEAR lv_tipo.
  lv_tipo = 'C'.

  " 1. Crear la orden:
  CALL FUNCTION 'BAPI_PROCORD_CREATE'
    EXPORTING
      orderdata    = ls_orderdata
    IMPORTING
      return       = ls_return
      order_number = lv_aufnr
      order_type   = lv_auart.


  IF lv_aufnr IS INITIAL.
    " Error
    CLEAR: pv_ok, pv_aufnr_rol, pv_auart_rol.
    PERFORM registrar_log USING ps_selec
                                ls_return
                                lv_tipo
                                ps_selec-aufa_rol
                                ' '.
  ELSE.

* 28/01/2021 - CMS espera antes de obtener los estados de OF
    PERFORM validar_estado_of_edet USING    lv_aufnr
                                         ps_selec
                                CHANGING lv_error.
    IF lv_error = 'X'.
      CLEAR: pv_ok, pv_aufnr_rol, pv_auart_rol. "Al limpiar "pv_aufnr_rol", luego no sigue procesando.
      EXIT.
    ELSE.

      " Todo el proceso ha ido correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      pv_aufnr_rol = lv_aufnr.
      pv_auart_rol = ps_selec-aufa_rol.

      PERFORM espera_orden_creada USING lv_aufnr.

      " Recuperar datos rollos y tornadas:
      CLEAR: lv_rol1, lv_rol2, lv_tor1, lv_tor2.
      PERFORM dat_rollo_torn USING ps_selec-cant_rol_agrup
                                   ps_selec-anch_bob
                             CHANGING lv_rol1
                                      lv_tor1
                                      lv_rol2
                                      lv_tor2.

      PERFORM espera_bloqueo_orden USING lv_aufnr.

      CLEAR lv_error.
      PERFORM datos_adic_rol USING lv_aufnr
                                   ps_selec
                                   lv_rol1
                                   lv_tor1
                                   lv_rol2
                                   lv_tor2
                             CHANGING lv_error.

      IF lv_error = 'X'.

        CLEAR: ls_listado1.

        PERFORM mensajes_error
          TABLES i_messtab
          CHANGING ls_listado1-msg_ret.

        CLEAR ls_return.
        ls_return-type = 'E'.
        ls_return-message = ls_listado1-msg_ret.

        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.

        PERFORM espera_bloqueo_orden USING lv_aufnr.
        PERFORM cerrar_tec_orden USING lv_aufnr
                                 CHANGING ls_return.

        IF ls_return-type = 'E'.

          CLEAR: pv_ok.
          pv_aufnr_rol = lv_aufnr.
          pv_auart_rol = ps_selec-aufa_rol.

          PERFORM registrar_log USING ps_selec
                                      ls_return
                                      lv_tipo
                                      ps_selec-aufa_rol
                                      lv_aufnr.

        ELSEIF ls_return-type = 'I' AND ls_return-id = 'CO' AND
        ls_return-number = '889'.

          CLEAR: pv_aufnr_rol, pv_auart_rol, pv_ok.
          PERFORM registrar_log USING ps_selec
                              ls_return
                              lv_tipo
                              ps_selec-aufa_rol
                              lv_aufnr.

        ENDIF.
      ELSE.
        " Todo el proceso ha ido correctamente:
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.

        pv_ok = 'X'.
        pv_aufnr_rol = lv_aufnr.
        pv_auart_rol = ps_selec-aufa_rol.

        CLEAR ls_return.
        ls_return-type = 'S'.
        PERFORM registrar_log USING ps_selec
                                    ls_return
                                    lv_tipo
                                    ps_selec-aufa_rol
                                    lv_aufnr.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " CREAR_ORDEN_ROLLO_CAMBIO
*&---------------------------------------------------------------------*
*&      Form  LINEAS_MARCADAS_DESH_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM lineas_marcadas_desh_rollo  CHANGING pv_error.

  DATA: lti_rows TYPE lvc_t_roid,
        ls_row   TYPE lvc_s_roid,
        ls_alv   TYPE zspp0026_alv,
        lv_lines TYPE i.

  DATA: pv_error2 TYPE xfeld,
        pv_error3 TYPE xfeld.

  CLEAR: gt_selec. REFRESH: gt_selec.

* Recuperamos las líneas marcadas
  CALL METHOD gcl_grid->get_selected_rows
    IMPORTING
      et_row_no = lti_rows.

* Sacamos el número de líneas marcadas
  DESCRIBE TABLE lti_rows LINES lv_lines.

* Si no hay nada marcado -> ERROR
  IF lv_lines = 0.
    pv_error = 'X'.
    MESSAGE w075(zpp).
    EXIT.
  ENDIF.

* Verificamos que no están en una agrupación
* Verificamos que las líneas no estén procesadas
* Verificamos que no tengan ni orden de rollo, ni de bobina
* creadas

  CLEAR: pv_error2, pv_error3.
  LOOP AT lti_rows INTO ls_row.

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv INDEX ls_row-row_id.

    IF ls_alv-agru_bob IS NOT INITIAL.
      CLEAR: gt_selec. REFRESH: gt_selec.
      pv_error = 'X'.
      EXIT.
    ELSEIF ls_alv-procesado = 'X'.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error2 = 'X'.
      EXIT.
    ELSEIF ls_alv-aufnr_bob IS NOT INITIAL
           OR ls_alv-aufnr_rol IS NOT INITIAL.
      CLEAR gt_selec. REFRESH: gt_selec.
      pv_error3 = 'X'.
      EXIT.
    ELSE.
      APPEND ls_alv TO gt_selec.
    ENDIF.
  ENDLOOP.

  IF pv_error = 'X'.
    MESSAGE w110(zpp).
    EXIT.
  ELSEIF pv_error2 = 'X'.
    pv_error = 'X'.
    MESSAGE w083(zpp).
    EXIT.
  ELSEIF pv_error3 = 'X'.
    pv_error = 'X'.
    MESSAGE w084(zpp).
    EXIT.
  ENDIF.

ENDFORM.                    " LINEAS_MARCADAS_DESH_ROLLO
*&---------------------------------------------------------------------*
*&      Form  DESHACER_CAMBIO_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM deshacer_cambio_rollo .

  DATA: ls_alv       TYPE zspp0026_alv,
        ls_selec     TYPE zspp0026_alv,
        lv_ind       TYPE i,
        lv_zzgramaje TYPE zgramaje,
        lv_zzancho   TYPE zancho.

  LOOP AT gt_selec INTO ls_selec WHERE cambio_rollo_flag = 'X'.

    CLEAR ls_alv.
    READ TABLE gt_alv INTO ls_alv WITH KEY vbeln = ls_selec-vbeln
                                           posnr = ls_selec-posnr
                                           etenr = ls_selec-etenr
                                           cambio_rollo_flag = 'X'.

    lv_ind = sy-tabix.
    IF ls_alv IS NOT INITIAL.
      CLEAR: ls_alv-cant_rol_agrup, ls_alv-mate_rol_agrup.
      CLEAR: ls_alv-desc_rol_agrup, ls_alv-cambio_rollo_flag.
      CLEAR: ls_alv-anch_rol_agrup, ls_alv-num_bobinas.

      CLEAR: lv_zzgramaje, lv_zzancho.
      SELECT SINGLE zzgramaje zzancho
             INTO (lv_zzgramaje, lv_zzancho)
             FROM mara
             WHERE matnr = ls_alv-mate_rol.

      ls_alv-gram_rol = lv_zzgramaje.

*     CGIJON - INI 06.02.17 - TENEMOS EN CUENTA DE SI SE HA INFORMADO EL
*     ANCHO DE LA BOBINA EN EL POP UP. SI NO SE HA INFORMADO, SE CÁLCULA
*     COMO LO HACÍA ANTERIORMENTE
      IF gv_ancho_popup = 'X'.
        ls_alv-anch_rol = gv_zzancho_max.
      ELSE.
        ls_alv-anch_rol = lv_zzancho.
      ENDIF.
*     CGIJON - FIN 06.02.17

      MODIFY gt_alv FROM ls_alv INDEX lv_ind.
    ENDIF.
  ENDLOOP.

  CLEAR: gv_ancho_popup. "CGIJON - 06.02.17 - TENEMOS EN CUENTA DE SI SE HA INFORMADO EL
*                         ANCHO DE LA BOBINA EN EL POP UP

ENDFORM.                    " DESHACER_CAMBIO_ROLLO


*&---------------------------------------------------------------------*
*&      Form  RECUPERAR_ANCHO_TRIM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->PI_WERKS  text
*      -->PI_MATNR  text
*      <--PO_ANCHO_TRIM  text
*----------------------------------------------------------------------*
FORM recuperar_ancho_trim  USING    pi_werks
                                    pi_matnr
                           CHANGING po_ancho_trim
                                    po_ancho_min.

  DATA: lv_plnty TYPE plnty,
        lv_plnnr TYPE plnnr,
        lv_alnal TYPE plnal,
        lv_arbid TYPE objektid,
        lv_arbpl TYPE arbpl.

* Sacamos la hoja de ruta del material
  SELECT SINGLE plnty plnnr alnal
      INTO (lv_plnty, lv_plnnr, lv_alnal)
      FROM  mkal
      WHERE matnr = pi_matnr
      AND   werks = pi_werks
      AND   verid = gc_verid.

* Buscamos el puesto de trabajo
  IF lv_plnnr IS NOT INITIAL.
    SELECT SINGLE arbid INTO lv_arbid
        FROM  plpo
        WHERE plnty = lv_plnty
        AND   plnnr = lv_plnnr
        AND   phflg = space.
  ENDIF.

* Buscamos el identificador del puesto de trabajo
  IF lv_arbid IS NOT INITIAL.
    SELECT SINGLE arbpl INTO lv_arbpl
        FROM  crhd
        WHERE objty = 'A'
        AND   objid = lv_arbid.
  ENDIF.

* Buscamos en ancho trim de la tabla Z
  IF lv_arbpl IS NOT INITIAL.
    SELECT SINGLE ancho_trim ancho_min INTO (po_ancho_trim, po_ancho_min)
        FROM  ztpp0008
        WHERE werks = pi_werks
        AND   arbpl = lv_arbpl.
  ENDIF.

* uDefine 29/01/2018 - Se anulan las siguiente lineas y
* se permite que el trim sea cero si es asi como esta definido
* en la tabla

ENDFORM.                    " RECUPERAR_ANCHO_TRIM
*&---------------------------------------------------------------------*
*&      Form  CABOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_ZZANCHO_MAX  text
*      -->P_P_ANCHO_BOB  text
*----------------------------------------------------------------------*
FORM cabos  USING    p_werks
                     p_zzancho_max
                     p_ancho_bob
                     p_peso_cabo
                     p_matkl
                     p_zzgramaje
            CHANGING gt_cabos TYPE ty_t_cabos.

  DATA: lv_ancho_cabo_def TYPE zancho,
        lv_matnr          TYPE matnr.
  DATA: lv_verid_cabo1 TYPE verid.
  DATA: ls_cabos TYPE LINE OF ty_t_cabos.


  lv_ancho_cabo_def   = p_zzancho_max -  p_ancho_bob.

  " buscamos materiales con los datos seleccionados:
  SELECT SINGLE a~matnr INTO  lv_matnr
    FROM mara AS a
    INNER JOIN marc AS b ON ( a~matnr = b~matnr )
    WHERE a~mtart = 'ZPAP'
      AND a~matkl = p_matkl
      AND a~zzgramaje = p_zzgramaje
      AND a~zzancho = lv_ancho_cabo_def
      AND b~werks = p_werks.

  IF lv_matnr IS INITIAL.
    MESSAGE i096(zpp) WITH lv_ancho_cabo_def p_matkl p_zzgramaje
                      DISPLAY LIKE 'E'.
    EXIT.
  ELSE.
    CLEAR lv_verid_cabo1.
    SELECT SINGLE verid INTO lv_verid_cabo1
      FROM mkal
      WHERE matnr = lv_matnr
      AND werks = gv_werks_fab
      AND verid = gc_verid.

    IF lv_verid_cabo1 IS INITIAL.
      MESSAGE i103(zpp) WITH lv_matnr gv_werks_fab
              DISPLAY LIKE 'E'.
      EXIT.
    ELSE.
      CLEAR ls_cabos.
      ls_cabos-matnr = lv_matnr.

      SELECT SINGLE maktx INTO ls_cabos-matkx
        FROM makt
        WHERE matnr = lv_matnr
        AND spras = sy-langu.

      ls_cabos-matkl = p_matkl.
      ls_cabos-cantidad = p_peso_cabo.
      ls_cabos-zzgramaje = p_zzgramaje.
      ls_cabos-zzancho = lv_ancho_cabo_def.
      APPEND ls_cabos TO gt_cabos.
    ENDIF.
  ENDIF.
ENDFORM.                    " CABOS
*&---------------------------------------------------------------------*
*&      Form  VERIFICAR_CALCULO_COSTES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PS_SELEC_MATE_BOB  text
*      -->P_PS_SELEC_WERKS_FAB  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM verificar_calculo_costes  USING   matnr TYPE matnr
                                       werks TYPE werks_d
                                       aufa_bob TYPE aufart
                               CHANGING lv_error.

  DATA: lv_answer(1),
        lv_code          LIKE sy-subrc,
        lv_text_question TYPE string.

  IF ( werks = '3000' OR werks = '3020' ) AND
     ( aufa_bob = 'ZI01' OR aufa_bob = 'ZI02' OR aufa_bob = 'ZI03' OR
       aufa_bob = 'ZI04' OR aufa_bob = 'ZI05' OR aufa_bob = 'ZI06' ).

    CALL FUNCTION 'COPC_CHECK_MBEW_KEKO'
      EXPORTING
        material = matnr
        bwkey    = werks
        status   = 'FR'
      IMPORTING
        rcode    = lv_code.

    IF lv_code <> 0. "  NO se ha hecho el calculo de costes
      CALL FUNCTION 'ZPP_PANTALLA_AVISO'
        EXPORTING
          titulo   = 'Error en la creación de OF'
          tp_icono = 'E'
          text1    = 'ERROR EN LA DETERMINACIÓN DE COSTES. '
          text2    = 'No se crea la OF.'.

      lv_error = 'X'.

    ENDIF.

***    IF lv_code <> 0. "  NO se ha hecho el calculo de costes
***
***
***      lv_text_question = 'Error en la determinación de costes. ¿Desea grabar de todos modos?'.
***
***      CALL FUNCTION 'POPUP_TO_CONFIRM'
***        EXPORTING
***          titlebar       = text-019
***          text_question  = lv_text_question
***          text_button_1  = 'Sí'
***          text_button_2  = 'No'
***        IMPORTING
***          answer         = lv_answer
***        EXCEPTIONS
***          text_not_found = 1
***          OTHERS         = 2.
***
***      IF sy-subrc <> 0.
***        lv_answer = '2'.
***      ELSEIF lv_answer = '2'.
***        lv_error = 'X'.
***      ENDIF.
***    ENDIF.
  ENDIF.
ENDFORM.                    " VERIFICAR_CALCULO_COSTES
*&---------------------------------------------------------------------*
*&      Form  INF_ORDROLLO_EN_ORDENBOBINA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_ORDEN_BOBINA_AUFNR  text
*      -->P_LV_AUFNR_ROL  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM inf_ordrollo_en_ordenbobina  USING    p_orden_bobina
                                           p_orden_rollo
                                  CHANGING p_error.


*  "Hacemos EXPORT a memoria con la orden para no tener problemas con el
*  "batch input y los campos que se sombrean en pantalla en la COR2.
*  EXPORT  P_orden_bobina FROM p_aufnr TO MEMORY ID 'ORDER'.

  " Ahora hacemos el batch-input para modificar campos de cliente:
  REFRESH bdcdata.
  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5110'.
  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-AUFNR'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '/00'.
  PERFORM bdc_field       USING 'CAUFVD-AUFNR'
                                p_orden_bobina.
  PERFORM bdc_field       USING 'R62CLORD-FLG_COMPL'
                                'X'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=+COI'.

  PERFORM bdc_field       USING 'BDC_CURSOR'
                                'CAUFVD-GAMNG'.

  PERFORM bdc_dynpro      USING 'SAPLCOKO' '5115'.
  PERFORM bdc_field       USING 'BDC_OKCODE'
                                '=BU'.

  PERFORM bdc_field       USING 'BDC_CURSOR'
                                  'AUFK-ZZAUFNR_ROLLO'.
  PERFORM bdc_field       USING 'AUFK-ZZAUFNR_ROLLO'
                                 p_orden_rollo.

  CLEAR: i_messtab.
  REFRESH: i_messtab.

  CALL TRANSACTION 'COR2' USING bdcdata MODE 'N'
                          MESSAGES INTO i_messtab
                          UPDATE 'S'.

  IF sy-subrc <> 0.
    p_error = 'X'.
  ENDIF.

ENDFORM.                    " INF_ORDROLLO_EN_ORDENBOBINA
*&---------------------------------------------------------------------*
*&      Form  ALV_PREPARE_EVENTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM alv_prepare_events .

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  F_EVENT_UCOMM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_E_UCOMM  text
*----------------------------------------------------------------------*
FORM f_event_ucomm USING p_row_id p_column_id p_row_no STRUCTURE lvc_s_roid.

  DATA: ls_vbak TYPE vbak,
        ls_ekko TYPE ekko,
        ls_alv  TYPE zspp0026_alv.

  CHECK p_column_id EQ 'VBELN'.

  READ TABLE gt_alv INTO ls_alv INDEX p_row_no-row_id.
  IF sy-subrc = 0.

    SELECT SINGLE * FROM vbak INTO ls_vbak WHERE vbeln = ls_alv-vbeln.
    IF sy-subrc = 0.
      SET PARAMETER ID 'AUN' FIELD ls_vbak-vbeln.
      CALL TRANSACTION 'VA03' AND SKIP FIRST SCREEN.
    ELSE.

      SELECT SINGLE * FROM ekko INTO ls_ekko WHERE ebeln = ls_alv-vbeln.
      IF sy-subrc = 0.
        SET PARAMETER ID 'BES' FIELD ls_ekko-ebeln.
        CALL TRANSACTION 'ME23N' AND SKIP FIRST SCREEN.
      ENDIF.

    ENDIF.
  ENDIF.

ENDFORM.
