*&---------------------------------------------------------------------*
*&  Include           ZRPP0027_F01
*&---------------------------------------------------------------------*


*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_DATOS_0201_tree
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_datos_0300.

  DATA: l_tree_container_name(30) TYPE c.
  DATA: lv_variant TYPE disvariant.


  l_tree_container_name = 'TREE_CONTROL'.

  CREATE OBJECT g_custom_container
    EXPORTING
      container_name              = l_tree_container_name
    EXCEPTIONS
      cntl_error                  = 1
      cntl_system_error           = 2
      create_error                = 3
      lifetime_error              = 4
      lifetime_dynpro_dynpro_link = 5.


  CREATE OBJECT g_alv_tree
    EXPORTING
      parent                      = g_custom_container
      node_selection_mode         = cl_gui_column_tree=>node_sel_mode_single
      item_selection              = ''
      no_html_header              = 'X'
      no_toolbar                  = ''
    EXCEPTIONS
      cntl_error                  = 1
      cntl_system_error           = 2
      create_error                = 3
      lifetime_error              = 4
      illegal_node_selection_mode = 5
      failed                      = 6
      illegal_column_name         = 7.

  PERFORM fill_catalog_tree.

  PERFORM build_hierarchy_header CHANGING l_hierarchy_header.

  lv_variant-report = 'ZRPP0027'.

  CALL METHOD g_alv_tree->set_table_for_first_display
    EXPORTING
      is_hierarchy_header = l_hierarchy_header
      i_save              = 'A'
      is_variant          = lv_variant
    CHANGING
      it_outtab           = t_tree[]
      it_fieldcatalog     = gt_fieldcat_tree.


  PERFORM create_hierarchy.

* Expandir nodos del ALV tree.
  DATA: lt_node_key TYPE lvc_t_nkey,
        ls_node_key LIKE LINE OF lt_node_key.
  CLEAR lt_node_key.
  LOOP AT gt_header INTO DATA(ls_header).

* Si el nodo no tiene lotes colgando de él, no expandimos ya que corrompe el ALV.
    IF NOT line_exists( gt_cuerpo[ aufnr = ls_header-aufnr ] ).
      CONTINUE.
    ENDIF.

    CLEAR ls_node_key.
    ls_node_key = ls_header-nkey.
    INSERT ls_node_key INTO TABLE lt_node_key.
  ENDLOOP.
*  call method g_alv_tree->expand_nodes


  CALL METHOD g_alv_tree->expand_nodes
    EXPORTING
      it_node_key             = lt_node_key
    EXCEPTIONS
      failed                  = 1
      cntl_system_error       = 2
      error_in_node_key_table = 3
      dp_error                = 4
      node_not_found          = 5
      OTHERS                  = 6.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.

  PERFORM change_toolbar.

  PERFORM register_events.

  CALL METHOD cl_gui_cfw=>flush
    EXCEPTIONS
      cntl_system_error = 1
      cntl_error        = 2.

ENDFORM.                    " MOSTRAR_DATOS_0300_tree
*&---------------------------------------------------------------------*
*&      Form  FILL_CATALOG_TREE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fill_catalog_tree .

  DATA:  wa_fieldcat_tree TYPE LINE OF lvc_t_fcat.

  CLEAR:  gt_fieldcat_tree. REFRESH:  gt_fieldcat_tree.

  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name = 'ZEPP0027_CUERPO'
*     i_client_never_display = 'X'
*     i_bypassing_buffer     =
    CHANGING
      ct_fieldcat      = gt_fieldcat_tree
    EXCEPTIONS
      OTHERS           = 3.


  LOOP AT gt_fieldcat_tree INTO wa_fieldcat_tree.

    CASE wa_fieldcat_tree-fieldname.
      WHEN 'CHARG'.
        wa_fieldcat_tree-outputlen = 16.

      WHEN 'TIPO'.
        wa_fieldcat_tree-coltext = text-005.
        wa_fieldcat_tree-scrtext_l = text-005.
        wa_fieldcat_tree-scrtext_m = text-005.
        wa_fieldcat_tree-scrtext_s = text-005.
        wa_fieldcat_tree-outputlen = 8.

      WHEN 'TIPO_SEM'.
        wa_fieldcat_tree-icon = 'X'.
        wa_fieldcat_tree-outputlen = 10.

      WHEN 'BWART'.
        wa_fieldcat_tree-no_out = 'X'.

      WHEN 'MATNR'.
        wa_fieldcat_tree-no_out = 'X'.

      WHEN 'AUFNR'.
        wa_fieldcat_tree-no_out = 'X'.

      WHEN 'MBLNR'.
        wa_fieldcat_tree-no_out = 'X'.

      WHEN 'MJAHR'.
        wa_fieldcat_tree-no_out = 'X'.

      WHEN 'MENGE'.
        wa_fieldcat_tree-coltext = text-023.
        wa_fieldcat_tree-scrtext_l = text-023.
        wa_fieldcat_tree-scrtext_m = text-023.
        wa_fieldcat_tree-scrtext_s = text-023.
        wa_fieldcat_tree-outputlen = 17.

      WHEN 'DIAMETRO'.
        wa_fieldcat_tree-coltext = text-024.
        wa_fieldcat_tree-scrtext_l = text-024.
        wa_fieldcat_tree-scrtext_m = text-024.
        wa_fieldcat_tree-scrtext_s = text-024.
        wa_fieldcat_tree-outputlen = 17.

      WHEN 'METROS'.
        wa_fieldcat_tree-coltext = text-025.
        wa_fieldcat_tree-scrtext_l = text-025.
        wa_fieldcat_tree-scrtext_m = text-025.
        wa_fieldcat_tree-scrtext_s = text-025.
        wa_fieldcat_tree-outputlen = 17.

    ENDCASE.

    MODIFY gt_fieldcat_tree FROM wa_fieldcat_tree INDEX sy-tabix.
  ENDLOOP.
ENDFORM.                    " FILL_CATALOG_TREE
*&---------------------------------------------------------------------*
*&      Form  BUILD_HIERARCHY_HEADER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_HIERARCHY_HEADER  text
*----------------------------------------------------------------------*
FORM build_hierarchy_header  CHANGING p_hierarchy_header TYPE treev_hhdr.

  CLEAR p_hierarchy_header.

*  p_hierarchy_header-heading = 'Orden # Material # Descripción # Pedido # Cliente'.
  p_hierarchy_header-heading = 'Orden # Material # Cliente'.
  p_hierarchy_header-width = 72.
  p_hierarchy_header-width_pix = ''.


ENDFORM.                    " BUILD_HIERARCHY_HEADER
*&---------------------------------------------------------------------*
*&      Form  CREATE_HIERARCHY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM create_hierarchy .

  DATA: l_root_key       TYPE lvc_nkey,
        l_next_key       TYPE lvc_nkey,
        l_last_key       TYPE lvc_nkey,
        header           TYPE string,
        w_menge_text(13) TYPE c.

  CLEAR l_root_key.


  LOOP AT  gt_header ASSIGNING FIELD-SYMBOL(<fs_header>).
    CLEAR: l_root_key, l_next_key.

    PERFORM add_node USING <fs_header>-aufnr
                           <fs_header>-plnbez
                           <fs_header>-maktx
                           <fs_header>-zebeln1
                           <fs_header>-zebelp1
                           <fs_header>-zkunnr1
                           <fs_header>-name1
                           l_root_key
                           <fs_header>-zzsecuencia
                     CHANGING l_next_key.

    <fs_header>-nkey = l_next_key.
    <fs_header>-nkey = l_next_key.

    LOOP AT gt_cuerpo ASSIGNING <cuerpo>  WHERE aufnr EQ <fs_header>-aufnr.
      PERFORM add_leaf USING <cuerpo> l_next_key <fs_header>-zzsecuencia
                       CHANGING l_last_key.
    ENDLOOP.
  ENDLOOP.

  CALL METHOD g_alv_tree->frontend_update.


ENDFORM.                    " CREATE_HIERARCHY
*&---------------------------------------------------------------------*
*&      Form  ADD_NODE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_<HEADER>_CARRID  text
*      -->P_L_ROOT_KEY  text
*      <--P_L_NEXT_KEY  text
*----------------------------------------------------------------------*
FORM add_node USING l_aufnr
                    l_plnbez
                    l_maktx
                    l_zebeln1
                    l_zebelp1
                    l_zkunnr1
                    l_name1
                    l_root_key
                    l_zzsecuencia TYPE zzsecuencia "Bobina partida
              CHANGING l_next_key.

  DATA: l_node_text TYPE lvc_value,
        ls_tree     TYPE zepp0027_cuerpo.

  DATA: lv_aufnr   TYPE aufnr,
        lv_plnbez  TYPE matnr,
        lv_zebeln1 TYPE ebeln,
        lv_zebelp1 TYPE ebelp,
        lv_ped_pos TYPE c LENGTH 17,
        lv_cli     TYPE c LENGTH 50.
  DATA: l_layout_node TYPE lvc_s_layn.


  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = l_aufnr
    IMPORTING
      output = lv_aufnr.


  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = l_plnbez
    IMPORTING
      output = lv_plnbez.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = l_zebeln1
    IMPORTING
      output = lv_zebeln1.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = l_zebelp1
    IMPORTING
      output = lv_zebelp1.

  CONCATENATE lv_zebeln1 lv_zebelp1 INTO lv_ped_pos SEPARATED BY '-'.
  CONDENSE lv_ped_pos.

*  CONCATENATE l_zkunnr1 l_name1 INTO lv_cli SEPARATED BY '-'.
*  CONDENSE lv_cli.

*  CONCATENATE lv_aufnr lv_plnbez l_maktx lv_ped_pos lv_cli
*                      INTO l_node_text SEPARATED BY ' # '.


  CONCATENATE lv_aufnr l_maktx l_zkunnr1
                      INTO l_node_text SEPARATED BY ' # '.

  CLEAR l_layout_node.

* 26/03/2021 - 57299 - CMS Gestión ICONO BOBINA PARTIDA.
  IF l_zzsecuencia > 1. " Si es bobina partida, mostrar icono "ICON_COMPARE"
    l_layout_node-n_image = '@46@'.
  ENDIF.

  CALL METHOD g_alv_tree->add_node
    EXPORTING
      i_relat_node_key = l_root_key
      i_relationship   = cl_gui_column_tree=>relat_last_child
      i_node_text      = l_node_text
      is_outtab_line   = ls_tree
      is_node_layout   = l_layout_node
    IMPORTING
      e_new_node_key   = l_next_key.

ENDFORM.                    " ADD_NODE
*&---------------------------------------------------------------------*
*&      Form  ADD_LEAF
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TAB_TREE  text
*      -->P_L_NEXT_KEY  text
*      <--P_L_LAST_KEY  text
*----------------------------------------------------------------------*
FORM add_leaf  USING l_tree
                      l_next_key
                      l_secuencia TYPE zzsecuencia
              CHANGING l_last_key.

  DATA: l_layout_node TYPE lvc_s_layn.

  DATA: l_node_text TYPE lvc_value.

  CLEAR l_layout_node.

  IF l_secuencia > 1. " Si es bobina partida, mostrar icono "ICON_COMPARE"
    l_layout_node-n_image = '@46@'.
  ENDIF.


*  l_node_text = |@@ Cambio de ancho|.
  CALL METHOD g_alv_tree->add_node
    EXPORTING
      i_relat_node_key = l_next_key
      i_relationship   = cl_gui_column_tree=>relat_last_child
      is_outtab_line   = l_tree
      i_node_text      = l_node_text
      is_node_layout   = l_layout_node
    IMPORTING
      e_new_node_key   = l_last_key.


ENDFORM.                    " ADD_LEAF
*&---------------------------------------------------------------------*
*&      Form  CHANGE_TOOLBAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM change_toolbar .

  CALL METHOD g_alv_tree->get_toolbar_object
    IMPORTING
      er_toolbar = g_toolbar.

  CHECK NOT g_toolbar IS INITIAL. "could happen if you do not use the
  "standard toolbar


  CALL METHOD g_toolbar->add_button
    EXPORTING
      fcode     = ''
      icon      = ''
      butn_type = cntb_btype_sep.

* add Standard Button to toolbar (for Delete Subtree)
  CALL METHOD g_toolbar->add_button
    EXPORTING
      fcode     = 'DELETE'
      icon      = '@11@' "'ICON_DELETE'
      butn_type = cntb_btype_button
      text      = 'Eliminar lote'
      quickinfo = text-006.   "Delete subtree


* add Standard Button to toolbar (for Delete Subtree)
  CALL METHOD g_toolbar->add_button
    EXPORTING
      fcode     = 'REIMPRIMIR'
      icon      = '@0X@' "'ICON_PRINT'
      butn_type = cntb_btype_button
      text      = 'Reimprimir etiqueta'
      quickinfo = text-007.   "Delete subtree

* add Standard Button to toolbar (for Delete Subtree)
*  CALL METHOD g_toolbar->add_button
*    EXPORTING
*      fcode     = 'OBSBOBINA'
*      icon      = '@0S@' "'ICON_PRINT'
*      butn_type = cntb_btype_button
*      text      = 'Observ.bobinadora'
*      quickinfo = text-007.   "Delete subtree


* La visualización del botón de Reimpresión dependerá del flag de activación en ZTPP0032.
*  DATA: l_flag TYPE flag.
*  CLEAR l_flag.

* add Standard Button to toolbar (for Delete Subtree)
  CALL METHOD g_toolbar->add_button
    EXPORTING
      fcode     = 'REIMPOBS'
      icon      = '@0X@' "'ICON_PRINT'
      butn_type = cntb_btype_button
      text      = 'Reimp etiq observ'
      quickinfo = text-007.   "Delete subtree

  CALL METHOD g_toolbar->add_button
    EXPORTING
      fcode     = 'DEFBOBINA'
      icon      = '@0K@'
      butn_type = cntb_btype_button
      text      = 'Defc/Obsv bobina'
      quickinfo = text-037.


ENDFORM.                    " CHANGE_TOOLBAR
*&---------------------------------------------------------------------*
*&      Form  REGISTER_EVENTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM register_events .

  DATA: lt_events        TYPE        cntl_simple_events,
        l_event          TYPE        cntl_simple_event,
        l_event_receiver TYPE REF TO lcl_toolbar_event_receiver.

* Frontend registration: do not forget to register (for ALV Tree
* mandatory) tree events.

*................................................................
* Tree events:
* The following four tree events registers ALV Tree in the constructor
* method itself.
*    - cl_gui_column_tree=>eventid_expand_no_children
* (needed to load data to frontend when a user expands a node)
*    - cl_gui_column_tree=>eventid_header_context_men_req
* (needed for header context menu)
*    - cl_gui_column_tree=>eventid_header_click
* (allows selection of columns (only when item selection activated))
*   - cl_gui_column_tree=>eventid_item_keypress
* (needed for F1-Help (only when item selection activated))

* Nevertheless you have to provide their IDs again if you register
* additional events with SET_REGISTERED_EVENTS (see below).
* To do so, call first method  GET_REGISTERED_EVENTS (this way,
* all already registered events remain registered, even your own):
  CALL METHOD g_alv_tree->get_registered_events
    IMPORTING
      events = lt_events.


  l_event-eventid = cl_gui_column_tree=>eventid_node_double_click.
  APPEND l_event TO lt_events.

* (If you do not these events will be deregistered!!!).
* You do not have to register events of the toolbar again.
* define the events which will be passed to the backend

* Toolbar events:
* Note that the instance of your ALV Tree Control registers the toolbar
* events on frontend as application events (within the constructor).
* You do not have to register events of the toolbar again.

* register events on frontend
  CALL METHOD g_alv_tree->set_registered_events
    EXPORTING
      events                    = lt_events
    EXCEPTIONS
      cntl_error                = 1
      cntl_system_error         = 2
      illegal_event_combination = 3.
  IF sy-subrc <> 0.
    MESSAGE x208(00) WITH 'ERROR'.                          "#EC NOTEXT
  ENDIF.
*-------------------------------------------------------------------
* §6. Register toolbar events on backend (ABAP Objects
*     event handling).
* Note that the instance of your ALV Tree Control registers the toolbar
* events on frontend as application events (within the constructor).
  CREATE OBJECT l_event_receiver.
  SET HANDLER l_event_receiver->on_function_selected FOR g_toolbar.
  SET HANDLER l_event_receiver->handle_node_double_click FOR g_alv_tree.
ENDFORM.                    " REGISTER_EVENTS
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQ_BOBINA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_CUERPO  text
*----------------------------------------------------------------------*
FORM reimprimir_etiq_bobina  USING    wa_cuerpo TYPE zepp0027_cuerpo.

  DATA: ls_bobina TYPE zspp_etiq_bobina,
        lv_ebeln  TYPE ebeln,
        lv_pos    TYPE kdpos.


  ls_bobina-matnr = wa_cuerpo-matnr.
  ls_bobina-werks = gv_werks.
  ls_bobina-lgort =
  ls_bobina-charg = wa_cuerpo-charg.
  ls_bobina-aufnr = wa_cuerpo-aufnr.



  SELECT SINGLE aufk~zzkunnr1 aufk~zzebeln1 aufk~zzebelp1
    INTO (ls_bobina-kunnr, lv_ebeln, lv_pos)
    FROM aufk
    INNER JOIN afko ON afko~aufnr = aufk~aufnr
    WHERE aufk~aufnr = wa_cuerpo-aufnr.

  ls_bobina-pedido =  lv_ebeln.
  ls_bobina-posicion = lv_pos.


  ls_bobina-peso            = wa_cuerpo-menge.
  ls_bobina-diametro        = wa_cuerpo-diametro.
  ls_bobina-fec_fabricacion = sy-datum .
  ls_bobina-longitud        = wa_cuerpo-metros.


  ls_bobina-werks_ent = gv_werks.
  ls_bobina-arbpl_ent = gv_arbpl.

* Buscar el material actual (por si hay un cambio de ancho), en kg. en stock
  SELECT SINGLE matnr
    FROM mchb
    INTO @DATA(l_ult_matnr)
    WHERE charg = @ls_bobina-charg AND
          werks = @gv_werks AND
          ( lgort = '1040' OR lgort = '4001' ) AND
          clabs NE 0.

  IF sy-subrc = 0 AND l_ult_matnr IS NOT INITIAL.
    ls_bobina-matnr = l_ult_matnr.
  ENDIF.

* Forzar impresión manual para la reimpresión.
  IF g_flag_bob_auto = ' '.
    SELECT SINGLE padest
      INTO @DATA(l_padest_manual)
      FROM ztpp0008
      WHERE werks = @gv_werks AND
            arbpl = @gv_arbpl AND
            cont  = 1. " Obtener impresora manual siempre

    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA'
      EXPORTING
        i_bobina     = ls_bobina
        i_reimp_peso = 'X'
        i_padest     = l_padest_manual
        i_nodialog   = ' '.
  ELSE.
    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA'
      EXPORTING
        i_bobina     = ls_bobina
        i_reimp_peso = 'X'.

  ENDIF.

ENDFORM.                    " IMPRIMIR_ETIQ_BOBINA
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQ_PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_CUERPO  text
*----------------------------------------------------------------------*
FORM imprimir_etiq_pulper_btn_reimp  USING wa_cuerpo TYPE zepp0027_cuerpo.

  DATA: ls_bobina_pulper TYPE zspp_etiq_bobina_pulper.
  DATA: lv_aufnr_int TYPE aufnr,
        lv_ebeln     TYPE ebeln,
        lv_pos       TYPE kdpos.





  SELECT SINGLE matnr INTO ls_bobina_pulper-matnr
   FROM mseg
   WHERE mblnr = wa_cuerpo-mblnr AND
         mjahr = wa_cuerpo-mjahr.


  ls_bobina_pulper-werks           = gv_werks.
  ls_bobina_pulper-charg           = wa_cuerpo-charg.
  ls_bobina_pulper-aufnr           = wa_cuerpo-aufnr.
  ls_bobina_pulper-peso            = wa_cuerpo-menge.
  ls_bobina_pulper-diametro        = wa_cuerpo-diametro.
  ls_bobina_pulper-fec_fabricacion = sy-datum .
  ls_bobina_pulper-longitud        = wa_cuerpo-metros.

  SELECT SINGLE afko~plnbez aufk~zzkunnr1 aufk~zzebeln1 aufk~zzebelp1
INTO (ls_bobina_pulper-plnbez, ls_bobina_pulper-kunnr, lv_ebeln, lv_pos)
FROM aufk
INNER JOIN afko ON afko~aufnr = aufk~aufnr
WHERE aufk~aufnr = wa_cuerpo-aufnr.

  ls_bobina_pulper-pedido =  lv_ebeln.
  ls_bobina_pulper-posicion = lv_pos.

  CONCATENATE ls_bobina_pulper-matnr ls_bobina_pulper-charg INTO ls_bobina_pulper-cod_barras.

  CALL FUNCTION 'ZMFPP_ETIQ_BOBINA_PULPER'
    EXPORTING
      i_bobina = ls_bobina_pulper.
ENDFORM.                    " IMPRIMIR_ETIQ_PULPER
*&---------------------------------------------------------------------*
*&      Form  ELIMINAR_NOTIFICACIONES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_NODO_SEL  text
*----------------------------------------------------------------------*
FORM eliminar_notificaciones  USING  wa_cuerpo TYPE zepp0027_cuerpo
                              CHANGING lv_error.


*----------------------------------------------------------------------*
*eliminará la notificación seleccionada anulando:
*  o  El documento de material de alta de bobina:
*      #  Bobina normal: el documento de material que produce el alta
*                de la bobina buena (movimiento 101)
*      #  Bobina pulper (P): el documento de material que produce el alta
*                de la bobina pulper (movimiento 531)
*      #  Bobina a reprocesar (R): el documento de material que produce el
*                alta de la bobina a reprocesar (movimiento 101) en el
*                almacén 4001.
*  o  El documento de material que produce el consumo de rollo (movimiento 261)
*  o  Las notificaciones de los tiempos.
*  o  Las características de clasificación del lote correspondientes al peso,
*     longitud, diámetro y empalmes.
*----------------------------------------------------------------------*

** Eliminamos el documento de material de alta de bobina
  PERFORM eliminar_doc_mat_alta_bob USING wa_cuerpo-mblnr
                                          wa_cuerpo-mjahr
                                          wa_cuerpo-menge
                                          wa_cuerpo-mblnr_309
                                          wa_cuerpo-mjahr_309
                                    CHANGING lv_error
                                             gv_kg_producir
                                             gv_kg_consum
                                             gv_diferencia
                                             gv_kg_producir_c
                                             gv_kg_consum_c
                                             gv_diferencia_c
                                             gv_diferencia_sem.
  IF lv_error IS INITIAL.
**  Eliminamos el documento de material que produce el consumo de rollo (movimiento 261)
    PERFORM eliminar_doc_mat_cons_rol USING wa_cuerpo-aufnr
                                            gv_lote
                                            wa_cuerpo-menge
                                      CHANGING lv_error
                                               gv_kg_producir
                                               gv_kg_consum
                                               gv_diferencia
                                               gv_kg_producir_c
                                               gv_kg_consum_c
                                               gv_diferencia_c
                                               gv_diferencia_sem.
    IF lv_error IS INITIAL.
**    Las notificaciones de los tiempos.
      PERFORM eliminar_tiempos USING wa_cuerpo-aufnr
                                     wa_cuerpo-menge
                               CHANGING lv_error.

*      IF lv_error IS INITIAL.
*      Las características de clasificación del lote correspondientes al peso,
*       longitud, diámetro y empalmes.
      PERFORM eliminar_clasificacion USING  wa_cuerpo-matnr
                                            wa_cuerpo-charg
                                            wa_cuerpo-tipo
                                     CHANGING lv_error.

      CLEAR: lv_error.
*      ENDIF.
    ENDIF.
  ENDIF.


  IF lv_error IS NOT INITIAL.
    DATA: lv_extnumber TYPE balnrext.

    lv_extnumber = wa_cuerpo-aufnr .
    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = gt_messages[]
        extnumber = lv_extnumber.

  ENDIF.


ENDFORM.                    " ELIMINAR_NOTIFICACIONES
*&---------------------------------------------------------------------*
*&      Form  LEER_LOTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM leer_lote .

  DATA: lv_charg TYPE         charg_d,
        wa_mch1  TYPE         mch1,
        t_aufm   TYPE         tty_aufm,
        wa_aufm  TYPE LINE OF tty_aufm.

  DATA: t_anulaciones  TYPE         tty_anulaciones,
        wa_anulaciones TYPE LINE OF tty_anulaciones.

  DATA: lv_bwart TYPE bwart,
        lv_ind   TYPE sy-tabix.


  DATA: lv_object            TYPE         objnum,
        lt_alloc_values_num  TYPE         tt_bapi1003_alloc_values_num,
        wa_num               TYPE LINE OF tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE         tt_bapi1003_alloc_values_char,
        wa_char              TYPE LINE OF tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE         tt_bapi1003_alloc_values_curr,
        lt_return            TYPE         bapiret2_tab.


  DATA: lv_kg_producir TYPE i,
        lv_kg_consum   TYPE i,
        lv_diferencia  TYPE i,
        lv_tornadas    TYPE /isdfps/de_lm_cnt_value_txt,
        lv_tornadas_1  TYPE i.

  DATA: lv_length TYPE i,
        lv_dif    TYPE i.

  DATA: wa_jest  TYPE jest,
        lv_objnr TYPE jest-objnr.

  DATA: lv_dec TYPE c LENGTH 10.

*************************************************************************
**                    datos cabecera de la dynpro                  ******
*************************************************************************
  CLEAR: gv_lote, gv_aunfr, gv_aunfr_mostrar, gv_matnr, gv_matnr_mostrar,
         gv_maktx, gv_kg_producir, gv_kg_consum, gv_diferencia,
         gv_kg_producir_c, gv_kg_consum_c, gv_diferencia_c,
         gv_diferencia_sem .
  CONDENSE gv_cb NO-GAPS.

  lv_length = strlen( gv_cb ).

  IF lv_length <= 10.
    gv_lote = gv_cb.
  ELSE.
    lv_dif = lv_length - 10.
    gv_lote = gv_cb+lv_dif(10).
  ENDIF.

* verificamos que el lote existe
  SELECT SINGLE * FROM mch1
    INTO wa_mch1
    WHERE charg = gv_lote.

  IF sy-subrc <> 0.
    lv_charg = gv_lote.
    CLEAR: gv_lote.
    MESSAGE e007(zpp) WITH lv_charg.
  ELSE.
*   Cuando se lea un lote de rollo, se informarán los campos
*   correspondientes a OF de rollo, material y descripción del rollo y
*   kg fabricados, y el campo “Lote rollo” quedará no editable.
    CLEAR: t_aufm, t_anulaciones.
    REFRESH: t_aufm, t_anulaciones.

    SELECT aufnr matnr charg menge bwart lgort mblnr mjahr FROM aufm
      INTO TABLE t_aufm
      WHERE werks = gv_werks AND
            charg = gv_lote.

    IF t_aufm[] IS NOT INITIAL.

      READ TABLE t_aufm INTO wa_aufm WITH KEY bwart = '101'.


      SELECT matnr charg menge bwart mblnr mjahr APPENDING CORRESPONDING FIELDS OF TABLE t_aufm
      FROM mseg WHERE werks = gv_werks AND
      lgort = wa_aufm-lgort AND
      matnr = wa_mch1-matnr AND
      charg = gv_lote AND
      bwart IN ('309','310').
      IF sy-subrc EQ 0.
        SORT t_aufm BY mblnr ASCENDING .
        DELETE ADJACENT DUPLICATES FROM t_aufm COMPARING mblnr.
      ENDIF.
* SAT -   7000015845, Ticket_##_42935
*      SELECT aufnr matnr charg menge bwart mblnr mjahr smbln FROM mseg
*        INTO TABLE t_anulaciones
*        FOR ALL ENTRIES IN t_aufm
*        WHERE werks = gv_werks AND
*              charg = gv_lote AND
*              smbln = t_aufm-mblnr.
*
*      IF t_anulaciones[] IS NOT INITIAL.
*        LOOP AT t_aufm INTO wa_aufm.
*          CLEAR: lv_bwart, lv_ind, wa_anulaciones.
*
*          lv_bwart = wa_aufm-bwart + 1.
*          lv_ind = sy-tabix.
*          READ TABLE t_anulaciones INTO wa_anulaciones WITH KEY bwart = lv_bwart
*                                                                smbln = wa_aufm-mblnr.
*          IF sy-subrc = 0.
*            DELETE t_aufm INDEX lv_ind.
*            DELETE t_aufm WHERE mblnr = wa_anulaciones-mblnr AND
*                                mjahr = wa_anulaciones-mjahr.
*          ENDIF.
*        ENDLOOP.
*      ENDIF.
*SAT - 7000015845, Ticket_##_42935

      READ TABLE t_aufm INTO wa_aufm WITH KEY bwart = '101'.
      IF sy-subrc = 0.
        gv_aunfr = wa_aufm-aufnr.

        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
          EXPORTING
            input  = wa_aufm-aufnr
          IMPORTING
            output = gv_aunfr_mostrar.


        SELECT SINGLE plnbez INTO gv_matnr
          FROM afko
          WHERE aufnr = gv_aunfr.

        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
          EXPORTING
            input  = gv_matnr
          IMPORTING
            output = gv_matnr_mostrar.

        IF gv_matnr IS NOT INITIAL.
          SELECT SINGLE maktx FROM makt
            INTO gv_maktx
            WHERE matnr = gv_matnr AND
                  spras = sy-langu.
        ENDIF.
      ENDIF.

      LOOP AT t_aufm INTO wa_aufm.
        CASE wa_aufm-bwart.
          WHEN '101'.
            gv_kg_producir = gv_kg_producir + wa_aufm-menge.

          WHEN '102'. "CGIJON - SAT 7000018982 - Ticket 46871
            gv_kg_producir = gv_kg_producir - wa_aufm-menge.

          WHEN '261' OR '531'." OR '309'."uDefine - se añaden la pareja dw movimientos 309/310
            gv_kg_consum = gv_kg_consum + wa_aufm-menge.

          WHEN '262' OR '532'." OR '310'.
            gv_kg_consum = gv_kg_consum - wa_aufm-menge.
        ENDCASE.
      ENDLOOP.

      gv_diferencia  = gv_kg_producir - gv_kg_consum.

*     pasamos de dec a int
      lv_kg_producir = trunc( gv_kg_producir ).
      lv_kg_consum = trunc( gv_kg_consum ).
      lv_diferencia = trunc( gv_diferencia ).

*     pasamos de int a char
      gv_kg_producir_c = lv_kg_producir.
      gv_kg_consum_c = lv_kg_consum.
      gv_diferencia_c = lv_diferencia.

      CONDENSE gv_kg_producir_c.
      CONDENSE gv_kg_consum_c.
      CONDENSE gv_diferencia_c.

*     sémaforo diferencias
      IF gv_diferencia  > 0 AND gv_diferencia < 3000.
        gv_diferencia_sem = icon_yellow_light."semáforo en verde
      ELSEIF gv_diferencia > 3000.
        gv_diferencia_sem = icon_green_light . "semáforo en amarillo
      ELSEIF gv_diferencia < 3000.
        gv_diferencia_sem = icon_red_light . "semáforo en rojo
      ENDIF.

*     tornadas
      CLEAR: lv_object, lt_alloc_values_num, lt_alloc_values_char,
                       lt_alloc_values_curr, lt_return.
      REFRESH: lt_alloc_values_num, lt_alloc_values_char,
               lt_alloc_values_curr, lt_return.

      CONCATENATE gv_matnr gv_lote INTO lv_object.
      CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
        EXPORTING
          objectkey       = lv_object
          objecttable     = 'MCH1'
          classnum        = 'Z_ROLLO'
          classtype       = '023'
        TABLES
          allocvaluesnum  = lt_alloc_values_num
          allocvalueschar = lt_alloc_values_char
          allocvaluescurr = lt_alloc_values_curr
          return          = lt_return.


* Validamos si Decisión de Empleo = 'P'
      CLEAR g_dec_empleo_p.
      TRY.
          IF lt_alloc_values_char[ charact = 'LOBM_UDCODE' ]-value_char = 'DE       P' .
            g_dec_empleo_p = 'X'.

          ENDIF.
        CATCH cx_root .
      ENDTRY.


      READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_TORNADAS'.
      IF sy-subrc = 0.
        CALL FUNCTION '/ISDFPS/LM_CONVERT_FLTP_TO_C'
          EXPORTING
            i_unit   = 'ST'
            i_dec    = 15
            i_input  = wa_num-value_from
          IMPORTING
            e_output = lv_tornadas.

        CONDENSE lv_tornadas.
        SPLIT lv_tornadas AT ',' INTO gv_tornadas_c lv_dec.

      ENDIF.

    ENDIF.

*************************************************************************
**                    datos cuerpo de la dynpro                    ******
*************************************************************************
    IF gv_aunfr IS NOT INITIAL.
*     buscamos las órdenes de bobina donde se encuentra la orden de rollo
      CLEAR: gt_ordenes_bobina, gt_cuerpo.
      REFRESH: gt_ordenes_bobina, gt_cuerpo.

      SELECT aufnr zzebeln1 zzebelp1 zzkunnr1 zzsecuencia FROM aufk
        INTO TABLE gt_ordenes_bobina
        WHERE zzaufnr_rollo = gv_aunfr AND
              auart = 'ZI02'
        ORDER BY aufnr.

*     Nos quedamos con las que están en estatus liberada
      LOOP AT gt_ordenes_bobina INTO wa_ordenes_bobina.
        CLEAR: lv_objnr, wa_jest.

        CONCATENATE 'OR' wa_ordenes_bobina-aufnr INTO lv_objnr.

        SELECT SINGLE * FROM jest
          INTO wa_jest
          WHERE objnr = lv_objnr AND
                stat = 'I0002' AND
                inact = ''.

        IF sy-subrc = 0.
          CLEAR: wa_header, wa_cuerpo.

          wa_header-aufnr = wa_ordenes_bobina-aufnr.
          wa_header-zebeln1 = wa_ordenes_bobina-zebeln1.
          wa_header-zebelp1 = wa_ordenes_bobina-zebelp1.
          wa_header-zkunnr1 = wa_ordenes_bobina-zkunnr1.
          wa_header-zzsecuencia = wa_ordenes_bobina-zzsecuencia.

          SELECT SINGLE name1 FROM kna1
            INTO wa_header-name1
            WHERE kunnr = wa_header-zkunnr1.

          SELECT SINGLE plnbez INTO wa_header-plnbez
            FROM afko
            WHERE aufnr = wa_ordenes_bobina-aufnr.

          SELECT SINGLE maktx FROM makt
            INTO wa_header-maktx
            WHERE matnr = wa_header-plnbez AND
              spras = sy-langu.

          CLEAR: t_aufm. REFRESH: t_aufm.

          SELECT aufnr matnr charg menge bwart mblnr mjahr FROM aufm
            INTO CORRESPONDING FIELDS OF TABLE t_aufm
            WHERE werks = gv_werks AND
                  aufnr = wa_ordenes_bobina-aufnr AND
                  ( bwart = '101' OR bwart = '531' ).


          IF t_aufm[] IS NOT INITIAL.
            CLEAR: t_anulaciones. REFRESH: t_anulaciones.
            SELECT aufnr matnr charg menge bwart mblnr mjahr smbln FROM mseg
                  INTO CORRESPONDING FIELDS OF TABLE t_anulaciones
                  FOR ALL ENTRIES IN t_aufm
                  WHERE werks = gv_werks     AND
                        charg = t_aufm-charg AND
                        smbln = t_aufm-mblnr AND
                        mjahr = t_aufm-mjahr.

            IF t_anulaciones[] IS NOT INITIAL.
              LOOP AT t_aufm INTO wa_aufm.
                CLEAR: lv_bwart, lv_ind, wa_anulaciones.

                lv_bwart = wa_aufm-bwart + 1.
                lv_ind = sy-tabix.
                READ TABLE t_anulaciones INTO wa_anulaciones WITH KEY bwart = lv_bwart
                                                                smbln = wa_aufm-mblnr.
                IF sy-subrc = 0.
                  DELETE t_aufm INDEX lv_ind.
                ENDIF.
              ENDLOOP.
            ENDIF.

            SORT  t_aufm BY aufnr matnr charg ASCENDING.
          ENDIF.

          APPEND wa_header TO gt_header.

          MOVE-CORRESPONDING wa_header TO wa_cuerpo.

          LOOP AT t_aufm INTO wa_aufm.
            wa_cuerpo-charg = wa_aufm-charg.
            wa_cuerpo-menge = wa_aufm-menge.
            wa_cuerpo-bwart = wa_aufm-bwart.
            wa_cuerpo-matnr = wa_aufm-matnr.

            wa_cuerpo-mblnr = wa_aufm-mblnr.
            wa_cuerpo-mjahr = wa_aufm-mjahr.

            CLEAR: lv_object, lt_alloc_values_num, lt_alloc_values_char,
                   lt_alloc_values_curr, lt_return.
            REFRESH: lt_alloc_values_num, lt_alloc_values_char,
                     lt_alloc_values_curr, lt_return.

            CONCATENATE wa_aufm-matnr wa_aufm-charg INTO lv_object.

            IF wa_aufm-bwart = '101'.
              CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
                EXPORTING
                  objectkey       = lv_object
                  objecttable     = 'MCH1'
                  classnum        = 'Z_BOBINA'
                  classtype       = '023'
                TABLES
                  allocvaluesnum  = lt_alloc_values_num
                  allocvalueschar = lt_alloc_values_char
                  allocvaluescurr = lt_alloc_values_curr
                  return          = lt_return.


              READ TABLE lt_alloc_values_char INTO wa_char WITH KEY charact = 'Z_LOTE_ORIGEN'.
              CHECK sy-subrc = 0 AND wa_char-value_char = gv_lote.

              READ TABLE lt_alloc_values_char INTO wa_char WITH KEY charact = 'Z_REPROCESO'.
              IF sy-subrc = 0.
                wa_cuerpo-tipo = 'R'.
                wa_cuerpo-tipo_sem = '@09@'. "Yellow light
              ELSE.
                wa_cuerpo-tipo = ''.
                wa_cuerpo-tipo_sem = '@08@'." Green light .
              ENDIF.

              READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_DIAMETRO'.
              IF sy-subrc = 0.
                wa_cuerpo-diametro = wa_num-value_from. "Z_DIAMETRO
              ENDIF.


              READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_EMPALMES'.
              IF sy-subrc = 0.
                wa_cuerpo-empalmes = wa_num-value_from. "Z_EMPALMES
              ENDIF.


              READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_LONGITUD_B'.
              IF sy-subrc = 0.
                wa_cuerpo-metros = wa_num-value_from. "Z_LONGITUD_B
              ENDIF.

            ELSEIF wa_aufm-bwart = '309'.
              wa_cuerpo-mblnr_309 = wa_aufm-mblnr.
              wa_cuerpo-mjahr_309 = wa_aufm-mjahr.

            ELSEIF wa_aufm-bwart = '531'.

              CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
                EXPORTING
                  objectkey       = lv_object
                  objecttable     = 'MCH1'
                  classnum        = 'Z_BOBINA_PULPER'
                  classtype       = '023'
                TABLES
                  allocvaluesnum  = lt_alloc_values_num
                  allocvalueschar = lt_alloc_values_char
                  allocvaluescurr = lt_alloc_values_curr
                  return          = lt_return.

              READ TABLE lt_alloc_values_char INTO wa_char WITH KEY charact = 'Z_LOTE_ORIGEN'.
              CHECK sy-subrc = 0 AND wa_char-value_char = gv_lote.
              wa_cuerpo-tipo = 'P'.
              wa_cuerpo-tipo_sem = '@0A@'. "Red light
              wa_cuerpo-diametro = ''. "Z_EMPALMES

              READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_LONGITUD_B'.
              IF sy-subrc = 0.
                wa_cuerpo-metros = wa_num-value_from. "Z_LONGITUD_B
              ENDIF.

              READ TABLE lt_alloc_values_num INTO wa_num WITH KEY charact = 'Z_DIAMETRO'.
              IF sy-subrc = 0.
                wa_cuerpo-diametro = wa_num-value_from.
              ENDIF.
            ENDIF.

* 12/04/2021 - 57299 - CMS - Revisar si el lote tiene mov.309(cambio de ancho/material)
            SELECT matnr , charg , menge , bwart , mblnr , mjahr
              INTO TABLE @DATA(lt_mov309_310)
              FROM mseg
              WHERE werks = @gv_werks AND
                    charg = @wa_cuerpo-charg AND
                    bwart IN ('309','310').

            IF line_exists( lt_mov309_310[ bwart = '309' ] ) AND
               NOT line_exists( lt_mov309_310[ bwart = '310' ] ).

              wa_cuerpo-mblnr_309 = lt_mov309_310[ bwart = '309' ]-mblnr.
              wa_cuerpo-mjahr_309 = lt_mov309_310[ bwart = '309' ]-mjahr.
              wa_cuerpo-tipo_sem = '@UF@'. " Cambio de ancho
            ELSE.
              CLEAR:   wa_cuerpo-mblnr_309 , wa_cuerpo-mjahr_309.
            ENDIF.

            APPEND wa_cuerpo TO gt_cuerpo.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Leer datos de defectos para mostrar o no el bóton de visualizacion de Defectos.

  DATA: l_matnr TYPE matnr,
        l_aufnr TYPE aufnr.

  l_matnr = |{ gv_matnr_mostrar ALPHA = IN }|.
  l_aufnr = |{ gv_aunfr_mostrar ALPHA = IN }|.

  SELECT SINGLE *
FROM ztpp0030
INTO  @DATA(gs_ztpp0030)
WHERE aufnr = @l_aufnr AND
      matnr = @l_matnr AND
      charg = @gv_lote.
  IF sy-subrc = 0.
*    IF gs_ztpp0030-flag_defectos = 'X'.
*      gw_mostrar_def = abap_true.
*    else.
*      gw_mostrar_def = abap_false.
*    ENDIF.
  ENDIF.


ENDFORM.                    " LEER_LOTE
*&---------------------------------------------------------------------*
*&      Form  ELIMINAR_CLASIFICACION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_CUERPO_MATNR  text
*      -->P_WA_CUERPO_CHARG  text
*----------------------------------------------------------------------*
FORM eliminar_clasificacion  USING    p_matnr TYPE matnr
                                      p_charg TYPE charg_d
                                      p_tipo
                             CHANGING lv_error.

  DATA: l_objkey           TYPE                   objnum,
        lv_classnum        TYPE                   bapi1003_key-classnum,
        lt_allocvaluesnum  TYPE STANDARD TABLE OF bapi1003_alloc_values_num WITH HEADER LINE,
        wa_num             TYPE                   bapi1003_alloc_values_num,
        lt_allocvalueschar TYPE STANDARD TABLE OF bapi1003_alloc_values_char WITH HEADER LINE,
        lt_allocvaluescurr TYPE STANDARD TABLE OF bapi1003_alloc_values_curr WITH HEADER LINE,
        t_return           TYPE TABLE OF          bapiret2,
        wa_return          TYPE                   bapiret2.

  DATA: lv_matnr_pulper TYPE matnr.

  DATA: lv_extnumber TYPE balnrext.


  CLEAR: t_return.

  IF p_tipo = 'P'.
    lv_matnr_pulper = '2001764'.

    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = lv_matnr_pulper
      IMPORTING
        output = lv_matnr_pulper.

    CONCATENATE lv_matnr_pulper  p_charg INTO l_objkey.
  ELSE.
*    CONCATENATE p_matnr p_charg INTO l_objkey.
    l_objkey = |{ p_matnr ALPHA = IN }{ p_charg ALPHA = IN }|.
  ENDIF.

  CASE p_tipo.
    WHEN ' ' OR 'R'.
      lv_classnum  = 'Z_BOBINA'.

    WHEN 'P'.
      lv_classnum  = 'Z_BOBINA_PULPER'.
  ENDCASE.

  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
    EXPORTING
      objectkey       = l_objkey
      objecttable     = 'MCH1'
      classnum        = lv_classnum
      classtype       = '023'
    TABLES
      allocvaluesnum  = lt_allocvaluesnum
      allocvalueschar = lt_allocvalueschar
      allocvaluescurr = lt_allocvaluescurr
      return          = t_return.


  READ TABLE lt_allocvaluesnum INTO wa_num WITH KEY charact = 'Z_DIAMETRO'.
  IF sy-subrc = 0.
    CLEAR: wa_num-value_from.
    MODIFY lt_allocvaluesnum FROM wa_num INDEX sy-tabix.
  ENDIF.


  READ TABLE lt_allocvaluesnum INTO wa_num WITH KEY charact = 'Z_PESO'.
  IF sy-subrc = 0.
    CLEAR: wa_num-value_from.
    MODIFY lt_allocvaluesnum FROM wa_num INDEX sy-tabix.
  ENDIF.


  READ TABLE lt_allocvaluesnum INTO wa_num WITH KEY charact = 'Z_EMPALMES'.
  IF sy-subrc = 0.
    CLEAR: wa_num-value_from.
    MODIFY lt_allocvaluesnum FROM wa_num INDEX sy-tabix.
  ENDIF.


  READ TABLE lt_allocvaluesnum INTO wa_num WITH KEY charact = 'Z_LONGITUD_B'.
  IF sy-subrc = 0.
    CLEAR: wa_num-value_from. "Z_LONGITUD_B
    MODIFY lt_allocvaluesnum FROM  wa_num INDEX sy-tabix.
  ENDIF.

* 28/10/2021 - CMS-69264-HPAP-PP ZPP0032 Notif.bob.borrar DE al anular lote
  ASSIGN lt_allocvalueschar[ charact = 'LOBM_UDCODE' ] TO FIELD-SYMBOL(<fs_caract_de>).
  IF sy-subrc = 0.
    CLEAR: <fs_caract_de>-value_char , <fs_caract_de>-value_neutral.
  ENDIF.

  CALL FUNCTION 'BAPI_OBJCL_CHANGE'
    EXPORTING
      objectkey          = l_objkey
      objecttable        = 'MCH1'
      classnum           = lv_classnum
      classtype          = '023'
    TABLES
      allocvaluesnumnew  = lt_allocvaluesnum
      allocvaluescharnew = lt_allocvalueschar
      allocvaluescurrnew = lt_allocvaluescurr
      return             = t_return.

  READ TABLE t_return INTO wa_return WITH KEY type = 'E'.
  IF sy-subrc = 0.
    lv_error = 'X'.

* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

    gt_messages = t_return.

    CLEAR lv_extnumber.
    CONCATENATE 'Eliminar Clasif. Lote'  p_charg 'del material' p_matnr
      INTO lv_extnumber SEPARATED BY space.

    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = gt_messages[]
        extnumber = lv_extnumber.


*   guardar los en SLG1
    CALL FUNCTION 'ZMONTAR_LOG_SLG1'
      EXPORTING
        i_extnumber = ''
        i_object    = 'ZPP'
        i_subobject = sy-tcode
      TABLES
        t_return    = t_return.

  ELSE. " proceso OK

* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.


  ENDIF.
ENDFORM.                    " ELIMINAR_CLASIFICACION
*&---------------------------------------------------------------------*
*&      Form  ELIMINAR_TIEMPOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM eliminar_tiempos USING p_aufnr
                            p_menge
                      CHANGING lv_error.

  DATA: lv_postg_date TYPE          bapi_pi_confirm-postg_date,
        t_return_1    TYPE TABLE OF bapiret1,
        wa_return_1   TYPE          bapiret1.

  DATA: wa_detail        TYPE          bapi_pi_confirm,
        t_goodsmovements TYPE TABLE OF bapi2017_gm_item_show,
        t_failedgmoves   TYPE TABLE OF bapi_coru_fgm.


  DATA: wa_return        TYPE          bapiret1,
        t_order_range    TYPE TABLE OF bapi_pi_orderrange,
        wa_order_range   TYPE          bapi_pi_orderrange,
        t_confirmations  TYPE TABLE OF bapi_pi_conf_key,
        wa_confirmations TYPE          bapi_pi_conf_key.

  DATA: lv_extnumber TYPE balnrext.


* obtenemos las notificaciones de tiempo
  wa_order_range-sign = 'I'.
  wa_order_range-option = 'EQ'.
  wa_order_range-low = p_aufnr.
  APPEND wa_order_range TO t_order_range.

  CALL FUNCTION 'BAPI_PROCORDCONF_GETLIST'
* EXPORTING
*   PHASE               =
*   SEC_RESOURCE        =
    IMPORTING
      return        = wa_return
    TABLES
      order_range   = t_order_range
*     CONF_RANGE    =
      confirmations = t_confirmations.


* borramos las notificaciones de tiempo
  LOOP AT t_confirmations INTO wa_confirmations WHERE reversed = ''.
    CLEAR: wa_return_1, wa_detail, t_goodsmovements, t_failedgmoves.
    REFRESH: t_goodsmovements, t_failedgmoves.

    CALL FUNCTION 'BAPI_PROCORDCONF_GETDETAIL'
      EXPORTING
        confirmation        = wa_confirmations-conf_no
        confirmationcounter = wa_confirmations-conf_cnt
      IMPORTING
        return              = wa_return_1
        conf_detail         = wa_detail
      TABLES
        goodsmovements      = t_goodsmovements
        failedgmoves        = t_failedgmoves.

    IF wa_return_1-type <> 'E' AND wa_detail-yield = p_menge.

      CLEAR: wa_return_1.

      CALL FUNCTION 'BAPI_PROCORDCONF_CANCEL'
        EXPORTING
          confirmation        = wa_confirmations-conf_no
          confirmationcounter = wa_confirmations-conf_cnt
*         POSTG_DATE          =
*         CONF_TEXT           =
        IMPORTING
          return              = wa_return_1.

      IF wa_return_1-type <> 'E'.

        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
          EXPORTING
            wait = 'X'.

        EXIT.

      ELSE.
        lv_error  = 'X'.
* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.
        CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

        MOVE-CORRESPONDING wa_return_1 TO gs_messages.
        APPEND gs_messages TO gt_messages.

        CLEAR lv_extnumber.
        CONCATENATE 'Notif.Tiempo' wa_confirmations-conf_no wa_confirmations-conf_cnt
        INTO lv_extnumber SEPARATED BY space.

        CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
          EXPORTING
            objeto    = 'ZPP'
            subobjeto = sy-tcode
            mensajes  = gt_messages[]
            extnumber = lv_extnumber.

*       guardar los en slg1
        CALL FUNCTION 'ZMONTAR_LOG_SLG1'
          EXPORTING
            i_extnumber = ''
            i_object    = 'ZPP'
            i_subobject = sy-tcode
          TABLES
            t_return    = gt_messages.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " ELIMINAR_TIEMPOS
*&---------------------------------------------------------------------*
*&      Form  ELIMINAR_DOC_MAT_ALTA_BOB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM eliminar_doc_mat_alta_bob  USING mblnr
                                      mjahr
                                      menge
                                      mblnr_309
                                      mjahr_309
                                CHANGING lv_error
                                         p_kg_producir TYPE erfmg
                                         p_kg_consum   TYPE erfmg
                                         p_diferencia  TYPE erfmg
                                         p_kg_producir_c
                                         p_kg_consum_c
                                         p_diferencia_c
                                         p_diferencia_sem.

  DATA: t_return    TYPE TABLE OF bapiret2,
        wa_return   TYPE          bapiret2,
        wa_return_1 TYPE          bapiret1.

  DATA: lv_extnumber TYPE balnrext.

* 12/04/2021 - 57299 - CMS Si se ha hecho cambio de ancho (309), anular primero éste, y luego anular el 101.
  IF mblnr_309 IS NOT INITIAL AND
     mjahr_309 IS NOT INITIAL.

    CALL FUNCTION 'BAPI_GOODSMVT_CANCEL'
      EXPORTING
        materialdocument = mblnr_309
        matdocumentyear  = mjahr_309
      TABLES
        return           = t_return.
    IF NOT  line_exists( t_return[ type = 'E' ] ).
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.
    ELSE.

      lv_error = 'X'.
      APPEND LINES OF  t_return TO gt_messages.
      CLEAR lv_extnumber.
      CONCATENATE 'Doc.cambio ancho(309)' mblnr_309 mjahr_309 INTO lv_extnumber SEPARATED BY space.

      CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
        EXPORTING
          objeto    = 'ZPP'
          subobjeto = sy-tcode
          mensajes  = gt_messages[]
          extnumber = lv_extnumber.

*   guardamos log en SLG1
      CALL FUNCTION 'ZMONTAR_LOG_SLG1'
        EXPORTING
          i_extnumber = ''
          i_object    = 'ZPP'
          i_subobject = sy-tcode
        TABLES
          t_return    = gt_messages.
      EXIT.
    ENDIF.

  ENDIF.


* Anulación del mov.101 del lote bobina
  CALL FUNCTION 'BAPI_GOODSMVT_CANCEL'
    EXPORTING
      materialdocument = mblnr
      matdocumentyear  = mjahr
    TABLES
      return           = t_return.
  READ TABLE t_return INTO wa_return WITH KEY type = 'E'.
  IF sy-subrc <> 0.

* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

  ELSE.
    lv_error = 'X'.

    APPEND LINES OF  t_return TO gt_messages.

    CLEAR lv_extnumber.
    CONCATENATE 'Doc.alta bobina' mblnr mjahr INTO lv_extnumber SEPARATED BY space.

    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = gt_messages[]
        extnumber = lv_extnumber.


*   guardamos log en SLG1
    CALL FUNCTION 'ZMONTAR_LOG_SLG1'
      EXPORTING
        i_extnumber = ''
        i_object    = 'ZPP'
        i_subobject = sy-tcode
      TABLES
        t_return    = gt_messages.
  ENDIF.
ENDFORM.                    " ELIMINAR_DOC_MAT_ALTA_BOB
*&---------------------------------------------------------------------*
*&      Form  ELIMINAR_DOC_MAT_CONS_ROL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM eliminar_doc_mat_cons_rol USING p_aufnr
                                     p_charg
                                     p_menge TYPE menge_d
                               CHANGING lv_error
                                        p_kg_producir TYPE erfmg
                                        p_kg_consum   TYPE erfmg
                                        p_diferencia  TYPE erfmg
                                        p_kg_producir_c
                                        p_kg_consum_c
                                        p_diferencia_c
                                        p_diferencia_sem.

  DATA: lv_mblnr TYPE mblnr,
        lv_mjahr TYPE mjahr,
        lv_ind   TYPE sy-tabix.

  DATA: t_261          TYPE         tty_aufm,
        wa_261         TYPE LINE OF tty_aufm,
        t_anulaciones  TYPE         tty_anulaciones,
        wa_anulaciones TYPE LINE OF tty_anulaciones.

  DATA: lv_extnumber TYPE balnrext.

  DATA: t_return    TYPE TABLE OF bapiret2,
        wa_return   TYPE          bapiret2,
        wa_return_1 TYPE          bapiret1.


  CLEAR: t_261. REFRESH: t_261.
  SELECT aufnr matnr charg menge bwart mblnr mjahr FROM mseg
     INTO CORRESPONDING FIELDS OF TABLE t_261
     WHERE bwart = '261' AND
           werks = gv_werks AND
           charg = p_charg AND
           menge = p_menge AND
           aufnr = p_aufnr.

  IF t_261[] IS NOT INITIAL.
    CLEAR: t_anulaciones. REFRESH: t_anulaciones.
    SELECT aufnr matnr charg menge bwart mblnr mjahr smbln FROM mseg
      INTO CORRESPONDING FIELDS OF TABLE t_anulaciones
      FOR ALL ENTRIES IN t_261
      WHERE bwart = '262' AND
            werks = gv_werks AND
            charg = p_charg AND
            smbln = t_261-mblnr.


    IF t_anulaciones[] IS NOT INITIAL.
      LOOP AT t_261 INTO wa_261.
        lv_ind = sy-tabix.

        READ TABLE t_anulaciones INTO wa_anulaciones WITH KEY smbln = wa_261-mblnr.
        IF sy-subrc = 0.
          DELETE t_261 INDEX lv_ind.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

  IF t_261[] IS NOT INITIAL.

    READ TABLE t_261 INTO wa_261 INDEX 1.

    lv_mblnr = wa_261-mblnr.
    lv_mjahr  = wa_261-mjahr.

    CALL FUNCTION 'BAPI_GOODSMVT_CANCEL'
      EXPORTING
        materialdocument = lv_mblnr
        matdocumentyear  = lv_mjahr
      TABLES
        return           = t_return.
    READ TABLE t_return INTO wa_return WITH KEY type = 'E'.
    IF sy-subrc <> 0.

* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.

      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

*   actualizamos las cantidades de la cabecera de la dynpro
      PERFORM actualizar_cabecera_300 USING p_menge
                                            '262'
                                      CHANGING p_kg_producir
                                               p_kg_consum
                                               p_diferencia
                                               p_kg_producir_c
                                               p_kg_consum_c
                                               p_diferencia_c
                                               p_diferencia_sem .
    ELSE.
      lv_error = 'X'.

* CMS 04-05-2020 60154 Commit anulat fins al final del cicle d'eliminació de bobina.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.


      APPEND LINES OF t_return TO gt_messages.

      CLEAR lv_extnumber.
      CONCATENATE 'Doc.consumo de rollo' lv_mblnr lv_mjahr INTO lv_extnumber
        SEPARATED BY space.

      CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
        EXPORTING
          objeto    = 'ZPP'
          subobjeto = sy-tcode
          mensajes  = gt_messages[]
          extnumber = lv_extnumber.

*     guardamos log en SLG1
      CALL FUNCTION 'ZMONTAR_LOG_SLG1'
        EXPORTING
          i_extnumber = ''
          i_object    = 'ZPP'
          i_subobject = sy-tcode
        TABLES
          t_return    = t_return.
    ENDIF.
  ENDIF.
ENDFORM.                    " ELIMINAR_DOC_MAT_CONS_ROL
*&---------------------------------------------------------------------*
*&      Form  ETIQUETA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM etiqueta .
*----------------------------------------------------------------------*
* realizará la notificación de una bobina en los términos actuales,
* es decir, alta de bobina, notificación de tiempos e impresión de
* etiqueta de bobina (funcionalidad ya existente en la transacción
* ZPP0012/22/23, alta de bobina)
*----------------------------------------------------------------------*

  DATA: lv_error     TYPE xfeld,
        lv_peso(15)  TYPE c,
        lv_text(400) TYPE c,
        lv_answer    TYPE c,
        lt_param     LIKE spar OCCURS 0.


  DATA: lv_mov TYPE xflag,
        lv_bob LIKE sy-tabix.

  DATA: lv_answer_2    TYPE c,
        lv_text_2(400) TYPE c,
        lt_param_2     LIKE spar OCCURS 0,
        lv_bob_txt(10) TYPE c.

  DATA: lv_mblnr     TYPE mblnr,
        lv_mjahr     TYPE mjahr,
        l_mblnr_309  TYPE mblnr,
        l_mjahr_309  TYPE mjahr,
        lv_new_charg TYPE charg_d.

  DATA: lv_extnumber TYPE balnrext.

  DATA: lv_reproceso TYPE xfeld.

  DATA: lv_cuerpo TYPE zepp0027_cuerpo.

  DATA: lt_messages LIKE bapiret2 OCCURS 0.


*----------------------------------------------------------------------*

  lv_reproceso  = ''.

  PERFORM orden_liberada USING gv_orden_300
                               gv_orden_300_int.

  PERFORM stock_rollo USING gv_werks
                            gv_matnr
                            gv_kg
                            gv_lote
                      CHANGING lv_error.

  IF lv_error <> 'X'.
    CLEAR: lv_error.
    DATA: l_rc TYPE char2.

    PERFORM check_bloqueo_of USING gv_orden_300
                          CHANGING l_rc.
    IF l_rc <> '00'.
      EXIT.
    ENDIF.

*1.-  alta de stock con orden y creación del lote
    PERFORM alta_stock USING gv_orden_300
                             gv_orden_300_int
                             gv_werks
                             gv_matnr
                             gv_kg
                             lv_reproceso
                       CHANGING lv_error
                                lv_mblnr
                                lv_mjahr
                                lv_new_charg
                                gv_lgort_300
                                gv_kg_producir
                                gv_kg_consum
                                gv_diferencia
                                gv_kg_producir_c
                                gv_kg_consum_c
                                gv_diferencia_c
                                gv_diferencia_sem .

    IF lv_error IS INITIAL.
*2.- Clasificar Lote
      PERFORM clasificar_lote USING lv_mblnr
                                    lv_mjahr
                                    gv_diam
                                    gv_kg
                                    gv_long
                                    gv_empa
                                    gv_kunnr_300
                                    gv_ped_300
                                    gv_pos_300
                                    lv_new_charg
                                    gv_matnr
                                    lv_reproceso
                                    gv_repr
                              CHANGING
*                                  lv_new_charg
                                       lv_error.

      "EAB T76941 28.06.2023 Integración E80: se llama a la función de envio de datos de bobina a E80 una vez se ha dado de alta la bobina
      CALL FUNCTION 'Z_E80_ENVIO_STOCK_BOBINA'
        EXPORTING
          i_werks          = gv_werks
*         I_CHARG          =
*         I_OBJEK          =
          i_par_origen     = '0'
        EXCEPTIONS
          lote_inexistente = 1
          OTHERS           = 2.
      IF sy-subrc <> 0.
* Implement suitable error handling here
      ENDIF.


      IF lv_error IS INITIAL.

*3.- Notificar
        PERFORM notificar_orden_new USING gv_orden_300
                                          gv_orden_300_int
                                          gv_werks
                                          gv_kg
                                          gv_lote "lv_new_charg
                                          gv_matnr "lv_mat_rollo
                                    CHANGING lv_error
                                             gv_kg_producir
                                             gv_kg_consum
                                             gv_diferencia
                                             gv_kg_producir_c
                                             gv_kg_consum_c
                                             gv_diferencia_c
                                             gv_diferencia_sem.

        IF lv_error IS INITIAL.

* 02/03/2021 - 64594 - CMS
* Antes de imprimir etiqueta, si hay un cambio de ancho,
* se procesa y se imprime SOLO la nueva etiqueta
          IF g_cambio_ancho_cabo = 'X'.
            CLEAR: l_mblnr_309 , l_mjahr_309.

            PERFORM avisos_cambio_ancho_cabo USING gv_matnr_300
                                                   lv_new_charg
                                          CHANGING l_mblnr_309
                                                   l_mjahr_309
                                                   lv_error.
            IF lv_error = 'X'.
              MESSAGE |¡ERROR! No se puede realizar el cambio de ancho.| TYPE 'I' DISPLAY LIKE 'E'.
              CLEAR: l_mblnr_309 , l_mjahr_309.
            ENDIF.
          ENDIF.

          "Valor lote bobina para defectos bobina y etiqueta de muestra
          gv_lote_bob     = lv_new_charg.

*4.- Impresión de etiqueta
          PERFORM imprimir_etiqueta USING gv_orden_300
                                          gv_orden_300_int
                                          lv_new_charg
                                          gv_werks
                                          gv_diam
                                          gv_long
                                          gv_lgort_300
                                          ' '.

*5.- Añadir registro al alv
          g_matnr_etiq = gv_matnr_300.
          g_kunnr_etiq = gv_kunnr_300.
          PERFORM anyadir_nodo USING lv_new_charg
                                     lv_mblnr
                                     lv_mjahr
                                     ''
                                     '101'
                                     l_mblnr_309
                                     l_mjahr_309
                               CHANGING lv_cuerpo.

* Obtener el cliente de la orden para validar si es cabo.
          SELECT SINGLE zzkunnr1
            INTO @DATA(l_kunnr_sel)
            FROM aufk
            WHERE aufnr = @gv_orden_300.

          IF zcl_utils_hpap_pp=>es_cabo( i_matnr = g_matnr_etiq
                                         i_kunnr = l_kunnr_sel ) = 'X'.
*    IF gw_btn_etiq = ' '. " cuando estemos en el boton etiqueta no mostrar msg error.
*      MESSAGE e334(zpp). "No se permite imprimir etiqueta de muestra para cabo.
*    ENDIF.
            EXIT.
          ENDIF.

          PERFORM reimprimir_etiq_obs_lab USING lv_cuerpo
                                               ' '.

        ELSE.
*         Anular clasificacion del lote y alta de stock
          PERFORM anular_doc USING lv_mblnr
                                   lv_mjahr
                                   gv_kg
                             CHANGING lv_error
                                      gv_kg_producir
                                      gv_kg_consum
                                      gv_diferencia
                                      gv_kg_producir_c
                                      gv_kg_consum_c
                                      gv_diferencia_c
                                      gv_diferencia_sem.

        ENDIF.
      ELSE.
*       Anular alta de stock
        PERFORM anular_doc USING lv_mblnr
                                 lv_mjahr
                                 gv_kg
                           CHANGING lv_error
                                    gv_kg_producir
                                    gv_kg_consum
                                    gv_diferencia
                                    gv_kg_producir_c
                                    gv_kg_consum_c
                                    gv_diferencia_c
                                    gv_diferencia_sem.

      ENDIF.
    ENDIF.


*6.-  Mostrar Log
    lt_messages[] = gt_messages[].
    PERFORM clean_vbles.

    CLEAR lv_extnumber.
    CONCATENATE gv_matnr_300 lv_new_charg INTO lv_extnumber.

    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = lt_messages[]
        extnumber = lv_extnumber.

    PERFORM mostrar_log1 USING lt_messages.


*    ENDIF.
  ELSE.
    PERFORM clean_vbles.
  ENDIF.

  CALL FUNCTION 'DEQUEUE_ALL'
*   EXPORTING
*     _SYNCHRON       = ' '
    .


ENDFORM.                    " ETIQUETA
*&---------------------------------------------------------------------*
*&      Form  ORDEN_LIBERADA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM orden_liberada USING p_aufnr_ext
                          p_aufnr_int.

  DATA: ls_header LIKE bapi_alm_order_header_e.
  DATA: ls_ret TYPE bapiret2 OCCURS 0 WITH HEADER LINE.
  DATA: lv_objnr LIKE aufk-objnr.
  DATA: lt_status LIKE jstat OCCURS 0.
  DATA: ls_status TYPE jstat.
*  DATA: lv_aufnr TYPE aufk-aufnr.

  CHECK p_aufnr_ext IS NOT INITIAL.

*  Chequeamos el status de la orden
  CLEAR lv_objnr.
  SELECT SINGLE objnr INTO lv_objnr
    FROM aufk
    WHERE aufnr = p_aufnr_int.

  CALL FUNCTION 'STATUS_READ'
    EXPORTING
      client           = sy-mandt
      objnr            = lv_objnr
    TABLES
      status           = lt_status
    EXCEPTIONS
      object_not_found = 1
      OTHERS           = 2.

  READ TABLE lt_status INTO ls_status WITH KEY stat = 'I0002'.
  IF sy-subrc = 0.
    IF ls_status-inact = 'X'.
      MESSAGE e011(zpp) WITH p_aufnr_ext.
    ENDIF.
  ELSE.
    MESSAGE e011(zpp) WITH p_aufnr_ext.
  ENDIF.
*  ENDIF.

ENDFORM.                    " ORDEN_LIBERADA
*&---------------------------------------------------------------------*
*&      Form  STOCK_ROLLO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_ORDEN_300  text
*      -->P_GV_KG  text
*      -->P_GV_LOTE  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM stock_rollo  USING    p_werks
                           p_matnr
                           p_menge
                           p_charg
                  CHANGING p_error.


  DATA: ls_mch1  TYPE mch1,
        lv_clabs TYPE labst.


  SELECT SINGLE * INTO ls_mch1
     FROM mch1
     WHERE matnr = p_matnr AND
           charg = p_charg.

  IF ls_mch1 IS NOT INITIAL.
    CLEAR: p_error, lv_clabs.

    SELECT SINGLE clabs FROM mchb
      INTO lv_clabs
      WHERE werks = p_werks AND "ls_aufk-werks AND
            matnr = p_matnr AND
            charg = p_charg AND
            cinsm = ' ' AND
            cspem = ' '.

    IF lv_clabs < p_menge.
      p_error = 'X'.
      MESSAGE e051(zpp) WITH p_matnr p_charg lv_clabs p_menge.
    ENDIF.

  ELSE.
    p_error = 'X'.
    MESSAGE e016(zpp) WITH p_matnr p_charg. " Material/Lote rollo no existe.
  ENDIF.


ENDFORM.                    " STOCK_ROLLO

*&---------------------------------------------------------------------*
*&      Form  ALTA_STOCK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM alta_stock USING p_aufnr_ext
                      p_aufnr_int
                      p_werks
                      p_matnr
                      p_menge
                      p_repr
                CHANGING p_error
                         p_mblnr
                         p_mjahr
                         p_new_charg
                         p_lgort_300
                         p_kg_producir
                         p_kg_consum
                         p_diferencia
                         p_kg_producir_c
                         p_kg_consum_c
                         p_diferencia_c
                         p_diferencia_sem .

  DATA: ls_header  TYPE bapi2017_gm_head_01,
        lt_return  LIKE bapiret2 OCCURS 0,
        ls_return  TYPE bapiret2,
        lt_item    LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item    TYPE bapi2017_gm_item_create,
        ls_headret TYPE bapi2017_gm_head_ret.


  DATA: ls_afko TYPE afko.
  DATA: ls_aufk TYPE aufk.
  DATA: ls_afpo TYPE afpo.
  DATA: lv_lgort TYPE lgort_d.
  DATA: lv_mblnr TYPE bapi2017_gm_head_ret-mat_doc,
        lv_mjahr TYPE bapi2017_gm_head_ret-doc_year.


  CLEAR: p_mblnr,  p_mjahr, lt_item, ls_header, ls_item,
         ls_afko,  ls_aufk, ls_afpo.
  REFRESH: lt_item, lt_return.

* SGM - ini 03.08.2017 Ticket 0000043398
  CALL FUNCTION 'BUFFER_REFRESH_ALL'.
  CALL FUNCTION 'CO_SF_DATA_RESET'.
* SGM - fin 03.08.2017 Ticket 0000043398

* cabecera
  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.
  ls_header-pr_uname = sy-uname.
  ls_header-header_txt = 'Notificacion de bobinas'.

* recuperar datos orden
  SELECT SINGLE * INTO ls_afko
    FROM afko
    WHERE aufnr = p_aufnr_int.

  SELECT SINGLE * INTO ls_aufk
    FROM aufk
    WHERE aufnr = p_aufnr_int.

  SELECT SINGLE * INTO ls_afpo
   FROM afpo
   WHERE aufnr = p_aufnr_int AND
         posnr = '0001'.

* posicion
  ls_item-material = ls_afko-plnbez.
  ls_item-plant = p_werks.

* EN CASO DE REPROCESADO SE DA DE ALTA EN EL ALMACEN DE REPROCESADO
  IF p_repr IS INITIAL.
    ls_item-stge_loc = ls_afpo-lgort.
  ELSE.
    ls_item-stge_loc = '4001'.
  ENDIF.


  p_lgort_300 = ls_item-stge_loc.

  ls_item-move_type = '101'.
  ls_item-entry_qnt = p_menge.
  ls_item-entry_uom = 'KG'.
  ls_item-orderid = p_aufnr_int.
  ls_item-mvt_ind = 'F'.

* Obtener almacén de tabla Z
  IF p_repr IS INITIAL.
    SELECT SINGLE lgort FROM ztpp0008
      INTO lv_lgort
      WHERE werks = p_werks AND
            arbpl = gv_arbpl.

    IF sy-subrc = 0.
      ls_item-stge_loc = lv_lgort.
    ENDIF.
  ENDIF.

  APPEND ls_item TO lt_item.


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = '02'
*     TESTRUN          = ' '
*     GOODSMVT_REF_EWM =
    IMPORTING
      goodsmvt_headret = ls_headret
      materialdocument = lv_mblnr
      matdocumentyear  = lv_mjahr
    TABLES
      goodsmvt_item    = lt_item
*     GOODSMVT_SERIALNUMBER         =
      return           = lt_return
*     GOODSMVT_SERV_PART_DATA       =
*     EXTENSIONIN      =
    .

  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
  IF sy-subrc <> 0.
    p_mblnr = lv_mblnr.
    p_mjahr = lv_mjahr.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

*   GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    CLEAR gs_messages.

    gs_messages-type = 'S'.
    gs_messages-number = '012'.
    gs_messages-id = 'ZPP'.
    gs_messages-message_v1 = p_mblnr.
    gs_messages-message_v2 = p_mjahr.

    APPEND gs_messages TO gt_messages.


    SELECT SINGLE charg FROM mseg
      INTO p_new_charg
      WHERE mblnr = p_mblnr AND
            mjahr = p_mjahr.

  ELSE.
    p_error = 'X'.

*   REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

*   guardar los en SLG1
    CALL FUNCTION 'ZMONTAR_LOG_SLG1'
      EXPORTING
        i_extnumber = ''
        i_object    = 'ZPP'
        i_subobject = sy-tcode
      TABLES
        t_return    = gt_messages.
  ENDIF.

ENDFORM.                    " ALTA_STOCK
*&---------------------------------------------------------------------*
*&      Form  CLASIFICAR_LOTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM clasificar_lote USING p_mblnr
                           p_mjahr
                           p_diam
                           p_menge
                           p_long
                           p_empa
                           p_cli p_ped
                           p_pos
                           p_charg
                           p_mat_rollo
                           p_repr
                           gv_repr

                     CHANGING
*                       p_new_charg
                              p_error .

  DATA: lv_object            TYPE objnum,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        ls_return            TYPE bapiret2.

  DATA: lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab.

  DATA: lv_matnr      TYPE matnr,
        lv_charg      TYPE charg_d,
        lv_budat_mkpf TYPE mseg-budat_mkpf.

  CLEAR: lv_object, lt_alloc_values_num, lt_alloc_values_char,
         lt_alloc_values_curr, lt_return, ls_alloc_values_num,
         ls_alloc_values_char, ls_return, lv_matnr, lv_charg.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char, lt_alloc_values_curr,
        lt_return.


  SELECT SINGLE matnr budat_mkpf FROM mseg
    INTO (lv_matnr,lv_budat_mkpf)
    WHERE mblnr = p_mblnr AND
          mjahr = p_mjahr.

  gv_matnr_bob = lv_matnr. "Numero material de bobina para utilizar en pantalla defectos de bobina

  CONCATENATE lv_matnr p_charg INTO lv_object.

  " DIAMETRO:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_DIAMETRO'.
  ls_alloc_values_num-value_from = p_diam.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.

  " PESO:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_PESO'.
  ls_alloc_values_num-value_from = p_menge.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.


  " LONGITUD DE BOBINA:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_LONGITUD_B'.
  ls_alloc_values_num-value_from = p_long.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.

  " FECHA DE FABRICACION:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_FECHA_FABRICACION'.
*  IF lv_budat_mkpf IS NOT INITIAL AND lv_budat_mkpf NE '00000000'.
  WRITE lv_budat_mkpf TO ls_alloc_values_char-value_char.
*  ELSE.
*    WRITE gv_fecha TO ls_alloc_values_char-value_char.
*  ENDIF.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " Nº EMPALMES:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_EMPALMES'.
  ls_alloc_values_num-value_from = p_empa.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.

  " REPROCESADO:
  IF p_repr = 'X'.
    CLEAR ls_alloc_values_char.
    ls_alloc_values_char-charact = 'Z_REPROCESO'.
    ls_alloc_values_char-value_char = '1'.
    APPEND ls_alloc_values_char TO lt_alloc_values_char.

    IF gv_repr  IS NOT INITIAL.
      CLEAR ls_alloc_values_char.
      ls_alloc_values_char-charact = 'ZPPI_MOTIVO_REPROCESO_BOBINA'.
      ls_alloc_values_char-value_char = gv_repr .
      APPEND ls_alloc_values_char TO lt_alloc_values_char.
    ENDIF.
  ENDIF.

  " CLIENTE:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_CLIENTE'.
  ls_alloc_values_char-value_char = p_cli.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " LOTE ORIGEN:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_LOTE_ORIGEN'.
  ls_alloc_values_char-value_char = gv_lote.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " MATERIAL ORIGEN:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_ROLLO_ORIGEN_V2'.
  ls_alloc_values_char-value_char = |{ p_mat_rollo ALPHA = OUT }|.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " PEDIDO:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_PEDIDO'.
  ls_alloc_values_char-value_char = p_ped.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " POSICION:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_POSICION'.
  ls_alloc_values_char-value_char = p_pos.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

*  " PUESTO DE TRABAJO:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_PUESTO_TRABAJO'.
  ls_alloc_values_char-value_char = gv_arbpl.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

* INI CMS 24/05/2019

* Primero validamos si se trata de un cabo.
* Si lo es, buscamos defectos en lado transmisor/conductor o Nuevas características para defectos. Se cumplimentará para cabos.
* Condición para ser cabo --> (ancho<=1340 y cliente = C3000 o C3020)

  IF zcl_utils_hpap_pp=>es_cabo( i_matnr = gv_matnr_300
                                 i_kunnr = p_cli ) = 'X'
    AND p_repr = ' '.

    DATA(lw_def) = ' '.

* Obtenemos datos de defectos de Rollo:
    DATA(l_matnr_rollo_alpha) = |{ gv_matnr_mostrar ALPHA = IN }|.
    DATA(l_aufnr_rollo_alpha) = |{ gv_aunfr_mostrar ALPHA = IN }|.

    SELECT SINGLE * INTO @DATA(ls_def_rollo)
      FROM ztpp0030
      WHERE werks = @gv_werks         AND
            aufnr = @l_aufnr_rollo_alpha AND
            matnr = @l_matnr_rollo_alpha AND
            charg = @gv_lote.
    IF sy-subrc = 0.

      CASE 'X'.
*** Lado TRANSMISOR ***
        WHEN ls_def_rollo-cabo_lt.
          IF ls_def_rollo-defecto1_lt IS NOT INITIAL.
*  " Defecto 1
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS1'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto1_lt.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
          IF ls_def_rollo-defecto2_lt IS NOT INITIAL.
*  " Defecto 2
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS2'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto2_lt.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
          IF ls_def_rollo-defecto3_lt IS NOT INITIAL.
*  " Defecto 3
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS3'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto3_lt.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
*** Lado CONDUCTOR ***
        WHEN ls_def_rollo-cabo_lc.
          IF ls_def_rollo-defecto1_lc IS NOT INITIAL.
*  " Defecto 1
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS1'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto1_lc.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
          IF ls_def_rollo-defecto2_lc IS NOT INITIAL.
*  " Defecto 2
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS2'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto2_lc.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
          IF ls_def_rollo-defecto3_lc IS NOT INITIAL.
*  " Defecto 3
            lw_def = 'X'.
            CLEAR ls_alloc_values_char.
            ls_alloc_values_char-charact = 'Z_DEFECTOS3'.
            ls_alloc_values_char-value_char = ls_def_rollo-defecto3_lc.
            APPEND ls_alloc_values_char TO lt_alloc_values_char.
          ENDIF.
        WHEN OTHERS.
      ENDCASE.

* Si existe algún defecto, informamos la característica DE = R
      IF lw_def = 'X'.
        CLEAR ls_alloc_values_char.
        ls_alloc_values_char-charact = 'LOBM_UDCODE'.
        ls_alloc_values_char-value_char = 'DE       R'.
        APPEND ls_alloc_values_char TO lt_alloc_values_char.

*  " Informamos FSC 100% para los cabos con defectos.
        CLEAR ls_alloc_values_num.
        ls_alloc_values_num-charact = 'Z_FSC_PORCENTAJE'.
        ls_alloc_values_num-value_from = 100.
        APPEND ls_alloc_values_num TO lt_alloc_values_num.

      ENDIF.

    ENDIF.
  ENDIF.

* Cuando venimos de Etiqueta (NO reproceso) , si el Rollo tiene DE=P y es cabo: aplicar DE=R + %FSC=100
  IF p_repr = ' ' AND
     g_dec_empleo_p = 'X'    AND
     zcl_utils_hpap_pp=>es_cabo( i_matnr = gv_matnr_300
                                i_kunnr = gv_kunnr_300 ) = 'X'.
    CLEAR ls_alloc_values_char.
    ls_alloc_values_char-charact = 'LOBM_UDCODE'.
    ls_alloc_values_char-value_char = 'DE       R'.
    APPEND ls_alloc_values_char TO lt_alloc_values_char.

*  " Informamos FSC 100% para los cabos con defectos.
    CLEAR ls_alloc_values_num.
    ls_alloc_values_num-charact = 'Z_FSC_PORCENTAJE'.
    ls_alloc_values_num-value_from = 100.
    APPEND ls_alloc_values_num TO lt_alloc_values_num.
  ENDIF.

  " OPERARIO:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_OPERARIO'.
  ls_alloc_values_char-value_char = gv_nombre_oper.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

* FIN CMS 24/05/2019


* 12/05/2021 - 57299 - CMS - Si se obtiene ancho de BBDD Augi informar característica del lote.
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_ANCHO_REAL'.
  ls_alloc_values_num-value_from = g_ancho_caract.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.



  CALL FUNCTION 'BAPI_OBJCL_CHANGE'
    EXPORTING
      objectkey          = lv_object
      objecttable        = 'MCH1'
      classnum           = 'Z_BOBINA'
      classtype          = '023'
    TABLES
      allocvaluesnumnew  = lt_alloc_values_num
      allocvaluescharnew = lt_alloc_values_char
      allocvaluescurrnew = lt_alloc_values_curr
      return             = lt_return.

  CLEAR ls_return.
  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
  IF ls_return IS NOT INITIAL. " Error act. característica
    p_error = 'X'.

    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

*   REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.

  ELSE.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

    "EAB T76941 28.06.2023 Integración E80: se llama a la función de envio de datos de bobina a E80 una vez se da de alta una bobina

    CALL FUNCTION 'Z_E80_ENVIO_STOCK_BOBINA'
      EXPORTING
        i_werks          = gv_werks
*       I_CHARG          =
        i_objek          = lv_object
        i_par_origen     = '0'
      EXCEPTIONS
        lote_inexistente = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.


*   GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    READ TABLE lt_return INTO ls_return WITH KEY type = 'S'.
    CLEAR gs_messages.
    gs_messages = ls_return.
    APPEND gs_messages TO gt_messages.

  ENDIF.


* montar log slg1
  CALL FUNCTION 'ZMONTAR_LOG_SLG1'
    EXPORTING
      i_extnumber = ''
      i_object    = 'ZPP'
      i_subobject = sy-tcode
    TABLES
      t_return    = gt_messages.

ENDFORM.                    " CLASIFICAR_LOTE
*&---------------------------------------------------------------------*
*&      Form  NOTIFICAR_ORDEN_NEW
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM notificar_orden_new USING p_aufnr_ext
                               p_aufnr_int
                               p_werks
                               p_kg
                               p_lote
                               p_mat_rollo
                         CHANGING lv_error
                                  p_kg_producir TYPE erfmg
                                  p_kg_consum   TYPE erfmg
                                  p_diferencia  TYPE erfmg
                                  p_kg_producir_c
                                  p_kg_consum_c
                                  p_diferencia_c
                                  p_diferencia_sem.


  DATA: lti_detail TYPE TABLE OF bapi_coru_return WITH HEADER LINE,
        ls_return1 TYPE          bapiret1.
  DATA: ls_return TYPE bapiret2.
  DATA: ls_ret2 TYPE bapiret1.

  DATA: lti_times   TYPE TABLE OF bapi_pi_timeticket1 WITH HEADER LINE,
        lti_goodmov TYPE TABLE OF bapi2017_gm_item_create WITH HEADER LINE,
        lti_link    TYPE TABLE OF bapi_link_conf_goodsmov WITH HEADER LINE.
  DATA: ls_propose TYPE bapi_pp_conf_prop.

  DATA: ls_afko TYPE afko.
*  DATA: ls_aufk TYPE aufk.
  DATA: ls_afpo TYPE afpo.
  DATA: lv_yield TYPE ru_lmnga.

*  DATA: lt_stb TYPE stpox OCCURS 0 WITH HEADER LINE,
*        ls_stb TYPE stpox.

  DATA: lt_goodsmvt_item TYPE TABLE OF bapi2017_gm_item_create,
        lt_return        TYPE          bapiret2_t.

  DATA: ls_goodsmvt_header  TYPE bapi2017_gm_head_01,
        ls_goodsmvt_code    TYPE bapi2017_gm_code,
        ls_goodsmvt_item    TYPE bapi2017_gm_item_create,
        lv_materialdocument TYPE bapi2017_gm_head_ret-mat_doc,
        lv_matdocumentyear  TYPE bapi2017_gm_head_ret-doc_year,
        ls_return_aux       TYPE bapiret2.
  DATA: lv_times_rollo TYPE xflag.

  DATA: lv_desbl_matnr  TYPE xflag,
        lv_desbl_matnr2 TYPE xflag,
        lv_desbl_reserv TYPE xflag,
        lv_desbl_charg  TYPE xflag,
        lv_espera       TYPE xflag,
        lv_espera2      TYPE xflag,
        lv_espera3      TYPE xflag,
        lv_espera4      TYPE xflag.

  DATA: wa_log TYPE bapiret1.

  "Recuperamos orden de bobina para pantalla defectos bobina
  gv_aufnr_bob = p_aufnr_int.

** recuperar datos orden
  SELECT SINGLE * INTO ls_afko
    FROM afko
    WHERE aufnr = p_aufnr_int.

  SELECT SINGLE * INTO ls_afpo
   FROM afpo
   WHERE aufnr = p_aufnr_int AND
         posnr = '0001'.

*  Consumo material rollo:
  REFRESH: lt_goodsmvt_item, lt_return.
  CLEAR lv_times_rollo.

  " Cabecera:
  CLEAR ls_goodsmvt_header.
  ls_goodsmvt_header-pstng_date  = sy-datum.
  ls_goodsmvt_header-doc_date    = sy-datum.
  ls_goodsmvt_header-header_txt  = text-014.

  " Tipo de movimiento:
  CLEAR ls_goodsmvt_code.
  ls_goodsmvt_code-gm_code       = '06'.

  " Posiciones:
  CLEAR: ls_goodsmvt_item.
  ls_goodsmvt_item-material = p_mat_rollo.
  ls_goodsmvt_item-plant = p_werks.
  ls_goodsmvt_item-stge_loc = '1020'.
  ls_goodsmvt_item-batch = p_lote. " Lote a consumir
  ls_goodsmvt_item-move_type = '261'.
  ls_goodsmvt_item-stck_type = ' '. " Libre utilización
  ls_goodsmvt_item-entry_qnt = p_kg.

  SELECT SINGLE meins INTO ls_goodsmvt_item-entry_uom
    FROM mara
    WHERE matnr = p_mat_rollo.

  IF ls_goodsmvt_item-entry_uom IS INITIAL.
    ls_goodsmvt_item-entry_uom = 'KG'.
  ENDIF.

  ls_goodsmvt_item-reserv_no = ls_afko-rsnum.

*--->mhernandez. 23.01.2018
*7000016489, Ticket_##_43615_##_de_ealegre@hinojosa
*  SELECT SINGLE rspos INTO ls_goodsmvt_item-res_item
*  FROM resb
*  WHERE rsnum = ls_afko-rsnum
*  AND matnr = p_mat_rollo.

* 65397 - 03/05/2021 -CMS - Obtener siempre 1a posición de mat.rollo menor para consumir(261)
  SELECT SINGLE MIN( rspos ) INTO ls_goodsmvt_item-res_item
    FROM resb
    WHERE rsnum = ls_afko-rsnum
    AND matnr = p_mat_rollo
    AND xloek = space.
*<---fin mhernandez

  APPEND ls_goodsmvt_item TO lt_goodsmvt_item.

*   Bloqueos en consumo rollo ->
*   Chequeamos que no hay ningún bloqueo ni en la resb, ni en el lote:
  CLEAR: lv_desbl_reserv, lv_desbl_charg, lv_espera, lv_espera2.
  CLEAR: lv_desbl_matnr, lv_desbl_matnr2, lv_espera3, lv_espera4.

  CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA_MARC'
    EXPORTING
      matnr      = p_mat_rollo
      werks      = p_werks
    IMPORTING
      desbloqueo = lv_desbl_matnr
      espera     = lv_espera.

  IF lv_desbl_matnr = 'X'.
    CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA'
      EXPORTING
        matnr      = p_mat_rollo
        werks      = p_werks
      IMPORTING
        desbloqueo = lv_desbl_matnr2
        espera     = lv_espera2.

    IF lv_desbl_matnr2 = 'X'.
      CALL FUNCTION 'ZMFPP_BLOQUEO_LOTE'
        EXPORTING
          charg      = p_lote
        IMPORTING
          desbloqueo = lv_desbl_charg
          espera     = lv_espera3.

      IF lv_desbl_charg = 'X'.
        CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA_RKPF'
          EXPORTING
            rsnum      = ls_afko-rsnum
          IMPORTING
            desbloqueo = lv_desbl_reserv
            espera     = lv_espera4.
      ENDIF.
    ENDIF.
  ENDIF.

  IF lv_espera = 'X' OR lv_espera2 = 'X'.
    IF lv_desbl_matnr = 'X' AND lv_desbl_matnr2 = 'X'.
      CLEAR gs_messages.
      gs_messages-type = 'S'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '047'.
      APPEND gs_messages TO gt_messages.
    ELSE.
      lv_error = 'X'.

      CLEAR gs_messages.
      gs_messages-type = 'E'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '048'.
      APPEND gs_messages TO gt_messages.
    ENDIF.
  ENDIF.

  IF lv_espera3 = 'X'.
    IF lv_desbl_charg = 'X'.
      CLEAR gs_messages.
      gs_messages-type = 'S'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '045'.
      APPEND gs_messages TO gt_messages.
    ELSE.
      lv_error = 'X'.

      CLEAR gs_messages.
      gs_messages-type = 'E'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '046'.
      APPEND gs_messages TO gt_messages.
    ENDIF.
  ENDIF.

  IF lv_espera4 = 'X'.
    IF lv_desbl_reserv = 'X'.
      CLEAR gs_messages.
      gs_messages-type = 'S'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '043'.
      APPEND gs_messages TO gt_messages.
    ELSE.
      lv_error = 'X'.

      CLEAR gs_messages.
      gs_messages-type = 'E'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '044'.
      APPEND gs_messages TO gt_messages.

    ENDIF.
  ENDIF.

  IF lv_desbl_reserv = 'X' AND lv_desbl_charg = 'X' AND
     lv_desbl_matnr = 'X' AND lv_desbl_matnr2 = 'X'.

    CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
      EXPORTING
        goodsmvt_header  = ls_goodsmvt_header
        goodsmvt_code    = ls_goodsmvt_code
      IMPORTING
        materialdocument = lv_materialdocument
        matdocumentyear  = lv_matdocumentyear
      TABLES
        goodsmvt_item    = lt_goodsmvt_item
        return           = lt_return.

    WAIT UP TO 3 SECONDS.
    CLEAR: ls_return_aux.
    READ TABLE lt_return INTO ls_return_aux WITH KEY type = 'E'.

    IF ls_return_aux IS NOT INITIAL.
      lv_error = 'X'.

      " Error en la creación del movimiento de consumo:
      CLEAR gs_messages.
      gs_messages = ls_return_aux.
      APPEND gs_messages TO gt_messages.

      " Error identificativo del movimiento de consumo:
      CLEAR gs_messages.
      gs_messages-type = 'E'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '042'.
      APPEND gs_messages TO gt_messages.

    ELSE.
*     actualizamos las cantidades de la cabecera de la dynpro
      PERFORM actualizar_cabecera_300 USING p_kg
                                            '261'
                                      CHANGING p_kg_producir
                                               p_kg_consum
                                               p_diferencia
                                               p_kg_producir_c
                                               p_kg_consum_c
                                               p_diferencia_c
                                               p_diferencia_sem .

      " Se ha creado el movimiento de consumo correctamente:
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = 'X'.

      lv_times_rollo = 'X'.

*     GUARDAR LOGS CON EL MOVIMIENTO CONSUMO CREADO
      CLEAR gs_messages.
      gs_messages-type = 'S'.
      gs_messages-id = 'ZPP'.
      gs_messages-number = '018'.
      gs_messages-message_v1 = lv_materialdocument.
      gs_messages-message_v2 = lv_matdocumentyear.
      APPEND gs_messages TO gt_messages.

* Ahora tenermos que hacer la notificación de tiempos:
* Primero chequeamos que no hay ningún bloqueo en la RESB, ni en el lote
      CLEAR: lv_desbl_reserv, lv_desbl_charg, lv_espera, lv_espera2,
              lv_desbl_matnr, lv_desbl_matnr2, lv_espera3, lv_espera4.

      CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA_MARC'
        EXPORTING
          matnr      = p_mat_rollo
          werks      = p_werks
        IMPORTING
          desbloqueo = lv_desbl_matnr
          espera     = lv_espera.

      IF lv_desbl_matnr = 'X'.
        CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA'
          EXPORTING
            matnr      = p_mat_rollo
            werks      = p_werks
          IMPORTING
            desbloqueo = lv_desbl_matnr2
            espera     = lv_espera2.

        IF lv_desbl_matnr2 = 'X'.
          CALL FUNCTION 'ZMFPP_BLOQUEO_LOTE'
            EXPORTING
              charg      = p_lote
            IMPORTING
              desbloqueo = lv_desbl_charg
              espera     = lv_espera3.

          IF lv_desbl_charg = 'X'.
            CALL FUNCTION 'ZMFPP_BLOQUEO_RESERVA_RKPF'
              EXPORTING
                rsnum      = ls_afko-rsnum
              IMPORTING
                desbloqueo = lv_desbl_reserv
                espera     = lv_espera4.
          ENDIF.
        ENDIF.
      ENDIF.

      IF lv_espera = 'X' OR lv_espera2 = 'X'.
        IF lv_desbl_matnr = 'X' AND lv_desbl_matnr2 = 'X'.
          CLEAR gs_messages.
          gs_messages-type = 'S'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '047'.
          APPEND gs_messages TO gt_messages.
        ELSE.
          lv_error = 'X'.

          CLEAR gs_messages.
          gs_messages-type = 'E'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '048'.
          APPEND gs_messages TO gt_messages.

        ENDIF.
      ENDIF.

      IF lv_espera3 = 'X'.
        IF lv_desbl_charg = 'X'.
          CLEAR gs_messages.
          gs_messages-type = 'S'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '045'.
          APPEND gs_messages TO gt_messages.
        ELSE.
          lv_error = 'X'.

          CLEAR gs_messages.
          gs_messages-type = 'E'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '046'.
          APPEND gs_messages TO gt_messages.
        ENDIF.
      ENDIF.

      IF lv_espera4 = 'X'.
        IF lv_desbl_reserv = 'X'.
          CLEAR gs_messages.
          gs_messages-type = 'S'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '043'.
          APPEND gs_messages TO gt_messages.
        ELSE.
          lv_error = 'X'.

          CLEAR gs_messages.
          gs_messages-type = 'E'.
          gs_messages-id = 'ZPP'.
          gs_messages-number = '044'.
          APPEND gs_messages TO gt_messages.
        ENDIF.
      ENDIF.


      IF lv_desbl_reserv = 'X' AND lv_desbl_charg = 'X' AND
        lv_desbl_matnr = 'X' AND lv_desbl_matnr2 = 'X'.
*       Recuperamos los datos de la notificación:
        CLEAR: ls_return, lti_times, lv_yield.
        lti_times-orderid        = p_aufnr_int.
        lti_times-phase          = '0020'.
        lti_times-fin_conf       = '1'.
        lti_times-plant          = p_werks.
        lti_times-yield          = p_kg.
        lti_times-conf_quan_unit = ls_afko-gmein.
        lti_times-clear_res      = 'X'.
        lti_times-resource       = gv_arbpl.
        APPEND lti_times.

        CLEAR ls_propose.
        ls_propose-goodsmovement = 'X'.

* 21/01/2021 - CMS - 64497 -Notificaciones de tiempos a Cero para oper.40 cuando los kg estan excedidos.
* Al no pasarle el flag de cantidad, aunque los kg.OF esten excedidos, devuelve valores de tiempos.
*        ls_propose-quantity = 'X'.
        ls_propose-quantity = ' '.
* FIN CMS

        ls_propose-activity = 'X'.
        ls_propose-personnel = 'X'.
        CLEAR ls_ret2.

*       Recuperamos los datos de la BAPI que notifica
        CALL FUNCTION 'BAPI_PROCORDCONF_GET_TT_PROP'
          EXPORTING
            propose            = ls_propose
          IMPORTING
            return             = ls_ret2
          TABLES
            timetickets        = lti_times
            goodsmovements     = lti_goodmov
            link_conf_goodsmov = lti_link.

        LOOP AT lti_times.
          lti_times-exec_fin_date   = sy-datum.
          lti_times-exec_fin_time   = sy-uzeit.
          lti_times-exec_start_date = ls_afko-ftrmi.
          lti_times-conf_activity1 = (  lti_times-conf_activity1 * p_kg ) /
          lti_times-yield.
          lti_times-conf_activity2 = (  lti_times-conf_activity2 * p_kg ) /
          lti_times-yield.
          lv_yield = lti_times-yield.
          lti_times-yield =  p_kg.

* 27/09/2021 - 68809 - CMS
* Corrección de imputación de costes.  Para que se tome correctamente la HdR/costes de actividades
* inputaremos costes a BOBI_01 cuando se trate de BOBI_02.
          IF gv_arbpl = 'BOBI_02'.
            lti_times-resource = 'BOBI_01'.
          ELSE.
            lti_times-resource = gv_arbpl.
          ENDIF.


          MODIFY lti_times.
        ENDLOOP.

*       para el consumo del rollo
        LOOP AT lti_goodmov.
          IF lti_goodmov-material <> p_mat_rollo.
            lti_goodmov-entry_qnt = ( p_kg * lti_goodmov-entry_qnt ) / lv_yield.
            lti_goodmov-prod_date = sy-datum.
            lti_goodmov-batch     = p_lote.
            MODIFY lti_goodmov.
          ENDIF.
        ENDLOOP.

        CALL FUNCTION 'BAPI_PROCORDCONF_CREATE_TT'
*           EXPORTING
*             POST_WRONG_ENTRIES             = '0'
*             TESTRUN                        =
          IMPORTING
            return             = ls_return1
          TABLES
            timetickets        = lti_times
            goodsmovements     = lti_goodmov
            link_conf_goodsmov = lti_link
            detail_return      = lti_detail.

        READ TABLE lti_detail WITH KEY type = 'E'.
        IF sy-subrc = 0.
          lv_error = 'X'.

*         REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
          CLEAR gs_messages.
          gs_messages = lti_detail.
          APPEND gs_messages TO gt_messages.

        ELSE.
          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
            EXPORTING
              wait = 'X'.

*         GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
          CLEAR gs_messages.
          gs_messages = lti_detail.
          APPEND gs_messages TO gt_messages.
        ENDIF.
      ENDIF.
    ENDIF.

  ELSE.
    lv_error = 'X'.

    " Añadimos como erróres que no se ha hecho el consumo de rollo, ni la
    " notificación de tiempos:

    " Error identificativo del movimiento de consumo:
    CLEAR gs_messages.
    gs_messages-type = 'E'.
    gs_messages-id = 'ZPP'.
    gs_messages-number = '042'.
    APPEND gs_messages TO gt_messages.

    " Error identificativo de notificación de tiempos:
    CLEAR gs_messages.
    gs_messages-type = 'E'.
    gs_messages-id = 'ZPP'.
    gs_messages-number = '072'.
    APPEND gs_messages TO gt_messages.

  ENDIF.
*  ENDIF.


* montar log slg1
  CALL FUNCTION 'ZMONTAR_LOG_SLG1'
    EXPORTING
      i_extnumber = ''
      i_object    = 'ZPP'
      i_subobject = sy-tcode
    TABLES
      t_return    = gt_messages.
ENDFORM.                    " NOTIFICAR_ORDEN_NEW
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta USING p_aufnr_ext
                             p_aufnr_int
                             p_charg
                             p_werks
                             p_diam
                             p_long
                             p_lgort
                             p_repr.

  DATA: p_aufnr_1      TYPE aufnr.
  DATA: ls_bobina      TYPE zspp_etiq_bobina.
  DATA: ls_zebelp1     TYPE posnr_va.
  DATA: l_impr_auto    TYPE flag.
  DATA: l_nodialog     TYPE fpnodialog.
  DATA: l_padest_bapi  TYPE rspopname.


  CLEAR: ls_bobina, ls_zebelp1.

  ls_bobina-diametro = p_diam.
  ls_bobina-charg = p_charg.
  ls_bobina-aufnr = p_aufnr_int.
*  ls_bobina-fec_fabricacion = gv_fecha. "p_ffab.
  ls_bobina-fec_fabricacion = sy-datum.
  ls_bobina-lgort = p_lgort.
  ls_bobina-longitud = p_long.
  ls_bobina-werks_ent = p_werks.
  ls_bobina-arbpl_ent = gv_arbpl.

  SELECT SINGLE afko~plnbez aufk~werks aufk~zzkunnr1 aufk~zzebeln1 aufk~zzebelp1
  INTO (ls_bobina-matnr, ls_bobina-werks, ls_bobina-kunnr,
  ls_bobina-pedido, ls_zebelp1)
  FROM aufk
  INNER JOIN afko ON afko~aufnr = aufk~aufnr
  WHERE aufk~aufnr = p_aufnr_int.

  ls_bobina-posicion = ls_zebelp1.


* Doble tratamiento según BOBINA_AUTOMATICA
  IF g_flag_bob_auto = ' '.

* Si se ha realizado un cambio de ancho, tomar este MATNR.
    IF g_matnr_cambio_ancho IS NOT INITIAL.
      ls_bobina-matnr = g_matnr_cambio_ancho.
    ENDIF.

* Obtenemos el ancho del material a imprimir
    SELECT SINGLE zzancho
      INTO @DATA(l_ancho)
      FROM mara
      WHERE matnr = @ls_bobina-matnr.

    SELECT SINGLE padest
      INTO @DATA(l_padest_man)
      FROM ztpp0008
      WHERE werks = @gv_werks AND
            arbpl = @gv_arbpl AND
            cont  = 1. " Obtener datos de impresora manual


    IF l_ancho > gs_ztpp0008-ancho_minimo               AND " si se cumplen las 4 condiciones->Impr.automática
       gs_ztpp0008-cont = 2                             AND
       gs_ztpp0008-act_etiq = 'X'                       AND
       NOT ( p_repr = 'X'   AND
            zcl_utils_hpap_pp=>es_cabo( i_matnr = gv_matnr_300
                                        i_kunnr = gv_kunnr_300 ) = 'X'
           ).
      .
      l_padest_bapi = gs_ztpp0008-padest.
      l_impr_auto   = 'X'.
      l_nodialog    = 'X'.
    ELSE.                                 " sino, impresión manual
      l_padest_bapi = l_padest_man.
      l_impr_auto   = ' '.
      l_nodialog    = ' '.
    ENDIF.

    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA' " Impresión Manual/automática según botón.
      EXPORTING
        i_bobina          = ls_bobina
        i_padest          = l_padest_bapi
        i_impr_automatica = l_impr_auto
        i_nodialog        = l_nodialog.

  ELSE.

* Llamada para Alqueria.
    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA'
      EXPORTING
        i_bobina = ls_bobina.


  ENDIF.

ENDFORM.                    " IMPRIMIR_ETIQUETA
*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_LOG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM mostrar_log .

  CALL FUNCTION 'C14ALD_BAPIRET2_SHOW'
    TABLES
      i_bapiret2_tab = gt_messages.
ENDFORM.                    " MOSTRAR_LOG
*&---------------------------------------------------------------------*
*&      Form  CLEAN_VBLES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM clean_vbles .
  CLEAR: gv_orden_300, gv_orden_300_int, gv_matnr_300, gv_maktx_300,
         gv_pedpos_300, gv_ped_300, gv_pos_300,  gv_kunnr_300,
         gv_cli_name_300, gv_kg, gv_diam, gv_long, gv_empa, gt_messages,
         gv_lgort_300, gv_pulper, gv_repr,
         g_ancho_bbdd , g_ancho_caract , g_matnr_cambio_ancho. " variables de gestión del Cambio de ancho.
  REFRESH gt_messages.

*  LEAVE SCREEN.
ENDFORM.                    " CLEAN_VBLES
*&---------------------------------------------------------------------*
*&      Form  PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM pulper CHANGING gv_pulper.
*----------------------------------------------------------------------*
* realizará la notificación de una bobina pulper en los términos
* actuales, es decir, alta de bobina pulper como subproducto de la OF
* (movimiento 531), notificación de tiempos e impresión de etiqueta
* de bobina pulper (funcionalidad ya existente en la transacción
* ZPP0012/22/23, alta de bobina pulper)
* Cuando se seleccione esta opción saltará una ventana con los motivos
* que han provocado el alta de la bobina pulper para que el usuario
* seleccione uno de ellos (actualmente lista desplegable en la transacción
* ZPP0012/22/23 seleccionando la opción bobina pulper)
*----------------------------------------------------------------------*
  DATA: lv_error     TYPE xfeld,
        lv_peso(15)  TYPE c,
        lv_text(400) TYPE c,
        lv_answer    TYPE c,
        lt_param     LIKE spar OCCURS 0.
*        lv_mat_rollo TYPE matnr.


  DATA: lv_mov TYPE xflag,
        lv_bob LIKE sy-tabix.

  DATA: lv_answer_2    TYPE c,
        lv_text_2(400) TYPE c,
        lt_param_2     LIKE spar OCCURS 0,
        lv_bob_txt(10) TYPE c.

  DATA: lv_mblnr     TYPE mblnr,
        lv_mjahr     TYPE mjahr,
        lv_new_charg TYPE charg_d.

  DATA: lv_extnumber TYPE balnrext,
        lv_matnr_bob TYPE matnr.

  DATA: lv_cuerpo TYPE zepp0027_cuerpo.

  DATA: lt_messages TYPE tty_bapiret2.

*----------------------------------------------------------------------*



  PERFORM orden_liberada USING gv_orden_300
                                gv_orden_300_int.

  PERFORM stock_rollo USING gv_werks
                            gv_matnr
                            gv_kg
                            gv_lote
                      CHANGING lv_error.

  IF lv_error <> 'X'.

    CLEAR: lv_error.

    DATA: l_rc TYPE char2.

    PERFORM check_bloqueo_of USING gv_orden_300
                          CHANGING l_rc.
    CHECK l_rc = '00'.
*1.-  Se genera un 531 (porque se modifica el material)
    PERFORM lista_materiales USING gv_orden_300
                                   gv_orden_300_int
                                   gv_kg
                             CHANGING gv_lgort_300
                                      lv_mblnr
                                      lv_mjahr
                                      lv_new_charg
                                      lv_error
                                      gv_kg_producir
                                      gv_kg_consum
                                      gv_diferencia
                                      gv_kg_producir_c
                                      gv_kg_consum_c
                                      gv_diferencia_c
                                      gv_diferencia_sem.

    IF lv_error IS INITIAL.

*2.- Clasificar Lote
      PERFORM clasificar_lote_pulper USING lv_mblnr
                                           lv_mjahr
                                           lv_new_charg
                                           gv_diam
                                           gv_kg
                                           gv_long
                                           gv_kunnr_300
                                           lv_new_charg
                                           gv_matnr
                                           gv_pulper
                                     CHANGING lv_error.
      IF lv_error IS INITIAL.

*3.- Notificar
        PERFORM notificar_orden_new USING gv_orden_300
                                          gv_orden_300_int
                                          gv_werks
                                          gv_kg
                                          gv_lote "lv_new_charg
                                          gv_matnr "lv_mat_rollo
                                    CHANGING lv_error
                                             gv_kg_producir
                                             gv_kg_consum
                                             gv_diferencia
                                             gv_kg_producir_c
                                             gv_kg_consum_c
                                             gv_diferencia_c
                                             gv_diferencia_sem.

        IF lv_error IS INITIAL.

*4.- Impresión de etiqueta
          PERFORM imprimir_etiqueta_pulper USING gv_orden_300
                                                     gv_orden_300_int
                                                     gv_diam
                                                     gv_long
                                                     gv_lgort_300
                                                     lv_mblnr
                                                     lv_mjahr
                                                     lv_new_charg.
*                                             CHANGING lv_new_charg .

*5.- Añadir registro al alv
          PERFORM anyadir_nodo USING lv_new_charg
                                     lv_mblnr
                                     lv_mjahr
                                     'P'
                                     '531' ' ' 0
          CHANGING lv_cuerpo.
        ELSE.

          PERFORM anular_doc USING lv_mblnr
                                   lv_mjahr
                                   gv_kg
                             CHANGING lv_error
                                      gv_kg_producir
                                      gv_kg_consum
                                      gv_diferencia
                                      gv_kg_producir_c
                                      gv_kg_consum_c
                                      gv_diferencia_c
                                      gv_diferencia_sem.

*          PERFORM anular_clasificar_lote_pulper USING lv_mblnr
*                                                      lv_mjahr
*                                                CHANGING lv_error.

        ENDIF.

      ELSE.

        PERFORM anular_doc USING lv_mblnr
                                 lv_mjahr
                                 gv_kg
                           CHANGING lv_error
                                    gv_kg_producir
                                    gv_kg_consum
                                    gv_diferencia
                                    gv_kg_producir_c
                                    gv_kg_consum_c
                                    gv_diferencia_c
                                    gv_diferencia_sem.

      ENDIF.
    ENDIF.


*6.-  Mostrar Log
    lt_messages[] = gt_messages[].
    PERFORM clean_vbles.

    CLEAR lv_extnumber.
    CONCATENATE lv_matnr_bob lv_new_charg INTO lv_extnumber.

    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = lt_messages[]
        extnumber = lv_extnumber.

    PERFORM mostrar_log1 USING lt_messages.

  ELSE.
    PERFORM clean_vbles.
    CLEAR: gv_pulper.
  ENDIF.

ENDFORM.                    " PULPER
*&---------------------------------------------------------------------*
*&      Form  LISTA_MATERIALES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM lista_materiales USING  p_aufnr_ext
                             p_aufnr_int
                             p_menge
                      CHANGING gv_lgort_300
                               p_mblnr
                               p_mjahr
                               p_new_charg
                               lv_error
                               p_kg_producir
                               p_kg_consum
                               p_diferencia
                               p_kg_producir_c
                               p_kg_consum_c
                               p_diferencia_c
                               p_diferencia_sem.

  DATA: lv_matnr LIKE afko-plnbez,
        lv_werks LIKE aufk-werks,
        lv_rsnum LIKE afko-rsnum,
        ls_resb  TYPE resb.

  CLEAR: lv_matnr, lv_werks, lv_rsnum, ls_resb.



  SELECT SINGLE afko~plnbez aufk~werks afko~rsnum
          INTO (lv_matnr, lv_werks, lv_rsnum)
    FROM afko
    INNER JOIN aufk ON aufk~aufnr = afko~aufnr
    WHERE afko~aufnr = p_aufnr_int.

  IF sy-subrc = 0.
*--->mhernandez. 23.01.2018
*7000016489, Ticket_##_43615_##_de_ealegre@hinojosa
*    SELECT SINGLE * INTO ls_resb
*     FROM resb
*     WHERE rsnum = lv_rsnum AND
*           sortf = 'SUB'.
*    SELECT SINGLE * INTO ls_resb
    DATA: ls_resb2 TYPE ty_resb.
    SELECT SINGLE matnr , rsnum , MIN( rspos ) AS rspos INTO @ls_resb2
    FROM resb
    WHERE rsnum = @lv_rsnum AND
    sortf = 'SUB' AND
    xloek = @space
      GROUP BY matnr , rsnum.
*<---fin mhernandez

    IF sy-subrc = 0.
      PERFORM alta_stock_pulper USING p_aufnr_int
                                      p_menge
                                      ls_resb2
                                CHANGING lv_error
                                         gv_lgort_300
                                         p_mblnr
                                         p_mjahr
                                         p_new_charg
                                         p_kg_producir
                                         p_kg_consum
                                         p_diferencia
                                         p_kg_producir_c
                                         p_kg_consum_c
                                         p_diferencia_c
                                         p_diferencia_sem.
    ENDIF.
  ENDIF.

ENDFORM.                    " LISTA_MATERIALES
*&---------------------------------------------------------------------*
*&      Form  CLASIFICAR_LOTE_PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM clasificar_lote_pulper USING p_mblnr
                                  p_mjahr
                                  p_new_charg
                                  p_diam
                                  p_menge
                                  p_long
                                  p_cli
                                  p_charg
                                  p_mat_rollo
                                  p_pulper
                            CHANGING
                                     lv_error.

  DATA: lv_object            TYPE objnum,
        ls_alloc_values_num  TYPE bapi1003_alloc_values_num,
        ls_alloc_values_char TYPE bapi1003_alloc_values_char,
        ls_return            TYPE bapiret2.

  DATA: lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_tab.

  DATA: lv_matnr      TYPE matnr,
        lv_charg      TYPE charg_d,
        lv_budat_mkpf TYPE mseg-budat_mkpf.

  CLEAR: lv_object, lt_alloc_values_num, lt_alloc_values_char,
         lt_alloc_values_curr, lt_return, ls_alloc_values_num,
         ls_alloc_values_char, ls_return, lv_matnr, lv_charg.
  REFRESH: lt_alloc_values_num, lt_alloc_values_char,
           lt_alloc_values_curr, lt_return.


  SELECT SINGLE matnr budat_mkpf FROM mseg
    INTO (lv_matnr,lv_budat_mkpf)
    WHERE mblnr = p_mblnr AND
          mjahr = p_mjahr.


  CONCATENATE lv_matnr p_new_charg INTO lv_object.

  " DIAMETRO:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_DIAMETRO'.
  ls_alloc_values_num-value_from = p_diam.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.

  " PESO:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_PESO'.
  ls_alloc_values_num-value_from = p_menge.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.


  " LONGITUD DE BOBINA:
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_LONGITUD_B'.
  ls_alloc_values_num-value_from = p_long.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.

* INI 25/09/2020 - 62887 - CMS - Añadir %FSC a bobina pulper
  CLEAR ls_alloc_values_num.
  ls_alloc_values_num-charact = 'Z_FSC_PORCENTAJE'.
  ls_alloc_values_num-value_from = 100.
  APPEND ls_alloc_values_num TO lt_alloc_values_num.
* FIN 25/09/2020 - 62887 - CMS - Añadir %FSC a bobina pulper


  " FECHA DE FABRICACION:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_FECHA_FABRICACION'.
  IF lv_budat_mkpf IS NOT INITIAL AND lv_budat_mkpf NE '00000000'.
    WRITE lv_budat_mkpf TO ls_alloc_values_char-value_char.
  ELSE.
    WRITE sy-datum TO ls_alloc_values_char-value_char.
  ENDIF.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " CLIENTE:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_CLIENTE'.
  ls_alloc_values_char-value_char = p_cli.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " LOTE ORIGEN:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_LOTE_ORIGEN'.
  ls_alloc_values_char-value_char = gv_lote.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " MATERIAL ORIGEN:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_ROLLO_ORIGEN_V2'.
  ls_alloc_values_char-value_char =  |{ p_mat_rollo ALPHA = OUT }|.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " MOTIVO RECHAZO PULPER:
  IF p_pulper IS NOT INITIAL.
    CLEAR ls_alloc_values_char.
    ls_alloc_values_char-charact = 'ZPPI_MOTIVO_RECHAZO'.
    ls_alloc_values_char-value_char = p_pulper.
    APPEND ls_alloc_values_char TO lt_alloc_values_char.
  ENDIF.
*
  IF gv_werks EQ '3020' AND sy-tcode EQ 'ZPP0034' AND gv_ancho_real IS NOT INITIAL.
    CLEAR ls_alloc_values_num.
    ls_alloc_values_num-charact = 'Z_ANCHO_REAL'.
    ls_alloc_values_num-value_from = gv_ancho_real.
    APPEND ls_alloc_values_num TO lt_alloc_values_num.
  ENDIF.

  " OPERARIO:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'Z_OPERARIO'.
  ls_alloc_values_char-value_char = gv_nombre_oper.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.

  " Puesto de trabajo:
  CLEAR ls_alloc_values_char.
  ls_alloc_values_char-charact = 'ZPPI_PUESTO_TRABAJO'.
  ls_alloc_values_char-value_char = gv_arbpl.
  APPEND ls_alloc_values_char TO lt_alloc_values_char.



  CALL FUNCTION 'BAPI_OBJCL_CHANGE'
    EXPORTING
      objectkey          = lv_object
      objecttable        = 'MCH1'
      classnum           = 'Z_BOBINA_PULPER'
      classtype          = '023'
    TABLES
      allocvaluesnumnew  = lt_alloc_values_num
      allocvaluescharnew = lt_alloc_values_char
      allocvaluescurrnew = lt_alloc_values_curr
      return             = lt_return.

  CLEAR ls_return.
  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
  IF ls_return IS NOT INITIAL. " Error act. característica
    lv_error = 'X'.

    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'
*       IMPORTING
*         RETURN        =
      .

*   REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.
  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

*   GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    READ TABLE lt_return INTO ls_return WITH KEY type = 'S'.
    CLEAR gs_messages.
    gs_messages = ls_return.
    APPEND gs_messages TO gt_messages.

  ENDIF.

* montar log slg1
  CALL FUNCTION 'ZMONTAR_LOG_SLG1'
    EXPORTING
      i_extnumber = ''
      i_object    = 'ZPP'
      i_subobject = sy-tcode
    TABLES
      t_return    = gt_messages.
ENDFORM.                    " CLASIFICAR_LOTE_PULPER
*&---------------------------------------------------------------------*
*&      Form  IMPRIMIR_ETIQUETA_PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM imprimir_etiqueta_pulper USING p_aufnr_ext
                                    p_aufnr_int
                                    p_diam
                                    p_long
                                    gv_lgort_300
                                    lv_mblnr
                                    lv_mjahr
                                    lv_new_charg.
*                              CHANGING p_lote.

  DATA: ls_bobina       TYPE zspp_etiq_bobina_pulper.
  DATA: ls_zebelp1      TYPE posnr_va.
  DATA: l_nodialog      TYPE fpnodialog.

  CLEAR: ls_bobina, ls_zebelp1.

  ls_bobina-diametro = p_diam.
  ls_bobina-charg = lv_new_charg. "p_lote.
  ls_bobina-aufnr = p_aufnr_int.
*  ls_bobina-fec_fabricacion = gv_fecha.
  ls_bobina-fec_fabricacion = sy-datum.
  ls_bobina-lgort = gv_lgort_300.
  ls_bobina-longitud = p_long.
  ls_bobina-arbpl_ent = gv_arbpl.

  SELECT SINGLE afko~plnbez aufk~werks aufk~zzkunnr1 aufk~zzebeln1 aufk~zzebelp1
  INTO (ls_bobina-plnbez, ls_bobina-werks, ls_bobina-kunnr,
  ls_bobina-pedido, ls_zebelp1)
  FROM aufk
  INNER JOIN afko ON afko~aufnr = aufk~aufnr
  WHERE aufk~aufnr = p_aufnr_int.

* SE RECUPERA EL MATERIAL(SUBPRODUCTO) QUE SE HA HECHO EL 531 PARA LA
* ORDEN
  SELECT SINGLE matnr INTO ls_bobina-matnr
   FROM mseg
   WHERE mblnr = lv_mblnr AND
         mjahr = lv_mjahr.

  ls_bobina-posicion = ls_zebelp1.

  CONCATENATE ls_bobina-matnr ls_bobina-charg INTO ls_bobina-cod_barras.

* Gestión de impresión automática/manual para etiqueta pulper

* Doble tratamiento según BOBINA_AUTOMATICA

* Obtenemos el ancho del material a imprimir
  DATA: l_matnr TYPE matnr.
  l_matnr = |{ gv_matnr_300 ALPHA = IN }|.
  SELECT SINGLE zzancho
    INTO @DATA(l_ancho)
    FROM mara
    WHERE matnr = @l_matnr.


  DATA: l_impr_automatica TYPE flag.

  IF g_flag_bob_auto = ' '.

    IF l_ancho               > gs_ztpp0008-ancho_minimo AND
       gs_ztpp0008-cont      = 2 AND
       gs_ztpp0008-act_etiq  = 'X'.
      l_nodialog        = 'X'.
      l_impr_automatica = 'X'.
    ELSE. "Si no cumple las 3 condiciones, limpiamos campos para imprimir Manual y con diálogo
      CLEAR: l_nodialog , l_impr_automatica.
    ENDIF.

    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA_PULPER' " Impresión Manual/automática según botón.
      EXPORTING
        i_bobina          = ls_bobina
        i_impr_automatica = l_impr_automatica    " Enviamos el flag etiq.automática
        i_nodialog        = l_nodialog.          " Si es etiq.auto, SIN diálogo

  ELSE.

* Llamada para Alqueria.
    CALL FUNCTION 'ZMFPP_ETIQ_BOBINA_PULPER'
      EXPORTING
        i_bobina = ls_bobina.


  ENDIF.


ENDFORM.                    " IMPRIMIR_ETIQUETA_PULPER
*&---------------------------------------------------------------------*
*&      Form  ALTA_STOCK_PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_RESB  text
*----------------------------------------------------------------------*
FORM alta_stock_pulper  USING   p_aufnr
                                p_menge
                                ts_resb TYPE ty_resb
                        CHANGING lv_error
                                 p_lgort_300
                                 p_mblnr
                                 p_mjahr
                                 p_new_charg
                                 p_kg_producir
                                 p_kg_consum
                                 p_diferencia
                                 p_kg_producir_c
                                 p_kg_consum_c
                                 p_diferencia_c
                                 p_diferencia_sem
                                 .


  DATA: ls_header  TYPE bapi2017_gm_head_01,
        lt_return  LIKE bapiret2 OCCURS 0,
        ls_return  TYPE bapiret2,
        lt_item    LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item    TYPE bapi2017_gm_item_create,
        ls_headret TYPE bapi2017_gm_head_ret.

  DATA: ls_afko TYPE afko.
  DATA: ls_aufk TYPE aufk.
  DATA: ls_afpo TYPE afpo.

  CLEAR: p_mblnr, p_mjahr, lt_item, ls_header, ls_item,
         ls_afko, ls_aufk, ls_afpo.

  REFRESH: lt_item, lt_return.

* SGM - ini 03.08.2017 Ticket 0000043398
  CALL FUNCTION 'BUFFER_REFRESH_ALL'.
  CALL FUNCTION 'CO_SF_DATA_RESET'.
* SGM - fin 03.08.2017 Ticket 0000043398

* cabecera
  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.
  ls_header-pr_uname = sy-uname.

  ls_header-header_txt = 'Notificacion de bobinas'.

* recuperar datos orden
  SELECT SINGLE * INTO ls_afko
   FROM afko
   WHERE aufnr = p_aufnr.

  SELECT SINGLE * INTO ls_aufk
    FROM aufk
    WHERE aufnr = p_aufnr.

  SELECT SINGLE * INTO ls_afpo
    FROM afpo
    WHERE aufnr = p_aufnr AND
          posnr = '0001'.

* posicion
  ls_item-material = ts_resb-matnr.
  ls_item-plant = ls_aufk-werks.
  ls_item-stge_loc = '1000'.

  p_lgort_300 = ls_item-stge_loc.

  ls_item-move_type = '531'.
  ls_item-entry_qnt = p_menge.
  ls_item-entry_uom = 'KG'.
  ls_item-reserv_no = ts_resb-rsnum.
  ls_item-res_item =  ts_resb-rspos.

  APPEND ls_item TO lt_item.


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = '03'
*     TESTRUN          = ' '
*     GOODSMVT_REF_EWM =
    IMPORTING
      goodsmvt_headret = ls_headret
      materialdocument = p_mblnr
      matdocumentyear  = p_mjahr
    TABLES
      goodsmvt_item    = lt_item
      return           = lt_return.

  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
  IF sy-subrc <> 0.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

*   GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    CLEAR gs_messages.

    gs_messages-type = 'S'.
    gs_messages-number = '012'.
    gs_messages-id = 'ZPP'.
    gs_messages-message_v1 = p_mblnr.
    gs_messages-message_v2 = p_mjahr.

    APPEND gs_messages TO gt_messages.

    SELECT SINGLE charg FROM mseg
      INTO p_new_charg
      WHERE mblnr = p_mblnr AND
            mjahr = p_mjahr.

  ELSE.
    lv_error = 'X'.

*   REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.
  ENDIF.

* guardar los en SLG1
  CALL FUNCTION 'ZMONTAR_LOG_SLG1'
    EXPORTING
      i_extnumber = ''
      i_object    = 'ZPP'
      i_subobject = sy-tcode
    TABLES
      t_return    = gt_messages.

ENDFORM.                    " ALTA_STOCK_PULPER
*&---------------------------------------------------------------------*
*&      Form  REPROCESO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM reproceso CHANGING gv_repr TYPE cawn-atwrt.
*----------------------------------------------------------------------*
* realizará la notificación de una bobina para reprocesar en los términos
* actuales, es decir, alta de bobina para reprocesar (movimiento 101 en
* almacén 4001), notificación de tiempos e impresión de etiqueta de bobina
* para reprocesar (funcionalidad ya existente en la transacción
* ZPP0012/22/23, alta de bobina para reprocesar)
* Cuando se seleccione esta opción saltará una ventana con los motivos que
* han provocado el alta de la bobina a reprocesar para que el usuario
* seleccione uno de ellos (actualmente lista desplegable en la transacción
* ZPP0012/22/23 seleccionando la opción bobina para reprocesado)
*----------------------------------------------------------------------*
  DATA: lv_error     TYPE xfeld,
        lv_peso(15)  TYPE c,
        lv_text(400) TYPE c,
        lv_answer    TYPE c,
        lt_param     LIKE spar OCCURS 0.


  DATA: lv_mov TYPE xflag,
        lv_bob LIKE sy-tabix.

  DATA: lv_answer_2    TYPE c,
        lv_text_2(400) TYPE c,
        lt_param_2     LIKE spar OCCURS 0,
        lv_bob_txt(10) TYPE c.

  DATA: lv_mblnr     TYPE mblnr,
        lv_mjahr     TYPE mjahr,
        lv_new_charg TYPE charg_d.

  DATA: lv_extnumber TYPE balnrext.

  DATA: lv_reproceso TYPE xfeld.

  DATA: lv_cuerpo TYPE zepp0027_cuerpo.

  DATA: lt_messages LIKE bapiret2 OCCURS 0.

*----------------------------------------------------------------------*

  lv_reproceso  = 'X'.

  PERFORM orden_liberada USING gv_orden_300
                               gv_orden_300_int.

  PERFORM stock_rollo USING gv_werks
                            gv_matnr
                            gv_kg
                            gv_lote
                      CHANGING lv_error.

  IF lv_error <> 'X'.

    DATA: l_rc TYPE char2.

    PERFORM check_bloqueo_of USING gv_orden_300
                          CHANGING l_rc.
    CHECK l_rc = '00'.

*1.-  alta de stock con orden y creación del lote
    PERFORM alta_stock USING gv_orden_300
                             gv_orden_300_int
                             gv_werks
                             gv_matnr
                             gv_kg
                             lv_reproceso
                       CHANGING lv_error
                                lv_mblnr
                                lv_mjahr
                                lv_new_charg
                                gv_lgort_300
                                gv_kg_producir
                                gv_kg_consum
                                gv_diferencia
                                gv_kg_producir_c
                                gv_kg_consum_c
                                gv_diferencia_c
                                gv_diferencia_sem.

    IF lv_error IS INITIAL.
*2.- Clasificar Lote
      PERFORM clasificar_lote USING lv_mblnr
                                    lv_mjahr
                                    gv_diam
                                    gv_kg
                                    gv_long
                                    gv_empa
                                    gv_kunnr_300
                                    gv_ped_300
                                    gv_pos_300
                                    lv_new_charg
                                    gv_matnr
                                    lv_reproceso
                                    gv_repr
                              CHANGING
*                                  lv_new_charg
                                       lv_error.
      IF lv_error IS INITIAL.

*3.- Notificar
        PERFORM notificar_orden_new USING gv_orden_300
                                          gv_orden_300_int
                                          gv_werks
                                          gv_kg
                                          gv_lote
                                          gv_matnr "lv_mat_rollo
                                    CHANGING lv_error
                                             gv_kg_producir
                                             gv_kg_consum
                                             gv_diferencia
                                             gv_kg_producir_c
                                             gv_kg_consum_c
                                             gv_diferencia_c
                                             gv_diferencia_sem.

        IF lv_error IS INITIAL.

*4.- Alta defecto bobina 17/10/23 UDEFINE
          CLEAR gs_dyn601.

          gv_modification = ' '.
          "Valor lote bobina para defectos bobina y etiqueta de muestra
          gv_lote_bob     = lv_new_charg.
          "Valor del motivo de reproceso para defecto de bobina antes de que lo limpie el perform anyadir_nodo.
          gv_motivo_repr = gv_repr.

          CALL SCREEN 601.

*5.- Impresión de etiqueta
          PERFORM imprimir_etiqueta USING gv_orden_300
                                          gv_orden_300_int
                                          lv_new_charg
                                          gv_werks
                                          gv_diam
                                          gv_long
                                          gv_lgort_300
                                          'X'.

          lv_cuerpo-charg = lv_new_charg.

          SELECT SINGLE zzkunnr1
            INTO @DATA(l_kunnr_300)
            FROM aufk
            WHERE aufnr = @gv_orden_300.
* Solo si no es cabo, se reimprime etiqueta laboratorio
          IF zcl_utils_hpap_pp=>es_cabo( i_matnr = g_matnr_etiq
                               i_kunnr = l_kunnr_300 ) = ' '.

            PERFORM reimprimir_etiq_obs_lab USING lv_cuerpo
                                                 'X'.
          ENDIF.

*6.- Añadir registro al alv
          PERFORM anyadir_nodo USING lv_new_charg
                                     lv_mblnr
                                     lv_mjahr
                                     'R'
                                     '101' ' ' 0
                               CHANGING lv_cuerpo.
        ELSE.
*         Anulamos clasificación del lote y el alta de stock
          PERFORM anular_doc USING lv_mblnr
                                   lv_mjahr
                                   gv_kg
                             CHANGING lv_error
                                      gv_kg_producir
                                      gv_kg_consum
                                      gv_diferencia
                                      gv_kg_producir_c
                                      gv_kg_consum_c
                                      gv_diferencia_c
                                      gv_diferencia_sem.

        ENDIF.
      ELSE.
*       Anulamos alta de stock
        PERFORM anular_doc USING lv_mblnr
                                 lv_mjahr
                                 gv_kg
                           CHANGING lv_error
                                    gv_kg_producir
                                    gv_kg_consum
                                    gv_diferencia
                                    gv_kg_producir_c
                                    gv_kg_consum_c
                                    gv_diferencia_c
                                    gv_diferencia_sem.

      ENDIF.
    ENDIF.

*7.-  Mostrar Log
    lt_messages[] = gt_messages[].
    PERFORM clean_vbles.

    CLEAR lv_extnumber.
    CONCATENATE gv_matnr_300 lv_new_charg INTO lv_extnumber.

    CALL FUNCTION 'ZMFPP_GUARDAR_LOG'
      EXPORTING
        objeto    = 'ZPP'
        subobjeto = sy-tcode
        mensajes  = lt_messages[]
        extnumber = lv_extnumber.

    PERFORM mostrar_log1 USING lt_messages.

  ELSE.
    PERFORM clean_vbles.
    CLEAR: gv_repr.
    CLEAR gs_dyn601.
  ENDIF.
ENDFORM.                    " REPROCESO
*&---------------------------------------------------------------------*
*&      Form  VALIDAR_DATOS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_KG  text
*      -->P_GV_DIAM  text
*      -->P_GV_LONG  text
*----------------------------------------------------------------------*
FORM validar_datos  USING   p_matnr
                            p_arbpl
                            p_werks
                            p_kg
                            p_diam
                            p_long
                            boton TYPE c
                    CHANGING p_error.

*  IF p_kg IS INITIAL OR p_diam IS INITIAL OR p_long IS INITIAL.
*    p_error = 'X'.
*    MESSAGE i000(zpp) WITH text-015.
*  ELSE.
  PERFORM calcular_valores_max USING p_matnr
                                     p_arbpl
                                     p_werks
                                     p_kg
                                     p_diam
                                     p_long
                                     boton
                               CHANGING p_error.
*  ENDIF.

ENDFORM.                    " VALIDAR_DATOS
*&---------------------------------------------------------------------*
*&      Form  CALCULAR_PESO_MAX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GV_MATNR  text
*      <--P_LV_PESO_MAX  text
*----------------------------------------------------------------------*
FORM calcular_valores_max  USING p_matnr
                                 p_arbpl
                                 p_werks
                                 p_kg
                                 p_diam
                                 p_long
                                 boton
                           CHANGING p_error.

  DATA: lv_matnr       TYPE matnr,
        lv_gramaje     TYPE mara-zzgramaje,
        lv_ancho       TYPE mara-zzancho,
        lv_ancho_300   TYPE mara-zzancho,
        lv_ancho_d     TYPE p LENGTH 4 DECIMALS 2,
        lv_peso        TYPE atflv,
        lv_dif_peso    TYPE atflv,
        lv_coeficiente TYPE atflv.

  DATA: lv_diametro     TYPE p,
        lv_dif_diametro TYPE p.

  CONSTANTS: c_pi TYPE p DECIMALS 10 VALUE '3.1415926536'.

  DATA: wa_ztpp0008 TYPE ztpp0008.

  DATA: lv_answer      TYPE c,
        lv_text(400)   TYPE c,
        lv_text_2(400) TYPE c.

  DATA: lv_matnr_300_int     TYPE matnr.

  DATA: lv_clabs TYPE mchb-clabs.

  DATA: wa_afko TYPE afko,
        wa_resb TYPE resb.

  CLEAR: lv_gramaje, lv_ancho, lv_dif_peso, lv_diametro,
         lv_dif_diametro, lv_clabs, p_error, lv_coeficiente,
         g_cambio_ancho_cabo , g_matnr_cambio_ancho.



* obtenemos la información de la tabla ZTPP0008
  SELECT SINGLE * FROM ztpp0008
    INTO wa_ztpp0008
    WHERE werks = p_werks AND
          arbpl = p_arbpl.

  IF g_flag_bob_auto = 'X'.

*----------------------------------------------------------------------*
**  validación del PESO
*----------------------------------------------------------------------*
* obtener el peso aproximado de la bobina aplicando la siguiente fórmula:
* Peso (kg) = (Gramaje (g/m2) x Ancho (m) x Longitud (m)/1000)
* Donde gramaje (MARA-ZZGRAMAJE) y ancho (MARA-ZZANCHO) se obtienen del
* material y longitud de la longitud introducida en la notificación.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = p_matnr
      IMPORTING
        output = lv_matnr.

    SELECT SINGLE zzgramaje zzancho FROM mara
      INTO ( lv_gramaje, lv_ancho )
      WHERE matnr = lv_matnr.

    lv_ancho_d  = lv_ancho / 1000. "pasamos el ancho que está en cm a m

* Peso (kg) = (Gramaje (g/m2) x Ancho (m) x Longitud (m)/1000)
    lv_peso  = ( lv_gramaje * lv_ancho_d  * gv_long / 1000 ).

* Si la diferencia entre el peso introducido y el peso calculado supera,
* por exceso o por defecto, la tolerancia permitida se avisará de esta
* circunstancia (Datos de notificación incoherentes (peso)
* Desea notificar igualmente | Cancelar, Aceptar)

    lv_dif_peso = lv_peso - p_kg.

    lv_dif_peso = abs( lv_dif_peso ).

    lv_coeficiente  = ( lv_dif_peso / p_kg ) * 100.


    DATA: l_peso_sup TYPE p DECIMALS 2, l_peso_inf TYPE p DECIMALS 2.
    l_peso_sup = lv_peso + ( lv_peso * wa_ztpp0008-tolerancia_peso / 100 ).
    l_peso_inf = lv_peso - ( lv_peso * wa_ztpp0008-tolerancia_peso / 100 ).



    DATA(l_string_coef) = |Peso SUP:{ l_peso_sup } Peso INF:{ l_peso_inf }|.

    IF lv_coeficiente > wa_ztpp0008-tolerancia_peso.
      p_error = 'X'.

      lv_text   = |@1A@ Peso teórico superior:   { l_peso_sup NUMBER = USER }|.
      lv_text_2 = |@1A@ Peso teórico inferior:    { l_peso_inf NUMBER = USER }|.

      CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
        EXPORTING
          defaultoption  = 'N'
          diagnosetext1  = '@1A@ ATENCION REVISAR PESO '
          diagnosetext2  = lv_text
          diagnosetext3  = lv_text_2
          textline1      = 'El peso supera la tolerancia definida!!'
          textline2      = '¿Desea notificar igualmente?'
          titel          = 'Revisar peso'
*         START_COLUMN   = 25
*         START_ROW      = 6
          cancel_display = ''
        IMPORTING
          answer         = lv_answer.

      IF lv_answer = 'J'.
        p_error = ''.
      ENDIF.
    ENDIF.

    CHECK p_error = ''.

*----------------------------------------------------------------------*
**  validación del DIÁMETRO
*----------------------------------------------------------------------*
* obtener el diámetro aproximado de la bobina aplicando la siguiente fórmula:
* Diámetro = Raíz Cuadrada (Peso x 4 / ( PI() x 820 x Ancho))
*  lv_diametro = ( sqrt( ( lv_peso * 4 ) / ( c_pi * 820 * lv_ancho_d ) ) ) * 1000.
    lv_diametro = ( sqrt( ( lv_peso * 4 ) / ( c_pi * 760 * lv_ancho_d ) ) ) * 1000. "uDefine, cambio densidad por 760 en lugar de 820

* Si la diferencia entre el diámetro introducido y el diámetro calculado supera,
* por exceso o por defecto, la tolerancia permitida se avisará de esta
* circunstancia (Datos de notificación incoherentes (diámetro)
* Desea notificar igualmente | Cancelar, Aceptar)
    lv_dif_diametro = lv_diametro - p_diam.

    lv_dif_diametro = abs( lv_dif_diametro ).

    CLEAR: lv_coeficiente.

    lv_coeficiente = ( lv_dif_diametro / p_diam ) * 100.
    gv_coeficiente = lv_diametro.

    DATA: l_diametro_sup TYPE p DECIMALS 2, l_diametro_inf TYPE p DECIMALS 2.
    l_diametro_sup = lv_diametro + ( lv_diametro * wa_ztpp0008-tolerancia_diametro / 100 ).
    l_diametro_inf = lv_diametro - ( lv_diametro * wa_ztpp0008-tolerancia_diametro / 100 ).



    l_string_coef = |Diametro SUP:{ l_diametro_sup } Diametro INF:{ l_diametro_inf }|.


    IF lv_coeficiente  > wa_ztpp0008-tolerancia_diametro.
      p_error = 'X'.

      lv_text   = |@1A@ Diámetro teórico superior:   { l_diametro_sup NUMBER = USER }|.
      lv_text_2 = |@1A@ Diámetro teórico inferior:    { l_diametro_inf NUMBER = USER }|.

      CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
        EXPORTING
          defaultoption  = 'N'
          diagnosetext1  = '@1A@ ATENCION REVISAR DIAMETRO'
          diagnosetext2  = lv_text
          diagnosetext3  = lv_text_2
          textline1      = 'El diámetro supera la tolerancia definida!!'
          textline2      = '¿Desea notificar igualmente?'
          titel          = 'Revisar diámetro.'
*         START_COLUMN   = 25
*         START_ROW      = 6
          cancel_display = ''
        IMPORTING
          answer         = lv_answer.


      IF lv_answer = 'J'.
*    IF lv_answer IS INITIAL OR lv_answer = '1'.
        p_error = ''.
      ENDIF.
    ENDIF.

  ENDIF.
* INI CGIJON - 16.01.18 - SAT 7000018339
  CHECK p_error = ''.

* Se deberá de verificar que el material de cabecera de la orden con
* clase de orden ZI01 está en la reserva de la orden con clase de orden ZI02.
  SELECT SINGLE * FROM resb
    INTO wa_resb
    WHERE matnr = gv_matnr AND
          werks = gv_werks AND
          aufnr = gv_orden_300_int AND
          xloek = space .

  IF sy-subrc <> 0.
    p_error = 'X'.
    MESSAGE i000(zpp) WITH text-031 text-032.
  ENDIF.

  CHECK p_error = ''.
* FIN CGIJON - 16.01.18 - SAT 7000018339



  lv_matnr_300_int = |{ gv_matnr_300 ALPHA = IN }|.
  SELECT SINGLE zzancho FROM mara
   INTO ( lv_ancho_300 )
   WHERE matnr = lv_matnr_300_int.


* INI CGIJON - 16.01.18 - SAT 7000018338
  IF boton <> '2'. "SOLO PARA EL BOTÓN ETIQUETA Y REPROCESO
*    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*      EXPORTING
*        input  = gv_matnr_300
*      IMPORTING
*        output = lv_matnr_300_int.

*    SELECT SINGLE zzancho FROM mara
*     INTO ( lv_ancho_300 )
*     WHERE matnr = lv_matnr_300_int.

    IF lv_ancho_300 < wa_ztpp0008-ancho_min_pulp.
      p_error = 'X'.
      MESSAGE e283(zpp) DISPLAY LIKE 'I'. "Para este ancho únicamente se permite notificar bobina pulper
    ENDIF.

    CHECK p_error = ''.
  ENDIF.
* FIN CGIJON - 16.01.18 - SAT 7000018338

**  validación de la Cantidad kg consumo de rollo
* por cada notificación realizada, independientemente que se trate de bobina,
* bobina pulper o bobina a reprocesar, se calculará la cantidad de kg
* consumidos (sumatorio de movimientos 261/262 del rollo en la OF de bobina)
* y la diferencia respecto a los kg producidos del rollo.
* Si se intenta realizar una notificación por una cantidad superior a la
* diferencia de kg existente en ese momento se mostrará un error
* (Los kg consumidos del lote superan los kg producidos. No se permite
* La notificación | Aceptar) y no permitir la notificación.
  SELECT SINGLE clabs FROM mchb
    INTO lv_clabs
    WHERE matnr = gv_matnr AND
          werks = gv_werks AND
          charg = gv_lote.

  IF gv_kg > lv_clabs.
    p_error = 'X'.
    MESSAGE i000(zpp) WITH text-029.
    EXIT.
  ENDIF.


* Validación válida para Boton Etiqueta(boton=1) y bobina.
* Cuando sea un cabo + (pulper o repr.) no se validará ancho.
  IF boton = 1 OR lv_ancho_300 > 1340.
    PERFORM validar_ancho_bbdd_ext    USING lv_ancho_300
                                   CHANGING p_error.
  ELSE.
    CLEAR: g_ancho_bbdd , g_matnr_cambio_ancho.
  ENDIF.

ENDFORM.                    " CALCULAR_PESO_MAX

FORM validar_ancho_bbdd_ext  USING p_ancho_notif TYPE zancho
                          CHANGING p_error TYPE xfeld. " CHANGING lv_repr

  DATA: l_string    TYPE string,
        l_string2   TYPE string,
        l_rc        TYPE char1,
        l_ancho_txt TYPE char4.


  CLEAR: p_error , g_cambio_ancho_cabo.

* Si el ancho es mayor al ancho máximo, actualizamos valor a Cero para salir y no validar nada mas.
  IF g_ancho_bbdd > gs_ztpp0008-ancho_maximo.
    g_ancho_bbdd = 0.
  ENDIF.

  CHECK g_ancho_bbdd > 0.

* Calcular diferencia entre el ancho notificado y el recibido
  DATA(l_dif)      = abs( p_ancho_notif - g_ancho_bbdd ).


  CHECK l_dif >= gs_ztpp0008-tolerancia_ancho. " Si la diferencia es mayor que la desviación permitida (ZTPP0008-TOLERANCIA_ANCHO = 10mm),

  PERFORM redondeo_ancho_para_matnr.

  l_ancho_txt = |{ g_ancho_bbdd ALPHA = OUT }|.
  l_string  = |@1A@ Ancho leído: { l_ancho_txt } mm|.

  l_ancho_txt = |{ p_ancho_notif ALPHA = OUT }|.
  l_string2 = |@1A@ Ancho OF: { l_ancho_txt } mm|.

  CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
    EXPORTING
      defaultoption  = 'N'
      diagnosetext1  = '@1A@ ATENCIÓN ANCHOS DIFERENTES '
      diagnosetext2  = l_string
      diagnosetext3  = l_string2
      textline1      = 'Ancho leído y ancho OF no corresponden'
      textline2      = '¿Desea notificar igualmente?'
      titel          = 'ATENCION'
      start_column   = 20
      start_row      = 4
      cancel_display = ''
    IMPORTING
      answer         = l_rc.

  IF l_rc NE 'J'.
    p_error = 'X'.
    MESSAGE i000(zpp) WITH 'Notificación cancelada.'.
    EXIT.
  ENDIF.

  CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
    EXPORTING
      defaultoption  = 'N'
      diagnosetext1  = '@1A@ ATENCIÓN'
      diagnosetext2  = l_string
      diagnosetext3  = l_string2
      textline1      = 'El ancho de la etiqueta no corresponde al ancho de la bobina.'
      textline2      = '¿Desea continuar?'
      titel          = '¡ATENCION!'
      start_column   = 62
      start_row      = 8
      cancel_display = ''
    IMPORTING
      answer         = l_rc.

  IF l_rc NE 'J'.
    p_error = 'X'.
    MESSAGE i000(zpp) WITH 'Notificación cancelada.'.
    EXIT.
  ELSE.

    IF p_ancho_notif <= 1340.
      g_cambio_ancho_cabo = 'X'.
    ELSE.

      CALL FUNCTION 'ZPP_PANTALLA_AVISO'
        EXPORTING
          titulo   = 'Notificación con ancho diferente'
          tp_icono = 'W'
          text1    = '¡ATENCIÓN! Ancho diferente.'
          text2    = 'Informar de la incidencia a Expediciones.'.
      CLEAR: g_ancho_bbdd , g_matnr_cambio_ancho , g_matnr_cambio_ancho.
    ENDIF.
  ENDIF.
ENDFORM.                    " validar_ancho_bbdd_ext

FORM avisos_cambio_ancho_cabo USING p_matnr_300 TYPE matnr
                             p_charg              TYPE charg_d
                    CHANGING p_mblnr              TYPE mblnr
                             p_mjahr              TYPE mjahr
                             p_error              TYPE flag.

  DATA: l_string    TYPE string,
        l_string2   TYPE string,
        l_rc        TYPE char1,
        l_ancho_txt TYPE char4.

  CLEAR:  p_mblnr.

* Obtener ancho del material notificado.
  SELECT SINGLE zzancho
    INTO @DATA(l_ancho_notif)
    FROM mara
    WHERE matnr = @p_matnr_300.

* Solo procesar cambio ancho cuando sea cabo.
  CHECK l_ancho_notif <= 1340.


  IF g_matnr_cambio_ancho IS INITIAL.
*      p_error = 'X'.
*      MESSAGE i000(zpp) WITH 'Ancho de cabo incorrecto.'.
    MESSAGE |Ancho de cabo incorrecto.| TYPE 'I' DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.


  l_ancho_txt = |{ g_ancho_bbdd ALPHA = OUT }|.
  CLEAR: l_string  , l_string2.
  l_string  = |@1A@ Nuevo ancho de cabo: { l_ancho_txt } mm|.
  l_string2  = |Se realizará un cambio de ancho de cabo a { l_ancho_txt } mm.  |.

  CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
    EXPORTING
      defaultoption  = 'N'
      diagnosetext1  = '@1A@ ATENCIÓN CAMBIO DE ANCHO '
      diagnosetext2  = l_string
*     diagnosetext3  = l_string2
      textline1      = l_string2
      textline2      = '¿Desea continuar?'
      titel          = 'OPERACIÓN DE CAMBIO DE ANCHO'
      start_column   = 20
      start_row      = 4
      cancel_display = ''
    IMPORTING
      answer         = l_rc.

  IF l_rc NE 'J'.
    CLEAR:  g_matnr_cambio_ancho , g_ancho_bbdd.
*    MESSAGE |Cambio de ancho cancelado. Informar de la incidencia a Expediciones.| TYPE 'I' DISPLAY LIKE 'E'.
*    MESSAGE |Notificación con ancho diferente. Informar de la incidencia a Expediciones.| TYPE 'I'.

    CALL FUNCTION 'ZPP_PANTALLA_AVISO'
      EXPORTING
        titulo   = 'Notificación con ancho diferente'
        tp_icono = 'W'
        text1    = '¡ATENCIÓN! Ancho diferente.'
        text2    = 'Informar de la incidencia a Expediciones.'.


    EXIT.
  ELSE.

    PERFORM cambio_ancho USING p_charg
                      CHANGING p_mblnr
                               p_mjahr
                               p_error.
  ENDIF.

ENDFORM.                    " avisos_cambio_ancho_cabo


FORM redondeo_ancho_para_matnr.

  DATA: l_ancho TYPE mara-zzancho,
        l_dec   TYPE p DECIMALS 2,
        l_dec2  TYPE p DECIMALS 2.

* Redondeo del ancho a múltiple de 10.
  l_dec = g_ancho_bbdd / 10.
  l_dec2 = round( val = l_dec dec = 0 ).
  l_ancho = l_dec2 * 10.

* Construir el material con el nuevo ancho
  DATA(l_matnr) = |{ gv_matnr_300 ALPHA = IN }|.
  DATA(l_len) = strlen( l_matnr ).
  l_len = l_len - 4.
  l_matnr = |{ l_matnr(l_len) }{ l_ancho }|.
  l_matnr = |{ l_matnr ALPHA = IN }|.

* Validar si el material con el ancho de la BBDD redondeado existe.
  SELECT SINGLE matnr
    INTO @g_matnr_cambio_ancho
    FROM marc
    WHERE matnr = @l_matnr  AND
          werks = @gv_werks AND
          lvorm = @space.

* Si no se encuentra, limpiamos campo del material
  IF sy-subrc <> 0.
    CLEAR g_matnr_cambio_ancho.
  ELSE.
    g_ancho_bbdd =   l_ancho.
  ENDIF.

ENDFORM.


FORM cambio_ancho USING p_charg TYPE charg_d
                CHANGING p_mblnr           TYPE mblnr
                         p_mjahr           TYPE mjahr
                         p_error              TYPE flag.



  CLEAR: p_error.
  DATA lv_objectkey  TYPE bapi1003_key-object.
  DATA :lt_alloc_values_num  TYPE tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE tt_bapi1003_alloc_values_curr,
        lt_return            TYPE bapiret2_t.

  DATA: ls_goodsmvt_header TYPE bapi2017_gm_head_01,
        ls_goodsmvt_item   TYPE bapi2017_gm_item_create,
        lv_goodsmvt_code   TYPE bapi2017_gm_code,
        lt_goodsmvt_item   TYPE TABLE OF bapi2017_gm_item_create,

*        lv_mblnr           TYPE mblnr,
        lt_valuesnum       TYPE TABLE OF bapi1003_alloc_values_num,
        lt_valueschar      TYPE TABLE OF bapi1003_alloc_values_char,
        lt_valuescurr      TYPE TABLE OF bapi1003_alloc_values_curr,
        ls_valuesnum       TYPE bapi1003_alloc_values_num,
*        ls_valueschar      TYPE bapi1003_alloc_values_char,
*        ls_valuescurr      TYPE bapi1003_alloc_values_curr,
        lv_diametro        TYPE p DECIMALS 0,
        lv_longitud        TYPE p DECIMALS 0,
        lv_cliente         TYPE atwrt,
        lv_go              TYPE char1,
        l_matnr            TYPE matnr.

  l_matnr = |{ gv_matnr_300 ALPHA = IN }|.

  CLEAR: p_mblnr.
  ls_goodsmvt_header-pstng_date = sy-datum.
  ls_goodsmvt_header-doc_date   = sy-datum.
  ls_goodsmvt_header-header_txt = 'Cambio ancho cabo'.

  ls_goodsmvt_item-material     = l_matnr.
  ls_goodsmvt_item-plant        = gv_werks.
  ls_goodsmvt_item-stge_loc     = gv_lgort_300.
  ls_goodsmvt_item-batch        = p_charg.
  ls_goodsmvt_item-move_type    = '309'.


  ls_goodsmvt_item-move_mat     = g_matnr_cambio_ancho.
  ls_goodsmvt_item-entry_qnt    = gv_kg.
  ls_goodsmvt_item-move_plant   = gv_werks.


  ls_goodsmvt_item-move_batch   = p_charg.
  APPEND ls_goodsmvt_item TO lt_goodsmvt_item.

  lv_goodsmvt_code = '04'.  "04 – MB1B – Registro de traspaso


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_goodsmvt_header
      goodsmvt_code    = lv_goodsmvt_code
    IMPORTING
      materialdocument = p_mblnr
      matdocumentyear  = p_mjahr
    TABLES
      goodsmvt_item    = lt_goodsmvt_item
      return           = lt_return.
  IF lt_return[] IS NOT INITIAL.
***    PERFORM add_log TABLES lt_return.
  ENDIF.
  IF p_mblnr IS INITIAL.
    CLEAR g_matnr_cambio_ancho.
    p_error = 'X'.
    RETURN.
  ENDIF.

  CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
    EXPORTING
      wait = abap_true.

ENDFORM.                    " CAMBIO ANCHO
*&---------------------------------------------------------------------*
*&      Form  SELECCIONAR_MOTIVO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM seleccionar_motivo_reproceso CHANGING lv_repr
                                           lv_error.

  DATA: lv_atinn TYPE atinn.

  TYPES: BEGIN OF tipo_reproceso,
           atwrt TYPE atwrt,
           atwtb TYPE atwtb.
  TYPES: END OF tipo_reproceso.
  TYPES: tty_tipo_reproceso TYPE TABLE OF tipo_reproceso.

  DATA: lt_reproceso       TYPE          tty_tipo_reproceso,
        wa_reproceso       TYPE LINE OF  tty_tipo_reproceso,
        lt_zvpp_carac_repr TYPE TABLE OF zvpp_carac_repr,
        wa_vpp_carac_repr  TYPE          zvpp_carac_repr.

  DATA: lv_choice TYPE sy-tabix,
        l_rc      TYPE c,
        lv_text   TYPE c LENGTH 100.



  SELECT SINGLE atinn FROM cabn
    INTO lv_atinn
    WHERE atnam = 'ZPPI_MOTIVO_REPROCESO_BOBINA'.

  IF lv_atinn IS NOT INITIAL.
    SELECT * FROM zvpp_carac_repr
      INTO TABLE lt_zvpp_carac_repr
      WHERE atinn = lv_atinn.

    IF lt_zvpp_carac_repr[] IS NOT INITIAL.

      LOOP AT lt_zvpp_carac_repr INTO wa_vpp_carac_repr.
        MOVE-CORRESPONDING wa_vpp_carac_repr TO wa_reproceso.
        APPEND wa_reproceso TO lt_reproceso.
      ENDLOOP.


      CALL FUNCTION 'POPUP_WITH_TABLE_DISPLAY'
        EXPORTING
          endpos_col   = 60
          endpos_row   = 20
          startpos_col = 1
          startpos_row = 1
          titletext    = text-016
        IMPORTING
          choise       = lv_choice
        TABLES
          valuetab     = lt_reproceso
        EXCEPTIONS
          break_off    = 1
          OTHERS       = 2.
      IF sy-subrc <> 0.
        lv_error = 'X'.
        EXIT.
      ENDIF.

      IF lv_choice IS NOT INITIAL.
        READ TABLE lt_reproceso INTO wa_reproceso INDEX lv_choice.

        lv_text = wa_reproceso-atwtb.

* 12/04/2021 - 57299 - CMS Únicamente se permitirá la notificación de un cabo a reproceso conel motivo cabero enganchado
        IF zcl_utils_hpap_pp=>es_cabo( i_matnr = gv_matnr_300 i_kunnr = gv_kunnr_300 ) = 'X' AND
           lv_text <> 'Cabero Enganchado'.

          lv_error = ' '.
          lv_repr  = ' '.
          MESSAGE |Únicamente se permite motivo "Cabero enganchado".| TYPE 'I' DISPLAY LIKE 'E'.
          EXIT.

        ENDIF.

        CALL FUNCTION 'POPUP_TO_CONFIRM_STEP'
          EXPORTING
            defaultoption  = '2'
            textline1      = text-026 "¿Está seguro del motivo indicado?'(902)
            textline2      = lv_text "
            titel          = 'Confirmación'(904)
            cancel_display = ' '
          IMPORTING
            answer         = l_rc
          EXCEPTIONS
            text_not_found = 1
            OTHERS         = 2.
*
        IF sy-subrc <> 0.
          lv_error = 'X'.
          EXIT.
        ENDIF.

        IF l_rc EQ 'J'. "Si
          lv_repr = wa_reproceso-atwrt.
        ELSEIF l_rc EQ 'A'. "cancelar el proceso de seleccion
          lv_error = 'X'.
        ELSE.
          lv_repr = ''.
        ENDIF.
*        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " SELECCIONAR_MOTIVO
*&---------------------------------------------------------------------*
*&      Form  ANYADIR_NODO_ETIQUETA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM anyadir_nodo USING p_new_charg
                        p_mblnr
                        p_mjahr
                        p_tipo
                        p_bwart
                          p_mblnr_309
                        p_mjahr_309

  CHANGING cuerpo TYPE zepp0027_cuerpo.



  DATA: lv_matnr   TYPE matnr,
        lv_aufnr   TYPE aufnr,
        l_next_key TYPE lvc_nkey,
        l_last_key TYPE lvc_nkey.

  DATA: lv_object            TYPE         objnum,
        lt_alloc_values_num  TYPE         tt_bapi1003_alloc_values_num,
        wa_num               TYPE LINE OF tt_bapi1003_alloc_values_num,
        lt_alloc_values_char TYPE         tt_bapi1003_alloc_values_char,
        wa_char              TYPE LINE OF tt_bapi1003_alloc_values_char,
        lt_alloc_values_curr TYPE         tt_bapi1003_alloc_values_curr,
        lt_return            TYPE         bapiret2_tab.


  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = gv_orden_300
    IMPORTING
      output = lv_aufnr.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = gv_matnr_300
    IMPORTING
      output = lv_matnr.

  cuerpo-aufnr = lv_aufnr .

  IF g_matnr_cambio_ancho IS INITIAL.
    cuerpo-matnr  = gv_matnr_300.
  ELSE.
    cuerpo-matnr  = g_matnr_cambio_ancho.
  ENDIF.

  cuerpo-charg = p_new_charg.
  cuerpo-menge = gv_kg.
  cuerpo-tipo = p_tipo.


  CASE p_tipo.
    WHEN ''.
* 04/03/2021 - CMS - Añadir icono Cambio de Ancho
      IF g_matnr_cambio_ancho IS NOT INITIAL.
        cuerpo-tipo_sem = '@UF@'. " Cambio de ancho
      ELSE.
        cuerpo-tipo_sem = '@08@'. ""Green light
      ENDIF.

    WHEN 'R'.
      CONCATENATE lv_matnr p_new_charg INTO lv_object.

      CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
        EXPORTING
          objectkey       = lv_object
          objecttable     = 'MCH1'
          classnum        = 'Z_BOBINA'
          classtype       = '023'
        TABLES
          allocvaluesnum  = lt_alloc_values_num
          allocvalueschar = lt_alloc_values_char
          allocvaluescurr = lt_alloc_values_curr
          return          = lt_return.


      READ TABLE lt_alloc_values_char INTO wa_char WITH KEY charact = 'Z_REPROCESO'.
      IF sy-subrc = 0 AND wa_char-value_char IS NOT INITIAL.
        cuerpo-tipo = 'R'.
        cuerpo-tipo_sem = '@09@'. "Yellow light
      ELSE.
        cuerpo-tipo = ''.
        cuerpo-tipo_sem = '@08@'. "Green light
      ENDIF.

    WHEN 'P'.
      cuerpo-tipo_sem = '@0A@'. "Red light
  ENDCASE.

  cuerpo-diametro = gv_diam.
  cuerpo-empalmes = gv_empa.
  cuerpo-metros =  gv_long.
  cuerpo-bwart = p_bwart.
  cuerpo-mblnr = p_mblnr.
  cuerpo-mjahr =  p_mjahr.
  cuerpo-mblnr_309 =  p_mblnr_309.
  cuerpo-mjahr_309 =  p_mjahr_309.


  READ TABLE gt_header INTO wa_header WITH KEY aufnr = gv_orden_300.
  l_next_key = wa_header-nkey.

* añadimos el nodo
  PERFORM add_leaf USING cuerpo l_next_key wa_header-zzsecuencia
                   CHANGING l_last_key.

  PERFORM clean_vbles.

  CALL METHOD g_alv_tree->expand_node
    EXPORTING
      i_node_key          = wa_header-nkey
*     i_level_count       = 1
*     i_expand_subtree    =
    EXCEPTIONS
      failed              = 1
      illegal_level_count = 2
      cntl_system_error   = 3
      node_not_found      = 4
      cannot_expand_leaf  = 5
      OTHERS              = 6.
  IF sy-subrc <> 0.
*               Implement suitable error handling here
  ENDIF.

* refrescamos
  CALL METHOD g_alv_tree->frontend_update.

ENDFORM.                    " ANYADIR_NODO_ETIQUETA
*&---------------------------------------------------------------------*
*&      Form  SELECCIONAR_MOTIVO_PULPER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_GV_PULPER  text
*----------------------------------------------------------------------*
FORM seleccionar_ancho_real  CHANGING p_ancho TYPE zancho
                                      lv_error
  .

  DATA:lt_fields TYPE TABLE OF sval,
       ls_fields LIKE LINE OF lt_fields.

  CHECK p_ancho IS NOT INITIAL.

  APPEND VALUE sval( tabname = 'MARA' fieldname = 'ZZANCHO' fieldtext = 'Ancho real' value = p_ancho ) TO lt_fields.

  CALL SCREEN 9001 STARTING AT 5 5 ENDING AT 60 10.



ENDFORM.
FORM seleccionar_motivo_pulper  CHANGING p_pulper
                                         lv_error.
  DATA: lv_atinn TYPE atinn.

  TYPES: BEGIN OF tipo_reproceso,
           atwrt TYPE atwrt,
           atwtb TYPE atwtb.
  TYPES: END OF tipo_reproceso.
  TYPES: tty_tipo_reproceso TYPE TABLE OF tipo_reproceso.

  DATA: lt_reproceso       TYPE          tty_tipo_reproceso,
        wa_reproceso       TYPE LINE OF  tty_tipo_reproceso,
        lt_zvpp_carac_repr TYPE TABLE OF zvpp_carac_repr,
        wa_vpp_carac_repr  TYPE          zvpp_carac_repr.

  DATA: lv_choice TYPE sy-tabix,
        l_rc      TYPE c,
        lv_text   TYPE c LENGTH 100.


  SELECT SINGLE atinn FROM cabn
    INTO lv_atinn
    WHERE atnam = 'ZPPI_MOTIVO_RECHAZO'.

  IF lv_atinn IS NOT INITIAL.
    SELECT * FROM zvpp_carac_recha
      INTO TABLE lt_zvpp_carac_repr
      WHERE atinn = lv_atinn.

    IF lt_zvpp_carac_repr[] IS NOT INITIAL.

      LOOP AT lt_zvpp_carac_repr INTO wa_vpp_carac_repr.
        MOVE-CORRESPONDING wa_vpp_carac_repr TO wa_reproceso.
        APPEND wa_reproceso TO lt_reproceso.
      ENDLOOP.



      CALL FUNCTION 'POPUP_WITH_TABLE_DISPLAY'
        EXPORTING
          endpos_col   = 60
          endpos_row   = 20
          startpos_col = 1
          startpos_row = 1
          titletext    = text-027
        IMPORTING
          choise       = lv_choice
        TABLES
          valuetab     = lt_reproceso
        EXCEPTIONS
          break_off    = 1
          OTHERS       = 2.
      IF sy-subrc <> 0.
        lv_error = 'X'.
*       Implement suitable error handling here
      ELSE.
        IF lv_choice IS NOT INITIAL.
          READ TABLE lt_reproceso INTO wa_reproceso INDEX lv_choice.

          lv_text = wa_reproceso-atwtb.

          CALL FUNCTION 'POPUP_TO_CONFIRM_STEP'
            EXPORTING
              defaultoption  = '2'
              textline1      = text-026 "¿Está seguro del motivo indicado?'(902)
              textline2      = lv_text "
              titel          = 'Confirmación'(904)
              cancel_display = ' '
            IMPORTING
              answer         = l_rc
            EXCEPTIONS
              text_not_found = 1
              OTHERS         = 2.
          IF sy-subrc <> 0.
            lv_error = 'X'.
          ELSE.
            IF l_rc EQ 'J'. "Si
              p_pulper = wa_reproceso-atwrt.
            ELSEIF l_rc EQ 'A'. "cancelar el proceso de seleccion
              lv_error = 'X'.
            ELSE.
              p_pulper = ''.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " SELECCIONAR_MOTIVO_PULPER
*&---------------------------------------------------------------------*
*&      Form  ANULAR_ALTA_STOCK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_MBLNR  text
*      -->P_LV_MJAHR  text
*      <--P_LV_ERROR  text
*----------------------------------------------------------------------*
FORM anular_doc  USING    p_mblnr
                          p_mjahr
                          p_menge
                 CHANGING p_error
                          p_kg_producir TYPE erfmg
                          p_kg_consum   TYPE erfmg
                          p_diferencia  TYPE erfmg
                          p_kg_producir_c
                          p_kg_consum_c
                          p_diferencia_c
                          p_diferencia_sem.

  DATA: lt_return TYPE TABLE OF bapiret2,
        ls_return TYPE          bapiret2.

  CALL FUNCTION 'BAPI_GOODSMVT_CANCEL'
    EXPORTING
      materialdocument = p_mblnr
      matdocumentyear  = p_mjahr
    TABLES
      return           = lt_return
*     GOODSMVT_MATDOCITEM       =
    .

  READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
  IF sy-subrc <> 0.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

*   GUARDAR LOGS CON EL PEDIDO DE COMPRAS CREADO
    CLEAR gs_messages.

    gs_messages-type = 'S'.
    gs_messages-number = '124'.
    gs_messages-id = 'ZPP'.
    gs_messages-message_v1 = p_mblnr.
    gs_messages-message_v2 = p_mjahr.

    APPEND gs_messages TO gt_messages.

*   actualizamos las cantidades de la cabecera de la dynpro
    PERFORM actualizar_cabecera_300 USING p_menge
                                          '262'
                                    CHANGING p_kg_producir
                                             p_kg_consum
                                             p_diferencia
                                             p_kg_producir_c
                                             p_kg_consum_c
                                             p_diferencia_c
                                             p_diferencia_sem .

  ELSE.
    p_error = 'X'.

*   REGISTRAR ERROR EN CASO DE NO CREACION DEL PEDIDO DE COMPRAS
    LOOP AT lt_return INTO ls_return WHERE type  = 'E'.
      CLEAR gs_messages.
      gs_messages = ls_return.
      APPEND gs_messages TO gt_messages.
    ENDLOOP.
  ENDIF.

* montar log slg1
  CALL FUNCTION 'ZMONTAR_LOG_SLG1'
    EXPORTING
      i_extnumber = ''
      i_object    = 'ZPP'
      i_subobject = sy-tcode
    TABLES
      t_return    = gt_messages.

ENDFORM.                    " ANULAR_ALTA_STOCK

*&---------------------------------------------------------------------*
*&      Form  ACTUALIZAR_CABECERA_300
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_KG_PRODUCIR  text
*      -->P_P_KG_CONSUM  text
*      -->P_P_DIFERENCIA  text
*      -->P_P_MENGE  text
*      <--P_P_KG_PRODUCIR_C  text
*      <--P_P_KG_CONSUM_C  text
*      <--P_P_DIFERENCIA_C  text
*      <--P_P_DIFERENCIA_SEM  text
*----------------------------------------------------------------------*
FORM actualizar_cabecera_300  USING    p_menge
                                       p_mov
                              CHANGING p_kg_producir
                                       p_kg_consum
                                       p_diferencia
                                       p_kg_producir_c
                                       p_kg_consum_c
                                       p_diferencia_c
                                       p_diferencia_sem.

  DATA: lv_kg_producir TYPE i,
        lv_kg_consum   TYPE i,
        lv_diferencia  TYPE i.

  CASE p_mov.
    WHEN '101'.
      p_kg_producir = p_kg_producir + p_menge.
    WHEN '102'. "CGIJON - 27.02.18 - SAT 7000018982 TICKET 46871
      p_kg_producir = p_kg_producir - p_menge.
    WHEN '261' OR '531'.
      p_kg_consum = p_kg_consum + p_menge.
    WHEN '262' OR '532'.
      p_kg_consum = p_kg_consum - p_menge.
  ENDCASE.

  p_diferencia = p_kg_producir - p_kg_consum.

* pasamos de dec a int
  lv_kg_producir = trunc( p_kg_producir ).
  lv_kg_consum = trunc( p_kg_consum ).
  lv_diferencia = trunc( p_diferencia ).

* pasamos de int a char
  p_kg_producir_c = lv_kg_producir.
  p_kg_consum_c = lv_kg_consum.
  p_diferencia_c = lv_diferencia.


  CONDENSE p_kg_producir_c.
  CONDENSE p_kg_consum_c.
  CONDENSE p_diferencia_c.


* sémaforo diferencias
  IF p_diferencia  > 0 AND p_diferencia < 3000.
    p_diferencia_sem = icon_yellow_light."semáforo en verde
  ELSEIF p_diferencia > 3000.
    p_diferencia_sem = icon_green_light . "semáforo en amarillo
  ELSEIF p_diferencia < 3000.
    p_diferencia_sem = icon_red_light . "semáforo en rojo
  ENDIF.

ENDFORM.                    " ACTUALIZAR_CABECERA_300
*&---------------------------------------------------------------------*
*&      Form  MOSTRAR_LOG1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_MESSAGES  text
*----------------------------------------------------------------------*
FORM mostrar_log1  USING    lt_messages TYPE tty_bapiret2.

  CALL FUNCTION 'C14ALD_BAPIRET2_SHOW'
    TABLES
      i_bapiret2_tab = lt_messages.
ENDFORM.                    " MOSTRAR_LOG1

FORM save_def.

  DATA: ls_ztpp031 TYPE ztpp0031,
        lt_tdline  TYPE STANDARD TABLE OF tdline,
        l_modified TYPE i.

  CALL METHOD go_textedit_bob->get_text_as_r3table
    EXPORTING
      only_when_modified     = 1
    IMPORTING
      table                  = lt_tdline
      is_modified            = l_modified
    EXCEPTIONS
      error_dp               = 1
      error_cntl_call_method = 2
      error_dp_create        = 3
      potential_data_loss    = 4
      OTHERS                 = 5.


*  IF lt_tdline IS NOT INITIAL.
  IF l_modified = '1'.

    DELETE FROM ztpp0031
    WHERE aufnr   = gs_k_dyn500-aufnr AND
          matnr   = gs_k_dyn500-matnr AND
          charg   = gs_k_dyn500-charg AND
          tp_ubic = 'B'.

    CLEAR: ls_ztpp031.

    LOOP AT lt_tdline INTO DATA(ls_tdline).
      CHECK ls_tdline IS NOT INITIAL.
      ADD 1 TO ls_ztpp031-seq.
      ls_ztpp031-aufnr  = |{ gs_k_dyn500-aufnr ALPHA = IN }|.
      ls_ztpp031-matnr  = |{ gs_k_dyn500-matnr ALPHA = IN }|.
      ls_ztpp031-charg  = gs_k_dyn500-charg.
      ls_ztpp031-tp_ubic  = 'B'.
      ls_ztpp031-werks  = gv_werks.
      ls_ztpp031-tdline = ls_tdline.
      INSERT ztpp0031 FROM ls_ztpp031.
    ENDLOOP.
    MESSAGE s419(0k).


  ENDIF.


ENDFORM.

FORM popup_def CHANGING p_answer TYPE c.

  DATA: lv_answer TYPE c.
  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
      titlebar       = text-035 " 'Datos de defectos'
      text_question  = text-034
      text_button_1  = 'Ja'(001)
      text_button_2  = 'Grabar'
      default_button = '2'
    IMPORTING
      answer         = p_answer
    EXCEPTIONS
      text_not_found = 1
      OTHERS         = 2.

ENDFORM.


FORM obtener_datos_bascula.
* 01/03/2021 - CMS - 64594 -
* •	En la lectura de datos de la bobina, en la BD SQL Express se dispondrá de 2 pesos. El peso 1 corresponderá a la báscula antigua,
*   el peso 2 corresponderá a la báscula de FOMAT. De esta forma, no es necesario que AUGI informe la báscula origen del dato.
*
* Se informará uno u otro peso dependiendo del tipo de impresión activo:
* •	Manual: Siempre PESO1
* •	Automático: Si el ancho es < ANCHO_MINIMO asignamos PESO1, sino PESO2

  DATA: l_matnr TYPE matnr.
  CLEAR: g_ancho_bbdd.

  CALL METHOD zcl_utils_hpap_pp=>conectar_bbdd_bobinadora
    EXPORTING
      i_werks    = gv_werks
    IMPORTING
      o_rc       = DATA(l_rc)
      o_peso     = DATA(l_peso1) "gv_kg
      o_peso2    = DATA(l_peso2)
      o_longitud = gv_long
      o_diametro = gv_diam
      o_ancho    = g_ancho_bbdd.


** TEST - BORRAR!!!!!!!!!!!!!!!!!! - Prueba para obtener datos de ANCHO desde el campo ANCHO_MAXIMO
*  SELECT SINGLE ancho_maximo
*    INTO @g_ancho_bbdd
*    FROM ztpp0008
*    WHERE werks = @gv_werks AND
*          arbpl = 'PROVA'.


  CASE gs_ztpp0008-cont.
    WHEN 1. " Impr.Manual , limpiar ancho y peso2(FOMAT), GV_KG ya contine PESO1.
      CLEAR: g_ancho_bbdd , g_ancho_caract , l_peso2.
      gv_kg = l_peso1.

    WHEN 2. " Impr.Automática.

      IF gs_ztpp0008-act_basc = ' '. " Si BÁSCULA está inactivo, ANCHO inactivo.
        gv_kg = l_peso1.
      ELSE.
        gv_kg  = l_peso2.
      ENDIF.

      IF gs_ztpp0008-act_ancho = ' '.
        CLEAR: g_ancho_bbdd , g_ancho_caract.
      ELSE.
        g_ancho_caract = g_ancho_bbdd.
      ENDIF.

      l_matnr = |{ gv_matnr_300 ALPHA = IN }|.

      SELECT SINGLE zzancho
      INTO @DATA(l_ancho)
      FROM mara
      WHERE matnr = @l_matnr.
      IF l_ancho <= gs_ztpp0008-ancho_minimo. " Solo si el ancho es mayor o igual que el mínimo,
*                                             " tomar peso2 para GV_KG y mantener el ancho para la característica
        CLEAR: g_ancho_bbdd, g_ancho_caract.
        gv_kg = l_peso1.

      ENDIF.

*      IF l_ancho > gs_ztpp0008-ancho_minimo. " Solo si el ancho es mayor o igual que el mínimo,
*        gv_kg = l_peso2.
*      ELSE.
*        CLEAR: g_ancho_bbdd, g_ancho_caract.
*      ENDIF.

    WHEN OTHERS.
  ENDCASE.

ENDFORM.

FORM mostrar_planificacion.

*  CALL TRANSACTION 'ZPP0030BOB' AND SKIP FIRST SCREEN.
  DATA: l_tcode TYPE syst_tcode.

  CLEAR l_tcode.
  CASE gv_werks.
    WHEN '3000'. l_tcode = 'ZPP0030V_3000'.
    WHEN '3020'. l_tcode = 'ZPP0030V_3020'.
    WHEN OTHERS.
  ENDCASE.

  CALL FUNCTION 'TH_CREATE_MODE'
    EXPORTING
      transaktion  = l_tcode
      process_dark = 'X'.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.



ENDFORM.


FORM tratar_boton_ancho.

  CASE gs_ztpp0008-act_ancho.
    WHEN ' '.
      UPDATE  ztpp0008   " Desactivamos reg.manual
        SET   act_ancho = 'X'
        WHERE cont  = @gs_ztpp0008-cont AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.
      gs_ztpp0008-act_ancho = 'X'.
    WHEN 'X'.

      UPDATE ztpp0008   " Desactivamos reg.manual
         SET act_ancho = ' '
       WHERE cont  = @gs_ztpp0008-cont AND
             werks = @gv_werks AND
             arbpl = @gv_arbpl.
      gs_ztpp0008-act_ancho = ' '.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.
FORM tratar_boton_bascula.

  CASE gs_ztpp0008-act_basc.
    WHEN ' '.
      UPDATE  ztpp0008   " Desactivamos reg.manual
        SET   act_basc = 'X'
        WHERE cont  = @gs_ztpp0008-cont AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.
      gs_ztpp0008-act_basc = 'X'.
    WHEN 'X'.

      UPDATE ztpp0008   " Desactivamos reg.manual
         SET act_basc  = ' ' ,
             act_ancho = ' '
       WHERE cont  = @gs_ztpp0008-cont AND
             werks = @gv_werks AND
             arbpl = @gv_arbpl.
      gs_ztpp0008-act_basc = ' '.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.

FORM tratar_boton_etiqueta.

  CASE gs_ztpp0008-act_etiq.
    WHEN ' '.
      UPDATE ztpp0008   " Desactivamos reg.manual
  SET act_etiq = 'X'
  WHERE cont  = @gs_ztpp0008-cont AND
        werks = @gv_werks AND
        arbpl = @gv_arbpl.
      gs_ztpp0008-act_etiq = 'X'.
    WHEN 'X'.

      UPDATE ztpp0008   " Desactivamos reg.manual
  SET act_etiq = ' '
  WHERE cont  = @gs_ztpp0008-cont AND
        werks = @gv_werks AND
        arbpl = @gv_arbpl.
      gs_ztpp0008-act_etiq = ' '.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.

FORM tratar_boton_tp_extraccion.
  CASE gs_ztpp0008-cont.
    WHEN 1. " si es manual, cambiamos a automático

* Desactivo reg 1 (manual)
      UPDATE ztpp0008   " Desactivamos reg.manual
        SET activo = ' '
        WHERE cont = 1 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

* Activo reg 2 (automático) y seleccionar datos
      UPDATE ztpp0008   " Activamos reg.Automático
        SET activo = 'X'
        WHERE cont = 2 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

      SELECT SINGLE *
        INTO @gs_ztpp0008
        FROM ztpp0008
        WHERE cont = 2 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

    WHEN 2.

* Desactivo reg 2 (manual)
      UPDATE ztpp0008   " Desactivamos reg.manual
        SET activo = ' '
        WHERE cont = 2 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

* Activo reg 1 (automático) y seleccionar datos
      UPDATE ztpp0008   " Activamos reg.Automático
        SET activo = 'X'
        WHERE cont = 1 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

      SELECT SINGLE *
        INTO @gs_ztpp0008
        FROM ztpp0008
        WHERE cont = 1 AND
              werks = @gv_werks AND
              arbpl = @gv_arbpl.

    WHEN OTHERS.
  ENDCASE.
ENDFORM.
FORM mostrar_aviso_solo_pulper.

  CALL FUNCTION 'ZPP_PANTALLA_AVISO'
    EXPORTING
      titulo   = 'Error'
      tp_icono = 'E'
      text1    = 'ATENCIÓN ROLLO PULPER'
      text2    = 'Únicamente se permite bobinar como pulper.'.

ENDFORM.

FORM call_zpp0004.

  DATA: lr_budat TYPE RANGE OF budat.

  CLEAR lr_budat[].
  lr_budat = VALUE #( ( sign = 'I'  option = 'EQ'  low = sy-datum )  ).

* Según el turno, informamos el parámetro correspondiente.
  CASE gv_turno.
    WHEN 'T1'.
      SUBMIT zrpp0014_bis
        WITH pwerks EQ gv_werks
        WITH sbudat  IN lr_budat
        WITH ptodos  EQ 'X'
        WITH p_t1    EQ 'X'
        WITH p_t2    EQ ' '
        WITH p_t3    EQ ' '
        WITH pvari   EQ '/02 PROD NET'
        AND RETURN.
    WHEN 'T2'.
      SUBMIT zrpp0014_bis
        WITH pwerks EQ gv_werks
        WITH sbudat  IN lr_budat
        WITH ptodos  EQ 'X'
        WITH p_t1    EQ ' '
        WITH p_t2    EQ 'X'
        WITH p_t3    EQ ' '
        WITH pvari   EQ '/02 PROD NET'
        AND RETURN.
    WHEN 'T3'.
      SUBMIT zrpp0014_bis
        WITH pwerks EQ gv_werks
        WITH sbudat  IN lr_budat
        WITH ptodos  EQ 'X'
        WITH p_t1    EQ ' '
        WITH p_t2    EQ ' '
        WITH p_t3    EQ 'X'
        WITH pvari   EQ '/02 PROD NET'
        AND RETURN.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.


FORM reimprimir_etiq_obs_lab  USING ps_cuerpo TYPE zepp0027_cuerpo
                                    p_reproc  TYPE flag.

  DATA: "lf_formname     TYPE fpname VALUE 'ZESPPF_ETIQ_BOBINA_OBSERV_LAB',
    ls_etiq_bob_obs TYPE zstpp_etiq_bobina_observ_lab,
    l_rc            TYPE char2,
    l_aufnr         TYPE aufnr,
    l_matnr         TYPE matnr,
    l_charg         TYPE charg_d,
    l_string        TYPE char300,
    lv_desc_motivo  TYPE string,
    lv_pos_def      TYPE string.

  DATA: lv_zdist_s TYPE c LENGTH 3,
        lv_zdist_e TYPE c LENGTH 3,
        lv_zdist_d TYPE c LENGTH 3.

* Para evitar CLEAN_VBLES. :(
  IF gv_matnr_300 IS NOT INITIAL.
    g_matnr_etiq = gv_matnr_300.
  ENDIF.
  IF gv_kunnr_300 IS NOT INITIAL.
    g_kunnr_etiq = gv_kunnr_300.
  ENDIF.

  IF zcl_utils_hpap_pp=>es_cabo( i_matnr = g_matnr_etiq
                                 i_kunnr = g_kunnr_etiq ) = 'X'.
*    IF gw_btn_etiq = ' '. " cuando estemos en el boton etiqueta no mostrar msg error.
*      MESSAGE e334(zpp). "No se permite imprimir etiqueta de muestra para cabo.
*    ENDIF.
    EXIT.
  ENDIF.

  CLEAR ls_etiq_bob_obs.
  ls_etiq_bob_obs-lote_rollo     = gv_cb.
  ls_etiq_bob_obs-lote_bobina    = ps_cuerpo-charg.

* Recuperamos información ztpp0076 para obtener motivo defecto, posición defecto y observaciones.
  l_aufnr = |{ gv_aufnr_bob  ALPHA = IN }|.
  l_matnr = |{ gv_matnr_bob  ALPHA = IN }|.
  l_charg = |{ gv_lote_bob   ALPHA = IN }|.

  SELECT *
  FROM ztpp0076
  INTO TABLE @DATA(lt_ztpp0076)
  WHERE aufnr   = @l_aufnr AND
        matnr   = @l_matnr AND
        charg   = @l_charg.

  IF sy-subrc = 0.

    LOOP AT lt_ztpp0076 INTO DATA(ls_ztpp0076).

      SELECT atwrt
    FROM zvpp_carac_repr
    INTO lv_desc_motivo
    WHERE atzhl = ls_ztpp0076-motivo_rep.
      ENDSELECT.
*Rellenamos motivo de reproceso
      ls_etiq_bob_obs-bobina_a_repr = lv_desc_motivo.

*Rellenamos lineas de observaciones
      IF ls_ztpp0076 IS NOT INITIAL.
        l_string = |{ l_string }{ ls_ztpp0076-zobs_bobina }|.
      ENDIF.
    ENDLOOP.
    TRY.
        DATA(l_str1) = l_string(45).
        IF l_str1 IS NOT INITIAL.
          ls_etiq_bob_obs-observaciones1 = l_str1.
        ENDIF.
        DATA(l_str2) = l_string+45(45).
        IF l_str2 IS NOT INITIAL.
          ls_etiq_bob_obs-observaciones2 = l_str2.
        ENDIF.
        DATA(l_str3) = l_string+90(45).
        IF l_str3 IS NOT INITIAL.
          ls_etiq_bob_obs-observaciones3 = l_str3.
        ENDIF.
        DATA(l_str4) = l_string+135(45).
        IF l_str4 IS NOT INITIAL.
          ls_etiq_bob_obs-observaciones4 = l_str4.
        ENDIF.
        DATA(l_str5) = l_string+180(45).
        IF l_str5 IS NOT INITIAL.
          ls_etiq_bob_obs-observaciones5 = l_str5.
        ENDIF.
      CATCH cx_root .
    ENDTRY.

* Montar literal de posición de defecto
    CASE p_reproc.
      WHEN ' '.
        ls_etiq_bob_obs-pos_def = ' '.
      WHEN 'X'. "Bobina de reproceso

        CLEAR: lv_zdist_s, lv_zdist_e, lv_zdist_d.

        lv_zdist_s = ls_ztpp0076-zdist_s+4(3).
        lv_zdist_e = ls_ztpp0076-zdist_e+4(3).
        lv_zdist_d = ls_ztpp0076-zdist_d+4(3).

        IF ls_ztpp0076-zpos_a = 'X'.
          ls_etiq_bob_obs-pos_def = 'A'.

        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'S' lv_zdist_s INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = ' '.
          lv_pos_def = 'C'.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'E' lv_zdist_e INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.


        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'S' lv_zdist_s '| C' INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'S' lv_zdist_s '| E' lv_zdist_e INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'S' lv_zdist_s '| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'C| E' lv_zdist_e INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'C| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'E' lv_zdist_e '| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.


        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = ' '.
          CONCATENATE 'S' lv_zdist_s '| C | E' lv_zdist_e INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = ' ' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'S' lv_zdist_s '| C | D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = ' ' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'S' lv_zdist_s '| E' lv_zdist_e '| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ELSEIF ls_ztpp0076-zpos_s = ' ' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'C | E' lv_zdist_e '| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.


        ELSEIF ls_ztpp0076-zpos_s = 'X' AND ls_ztpp0076-zpos_c = 'X' AND ls_ztpp0076-zpos_e = 'X' AND ls_ztpp0076-zpos_d = 'X'.
          CONCATENATE 'S' lv_zdist_s '| C | E' lv_zdist_e '| D' lv_zdist_d INTO lv_pos_def SEPARATED BY ' '.
          ls_etiq_bob_obs-pos_def = lv_pos_def.

        ENDIF.

      WHEN OTHERS.
    ENDCASE.

  ENDIF.

  CALL FUNCTION 'ZMFPP_ETIQ_BOBINA_OBSERV_LAB'
    EXPORTING
      i_werks          = gv_werks
      i_datos_etiqueta = ls_etiq_bob_obs
*     I_REIMP_PESO     =
      i_nodialog       = 'X'
    IMPORTING
*     O_PRINTPARMS     =
      o_rc             = l_rc.

ENDFORM.

FORM popup_obs_bobina  USING ps_cuerpo TYPE zepp0027_cuerpo.
  DATA: lt_lines    TYPE STANDARD TABLE OF tdline,
        lt_ztpp0031 TYPE STANDARD TABLE OF ztpp0031,
        l_aufnr     TYPE aufnr,
        l_matnr     TYPE matnr,
        l_charg     TYPE charg_d.

  l_aufnr = |{ gv_aunfr_mostrar ALPHA = IN }|.
  l_matnr = |{ gv_matnr_mostrar ALPHA = IN }|.
  l_charg = |{ gv_cb ALPHA = IN }|.

  CLEAR lt_lines.
  SELECT tdline
    FROM ztpp0031
    INTO TABLE @DATA(lt_tdlines)
    WHERE aufnr   = @l_aufnr AND
          matnr   = @l_matnr AND
          charg   = @l_charg AND
          tp_ubic = 'B'                AND
          werks   = @gv_werks.
  IF sy-subrc = 0 AND lt_tdlines IS NOT INITIAL.
    LOOP AT lt_tdlines INTO DATA(ls).
      APPEND INITIAL LINE TO lt_lines ASSIGNING FIELD-SYMBOL(<fs_line>).
      <fs_line> = ls.
    ENDLOOP.
    CLEAR lt_tdlines[].
  ENDIF.

  CALL FUNCTION 'TERM_CONTROL_EDIT'
    EXPORTING
      titel          = ' Observaciones bobinadora'
      langu          = sy-langu
    TABLES
      textlines      = lt_lines
    EXCEPTIONS
      user_cancelled = 1
      OTHERS         = 2.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ELSE.
    DATA(l_cont) = 0.
    LOOP AT lt_lines INTO DATA(ls_line).
      l_cont = l_cont + 1.
      CHECK ls_line IS NOT INITIAL.
      APPEND INITIAL LINE TO lt_ztpp0031 ASSIGNING FIELD-SYMBOL(<fs>).
      <fs>-aufnr    = |{ gv_aunfr_mostrar ALPHA = IN }|. " Orden Rollo
      <fs>-charg    = |{ gv_cb ALPHA = IN }|.            " Lote Rollo
      <fs>-matnr    = |{ gv_matnr_mostrar ALPHA = IN }|.
      <fs>-seq      = l_cont.
      <fs>-tdline   = ls_line.
      <fs>-tp_ubic  = 'B'.
      <fs>-werks    = gv_werks .

    ENDLOOP.
    IF lt_lines IS NOT INITIAL.
      DELETE FROM ztpp0031
      WHERE aufnr = @l_aufnr AND
          matnr   = @l_matnr AND
          charg   = @l_charg AND
          tp_ubic = 'B'                AND
          werks   = @gv_werks.

      INSERT ztpp0031 FROM TABLE lt_ztpp0031.
    ENDIF.
  ENDIF.
ENDFORM.

FORM check_bloqueos_rollo  CHANGING p_rc TYPE syst_subrc
                                      p_user TYPE char12.

  CLEAR: p_user , p_rc .

  DATA: t_enq TYPE TABLE OF seqg3.
  CALL FUNCTION 'ENQUE_READ'
    EXPORTING
*     GCLIENT       = SY-MANDT
*     GNAME  = ' '
*     GARG   = ' '
      guname = ' ' "SY-UNAME
*   IMPORTING
*     NUMBER =
*     SUBRC  =
    TABLES
      enq    = t_enq.
  LOOP AT t_enq INTO DATA(ls_enq) WHERE gname = 'MCH1'.
    IF ls_enq-garg CS gv_lote.
      p_user = ls_enq-guname.
      MESSAGE e353(zpp)  DISPLAY LIKE 'I' WITH gv_lote p_user. "Atención! Lote & bloqueado. Notificar más tarde.
      p_rc = 1.
      EXIT.
    ENDIF.
  ENDLOOP.

  LOOP AT t_enq INTO ls_enq WHERE gname = 'MARA'.
    IF ls_enq-garg CS gv_matnr_mostrar.
      p_user = ls_enq-guname.
      MESSAGE e359(zpp) DISPLAY LIKE 'I' WITH gv_matnr_mostrar p_user. "Atención! Material rollo & bloqueado por usuario &. Notificar más tarde.
      p_rc = 1.
      EXIT.
    ENDIF.
  ENDLOOP.


ENDFORM.


FORM check_bloqueo_of USING p_aufnr TYPE aufnr
              CHANGING p_rc TYPE char2.

  p_aufnr = |{ p_aufnr ALPHA = IN }|.

  CALL FUNCTION 'ENQUEUE_ESORDER'
    EXPORTING
      mode_aufk      = 'E'
      mandt          = sy-mandt
      aufnr          = p_aufnr
*     X_AUFNR        = ' '
*     _SCOPE         = '2'
*     _WAIT          = ' '
*     _COLLECT       = ' '
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.
  IF sy-subrc = 0.
    CALL FUNCTION 'DEQUEUE_ESORDER'
      EXPORTING
        mode_aufk = 'E'
        mandt     = sy-mandt
        aufnr     = p_aufnr.
    p_rc = '00'.
  ELSE.
    MESSAGE |Orden de bobina bloqueada, notificar mas tarde.| TYPE 'I' DISPLAY LIKE 'E'.
    p_rc = '01'.
    PERFORM clean_vbles.

  ENDIF.


ENDFORM.
