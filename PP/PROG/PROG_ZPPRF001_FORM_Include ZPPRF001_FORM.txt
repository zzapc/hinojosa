*&---------------------------------------------------------------------*
*&  Include           ZPPRF001_FORM
*&---------------------------------------------------------------------*


FORM traspasar

               USING p_matnr
                     p_charg
                     p_werks
                     p_lgort_origen
                     p_lgort_destino
                     p_quantity
               CHANGING p_error
              .

  DATA: ls_header TYPE bapi2017_gm_head_01,
        ##NEEDED
        l_mblnr   TYPE bapi2017_gm_head_ret-mat_doc,
        lt_item   LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item   TYPE bapi2017_gm_item_create,
        lt_return TYPE TABLE OF bapiret2.



  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.




  SELECT SINGLE meins FROM mara INTO @DATA(l_meins)
                                WHERE matnr EQ @p_matnr AND
                                      lvorm EQ @space.


  ls_item-material    = p_matnr.
  ls_item-batch       = p_charg.
  ls_item-plant       = p_werks.
  ls_item-stge_loc    = p_lgort_origen.
  ls_item-move_type   = '311'.
  ls_item-entry_qnt   = p_quantity.
  ls_item-entry_uom   = l_meins.
  ls_item-move_stloc  = p_lgort_destino.
  APPEND ls_item TO lt_item.

  CALL FUNCTION 'BUFFER_REFRESH_ALL'.

  SET UPDATE TASK LOCAL.


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = CONV bapi2017_gm_code( '04' )
    IMPORTING
      materialdocument = l_mblnr
    TABLES
      goodsmvt_item    = lt_item
      return           = lt_return.


  IF line_exists( lt_return[ type = 'E' ] ).
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
    p_error = abap_true.
    MESSAGE lt_return[ 1 ]-message TYPE 'S' DISPLAY LIKE 'E'. .
  ELSE.
    p_error = abap_false.
    COMMIT WORK AND WAIT.
  ENDIF.





ENDFORM.
FORM limpiar_campos .

  CLEAR: g_matnr,
         g_maktx,
         g_barcode,
         g_peso,
         g_peso_text ,
         g_peso_acumulado,
         g_peso_acumulado_txt,
         g_maktx,
         g_lgort_origen,
         g_lgort_dstino ,
         g_lgobe ,
         g_calidad,
         g_gramaje_ancho,
         g_charg,
*         g_lgort,
         g_decision_empleo,
         g_kunnr
         .

ENDFORM.

FORM limpiar_campos_no_acum.


*CLEAR:g_barcode, g_mostrar_botones.",g_charg,g_peso,g_kunnr,g_gramaje_ancho,g_decision_empleo.

  CLEAR: g_matnr,
         g_maktx,
         g_barcode,
         g_peso,
         g_peso_text ,
*         g_peso_acumulado,
*         g_peso_acumulado_txt,
         g_maktx,
         g_lgort_origen,
         g_lgort_dstino ,
         g_lgobe ,
         g_calidad,
         g_gramaje_ancho,
         g_charg,
*         g_lgort,
         g_decision_empleo,
         g_kunnr
         .

ENDFORM.


*&---------------------------------------------------------------------*
*&      Form  REUBICAR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM reubicar .


  DATA: ls_header TYPE bapi2017_gm_head_01,
        l_mblnr   LIKE bapi2017_gm_head_ret-mat_doc,
        lt_item   TYPE TABLE OF  bapi2017_gm_item_create,
        ls_item   TYPE bapi2017_gm_item_create,
        lt_return TYPE bapiret2_t,
        ls_return TYPE bapiret2.


  IF g_lgort_dstino IS INITIAL.
    MESSAGE 'Seleccionar almacén de destino' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.
  ls_header-header_txt = 'ZPPRF'.

  ls_item-material     = |{ g_matnr ALPHA = IN }|.
  ls_item-batch        = g_charg.
  ls_item-plant        = g_werks.
  ls_item-stge_loc     = g_lgort_origen.
  ls_item-move_type    = '311'.


  ls_item-entry_qnt    = g_peso.
  ls_item-move_plant   = g_werks.
  ls_item-move_stloc   = g_lgort_dstino.

  SELECT SINGLE meins INTO ls_item-entry_uom FROM mara WHERE matnr = g_matnr .

  APPEND ls_item TO lt_item.


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = '04'
    IMPORTING
      materialdocument = l_mblnr
    TABLES
      goodsmvt_item    = lt_item
      return           = lt_return.

  IF line_exists( lt_return[ type = 'E' ] ).

    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

    DATA(l_msg) = lt_return[ type = 'E' ]-message.

    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.

  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = abap_true.

    MESSAGE 'Reubicación correcta' TYPE 'S'.



  ENDIF.

ENDFORM.        " TRASPASA
*&---------------------------------------------------------------------*
*&      Form  REALIZAR_TRASPASO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM realizar_traspaso .


  DATA: ls_header    TYPE bapi2017_gm_head_01,
        ##NEEDED
        l_mblnr      TYPE bapi2017_gm_head_ret-mat_doc,
        l_mjahr      TYPE gjahr,
        lt_item      LIKE bapi2017_gm_item_create OCCURS 0,
        ls_item      TYPE bapi2017_gm_item_create,
        lt_return    TYPE TABLE OF bapiret2,
        lv_objectkey TYPE cuobn.




  LOOP AT lt_bobinas INTO ls_bobinas.

    ls_item-material    = |{ ls_bobinas-matnr ALPHA = IN }|.
    ls_item-batch       = ls_bobinas-charg.
    ls_item-plant       = g_werks.
    ls_item-stge_loc    = ls_bobinas-lgort.
    ls_item-move_type   = '311'.
    ls_item-entry_qnt   = ls_bobinas-peso_real.

    SELECT SINGLE meins FROM mara INTO @DATA(l_meins)
                                  WHERE matnr EQ @ls_bobinas-matnr AND
                                        lvorm EQ @space.

    ls_item-entry_uom   = l_meins.
    IF g_lgort_dstino IS NOT INITIAL.
      ls_item-move_stloc  = g_lgort_dstino.
    ELSE.
      ls_item-move_stloc  = g_lgort.
    ENDIF.
*    ls_item-move_stloc  = g_lgort_dstino.
    APPEND ls_item TO lt_item.
  ENDLOOP.


  ls_header-pstng_date = sy-datum.
  ls_header-doc_date   = sy-datum.
  ls_header-header_txt = 'ZPPRF'.


  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
    EXPORTING
      goodsmvt_header  = ls_header
      goodsmvt_code    = CONV bapi2017_gm_code( '04' )
    IMPORTING
      materialdocument = l_mblnr
      matdocumentyear  = l_mjahr
    TABLES
      goodsmvt_item    = lt_item
      return           = lt_return.


  IF line_exists( lt_return[ type = 'E' ] ).
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
    DATA(l_message) = lt_return[ type = 'E' ]-message.
    MESSAGE l_message TYPE 'S' DISPLAY LIKE 'E'.
  ELSE.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

"EAB T76941 28.06.2023 Integración E80: se llama a la función de envio de datos de bobina a E80 para todas las bobinas traspasadas a almacen destino 1040 o 4005
    IF g_lgort_dstino = '1040' OR g_lgort_dstino = '4005'.

      LOOP AT lt_item INTO ls_item.

        CONCATENATE ls_item-material ls_item-batch INTO lv_objectkey.

        CALL FUNCTION 'Z_E80_ENVIO_STOCK_BOBINA'
          EXPORTING
            i_werks          = g_werks
*           I_CHARG          =
            i_objek          = lv_objectkey
            i_par_origen     = '2'
          EXCEPTIONS
            lote_inexistente = 1
            OTHERS           = 2.
        IF sy-subrc <> 0.
* Implement suitable error handling here
        ENDIF.
      ENDLOOP.
    ENDIF.

    MESSAGE 'Traspaso realizado' TYPE 'S'.


    CLEAR:g_barcode, g_matnr,g_charg,g_peso_text,g_calidad,g_decision_empleo,g_gramaje_ancho,
          g_kunnr.

    IF g_dynpro EQ '0320'.

      DATA ls_ztpp0027 TYPE ztpp0027.

      LOOP AT lt_bobinas INTO ls_bobinas.
        ADD ls_bobinas-peso_real TO  ls_ztpp0027-allowed_twgt .
      ENDLOOP.


      ls_ztpp0027-creation_date = sy-datum.
      ls_ztpp0027-creation_time = sy-uzeit.
      ls_ztpp0027-mblnr         = l_mblnr.
      ls_ztpp0027-mjahr         = l_mjahr.
      ls_ztpp0027-werks         = g_werks.
      ls_ztpp0027-meins         = 'KG'.
      IF g_lgort_dstino IS NOT INITIAL. " cuando la variable g_lgort_dstino esta a blanco, tomamos g_lgort
        ls_ztpp0027-lgort         = g_lgort_dstino.
      ELSE.
        ls_ztpp0027-lgort         = g_lgort.
      ENDIF.

      MODIFY ztpp0027 FROM ls_ztpp0027.

    ENDIF.

  ENDIF.

  REFRESH lt_bobinas.
  o_app->borrar_lista_bobinas( ).
  CLEAR g_peso_acumulado.
  g_peso_acumulado_txt = |{ g_peso_acumulado DECIMALS = 0 } KG|.


ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CONVERSION_A_NSP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
*FORM conversion_a_nsp .
*
*  DATA: l_obj_key TYPE ausp-objek.
*
*  DATA: lt_valuesnum  TYPE TABLE OF bapi1003_alloc_values_num,
*        lt_valueschar TYPE TABLE OF bapi1003_alloc_values_char,
*        ls_valueschar LIKE LINE OF lt_valueschar,
*        lt_valuescurr TYPE TABLE OF bapi1003_alloc_values_curr.
*
*  DATA: ls_header TYPE bapi2017_gm_head_01,
*        ##NEEDED
*        l_mblnr   TYPE bapi2017_gm_head_ret-mat_doc,
*        l_mjahr   TYPE gjahr,
*        lt_item   LIKE bapi2017_gm_item_create OCCURS 0,
*        ls_item   TYPE bapi2017_gm_item_create,
*        lt_return TYPE TABLE OF bapiret2.
*
*  LOOP AT lt_bobinas INTO ls_bobinas.
*
*    ls_item-material    = |{ ls_bobinas-matnr ALPHA = IN }|.
*    ls_item-batch       = ls_bobinas-charg.
*    ls_item-plant       = ls_bobinas-werks.
*    ls_item-stge_loc    = '1000'.
*    ls_item-move_type   = '309'.
*    ls_item-entry_qnt   = ls_bobinas-peso_real.
*
*    SELECT SINGLE meins FROM mara INTO @DATA(l_meins)
*                                  WHERE matnr EQ @ls_bobinas-matnr AND
*                                        lvorm EQ @space.
*
*    ls_item-entry_uom   = l_meins.
*    ls_item-move_stloc  = '1040'.
*    ls_item-move_batch  = ls_bobinas-charg.
*    ls_item-move_mat    = |{ g_matnr_non_standard_paper ALPHA = IN }|.
*    APPEND ls_item TO lt_item.
*
*  ENDLOOP.
*
*
*  ls_header-pstng_date = sy-datum.
*  ls_header-doc_date   = sy-datum.
*  ls_header-header_txt = 'ZPPRF'.
*
*
*  CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
*    EXPORTING
*      goodsmvt_header  = ls_header
*      goodsmvt_code    = CONV bapi2017_gm_code( '04' )
*    IMPORTING
*      materialdocument = l_mblnr
*      matdocumentyear  = l_mjahr
*    TABLES
*      goodsmvt_item    = lt_item
*      return           = lt_return.
*
*
*  IF line_exists( lt_return[ type = 'E' ] ).
*    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
*    DATA(l_message) = lt_return[ type = 'E' ]-message.
*    MESSAGE l_message TYPE 'S' DISPLAY LIKE 'E'.
*  ELSE.
*
*    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*      EXPORTING
*        wait = 'X'.
*
*    MESSAGE 'Traspaso realizado' TYPE 'S'.
*
*
*
*    LOOP AT lt_bobinas INTO ls_bobinas.
*
*      l_obj_key = |{ g_matnr_non_standard_paper ALPHA = IN }{ ls_bobinas-charg }|.
*
**
*      CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
*        EXPORTING
*          objectkey       = l_obj_key
*          objecttable     = 'MCH1'
*          classnum        = 'Z_BOBINA'
*          classtype       = '023'
*        TABLES
*          allocvaluesnum  = lt_valuesnum
*          allocvalueschar = lt_valueschar
*          allocvaluescurr = lt_valuescurr
*          return          = lt_return.
*
*
*
*      READ TABLE lt_valueschar ASSIGNING FIELD-SYMBOL(<fs>) WITH KEY charact = 'LOBM_UDCODE'.
*      IF sy-subrc NE 0.
*        ls_valueschar-charact = 'LOBM_UDCODE'.
*        ls_valueschar-value_char = ls_valueschar-value_neutral = 'DE       R'.
*        APPEND ls_valueschar TO lt_valueschar.
*      ELSE.
*        <fs>-value_char = <fs>-value_neutral = 'DE       R'.
*      ENDIF.
*
*      CALL FUNCTION 'BAPI_OBJCL_CHANGE'
*        EXPORTING
*          objectkey          = l_obj_key
*          objecttable        = 'MCH1'
*          classnum           = 'Z_BOBINA'
*          classtype          = '023'
*        TABLES
*          allocvaluesnumnew  = lt_valuesnum
*          allocvaluescharnew = lt_valueschar
*          allocvaluescurrnew = lt_valuescurr
*          return             = lt_return.
*
*      IF NOT line_exists( lt_return[ type = 'E'] ).
*        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*          EXPORTING
*            wait = 'X'.
*
*
*      ENDIF.
*
*    ENDLOOP.
*
*    REFRESH lt_bobinas.
*
*  ENDIF.
*
*ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CAMBIO_MASIVO_CLIENTE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
*FORM cambio_masivo_cliente .
*
*  DATA: l_obj_key TYPE ausp-objek.
*
*  DATA: lt_valuesnum  TYPE TABLE OF bapi1003_alloc_values_num,
*        lt_valueschar TYPE TABLE OF bapi1003_alloc_values_char,
*        ls_valueschar LIKE LINE OF lt_valueschar,
*        lt_valuescurr TYPE TABLE OF bapi1003_alloc_values_curr,
*        lt_return     TYPE TABLE OF bapiret2.
*
*  DATA l_error TYPE abap_bool.
*
*  LOOP AT lt_bobinas INTO ls_bobinas.
*
*    l_obj_key = |{ ls_bobinas-matnr ALPHA = IN }{ ls_bobinas-charg }|.
*
**
*    CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
*      EXPORTING
*        objectkey       = l_obj_key
*        objecttable     = 'MCH1'
*        classnum        = 'Z_BOBINA'
*        classtype       = '023'
*      TABLES
*        allocvaluesnum  = lt_valuesnum
*        allocvalueschar = lt_valueschar
*        allocvaluescurr = lt_valuescurr
*        return          = lt_return.
*
*
*
*    READ TABLE lt_valueschar ASSIGNING FIELD-SYMBOL(<fs>) WITH KEY charact = 'Z_CLIENTE'.
*    IF sy-subrc NE 0.
*      ls_valueschar-charact = 'Z_CLIENTE'.
*      ls_valueschar-value_char = ls_valueschar-value_neutral = g_new_kunnr.
*      APPEND ls_valueschar TO lt_valueschar.
*    ELSE.
*      <fs>-value_char = <fs>-value_neutral = g_new_kunnr.
*    ENDIF.
*
*    CALL FUNCTION 'BAPI_OBJCL_CHANGE'
*      EXPORTING
*        objectkey          = l_obj_key
*        objecttable        = 'MCH1'
*        classnum           = 'Z_BOBINA'
*        classtype          = '023'
*      TABLES
*        allocvaluesnumnew  = lt_valuesnum
*        allocvaluescharnew = lt_valueschar
*        allocvaluescurrnew = lt_valuescurr
*        return             = lt_return.
*
*    IF  line_exists( lt_return[ type = 'E'] ).
*      l_error = abap_true.
*
*    ENDIF.
*
*
*  ENDLOOP.
*  IF l_error EQ abap_false.
*    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
*      EXPORTING
*        wait = 'X'.
*    MESSAGE 'Cambio de cliente realizado' TYPE 'S'.
*    REFRESH lt_bobinas.
*  ENDIF.
*ENDFORM.


*&---------------------------------------------------------------------*
*&      Form  UBICAR_BOBINA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
*FORM ubicar_bobina .
*
*  DATA l_msg type text72.
*
*  o_app->cambiar_ubicacion( EXPORTING  nueva_ubicacion  = g_nueva_ubicacion
*                            EXCEPTIONS lote_incorrecto  = 1
*                                       error_actualizar = 2
*                                       OTHERS           = 3 ).
*  CASE sy-subrc .
*    WHEN 0.
*      MESSAGE 'Bobina ubicada'(610) TYPE 'S'.
*      LEAVE TO SCREEN 600.
*    WHEN 1.
*      l_msg = 'Error: lote & incorrecto'(010).
*      REPLACE '&' in l_msg WITH o_app->charg.
*      MESSAGE l_msg type 'S' DISPLAY LIKE 'E'.
*    WHEN 2.
*
*      MESSAGE text-011 type 'S' DISPLAY LIKE 'E'.
*  ENDCASE.
*

*  DATA l_ubicacion TYPE zzona_ubicacion.
*
*  DATA l_msg TYPE text72.
*
*  DATA: l_obj_key TYPE ausp-objek.
*
*  DATA: lt_valuesnum  TYPE TABLE OF bapi1003_alloc_values_num,
*        lt_valueschar TYPE TABLE OF bapi1003_alloc_values_char,
*        ls_valueschar LIKE LINE OF lt_valueschar,
*        lt_valuescurr TYPE TABLE OF bapi1003_alloc_values_curr,
*        lt_return     TYPE bapiret2_t.
*
*  DATA: ls_header TYPE bapi2017_gm_head_01,
*        ##NEEDED
*        l_mblnr   TYPE bapi2017_gm_head_ret-mat_doc,
*        l_mjahr   TYPE gjahr,
*        lt_item   LIKE bapi2017_gm_item_create OCCURS 0,
*        ls_item   TYPE bapi2017_gm_item_create.
*
**  Validar que la ubicacion introducida exista
*
*  SELECT SINGLE zona_ubicacion INTO l_ubicacion FROM ztpp0023
*                               WHERE werks EQ g_werks AND
*                                     zona_ubicacion EQ g_nueva_ubicacion AND
*                                     lgort EQ g_lgort AND
*                                     tipo_ubicacion EQ space.
*  IF sy-subrc NE 0.
*    MESSAGE 'Error:Ubicacion inexistente. F3 Cancelar' TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  SELECT SINGLE zona_ubicacion INTO l_ubicacion FROM ztpp0023
*                             WHERE werks EQ g_werks AND
*                                   zona_ubicacion EQ g_nueva_ubicacion AND
*                                   lgort NE g_lgort AND
*                                   tipo_ubicacion EQ space.
*  IF sy-subrc EQ 0.
*    MESSAGE 'Almacén/Ubicación destino incorrecta' TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  l_obj_key = |{ g_matnr ALPHA = IN }{ g_charg }|.
*
*  REFRESH: lt_valueschar,lt_valuescurr,lt_valuesnum.
*
*  CALL FUNCTION 'BAPI_OBJCL_GETDETAIL'
*    EXPORTING
*      objectkey       = l_obj_key
*      objecttable     = 'MCH1'
*      classnum        = 'Z_BOBINA'
*      classtype       = '023'
*    TABLES
*      allocvaluesnum  = lt_valuesnum
*      allocvalueschar = lt_valueschar
*      allocvaluescurr = lt_valuescurr
*      return          = lt_return.
*
*  IF line_exists( lt_return[ type = 'E'] ).
*    l_msg = 'Error:lote & incorrecto'.
*    REPLACE '&' IN l_msg WITH g_charg.
*    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*
*  READ TABLE lt_valueschar ASSIGNING FIELD-SYMBOL(<fs>) WITH KEY charact = 'Z_UBIC_HPAP'.
*  IF sy-subrc EQ 0.
*    <fs>-value_char = <fs>-value_neutral = g_nueva_ubicacion.
*  ELSE.
*    ls_valueschar-charact    = 'Z_UBIC_HPAP'.
*    ls_valueschar-value_char = ls_valueschar-value_neutral = g_nueva_ubicacion.
*    APPEND ls_valueschar TO lt_valueschar.
*  ENDIF.
*
*  CALL FUNCTION 'BAPI_OBJCL_CHANGE'
*    EXPORTING
*      objectkey          = l_obj_key
*      objecttable        = 'MCH1'
*      classnum           = 'Z_BOBINA'
*      classtype          = '023'
*    TABLES
*      allocvaluesnumnew  = lt_valuesnum
*      allocvaluescharnew = lt_valueschar
*      allocvaluescurrnew = lt_valuescurr
*      return             = lt_return.
*  IF line_exists( lt_return[ type = 'E'] ).
*    l_msg = 'Error al actualizar ubicacion'.
*    REPLACE '&' IN l_msg WITH g_charg.
*    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
*    RETURN.
*  ENDIF.
*

*ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  CREAR_OBJETO_APP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM crear_objeto_app .
  IF o_app IS NOT BOUND.
    o_app = NEW zcl_app( ).
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  EXPORTAR_CAMPOS_APP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM exportar_campos_app .

  PERFORM limpiar_campos.

  g_matnr              = |{ o_app->matnr ALPHA = OUT }|.
  g_calidad            = o_app->calidad.
  g_gramaje_ancho      = o_app->gramaje_ancho.
  g_decision_empleo    = o_app->decision_empleo.
  g_kunnr              = o_app->kunnr.
  g_lgort              = o_app->lgort.
  g_peso_text          = o_app->peso_text.
  g_peso_acumulado_txt = o_app->peso_acumulado_txt.
  g_charg              = o_app->charg.
  g_ubicacion          = o_app->ubicacion.
  g_almacen            = o_app->lgort.



ENDFORM.
*FORM exportar_campos_app .
*
*  PERFORM limpiar_campos.
*
*  g_matnr              = |{ o_app->matnr ALPHA = OUT }|.
*  g_calidad            = o_app->calidad.
*  g_gramaje_ancho      = o_app->gramaje_ancho.
*  g_decision_empleo    = o_app->decision_empleo.
*  g_kunnr              = o_app->kunnr.
*  g_lgort              = o_app->lgort.
*  g_peso_text          = o_app->peso_text.
*  g_peso_acumulado_txt = o_app->peso_acumulado_txt.
*  g_charg              = o_app->charg.
*  g_ubicacion          = o_app->ubicacion.
*  g_almacen            = o_app->lgort.
*
*
*
*ENDFORM.

FORM traspaso_a_almacen.

  IF NOT line_exists( lt_bobinas[ charg = g_charg_traspaso ] ).
    ls_bobinas-matnr           = |{ g_matnr_alpha_in ALPHA = OUT }|.
    ls_bobinas-charg           = g_charg_traspaso.
    ls_bobinas-decision_empleo = g_decision_empleo.
    ls_bobinas-gramaje_ancho   = g_gramaje_ancho.
    ls_bobinas-kunnr           = g_kunnr.
    ls_bobinas-peso            = g_peso_text.
    ls_bobinas-peso_real       = g_peso.
    ls_bobinas-calidad         = g_calidad.

    APPEND ls_bobinas TO lt_bobinas.

    ADD g_peso TO g_peso_acumulado.
    g_peso_acumulado_txt =  |{ g_peso_acumulado DECIMALS = 0 } KG |.
  ENDIF.

  MESSAGE 'Lote leído correctamente' TYPE 'S'.

  CLEAR g_barcode.
*  PERFORM alinear_textos_pantalla.

*  g_mostrar_botones = abap_true.

ENDFORM.

FORM validar_turno.


  CALL METHOD zclpp_trazabilidad_usuario=>obtener_datos_turno
    IMPORTING
      o_turno = DATA(l_turno)
*     o_desc_turno =
    .

  IF l_turno <> g_turno.

  ENDIF.

ENDFORM.

FORM obtener_datos_control USING p_rec_tur TYPE char1
                                 p_ret     TYPE char2.

  DATA : l_fecha_fabr      TYPE datum,
         lr_fec            TYPE RANGE OF datum,
         lt_consumo_receta LIKE gt_consumo_receta,
         l_t1              TYPE flag,
         l_t2              TYPE flag,
         l_t3              TYPE flag
         .


  CLEAR lt_consumo_receta.
  CASE p_rec_tur.
    WHEN 'R'. " Datos de receta

      CALL METHOD zclpp_consumo_recetas_mp=>obtener_datos_receta_consumida
        EXPORTING
          i_werks          = g_werks
          i_id_receta      = g_id_receta
          i_t1             = 'X'
          i_t2             = 'X'
          i_t3             = 'X'
        IMPORTING
          ot_datos_consumo = lt_consumo_receta
          o_rc             = p_ret.

    WHEN 'T'. " Datos de turno
* Guardamos la fecha de fabricación, si es la madrugada del T3, restamos 1.
      IF g_turno = 'T3' AND sy-uzeit BETWEEN '000000' AND '055959'.
        l_fecha_fabr     = sy-datum - 1.
      ELSE.
        l_fecha_fabr     = sy-datum.
      ENDIF.
      CLEAR lr_fec.
      APPEND VALUE #( sign = 'I' option = 'EQ'  low = l_fecha_fabr
                      ) TO lr_fec.

      CLEAR: l_t1, l_t2, l_t3.
      CASE g_turno.
        WHEN 'T1'. l_t1 = 'X'.
        WHEN 'T2'. l_t2 = 'X'.
        WHEN 'T3'. l_t3 = 'X'.
        WHEN OTHERS.
      ENDCASE.

      CALL METHOD zclpp_consumo_recetas_mp=>obtener_datos_receta_consumida
        EXPORTING
          i_werks          = g_werks
          i_id_receta      = g_id_receta
          i_t1             = l_t1
          i_t2             = l_t2
          i_t3             = l_t3
*         i_fecha_fab      = l_fecha_fabr
          ir_fecha_fab     = lr_fec
        IMPORTING
          ot_datos_consumo = lt_consumo_receta
          o_rc             = p_ret.

    WHEN OTHERS.
  ENDCASE.

  IF p_ret = '00' OR p_ret = '01'.
    gt_consumo_receta = lt_consumo_receta.
  ENDIF.
ENDFORM.

FORM obtener_datos_dyn820.

  DATA: l_num TYPE numc1.

  CLEAR: gs_dyn820 , l_num.

  CASE g_rec_tur.
    WHEN 'T'. gs_dyn820-titulo = 'CONTROL TURNO'.
    WHEN 'R'. gs_dyn820-titulo = 'CONTROL RECETA'.
    WHEN OTHERS.
  ENDCASE.


* Completar campos de GS_DYN820
  LOOP AT gt_consumo_receta INTO DATA(ls_cons) WHERE ind_equiv = ' '.

    ADD 1 TO l_num.

    DATA(nom_mat) = |GS_DYN820-DESC_MAT{ l_num }|.
    ASSIGN (nom_mat) TO FIELD-SYMBOL(<fs_mat>).
    TRY.
        <fs_mat> = zclpp_consumo_recetas_mp=>gt_mp[ matnr = ls_cons-matnr  werks = g_werks       ]-descrip_rf.
      CATCH cx_root .
    ENDTRY.

    DATA(porc_cic) = |GS_DYN820-PORC_CIC{ l_num }|.
    ASSIGN (porc_cic) TO FIELD-SYMBOL(<fs_porc_cic>).
    <fs_porc_cic> = ls_cons-porc_ciclo.

    DATA(porc_rea) = |GS_DYN820-PORC_REA{ l_num }|.
    ASSIGN (porc_rea) TO FIELD-SYMBOL(<fs_porc_rea>).
    <fs_porc_rea> = ls_cons-porc_real.

    DATA(porc_dif) = |GS_DYN820-DIF_PORC{ l_num }|.
    ASSIGN (porc_dif) TO FIELD-SYMBOL(<fs_porc_dif>).
    <fs_porc_dif> = ls_cons-porc_dif.

    IF abs( ls_cons-porc_dif ) > ls_cons-tolerancia.
    ELSE.
      DATA(ico) = |GS_DYN820-LED{ l_num }|.
      LOOP AT SCREEN.
        IF screen-name = ico.
          screen-invisible = 1.
          MODIFY SCREEN.
        ENDIF.
      ENDLOOP.

    ENDIF.


* A las 9 ocurrencias salimos, lineas completadas
    IF l_num = 9.
      EXIT.
    ENDIF.

  ENDLOOP.

* Ocultar campos de lineas en blanco.
  DATA(l_tot_blanks) = l_num.
  DO 9 - l_tot_blanks TIMES.
    ADD 1 TO l_num.
    LOOP AT SCREEN.
      IF screen-name = |GS_DYN820-LED{ l_num }| OR
         screen-name = |GS_DYN820-PORC_CIC{ l_num }| OR
         screen-name = |GS_DYN820-PORC_REA{ l_num }| OR
         screen-name = |GS_DYN820-DIF_PORC{ l_num }|.

        screen-invisible = 1.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ENDDO.


ENDFORM.

*FORM timer.
*
*  IF zcl_secuenciador=>gc_time_alv_pope > 0. " g_af_timer GT 0.
*    CREATE OBJECT g_timer.
*    CREATE OBJECT g_receiver.
*    SET HANDLER g_receiver->handle_finished FOR g_timer.
*    g_timer->interval = zcl_secuenciador=>gc_time_alv_pope.
*    CALL METHOD g_timer->run.
*  ENDIF.
*
*ENDFORM.


FORM proceso_barcode.

  DATA: l_clabs          TYPE labst, l_meins TYPE meins,
        l_matnr          TYPE matnr,
        l_matnr_alpha_in TYPE matnr,
        l_maktx          TYPE maktx,
        l_werks          TYPE werks_d,
        l_mtart          TYPE mtart,
        l_lgobe          TYPE lgobe,
        l_charg          TYPE charg_d,
        l_lgort          TYPE lgort_d.
  DATA lt_mseg TYPE TABLE OF mseg.
  DATA l_error TYPE abap_bool.

  IF g_rec_inact_caduc = 'X'. " Si receta caducada, no se permite grabacion
    DATA(l_msg2) = CONV string( 'Receta inactiva y caducada, no se permite lectura' ).
    MESSAGE l_msg2 TYPE 'S' DISPLAY LIKE 'E'.
    IF sy-dynnr = '0825'. " Este form se llama 2 veces, dyn 100 y en dyn 825 después, iniciamos variable despues de la 2a pantalla
      CLEAR g_rec_inact_caduc.
    ENDIF.
    RETURN.
  ENDIF.

  CLEAR l_error.

  IF g_werks IS INITIAL.
    SELECT SINGLE parva INTO g_werks FROM usr05
                                    WHERE bname = sy-uname AND parid = 'WRK'.
  ENDIF.

  CHECK g_barcode IS NOT INITIAL AND sy-ucomm NE 'BACK'.

  DATA(l_len) = strlen( g_barcode ).

  IF l_len <= 10.
    l_msg2 = CONV string( 'Material inexistente' ).
    MESSAGE l_msg2 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  DATA(l_len_charg) = l_len - 10.

*Validar que se trata de un lote de recorte (ZREC) o bobina pulper (material 2001764) --> "Error: lote XXXXXXXXXX inexistente"
*Validar que tiene stock --> "Error lote XXXXXXXXXX con 0 kg"
*Validar que el lote no existe ya en el pulper (4002) --> "Error: lote XXXXXXXXXX ya enviado a pulper"
*Validar que el lote, aunque no exista en el pulper, ya se envió (311 a 4002) --> "Error: lote XXXXXXXXXX ya enviado a pulper"

  l_charg = g_barcode+l_len_charg(10).

  l_matnr = |{ g_barcode(l_len_charg) ALPHA = OUT }|.
  l_matnr_alpha_in = |{ l_matnr ALPHA = IN }|.

  SELECT SINGLE: maktx INTO l_maktx FROM makt WHERE matnr = l_matnr_alpha_in AND spras = sy-langu,
                 mtart INTO l_mtart FROM mara WHERE matnr = l_matnr_alpha_in.


  IF l_mtart NE 'ZREC' AND  l_matnr NE c_matnr_pulper.
    DATA(l_msg) = CONV string( 'Lote & inexistente' ).
    REPLACE '&' IN l_msg WITH l_charg.
    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  SELECT SINGLE matnr INTO l_matnr_alpha_in FROM mcha WHERE matnr = l_matnr_alpha_in AND charg = l_charg AND werks = g_werks.
  IF sy-subrc NE 0.
    l_msg = CONV string( 'Lote & inexistente' ).
    REPLACE '&' IN l_msg WITH l_charg.
    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.

    RETURN.
  ENDIF.

  REFRESH lt_mseg.

  RANGES range_lgort FOR mseg-lgort.


  SELECT * INTO TABLE lt_mseg FROM mseg
                 WHERE matnr EQ l_matnr_alpha_in
                   AND werks EQ g_werks
                   AND lgort IN range_lgort
                   AND
                   ( bwart EQ '701' OR bwart EQ '702'  )
                   AND sobkz = ''
                   AND charg EQ l_charg
                   ORDER BY budat_mkpf DESCENDING cputm_mkpf DESCENDING.


  IF lines( lt_mseg ) NE 0.
    IF lt_mseg[ 1 ]-bwart = '702'.
      l_msg = 'Error:Lote & dado de baja por regularizacion'.
      REPLACE '&' IN l_msg WITH l_charg.
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.
  ENDIF.


  CLEAR l_clabs.

  SELECT SINGLE clabs
              INTO l_clabs
              FROM mchb
              WHERE matnr = l_matnr_alpha_in
                AND charg = l_charg
                AND lgort = '4002'
                AND werks = g_werks
                .
  IF sy-subrc EQ 0.
    IF l_clabs GT 0.
      l_msg = 'Lote & ya lanzado al pulper'.
      CLEAR g_barcode.
      REPLACE '&' IN l_msg WITH l_charg.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      EXIT.
    ELSE.
      l_msg = CONV string( text-004 ).
      REPLACE '&' IN l_msg WITH l_charg.
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      EXIT.
    ENDIF.
  ENDIF.

  SELECT SINGLE mchb~clabs mara~meins t001l~lgort t001l~lgobe
                INTO ( l_clabs, l_meins, l_lgort, l_lgobe )
                FROM mchb INNER JOIN t001l
                                  ON mchb~lgort = t001l~lgort
                          INNER JOIN mara
                                  ON mchb~matnr = mara~matnr
                WHERE mchb~matnr = l_matnr_alpha_in
                  AND mchb~charg = l_charg
                  AND mchb~werks = g_werks
                  AND mchb~clabs > 0.
  IF sy-subrc NE 0.

    SELECT SINGLE mchb~clabs mara~meins t001l~lgort t001l~lgobe
                   INTO ( l_clabs, l_meins, l_lgort, l_lgobe )
                   FROM mchb INNER JOIN t001l
                                     ON mchb~lgort = t001l~lgort
                             INNER JOIN mara
                                     ON mchb~matnr = mara~matnr
                   WHERE mchb~matnr = l_matnr_alpha_in
                     AND mchb~charg = l_charg
                     AND mchb~werks = g_werks.
    IF l_lgort = c_lgort_pulper.
      l_msg = 'Lote & ya lanzado al pulper y consumido'.
      REPLACE '&' IN l_msg WITH l_charg.
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      EXIT.
    ELSE.
      SELECT SINGLE mchb~clabs mara~meins t001l~lgort t001l~lgobe
              INTO ( l_clabs, l_meins, l_lgort, l_lgobe )
              FROM mchb INNER JOIN t001l
                                ON mchb~lgort = t001l~lgort
                        INNER JOIN mara
                                ON mchb~matnr = mara~matnr
              WHERE mchb~matnr = l_matnr_alpha_in
                AND mchb~charg = l_charg
                AND mchb~werks = g_werks AND clabs = 0.
      IF sy-subrc EQ 0.
        l_msg = CONV string( 'Lote con 0 kg').
        REPLACE '&' IN l_msg WITH l_charg.
        CLEAR g_barcode.
        MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ELSE.
        l_msg = CONV string( text-004 ).
        REPLACE '&' IN l_msg WITH l_charg.
        CLEAR g_barcode.
        MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.
    ENDIF.
  ENDIF.

  g_matnr = l_matnr.
  g_maktx = l_maktx.
  g_charg = l_charg.
  g_lgort = l_lgort.
  g_lgobe = l_lgobe.

  g_peso = l_clabs.

  g_peso_text = |{ g_peso  } KG|.

  REPLACE ALL OCCURRENCES OF '.' IN g_peso_text WITH  ','.


*  IF zclpp_consumo_recetas_mp=>es_antiguo_tratamiento( i_werks = g_werks ) = ' '.

******************************
* Inicio Validación recetas. *
******************************
  CALL METHOD zclpp_consumo_recetas_mp=>validar_lectura_lote_rf
    EXPORTING
      i_werks     = g_werks
      i_id_receta = g_id_receta
      i_lote      = g_charg
    IMPORTING
      o_rc        = DATA(l_ret).

  CASE l_ret.
    WHEN '00'. " Lote tratado correctamente

    WHEN '01'.
      l_msg = CONV string( 'Receta no iniciada.').
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    WHEN '02' OR '03'.
      l_msg = CONV string( 'Lote no valido.').
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    WHEN '04'.
      g_aviso_d_r_t = 'M'. " Llamada a pantalla de aviso "El material no existe en la receta"
*      CALL SCREEN 825.
      SET SCREEN 825.
      EXIT.
**      RETURN.
    WHEN '05'.
      l_msg = CONV string( 'Ya se ha leido el lote.').
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.

    WHEN OTHERS.
  ENDCASE.
**************************
* Fin Validación recetas *
**************************
*  ENDIF.
  PERFORM traspasar
              USING
                 l_matnr_alpha_in
                 g_charg
                 g_werks
                 g_lgort
                 c_lgort_pulper
                 l_clabs
              CHANGING l_error.

  IF l_error EQ abap_true.
*    l_msg = |{ text-002 } { g_charg }|.
*    MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'
*    EXIT.
  ELSE.

*    IF zclpp_consumo_recetas_mp=>es_antiguo_tratamiento( i_werks = g_werks ) = ' '.

* Inicio grabación datos de receta, y validar aviso si no es la receta actual.
    DATA l_operario TYPE znombre_oper.

    TRY.
        l_operario = gt_values_dyn0015[ key = g_operario ]-text(30).
      CATCH cx_root .
        l_operario = g_operario.
    ENDTRY.

    CALL METHOD zclpp_consumo_recetas_mp=>generar_consumo_receta
      EXPORTING
        i_werks     = g_werks
        i_id_receta = g_id_receta
        i_lote      = g_charg
        i_matnr     = l_matnr_alpha_in
        i_lgort     = g_lgort
        i_operario  = l_operario
      IMPORTING
        o_rc        = DATA(l_ret2).
    IF l_ret2 <> '00'.
      l_msg = CONV string( |Error inesperado al grabar receta. RC={ l_ret2 }.| ).
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.

*      ELSEIF zclpp_recetas_mp=>obtener_temporalidad_receta( i_fecha_ini = gs_datos_receta-fecha_ini
*                                                            i_hora_ini  = gs_datos_receta-hora_ini
*                                                            i_fecha_fin = gs_datos_receta-fecha_fin
*                                                            i_hora_fin  = gs_datos_receta-hora_fin
*                                                            ) = 'P'.
*        l_msg = CONV string( |Aviso. Receta NO actual.| ).
*        CLEAR g_barcode.
*        MESSAGE l_msg TYPE 'S' DISPLAY LIKE 'E'.
*        RETURN.

    ELSE.

      l_msg = 'Lote & --> pulper'.
      REPLACE '&' IN l_msg WITH l_charg.
      CLEAR g_barcode.
      MESSAGE l_msg TYPE 'S'.

    ENDIF.
* Fin modif. RECETAS

***    ELSE.
***      l_msg = 'Lote & --> pulper'.
***      REPLACE '&' IN l_msg WITH l_charg.
***      CLEAR g_barcode.
***      MESSAGE l_msg TYPE 'S'.
***    ENDIF.

  ENDIF.


ENDFORM.

FORM proceso_barcode_101.
  DATA: l_peso TYPE p DECIMALS 3.

  CHECK gs_dyn101-barcode IS NOT INITIAL AND
        sy-ucomm NE 'BACK' AND
        sy-ucomm NE 'ACPT' . " Solo se valida antes de mostrar F5.

  DATA(l_len) = strlen( gs_dyn101-barcode ).

  IF l_len <= 10.
    DATA(l_msg2) = CONV string( 'Material inexistente' ).
    MESSAGE l_msg2 TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  DATA(l_len_charg) = l_len - 10.

  gs_dyn101-lote = gs_dyn101-barcode+l_len_charg(10).


  SELECT SINGLE * INTO @DATA(ls_lote_hermano)
    FROM ztpp0041
    WHERE werks     = @g_werks     AND
          id_receta = @g_id_receta AND
          charg     = @gs_dyn101-lote.
  IF sy-subrc <> 0.
    CLEAR gs_dyn101-lote.
    l_msg2 = CONV string( 'Lote hermano aún no leído' ).
    MESSAGE l_msg2 TYPE 'S' DISPLAY LIKE 'E'.
  ELSE.

* 03/08/2020 - CMS - 62303 - No se permite crear lotes hermanos de materiales equivalentes (Pulper, papel manta, mandriles....)
    PERFORM obtener_equivalentes_recorte.
    IF line_exists( gt_equiv_recorte[ werks = g_werks matnr_mp = ls_lote_hermano-matnr ] ).
      l_msg2 = CONV string( 'Material no permitido' ).
      MESSAGE l_msg2 TYPE 'S' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    gs_dyn101-f5_ok    = 'X'.
    gs_dyn101-matnr    = ls_lote_hermano-matnr.
    gs_dyn101-matnr    = |{ ls_lote_hermano-matnr ALPHA = OUT }|.

    l_peso = ls_lote_hermano-kg_reales.
    gs_dyn101-peso_text = |{ l_peso  } KG|.

    SELECT SINGLE maktx INTO gs_dyn101-maktx
      FROM makt
      WHERE matnr = gs_dyn101-matnr AND spras = sy-langu.

  ENDIF.


ENDFORM.

FORM obtener_equivalentes_recorte.

  DATA: l_recorte TYPE matnr.

  IF gt_equiv_recorte IS INITIAL.

    l_recorte = '000000000001500005'.

    SELECT *
      INTO TABLE @gt_equiv_recorte
      FROM ztpp0037
      WHERE werks       = @g_werks AND
            matnr_equiv = @l_recorte AND
            lvorm       = ' '.

  ENDIF.

ENDFORM.

FORM iniciar_timer.

  IF g_timer IS NOT BOUND.
    CREATE OBJECT g_timer.
    CREATE OBJECT g_receiver.
    SET HANDLER g_receiver->handle_finished FOR g_timer.
*    g_timer->interval = 7200.
    g_timer->interval = zclpp_consumo_recetas_mp=>obtener_intervalo_ctrl_receta( i_werks = g_werks ). " Valor informado en ZTPP0033.
  ELSE.
    CALL METHOD g_timer->finalize.
  ENDIF.

  CALL METHOD g_timer->run.

ENDFORM.

FORM validar_desviacion_receta CHANGING p_aviso TYPE char1.

  DATA: l_fecha_fabr TYPE datum,
        l_t1         TYPE flag,
        l_t2         TYPE flag,
        l_t3         TYPE flag,
        lr_fec       TYPE RANGE OF datum
        .

  IF g_turno = 'T3' AND sy-uzeit BETWEEN '000000' AND '055959'.
    l_fecha_fabr     = sy-datum - 1.
  ELSE.
    l_fecha_fabr     = sy-datum.
  ENDIF.
  APPEND VALUE #( sign = 'I' option = 'EQ'  low = l_fecha_fabr
                  ) TO lr_fec.

  CLEAR: l_t1, l_t2, l_t3.
  CASE g_turno.
    WHEN 'T1'. l_t1 = 'X'.
    WHEN 'T2'. l_t2 = 'X'.
    WHEN 'T3'. l_t3 = 'X'.
    WHEN OTHERS.
  ENDCASE.

  CALL METHOD zclpp_consumo_recetas_mp=>obtener_datos_receta_consumida
    EXPORTING
      i_werks          = g_werks
      i_id_receta      = g_id_receta
      i_t1             = l_t1
      i_t2             = l_t2
      i_t3             = l_t3
*     i_fecha_fab      = l_fecha_fabr
      ir_fecha_fab     = lr_fec
    IMPORTING
      ot_datos_consumo = DATA(lt_consumo_receta).
*          o_rc             = l_ret.

  LOOP AT lt_consumo_receta INTO DATA(ls_cons).

    IF abs( ls_cons-porc_dif ) > ls_cons-tolerancia.
      p_aviso = 'X'.
      EXIT.
    ELSE.
      CLEAR p_aviso.
    ENDIF.

  ENDLOOP.



ENDFORM.


FORM obtener_stock.

  DATA: l_objkey TYPE ausp-objek,
        l_cuobj  TYPE cuobj.

  DATA(l_matnr) = |{ g_matnr ALPHA = IN }|.
  SELECT mchb~matnr, charg FROM mara
           JOIN mchb ON mara~matnr EQ mchb~matnr
           INTO TABLE @DATA(lt_charg)
          WHERE mara~matnr = @l_matnr
            AND werks = @o_app->werks
            AND lgort = @g_lgort
            AND clabs NE 0.

  IF sy-subrc EQ 0.

    SELECT SINGLE atinn INTO @DATA(g_atinn_peso)
                              FROM cabn
                              WHERE atnam = 'Z_PESO'.

    SELECT SINGLE atinn INTO @DATA(g_atinn_ubic)
                              FROM cabn
                              WHERE atnam = 'Z_UBIC_HPAP'.

    SELECT SINGLE atinn INTO @DATA(g_atinn_cliente)
                              FROM cabn
                              WHERE atnam = 'Z_CLIENTE'.
    SELECT SINGLE atinn INTO @DATA(g_atinn_de)
                              FROM cabn
                              WHERE atnam = 'LOBM_UDCODE'.

    LOOP AT lt_charg INTO DATA(ls_charg).

      CLEAR :gs_data_0650.
      gs_data_0650-charg = ls_charg-charg.

      CONCATENATE ls_charg-matnr ls_charg-charg INTO l_objkey .

      SELECT SINGLE cuobj INTO l_cuobj FROM inob
                         WHERE objek = l_objkey AND obtab = 'MCH1'.

      SELECT SINGLE atflv INTO @DATA(l_peso) FROM ausp
                         WHERE objek = @l_cuobj AND atinn = @g_atinn_peso
                                                AND klart = '023'.

      SELECT SINGLE atwrt INTO @DATA(l_ubic) FROM ausp
                         WHERE objek = @l_cuobj AND atinn = @g_atinn_ubic
                                                AND klart = '023'.
      IF l_ubic IS INITIAL OR sy-subrc NE 0.
        l_ubic = '0000'.
      ENDIF.

*      SELECT SINGLE atwrt INTO @DATA(l_de) FROM ausp
*                         WHERE objek = @l_cuobj AND atinn = @g_atinn_de
*                                                AND klart = '023'.
*
*      IF l_de NE g_decision_empleo AND g_decision_empleo IS NOT INITIAL..
*        CONTINUE.
*      ENDIF.

      SELECT SINGLE atwrt INTO @DATA(l_kunnr) FROM ausp
                          WHERE objek = @l_cuobj AND atinn = @g_atinn_cliente
                                                 AND klart = '023'.
      IF sy-subrc NE 0.
        CONTINUE.
      ENDIF.
      IF l_kunnr NE g_kunnr AND g_kunnr IS NOT INITIAL..
        CONTINUE.
      ENDIF.
      gs_data_0650-peso        = |{ l_peso DECIMALS = 0 } KG|.
      gs_data_0650-ubicacion   = l_ubic.

      APPEND gs_data_0650 TO gt_data_0650.

    ENDLOOP.

    SORT gt_data_0650 ASCENDING BY ubicacion
                                   charg.

  ENDIF.

ENDFORM.


FORM paginacion_stock_0650.

  DATA l_pag TYPE p DECIMALS 2.
  CLEAR:
  linea_1,
  linea_2,
  linea_3,
  linea_4,
  linea_5,
  linea_6,
  linea_7,
  linea_8,linea_9,linea_0.


  l_pag = lines( gt_data_0650 ) / 10.

  IF l_pag LE 1.
    g_pagina_0650 = 0.
  ELSE.
    g_pagina_0650 = trunc( l_pag ) .
  ENDIF.


  IF g_pag_actual_0650 = 0.
    g_linea_actual_0650 = 0.
  ELSE.
    g_linea_actual_0650 = ( g_pag_actual_0650 * 10 ) + 1.
  ENDIF.
  g_linea_actual_0650_max = g_linea_actual_0650 + 10.

  DATA l_linea     TYPE char10.
  DATA l_index_tab TYPE n LENGTH 1.
  DATA l_spaces    TYPE char8.

  l_index_tab = 0.
  LOOP AT gt_data_0650 INTO gs_data_0650 FROM g_linea_actual_0650 TO g_linea_actual_0650_max.

    CONCATENATE 'LINEA_' l_index_tab INTO l_linea.
    ASSIGN (l_linea) TO FIELD-SYMBOL(<fs_650>).
    IF <fs_650> IS ASSIGNED .
      <fs_650> = |{ gs_data_0650-charg }        { gs_data_0650-peso }       { gs_data_0650-ubicacion }|.
    ENDIF.
    ADD 1 TO l_index_tab .
  ENDLOOP.

ENDFORM.
