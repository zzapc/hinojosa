
class ZCL_SI_PROD_REPLENISHMENT_UI5 definition
  public
  create public .

public section.

  interfaces ZII_SI_PROD_REPLENISHMENT_UI5 .

  data GA_CLA_NEMESIS type XFELD .
  data GA_WERKS type WERKS_D value 2001 ##NO_TEXT.
  constants GAC_CLAVE_HARDCODES_PACS type ZTWM001-CPROG value 'INTF_OMP_PACS' ##NO_TEXT.
  constants GAC_CLAVE_HARDCODES_XATIVA type ZTWM001-CPROG value 'INTF_OMP_HPX' ##NO_TEXT.
  constants GAC_CLAVE_HARDCODES_BERNABEU type ZTWM001-CPROG value 'INTF_NEMESIS' ##NO_TEXT.
  constants GAC_LGNUM_BERNABEU type LGNUM value '240' ##NO_TEXT.
  constants GAC_LGNUM_PACS type LGNUM value '201' ##NO_TEXT.
  data GA_LGNUM type LGNUM .
  data GA_HOURS_RSNUM type UZEIT .
  constants GAC_CLAVE_HARDCODES_ER type ZTWM001-CPROG value 'INTF_OMP_ER' ##NO_TEXT.
  constants GAC_CLAVE_HARDCODES_SCY type ZTWM001-CPROG value 'INTF_OMP_SCY' ##NO_TEXT.
  constants GAC_LGNUM_HPX type LGNUM value '200' ##NO_TEXT.
  constants GAC_LGNUM_ER type LGNUM value '210' ##NO_TEXT.
  constants GAC_LGNUM_SCY type LGNUM value '270' ##NO_TEXT.
  constants C_MATERIAL_DUMMY type MATNR value '000001010100000000' ##NO_TEXT.
  data O_LOG type ref to ZCL_AP_LOG .

  class-methods DAME_MATERIAL_PACS
    importing
      !IV_STR type STRING
      !IV_WERKS type WERKS_D
    changing
      !CV_MATNR type MATNR
    exceptions
      NO_MATERIAL_FOUND
      E_CALIDAD_VACIA
      E_VALOR_EXTERNO
      E_VALOR_SAP
      E_SIN_VALOR
      E_MAT_ZPIM_NOT_FOUND .
  class-methods DAME_MATERIAL
    importing
      !IV_STR type STRING
      !IV_WERKS type WERKS_D
    changing
      !CV_MATNR type MATNR
    exceptions
      NO_MATERIAL_FOUND
      E_CALIDAD_VACIA
      E_VALOR_EXTERNO
      E_VALOR_SAP
      E_SIN_VALOR
      E_MAT_ZPIM_NOT_FOUND .
  class-methods DAME_MATERIAL_NAV
    importing
      !I_MATNR_NAV type STRING
      !I_WERKS type WERKS_D
    returning
      value(E_MATNR) type MATNR
    exceptions
      NO_MATERIAL_FOUND
      E_CALIDAD_VACIA
      E_VALOR_EXTERNO
      E_VALOR_SAP
      E_SIN_VALOR
      E_MAT_ZPIM_NOT_FOUND .
  class-methods DAME_MATERIAL_SAP
    importing
      !IV_MATNR type MATNR
      !IV_WERKS type WERKS_D
    exceptions
      NO_MATERIAL_FOUND
      E_CALIDAD_VACIA
      E_VALOR_EXTERNO
      E_VALOR_SAP
      E_SIN_VALOR
      E_MAT_ZPIM_NOT_FOUND .
  class-methods CHECK_MATERIAL_EXISTS
    importing
      !IV_MATNR type MATNR
      !IV_WERKS type WERKS_D
    exceptions
      ERROR_CREACION
      MATERIAL_VACIO .
  methods BORRA_NT_ABIERTAS
    importing
      !IV_NLPLA type LTBK-NLPLA optional .
  methods CLOSE_RESERVATION
    importing
      !IV_NLPLA type LTBK-NLPLA optional .
  methods DAME_HARDCODES
    importing
      !VP_CPROG type ZTWM001-CPROG .
  PROTECTED SECTION.
private section.

  types:
    gtyp_ltbk TYPE STANDARD TABLE OF ltbk WITH DEFAULT KEY .
  types:
    gtyp_ltbp TYPE STANDARD TABLE OF ltbp .
  types:
    BEGIN OF treg_log,
        cinumber TYPE lvs_benum,
*
        matnr_1  TYPE string,
        menge_1  TYPE ltbp_menge,
        ok_1     TYPE tbnum,
        ko_1     TYPE bapi_msg,

        matnr_2  TYPE string,
        menge_2  TYPE ltbp_menge,
        ok_2     TYPE tbnum,
        ko_2     TYPE bapi_msg,

        matnr_3  TYPE string,
        menge_3  TYPE ltbp_menge,
        ok_3     TYPE tbnum,
        ko_3     TYPE bapi_msg,

        matnr_4  TYPE string,
        menge_4  TYPE ltbp_menge,
        ok_4     TYPE tbnum,
        ko_4     TYPE bapi_msg,

        matnr_5  TYPE string,
        menge_5  TYPE ltbp_menge,
        ok_5     TYPE tbnum,
        ko_5     TYPE bapi_msg,

        matnr_6  TYPE string,
        menge_6  TYPE ltbp_menge,
        ok_6     TYPE tbnum,
        ko_6     TYPE bapi_msg,

      END OF treg_log .
  types:
    gtyp_log TYPE STANDARD TABLE OF treg_log .

  data GAT_BDCDATA type BDCDATA_TAB .
  constants GAC_NODATA type BDC_FVAL value '/' ##NO_TEXT.
  data GAT_BORRADAS type GTYP_LTBK .
  data GAT_CREADAS type GTYP_LTBK .
  data GAT_MODIFICADAS type GTYP_LTBK .
  data GAT_RETURN type BAPIRET2_T .
  data GA_LGORT_ISC type LGORT_D value 1000 ##NO_TEXT.
  data GA_LGORT type LGORT_D value 1000 ##NO_TEXT.
  data GA_BWART type BWART value 919 ##NO_TEXT.
  data GA_AUFNR type AUFNR .
  data GA_NLPLA01 type LTAP_NLPLA .
  data GA_NLPLA02 type LTAP_NLPLA .
  data GA_NLPLA03 type LTAP_NLPLA .
  data GA_NLPLA04 type LTAP_NLPLA .
  data GA_NLPLA05 type LTAP_NLPLA .
  data GA_NLPLA06 type LTAP_NLPLA value '' ##NO_TEXT.
  data GAT_LOG type GTYP_LOG .
  data:
    gac_th(4) value '<th>' ##NO_TEXT.
  data:
    gac_thf(5) value '</th>' ##NO_TEXT.
  data:
    gac_tr(4) value '<tr>' ##NO_TEXT.
  data:
    gac_trf(5) value '</tr>' ##NO_TEXT.
  data:
    gac_td(4) value '<td>' ##NO_TEXT.
  data:
    gac_tdf(5) value '</td>' ##NO_TEXT.
  data GAV_HAY_ERROR type ABAP_BOOL .
  data GT_LTBA type ZCL_WM_CONSTANTS=>GTTY_LTBA_IDX .
  data GT_NT_DAT_UPDATE type GTYP_LTBK .
  constants GAC_NOMBRE_JOB_CREA_MATERIAL type STRING value 'CREAR_MATERIAL_NEMESIS_REPLEN' ##NO_TEXT.
  data TG_LGPLA_BORRAR_NTS type ZRANGE_T_LGPLA .

  methods ADD_NT_DAT_UPD
    importing
      !IS_LTBK type LTBK .
  methods GET_NT_DAT_UPD
    importing
      !IV_IDX type INT4 optional
      !IV_REMOVE type BOOLEAN default ABAP_FALSE
    returning
      value(RT_LTBK) type GTYP_LTBK .
  methods INIT_NT_DAT_UPD .
  methods ADJUST_NT_DATE_INDIVIDUAL
    importing
      !I_LTBA type LTBA
      value(I_LTBK) type LTBK
      value(I_LTBP) type LTBP optional .
  methods ADJUST_NT_DATE
    importing
      !IV_NLPLA type LTBK-NLPLA optional .
  methods BORRA_NECESIDAD
    importing
      !PI_LGNUM type LGNUM
      !PI_TBNUM type TBNUM
    returning
      value(PR_BORRADA) type ABAP_BOOL .
  methods F_BDC_DYNPRO
    importing
      !PE_DYN type BDC_DYNR
      !PE_PROG type BDC_PROG .
  methods F_BDC_FIELD
    importing
      !PE_FNAM type FNAM_____4
      !PE_FVAL type BDC_FVAL .
  methods DAME_TABLA_CREADAS
    changing
      !PT_MESS type SOLI_TAB .
  methods DAME_TABLE_ERROES
    changing
      !PT_MESS type SOLI_TAB .
  methods ERROR_MATERIAL_LOG
    importing
      !PI_SUBRC type SYST_SUBRC
    returning
      value(PC_KO) type BAPI_MSG .
  methods BORRA_NT_NO_MODIFICADAS
    importing
      !IV_NLPLA type LTBK-NLPLA optional .
  methods CARGA_NT_MODIFICADAS .
  methods CREAR_NTS
    importing
      !PI_INDEX type SY-INDEX
      !IV_FSC type FLAG optional
      !IV_STORE_ONLY type BOOLEAN default ABAP_TRUE
      !IT_LTBA type ZCL_WM_CONSTANTS=>GTTY_LTBA optional
    changing
      !PT_LTBK type GTYP_LTBK optional
      !PT_LTBP type GTYP_LTBP optional
      !PC_OK type TBNUM
      !PC_KO type BAPI_MSG .
  methods ENVIA_MAIL_NOTIFICACION .
  methods NOTIFICA_BORRADA
    importing
      !PI_LGNUM type LGNUM
      !PI_TBNUM type TBNUM .
  methods NOTIFICA_MODIFICADA
    importing
      !PI_LTBK type LTBK .
  methods STORE_LTBA
    importing
      !IT_LTBA type ZCL_WM_CONSTANTS=>GTTY_LTBA
      !IV_FSC type FLAG optional
      !IV_IDX type SY-TABIX .
  methods RUN_LTBA .
  methods REMOVE_IDX_LTBA
    importing
      !IV_IDX type I .
  methods GET_LTBA
    returning
      value(RT_LTBA) type ZCL_WM_CONSTANTS=>GTTY_LTBA_IDX .
  methods CREATE_RESERVATION
    returning
      value(RV_RSNUM) type BAPI2093_RES_KEY-RESERV_NO .
  methods CHECK_RESERVATION
    importing
      !IT_LTBK type GTYP_LTBK
      !IV_RSNUM type BAPI2093_RES_KEY-RESERV_NO
    returning
      value(RV_CONF) type BOOLEAN .
  methods DELETE_RESERVATION
    importing
      !IV_RSNUM type BAPI2093_RES_KEY-RESERV_NO .
endclass. "ZCL_SI_PROD_REPLENISHMENT_UI5 definition
class ZCL_SI_PROD_REPLENISHMENT_UI5 implementation.
  METHOD add_nt_dat_upd.

    CHECK NOT line_exists( me->gt_nt_dat_update[ lgnum = is_ltbk-lgnum tbnum = is_ltbk-tbnum ] ).
    APPEND is_ltbk TO me->gt_nt_dat_update.
  ENDMETHOD.
  METHOD adjust_nt_date.
    DATA: lt_ltbk TYPE TABLE OF ltbk,
          lt_ltbp TYPE TABLE OF ltbp.
    DATA r_nlpla TYPE RANGE OF ltbk-nlpla.
    DATA(lt_ltba) = me->get_ltba( ).
    DATA(lt_nt_dat) = me->get_nt_dat_upd(
*                      iv_idx    =
                      iv_remove = abap_true
                  ).
    CHECK lines( lt_ltba ) > 0 AND lines( lt_nt_dat ) > 0.

    IF iv_nlpla IS NOT INITIAL.
      r_nlpla = VALUE #( sign = 'I' option = 'EQ' ( low = iv_nlpla ) ).
    ENDIF.

    LOOP AT lt_ltba INTO DATA(ls_ltba) WHERE nlpla IN r_nlpla.
      DATA(lv_idx) = sy-tabix.
      LOOP AT ls_ltba-it_ltba INTO DATA(ls_ltba_lin).
        TRY.
            DATA(ls_ltbk) = lt_nt_dat[ benum = ls_ltba_lin-benum nlpla = ls_ltba_lin-nlpla ] .

            CLEAR lt_ltbk.
            SELECT * FROM ltbk
              INTO CORRESPONDING FIELDS OF TABLE lt_ltbk
              WHERE lgnum = ls_ltbk-lgnum
              AND tbnum = ls_ltbk-tbnum.

            CHECK sy-subrc = 0 AND sy-dbcnt = 1.

            lt_ltbk[ 1 ]-pdatu = ls_ltba_lin-pdatu.
            lt_ltbk[ 1 ]-pzeit = ls_ltba_lin-pzeit.

            " remove from lt_ltba
            me->remove_idx_ltba( iv_idx = lv_idx ).
            DELETE lt_ltba.
            " now change for new date
            CALL FUNCTION 'L_TR_CHANGE_INTERN'
              TABLES
                iltbk = lt_ltbk     " Transfer requirement headers
                iltbp = lt_ltbp.    " Transfer requirement items
          CATCH cx_root.
        ENDTRY.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD adjust_nt_date_individual.
    DATA: lt_ltbk TYPE TABLE OF ltbk,
          lt_ltbp TYPE TABLE OF ltbp.

    i_ltbk-pdatu = i_ltba-pdatu.
    i_ltbk-pzeit = i_ltba-pzeit.
*    i_ltbk-tbktx = i_ltba-tbktx. " también actualizamos observaciones " del - cvivo - 65089
    APPEND i_ltbk TO lt_ltbk.

    " cvivo 65424 - aquí no vamos a modificar cantidad, no hay FM correcto (el intern no vale porque sólo modificaría el campo menga y
    " hay más de cantidad), tampoco consigo hacerlo por batch-input, así que la marcaremos para borrar y volver a crear en el método superior
    " controlamos que hay que modificar porque tenemos I_LTBP relleno



    DATA vl_modificado TYPE xfeld.
    SELECT SINGLE * FROM zwm_ltbk_adit
      INTO @DATA(ls_data)
      WHERE lgnum EQ @i_ltbk-lgnum
        AND tbnum EQ @i_ltbk-tbnum.
    IF sy-subrc = 0 AND i_ltbp-tbnum IS NOT INITIAL.
      IF i_ltbp-menga <> i_ltba-menga.
        ls_data-menge = i_ltba-menga.
        vl_modificado = 'X'.
      ENDIF.


      DATA(wl_ltbk_adit) = zcl_wm_zwm_ltbk_adit_dao=>get_internal_entry( iv_nlpla = ls_data-nlpla
                                                                         iv_benum = ls_data-benum ).
      IF wl_ltbk_adit IS NOT INITIAL AND ls_data-texto <> wl_ltbk_adit-texto.
        ls_data-texto = wl_ltbk_adit-texto.
        vl_modificado = 'X'.
      ENDIF.

      IF vl_modificado = 'X'.
        MODIFY zwm_ltbk_adit FROM ls_data.
      ENDIF.
    ENDIF.

    " now change for new date
    CALL FUNCTION 'L_TR_CHANGE_INTERN'
      TABLES
        iltbk = lt_ltbk     " Transfer requirement headers
        iltbp = lt_ltbp.    " Transfer requirement items

    COMMIT WORK AND WAIT.

    APPEND LINES OF lt_ltbk TO gat_modificadas. " apuntamos que ha sido modificada, para evitar borrarla después
  ENDMETHOD.
  METHOD borra_necesidad.
    DATA: ls_opt TYPE ctu_params,
          lt_msg TYPE TABLE OF bdcmsgcoll,
          lv_aux TYPE bdc_fval.

    REFRESH gat_bdcdata.
    CLEAR pr_borrada.

    ls_opt-nobinpt = abap_true.
    ls_opt-updmode = 'S'. " síncrono - cvivo - Si no la lectura posterior a LTBK para verificar no funciona
    ls_opt-dismode = 'N'.

    f_bdc_dynpro( EXPORTING pe_prog = 'SAPML02B' pe_dyn = '0100').
    f_bdc_field( EXPORTING pe_fnam = 'BDC_CURSOR' pe_fval = 'LTBK-TBNUM' ).
    f_bdc_field( EXPORTING pe_fnam = 'BDC_OKCODE' pe_fval ='/00' ).
    MOVE pi_lgnum TO lv_aux.
    f_bdc_field( EXPORTING pe_fnam = 'LTBK-LGNUM' pe_fval = lv_aux ).
    MOVE pi_tbnum TO lv_aux.
    f_bdc_field( EXPORTING pe_fnam = 'LTBK-TBNUM' pe_fval = lv_aux ).

    f_bdc_dynpro( EXPORTING pe_prog = 'SAPML02B' pe_dyn = '1103').
    f_bdc_field( EXPORTING pe_fnam = 'BDC_OKCODE' pe_fval = '=DLK' ).

    f_bdc_dynpro( EXPORTING pe_prog = 'SAPLSPO1' pe_dyn = '0400').
    f_bdc_field( EXPORTING pe_fnam = 'BDC_OKCODE' pe_fval = '=YES' ).

    CALL TRANSACTION 'LB02' USING gat_bdcdata OPTIONS FROM ls_opt MESSAGES INTO lt_msg.

    LOOP AT lt_msg INTO DATA(ls_msg) WHERE msgtyp = 'E'.
      CLEAR pr_borrada.
    ENDLOOP.
    IF sy-subrc NE 0.
      pr_borrada = abap_true.

      " cvivo - Punto de verificación: identificar NTs cerradas incorrectamente
      DATA(key) = |Cierre LB02 interfaz: { sy-datum } / { sy-uzeit } / { sy-uname }|.
      LOG-POINT ID zwm_ui5 SUBKEY key FIELDS pi_tbnum.
    ENDIF.
  ENDMETHOD.
  METHOD borra_nt_abiertas.

    DATA lt_rsnum TYPE TABLE OF rsnum.
    DATA lt_rsnum_cls TYPE TABLE OF rsnum.
    DATA: lt_ltbk  TYPE gtyp_ltbk,
          lt_ltbp  TYPE gtyp_ltbp,
          ls_ltbc  TYPE ltbc,
          lv_canc  TYPE abap_bool,
          lt_ltbc  TYPE STANDARD TABLE OF ltbc,
          ls_ltbk  TYPE ltbk,
          ls_modif TYPE ltbk,
          lv_ok    TYPE abap_bool.
    DATA: ls_ecm_bobine TYPE zwm_ecm_bobine,
          zid_bob_ecm   TYPE zwm_ecm_bobine-id_bob_ecm.
    IF lv_canc IS NOT INITIAL.

      SELECT * FROM ltbp
        INTO CORRESPONDING FIELDS OF TABLE lt_ltbp
        WHERE lgnum = ga_lgnum AND
              elikz = space AND
              werks = ga_werks . "AND
* ESTABA PUESTO CHARG /    LGORT = GA_LGORT .

      IF lt_ltbp IS NOT INITIAL.
        SELECT *
          FROM ltbk
          INTO CORRESPONDING FIELDS OF TABLE lt_ltbk
          FOR ALL ENTRIES IN lt_ltbp
          WHERE lgnum EQ lt_ltbp-lgnum AND
                tbnum EQ lt_ltbp-tbnum .

      ENDIF.

    ELSE.
      " cvivo
      DATA: r_nlpla TYPE RANGE OF ltbk-nlpla.
      REFRESH r_nlpla.

      IF iv_nlpla IS NOT INITIAL.
        r_nlpla = VALUE #( sign = 'I' option = 'EQ' ( low = iv_nlpla ) ).
      ENDIF.

* seleccionamos las NT abiertas y no modificadas!!!
      SELECT *
        FROM ltbk
        INTO CORRESPONDING FIELDS OF TABLE lt_ltbk
        WHERE lgnum = ga_lgnum AND
              statu = space AND
              betyp = 'O' AND
              tbpri EQ ' ' AND
              nlpla IN r_nlpla.
* HLB 05/12/2019* NO SELECCIONAMOS A TRATAR AQUELLAS RESERVAS QUE ESTAN SIENDO TRATADAS EN PANTALLA

      LOOP AT lt_ltbk INTO ls_ltbk.
        CLEAR zid_bob_ecm.
        zid_bob_ecm(10) = ls_ltbk-rsnum.
        SELECT SINGLE * FROM zwm_ecm_bobine
          INTO  ls_ecm_bobine
           WHERE id_bob_ecm = zid_bob_ecm.
        IF sy-subrc = 0.
*          SELECT DISTINCT sgtxt FROM resb
*            INTO TABLE @DATA(lt_resb) WHERE rsnum = @ls_ltbk-rsnum.
*          LOOP AT lt_resb INTO DATA(ls_resb).
*            ls_ltbk-benum = ls_resb-sgtxt.
*            DELETE lt_ltbk WHERE benum = ls_ltbk-benum.
*          ENDLOOP.
          LOOP AT lt_ltbk INTO DATA(ls_ltbk_aux) WHERE
            rsnum = ls_ltbk-rsnum.
            me->add_nt_dat_upd( is_ltbk = CORRESPONDING #( ls_ltbk_aux ) ).
            DELETE lt_ltbk.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
* END HLB 05/12/2019

* miramos que las necesidades no sean del mismo ID de trabajo que las modificadas
      LOOP AT gat_modificadas INTO ls_modif WHERE nlpla IN r_nlpla.
        "LOOP AT lt_ltbk INTO ls_ltbk WHERE benum = ls_modif-benum. " - KYV - 20191218 - RDM
        LOOP AT lt_ltbk INTO ls_ltbk WHERE rsnum = ls_modif-rsnum. " + KYV - 20191218 - RDM
          DELETE lt_ltbk INDEX sy-tabix.
        ENDLOOP.
      ENDLOOP.

    ENDIF.

    LOOP AT lt_ltbk INTO ls_modif.
      " only delete if reservation is not confirmed
      IF ls_modif-rsnum IS NOT INITIAL.
        IF me->check_reservation( it_ltbk = lt_ltbk iv_rsnum = ls_modif-rsnum ) = abap_false.
          APPEND ls_modif-rsnum TO lt_rsnum.
        ELSE.
          "KYV / RDM - 20200214
          IF zcl_wm_nt_generic=>is_reserv_closable( iv_rsnum = ls_modif-rsnum iv_hours_to_check = ga_hours_rsnum ) = abap_true.
            APPEND ls_modif-rsnum TO lt_rsnum_cls.
          ENDIF.
          "KYV / RDM - 20200214
          CONTINUE.
        ENDIF.
      ENDIF.

      lv_ok =  borra_necesidad( EXPORTING pi_lgnum = ls_modif-lgnum
                                          pi_tbnum = ls_modif-tbnum ).

      IF lv_ok IS INITIAL. " cvivo - corrección, ponía NOT INITIAL, entiendo que se debe ejecutar cuando no ha conseguido borrar...
        REFRESH lt_ltbc.

        SELECT *
          FROM ltbp
          INTO CORRESPONDING FIELDS OF TABLE lt_ltbp
          WHERE lgnum = ls_modif-lgnum AND
                tbnum = ls_modif-tbnum.

        LOOP AT lt_ltbp ASSIGNING FIELD-SYMBOL(<ls>).
          MOVE-CORRESPONDING <ls> TO ls_ltbc.
          APPEND ls_ltbc TO lt_ltbc.
        ENDLOOP.

        IF lt_ltbc IS NOT INITIAL.
          CALL FUNCTION 'L_TR_CANCEL'
            EXPORTING
              i_save_only_all      = 'X'
*             i_update_task        =
              i_commit_work        = 'X'
            TABLES
              t_ltbc               = lt_ltbc
            EXCEPTIONS
              item_error           = 1
              no_update_item_error = 2
              no_update_no_entry   = 3
              tr_locked            = 4
              OTHERS               = 5.
          IF sy-subrc <> 0.
* Implement suitable error handling here
          ELSE.
            LOOP AT lt_ltbc INTO ls_ltbc.
              notifica_borrada( EXPORTING pi_lgnum = ls_ltbc-lgnum
                                          pi_tbnum = ls_ltbc-tbnum ).
            ENDLOOP.
          ENDIF.
        ENDIF.
      ELSE.
        notifica_borrada( EXPORTING pi_lgnum = ls_modif-lgnum
                                    pi_tbnum = ls_modif-tbnum ).
      ENDIF.
    ENDLOOP.

    " now must delete the reservation
    SORT lt_rsnum.
    DELETE ADJACENT DUPLICATES FROM lt_rsnum COMPARING ALL FIELDS.
    LOOP AT lt_rsnum INTO DATA(lv_rsnum).
      me->delete_reservation( iv_rsnum = lv_rsnum ).
    ENDLOOP.

    " KYV - 20200214 - close rsnum
    SORT lt_rsnum_cls.
    DELETE ADJACENT DUPLICATES FROM lt_rsnum_cls COMPARING ALL FIELDS.
    LOOP AT lt_rsnum_cls INTO lv_rsnum.
      zcl_wm_nt_generic=>change_reserv_4_cons(
        EXPORTING
*          iv_bobine =
*          is_ltbk   =
*          iv_qty    =
*          iv_meins  =
          iv_rsnum  = lv_rsnum
          iv_close  = abap_true
      ).
    ENDLOOP.
    " KYV - 20200214 - close rsnum
  ENDMETHOD.
  METHOD borra_nt_no_modificadas.

    DATA lt_rsnum TYPE TABLE OF rsnum.
    DATA lt_rsnum_cls TYPE TABLE OF rsnum.
    DATA: lt_ltbk  TYPE gtyp_ltbk,
          lt_ltbp  TYPE gtyp_ltbp,
          ls_ltbc  TYPE ltbc,
          lv_canc  TYPE abap_bool,
          lt_ltbc  TYPE STANDARD TABLE OF ltbc,
          ls_ltbk  TYPE ltbk,
          ls_modif TYPE ltbk,
          lv_ok    TYPE abap_bool.
    DATA: ls_ecm_bobine TYPE zwm_ecm_bobine,
          zid_bob_ecm   TYPE zwm_ecm_bobine-id_bob_ecm.
    DATA: lt_item  TYPE TABLE OF bapi2093_res_item_change WITH DEFAULT KEY,
          lt_itemx TYPE TABLE OF bapi2093_res_item_changex WITH DEFAULT KEY,
          lt_ret   TYPE TABLE OF bapiret2.

    DATA(vl_condition) = |LG{ ga_lgnum } = 'X'|.

    SELECT SINGLE *
    INTO @DATA(w_func)
      FROM zwm_rf_func
      WHERE (vl_condition)
        AND func EQ 'INTERFAZ_NO_BORRAR_NTS'.

    IF sy-subrc EQ 0. " 65400 - borraremos sólo las anteriores a la fecha actual - 1h -> new, cvivo 68730: no borraremos NTS
      DATA: r_pdatu TYPE RANGE OF ltbk-pdatu,
            r_pzeit TYPE RANGE OF ltbk-pzeit.

*      CALL FUNCTION 'C14B_ADD_TIME'
*        EXPORTING
*          i_starttime = sy-uzeit
*          i_startdate = sy-datum
*          i_addtime   = -1
*        IMPORTING
*          e_endtime   = ls_ltbk-pzeit
*          e_enddate   = ls_ltbk-pdatu.
*
*      r_pdatu = value #( sign = 'I' option = 'GT' ( low = ls_ltbk-pdatu ) ).
*      r_pzeit = value #( sign = 'I' option = 'GT' ( low = ls_ltbk-pzeit ) ).

      " 68730 - cvivo - en HPX no hay consumos, debemos evitar borrar las NTs para no perder la trazabilidad
      EXIT.
    ENDIF.

* seleccionamos las NT abiertas y no modificadas!!!
    SELECT *
      FROM ltbk
      INTO CORRESPONDING FIELDS OF TABLE lt_ltbk
      WHERE lgnum = ga_lgnum AND
            statu = space AND
            betyp = 'O' AND
            pdatu IN r_pdatu AND
            pzeit IN r_pzeit AND
            nlpla IN tg_lgpla_borrar_nts. "JCB 30.03.23. Seleccionar ubicaciones a tratar
*            tbpri EQ ' '.
* HLB 05/12/2019* NO SELECCIONAMOS A TRATAR AQUELLAS RESERVAS QUE ESTAN SIENDO TRATADAS EN PANTALLA





    LOOP AT lt_ltbk INTO ls_ltbk.
      CLEAR zid_bob_ecm.
      zid_bob_ecm(10) = ls_ltbk-rsnum.
      SELECT SINGLE * FROM zwm_ecm_bobine
        INTO  ls_ecm_bobine
         WHERE id_bob_ecm = zid_bob_ecm.
      IF sy-subrc = 0.
*          SELECT DISTINCT sgtxt FROM resb
*            INTO TABLE @DATA(lt_resb) WHERE rsnum = @ls_ltbk-rsnum.
*          LOOP AT lt_resb INTO DATA(ls_resb).
*            ls_ltbk-benum = ls_resb-sgtxt.
*            DELETE lt_ltbk WHERE benum = ls_ltbk-benum.
*          ENDLOOP.
        LOOP AT lt_ltbk INTO DATA(ls_ltbk_aux) WHERE
          rsnum = ls_ltbk-rsnum.
          me->add_nt_dat_upd( is_ltbk = CORRESPONDING #( ls_ltbk_aux ) ).
          DELETE lt_ltbk.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
* END HLB 05/12/2019


    "JCB 07.02.22. No tratar necesidades de transporte que se generen desde los partes de rebobinado
    IF lt_ltbk IS NOT INITIAL.
      SELECT werks, tbnum
        INTO TABLE @DATA(tl_partes_reb_bp)
        FROM zwm_parte_reb_bp
        FOR ALL ENTRIES IN @lt_ltbk
        WHERE werks = @ga_werks AND
              tbnum = @lt_ltbk-tbnum.
      LOOP AT lt_ltbk ASSIGNING FIELD-SYMBOL(<fs_ltbk>).
        READ TABLE tl_partes_reb_bp TRANSPORTING NO FIELDS WITH KEY tbnum = <fs_ltbk>-tbnum.
        IF sy-subrc = 0.
          DELETE lt_ltbk.
        ENDIF.
      ENDLOOP.
    ENDIF.
    "FIN JCB 07.02.22. No tratar necesidades de transporte que se generen desde los partes de rebobinado



* miramos que las necesidades no sean del mismo ID de trabajo que las modificadas
    LOOP AT gat_modificadas INTO ls_modif.
      "LOOP AT lt_ltbk INTO ls_ltbk WHERE benum = ls_modif-benum. " - KYV - 20191218 - RDM
*      LOOP AT lt_ltbk INTO ls_ltbk WHERE rsnum = ls_modif-rsnum. " + KYV - 20191218 - RDM -> DEL - cvivo - En el modelo incremental,
      " si desaparece una de las NTs de una reserva, se debe borrar esa NT,
      " si controlamos por reserva, ésa se nos cuela
      LOOP AT lt_ltbk INTO ls_ltbk WHERE tbnum = ls_modif-tbnum. " INS - cvivo
        DELETE lt_ltbk INDEX sy-tabix.
      ENDLOOP.
    ENDLOOP.

    LOOP AT lt_ltbk INTO ls_modif.
      " only delete if reservation is not confirmed
      IF ls_modif-rsnum IS NOT INITIAL.
        IF me->check_reservation( it_ltbk = lt_ltbk iv_rsnum = ls_modif-rsnum ) = abap_false.
          APPEND ls_modif-rsnum TO lt_rsnum.
        ELSE.
          "KYV / RDM - 20200214
          IF zcl_wm_nt_generic=>is_reserv_closable( iv_rsnum = ls_modif-rsnum iv_hours_to_check = ga_hours_rsnum ) = abap_true.
            APPEND ls_modif-rsnum TO lt_rsnum_cls.
          ELSE. " INS - cvivo - si no vamos a borrar toda la reserva, al menos borramos la posición
            SELECT SINGLE rspos
              FROM resb INTO @DATA(lv_rspos)
              WHERE rsnum EQ @ls_modif-rsnum
                AND sgtxt EQ @ls_modif-benum.

            IF sy-subrc EQ 0.
              APPEND VALUE bapi2093_res_item_change( res_item = lv_rspos withdrawn = abap_true
              )  TO lt_item.

              APPEND VALUE bapi2093_res_item_changex( res_item = lv_rspos withdrawn = abap_true )
              TO lt_itemx.

              CALL FUNCTION 'BAPI_RESERVATION_CHANGE'
                EXPORTING
                  reservation               = ls_modif-rsnum
                TABLES
                  reservationitems_changed  = lt_item
                  reservationitems_changedx = lt_itemx
                  return                    = lt_ret.

              LOOP AT lt_ret TRANSPORTING NO FIELDS WHERE type CA 'XAE'.
                CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
              ENDLOOP.
              IF sy-subrc NE 0.
                CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
                  EXPORTING
                    wait = abap_true.
              ENDIF.
            ENDIF.
          ENDIF.
          "KYV / RDM - 20200214
*          CONTINUE. " DEL - cvivo - No saltamos la línea nunca, si está en la IT es porque se tiene que borrar la NT
        ENDIF.
      ENDIF.

      lv_ok =  borra_necesidad( EXPORTING pi_lgnum = ls_modif-lgnum
                                          pi_tbnum = ls_modif-tbnum ).

      IF lv_ok IS INITIAL. " cvivo - corrección, ponía NOT INITIAL, entiendo que se debe ejecutar cuando no ha conseguido borrar...
        REFRESH lt_ltbc.

        SELECT *
          FROM ltbp
          INTO CORRESPONDING FIELDS OF TABLE lt_ltbp
          WHERE lgnum = ls_modif-lgnum AND
                tbnum = ls_modif-tbnum.

        LOOP AT lt_ltbp ASSIGNING FIELD-SYMBOL(<ls>).
          MOVE-CORRESPONDING <ls> TO ls_ltbc.
          APPEND ls_ltbc TO lt_ltbc.
        ENDLOOP.

        IF lt_ltbc IS NOT INITIAL.
          CALL FUNCTION 'L_TR_CANCEL'
            EXPORTING
              i_save_only_all      = 'X'
*             i_update_task        =
              i_commit_work        = 'X'
            TABLES
              t_ltbc               = lt_ltbc
            EXCEPTIONS
              item_error           = 1
              no_update_item_error = 2
              no_update_no_entry   = 3
              tr_locked            = 4
              OTHERS               = 5.
          IF sy-subrc <> 0.
* Implement suitable error handling here
          ELSE.
            " cvivo - Punto de verificación: identificar NTs cerradas incorrectamente
            DATA(key) = |Cierre TR_CANCEL interfaz: { sy-datum } / { sy-uzeit } / { sy-uname }|.
            LOG-POINT ID zwm_ui5 SUBKEY key FIELDS lt_ltbc.

            LOOP AT lt_ltbc INTO ls_ltbc.
              notifica_borrada( EXPORTING pi_lgnum = ls_ltbc-lgnum
                                          pi_tbnum = ls_ltbc-tbnum ).
            ENDLOOP.
          ENDIF.
        ENDIF.
      ELSE.
        notifica_borrada( EXPORTING pi_lgnum = ls_modif-lgnum
                                    pi_tbnum = ls_modif-tbnum ).
      ENDIF.
    ENDLOOP.

    " now must delete the reservation
    SORT lt_rsnum.
    DELETE ADJACENT DUPLICATES FROM lt_rsnum COMPARING ALL FIELDS.
    LOOP AT lt_rsnum INTO DATA(lv_rsnum).
      me->delete_reservation( iv_rsnum = lv_rsnum ).
    ENDLOOP.

    " KYV - 20200214 - close rsnum
    SORT lt_rsnum_cls.
    DELETE ADJACENT DUPLICATES FROM lt_rsnum_cls COMPARING ALL FIELDS.
    LOOP AT lt_rsnum_cls INTO lv_rsnum.
      zcl_wm_nt_generic=>change_reserv_4_cons(
        EXPORTING
*          iv_bobine =
*          is_ltbk   =
*          iv_qty    =
*          iv_meins  =
          iv_rsnum  = lv_rsnum
          iv_close  = abap_true
      ).
    ENDLOOP.
    " KYV - 20200214 - close rsnum
  ENDMETHOD.
  METHOD carga_nt_modificadas.

    DATA: lt_ltbk  TYPE gtyp_ltbk,
          ls_ltbk  TYPE ltbk,
          lv_rsnum TYPE resb-rsnum.

* seleccionamos las NT abiertas y no modificadas!!!
    SELECT *
      FROM ltbk
      INTO CORRESPONDING FIELDS OF TABLE lt_ltbk
      WHERE lgnum = ga_lgnum AND
            statu NE space AND
            betyp = 'O'
            AND rsnum <> lv_rsnum." + KYV - 20191218 - RDM
* HAY QUE AÑADIR UNA FRANJA TEMPORAL EN ESTA SELECCIÓN PARA EVITAR GRANDES VOLÚMENES EN EL FUTURO.
* HLB 09/12/2019 NO SELECCIONABA MODIFICADAS POR STATUS CONTRADICTORIO
*            betyp = 'O' AND
*            ( statu NE ' ' OR  " SI SE HA TRATADO LA NT 919
*            tbpri NE ' ' ). " SI SE HA AJUSTADO CON MATERIAL DIFERENTE
* FIN HLB 09/12/2019 NO SELECCIONABA MODIFICADAS POR STATUS CONTRADICTORIO

    IF lt_ltbk[] IS NOT INITIAL.
      SELECT *
      FROM ltbk
      APPENDING TABLE lt_ltbk
      FOR ALL ENTRIES IN lt_ltbk
      WHERE lgnum = lt_ltbk-lgnum AND
            "benum = lt_ltbk-benum. " - KYV - 20191218 - RDM
            rsnum = lt_ltbk-rsnum. " + KYV - 20191218 - RDM
    ENDIF.

    LOOP AT lt_ltbk INTO ls_ltbk.

      " RDM - 20191211 - store for date update BEG
      IF ls_ltbk-statu = 'T'.
        me->add_nt_dat_upd( is_ltbk = CORRESPONDING #( ls_ltbk ) ).
        notifica_modificada( EXPORTING pi_ltbk = ls_ltbk ). " RDM - 20200522
      ENDIF.
      " RDM - 20191211 - END
      "notifica_modificada( EXPORTING pi_ltbk = ls_ltbk ).  " RDM - 20200522


    ENDLOOP.

  ENDMETHOD.
  METHOD check_material_exists.
    DATA: lv_matnr         LIKE iv_matnr,
          number           TYPE tbtcjob-jobcount,
          name             TYPE tbtcjob-jobname VALUE 'CREAR_MATERIAL_REPLENISHMENT',
          print_parameters TYPE pri_params.

    IF iv_matnr CO '0'. " comprobar que el material viene relleno
      RAISE material_vacio.
    ENDIF.

    CHECK iv_werks IS NOT INITIAL.

    SELECT SINGLE mara~matnr FROM mara
    INNER JOIN marc
    ON mara~matnr = marc~matnr
    INNER JOIN mard
    ON mara~matnr = mard~matnr
    AND marc~werks = mard~werks
    INTO lv_matnr
    WHERE mara~matnr EQ iv_matnr
    AND marc~werks = iv_werks
    AND mard~lgort = '1000' .

    IF sy-subrc NE 0.
      CALL FUNCTION 'JOB_OPEN'
        EXPORTING
          jobname          = name
        IMPORTING
          jobcount         = number
        EXCEPTIONS
          cant_create_job  = 1
          invalid_job_data = 2
          jobname_missing  = 3
          OTHERS           = 4.
      IF sy-subrc = 0.
        SUBMIT zrmm0022 WITH p_matnr EQ space " creación sin código material
        WITH p_werks EQ iv_werks
        WITH p_matnr EQ 'X'
        WITH s_matnr EQ iv_matnr
        WITH p_fondo EQ 'X'
        TO SAP-SPOOL
        SPOOL PARAMETERS print_parameters
        WITHOUT SPOOL DYNPRO
        VIA JOB name NUMBER number
        AND RETURN.

        IF sy-subrc = 0.
          CALL FUNCTION 'JOB_CLOSE'
            EXPORTING
              jobcount             = number
              jobname              = name
              strtimmed            = 'X'
            EXCEPTIONS
              cant_start_immediate = 1
              invalid_startdate    = 2
              jobname_missing      = 3
              job_close_failed     = 4
              job_nosteps          = 5
              job_notex            = 6
              lock_failed          = 7
              OTHERS               = 8.

          WAIT UP TO 3 SECONDS.
        ENDIF.
      ENDIF.

      SELECT SINGLE mara~matnr FROM mara " volvemos a intentarlo
      INNER JOIN marc
      ON mara~matnr = marc~matnr
      INNER JOIN mard
      ON mara~matnr = mard~matnr
      AND marc~werks = mard~werks
      INTO lv_matnr
      WHERE mara~matnr EQ iv_matnr
      AND marc~werks = iv_werks
      AND mard~lgort = '1000' .

      IF sy-subrc NE 0.
        RAISE error_creacion.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD check_reservation.
    rv_conf = abap_false.

    DATA(ls_ltbk) = it_ltbk[ 1 ].
    SELECT lgnum, tbnum
    FROM ltbk
    INTO TABLE @DATA(lt_ltbk)
    WHERE lgnum = @ls_ltbk-lgnum
    AND rsnum = @iv_rsnum.

    LOOP AT lt_ltbk INTO DATA(ls_ltbk_key).
      CHECK NOT line_exists( it_ltbk[ lgnum = ls_ltbk_key-lgnum tbnum = ls_ltbk_key-tbnum ] ).
      rv_conf = abap_true.
      EXIT.
    ENDLOOP.


  ENDMETHOD.
  METHOD close_reservation.
    DATA lv_end_date TYPE datum.
    DATA lv_end_time TYPE uzeit.

    DATA(lv_init_time) = ga_hours_rsnum.

    CHECK lv_init_time IS NOT INITIAL.

    SELECT a~rsnum, MAX( b~bdatu ) AS last_date, MAX( b~bzeit ) AS last_time
      FROM resb AS a
      INNER JOIN ltbk AS b
      ON a~rsnum = b~rsnum
      INTO TABLE @DATA(lt_resb)
      WHERE b~statu = 'E'
      AND a~kzear = @abap_false
      AND a~werks = @ga_werks
      AND b~lgnum = @ga_lgnum
      AND NOT EXISTS ( SELECT tbnum FROM ltbk WHERE rsnum = a~rsnum AND statu <> 'E' AND lgnum = @ga_lgnum )
      GROUP BY a~rsnum, a~rspos.

    CHECK sy-subrc = 0.


    "JCB 07.02.22. No tratar reservas que se generen desde los partes de rebobinado
    IF lt_resb IS NOT INITIAL.
      SELECT werks, rsnum
        INTO TABLE @DATA(tl_partes_reb_c)
        FROM zwm_parte_reb_c
        FOR ALL ENTRIES IN @lt_resb
        WHERE werks = @ga_werks AND
              rsnum = @lt_resb-rsnum.
      LOOP AT lt_resb ASSIGNING FIELD-SYMBOL(<fs_resb>).
        READ TABLE tl_partes_reb_c TRANSPORTING NO FIELDS WITH KEY rsnum = <fs_resb>-rsnum.
        IF sy-subrc = 0.
          DELETE lt_resb.
        ENDIF.
      ENDLOOP.
    ENDIF.
    "FIN JCB 07.02.22. No tratar reservas que se generen desde los partes de rebobinado


    LOOP AT lt_resb INTO DATA(ls_resb).
      DO.
        DATA(lv_uzeit) = COND t( WHEN lv_init_time > '240000' THEN '240000' ELSE lv_init_time ).
        lv_init_time = lv_init_time - lv_uzeit.
        ls_resb-last_time = COND #( WHEN lv_end_time IS INITIAL THEN ls_resb-last_time ELSE lv_end_time ).
        ls_resb-last_date = COND #( WHEN lv_end_date IS INITIAL THEN ls_resb-last_date ELSE lv_end_date ).

        CALL FUNCTION 'C14B_ADD_TIME'
          EXPORTING
            i_starttime = ls_resb-last_time
            i_startdate = ls_resb-last_date
            i_addtime   = lv_uzeit
          IMPORTING
            e_endtime   = lv_end_time
            e_enddate   = lv_end_date.

        IF lv_init_time IS INITIAL.
          EXIT.
        ENDIF.

      ENDDO.

      CHECK: lv_end_date < sy-datum OR ( lv_end_date = sy-datum AND lv_end_time <= sy-uzeit ).

      zcl_wm_nt_generic=>change_reserv_4_cons(
        EXPORTING
*          iv_bobine =
*          is_ltbk   =
*          iv_qty    =
*          iv_meins  =
          iv_rsnum  = ls_resb-rsnum
          iv_close  = abap_true
      ).


    ENDLOOP.


  ENDMETHOD.
  METHOD crear_nts.
    DATA: lt_ltba TYPE STANDARD TABLE OF ltba,
          ls_ltba TYPE ltba,
          ls_ltbk TYPE ltbk,
          ls_ltbp TYPE ltbp,
          lv_mess TYPE bapi_msg,
          ls_ret  TYPE bapiret2.

    IF it_ltba IS NOT SUPPLIED.
      READ TABLE pt_ltbk INTO ls_ltbk INDEX 1.
      IF sy-subrc EQ 0.
        MOVE-CORRESPONDING ls_ltbk TO ls_ltba.

        LOOP AT pt_ltbp INTO ls_ltbp.
          MOVE-CORRESPONDING ls_ltbp TO ls_ltba.
          ls_ltba-menga = ls_ltbp-menge.
          ls_ltba-altme = ls_ltbp-meins.
          ls_ltba-lgort = ga_lgort.
          ls_ltba-bwlvs = ga_bwart.
          ls_ltba-nlpla = ls_ltbk-nlpla.
          ls_ltba-betyp = 'O'.
          APPEND ls_ltba TO lt_ltba.
        ENDLOOP.

      ENDIF.
    ELSE.
      lt_ltba = it_ltba.
    ENDIF.

    IF iv_store_only = abap_true.
      me->store_ltba( it_ltba = lt_ltba iv_idx = pi_index  iv_fsc = iv_fsc ).
      sy-subrc = 0.
      RETURN.
    ENDIF.

    CALL FUNCTION 'L_TR_CREATE'
      EXPORTING
        i_single_item         = 'X'
        i_save_only_all       = 'X'
*       I_UPDATE_TASK         =
        i_commit_work         = 'X'
      TABLES
        t_ltba                = lt_ltba
      EXCEPTIONS
        item_error            = 1
        no_entry_in_int_table = 2
        item_without_number   = 3
        no_update_item_error  = 4
        OTHERS                = 5.

    IF sy-subrc <> 0.

      LOOP AT lt_ltba INTO ls_ltba.
        CALL FUNCTION 'BAPI_MESSAGE_GETDETAIL'
          EXPORTING
            id         = ls_ltba-msgid
            number     = ls_ltba-msgno
            language   = sy-langu
            textformat = 'RTF'
            message_v1 = ls_ltba-msgv1
            message_v2 = ls_ltba-msgv2
            message_v3 = ls_ltba-msgv3
            message_v4 = ls_ltba-msgv4
          IMPORTING
            message    = lv_mess.

        CONCATENATE pc_ko lv_mess ls_ltba-lgnum ls_ltba-nlpla INTO pc_ko SEPARATED BY space.
        gav_hay_error = abap_true.
      ENDLOOP.

    ELSE.

      LOOP AT lt_ltba INTO ls_ltba WHERE tbnum IS NOT INITIAL.
        pc_ok = ls_ltba-tbnum.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD create_reservation.
    DATA ls_log      TYPE treg_log.
    DATA lt_item TYPE zcl_wm_constants=>gtty_res_item.

    DATA ls_ltba_kg TYPE ltba.
    DATA lt_ret TYPE bapiret2_tab.
    DATA nlpla TYPE ltbk-nlpla.

    " 1st just change the dates for the nt's not deleted
*    me->adjust_nt_date( ). " lo pasamos a gestión por ubicación
    DATA(lt_ltba) = me->get_ltba( ).

    " must group ltba values
    DATA(lt_ltba_grp) = zcl_wm_nt_generic=>get_instance(
*        iv_langu = SY-LANGU
    )->group_ltba( it_ltba = lt_ltba  ).

    LOOP AT lt_ltba_grp ASSIGNING FIELD-SYMBOL(<group>).
      DATA(index_group) = sy-tabix.
      DATA(crear_grupo) = abap_false.

      " aquí buscamos si alguna agrupación no tiene la misma reserva,
      "en cuyo caso forzamos borrado y creación al quitarlas de modificadas
      LOOP AT <group>-it_ltba_idx ASSIGNING FIELD-SYMBOL(<idx>) WHERE rsnum NE <group>-rsnum.
        " si entro es porque no todas tienen la misma reserva -> sy-subrc 0
        crear_grupo = abap_true.
      ENDLOOP.

      "aquí buscamos si esta reserva está en alguna otra agrupación, en cuyo caso ambas deben borrarse y crearse de nuevo para separar la reserva
      LOOP AT lt_ltba_grp INTO DATA(create) WHERE rsnum EQ <group>-rsnum
                                             AND idx NE <group>-idx.
        crear_grupo = abap_true.
      ENDLOOP.

      " aquí buscamos que no sean necesidades que ya existen del fichero y por tanto no hay que volver a crear
      DATA(tl_gat_modificadas) = gat_modificadas.
      IF ga_cla_nemesis = space.
        LOOP AT tl_gat_modificadas ASSIGNING FIELD-SYMBOL(<fs_gat_modificadas>).
          <fs_gat_modificadas>-benum = zcl_wm_nt_generic=>convert_benum_omp_internal( vp_gjahr  =  <fs_gat_modificadas>-bdatu(4)
                                                                                      vp_input  =  <fs_gat_modificadas>-benum ).
        ENDLOOP.
      ENDIF.


      LOOP AT <group>-it_ltba_idx ASSIGNING <idx>.
        DATA(index_idx) = sy-tabix.
        LOOP AT <idx>-it_ltba INTO DATA(check).
          DATA(index_check) = sy-tabix.
          READ TABLE tl_gat_modificadas WITH KEY benum = check-benum nlpla = check-nlpla INTO DATA(modif).
          DATA(idx_gat_modif) = sy-tabix.
          IF sy-subrc EQ 0.
            IF crear_grupo EQ abap_true.
              DELETE tl_gat_modificadas INDEX idx_gat_modif.
              DELETE gat_modificadas INDEX idx_gat_modif.
              CLEAR <idx>-rsnum. " para no recicle la reserva al crearla después
            ELSE.
              DELETE <idx>-it_ltba INDEX index_check.
              <group>-rsnum = modif-rsnum. " he recuperado el rsnum original
            ENDIF.
          ENDIF.
        ENDLOOP.
        IF lines( <idx>-it_ltba ) = 0.
          DELETE <group>-it_ltba_idx INDEX index_idx.
        ENDIF.
        CLEAR <group>-rsnum. " para no recicle la reserva al crearla después
      ENDLOOP.
      IF lines( <group>-it_ltba_idx ) = 0.
        DELETE lt_ltba_grp INDEX index_group.
      ENDIF.
    ENDLOOP.

    SORT lt_ltba_grp BY nlpla. " cvivo, para borrar y crear por cada ubicación

    " cvivo  -  borramos las no modificadas, luego actualizamos fecha de las pendientes, finalmente agruparemos con todas (las modificas y las nuevas),
    "       , luego quitaremos de esa agrupación las modificadas, para que queden sólo las nuevas y éstas queden en referencia an las modificadas que ya existen,
    "       , para conservar el rsnum en agrupaciones
    " lo he movido aquí porque si no, si forzamos en el loop anterior la creación de algo, no borra la anterior

    borra_nt_no_modificadas( ).
    close_reservation( ).
    adjust_nt_date( ). " ahora hay que modificar fecha+hora de las que estaban tratadas

    CLEAR rv_rsnum.

    " for each line, create a reservation
    LOOP AT lt_ltba_grp INTO DATA(ls_grp).
      IF nlpla NE ls_grp-nlpla. " cambio de ubicación
        nlpla = ls_grp-nlpla.

*        me->adjust_nt_date( iv_nlpla = nlpla ). " aquí buscamos las que existen en el fichero (benum+nlpla) y actualizamos fecha
*        borra_nt_abiertas( iv_nlpla = nlpla ). " debo sustituirlo por un borrado general, al final, de los benum+nlpla que no encuentre en el fichero
*        close_reservation( iv_nlpla = nlpla ).
      ENDIF.

      CLEAR lt_item.
      LOOP AT ls_grp-it_ltba_idx INTO DATA(ls_ltba_idx).
        LOOP AT ls_ltba_idx-it_ltba INTO DATA(ls_ltba).
          ls_ltba_kg = ls_ltba.
          ls_ltba_kg-altme = 'KG'.

          IF NOT o_log IS INITIAL.
            DATA(l_kg) = zcl_ap_material=>convertir_unidad( matnr = ls_ltba_kg-matnr
                                                            unidad_origen = ls_ltba-altme
                                                            unidad_destino = ls_ltba_kg-altme
                                                            cantidad = 1000 ).
            IF l_kg IS INITIAL.
              o_log->log( msgty = 'E'
                         message  = |Material { ls_ltba_kg-matnr ALPHA = OUT } no tiene conversión { ls_ltba-altme } / { ls_ltba_kg-altme }|
                         msgv1    = ls_ltba_kg-matnr ).
            ENDIF.
          ENDIF.

          " must convert to KG
          CALL FUNCTION 'MATERIAL_CONVERT_QUANTITY'
            EXPORTING
              pi_material_src    = ls_ltba_kg-matnr   " Source Material
              pi_meinh_src       = ls_ltba-altme
*             pi_meins_src       =
              pi_quantity_src    = ls_ltba-menga
              pi_material_dst    = ls_ltba_kg-matnr   " Target Material
              pi_meinh_dst       = ls_ltba_kg-altme
*             pi_meins_dst       =
            IMPORTING
              pe_quantity_dst    = ls_ltba_kg-menga
*             pe_meinh_dst       =
*             pe_meins_dst       =
            EXCEPTIONS
              wrong_call         = 1
              material_not_found = 2
              no_conversion      = 3
              OTHERS             = 4.
          APPEND VALUE #(
          material = ls_ltba-matnr
          plant = ls_ltba-werks
          stge_loc = ls_ltba-lgort
          entry_qnt = ls_ltba_kg-menga
          entry_uom = ls_ltba_kg-altme
          movement = abap_true
          item_text = ls_ltba-benum
          ) TO lt_item.
        ENDLOOP.
      ENDLOOP.

      IF ls_grp-rsnum IS INITIAL. " si no hay reserva anterior por se un grupo con NTs modificadas
        zcl_wm_nt_generic=>create_reserv(
          EXPORTING
            is_header = VALUE #( move_type = zcl_wm_constants=>gc_bwart_291 orderid = ga_aufnr res_date = sy-datum )
            it_item   = lt_item
*            iv_commit = ABAP_TRUE
          IMPORTING
            es_rsnum  = ls_grp-rsnum
            et_ret    = lt_ret
        ).

        IF NOT o_log IS INITIAL.
          IF ls_grp-rsnum IS INITIAL.
            ASSIGN lt_ret[ type = 'E' ] TO FIELD-SYMBOL(<ret>).
            IF sy-subrc = 0.
              o_log->log( msgty = 'E'
                         message  = |Error creando reserva { <ret>-message }| ).
            ENDIF.
          ELSE.
            o_log->log( msgty = 'S'
                       message  = |Se ha crado reserva { ls_grp-rsnum  ALPHA = OUT }| ).
          ENDIF.
        ENDIF.
      ENDIF.
      " KYV - RDM - 20200220 - LOG BEG
      CLEAR ls_log.

      DATA(vl_pos_idx) = strlen( ls_grp-nlpla ) - 1.
      DATA(lv_nlpla_idx) = ls_grp-nlpla+vl_pos_idx(1).
      DATA(lv_ok) = 'OK_' && lv_nlpla_idx.
      DATA(lv_nok) = 'KO_' && lv_nlpla_idx.
      DATA(lv_menge) = 'MENGE_' && lv_nlpla_idx.
      DATA(lv_matnr) = 'MATNR_' && lv_nlpla_idx.
      ASSIGN COMPONENT lv_ok OF STRUCTURE ls_log TO FIELD-SYMBOL(<fs_ok>).
      ASSIGN COMPONENT lv_nok OF STRUCTURE ls_log TO FIELD-SYMBOL(<fs_nok>).
      ASSIGN COMPONENT lv_matnr OF STRUCTURE ls_log TO FIELD-SYMBOL(<fs_matnr>).
      ASSIGN COMPONENT lv_menge OF STRUCTURE ls_log TO FIELD-SYMBOL(<fs_menge>).
      <fs_matnr> = ls_grp-matnr.
      <fs_menge> = lt_item[ 1 ]-entry_qnt.
      ls_log-cinumber = lt_item[ 1 ]-item_text.
      IF ls_grp-rsnum IS INITIAL.
        <fs_nok> = |{ text-020 } { ls_grp-nlpla } { ls_grp-matnr }|.
        APPEND ls_log TO gat_log.
        LOOP AT lt_ret INTO DATA(ls_ret) WHERE type CA 'XAE'.
          <fs_nok> = ls_ret-message.
          APPEND ls_log TO gat_log.
        ENDLOOP.

        gav_hay_error = abap_true.

        CONTINUE.
      ELSE.
        <fs_ok> = ls_grp-rsnum . "|{ text-021 } { ls_grp-rsnum } { ls_grp-nlpla } { ls_grp-matnr }|.
        APPEND ls_log TO gat_log.
      ENDIF.

*      IF ls_grp-rsnum IS INITIAL.
*        CONTINUE.
*      ENDIF.
      " KYV - RDM - 20200220 - LOG END

      MODIFY lt_ltba_grp FROM ls_grp
      TRANSPORTING rsnum.

      " now create nt's
      LOOP AT ls_grp-it_ltba_idx INTO ls_ltba_idx.
        DATA(lv_idx) = sy-tabix.
        CLEAR ls_log.
        ls_ltba-rsnum = ls_grp-rsnum.
        MODIFY ls_ltba_idx-it_ltba
        FROM ls_ltba
        TRANSPORTING rsnum
        WHERE nlpla IS NOT INITIAL.

        " set rspos
        LOOP AT ls_ltba_idx-it_ltba ASSIGNING FIELD-SYMBOL(<fs_ltba_idx>).
          <fs_ltba_idx>-rspos = lv_idx.
        ENDLOOP.


        " KYV - RDM - 20200220 - LOG BEG
        CHECK sy-subrc = 0.
        CLEAR ls_log.


        vl_pos_idx    = strlen( ls_ltba_idx-it_ltba[ 1 ]-nlpla ) - 1.
        lv_nlpla_idx  = ls_ltba_idx-it_ltba[ 1 ]-nlpla+vl_pos_idx(1).
        lv_ok = 'OK_' && lv_nlpla_idx.
        lv_nok = 'KO_' && lv_nlpla_idx.
        lv_menge = 'MENGE_' && lv_nlpla_idx.
        lv_matnr = 'MATNR_' && lv_nlpla_idx.
        ASSIGN COMPONENT lv_ok OF STRUCTURE ls_log TO <fs_ok>.
        ASSIGN COMPONENT lv_nok OF STRUCTURE ls_log TO <fs_nok>.
        ASSIGN COMPONENT lv_matnr OF STRUCTURE ls_log TO <fs_matnr>.
        ASSIGN COMPONENT lv_menge OF STRUCTURE ls_log TO <fs_menge>.
        <fs_matnr> = ls_ltba_idx-it_ltba[ 1 ]-matnr.
        <fs_menge> = ls_ltba_idx-it_ltba[ 1 ]-menga.
        ls_log-cinumber = ls_ltba_idx-it_ltba[ 1 ]-benum. "KYV/RDM - 20200526
        " KYV - RDM - 20200220 - LOG END
        me->crear_nts(
          EXPORTING
            pi_index      =  ls_ltba_idx-idx   " ABAP System Field: Loop Index
            iv_store_only = abap_false
            it_ltba       = ls_ltba_idx-it_ltba
        CHANGING
*            pc_ok = ls_log-ok_1
*            pc_ko = ls_log-ko_1   " Message Text
            pc_ok = <fs_ok>
            pc_ko = <fs_nok>   " Message Text
        ).
        " KYV - RDM - 20200220 - LOG - BEG
        IF <fs_nok> IS NOT INITIAL.
          gav_hay_error = abap_true.
        ENDIF.
        APPEND ls_log TO gat_log.
        " KYV - RDM - 20200220 - LOG - BEG
      ENDLOOP.
    ENDLOOP.





  ENDMETHOD.
  METHOD dame_hardcodes.
    DATA: lt_hard TYPE STANDARD TABLE OF ztwm001.

    SELECT *
      FROM ztwm001
      INTO CORRESPONDING FIELDS OF TABLE lt_hard
      WHERE cprog = vp_cprog.

    LOOP AT lt_hard ASSIGNING FIELD-SYMBOL(<h>).
      IF <h>-param1 = 'BWART' AND <h>-param2 = '01'.
        ga_bwart = <h>-valor1.
      ELSEIF <h>-param1 = 'LGORT' AND <h>-param2 = '01'.
        ga_lgort = <h>-valor1.
      ELSEIF <h>-param1 = 'WERKS'  AND <h>-param2 = '01'.
        ga_werks = <h>-valor1 .
      ELSEIF <h>-param1 = 'LGNUM'  AND <h>-param2 = '01'.
        ga_lgnum = <h>-valor1.
      ELSEIF <h>-param1 = 'NLPLA'.
        DATA(lv_field) = 'GA_NLPLA' && <h>-param2.
        ASSIGN (lv_field) TO FIELD-SYMBOL(<fs_nlpla>).
        CHECK sy-subrc = 0.
        <fs_nlpla> = <h>-valor1.
      ELSEIF <h>-param1 = 'AUFNR'  AND <h>-param2 = '01'.
        ga_aufnr = <h>-valor1.
      ELSEIF <h>-param1 =  'HOURS_FOR_RSNUM_CLOSE'  AND <h>-param2 = '01'.
        ga_hours_rsnum(2) = <h>-valor1.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD DAME_MATERIAL.
    DATA: lt_str           TYPE TABLE OF string,
          lv_str           TYPE string,
          lv_matnr         TYPE matnr,
          lv_cal(3),
          lv_grama         TYPE zgramaje,
          lv_ancho         TYPE zancho,
          lv_val_ext       TYPE zedpi0005,
          lv_valor_sap     TYPE zedpi0004,
          lv_matkl         TYPE matkl,
          lv_mtart         TYPE mtart,
          lt_mara          TYPE STANDARD TABLE OF mara,
          number           TYPE tbtcjob-jobcount,
          name             TYPE tbtcjob-jobname VALUE 'CREAR_MATERIAL_OMP_REPLENISHMENT',
          print_parameters TYPE pri_params.

    IF iv_str IS NOT INITIAL.

      SPLIT iv_str AT '/' INTO TABLE lt_str.

      LOOP AT lt_str ASSIGNING FIELD-SYMBOL(<l>).
        CASE sy-tabix.
          WHEN '1'.
            IF <l> EQ 'PAP'.
              lv_mtart = 'ZPAP'.
            ENDIF.
          WHEN '2'.
            SPLIT <l> AT space INTO lv_cal lv_grama.
            IF lv_grama NE space.
              CONDENSE: lv_cal.
              CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                EXPORTING
                  input  = lv_grama
                IMPORTING
                  output = lv_grama.

            ELSE.
*             sera preimpreso?
              CLEAR: lv_cal, lv_grama.
              lv_mtart = 'ZPIM'.
              CONCATENATE 'P0' <l> '%' INTO lv_matnr.
            ENDIF.
          WHEN '3'.
            MOVE <l> TO lv_ancho. CONDENSE lv_ancho.
          WHEN OTHERS .
        ENDCASE.

      ENDLOOP.

      IF lv_cal IS NOT INITIAL.
        SELECT SINGLE valor_externo
          FROM ztpi0013
          INTO lv_val_ext
          WHERE calidad = lv_cal.

        IF sy-subrc EQ 0.
          SELECT SINGLE zvalor_sap
            FROM ztpi0003
            INTO lv_valor_sap
            WHERE zcodigo = '5' AND
                  werks = iv_werks AND
                  zvalor_externo = lv_val_ext.

          IF sy-subrc EQ 0.
            MOVE lv_valor_sap TO lv_matkl.

            SELECT SINGLE mara~matnr FROM mara
              INNER JOIN marc
              ON mara~matnr = marc~matnr
              INNER JOIN mard
              ON mara~matnr = mard~matnr
              AND marc~werks = mard~werks
              INTO lv_matnr
              WHERE matkl = lv_matkl AND
                    zzgramaje = lv_grama AND
                    zzancho = lv_ancho
                    AND marc~werks = iv_werks
                    AND mard~lgort = '1000' .

            IF sy-subrc EQ 0.
              cv_matnr = lv_matnr.
            ELSE. " cvivo - 61212 creación auto
              CALL FUNCTION 'JOB_OPEN'
                EXPORTING
                  jobname          = name
                IMPORTING
                  jobcount         = number
                EXCEPTIONS
                  cant_create_job  = 1
                  invalid_job_data = 2
                  jobname_missing  = 3
                  OTHERS           = 4.
              IF sy-subrc = 0.
                SUBMIT zrmm0022 WITH p_matnr EQ space " creación sin código material
                    WITH p_werks EQ iv_werks
                    WITH p_matkl EQ lv_matkl
                    WITH s_grama EQ lv_grama
                    WITH s_ancho EQ lv_ancho
                    WITH p_fondo EQ 'X'
                    TO SAP-SPOOL
                    SPOOL PARAMETERS print_parameters
                    WITHOUT SPOOL DYNPRO
                    VIA JOB name NUMBER number
                    AND RETURN.
                IF sy-subrc = 0.
                  CALL FUNCTION 'JOB_CLOSE'
                    EXPORTING
                      jobcount             = number
                      jobname              = name
                      strtimmed            = 'X'
                    EXCEPTIONS
                      cant_start_immediate = 1
                      invalid_startdate    = 2
                      jobname_missing      = 3
                      job_close_failed     = 4
                      job_nosteps          = 5
                      job_notex            = 6
                      lock_failed          = 7
                      OTHERS               = 8.

                  WAIT UP TO 3 SECONDS.
                ENDIF.
              ENDIF.

              SELECT SINGLE mara~matnr FROM mara " volvemos a intentarlo
                INNER JOIN marc
                ON mara~matnr = marc~matnr
                INNER JOIN mard
                ON mara~matnr = mard~matnr
                AND marc~werks = mard~werks
                INTO lv_matnr
                WHERE matkl = lv_matkl AND
                zzgramaje = lv_grama AND
                zzancho = lv_ancho
                AND marc~werks = iv_werks
                AND mard~lgort = '1000' .

              IF sy-subrc NE 0.
                RAISE no_material_found.
              ELSE.
                cv_matnr = lv_matnr.
              ENDIF.
            ENDIF.
          ELSE.
            RAISE e_valor_sap.
          ENDIF.
        ELSE.
          RAISE e_valor_externo.
        ENDIF.
      ELSE.
        IF lv_matnr IS NOT INITIAL.
          SELECT mara~*
            FROM mara INNER JOIN marc
            ON mara~matnr = marc~matnr
            INTO CORRESPONDING FIELDS OF TABLE @lt_mara
            WHERE mara~matnr LIKE @lv_matnr
            AND marc~werks = @iv_werks.

          " KYV/RDM - 20200521
          IF sy-subrc EQ 0.
            CLEAR lv_matnr.

            LOOP AT lt_mara ASSIGNING FIELD-SYMBOL(<ls>).
              MOVE <ls>-matnr+6(4) TO lv_grama.
              MOVE <ls>-matnr+10(4) TO lv_ancho.
              IF lv_grama EQ <ls>-zzgramaje AND lv_ancho EQ <ls>-zzancho.
                lv_matnr = <ls>-matnr.
                EXIT.
              ENDIF.
            ENDLOOP.
            IF lv_matnr IS INITIAL.
              RAISE e_mat_zpim_not_found.
            ELSE.
              cv_matnr = lv_matnr.
            ENDIF.
          ENDIF.
        ELSE.
          RAISE e_calidad_vacia.
        ENDIF.
      ENDIF.
    ELSE.
      RAISE e_sin_valor.
    ENDIF.
  ENDMETHOD.
METHOD dame_material_nav.

**********************************************************************
* FCC 18.05.2022
**********************************************************************
**********************************************************************
* Parámetros locales
**********************************************************************

  DATA: lo_utils_interfaces TYPE REF TO zcl_utils_interfaces.

  DATA: ls_matnr TYPE zmatnr_external,
        lt_matnr TYPE ztt_zmatnr_external.

  DATA: lv_ancho TYPE zancho.

**********************************************************************
* Validaciones
**********************************************************************

  IF ( i_matnr_nav IS INITIAL OR i_werks IS INITIAL ).
    RAISE e_sin_valor.
  ENDIF.

**********************************************************************
* Lógica
**********************************************************************

** Instancimos la clase de utilidades para interfaces

  lo_utils_interfaces = NEW zcl_utils_interfaces( ).

  IF ( lo_utils_interfaces IS NOT BOUND ).
    RAISE e_sin_valor.
  ENDIF.

** Obtenemos material NAV

  MOVE i_matnr_nav TO ls_matnr.
  TRANSLATE ls_matnr TO UPPER CASE.
  CONDENSE ls_matnr NO-GAPS.
*  REPLACE '/' IN ls_matnr WITH '-'. "FCC 25.09.2023 -> "Controlamos dentro del método

  lo_utils_interfaces->map_matnr_nav_2_sap(
    EXPORTING
      i_matnr_nav                 = ls_matnr    " Campo de texto, longitud 24
      i_werks                     = i_werks         " Centro
      i_lgort                     = '1000'   " Almacén  --> Hardcodeamos, en principio no hará falta cambiarlo pero si hiciera crearemos lógica.
    RECEIVING
      e_matnr_sap                 = lt_matnr    " Tabla de materiales
    EXCEPTIONS
      internal_error              = 1
      no_possible_decode          = 2
      error_nav_matnr_type        = 3
      error_map_quality_sap_value = 4
      OTHERS                      = 5
  ).
  "JCB 16.11.23. Material genérico para SCY
  IF lt_matnr IS INITIAL.
    APPEND '000001010100000000' TO lt_matnr.
  ENDIF.


*  IF sy-subrc <> 0.
*    CASE sy-subrc.
*      WHEN 1.
*        RAISE e_valor_externo.
*      WHEN 2.
*        RAISE e_valor_externo.
*      WHEN 3.
*        RAISE e_valor_externo.
*      WHEN 4.
*        RAISE e_valor_sap.
*      WHEN OTHERS.
*        RAISE e_valor_sap.
*    ENDCASE.
*  ENDIF.

** Obtenemos material

  IF ( lines( lt_matnr ) GT 0 ).

* Comento por nueva lógica.
*
*    "De momento obtenemos primer registro de la tabla.
*    " si nos indican una lógica corregimos.
*    READ TABLE lt_matnr INTO e_matnr INDEX 1.

    "Obtenemos ancho
    lo_utils_interfaces->get_ancho_nav( EXPORTING i_matnr_nav = ls_matnr
                                        RECEIVING e_ancho     = lv_ancho
                                        EXCEPTIONS no_value    = 1
                                                   no_q_value  = 2
                                                   OTHERS      = 3 ).
    IF sy-subrc <> 0.
      CLEAR lt_matnr.
      APPEND '000001010100000000' TO lt_matnr.
    ENDIF.

    "Reciclamos vble.
    CLEAR: ls_matnr.

    "Obtenemos registro con ancho.
    LOOP AT lt_matnr INTO ls_matnr.

      SELECT COUNT(*)
        FROM mara
       WHERE matnr   EQ ls_matnr
         AND zzancho EQ lv_ancho.

      IF ( sy-subrc EQ 0 ).
        MOVE ls_matnr TO e_matnr.
        EXIT.
      ENDIF.

    ENDLOOP.

    "Si no obtengo materiales con mismo ancho, obtengo primer registro.
    IF ( e_matnr IS INITIAL ).
      READ TABLE lt_matnr INTO e_matnr INDEX 1.
    ENDIF.

  ELSE.

    RAISE no_material_found.

  ENDIF.

ENDMETHOD.
  METHOD dame_material_pacs.
    IF iv_str IS INITIAL.
      RAISE e_sin_valor.
    ENDIF.

    DATA(vl_str) = iv_str.
    REPLACE ALL OCCURRENCES OF '/' IN vl_str WITH ''.

    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
      EXPORTING
        input        = vl_str
      IMPORTING
        output       = cv_matnr
      EXCEPTIONS
        length_error = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
      RAISE e_valor_externo.
    ENDIF.

    SELECT SINGLE werks, matnr
      INTO @DATA(wl_marc)
      FROM marc
      WHERE werks = @iv_werks AND
            matnr = @cv_matnr.
    IF sy-subrc <> 0.
      RAISE no_material_found.
    ENDIF.


  ENDMETHOD.
  METHOD DAME_MATERIAL_SAP.
    IF iv_matnr IS INITIAL. RAISE e_sin_valor.  ENDIF.

    SELECT SINGLE mara~matnr
      INTO @DATA(vl_matnr)
      FROM mara INNER JOIN marc ON mara~matnr = marc~matnr
                INNER JOIN mard ON mara~matnr = mard~matnr AND
                                   marc~werks = mard~werks
      WHERE mara~matnr = @iv_matnr.

    IF sy-subrc <> 0.
      RAISE no_material_found.
    ENDIF.

*    DATA: lt_str           TYPE TABLE OF string,
*          lv_str           TYPE string,
*          lv_matnr         TYPE matnr,
*          lv_cal(3),
*          lv_grama         TYPE zgramaje,
*          lv_ancho         TYPE zancho,
*          lv_val_ext       TYPE zedpi0005,
*          lv_valor_sap     TYPE zedpi0004,
*          lv_matkl         TYPE matkl,
*          lv_mtart         TYPE mtart,
*          lt_mara          TYPE STANDARD TABLE OF mara,
*          number           TYPE tbtcjob-jobcount,
*          print_parameters TYPE pri_params.
*
*    IF iv_str IS NOT INITIAL.
*
*      SPLIT iv_str AT '/' INTO TABLE lt_str.
*
*      LOOP AT lt_str ASSIGNING FIELD-SYMBOL(<l>).
*        CASE sy-tabix.
*          WHEN '1'.
*            IF <l> EQ 'PAP'.
*              lv_mtart = 'ZPAP'.
*            ENDIF.
*          WHEN '2'.
*            SPLIT <l> AT space INTO lv_cal lv_grama.
*            IF lv_grama NE space.
*              CONDENSE: lv_cal.
*              CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*                EXPORTING
*                  input  = lv_grama
*                IMPORTING
*                  output = lv_grama.
*
*            ELSE.
**             sera preimpreso?
*              CLEAR: lv_cal, lv_grama.
*              lv_mtart = 'ZPIM'.
*              CONCATENATE 'P0' <l> '%' INTO lv_matnr.
*            ENDIF.
*          WHEN '3'.
*            MOVE <l> TO lv_ancho. CONDENSE lv_ancho.
*          WHEN OTHERS .
*        ENDCASE.
*
*      ENDLOOP.
*
*      IF lv_cal IS NOT INITIAL.
*        SELECT SINGLE valor_externo
*          FROM ztpi0013
*          INTO lv_val_ext
*          WHERE calidad = lv_cal.
*
*        IF sy-subrc EQ 0.
*          SELECT SINGLE zvalor_sap
*            FROM ztpi0003
*            INTO lv_valor_sap
*            WHERE zcodigo = '5' AND
*                  werks = iv_werks AND
*                  zvalor_externo = lv_val_ext.
*
*          IF sy-subrc EQ 0.
*            MOVE lv_valor_sap TO lv_matkl.
*
*            SELECT SINGLE mara~matnr FROM mara
*              INNER JOIN marc
*              ON mara~matnr = marc~matnr
*              INNER JOIN mard
*              ON mara~matnr = mard~matnr
*              AND marc~werks = mard~werks
*              INTO lv_matnr
*              WHERE matkl = lv_matkl AND
*                    zzgramaje = lv_grama AND
*                    zzancho = lv_ancho
*                    AND marc~werks = iv_werks
*                    AND mard~lgort = '1000' .
*
*            IF sy-subrc EQ 0.
*              cv_matnr = lv_matnr.
*            ELSE. " cvivo - 61212 creación auto
*              CALL FUNCTION 'JOB_OPEN'
*                EXPORTING
*                  jobname          = gac_nombre_job_crea_material
*                IMPORTING
*                  jobcount         = number
*                EXCEPTIONS
*                  cant_create_job  = 1
*                  invalid_job_data = 2
*                  jobname_missing  = 3
*                  OTHERS           = 4.
*              IF sy-subrc = 0.
*                SUBMIT zrmm0022 WITH p_matnr EQ space " creación sin código material
*                    WITH p_werks EQ iv_werks
*                    WITH p_matkl EQ lv_matkl
*                    WITH s_grama EQ lv_grama
*                    WITH s_ancho EQ lv_ancho
*                    WITH p_fondo EQ 'X'
*                    TO SAP-SPOOL
*                    SPOOL PARAMETERS print_parameters
*                    WITHOUT SPOOL DYNPRO
*                    VIA JOB gac_nombre_job_crea_material NUMBER number
*                    AND RETURN.
*                IF sy-subrc = 0.
*                  CALL FUNCTION 'JOB_CLOSE'
*                    EXPORTING
*                      jobcount             = number
*                      jobname              = gac_nombre_job_crea_material
*                      strtimmed            = 'X'
*                    EXCEPTIONS
*                      cant_start_immediate = 1
*                      invalid_startdate    = 2
*                      jobname_missing      = 3
*                      job_close_failed     = 4
*                      job_nosteps          = 5
*                      job_notex            = 6
*                      lock_failed          = 7
*                      OTHERS               = 8.
*
*                  WAIT UP TO 3 SECONDS.
*                ENDIF.
*              ENDIF.
*
*              SELECT SINGLE mara~matnr FROM mara " volvemos a intentarlo
*                INNER JOIN marc
*                ON mara~matnr = marc~matnr
*                INNER JOIN mard
*                ON mara~matnr = mard~matnr
*                AND marc~werks = mard~werks
*                INTO lv_matnr
*                WHERE matkl = lv_matkl AND
*                zzgramaje = lv_grama AND
*                zzancho = lv_ancho
*                AND marc~werks = iv_werks
*                AND mard~lgort = '1000' .
*
*              IF sy-subrc NE 0.
*                RAISE no_material_found.
*              ELSE.
*                cv_matnr = lv_matnr.
*              ENDIF.
*            ENDIF.
*          ELSE.
*            RAISE e_valor_sap.
*          ENDIF.
*        ELSE.
*          RAISE e_valor_externo.
*        ENDIF.
*      ELSE.
*        IF lv_matnr IS NOT INITIAL.
*          SELECT mara~*
*            FROM mara INNER JOIN marc
*            ON mara~matnr = marc~matnr
*            INTO CORRESPONDING FIELDS OF TABLE @lt_mara
*            WHERE mara~matnr LIKE @lv_matnr
*            AND marc~werks = @iv_werks.
*
*          " KYV/RDM - 20200521
*          IF sy-subrc EQ 0.
*            CLEAR lv_matnr.
*
*            LOOP AT lt_mara ASSIGNING FIELD-SYMBOL(<ls>).
*              MOVE <ls>-matnr+6(4) TO lv_grama.
*              MOVE <ls>-matnr+10(4) TO lv_ancho.
*              IF lv_grama EQ <ls>-zzgramaje AND lv_ancho EQ <ls>-zzancho.
*                lv_matnr = <ls>-matnr.
*                EXIT.
*              ENDIF.
*            ENDLOOP.
*            IF lv_matnr IS INITIAL.
*              RAISE e_mat_zpim_not_found.
*            ELSE.
*              cv_matnr = lv_matnr.
*            ENDIF.
*          ENDIF.
*        ELSE.
*          RAISE e_calidad_vacia.
*        ENDIF.
*      ENDIF.
*    ELSE.
*      RAISE e_sin_valor.
*    ENDIF.
  ENDMETHOD.
  METHOD dame_tabla_creadas.
    DATA: lv_aux     TYPE string,
          lt_message TYPE soli_tab,
          ls_log     TYPE treg_log,
          ls_message TYPE soli.

    ls_message-line = '<b> <u>Â·<p> Resumen de NTs creadas por cinumber </b> </u/> </p>'.
    APPEND ls_message TO lt_message.

    CONCATENATE '<table style="width:100%">' gac_tr
                gac_th 'CInumber' gac_thf
                gac_th 'PaperStation' gac_thf
                gac_th 'NT' gac_thf
                gac_th 'Material' gac_thf
                gac_th 'Cantidad' gac_thf gac_trf
                INTO ls_message-line.
    APPEND ls_message TO lt_message.

    "KYV/RDM - 20200526
    SORT gat_log BY cinumber ok_1 DESCENDING ok_2 DESCENDING ok_3 DESCENDING ok_4 DESCENDING
    ok_5 DESCENDING.

    LOOP AT gat_log INTO ls_log.
      CLEAR ls_message.
      IF ls_log-ok_1 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation1' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_1 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_1 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_1 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ok_2 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation2' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_2 gac_tdf    INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_2 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_2 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ok_3 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation3' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_3 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_3 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_3 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ok_4 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation4' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_4 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_4 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_4 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ok_5 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation5' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_5 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_5 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_5 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ok_6 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation6' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ok_6 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_6 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_6 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.

    ENDLOOP.
    ls_message-line = '</table>'.
    APPEND ls_message TO lt_message.

    APPEND LINES OF lt_message TO pt_mess.

  ENDMETHOD.
  METHOD dame_table_erroes.
    DATA: ls_message TYPE soli,
          lt_message TYPE soli_tab,
          ls_log     TYPE treg_log,
          lv_aux     TYPE string.

    ls_message-line = '<b> <u>Â·<p> Resumen de errores por cinumber </b> </u/> </p>'.
    APPEND ls_message TO lt_message.

    CONCATENATE '<table style="width:100%">' gac_tr
                gac_th 'CInumber' gac_thf
                gac_th 'PaperStation' gac_thf
                gac_th 'Error' gac_thf
                gac_th 'Material' gac_thf
                gac_th 'Cantidad' gac_thf gac_trf
                INTO ls_message-line.
    APPEND ls_message TO lt_message.

    LOOP AT gat_log INTO ls_log.
      CLEAR ls_message.
      IF ls_log-ko_1 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation1' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_1 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_1 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_1 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ko_2 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation2' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_2 gac_tdf    INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_2 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_2 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ko_3 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation3' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_3 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_3 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_3 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ko_4 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation4' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_4 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_4 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_4 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ko_5 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation5' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_5 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_5 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_5 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.
      IF ls_log-ko_6 IS NOT INITIAL.
        CONCATENATE gac_tr gac_td ls_log-cinumber gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td 'PaperStation6' gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-ko_6 gac_tdf INTO ls_message-line.
        CONCATENATE ls_message-line gac_td ls_log-matnr_6 gac_tdf INTO ls_message-line.
        MOVE ls_log-menge_6 TO lv_aux. CONDENSE lv_aux.
        CONCATENATE ls_message-line gac_td lv_aux gac_tdf gac_trf INTO ls_message-line.
        APPEND ls_message TO lt_message.
      ENDIF.

    ENDLOOP.
    ls_message-line = '</table>'.
    APPEND ls_message TO lt_message.

    APPEND LINES OF lt_message TO pt_mess.
  ENDMETHOD.
  METHOD delete_reservation.
    DATA ls_log      TYPE treg_log.

    DATA(lt_ret) = zcl_wm_nt_generic=>delete_reserv(
      EXPORTING
        iv_rsnum  = iv_rsnum
        iv_commit = abap_true
    ).

    ls_log-ko_1 = |{ text-022 } { iv_rsnum }|.

    LOOP AT lt_ret INTO DATA(ls_ret) WHERE type CA 'XAE'.
      IF ls_log IS NOT INITIAL.
        APPEND ls_log TO gat_log.
      ENDIF.
      ls_log-ko_1 = ls_ret-message.
      APPEND ls_log TO gat_log.
      CLEAR ls_log.
      gav_hay_error = abap_true.
    ENDLOOP.
    "check sy-subrc = 0. "KYV/RDM - 20200710
    CHECK sy-subrc NE 0. "KYV/RDM - 20200710

    CLEAR ls_log.
    ls_log-ok_1 = |{ text-023 } { iv_rsnum }|.
    APPEND ls_log TO gat_log.
  ENDMETHOD.
  METHOD envia_mail_notificacion.
    CONSTANTS: lc_th(4)  VALUE '<th>',
               lc_thf(5) VALUE '</th>',
               lc_tr(4)  VALUE '<tr>',
               lc_trf(5) VALUE '</tr>',
               lc_td(4)  VALUE '<td>',
               lc_tdf(5) VALUE '</td>'.

    DATA: ls_mails       TYPE ztmm0025,
          lt_addr        TYPE bcsy_smtpa,
          lo_send_email  TYPE REF TO cl_bcs,
          lo_document    TYPE REF TO cl_document_bcs,
          lo_recipient   TYPE REF TO if_recipient_bcs,
          lv_sent_to_all TYPE os_boolean,
          lo_sender      TYPE REF TO cl_cam_address_bcs,
          lv_sender      TYPE adr6-smtp_addr,
          lv_subject     TYPE so_obj_des,
          lt_message     TYPE soli_tab,
          ls_message     TYPE soli,
          ls_ltbk        TYPE ltbk,
          lv_lin         TYPE i,
          ls_ret         TYPE bapiret2,
          lv_message     TYPE bapi_msg,
          lv_aux         TYPE string,
          ls_log         TYPE treg_log.

    SELECT SINGLE * FROM ztmm0025
      INTO ls_mails
      WHERE werks EQ ga_werks AND
            proceso = '3'.

    IF sy-subrc EQ 0 AND ls_mails IS NOT INITIAL.

      IF ls_mails-email1 NE space.
        APPEND ls_mails-email1 TO lt_addr.
      ENDIF.
      IF ls_mails-email2 NE space.
        APPEND ls_mails-email2 TO lt_addr.
      ENDIF.
      IF ls_mails-email3 NE space.
        APPEND ls_mails-email3 TO lt_addr.
      ENDIF.
      IF ls_mails-email4 NE space.
        APPEND ls_mails-email4 TO lt_addr.
      ENDIF.


* Cuerpo del email

* Necesidades borradas
      LOOP AT gat_borradas INTO ls_ltbk.
        IF sy-tabix EQ 1.
          DESCRIBE TABLE gat_borradas LINES lv_lin.
          MOVE lv_lin TO lv_aux.
          CONDENSE lv_aux.
          CONCATENATE '<font size="+3"> <b> <u> <p> Necesidades borradas. Total ' lv_aux '</b> </u/> </p> </font>' INTO lv_aux SEPARATED BY space.
          ls_message-line = lv_aux.
          APPEND ls_message TO lt_message.
          CLEAR ls_message.
        ENDIF.
        CONCATENATE '<p> Nº necesidad' ls_ltbk-tbnum 'Necesidad' ls_ltbk-benum INTO lv_aux SEPARATED BY space.
        ls_message-line = lv_aux.
        APPEND ls_message TO lt_message.
        CLEAR ls_message.
      ENDLOOP.

* Necesidades Modificadas
      LOOP AT gat_modificadas INTO ls_ltbk.
        IF sy-tabix EQ 1.
          DESCRIBE TABLE gat_modificadas LINES lv_lin.
          MOVE lv_lin TO lv_aux.
          CONDENSE lv_aux.
          CONCATENATE '<font size="+3"> <b> <u> <p>  Necesidades modificadas. Total ' lv_aux '</b> </u/> </p> </font>' INTO lv_aux SEPARATED BY space.
          ls_message-line = lv_aux.
          APPEND ls_message TO lt_message.
          CLEAR ls_message.
        ENDIF.
        CONCATENATE '<p>Nº necesidad' ls_ltbk-tbnum '. Necesidad' ls_ltbk-benum '</p>' INTO lv_aux SEPARATED BY space.
        ls_message-line = lv_aux.
        APPEND ls_message TO lt_message.
        CLEAR ls_message.
      ENDLOOP.

      ls_message-line = '<font size="+3"> <b> <u> <p> Resumen del resultado del fichero </p></font>'.
      APPEND ls_message TO lt_message.
      ls_message-line = text-sty.
      APPEND ls_message TO lt_message.

* tabla resumen de NTs creadas
      dame_tabla_creadas( CHANGING pt_mess = lt_message ).

* tabla resumen de errores
      dame_table_erroes( CHANGING pt_mess = lt_message ).


      TRY.
* InicializaciÃ³n de la clase
          lo_send_email = cl_bcs=>create_persistent( ).


* Crear documento
          CONCATENATE 'Centro' ga_werks ': Log de Interface OMP a SAP'  INTO lv_subject SEPARATED BY space. " 61212 - cvivo

          lo_document =  cl_document_bcs=>create_document( i_type    =  'HTM'
                                                            i_subject =  lv_subject
                                                            i_text    =  lt_message ).
* Enviar documento al email
          lo_send_email->set_document( lo_document ).

* AÃ±adir remitente
          lv_sender = 'sap@hinojosa.es'.
          lo_sender = cl_cam_address_bcs=>create_internet_address( lv_sender  ).
          lo_send_email->set_sender( i_sender = lo_sender ).

* AÃ±adir destinatarios al email
          LOOP AT lt_addr ASSIGNING FIELD-SYMBOL(<fs_addr>).
            lo_recipient = cl_cam_address_bcs=>create_internet_address( <fs_addr> ).
            lo_send_email->add_recipient( i_recipient = lo_recipient ).
          ENDLOOP.
          IF ls_mails-lista NE space. " 58445 - Envío a listas de distribución
            lo_recipient = cl_distributionlist_bcs=>getu_persistent( i_dliname = ls_mails-lista i_private = space ).
            lo_send_email->add_recipient( i_recipient = lo_recipient i_express = 'X' ).
          ENDIF.

* Enviar email
          lv_sent_to_all = lo_send_email->send( i_with_error_screen = 'X' ).

*  COMMIT WORK. " no se puede porque estamos en UPDATE!

          IF lv_sent_to_all EQ 'X'.
*   Enviado Correctamente
          ELSE.
*   Error al enviar
          ENDIF.


        CATCH cx_send_req_bcs.
        CATCH cx_address_bcs.
        CATCH cx_document_bcs.
      ENDTRY.

    ENDIF.

  ENDMETHOD.
  METHOD error_material_log.
    CASE pi_subrc.
      WHEN 1.
        MOVE 'No se ha encontrado el material' TO pc_ko.
      WHEN 2.
        MOVE 'No se ha recuperado valor de calidad' TO pc_ko.
      WHEN 3.
        MOVE 'No se ha recuperado valor externo' TO pc_ko.
      WHEN 4.
        MOVE 'No se ha recuperado valor SAP para el valor externo' TO pc_ko.
      WHEN 5.
      WHEN 6.
        MOVE 'No se ha encontraro el material tipo preimpreso' TO pc_ko.
    ENDCASE.

  ENDMETHOD.
  METHOD f_bdc_dynpro.
    DATA: ls_bdc TYPE bdcdata.

    ls_bdc-program  = pe_prog.
    ls_bdc-dynpro   = pe_dyn.
    ls_bdc-dynbegin = abap_true.
    APPEND ls_bdc TO gat_bdcdata.

  ENDMETHOD.
  METHOD f_bdc_field.
    DATA: ls_bdc TYPE bdcdata.

    IF pe_fval  <> gac_nodata.
      ls_bdc-fnam  = pe_fnam.
      ls_bdc-fval   = pe_fval.
      APPEND ls_bdc TO gat_bdcdata.
    ENDIF.
  ENDMETHOD.
  METHOD get_ltba.
    rt_ltba = me->gt_ltba.
  ENDMETHOD.
  METHOD get_nt_dat_upd.
    CLEAR rt_ltbk.
    IF iv_idx IS NOT INITIAL.
      TRY.
          DATA(ls_ltbk) = me->gt_nt_dat_update[ iv_idx ].
          APPEND ls_ltbk TO rt_ltbk.
          IF iv_remove = abap_true.
            DELETE me->gt_nt_dat_update INDEX iv_idx.
          ENDIF.
        CATCH cx_root.
      ENDTRY.
      RETURN.
    ENDIF.

    rt_ltbk = me->gt_nt_dat_update.
    CHECK iv_remove = abap_true.
    me->init_nt_dat_upd( ).
  ENDMETHOD.
  METHOD init_nt_dat_upd.
    CLEAR me->gt_nt_dat_update.
  ENDMETHOD.
  METHOD notifica_borrada.
    DATA: ls_ltbk TYPE ltbk.

    SELECT SINGLE *
      FROM ltbk
      INTO CORRESPONDING FIELDS OF ls_ltbk
      WHERE lgnum = pi_lgnum AND
            tbnum = pi_tbnum.

    IF sy-subrc NE 0.
      APPEND ls_ltbk TO gat_borradas.

      " cvivo - Limpiar datos ZWM_LTBK_ADIT
      DELETE FROM zwm_ltbk_adit WHERE lgnum EQ pi_lgnum
                                  AND tbnum EQ pi_tbnum.

      COMMIT WORK AND WAIT.
    ENDIF.
  ENDMETHOD.
  METHOD notifica_modificada.

    IF pi_ltbk IS NOT INITIAL.
      APPEND pi_ltbk TO gat_modificadas.
    ENDIF.
  ENDMETHOD.
  METHOD remove_idx_ltba.
    CHECK iv_idx > 0 AND lines( me->gt_ltba ) >= iv_idx.
    DELETE me->gt_ltba INDEX iv_idx.
  ENDMETHOD.
  METHOD run_ltba.
    DATA ls_log      TYPE treg_log.
    CHECK me->gt_ltba IS NOT INITIAL.

    DO lines( me->gt_ltba ) TIMES.
      me->crear_nts(
        EXPORTING
          pi_index      =  me->gt_ltba[ sy-index ]-idx   " ABAP System Field: Loop Index
            iv_store_only = abap_false
            it_ltba       = me->gt_ltba[ sy-index ]-it_ltba
        CHANGING
            pc_ok = ls_log-ok_1
            pc_ko = ls_log-ko_1   " Message Text
      ).
    ENDDO.

  ENDMETHOD.
  METHOD store_ltba.
    " must check that it is not confirmed yet...
    CHECK lines( it_ltba ) > 0.

    DATA(lt_nt_dat) = me->get_nt_dat_upd(
*                      iv_idx    =
                  iv_remove = abap_false
              ).

    DATA(ls_ltba) = it_ltba[ 1 ].
    SELECT SINGLE *
    FROM ltbk
    INTO @DATA(ls_ltbk)
    WHERE lgnum = @ls_ltba-lgnum
    AND benum = @ls_ltba-benum
    AND nlpla = @ls_ltba-nlpla.

    IF sy-subrc EQ 0 AND ls_ltbk-statu EQ space. " si no está tratada, si está tratada no informaremos LTBP
      SELECT SINGLE * " siempre hay 1 posición en estas NTs
        FROM ltbp
        INTO @DATA(ls_ltbp)
        WHERE lgnum = @ls_ltba-lgnum
          AND tbnum = @ls_ltbk-tbnum
          AND matnr = @ls_ltba-matnr " cvivo - incluimos esta cláusula para controlar si ha cambiado el material, en cuyo caso volver a crear
          AND menga = @ls_ltba-menga. " cvivo 65424 - si cambia la cantidad, la crearemos de nuevo, porque no podemos modificarla (el FM intern no
      " es apropiado porque sólo cambiaría el campo menga y no el resto de cantidades; y el BI no funciona)

    ENDIF.

    IF sy-subrc EQ 0. " si existe, actualizamos fecha+hora y lo añadimos a LTBA para no interferir en la posterior agrupación (salvo que ya esté tratada: STATU <> SPACE)
      adjust_nt_date_individual( i_ltba = ls_ltba i_ltbk = ls_ltbk i_ltbp = ls_ltbp ).
      APPEND VALUE #( idx  = iv_idx it_ltba = it_ltba nlpla = ls_ltba-nlpla pdatu = ls_ltba-pdatu pzeit = ls_ltba-pzeit fsc = iv_fsc rsnum = ls_ltbk-rsnum ) TO me->gt_ltba.
    ELSEIF NOT line_exists( lt_nt_dat[ lgnum = ls_ltba-lgnum benum = ls_ltba-benum nlpla = ls_ltba-nlpla ] ).
      APPEND VALUE #( idx  = iv_idx it_ltba = it_ltba nlpla = ls_ltba-nlpla pdatu = ls_ltba-pdatu pzeit = ls_ltba-pzeit fsc = iv_fsc rsnum = ls_ltbk-rsnum ) TO me->gt_ltba.
    ENDIF.
  ENDMETHOD.
  METHOD zii_si_prod_replenishment_ui5~si_prod_replenishment_ui5.
    "JCB 19.10.20. Viene de
    " - clase ZCL_SI_OMP_PROD_REP_IN_OMP_TO
    " - método ZII_SI_OMP_PROD_REP_IN_OMP_TO~SI_OMP_PROD_REP_IN_OMP_TO_SAP
    "JCB 29.05.22. Adaptación máquinas converting PACS

    DATA tl_intf_omp_sap TYPE TABLE OF zwm_intf_omp_sap.

    o_log = NEW zcl_ap_log( object = 'PROD_REP'
                            report = 'ZCL_SI_PROD_REPLENISHMENT_UI5'
                            clave  = zcl_ap_proxy=>get_msgguid( ) ).

    o_log->log( msgty = 'I'
               message  = 'Inicio proceso' ).

    CHECK input-mt_prod_replenishment_ui5-message-ompci IS NOT INITIAL.

    DATA: machine TYPE string.
    CLEAR gav_hay_error.

    DATA(datum) = sy-datum. " INS - cvivo - hacemos una foto en ejecución, para evitar bailes de segundos a posteriori
    DATA(uzeit) = sy-uzeit.

    " 0.- cargamos hardcodes
    "Actualizamos HARDCODE GA_LGNUM: Recuperamos una linea
    ga_lgnum = input-mt_prod_replenishment_ui5-message-ompci[ 1 ]-warehouse_number.

    "KYV/RDM - 20210212 - ADD Rambleños BEG
*    DATA(vl_clave_hardcodes) = COND repid( WHEN ga_lgnum = gac_lgnum_bernabeu THEN gac_clave_hardcodes_bernabeu
*                                                                              ELSE gac_clave_hardcodes_pacs ).
    DATA(vl_clave_hardcodes) = SWITCH repid( ga_lgnum WHEN gac_lgnum_bernabeu THEN gac_clave_hardcodes_bernabeu
                                                      WHEN gac_lgnum_pacs     THEN gac_clave_hardcodes_pacs
                                                      WHEN gac_lgnum_er       THEN gac_clave_hardcodes_er
                                                      WHEN gac_lgnum_hpx      THEN gac_clave_hardcodes_xativa
                                                      WHEN gac_lgnum_scy      THEN gac_clave_hardcodes_scy "KYV/RDM - 20220113 - ADD SCY
    ).

    DATA vl_cla_san_cayetano  TYPE xfeld.
    DATA vl_cla_xativa        TYPE xfeld.
    DATA vl_cla_ramblenyos    TYPE xfeld.
    DATA vl_cla_pacs          TYPE xfeld.
    IF ga_lgnum = gac_lgnum_scy.  vl_cla_san_cayetano  = 'X'. ENDIF.
    IF ga_lgnum = gac_lgnum_er.   vl_cla_ramblenyos    = 'X'. ENDIF.
    IF ga_lgnum = gac_lgnum_pacs. vl_cla_pacs          = 'X'. ENDIF.
    IF ga_lgnum = gac_lgnum_hpx.  vl_cla_xativa        = 'X'. ENDIF.



    "KYV/RDM - 20210212 - ADD Rambleños END
    ga_cla_nemesis = COND xfeld( WHEN ga_lgnum = gac_lgnum_bernabeu THEN 'X' ELSE space ).

    dame_hardcodes( vl_clave_hardcodes ).

*--> INI FCARDONA - Adaptar para SAITÍ
*
*    " 1.- las otras NTs, modificadas van al log
*    IF vl_cla_pacs = space.
*      carga_nt_modificadas( ).
*    ENDIF.

    "Separamos por NA --> 201
    IF ( ga_lgnum EQ gac_lgnum_pacs AND vl_cla_pacs = space ).
      carga_nt_modificadas( ).
    ENDIF.

    "Separamos por NA --> 200
    IF ( ga_lgnum EQ gac_lgnum_hpx AND vl_cla_xativa = space ).
      carga_nt_modificadas( ).
    ENDIF.

*<-- FIN FCARDONA - Adaptar para SAITÍ


**    " 2.- borrado de NTs abiertas sin modificacion y sin UA asignada actualmente en pantalla
*    borra_nt_abiertas( ). " cvivo - pasamos a gestionarlo por ubicación al crear las NTs y reservas
**
**    " 3 - close Reservations
*    close_reservation( ). "  cvivo - pasamos a gestionarlo por ubicación al crear las NTs y reservas

    " 4.- Generamos las NTs en SAP
    DATA: tl_ltbk TYPE gtyp_ltbk,
          tl_ltbp TYPE gtyp_ltbp,
          wl_ltbk LIKE LINE OF tl_ltbk,
          wl_ltbp LIKE LINE OF tl_ltbp,
          wl_log  TYPE treg_log.
    DATA: vl_aux_trim TYPE lqua_gesme,
          vl_str      TYPE string,
          vl_aux2     TYPE string.

    "Otenemos ubicaciones destino hardcodeadas
    DATA tl_lgpla_rg TYPE RANGE OF lagp-lgpla.
    FIELD-SYMBOLS: <fs_lgpla_rg> LIKE LINE OF tl_lgpla_rg.
    IF ga_nlpla01 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla01. ENDIF.
    IF ga_nlpla02 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla02. ENDIF.
    IF ga_nlpla03 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla03. ENDIF.
    IF ga_nlpla04 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla04. ENDIF.
    IF ga_nlpla05 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla05. ENDIF.
    IF ga_nlpla06 IS NOT INITIAL. APPEND INITIAL LINE TO tl_lgpla_rg ASSIGNING <fs_lgpla_rg>. <fs_lgpla_rg>-sign = 'I'. <fs_lgpla_rg>-option = 'EQ'. <fs_lgpla_rg>-low = ga_nlpla06. ENDIF.

    IF tl_lgpla_rg IS NOT INITIAL.
      SELECT lgnum, lgtyp, lgpla
        INTO TABLE @DATA(tl_lagp_hardcoded)
        FROM lagp
        WHERE lgnum = @ga_lgnum AND
              lgpla IN @tl_lgpla_rg.
    ENDIF.


    SELECT lgnum, lgtyp, lgpla
       INTO TABLE @DATA(tl_lagp_bd)
       FROM lagp
       WHERE lgnum = @ga_lgnum AND
             lgtyp = '100'.


    "Obtenemos las máquinas con gestión de palets
    SELECT low
      INTO TABLE @DATA(tl_maquinas_gestion_palets)
      FROM tvarvc
      WHERE name  = 'ZWM_MAQUINAS_GESTION_PALETS'.

    "Obtenemos valores para pedidos FSC - cvivo
    SELECT 'I' AS sign, 'EQ' AS option, high AS low, high AS high FROM tvarvc
      WHERE name EQ 'ZWM_FSC_RECYCLED'
      INTO TABLE @DATA(t_fsc).

    " cvivo - si la máquina no se encuentra, vemos si hay que obviarla
    SELECT 'I' AS sign, 'EQ' AS option, lgpla AS low, lgpla AS high FROM lagp
      WHERE lgnum EQ @ga_lgnum
        AND lgtyp EQ '100'
      INTO TABLE @DATA(r_ubicaciones).

    SELECT 'I' AS sign, 'EQ' AS option, low AS low, high AS high FROM tvarvc
    WHERE name EQ 'ZWM_NOMBRE_MAQUINA'
    INTO TABLE @DATA(r_ubicaciones_skip). " aunque este parámetro es para poner nombre a las estaciones y máquinas
    " lo utilizamos también para evitar generar log en estaciones donde sabemos que vamos a recibir datos erróneamente
    " y no queremos recibir log

    " cvivo - sustitución de estaciones
    SELECT 'I' AS sign, 'EQ' AS option, low, high
      FROM tvarvc
      WHERE name EQ 'ZWM_UI5_SUSTIT_MAQ'
      INTO TABLE @DATA(r_sustitucion).
    IF sy-subrc NE 0.
      r_sustitucion = VALUE #( sign = 'I' option = 'EQ' ( low = space ) ).
    ENDIF.

    SELECT 'I' AS sign, 'EQ' AS option, high AS low, low AS high FROM tvarvc
    WHERE name EQ 'ZWM_UI5_SUSTIT_MAQ'
      AND sign EQ 'E' " si el signo es E la sustitución es excluyente, las necesidades de la sustitiva no se tienen
                      " en cuenta sino únicamente de la sustituida
    INTO TABLE @DATA(r_excluir).

    IF sy-subrc NE 0.
      r_excluir = VALUE #( sign = 'I' option = 'EQ' ( low = space ) ).
    ENDIF.

    "Recorremos los datos de entrada para procesarlos
    "Fecha y horas de inicio actual. Redondeo al minuto 10
    DATA vl_fecha TYPE d. "vl_fecha = sy-datum.
    DATA vl_hora  TYPE t. "vl_hora  = sy-uzeit(3) && '000'.


    "Nuevo campo Orden acople en la interfaz Nemesis
    "En START_DATE en este caso en realidad viene un numérico con el orden por máquinas
    TYPES: BEGIN OF st_ompci,
             orden_acople TYPE i.
             INCLUDE TYPE zdt_prod_replenishment_to_sap.
           TYPES: END OF st_ompci.
    DATA tl_ompci TYPE TABLE OF st_ompci.

    "cvivo - ordenar en Némesis por "Orden_acople (start date)" y máquina
    MOVE-CORRESPONDING input-mt_prod_replenishment_ui5-message-ompci TO tl_ompci.
    IF ga_cla_nemesis NE space.
      LOOP AT tl_ompci ASSIGNING FIELD-SYMBOL(<fs>).
        <fs>-orden_acople = <fs>-start_date.
      ENDLOOP.

      SORT tl_ompci BY machine_code orden_acople ASCENDING.

*--> INI FCARDONA 26.08.2024 - Adaptar para SAITI

    ELSE.

      "Si es Xativa, ordenamos por máquina
      SORT tl_ompci BY machine_code ASCENDING.

*--> FIN FCARDONA 26.08.2024 - Adaptar para SAITI

    ENDIF.



    DATA: wl_interfase TYPE zwm_intf_omp_sap.

    LOOP AT tl_ompci ASSIGNING <fs>.
      CLEAR: wl_ltbk, wl_log.


      IF machine NE <fs>-machine_code. " cvivo - reiniciamos por máquina
        vl_fecha = sy-datum.
        vl_hora  = sy-uzeit(3) && '000'.
        machine = <fs>-machine_code.
      ENDIF.

      "JCB 07.01.22: Adaptar CI Number OMP
      "TODO: Comprobar la condición
      DATA(vl_cinumber) = <fs>-cinumber.
      IF ga_cla_nemesis = space.
        DATA(vl_benum) =  zcl_wm_nt_generic=>convert_benum_omp_internal( vp_gjahr  = CONV #( <fs>-start_date+6(4) )
                                                                         vp_input  = CONV #( <fs>-cinumber ) ).
        <fs>-cinumber = vl_benum.
      ENDIF.


      DATA(wl_adit) = CORRESPONDING zwm_ltbk_adit_inc( <fs> MAPPING benum     = cinumber
                                                                    fsc       = fsccertificateinfo
                                                                    cliente   = desc_cliente
                                                                    cliente2  = desc_cliente2 " cvivo 65088
                                                                    texto     = comment )."  cvivo 65089

      " cvivo - casuística específica de la Vatán, no pasará jamás en otra, así que hardcode a tope
      IF <fs>-warehouse_number EQ '240' AND ( <fs>-machine_code EQ '11' OR <fs>-machine_code EQ '10' ).
        " en este caso vamos a recibir en el papel 1 el material de alta, lo almacenaremos en zwm_ltbk_adit porque no necesitamos
        " generar necesidades; el resto de papeles son incorrectos, heredados de la calidad; el material de consumo viene porque es
        " el del alta pero sin largo y con el ancho del campo "reel_width"

        wl_adit-matnr_alta = CONV matnr( <fs>-paper_station1 ).
        wl_adit-matnr_alta = |{ wl_adit-matnr_alta ALPHA = IN }|.

        check_material_exists( EXPORTING " importante, porque después no lo tendrá en cuenta
                                iv_matnr = wl_adit-matnr_alta
                                iv_werks = ga_werks
                              EXCEPTIONS
                                error_creacion = 1
                                material_vacio = 5 ).

        IF ( sy-subrc NE 0 ).
          CONTINUE.
        ENDIF.

        DATA(ancho) = CONV zancho( <fs>-reel_width ).
        <fs>-paper_station1 = |{ <fs>-paper_station1(9) }{ ancho ALPHA = IN }|. " el papel de consumo es el de alta sin largo y con ancho del acople

        CLEAR: <fs>-paper_station2, <fs>-paper_station3, <fs>-paper_station4, <fs>-paper_station5.
      ENDIF.

      "Acople
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = wl_adit-benum
        IMPORTING
          output = wl_adit-benum.
      wl_ltbk-benum = wl_log-cinumber = <fs>-cinumber = wl_adit-benum.


      "Tratamiento fechas
      IF ga_cla_nemesis = 'X'.
        "Cada vez que se reciba de la interfaz, para cada acople vamos generando las NTs con fecha y hora actual (toma el siguiente minuto múltiplo de 10
        " y cada registro posterior lo vamos incrementando en 10 minutos.
        "Ojo, que hay casos en que la necesidad se ha tratado y la interfaz no la borra y la vuelve a crear,
        "sino que sólo modifique fecha y hora según tengo entendido; en este caso deberíamos actualizar la fecha y hora en base a esta lógica.

        "Hora, que sea el siguiente múltiplo de 10
        CALL FUNCTION 'C14B_ADD_TIME'
          EXPORTING
            i_starttime = vl_hora
            i_startdate = vl_fecha
            i_addtime   = '001000'
          IMPORTING
            e_endtime   = vl_hora
            e_enddate   = vl_fecha.
        wl_ltbk-pdatu = vl_fecha.
        wl_ltbk-pzeit = vl_hora.
        wl_ltbk-bdatu = datum.
        wl_ltbk-bzeit = uzeit.
      ELSE.
        wl_ltbk-bdatu = <fs>-start_date+6(4)  && <fs>-start_date+3(2)  && <fs>-start_date+0(2).
        wl_ltbk-bzeit = <fs>-start_date+11(2) && <fs>-start_date+14(2) && <fs>-start_date+17(2).
        wl_ltbk-pdatu = <fs>-end_date+6(4)    && <fs>-end_date+3(2)    && <fs>-end_date+0(2).
        wl_ltbk-pzeit = <fs>-end_date+11(2)   && <fs>-end_date+14(2)   && <fs>-end_date+17(2).
      ENDIF.


      "LZNUM
      MOVE <fs>-quality TO vl_str.
      IF <fs>-flute_type IS NOT INITIAL.
        IF vl_cla_san_cayetano = space. "JCB 20.09.23. En San Cayetano no quitamos el canal que se puede sobreescribir...
          REPLACE ALL OCCURRENCES OF <fs>-flute_type IN vl_str WITH space.
          CONDENSE vl_str.
        ENDIF.
      ENDIF.
      vl_aux_trim = <fs>-planned_trim.
      IF vl_aux_trim IS NOT INITIAL.
        vl_aux_trim = vl_aux_trim * 1000.
        vl_aux2 = vl_aux_trim.
      ENDIF.
      wl_ltbk-lznum = |{ <fs>-reel_width }/{ vl_str }/{ <fs>-flute_type }/{ vl_aux2 }|.

      "Posibles ubicaciones
      "En caso de recibir un código de máquina, esto determinará la ubicación destino para las
      "necesidades de transporte mediante la codificación Máquina + número de estación.
      IF <fs>-machine_code IS INITIAL.
        DATA(tl_lagp) = tl_lagp_hardcoded.
      ELSE.
        tl_lagp = tl_lagp_bd.
      ENDIF.


      "Datos interfase
      CLEAR: wl_interfase.
      wl_interfase-lgnum          = <fs>-warehouse_number.
      wl_interfase-benum          = <fs>-cinumber.
      wl_interfase-cinumber       = vl_cinumber.
      wl_interfase-start_date     = wl_ltbk-bdatu.
      wl_interfase-start_time     = wl_ltbk-bzeit.
      wl_interfase-desc_cliente   = <fs>-desc_cliente.
      wl_interfase-desc_cliente2  = <fs>-desc_cliente2.
      wl_interfase-end_date       = wl_ltbk-pdatu.
      wl_interfase-end_time       = wl_ltbk-pzeit.
      wl_interfase-cistatus       = <fs>-cistatus.
      wl_interfase-reel_width     = <fs>-reel_width.
      wl_interfase-quality        = <fs>-quality.
      wl_interfase-flute_type     = <fs>-flute_type.
      wl_interfase-planned_trim   = <fs>-planned_trim.
      wl_interfase-planned_lineal = <fs>-planned_lineal.
      wl_interfase-machine_code   = <fs>-machine_code.
      wl_interfase-hojas_teoricas = <fs>-hojas_teoricas.
      wl_interfase-fsccertificateinfo = <fs>-fsccertificateinfo.
      wl_interfase-upper_orderid      = |{ <fs>-upper_orderid ALPHA = IN }|.
      wl_interfase-lower_orderid      = |{ <fs>-lower_orderid ALPHA = IN }|.
      wl_interfase-texto              = <fs>-comment.

*--> INI FCARDONA - 12.04.2024 - PAPERREQ* CON STEPCONTRIBUTION

      "Comprobamos si viene relleno
      IF ( <fs>-lower_step_contribution IS NOT INITIAL AND <fs>-upper_step_contribution IS NOT INITIAL ). "con Step
        wl_interfase-stepcontribution_lower = <fs>-lower_step_contribution.
        wl_interfase-stepcontribution_upper = <fs>-upper_step_contribution.
      ELSE. "Sin step -> contingencia
        IF ( wl_interfase-upper_orderid IS NOT INITIAL ).
          IF ( wl_interfase-lower_orderid IS NOT INITIAL ).
            wl_interfase-stepcontribution_upper = '0.5'.
            wl_interfase-stepcontribution_lower = '0.5'.
          ELSE.
            wl_interfase-stepcontribution_upper = '1'.
            wl_interfase-stepcontribution_lower = '0'.
          ENDIF.
        ELSE.
          IF ( wl_interfase-lower_orderid IS NOT INITIAL ).
            wl_interfase-stepcontribution_upper = '0'.
            wl_interfase-stepcontribution_lower = '1'.
          ELSE.
            wl_interfase-stepcontribution_upper = '0'.
            wl_interfase-stepcontribution_lower = '0'.
          ENDIF.
        ENDIF.
      ENDIF.

*--> FIN FCARDONA - 12.04.2024 - PAPERREQ* CON STEPCONTRIBUTION

      "Tratamiento papeles
      DO 6 TIMES.
        DATA(vl_index) = sy-index.

        REFRESH: tl_ltbp, tl_ltbk.
        CLEAR wl_ltbp.

        ASSIGN COMPONENT |PAPER_STATION{ vl_index }|  OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs_paper_station>).
        ASSIGN COMPONENT |PAPER{ vl_index }LENGTH_M|  OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs_paper_length_m>).
        ASSIGN COMPONENT |PAPER{ vl_index }WEIGHT_KG| OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs_paper_weight_kg>).
        ASSIGN COMPONENT |MENGE_{ vl_index }| OF STRUCTURE wl_log TO FIELD-SYMBOL(<fs_log_menge>).
        ASSIGN COMPONENT |MATNR_{ vl_index }| OF STRUCTURE wl_log TO FIELD-SYMBOL(<fs_log_matnr>).
        ASSIGN COMPONENT |OK_{ vl_index }|    OF STRUCTURE wl_log TO FIELD-SYMBOL(<fs_log_ok>).
        ASSIGN COMPONENT |KO_{ vl_index }|    OF STRUCTURE wl_log TO FIELD-SYMBOL(<fs_log_ko>).
        CHECK <fs_paper_station> IS NOT INITIAL AND <fs_paper_station> NE '0'. " cvivo - a veces Némesis envía un 0 en vez de blanco

*--> INI FCARDONA 19.08.2024 - SAITÍ - Ubicación según onduladora
*
**** Se comenta por cambio de lógica
*
*        "Ubicación destino
*        IF ga_cla_nemesis = 'X'.
*          "Si se recibe una necesidad para la máquina Z107, si la necesidad figura sobre el tercer papel,
*          "sabemos que es la estación 3 de esta máquina, y que el código de ubicación será Z1073.
*          wl_ltbk-nlpla = |Z{ <fs>-machine_code }{ vl_index }|.
*        ELSEIF vl_cla_san_cayetano = 'X' AND <fs>-machine_code IS NOT INITIAL.
*          "La máquina se devuelve con el formato 04_xxx, donde xxx es el código de la máquina
*          "Las ubicaciones de SC tienen el formato ZSCxxx
*          DATA: tl_machine_code_split TYPE TABLE OF text20.
*
*          CLEAR tl_machine_code_split.
*          SPLIT <fs>-machine_code AT '_' INTO TABLE tl_machine_code_split.
*          IF lines( tl_machine_code_split ) >= 2.
*            wl_ltbk-nlpla = |ZSC{ tl_machine_code_split[ 2 ] }|.
*          ENDIF.
*
*          "TODO JCB 20.09.23. Hardcode en contracoladora. Tiene dos puntos de consumo!
*          "REVISAR HARDCODE
*          IF wl_ltbk-nlpla = 'ZSC102'.
*            wl_ltbk-nlpla = |{ wl_ltbk-nlpla }{ vl_index }|.
*          ENDIF.
*
*        ELSE.
*          DATA(vl_campo_nlpla) = |GA_NLPLA0{ vl_index }|. ASSIGN (vl_campo_nlpla) TO FIELD-SYMBOL(<fs_nlpla>).
*          wl_ltbk-nlpla = <fs_nlpla>.
*        ENDIF.

        "Ubicación destino
        IF ga_cla_nemesis = 'X'.

          "Si se recibe una necesidad para la máquina Z107, si la necesidad figura sobre el tercer papel,
          "sabemos que es la estación 3 de esta máquina, y que el código de ubicación será Z1073.
          wl_ltbk-nlpla = |Z{ <fs>-machine_code }{ vl_index }|.

        ELSEIF vl_cla_xativa = abap_true AND <fs>-machine_code IS NOT INITIAL.


          DATA(lv_field) = |GA_NLPLA0{ vl_index }|.
          ASSIGN (lv_field) TO FIELD-SYMBOL(<fs_nlpla>).

          IF ( sy-subrc = 0 ).

            "No viene ubicación
            <fs_nlpla> = |{ zcl_ap_parametros=>get_atributo1( clave = 'ZPAPERREQ' campo = 'NLPLA' valor = <fs>-machine_code ) }{ vl_index } |.
            wl_ltbk-nlpla = <fs_nlpla>.

          ENDIF.

        ELSEIF vl_cla_san_cayetano = 'X' AND <fs>-machine_code IS NOT INITIAL.
          "La máquina se devuelve con el formato 04_xxx, donde xxx es el código de la máquina
          "Las ubicaciones de SC tienen el formato ZSCxxx
          DATA: tl_machine_code_split TYPE TABLE OF text20.

          CLEAR tl_machine_code_split.
          SPLIT <fs>-machine_code AT '_' INTO TABLE tl_machine_code_split.
          IF lines( tl_machine_code_split ) >= 2.
            wl_ltbk-nlpla = |ZSC{ tl_machine_code_split[ 2 ] }|.
          ENDIF.

          "TODO JCB 20.09.23. Hardcode en contracoladora. Tiene dos puntos de consumo!
          "REVISAR HARDCODE
          IF wl_ltbk-nlpla = 'ZSC102'.
            wl_ltbk-nlpla = |{ wl_ltbk-nlpla }{ vl_index }|.
          ENDIF.

        ELSE.
          DATA(vl_campo_nlpla) = |GA_NLPLA0{ vl_index }|. ASSIGN (vl_campo_nlpla) TO <fs_nlpla>.
          wl_ltbk-nlpla = <fs_nlpla>.
        ENDIF.

*<-- FIN FCARDONA 19.08.2024 - SAITÍ - Ubicación según onduladora

        " sustitución, primero se excluye las de las sustituciones excluyentes y luego se procede a sustituir
        " de esta forma si la ubicaicón A sustituye excluyentemente a la B, las necesidades originales de la B
        " no se procesan
        IF wl_ltbk-nlpla IN r_excluir.
          CONTINUE.
        ENDIF.

        wl_ltbk-nlpla = COND #( WHEN wl_ltbk-nlpla IN r_sustitucion
                                THEN r_sustitucion[ low = wl_ltbk-nlpla ]-high ELSE wl_ltbk-nlpla ).

        IF wl_ltbk-nlpla NOT IN r_ubicaciones." cvivo - verificamos que la ubicación existe, para evitar fallos en XML
          IF wl_ltbk-nlpla NOT IN r_ubicaciones_skip.
            <fs_log_menge> = <fs_paper_length_m>.
            <fs_log_matnr> = <fs_paper_station>.
            <fs_log_ko>    = |No existe la ubicación { wl_ltbk-nlpla }|.
            gav_hay_error = abap_true.
            APPEND wl_log TO gat_log.
          ENDIF.

          CONTINUE.
        ENDIF.

        IF ga_cla_nemesis = 'X'.
          CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
            EXPORTING
              input        = <fs_paper_station>
            IMPORTING
              output       = wl_ltbp-matnr
            EXCEPTIONS
              length_error = 1
              OTHERS       = 2.

          check_material_exists(
            EXPORTING
              iv_matnr = wl_ltbp-matnr
              iv_werks = ga_werks
            EXCEPTIONS
              error_creacion = 1
              material_vacio = 5 ).

        ELSE.

          "FCC 18.05.2022 -> Mapeo de materiales NAVISION para ISC
          IF ga_lgnum = gac_lgnum_scy.
            dame_material_nav(
              EXPORTING
                i_matnr_nav          = <fs_paper_station>    " Número material ERP externo
                i_werks              = ga_werks              " Centro
              RECEIVING
                e_matnr              = wl_ltbp-matnr         " Número de material
              EXCEPTIONS
                no_material_found    = 1
                e_calidad_vacia      = 2
                e_valor_externo      = 3
                e_valor_sap          = 4
                e_sin_valor          = 5
                e_mat_zpim_not_found = 6
                OTHERS               = 7
            ).

          ELSEIF vl_cla_pacs = 'X' OR vl_cla_xativa = 'X'.
            dame_material_pacs(
              EXPORTING
                iv_str               = <fs_paper_station>
                iv_werks             = ga_werks
              CHANGING
                cv_matnr             =  wl_ltbp-matnr
              EXCEPTIONS
                no_material_found    = 1
                e_calidad_vacia      = 2
                e_valor_externo      = 3
                e_valor_sap          = 4
                e_sin_valor          = 5
                e_mat_zpim_not_found = 6
                OTHERS               = 7 ).

          ELSE.
            dame_material(
              EXPORTING
                iv_str               = <fs_paper_station>
                iv_werks             = ga_werks
              CHANGING
                cv_matnr             =  wl_ltbp-matnr
              EXCEPTIONS
                no_material_found    = 1
                e_calidad_vacia      = 2
                e_valor_externo      = 3
                e_valor_sap          = 4
                e_sin_valor          = 5
                e_mat_zpim_not_found = 6
                OTHERS               = 7 ).
          ENDIF.
        ENDIF.

        IF sy-subrc = 0.
          wl_ltbp-werks = ga_werks.

          "En algunas máquinas o estaciones se gestionan bobinas y en otras pallets (papel cortado en hojas).
          "Este es un concepto fijo por estación (una estación o consume pallets o consume bobinas).
          "En las estaciones en que se consuma pallets se tomará como cantidad el valor en el campo Hojas_teoricas,
          "y se corresponderán en SAP con unidades.
          READ TABLE tl_maquinas_gestion_palets TRANSPORTING NO FIELDS WITH KEY table_line = wl_ltbk-nlpla.
          IF sy-subrc = 0.
            wl_ltbp-menge = <fs>-hojas_teoricas.
            wl_ltbp-meins = 'ST'.
          ELSE.
            wl_ltbp-menge = <fs_paper_length_m>.
            wl_ltbp-meins = 'M'.
          ENDIF.

          wl_adit-nlpla = wl_ltbk-nlpla.
          wl_adit-menge = wl_ltbp-menge.
          wl_adit-meins = wl_ltbp-meins.
          zcl_wm_zwm_ltbk_adit_dao=>store_data_for_entry( is_data = wl_adit ).

*          wl_ltbk-tbktx = <fs>-comment. " cvivo - 65089

          READ TABLE tl_lagp ASSIGNING FIELD-SYMBOL(<fs_lagp>) WITH KEY lgnum = ga_lgnum
                                                                        lgpla = wl_ltbk-nlpla.
          IF sy-subrc = 0.
            wl_ltbk-lgnum = wl_ltbp-lgnum = <fs_lagp>-lgnum.
            wl_ltbk-nltyp = <fs_lagp>-lgtyp.
          ENDIF.

          APPEND wl_ltbp TO tl_ltbp.
          APPEND wl_ltbk TO tl_ltbk.

          IF vl_cla_pacs = space AND vl_cla_xativa = space. "FCARDONA ´Ajustes para SAITÍ
            crear_nts( EXPORTING pi_index       = sy-tabix
                                 iv_store_only  = abap_true
                                 iv_fsc         = COND #( WHEN <fs>-fsccertificateinfo IN t_fsc THEN abap_true ELSE abap_false )
                       CHANGING pt_ltbk         = tl_ltbk      " cvivo - Si es FSC lo almacenamos para tenerlo en cuenta en agrupación para generación de reservas
                                pt_ltbp         = tl_ltbp
                                pc_ok           = <fs_log_ok>
                                pc_ko           = <fs_log_ko> ).
            "movemos al log el material y la cantidad
            <fs_log_menge> = wl_ltbp-menge.
            <fs_log_matnr> = wl_ltbp-matnr.
          ENDIF.

        ELSE.
          IF sy-subrc <> 5. " si no hay material informado, no es un error
            <fs_log_menge> = <fs_paper_length_m>.
            <fs_log_matnr> = <fs_paper_station>.
            <fs_log_ko>    = error_material_log( EXPORTING pi_subrc = sy-subrc ).
            gav_hay_error = abap_true.
            APPEND wl_log TO gat_log.
          ENDIF.
        ENDIF.

        "Guardo ubicacion a tratar al borrar nts no modificadas
        DATA wl_lgpla_borrar_nts LIKE LINE OF tg_lgpla_borrar_nts.
        wl_lgpla_borrar_nts = VALUE #( sign = 'I' option = 'EQ' low = wl_ltbk-nlpla ).
        COLLECT wl_lgpla_borrar_nts INTO tg_lgpla_borrar_nts.



        "Tabla interfase OMP
        ASSIGN COMPONENT |PAPER_STATION{ vl_index }|  OF STRUCTURE wl_interfase TO FIELD-SYMBOL(<fs_intf_paper_station>).
        ASSIGN COMPONENT |PAPER{ vl_index }LENGTH_M|  OF STRUCTURE wl_interfase TO FIELD-SYMBOL(<fs_intf_paper_length_m>).
        ASSIGN COMPONENT |PAPER{ vl_index }WEIGHT_KG| OF STRUCTURE wl_interfase TO FIELD-SYMBOL(<fs_intf_paper_weight_kg>).
        ASSIGN COMPONENT |NLPLA{ vl_index }|          OF STRUCTURE wl_interfase TO FIELD-SYMBOL(<fs_intf_nlpla>).
        ASSIGN COMPONENT |MATNR{ vl_index }|          OF STRUCTURE wl_interfase TO FIELD-SYMBOL(<fs_intf_matnr>).

        <fs_intf_paper_station>   = <fs_paper_station>.
        <fs_intf_paper_length_m>  = <fs_paper_length_m>.
        <fs_intf_paper_weight_kg> = <fs_paper_weight_kg>.
        <fs_intf_nlpla>           = wl_ltbk-nlpla.
        <fs_intf_matnr>           = wl_ltbp-matnr.

      ENDDO.
      IF vl_cla_pacs = 'X' OR vl_cla_san_cayetano = 'X' OR vl_cla_xativa = 'X'. "FCARDONA - Ajustes SAITÍ.
        APPEND wl_interfase TO tl_intf_omp_sap.
      ENDIF.
    ENDLOOP.

*    DATA: vl_cla_step_up  TYPE xfeld,
*          vl_cla_step_low TYPE xfeld.
*    IF tl_intf_omp_sap IS NOT INITIAL AND vl_cla_pacs = 'X' OR vl_cla_xativa EQ abap_true. "FCARDONA - Ajustes SAITÍ

*--> INI FCARDONA - 11.04.2024 SAITÍ con STEPCONTRIBUTION

***--> Comento para reescribir lógica
*
*      SELECT aufnr, ci_number, stepcontribution
*        INTO TABLE @DATA(tl_cinumbers)
*        FROM zsppt_cinumbers
*        FOR ALL ENTRIES IN @tl_intf_omp_sap
*        WHERE aufnr = @tl_intf_omp_sap-upper_orderid OR
*              aufnr = @tl_intf_omp_sap-lower_orderid.
*      SORT tl_cinumbers BY ci_number DESCENDING.
*
*      LOOP AT tl_intf_omp_sap ASSIGNING FIELD-SYMBOL(<fs_intf_omp_sap>).
*        CLEAR: vl_cla_step_up, vl_cla_step_low.
*
*        IF <fs_intf_omp_sap>-upper_orderid IS NOT INITIAL.
*          READ TABLE tl_cinumbers ASSIGNING FIELD-SYMBOL(<fs_cinumbers>) WITH KEY aufnr = <fs_intf_omp_sap>-upper_orderid.
*          IF sy-subrc = 0.
*            <fs_intf_omp_sap>-stepcontribution_upper = <fs_cinumbers>-stepcontribution.
*            vl_cla_step_up = 'X'.
*          ENDIF.
*        ELSE.
*          vl_cla_step_up = 'X'.
*        ENDIF.
*
*        IF <fs_intf_omp_sap>-lower_orderid IS NOT INITIAL.
*          READ TABLE tl_cinumbers ASSIGNING <fs_cinumbers> WITH KEY aufnr     = <fs_intf_omp_sap>-lower_orderid.
*          IF sy-subrc = 0.
*            <fs_intf_omp_sap>-stepcontribution_lower = <fs_cinumbers>-stepcontribution.
*            vl_cla_step_low = 'X'.
*          ENDIF.
*        ELSE.
*          vl_cla_step_low = 'X'.
*        ENDIF.
*
*        IF vl_cla_step_up = space AND vl_cla_step_low = space.
*          <fs_intf_omp_sap>-stepcontribution_upper = <fs_intf_omp_sap>-stepcontribution_lower = '0.5'.
*        ELSEIF vl_cla_step_up = space.
*          <fs_intf_omp_sap>-stepcontribution_upper = 1 - <fs_intf_omp_sap>-stepcontribution_lower.
*        ELSEIF vl_cla_step_low = space.
*          <fs_intf_omp_sap>-stepcontribution_lower = 1 - <fs_intf_omp_sap>-stepcontribution_upper.
*        ENDIF.
*      ENDLOOP.

    FIELD-SYMBOLS: <fs_intf_omp_sap> TYPE zwm_intf_omp_sap.

*<-- FIN FCARDONA - 11.04.2024 SAITÍ con STEPCONTRIBUTION

    "Tratamiento datos interfase. Si no viene marco como inactivo
    IF vl_cla_pacs = 'X' OR vl_cla_san_cayetano = 'X' OR vl_cla_xativa EQ abap_true. "FCARDONA - Ajustes SAITÍ
      SELECT *
        INTO TABLE @DATA(tl_intf_bd_activas)
        FROM zwm_intf_omp_sap
        WHERE lgnum     = @ga_lgnum AND
              inactivo  = @space.
      LOOP AT tl_intf_bd_activas ASSIGNING FIELD-SYMBOL(<fs_intf_bd_activas>).
        READ TABLE tl_intf_omp_sap TRANSPORTING NO FIELDS WITH KEY lgnum         = <fs_intf_bd_activas>-lgnum
                                                                   benum         = <fs_intf_bd_activas>-benum
                                                                   machine_code  = <fs_intf_bd_activas>-machine_code. "FCARDONA 26.08.2024 - Adaptar para SAITI
        IF sy-subrc <> 0.
          <fs_intf_bd_activas>-inactivo = 'X'.
          <fs_intf_bd_activas>-aenam    = sy-uname.
          <fs_intf_bd_activas>-aedat    = sy-datum.
          <fs_intf_bd_activas>-aezet    = sy-uzeit.
          UPDATE zwm_intf_omp_sap FROM <fs_intf_bd_activas>.

          IF vl_cla_pacs = 'X' OR vl_cla_xativa EQ abap_true. "FCARDONA - Ajustes SAITÍ
            CALL FUNCTION 'ZSWM_ACT_NEC_CI_NUMBER'
              EXPORTING
                reg_in = <fs_intf_bd_activas>.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.


    "Grabación datos interfase
    IF tl_intf_omp_sap IS NOT INITIAL.
      SELECT *
        INTO TABLE @DATA(tl_intf_omp_sap_bd)
        FROM zwm_intf_omp_sap
        FOR ALL ENTRIES IN @tl_intf_omp_sap
        WHERE lgnum   = @tl_intf_omp_sap-lgnum AND
              benum   = @tl_intf_omp_sap-benum.

      LOOP AT tl_intf_omp_sap ASSIGNING <fs_intf_omp_sap>.
        DATA(vl_idx) = sy-tabix.

*APC20241121 Recuperamos el puesto de trabajo de PACS
        IF vl_cla_pacs = 'X' AND <fs_intf_omp_sap>-machine_code IS INITIAL.
          SELECT SINGLE arbpl FROM crhd
            INTO <fs_intf_omp_sap>-machine_code
           WHERE werks = ga_werks
             AND matyp = 'Z001'. "Onduladora
        ENDIF.

        READ TABLE tl_intf_omp_sap_bd ASSIGNING FIELD-SYMBOL(<fs_intf_omp_sap_bd>) WITH KEY lgnum = <fs_intf_omp_sap>-lgnum
                                                                                            benum = <fs_intf_omp_sap>-benum.
        IF sy-subrc = 0.
          DATA(wl_intf_omp_sap)     = <fs_intf_omp_sap>.
          DATA(wl_intf_omp_sap_bd)  = <fs_intf_omp_sap_bd>.

          CLEAR: wl_intf_omp_sap-mandt,     wl_intf_omp_sap_bd-mandt.
          CLEAR: wl_intf_omp_sap-ernam,     wl_intf_omp_sap-erdat,    wl_intf_omp_sap-erzet.
          CLEAR: wl_intf_omp_sap_bd-ernam,  wl_intf_omp_sap_bd-erdat, wl_intf_omp_sap_bd-erzet.
          CLEAR: wl_intf_omp_sap-aenam,     wl_intf_omp_sap-aedat,    wl_intf_omp_sap-aezet.
          CLEAR: wl_intf_omp_sap_bd-aenam,  wl_intf_omp_sap_bd-aedat, wl_intf_omp_sap_bd-aezet.

          IF wl_intf_omp_sap = wl_intf_omp_sap_bd.
            DELETE tl_intf_omp_sap INDEX vl_idx. CONTINUE.
          ELSE.
            <fs_intf_omp_sap>-ernam = <fs_intf_omp_sap_bd>-ernam.
            <fs_intf_omp_sap>-erdat = <fs_intf_omp_sap_bd>-erdat.
            <fs_intf_omp_sap>-erzet = <fs_intf_omp_sap_bd>-erzet.
            <fs_intf_omp_sap>-aenam = sy-uname.
            <fs_intf_omp_sap>-aedat = sy-datum.
            <fs_intf_omp_sap>-aezet = sy-uzeit.
          ENDIF.

        ELSE.
          <fs_intf_omp_sap>-ernam = sy-uname.
          <fs_intf_omp_sap>-erdat = sy-datum.
          <fs_intf_omp_sap>-erzet = sy-uzeit.
        ENDIF.
      ENDLOOP.

      MODIFY zwm_intf_omp_sap FROM TABLE tl_intf_omp_sap.
      COMMIT WORK AND WAIT.
    ENDIF.


    IF vl_cla_pacs = 'X' OR vl_cla_xativa EQ abap_true. "FCARDONA - Ajustes SAITÍ
      LOOP AT tl_intf_omp_sap ASSIGNING <fs_intf_omp_sap>.
        CALL FUNCTION 'ZSWM_ACT_NEC_CI_NUMBER'
          EXPORTING
            reg_in = <fs_intf_omp_sap>.
      ENDLOOP.
      COMMIT WORK AND WAIT.

    ELSE.
      " create reservation and nt's
      me->create_reservation( ).

      "3.- se envia notificacion necesidades creadas/borradas/modificadas
      "Solo enviamos el mail si hay algun error
      IF gav_hay_error IS NOT INITIAL.
        envia_mail_notificacion( ).
      ENDIF.
    ENDIF.

    o_log->log( msgty = 'I'
               message  = 'fIN proceso' ).
  ENDMETHOD.
