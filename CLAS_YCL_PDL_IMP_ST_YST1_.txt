
class YCL_PDL_IMP_ST_YST1 definition
  public
  final
  create public .

public section.

  interfaces IF_PDL_ADRV .

  types:
    BEGIN OF Y_PAGENUMS,
      Name type string,
      Num type i,
    END OF Y_PAGENUMS .
  types:
    BEGIN OF Y_POINT,
    X type i, Y type i,
    END OF Y_POINT .
  types:
    BEGIN OF Y_FONTINFO,
    FONTFAMILY(8) TYPE c,
    FONTSIZE(3) TYPE C,
    BOLD(1) TYPE C,
    ITALIC(1) TYPE C,
    CHWIDTH(5) TYPE C,
    PROPFLAG(1) TYPE C,
    PC1(5) TYPE C,
    PC2(5) TYPE C,
    CODEPAGE(4)  TYPE C,
    SPACEWIDTH(5)  TYPE C,
    LANGKEY(1) TYPE C,
    POSTENCODE(1) TYPE C,
    SCALEFONT(1)  TYPE C,
    PRINTERFONTPROP(1)  TYPE C,
    SOFTFONT(1) TYPE C,
    END OF Y_FONTINFO .
  types:
    BEGIN OF Y_BC_CMD,
      SAPBARCODE(8) TYPE C,
      MAXWIDTH(5) TYPE C,
      MAXHEIGHT(5) TYPE C,
      STRINGLEN(2) TYPE C,
      PCPREFIX(5) TYPE C,
      PCSUFFIX(5) TYPE C,
      BARCTYPE(8) TYPE C,
      BARCROT(3) TYPE C,
      ALIGNBASELINE(1) TYPE C,
      DATALEN(5) TYPE C,
      END OF Y_BC_CMD .
  types:
    BEGIN OF Y_BMP_INFO,
      PIX_WIDTH TYPE I,
      PIX_HEIGHT  TYPE I,
      DPI TYPE I,
      BPP TYPE I,
      BYTESIZE TYPE I,
      COLORTABLESIZE TYPE I,
      SATO_WIDTH TYPE I,
      SATO_HEIGHT TYPE I,
      END OF Y_BMP_INFO .
  types:
    BEGIN OF Y_RDJ_CMD,
      MAGICBYTES(8) TYPE C,
      DUMMY1(4) TYPE C,
      FORMATID(1) TYPE C,
      SUBFORMATID(1) TYPE C,
      PARM1(1) TYPE C,
      PARM2(1) TYPE C,
      BMP_W_TWIP(4) TYPE C,
      BMP_H_TWIP(4) TYPE C,
      BMP_W_PIX(4) TYPE C,
      BMP_H_PIX(4) TYPE C,
      BMP_DPI(2) TYPE C,
      BMP_BPP(2) TYPE C,
      COLOR_SIZE(2) TYPE C,
      BMP_BYTES(4) TYPE C,
      BMP_ID(90) TYPE C,
     END OF Y_RDJ_CMD .
  types:
    BEGIN OF Y_ST_STORE,
       ST_OTF type TDPRINTPAR,
       ST_FONT type Y_FONTINFO,
       ST_SAPCHAR type c LENGTH 1,
     END OF Y_ST_STORE .
  types:
    Y_ST_TBL type STANDARD TABLE OF Y_ST_STORE .

  constants C_RETCODE_OK type I value 0. "#EC NOTEXT
  constants C_RETCODE_ERR_ANY type I value 1. "#EC NOTEXT
  data G_PREV_COMMAND type STRING .
  data G_FONTINFO type Y_FONTINFO .
  data G_FONTFAMILY type STRING .
  data G_FONTITALIC type STRING .
  data G_FONTCONTROL type RSPOPRCTL .
  data G_CHARWIDTH type I .
  data G_FONTSIZE type I .
  data G_PAGECOUNT type STRING value 1. "#EC NOTEXT .
  data G_DEVICETYPE type STRING .
  data G_PAGELENGTH type STRING .
  data G_PAGEWIDTH type STRING .
  data G_PRINTCONTROL type RSPOPRCTL .
  data G_PRINTCONTROL2 type RSPOPRCTL .
  constants G_8DOTS_DPI type I value 203. "#EC NOTEXT
  constants G_12DOTS_DPI type I value 305. "#EC NOTEXT
  constants G_24DOTS_DPI type I value 609. "#EC NOTEXT

  methods CONSTRUCTOR .
protected section.
private section.

  constants C_MYCLASSNAME type STRING value 'CL_PDL_IMP_SATO'."#EC NOTEXT
  data G_RESOLUTION type I value 300 ."#EC NOTEXT
  data G_CUR_XPOS_TW type I value 0 ."#EC NOTEXT
  data G_CUR_YPOS_TW type I value 0 ."#EC NOTEXT
  data C_CRNL type XSTRING .
  data G_PG_XOFFSET type I value 0 ."#EC NOTEXT
  data G_PG_YOFFSET type I value 0 ."#EC NOTEXT
  data G_PG_XOFFSET_S type STRING value '+' ."#EC NOTEXT
  data G_PG_YOFFSET_S type STRING value '+' ."#EC NOTEXT
  data G_TWIP2DOT_FACTOR type F value '0.1409722' ."#EC NOTEXT
  data G_PIXEL2DOT_FACTOR type F value '0.1716667' ."#EC NOTEXT
  data G_FNTH2DOT_FACTOR type F value '0.2819444' ."#EC NOTEXT
  data G_ESC_GB type XSTRING .
  data G_ESC_ROT type XSTRING .
  data G_BC128A_TBL type STRING .
  data G_END_POS_FLAG type I value 0 ."#EC NOTEXT
  data G_MULTIPLE_CUT_VALUE type STRING .
  data G_CUT_SEGMENT_VALUE type STRING .
  data G_CMD_CUTCT_VALUE type STRING.
  data G_CMD_CUTNC_VALUE type STRING.
  data G_CMD_CUTB_VALUE type STRING.
  data G_CUTTING__OP_FLAG type I value 0 ."#EC NOTEXT
  data G_CUTTING__OPNC_FLAG type I value 0 ."#EC NOTEXT
  data G_AUTO_LF_VALUE type STRING .
  data G_LABEL_SIZE_FLAG type I value 0 ."#EC NOTEXT
  data G_START_POINT_FLAG type I value 0 ."#EC NOTEXT
  data G_PREV_FONT type Y_FONTINFO .
  data G_PATTERN_SJMAP type STRING .
  class-data G_FSIZE_RDB_08 type STRING .
  class-data G_FSIZE_RDB_12 type STRING .
  class-data G_FSIZE_RDB_24 type STRING .
  data G_ST_TBL type Y_ST_TBL .
  data G_PREVLINE_MT type Y_POINT .
  data G_CODE93_LUT1 type STRING .
  data G_CODE93_LUF1 type XSTRING .
  data G_CODE93_LUT2 type STRING .
  data G_CODE93_LUT3 type STRING .
  data G_TSP0A type TSP0A .
  data G_PATTERN_KPMAP type STRING .
  data G_PC_NBTCODE39_R13 type XSTRING .
  data G_PC_NBTPDF417 type XSTRING .
  data G_PC_NBTPDF417_J type XSTRING .
  data G_PC_NBTCODE93 type XSTRING .
  data G_PC_NBTCODE25_R13 type XSTRING .
  data G_PC_NBTCODE128 type XSTRING .
  data G_PC_NBTRFID type XSTRING .
  data G_ARG_OPT type C .
  data G_PC_NBTCODE39_R12 type XSTRING .
  data G_PC_NBTCODE39_R25 type XSTRING .
  data G_PC_NBTCODE25_R12 type XSTRING .
  data G_PC_NBTCODE25_R25 type XSTRING .
  data G_PC_NBTDNCMD type XSTRING .
  data G_WINDOW_90 type STRING .
  data G_WINDOW_180 type STRING .
  data G_WINDOW_270 type STRING .
  data G_CUR_PAGE type STRING .
  data G_CUR_WINDOW type STRING .
  data G_0_DEGREE type XSTRING .
  data G_90_DEGREE type XSTRING .
  data G_180_DEGREE type XSTRING .
  data G_270_DEGREE type XSTRING .
  data ESC_OUTLINE type XSTRING .
  data ESC_0_OUTLINE type XSTRING .
  data ESC_1_OUTLINE type XSTRING .
  data ESC_8_OUTLINE type XSTRING .
  data ESCA1 type XSTRING .
  data ESCA3 type XSTRING .
  data ESCFW type XSTRING .
  data ESCKC type XSTRING .
  data ESCP0 type XSTRING .
  data ESCPS type XSTRING .
  data ESCXM type XSTRING .
  data ESC_A type XSTRING .
  data ESC_H type XSTRING .
  data ESC_M type XSTRING .
  data ESC_P type XSTRING .
  data ESC_Q type XSTRING .
  data ESC_V type XSTRING .
  data ESC_Z type XSTRING .
  data:
    G_PAGENUMS type TABLE OF Y_PAGENUMS .

  methods CONVERTOP
    importing
      !OTF_DATA type TDPRINTPAR .
  methods CONVERTEP .
  methods CONVERTIN
    importing
      !OTF_DATA type TDPRINTPAR .
  methods CONVERTMT
    importing
      !OTF_DATA type TDPRINTPAR .
  methods CONVERTLI
    importing
      !OTF_DATA type TDPRINTPAR .
  methods CONVERT_COMMAND .
  methods CONVERTOPEN
    importing
      !OTF_DATA type TDPRINTPAR .
  methods CONVERT_FC
    importing
      !OTF_DATA type TDPRINTPAR .
  methods BARCODE_MOD43_CHECKSUM
    importing
      !BARCODESTRING type STRING
    returning
      value(OUTPUT) type STRING .
  methods BARCODE_CHECKSUM
    importing
      !BARCODETYPE type STRING
      !BARCODESTRING type STRING
    returning
      value(XOUTPUT) type STRING .
  methods BMP_RESIZE
    importing
      !BMP_INFO type Y_BMP_INFO
      !INPUT type XSTRING
    exporting
      !OUTPUT type XSTRING
      !NEWWIDTH type I
      !NEWHEIGHT type I .
  methods BMP_PADLINE
    importing
      !BMP_INFO type Y_BMP_INFO
    returning
      value(OUTPUT) type XSTRING .
  methods MAPCODE128B
    importing
      !INPUT type STRING
      !NFLAG type I default -1
    returning
      value(OUTPUT) type STRING .
  methods MAPCODE128A
    importing
      !INPUT type STRING
      !NFLAG type I default -1
      !ST type C default ' '
    returning
      value(OUTPUT) type STRING .
  methods MAPBC128_N
    importing
      !INPUT type STRING
    returning
      value(OUTPUT) type STRING .
  methods BC128_INVALIDATEINVO
    importing
      !INPUT type STRING
    returning
      value(OUTPUT) type STRING .
  methods BC128_MAPINVO
    importing
      !INPUT type STRING
    returning
      value(OUTPUT) type STRING .
  methods MAPCODE128C
    importing
      !INPUT type STRING
      !NFLAG type I default -1
      !ST type C default ' '
    returning
      value(OUTPUT) type STRING .
  methods BC128A_FIND99
    importing
      !INPUT type STRING
    returning
      value(OUTIDX) type I .
  methods MAPBC128_AUTO
    importing
      !INPUT type STRING
    returning
      value(OUTPUT) type STRING .
  methods MAPCODE93
    importing
      !INPUT type STRING
    returning
      value(XOUTPUT) type XSTRING .
  methods MAPPDF417
    importing
      !INPUT type STRING
    returning
      value(OUTPUT) type XSTRING .
  methods OUTPUT_NEWLINE .
  methods CONVERTCH
    importing
      !OTF_DATA type TDPRINTPAR .
  methods INIT_SJMAP .
  methods ADD_TO_PATTERN
    importing
      !P_IN type X
      !P_OUT type X .
  methods GETPREFIXEDFONTSIZERDB
    importing
      !FONTSIZEPT type STRING
    exporting
      !FWIDTH type STRING
      !FHEIGHT type STRING .
  methods FILLLOOKUPFORRDBFONTSIZE .
  methods NEWST_STOREDATA
    importing
      !OTF_DATA_STRING type TDPRINTPAR
      !X type I
      !Y type I
      !ISSAPCHAR type C default ' ' .
  methods NEWST_PROCESS .
  methods NEWST_PROCESS_ST
    importing
      !ST_INFO type Y_ST_STORE
      !MT_POS type Y_POINT
      !FIRSTTIME type C
      !MAXFONTSIZE type I
      !WINDOWNAME type STRING
    changing
      !PREVFONTSIZE type I .
  methods ADD_TRAN_PAIR
    importing
      !P_IN type X
      !P_OUT type X
    changing
      !MAPSTRING type STRING .
  methods GET_NEAREST_RATIO
    importing
      !GOF_RATIO type STRING
    returning
      value(SATO_RATIO) type STRING .
  methods PROCESS_RFID
    importing
      !ACSCODE type STRING
      !LOCKMASK type STRING
      !KILLCODE type STRING
      !BS_COMMAND type STRING
    returning
      value(TEXT1) type STRING .
  methods PROCESS_ROTATION_CMD
    importing
      !ROTATION_90 type STRING
      !ROTATION_180 type STRING
      !ROTATION_270 type STRING
      !WINDOW_NAME type STRING
    returning
      value(RESULT) type STRING .
  methods SAVEPAGENUMBERS
    importing
      !INPUT type STRING .
  methods GET_PAGENUMBER
    importing
      !PAGENAME type STRING
    returning
      value(PAGENUM) type STRING .
  methods OUTPUT_ROTATION .
endclass. "YCL_PDL_IMP_ST_YST1 definition
class YCL_PDL_IMP_ST_YST1 implementation.
* Modulus 10 Check Sum Generator
METHOD BARCODE_CHECKSUM.
  DATA: string(40) TYPE c.
  DATA: i TYPE i, m TYPE i, nn TYPE i, nutz TYPE i, sum1 TYPE i.
  DATA: l TYPE i. ", pruef TYPE i.
  DATA: oddtotal TYPE i, eventotal TYPE i.

  DATA s1 TYPE c.
  DATA: factor TYPE i.", rem TYPE i.
  DATA text1 TYPE string.
  sum1 = 0.
  IF barcodetype EQ '2OF5'.
    l = STRLEN( barcodestring ) - 1.
    factor = 3.
    TRY.
      WHILE l >= 0.
        sum1 = sum1 + barcodestring+l(1) * factor.
        factor = 4 - factor.
        l = l - 1.
      ENDWHILE.
    CATCH CX_SY_CONVERSION_NO_NUMBER.
        sum1 = -1.
    CLEANUP.

    ENDTRY.

  ElseIF barcodetype EQ 'UPC_A'.
    l = STRLEN( barcodestring ).
    IF l = 11. "UPC data must be 11 digits
      oddtotal = barcodestring+0(1) + barcodestring+2(1) +
                  barcodestring+4(1) + barcodestring+6(1) +
                  barcodestring+8(1) + barcodestring+10(1).
      oddtotal = oddtotal * 3.

      eventotal = barcodestring+1(1) + barcodestring+3(1) +
                  barcodestring+5(1) + barcodestring+7(1) +
                  barcodestring+9(1).

      sum1 = oddtotal + eventotal.

    ENDIF.
  ELSEIF barcodetype EQ 'EAN13' OR
    barcodetype EQ 'EAN8'.

    IF barcodetype EQ 'EAN8'. " add 5 '0' in front
      CONCATENATE '00000' barcodestring INTO string.
    ELSE.
      string = barcodestring.
    ENDIF.

    l = STRLEN( string ).
    IF l > 1.
      i = l - 1.
      nn = 1.
      DO l TIMES.
        s1 = string+i(1).
        MOVE s1 TO nutz.
        m = nn MOD 2.
        IF m EQ 1.
          sum1 = sum1 + ( nutz * 3 ).
        ELSE.
          sum1 = sum1 + nutz.
        ENDIF.

        nn = nn + 1.
        i = i - 1.
      ENDDO.

    ENDIF.

  ENDIF. " end of EAN13 and EAN8 checksum
  m = sum1 MOD 10.
  if m > 0.
    m = 10 - m.
  endif.
  text1 = m.
  CONDENSE text1 NO-GAPS.

  XOUTPUT = text1.
ENDMETHOD.
method ADD_TO_PATTERN.
  data: l_c_in  type c,
        l_c_out type c.

  try.
    l_c_in = cl_abap_conv_in_ce=>uccp( p_in ).
    l_c_out = cl_abap_conv_in_ce=>uccp( p_out ).
    catch cx_sy_conversion_codepage.
      exit.
  endtry.

  "concatenate G_PATTERN_SJMAP l_c_in l_c_out into G_PATTERN_SJMAP RESPECTING BLANKS.
  concatenate G_PATTERN_SJMAP l_c_in l_c_out into G_PATTERN_SJMAP.

endmethod.
method ADD_TRAN_PAIR.
    data: l_c_in  type c,
        l_c_out type c.

  try.
    l_c_in = cl_abap_conv_in_ce=>uccp( p_in ).
    l_c_out = cl_abap_conv_in_ce=>uccp( p_out ).
    catch cx_sy_conversion_codepage.
      exit.
  endtry.

  "concatenate G_PATTERN_SJMAP l_c_in l_c_out into G_PATTERN_SJMAP RESPECTING BLANKS.
  concatenate MAPSTRING l_c_in l_c_out into MAPSTRING.

endmethod.
method BARCODE_MOD43_CHECKSUM.
  Data: CHARSET TYPE STRING.
  DATA: LEN TYPE i.    " LEN of the given Barcode String
  DATA: TOTAL TYPE i.  " Total sum of Barcode String
  DATA: INDEX TYPE i.  " Position of Barocode String in loop
  DATA: POS TYPE i.    " Position of the Character List in loop
  DATA: REM TYPE i.    " Remainder after modulus 43
  DATA: text1 TYPE STRING. " output string
  DATA: CHECKDIGIT TYPE C.

  CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%'.

  LEN  = STRLEN( BARCODESTRING ).
  TOTAL = 0.
  INDEX = 0.

  DO LEN TIMES.
    POS = -1.
    FIND BARCODESTRING+INDEX(1) in CHARSET MATCH OFFSET POS.
    if POS <> -1.
      TOTAL = TOTAL + POS.
    ENDIF.
    INDEX = INDEX + 1.
  ENDDO.
  REM = TOTAL mod 43.
  CHECKDIGIT = CHARSET+REM(1).
  CONCATENATE CHECKDIGIT '' INTO text1.
  CONDENSE text1 NO-GAPS.
  OUTPUT = text1.
endmethod.
method BC128_INVALIDATEINVO.
data: len type i, tmpi1 type i, tmpi2 type i,
        sapBset type string, moff type i.

  sapBset = '0123456789<=:;'.
  output = ''.
  len  = strlen( input ).
  len = len - 1.

  "--------------Correction Start--------------
  do len times.
      tmpi1 = sy-index - 1. "syindex start form 1
      if input+tmpi1(1) = '>'.
        tmpi2 = tmpi1 + 1.

        moff = -1.
        FIND input+tmpi2(1) IN sapBset MATCH OFFSET moff.
        if moff > -1. "match found correct one
          CONCATENATE output input+tmpi1(1) into output.
        endif.
      else.
        CONCATENATE output input+tmpi1(1) into output.
      endif.
  enddo.

  if input+len(1) <> '>'. "Last one is > error skip
    CONCATENATE output input+len(1) into output.
  endif.
  "--------------Correction end--------------
endmethod.
method BC128_MAPINVO.
  output = input.
  REPLACE ALL OCCURRENCES OF '><' IN output WITH '^'.
  REPLACE ALL OCCURRENCES OF '>0' IN output WITH '>J'.
  REPLACE ALL OCCURRENCES OF '>1' IN output WITH '>?'.
  REPLACE ALL OCCURRENCES OF '>2' IN output WITH '>@'.
  REPLACE ALL OCCURRENCES OF '>3' IN output WITH '>A'.
  REPLACE ALL OCCURRENCES OF '>4' IN output WITH '>B'.
  REPLACE ALL OCCURRENCES OF '>5' IN output WITH '>C'.
  REPLACE ALL OCCURRENCES OF '>6' IN output WITH '>D'.
  REPLACE ALL OCCURRENCES OF '>7' IN output WITH '>E'.
  REPLACE ALL OCCURRENCES OF '>8' IN output WITH '>F'.
  REPLACE ALL OCCURRENCES OF '>9' IN output WITH '>G'.
  REPLACE ALL OCCURRENCES OF '>:' IN output WITH '>H'.
  REPLACE ALL OCCURRENCES OF '>;' IN output WITH '>I'.
  REPLACE ALL OCCURRENCES OF '>=' IN output WITH '~'.
endmethod.
method BC128A_FIND99.
  data: len type i, tmpi type i, idx type i.
  outidx = -1.
  len = strlen( input ).
  tmpi = len mod 2.
  if tmpi <> 0.
    len = len - 1.
  endif.
  if len < 0.
    len = 0.
  else.
    len = len / 2.
  endif.

  idx = 0.
  do len times.
    if input+idx(2) = '99'.
      outidx = idx.
      exit.
    endif.
    idx = idx + 2.
  enddo.
endmethod.
method BMP_PADLINE.
  data: bmp_h_sato_pix type i, tmpi type i, hex1 type x.

    bmp_h_sato_pix = bmp_info-sato_height * 8.
    if bmp_h_sato_pix > bmp_info-PIX_HEIGHT.
      tmpi = bmp_h_sato_pix - bmp_info-PIX_HEIGHT.
      tmpi = bmp_info-sato_width * tmpi.
      hex1 = '00'.
      clear output.
      do tmpi times.
        CONCATENATE output hex1 into output in BYTE MODE.
      enddo.
    endif.
endmethod.
method BMP_RESIZE.
  data: "dest_stride type i, "src_stride type i,
        dest_width type i, src_width type i,
        dest_height type i, src_height type i,
        dx type i, dy type i, ssx type i, ssy type i,
        scaleX type f, scaleY type f,
        byteIdx type i, bitIdx type i, bitValue type x,"destbitValue type x,
        tmpf type f, tmpi type i , outputhex type x, "postHex type xstring,
        tmpi1 type i, tmpi2 type i
        . "mydebug type i,
*  if bmp_info-pix_width = 157 and bmp_info-pix_height = 27.
*    mydebug = 1.
*  else.
*    mydebug = 0.
*  endif.
* mydebug = 0.
*  if mydebug = 1.
*    "TBL_LINE = '383940414243444546474849'.
*    data : fname type string value 'C:\Documents and Settings\C5107374\SapWorkDir\test.txt'.
*    types: BEGIN OF tb1_struc,
*          name type string,
*          data type xstring,
*      END OF tb1_struc.
*    data: TBL_LINE type STANDARD TABLE OF tb1_struc INITIAL SIZE 0.
*    "TBL_LINE-INDEX = 1.
*    data: line type tb1_struc.
*
*
*  endif.
  IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                     MESSAGE = 'Resize Image' ). "#EC NOTEXT

  src_width =  bmp_info-ByteSize / bmp_info-PIX_HEIGHT.
  src_width = src_width * 8.
  src_height = bmp_info-PIX_HEIGHT.
  tmpf = g_resolution.
  scaleX = tmpf / bmp_info-dpi.
  scaleY = tmpf / bmp_info-dpi.
  "scaleX = '9.0'. scaleY = '9.0'.
  dest_width = scaleX *  src_width.
  dest_height = scaleY * src_height.
  scaleX = '1.0' / scaleX.
  scaleY = '1.0' / scaleY.
  tmpf = dest_width mod 8.
  if tmpf > 0.
    dest_width = dest_width div 8.
    dest_width = dest_width + 1.
    dest_width = dest_width * 8.
    scaleX = src_width / dest_width.
    IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                      MESSAGE = 'padding added' ).  "#EC NOTEXT
  endif.
  clear outputhex.
  "dest_width = src_width.
  "dest_height = src_height.
  "scaleX = 1.
  "scaleY = 1.
  DO dest_height times.
    dy = sy-index - 1.
    do dest_width times.
      dx = sy-index - 1.

      """"""""""""""""""""""""""""
      "byteidx = dx + ( dy * dest_width ).
      "bitIdx =  byteidx mod 8 .
      "byteidx =  byteidx / 8 .
      "bitvalue = INPUT+byteidx(1).
      "tmpi = xstrlen( output ).
      "if tmpi = 0 or byteidx = tmpi1.
      "  CONCATENATE output outputhex into output in BYTE MODE.
      "elseif  byteidx = tmpi.
      " tmpi2 = xstrlen( output ) - 1.
      " CONCATENATE output(tmpi2) outputhex into output in BYTE MODE.
      "elseif byteidx < tmpi1.
      "  tmpi2 = xstrlen( output ) - 1.
      "  CONCATENATE output(byteidx) outputhex posthex into output in BYTE MODE.
      "endif.
      """""""""""""""""""""""""
      ssx = floor( scaleX * dx ).
      ssy = floor( scaleY * dy ).
      "ssx =  ( scaleX * dx ).
      "ssy =  ( scaleY * dy ).
      byteidx = ssx + ( ssy * src_width ).
      bitIdx = byteidx mod 8 .
      tmpi = byteidx mod src_width.
      if tmpi < bmp_info-pix_width.
       byteidx =   byteidx div 8   .
       if byteidx >= bmp_info-bytesize.
         byteidx = bmp_info-bytesize - 1.
         IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                       MESSAGE = 'byteidx overshoot' ). "#EC NOTEXT
       endif.
       bitvalue = INPUT+byteidx(1).

       "bitvalue = bitvalue bit-and G_HEXBITINDEX+bitidx(1).
       "if bitvalue > 0.
       "  bitvalue = 1.
       "else.
       "  bitvalue = 0.
       "endif.
       bitidx = bitidx + 1.
       get bit bitidx of bitvalue into bitvalue.
      else.
        bitvalue = 0.
      endif.

      byteidx = dx + ( dy * dest_width ).
      bitIdx = ( byteidx mod 8 ).
      byteidx =   byteidx div 8  .
      tmpi =  xstrlen( output ).
      tmpi1 = tmpi - 1.
      if tmpi1 < 0.
        tmpi1 = 0.
      endif.
      "if tmpi = 0 or byteidx = tmpi.
      "  clear outputhex.
      "elseif byteidx = tmpi1.
      "  outputhex = output+byteidx(1).
      "elseif byteidx < tmpi1.
      "  outputhex = output+byteidx(1).
      "  tmpi2 = byteidx + 1.
      "  posthex = output+tmpi2.
      "endif.
      if byteidx < tmpi.
        outputhex = output+byteidx(1).
      else.
        clear outputhex.
      endif.
      bitidx = bitidx + 1.
      set bit bitidx of outputhex to bitvalue.
      if byteidx = tmpi.
        CONCATENATE output outputhex into output in BYTE MODE.
      else.

        tmpi2 = xstrlen( output ) - 1.

        CONCATENATE output(tmpi2) outputhex  into output in BYTE MODE.

      endif.
      "if tmpi = 0 or byteidx = tmpi1.
      "  CONCATENATE output outputhex into output in BYTE MODE.
      "elseif  byteidx = tmpi.
      "  tmpi2 = xstrlen( output ) - 1.
      "  CONCATENATE output(tmpi2) outputhex into output in BYTE MODE.
      "elseif byteidx < tmpi1.
      "  tmpi2 = xstrlen( output ) - 1.
      "  CONCATENATE output(byteidx) outputhex posthex into output in BYTE MODE.
      "endif.

      "destbitvalue = OUTPUT+byteidx(1).


    enddo.
  enddo.

  newwidth = dest_width. newheight = dest_height.
  IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                      MESSAGE = 'Resize Image Done' ).  "#EC NOTEXT
*  if mydebug = 1.
*    data chstr3(3) type c.
*    unpack dest_width to chstr3.
*    CONCATENATE chstr3 '' into line-name.
*    unpack dest_height to chstr3.
*    CONCATENATE line-name chstr3 '' into line-name.
*    line-data = output.
*    append line to tbl_line.
*    call function 'GUI_DOWNLOAD'"'GUI_UPLOAD'"'GUI_DOWNLOAD'
*      exporting
*         filename = fname
*         filetype = 'ASC'
*          tables
*          data_tab = TBL_LINE.
*  endif.
endmethod.
method CONSTRUCTOR.

* Commands for New Barcode Technology
  G_PC_NBTCODE39_R13 = '1B4231'.
  G_PC_NBTPDF417 = '1B424B'.
  G_PC_NBTPDF417_J = '1B324431302C'.
  G_PC_NBTCODE93 = '1B4243'.
  G_PC_NBTCODE25_R13 = '1B4232'.
  G_PC_NBTCODE128 = '1B4247'.
  G_PC_NBTRFID = '1B495030653A7A'.
  G_PC_NBTCODE39_R12 = '1B4431'.
  G_PC_NBTCODE39_R25 = '1B424431'.
  G_PC_NBTCODE25_R12 = '1B4432'.
  G_PC_NBTCODE25_R25 = '1B424432'.
  G_PC_NBTDNCMD = '1B444E'.

* SBPL Commands
  ESC_OUTLINE = '1B243D'.
  ESC_0_OUTLINE = '301B243D'.
 " ESC_1_OUTLINE = '311B243D'.
  ESC_8_OUTLINE = '381B243D'.
  ESCA1 = '1B4131'.
  ESCA3 = '1B4133'.
  ESCFW = '1B4657'.
  ESCKC = '1B4B4331'.
  ESCP0 = '1B5030'.
  ESCPS = '1B5053'.
  ESCXM = '1B584D'.
  ESC_A = '1B41'.
  ESC_H = '1B48'.
  ESC_M = '1B4D'.
  ESC_P = '1B50'.
  ESC_Q = '1B51'.
  ESC_V = '1B56'.
  ESC_Z = '1B5A'.


  G_ESC_GB = '1B4742'.
*  G_HEXBITINDEX = '0102040810204080'.
*  G_HEXBITINDEXINV = 'FEFDFBF7EFDFBF7F'.
  G_ESC_ROT = '1B25'.

  G_BC128A_TBL = ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'.

  INIT_SJMAP( ).

  "Lookup map for RDB Font size
  FILLLOOKUPFORRDBFONTSIZE( ).

  "Lookup map for Code93
  G_CODE93_lut1 = '''U''A''B''C''D''E(A(B(C(F(G(H(I(J(L(Z''F''G''H''I''J''V''K''L''M''N''O''W''P''Q''R''S''T'.
  G_CODE93_luf1 = '001B1C1D1E1F212223262728292A2C3A3B3C3D3E3F405B5C5D5E5F607B7C7D7E7F'.
  G_CODE93_lut2 = '&A&B&C&D&E&F&G&H&I&J&K&L&M&N&O&P&Q&R&S&T&U&V&W&X&Y&Z'.
  G_CODE93_lut3 = ')A)B)C)D)E)F)G)H)I)J)K)L)M)N)O)P)Q)R)S)T)U)V)W)X)Y)Z'.

  " Add map for fix Space char for Kor font in GT
  G_PATTERN_KPMAP = ''.
  G_PATTERN_KPMAP = ` `. "<=== must be this way to put 'space'0x2000 (32)
                        " without ` ` 2000 space will be gone in concat func
  CALL METHOD me->ADD_TRAN_PAIR
    EXPORTING
      P_IN      = '0020'
      P_OUT     = '3000'
    CHANGING
      MAPSTRING = G_PATTERN_KPMAP.


" For Rotation
  G_0_DEGREE = '1B2530'.
  G_90_DEGREE = '1B2531'.
  G_180_DEGREE = '1B2532'.
  G_270_DEGREE = '1B2533'.

endmethod.
method CONVERT_COMMAND.
  Data mara_tt TYPE RSPO_FREE_PARAMS.
  DATA mytext TYPE string.

  Data CMD_PRINT_SPEED TYPE XSTRING.
  DATA CMD_PRINT_DARKNESS TYPE XSTRING.
  DATA CMD_PRINT_DARKNESS_F TYPE XSTRING.
  DATA CMD_LABEL_SIZE TYPE XSTRING.
  DATA CMD_START_POINT TYPE XSTRING.
  DATA CMD_ENLARGEMENT_AREA TYPE XSTRING.
  DATA CMD_STANDARD_AREA TYPE XSTRING.
  DATA CMD_CUT_OPERATION TYPE XSTRING.

  DATA CMD_ESC_A TYPE XSTRING.
  DATA CMD_ESC_Z TYPE XSTRING.
  DATA CMD_ESC TYPE XSTRING.

  DATA CMD_PRINTMOTION_MODE TYPE XSTRING.
  DATA CMD_LABELSTOP_OFFSET TYPE XSTRING.

  DATA hasCmd TYPE i.

  CMD_ESC = '1B'.
  CMD_ESC_A = '1B41'.
  CMD_ESC_Z = '1B5A'.
  CMD_PRINT_SPEED = '1B4353'.
  CMD_PRINT_DARKNESS = '1B2345'.
  CMD_PRINT_DARKNESS_F = '1B2346'.
  CMD_LABEL_SIZE = '1B4131'.
  CMD_START_POINT = '1B4133'.
  CMD_ENLARGEMENT_AREA = '1B4158'.
  CMD_STANDARD_AREA = '1B4152'.
  CMD_CUT_OPERATION = '1B7E42'.
  CMD_PRINTMOTION_MODE = '1B504D'.
  CMD_LABELSTOP_OFFSET = '1B504F'.

  " initialise the values
  G_END_POS_FLAG = 0.
  G_LABEL_SIZE_FLAG = 0.
  G_START_POINT_FLAG = 0.
  G_MULTIPLE_CUT_VALUE = ''.
  G_CUT_SEGMENT_VALUE = ''.
  G_CMD_CUTCT_VALUE = ''.
  G_CMD_CUTNC_VALUE = ''.
  G_CUTTING__OP_FLAG = 0.
  G_CUTTING__OPNC_FLAG = 0.
  G_AUTO_LF_VALUE = ''.

  if_pdl_adrv~adrv_util->output_data( CMD_ESC_A ).
  LOOP at IF_PDL_ADRV~FREE_PARAMS into mara_tt.
    hasCmd = 0.
    if mara_tt-PARAM EQ 'PRINT_SPEED'.
       if_pdl_adrv~adrv_util->output_data( CMD_PRINT_SPEED ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'PRINT_DARKNESS'.
       if_pdl_adrv~adrv_util->output_data( CMD_PRINT_DARKNESS ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'PRINT_DARKNESS_F'.
       if_pdl_adrv~adrv_util->output_data( CMD_PRINT_DARKNESS_F ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'LABEL_SIZE'.
       if_pdl_adrv~adrv_util->output_data( CMD_LABEL_SIZE ).
       G_LABEL_SIZE_FLAG = 1.
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'START_POINT'.
       if_pdl_adrv~adrv_util->output_data( CMD_START_POINT ).
       G_START_POINT_FLAG = 1.
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'PRINTMOTION_MODE'.
       if_pdl_adrv~adrv_util->output_data( CMD_PRINTMOTION_MODE ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'LABELSTOP_OFFSET'.
       if_pdl_adrv~adrv_util->output_data( CMD_LABELSTOP_OFFSET ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM CP 'COMMAND_ESC_*' OR
           mara_tt-PARAM EQ 'COMMAND_ESC' .
       if_pdl_adrv~adrv_util->output_data( CMD_ESC ).
       hasCmd = 1.
    ELSEIF mara_tt-PARAM EQ 'ENLARGEMENT_AREA'.
       if_pdl_adrv~adrv_util->output_data( CMD_ENLARGEMENT_AREA ).
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'STANDARD_AREA'.
       if_pdl_adrv~adrv_util->output_data( CMD_STANDARD_AREA ).
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'PRINT_END_POS'.
       G_END_POS_FLAG = 1.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'MULTIPLE_CUT'.
       G_MULTIPLE_CUT_VALUE = mara_tt-VALUE.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'CUT_SEGMENT'.
       G_CUT_SEGMENT_VALUE = mara_tt-VALUE.
       hasCmd = 0.
   ELSEIF mara_tt-PARAM EQ 'CUT_BCOMMANDNEW'.
       G_CMD_CUTB_VALUE = mara_tt-PARAM .
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'CUT_NCCOMMAND'.
       G_CUTTING__OPNC_FLAG = 1.
       G_CMD_CUTNC_VALUE = mara_tt-PARAM .
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'CUT_CTCOMMAND'.
       G_CMD_CUTCT_VALUE = mara_tt-VALUE.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'CUT_OPERATION'.
       G_CUTTING__OP_FLAG = 1.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'AUTO_LINEFEED'.
       G_AUTO_LF_VALUE = mara_tt-VALUE.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM CS 'ROTATE_90_'.
       CONCATENATE G_WINDOW_90 mara_tt-VALUE ':' into G_WINDOW_90.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM CS 'ROTATE_180_'.
       CONCATENATE G_WINDOW_180 mara_tt-VALUE ':' into G_WINDOW_180.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM CS 'ROTATE_270_'.
       CONCATENATE G_WINDOW_270 mara_tt-VALUE ':' into G_WINDOW_270.
       hasCmd = 0.
    ELSEIF mara_tt-PARAM EQ 'PRINT_QUANTITY'.
       G_PAGECOUNT = mara_tt-VALUE.
       SavePageNumbers( G_PAGECOUNT ).
       hasCmd = 0.
    ENDIF.

    if hasCmd = 1.
       CONCATENATE mara_tt-VALUE '' INTO mytext.
       CONDENSE mytext NO-GAPS.
       if_pdl_adrv~adrv_util->convert_and_output( text = mytext ).
    Endif.

  ENDLOOP.
  if_pdl_adrv~adrv_util->output_data( CMD_ESC_Z ).

  " check for Cutting Operation Command shifting this command to END_OTF_PROCESSING
 " IF G_CUTTING__OP_FLAG = 1.
  "  if_pdl_adrv~adrv_util->output_data( CMD_ESC_A ).
    "if_pdl_adrv~adrv_util->output_data( CMD_CUT_OPERATION ).
    "if_pdl_adrv~adrv_util->output_data( CMD_ESC_Z ).
  "ENDIF.

endmethod.
method CONVERT_FC.

*  data idx type i.
  data FontSet type Y_FONTINFO.
  FontSet = OTF_DATA.
*  idx = 0.
*  FontSet-FONTFAMILY = OTF_DATA(8).     idx = idx + 8.
*  FontSet-FONTSIZE = OTF_DATA+idx(3).   idx = idx + 3.
*  FontSet-BOLD = OTF_DATA+idx(1).       idx = idx + 1.
*  FontSet-ITALIC = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-CHWIDTH = OTF_DATA+idx(5).     idx = idx + 5.
*  FontSet-PROPFLAG = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-PC1 = OTF_DATA+idx(5).     idx = idx + 5.
*  FontSet-PC2 = OTF_DATA+idx(5).     idx = idx + 5.
*  FontSet-CODEPAGE = OTF_DATA+idx(4).     idx = idx + 4.
*  FontSet-SPACEWIDTH = OTF_DATA+idx(5).     idx = idx + 5.
*  FontSet-LANGKEY = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-POSTENCODE = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-SCALEFONT = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-PRINTERFONTPROP = OTF_DATA+idx(1).     idx = idx + 1.
*  FontSet-SOFTFONT = OTF_DATA+idx(1).     idx = idx + 1.

  G_FONTINFO = FontSet.
endmethod.
method CONVERTCH.
  data codenum type xstring.
  codenum = OTF_DATA+5.
  case codenum.
    when '0020AC'.
      if_pdl_adrv~adrv_util->output_data( 'D5' ).
  endcase.

endmethod.
method CONVERTEP.
  DATA CMD_PRINT_END_POS TYPE XSTRING.
  DATA CMD_MULTIPLE_CUT TYPE XSTRING.
  DATA CMD_CUT_SEGMENT TYPE XSTRING.
  DATA PGCOUNT type STRING.

     DATA CMD_CUTCT TYPE XSTRING.
     DATA CMD_CUTNC TYPE XSTRING.
     DATA CMD_CUTB TYPE XSTRING.

*  DATA CMD_AUTO_LINEFEED TYPE XSTRING.

  CMD_PRINT_END_POS = '1B4550'.
  CMD_MULTIPLE_CUT = '1B7E'.
  CMD_CUT_SEGMENT = '1B7E41'.

    CMD_CUTCT = '1B4354'.
    CMD_CUTNC = '1B4E43'.
    CMD_CUTB = '1B7E42'.

  IF G_CUT_SEGMENT_VALUE <> ''.
    IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( CMD_CUT_SEGMENT ).
    IF_PDL_ADRV~ADRV_UTIL->CONVERT_AND_OUTPUT( TEXT = G_CUT_SEGMENT_VALUE ).
  ENDIF.


   IF G_CMD_CUTCT_VALUE <> ''. "Takebe-san's case Adaing new commands to Lesprint device, Damo
    IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( CMD_CUTCT ).
    IF_PDL_ADRV~ADRV_UTIL->CONVERT_AND_OUTPUT( TEXT = G_CMD_CUTCT_VALUE ).
  ENDIF.



  IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( ESC_Q ).
  PGCOUNT = GET_PAGENUMBER( G_CUR_PAGE ).
  IF_PDL_ADRV~ADRV_UTIL->CONVERT_AND_OUTPUT( TEXT = PGCOUNT ). "G_PAGECOUNT

  IF G_END_POS_FLAG = '1'.
    IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( CMD_PRINT_END_POS ).
  ENDIF.
  IF G_MULTIPLE_CUT_VALUE <> ''.
    IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( CMD_MULTIPLE_CUT ).
    IF_PDL_ADRV~ADRV_UTIL->CONVERT_AND_OUTPUT( TEXT = G_MULTIPLE_CUT_VALUE ).

  ENDIF.

  IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( ESC_Z ).

 "IF G_CMD_CUTNC_VALUE = 'CUT_NCCOMMAND'. "Takebe-san's case Adaing new commands to Lesprint device, Damo
   "if_pdl_adrv~adrv_util->output_data( ESC_A ).
    "if_pdl_adrv~adrv_util->output_data( CMD_CUTNC ).
   "if_pdl_adrv~adrv_util->output_data( ESC_Z ).
 "ENDIF.

 IF G_CMD_CUTB_VALUE = 'CUT_BCOMMANDNEW'. "Takebe-san's case Adaing new commands to Lesprint device, Damo
   if_pdl_adrv~adrv_util->output_data( ESC_A ).
    if_pdl_adrv~adrv_util->output_data( CMD_CUTB ).
   if_pdl_adrv~adrv_util->output_data( ESC_Z ).
 ENDIF.

endmethod.
method CONVERTIN.
  Data info TYPE String.
  Data formName Type String.

  info = OTF_DATA+0(2).
  formName = OTF_Data+2(38).

  CONDENSE formName NO-GAPS.
  if info EQ '06'.
    G_CUR_WINDOW = formName.
  elseif info EQ '05'.
    G_CUR_PAGE = formName.
  ENDIF.

endmethod.
METHOD CONVERTLI.
*  DATA xpos_tw(5) TYPE n.
*  DATA ypos_tw(5) TYPE n.
  data xpos_tw type i.
  data ypos_tw type i.
  DATA l_direction TYPE c.
  DATA len_tw(5) TYPE n.
  DATA thickness_tw type i.
  DATA num5 type i.
*  DATA thickness_tw(5) TYPE n.
*  DATA num5(5) TYPE n.
*  DATA x_dots(6) TYPE c.
*  DATA vx_dots(6) TYPE c.
*  DATA y_dots(6) TYPE c.
*  Data vy_dots(6) TYPE c.
  DATA x_dots type i.
  DATA vx_dots type i.
  DATA y_dots type i.
  Data vy_dots type i.
  DATA text TYPE string.
*  DATA len_dots(6) TYPE c.
*  DATA thickness_dots(6) TYPE c.
  DATA len_dots TYPE i.
  DATA thickness_dots TYPE i.
*  data ch5(5) type c.
  data ch2(2) type c.

  xpos_tw     = otf_data(5).
  ypos_tw     = otf_data+5(5).
  l_direction = otf_data+10(1).
  len_tw       = otf_data+11(5).
  thickness_tw = otf_data+16(5).
  num5 = thickness_tw / 2.

*  x_dots = ( xpos_tw * g_resolution ) DIV 1440.
*  vx_dots = ( ( xpos_tw - num5 ) * g_resolution ) DIV 1440.
*  y_dots = ( ypos_tw * g_resolution ) DIV 1440.
*  vy_dots = ( ( ypos_tw - num5 ) * g_resolution ) DIV 1440.
  x_dots = xpos_tw * G_TWIP2DOT_FACTOR.
  vx_dots = ( xpos_tw - num5 ) * G_TWIP2DOT_FACTOR.
  y_dots = ypos_tw * G_TWIP2DOT_FACTOR.
  vy_dots = ( ypos_tw - num5 ) * G_TWIP2DOT_FACTOR.
  if x_dots < 0.
    x_dots = 0.
  endif.
  if vx_dots < 0.
    vx_dots = 0.
  endif.
  if y_dots < 0.
    y_dots = 0.
  endif.
  if vy_dots < 0.
    vy_dots = 0.
  endif.

  if_pdl_adrv~adrv_util->output_data( G_0_DEGREE ). "Line/box rotation is not supported must reset to work correctly [19/12/11 nai]

  if_pdl_adrv~adrv_util->output_data( ESC_H ).
  IF l_direction = 'V'.
    text = vx_dots.
    "CONCATENATE vx_dots '' INTO text.
  ELSE.
    text = x_dots.
    "CONCATENATE x_dots '' INTO text.
  ENDIF.

  CONDENSE text NO-GAPS.
  if text = 0.
    IF l_direction = 'V'. "Vert Line at zero reduce half of thickness
      thickness_tw = thickness_tw - num5.
    else. " Hor line at 0 dist reduce length by half of thickness for box drawing
      "Trade off if this is just line no box. will be shorter
      len_tw = len_tw - num5.
    endif.
  endif.
  if_pdl_adrv~adrv_util->convert_and_output( text = text ).

  if_pdl_adrv~adrv_util->output_data( ESC_V ).
  IF l_direction = 'H'.
    text = vy_dots.
    "CONCATENATE vy_dots '' INTO text.
  ELSE.
    text = y_dots.
    "CONCATENATE y_dots '' INTO text.
  ENDIF.

  CONDENSE text NO-GAPS.
  if text = 0. "here row swap
    IF l_direction = 'V'. "Vert Line at zero reduce half of thickness
      len_tw = len_tw - num5.
    else. " Hor line at 0 dist reduce length by half of thickness for box drawing
      "Trade off if this is just line no box. will be shorter
      thickness_tw = thickness_tw - num5.
    endif.
  endif.
  if_pdl_adrv~adrv_util->convert_and_output( text = text ).

  if_pdl_adrv~adrv_util->output_data( ESCFW ).

  len_dots = len_tw * G_TWIP2DOT_FACTOR.
  thickness_dots = thickness_tw * G_TWIP2DOT_FACTOR.
* Minimum value of thickness is 2
  IF thickness_dots < 2.
    thickness_dots = 2.
  elseif thickness_dots > 99.
    thickness_dots = 99.
  ENDIF.
  if len_dots < 1.
    len_dots = 1.
  endif.

  unpack thickness_dots to ch2.
  text = ch2.

  if_pdl_adrv~adrv_util->convert_and_output( text = text ).

  IF l_direction = 'H'.
    if_pdl_adrv~adrv_util->convert_and_output( text = 'H' ).
  ELSE.
    if_pdl_adrv~adrv_util->convert_and_output( text = 'V' ).
  ENDIF.
  text = len_dots.
  CONDENSE text NO-GAPS.

  "CONCATENATE '' len_dots '' INTO text.
  if_pdl_adrv~adrv_util->convert_and_output( text = text ).

  OUTPUT_NEWLINE( ).
ENDMETHOD.
method CONVERTMT.
    G_CUR_XPOS_TW = OTF_DATA(5).
    G_CUR_YPOS_TW = OTF_DATA+5(5).
endmethod.
METHOD convertop.
* First command of the page
* Convert to ESC+A
* Example: OPDINA4   P 144  240 1704011952000010000100001
* test add com
* line 2
  DATA text TYPE string.
  DATA maxheight TYPE i.
  DATA maxwidth TYPE i.

  DATA width_dot TYPE i.
  DATA height_dot TYPE i.
  DATA offsetx_dot TYPE i.
  DATA offsety_dot TYPE i.
  DATA chstr5(4) TYPE c.
  DATA chstr4(4) TYPE c.

  DATA cmd_auto_linefeed TYPE xstring.

  cmd_auto_linefeed = '1B45'.
  g_pagelength = otf_data+19(5).
  g_pagewidth = otf_data+24(5).
* Get the page count information for ESC+Q
* Commented on 24 April by Chan Kong Hing. Number of
* Pages to Print will be obtained from Command node
*  g_pagecount = otf_data+34(5).

  CONDENSE g_pagecount NO-GAPS.
  CONDENSE g_pagelength NO-GAPS.
  CONDENSE g_pagewidth NO-GAPS.

*  len_dots = ( G_PAGELENGTH * g_resolution ) div 1440.
*  width_dots = ( G_PAGEWIDTH * g_resolution ) div 1440.
  width_dot = g_pagewidth * g_twip2dot_factor.
  height_dot = g_pagelength * g_twip2dot_factor.

*  IF g_resolution = g_8dots_dpi.
*    maxheight = 1424.
*    maxwidth = 832.
*  ELSEIF g_resolution = g_12dots_dpi.
*    maxheight = 2136.
*    maxwidth = 1248.
*  ELSEIF g_resolution = g_24dots_dpi.
*    maxheight = 4272.
*    maxwidth = 2496.
*  ENDIF.
  maxheight = 9999.
  maxwidth = 9999.

  IF height_dot > maxheight.
    height_dot = maxheight.
  ENDIF.
  IF width_dot > maxwidth.
    width_dot = maxwidth.
  ENDIF.

  if_pdl_adrv~adrv_util->output_data( ESC_A ).

  UNPACK height_dot TO chstr5.
  UNPACK width_dot TO chstr4.
  CONCATENATE chstr5 chstr4 INTO text.

  IF g_label_size_flag <> 1.  " if it is not defined in the System Commnand
    if_pdl_adrv~adrv_util->output_data( ESCA1 ).
    if_pdl_adrv~adrv_util->convert_and_output( text = text ).
  ENDIF.

  offsetx_dot = g_pg_xoffset * g_twip2dot_factor.
  offsety_dot = g_pg_yoffset * g_twip2dot_factor.

*  IF g_resolution = g_8dots_dpi.
*    maxheight = 1412.
*    maxwidth = 832.
*  ELSEIF g_resolution = g_12dots_dpi.
*    maxheight = 2136.
*    maxwidth = 1248.
*  ELSEIF g_resolution = g_24dots_dpi.
*    maxheight = 4272.
*    maxwidth = 2496.
*  ENDIF.

  IF offsety_dot > maxheight.
    offsety_dot = maxheight.
  ENDIF.
  IF offsetx_dot > maxwidth.
    offsetx_dot = maxwidth.
  ENDIF.
  IF offsetx_dot <> 0 AND offsety_dot <> 0.
    IF offsety_dot = 0.
      offsety_dot = 1.
    ENDIF.
    IF offsetx_dot = 0.
      offsetx_dot = 1.
    ENDIF.

    IF g_start_point_flag <> 1. " if it is not defined in the system command
      if_pdl_adrv~adrv_util->output_data( ESCA3 ).

      UNPACK offsety_dot TO chstr4.
      CONCATENATE 'V' g_pg_yoffset_s chstr4 INTO text.
      if_pdl_adrv~adrv_util->convert_and_output( text = text ).

      UNPACK offsetx_dot TO chstr4.
      CONCATENATE 'H' g_pg_xoffset_s chstr4 INTO text.
      if_pdl_adrv~adrv_util->convert_and_output( text = text ).
    endif.

  endif.

    IF g_auto_lf_value <> ''.
      if_pdl_adrv~adrv_util->output_data( cmd_auto_linefeed ).
      if_pdl_adrv~adrv_util->convert_and_output( text = g_auto_lf_value ).
    ENDIF.

    if_pdl_adrv~adrv_util->output_data( c_crnl ).

  ENDMETHOD.
method CONVERTOPEN.
*  Processing the //X command
  G_DEVICETYPE = OTF_DATA+1(8).
  G_RESOLUTION = 0.
  data msg type string.
  TRY .
    select single * from tsp0a into g_tsp0a where patype = G_DEVICETYPE.
    if sy-subrc = 0.
      G_RESOLUTION = g_tsp0a-lstsubtype(3).
      G_ARG_OPT = g_tsp0a-lstsubtype+3(1).
    else.
      concatenate 'Device type' G_DEVICETYPE 'not found in TSP0A' "#EC NOTEXT
         into msg separated by space.
      IF_PDL_ADRV~ADRV_UTIL->TRCERR( CALLER  = C_MYCLASSNAME
                                     MESSAGE = msg ).
      "re_rc = c_retcode_err_any.
      exit.
    endif.

  ENDTRY.
  if G_RESOLUTION = 0.
    case G_DEVICETYPE+5(3).
      when '408'. G_RESOLUTION = G_8DOTS_DPI.
      when '412'. G_RESOLUTION = G_12DOTS_DPI.
      when '424'. G_RESOLUTION = G_24DOTS_DPI.
      when others.
        G_RESOLUTION = G_8DOTS_DPI.
        concatenate G_DEVICETYPE
                    'has no resolution tag-using 203 dpi'   "#EC NOTEXT
                    into msg.
        IF_PDL_ADRV~ADRV_UTIL->TRCERR( CALLER  = C_MYCLASSNAME
                                       MESSAGE = msg ).
    endcase.
  endif.
  G_TWIP2DOT_FACTOR = G_RESOLUTION / 1440.
  G_PIXEL2DOT_FACTOR = G_RESOLUTION / 600.
  G_FNTH2DOT_FACTOR = G_RESOLUTION / 720.

  G_PG_XOFFSET = OTF_DATA+18(5).
  G_PG_YOFFSET = OTF_DATA+24(5).
  G_PG_XOFFSET_S = OTF_DATA+23(1).
  G_PG_YOFFSET_S = OTF_DATA+29(1).
  CONDENSE G_PG_XOFFSET_S NO-GAPS.
  CONDENSE G_PG_YOFFSET_S NO-GAPS.
endmethod.
method FILLLOOKUPFORRDBFONTSIZE.
  data tmpstr type string.
  G_FSIZE_RDB_08 = ''.
  tmpstr = '01201101501301801602102002402302702503002703303003603404203704203904504105104405404805705106005306305506'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '60590690620720650750670780690810730840760900780930810960850990871020901050921080'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '95111099114102117104120106123109129113132116132118138120141123144127147130150132'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '15313415613815914116214416514616814817115217715518015718316018616418916619216919'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '51711981742011782041802071832101852131882191922221952251972281992312022342062372'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '09240210243213246217249220252223258225258227261231267234270236273239276241279245'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '28224828525028825329125729425929726230026430626730927130927331527531827832128232'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '42853272883302893332923362963392993423023483043483063543103573133603153633183663'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.
  tmpstr = '20369324372327375329378332381336384338'.
  CONCATENATE G_FSIZE_RDB_08 tmpstr into G_FSIZE_RDB_08.

  G_FSIZE_RDB_12 = ''.

  tmpstr = '01801602402102702503302903603404203804504105104705705106005406605907206407506708107208407609007909608509'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '90891050921080961141021201051231091291141351181381221441271471311531351591401621'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '44168147174153177157183160186165192169198173201178207182210185216191222195225198'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '23120223720824021124621524922025522426122826423327023627324027924628524928825329'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '42583002623032663092713122753182793242843272883332913392973423013483043513093573'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '13363317366322372326375329381335387339390342396346402352405355411359414364420368'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '42337242937743538043838444439045039445339745940246240746841047441547741948342348'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '64284924324954355014415074455104485164535224585254615314665344705404735464795494'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.
  tmpstr = '83555486558490564496570499573503579508'.
  CONCATENATE G_FSIZE_RDB_12 tmpstr into G_FSIZE_RDB_12.

  G_FSIZE_RDB_24 = ''.

  tmpstr = '03603404504105705106605907506708407609608510509211410212310913211814412715313416214417115218316019216920'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '11782101852221952312022402102492202582272702362792452882532972623092713182783272'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '88336296348304357313366320375329384338396346405354414364423371435380444389453397'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '46240647141448342249243150144051044752245752846454047354948255849056749957950858'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '85155975246065336155406275506365586455666545756665836755916846016936087026177146'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '26723633732643741651753659762668771677780684792694801701810710819719828726840735'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '84974485875286776187977088877789778790679591880392781293681994582895483796684597'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.
  tmpstr = '5853984863993870'.
  CONCATENATE G_FSIZE_RDB_24 tmpstr into G_FSIZE_RDB_24.

endmethod.
method GET_NEAREST_RATIO.
  if GOF_RATIO = '20' or  GOF_RATIO = '21' or  GOF_RATIO = '22'.
    SATO_RATIO = '12'.
  ELSEIF GOF_RATIO = '23' or  GOF_RATIO = '24' or  GOF_RATIO = '25' or
    GOF_RATIO = '26' or  GOF_RATIO = '27' .
    SATO_RATIO = '25'.
  ELSEIF GOF_RATIO = '28' or  GOF_RATIO = '29' or  GOF_RATIO = '30'.
    SATO_RATIO = '13' .
  ENDIF.
endmethod.
method GET_PAGENUMBER.
  PAGENUM = '1'.
  if G_PAGENUMS[] is INITIAL.
    PAGENUM = '1'.
  else.
    data tmprec TYPE Y_PAGENUMS.
    tmprec-Name = ''.
    READ TABLE G_PAGENUMS WITH TABLE KEY Name = PAGENAME INTO tmprec.
    if tmprec-Name = ''.
       PAGENUM = '1'.
    else.
      PAGENUM = tmprec-Num.
    ENDIF.
  endif.
  CONDENSE PAGENUM NO-GAPS.
endmethod.
method GETPREFIXEDFONTSIZERDB.
  FWidth = 24.
  FHeight = 24.
  data idx type i.
  idx = FontSizePt.
  idx = idx / 10.
  idx = idx - 4. "8. "Out Fsize array start from ptsize 8.
  if idx < 0.
    idx = 0.
  endif.
  data tmpi type i.



  IF g_resolution = g_8dots_dpi.
    tmpi = strlen( G_FSIZE_RDB_08 ).
   tmpi = tmpi / 6.
   tmpi = tmpi - 1.
   if idx > tmpi.
     idx = tmpi.
   endif.
    idx = idx * 6.
    FWidth = G_FSIZE_RDB_08+idx(3).
    idx = idx + 3.
    FHeight = G_FSIZE_RDB_08+idx(3).
  ELSEIF g_resolution = g_12dots_dpi.
     tmpi = strlen( G_FSIZE_RDB_12 ).
   tmpi = tmpi / 6.
   tmpi = tmpi - 1.
   if idx > tmpi.
     idx = tmpi.
   endif.
    idx = idx * 6.
    FWidth = G_FSIZE_RDB_12+idx(3).
    idx = idx + 3.
    FHeight = G_FSIZE_RDB_12+idx(3).
  ELSEIF g_resolution = g_24dots_dpi.
     tmpi = strlen( G_FSIZE_RDB_24 ).
   tmpi = tmpi / 6.
   tmpi = tmpi - 1.
   if idx > tmpi.
     idx = tmpi.
   endif.
    idx = idx * 6.
    FWidth = G_FSIZE_RDB_24+idx(3).
    idx = idx + 3.
    FHeight = G_FSIZE_RDB_24+idx(3).
  ENDIF.
endmethod.
method IF_PDL_ADRV~END_OTF_PROCESSING.

IF G_CUTTING__OP_FLAG = 1.
  if_pdl_adrv~adrv_util->output_data( ESC_A ).
    if_pdl_adrv~adrv_util->output_data( '1B7E42' ). "shifting ~B command at the end from CONVERT_COMMAND, Damo
   if_pdl_adrv~adrv_util->output_data( ESC_Z ).
ENDIF.

IF G_CUTTING__OPNC_FLAG = 1.
  if_pdl_adrv~adrv_util->output_data( ESC_A ).
    if_pdl_adrv~adrv_util->output_data( '1B4E43' ). "shifting ~NC command at the end from CONVERTEP, Damo
   if_pdl_adrv~adrv_util->output_data( ESC_Z ).
ENDIF.

  IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'end otf processing' ).
* housekeeping at end of OTF

RE_RC = c_retcode_ok. "ok
endmethod.
METHOD if_pdl_adrv~process_otf_barcode.
  DATA x_dots(6) TYPE c.
  DATA y_dots(6) TYPE c.
  DATA text1 TYPE string.
  DATA text2 TYPE string.
  DATA textx TYPE xstring.
  DATA newbc TYPE c.
  DATA pc(5) TYPE c.
  Data xpc TYPE XString.

*  DATA msg(80) TYPE c.
  DATA width_tw(5) TYPE n.
  DATA height_tw(5) TYPE n.
  DATA width_dots(2) TYPE c. "#EC NEEDED
  DATA height_dots(3) TYPE c.
  DATA len TYPE i.
*  DATA num TYPE i.
  DATA rotation TYPE c.
  DATA checkflag TYPE c.
  DATA checkdigit TYPE string.
  DATA RATIO  TYPE string.

* Variable for Old Barcode
  DATA barctype(8) TYPE c.
  DATA sapbarcode(8) TYPE c.
  DATA barcrot(3) TYPE c.
  DATA barclen(4) TYPE c.

  if_pdl_adrv~adrv_util->trc( caller  = c_myclassname
                                 message = 'ENTER BARCODE FUNCTION' ).

  IF im_otf_bp-tdprintcom IS INITIAL.
    CLEAR newbc.
  ELSE.
    newbc = 'X'.
  ENDIF.

  DATA bc_cmd TYPE y_bc_cmd.
  bc_cmd = im_otf_bc-tdprintpar.
* set cursor
  x_dots = ( g_cur_xpos_tw * g_resolution ) DIV 1440.
  y_dots = ( g_cur_ypos_tw * g_resolution ) DIV 1440.
  len = STRLEN( im_barcodestring ).

  IF len = 0.
    RETURN.
  ENDIF.

  g_printcontrol = bc_cmd-PCPREFIX. "im_otf_bc-tdprintpar+20(5).
  g_printcontrol2 = bc_cmd-PCSUFFIX.

  DATA tempidx TYPE i.
  DATA remainder TYPE i.
  tempidx = len - 1.

  " Rotate by 0 degree, by default
  "G_0_DEGREE = '1B2530'. " this already done in constructor
  if_pdl_adrv~adrv_util->output_data( G_0_DEGREE ).

  IF newbc = 'X'.
* New technology barcode, with BP data
    text1 = ''.
    DATA codetype TYPE c.
    "DATA esc_bk TYPE xstring.    esc_bk = '1B424B'.
    codetype = im_otf_bp-tdprintpar+1(1).
    IF codetype = 'C' AND im_otf_bp-tdprintpar+10(1) <> 'N' AND
      im_otf_bp-tdprintpar+10(1) <> 'A'.
      RETURN.
    ENDIF.
    rotation = im_otf_bp-tdprintpar+2(1).
    checkflag = im_otf_bp-tdprintpar+4(1).

    IF rotation = 'N'.
      rotation = '0'.
    ELSEIF rotation = 'R'.
      rotation = '1'.
    ELSEIF rotation = 'I'.
      rotation = '2'.
    ELSEIF rotation = 'B'.
      rotation = '3'.
    ENDIF.
    DATA width_px TYPE i.
    DATA height_px TYPE i.
    DATA chstr2(2) TYPE c.
    DATA chstr3(3) TYPE c.
    DATA chstr4(4) TYPE c.

    if im_otf_bp-tdprintpar+3(1) CA '1234567890'.
        width_px = im_otf_bp-tdprintpar+3(1).
        width_px = width_px + 1.
    else.
       if im_otf_bp-tdprintpar+3(1) = 'A'.
         width_px = 11.
       elseif im_otf_bp-tdprintpar+3(1) = 'B'.
         width_px = 12.
       elseif im_otf_bp-tdprintpar+3(1) = 'C'.
         width_px = 13.
       elseif im_otf_bp-tdprintpar+3(1) = 'D'.
         width_px = 14.
       elseif im_otf_bp-tdprintpar+3(1) = 'E'.
         width_px = 15.
       elseif im_otf_bp-tdprintpar+3(1) = 'F'.
         width_px = 16.
       elseif im_otf_bp-tdprintpar+3(1) = 'G'.
         width_px = 17.
       elseif im_otf_bp-tdprintpar+3(1) = 'H'.
         width_px = 18.
       elseif im_otf_bp-tdprintpar+3(1) = 'I'.
         width_px = 19.
       elseif im_otf_bp-tdprintpar+3(1) = 'J'.
         width_px = 20.
       elseif im_otf_bp-tdprintpar+3(1) = 'K'.
         width_px = 21.
       elseif im_otf_bp-tdprintpar+3(1) = 'L'.
         width_px = 22.
       elseif im_otf_bp-tdprintpar+3(1) = 'M'.
         width_px = 23.
       elseif im_otf_bp-tdprintpar+3(1) = 'N'.
         width_px = 24.
       elseif im_otf_bp-tdprintpar+3(1) = 'O'.
         width_px = 25.
       elseif im_otf_bp-tdprintpar+3(1) = 'P'.
         width_px = 26.
       elseif im_otf_bp-tdprintpar+3(1) = 'Q'.
         width_px = 27.
       elseif im_otf_bp-tdprintpar+3(1) = 'R'.
         width_px = 28.
       elseif im_otf_bp-tdprintpar+3(1) = 'S'.
         width_px = 29.
       elseif im_otf_bp-tdprintpar+3(1) = 'T'.
         width_px = 30.
       endif.
    endif.
    width_px = floor( width_px * g_pixel2dot_factor ).
    " Checking the maximum width_px
    RATIO = im_otf_bp-tdprintpar+10(2).
    RATIO = GET_NEAREST_RATIO( RATIO ).
    if ( RATIO = '25' AND ( codetype EQ '2' OR codetype EQ '3' ) ).
       IF ( width_px > 24 ).
         width_px = 24.
       ENDIF.
    else.
      if width_px > 12.
        width_px = 12.
      ENDIF.
    ENDIF.

    if codetype NE 'r'.
       height_px = im_otf_bp-tdprintpar+5(5).
    ELSE.
       height_px = 0.  " No need to print RFID Barcode
    ENDIF.

    height_px = height_px * g_pixel2dot_factor.
    " For rotation. should adjust H
    IF rotation = '0'.
      y_dots = y_dots - height_px.
      "ELSEIF rotation = '2'.
      "y_dots = y_dots - height_px.
      "x_dots = x_dots + ( width_px * len * barspercode ).
    ELSEIF rotation = '3'.
      "y_dots = y_dots - ( width_px * len * barspercode ).
      x_dots = x_dots + height_px.
    ENDIF.

    IF x_dots < 0.
      x_dots = 0.
    ENDIF.
    IF y_dots < 0.
      y_dots = 0.
    ENDIF.

    if_pdl_adrv~adrv_util->output_data( g_esc_rot ).
    CONCATENATE rotation '' INTO text1.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).

    if_pdl_adrv~adrv_util->output_data( ESC_H ).
    CONCATENATE x_dots '' INTO text1.
    CONDENSE text1 NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    if_pdl_adrv~adrv_util->output_data( ESC_V ).

    CONCATENATE y_dots '' INTO text1.
    CONDENSE text1 NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    CLEAR textx.

    " Handling RFID Tag
    IF codetype = 'r'.
      Data acs TYPE String.
      Data lock TYPE String.
      Data kill TYPE String.

      acs = im_otf_bp-tdprintpar+4(8).
      lock = im_otf_bp-tdprintpar+12(2).
      kill = im_otf_bp-tdprintpar+14(8).

      text1 = Process_RFID( AcsCode = acs
                            LockMask = lock
                            KillCode = kill
                            BS_Command = im_barcodestring ).

      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    ELSEIF codetype = '3' OR                                "Code39 B1
       codetype = 'A' OR                                    "Code93 BC
       codetype = '2' OR                                    "2of5 interlaved B2
       codetype = 'C'.                                      "Code128 BG

     " if_pdl_adrv~adrv_util->output_printcontrol( name = g_printcontrol ).

      UNPACK width_px TO chstr2.
      UNPACK height_px TO chstr3.
      CONCATENATE chstr2 chstr3 INTO text1.
      IF codetype = 'A'.                                    "Code93
        xpc = G_PC_NBTCODE93.
        if_pdl_adrv~adrv_util->output_data( xpc ).
        textx = mapcode93( im_barcodestring ).
        len = XSTRLEN( textx ).
        UNPACK len TO chstr2.
        CONCATENATE text1 chstr2 INTO text1.
        "text2 = MAPCode93( im_barcodestring ).

        "CONCATENATE text1 text2 INTO text1.

      ELSEIF codetype = '3'.                                "Code39
        RATIO = im_otf_bp-tdprintpar+10(2).
        RATIO = GET_NEAREST_RATIO( RATIO ).
        if RATIO = '12'.
          xpc = G_PC_NBTCODE39_R12.
        ELSEIF RATIO = '25'.
          xpc = G_PC_NBTCODE39_R25.

          "----- 2.5:1 ratio narrow barwidth / 2 fix -----------------
          "width_px = floor( width_px * g_pixel2dot_factor / 2 ).
          width_px = width_px / 2.
          UNPACK width_px TO chstr2.
          CONCATENATE chstr2 chstr3 INTO text1.
          "-----------------------------------------------------------

        ELSEIF RATIO = '13'.
          xpc = G_PC_NBTCODE39_R13.
        ENDIF.
        if_pdl_adrv~adrv_util->output_data( xpc ).
        IF im_barcodestring+1(1) NE '*' AND
          im_barcodestring+tempidx(1) NE '*'. " embed the data with *
          CONCATENATE text1 '*' INTO text1.
          CONCATENATE text1 im_barcodestring INTO text1.
          IF checkflag EQ 'X'.
            checkdigit = barcode_mod43_checksum( im_barcodestring ).
            CONCATENATE text1 checkdigit INTO text1.
          ENDIF.
          CONCATENATE text1 '*' INTO text1.
        ELSE.
          CONCATENATE text1 im_barcodestring INTO text1.
        ENDIF.
      ELSEIF codetype = '2'. "Interleaved 2 of 5
        RATIO = im_otf_bp-tdprintpar+10(2).
        RATIO = GET_NEAREST_RATIO( RATIO ).
         if RATIO = '12'.
          xpc = G_PC_NBTCODE25_R12.
        ELSEIF RATIO = '25'.
          xpc = G_PC_NBTCODE25_R25.

          "----- 2.5:1 ratio narrow barwidth / 2 fix -----------------
          "width_px = floor( width_px * g_pixel2dot_factor / 2 ).
          width_px = width_px / 2.
          UNPACK width_px TO chstr2.
          CONCATENATE chstr2 chstr3 INTO text1.
          "-----------------------------------------------------------

        ELSEIF RATIO = '13'.
          xpc = G_PC_NBTCODE25_R13.
        ENDIF.
        if_pdl_adrv~adrv_util->output_data( xpc ).
        DATA barcode_data TYPE string.
        CONCATENATE '' im_barcodestring INTO barcode_data.
        IF checkflag EQ 'X'. " generate modulus 10 check digit
          checkdigit = barcode_checksum( barcodetype = '2OF5'
                            barcodestring = im_barcodestring ).
          CONCATENATE im_barcodestring checkdigit INTO barcode_data.
          CONDENSE barcode_data NO-GAPS.
        ENDIF.
        len = STRLEN( barcode_data ).
        remainder = len MOD 2.
        IF remainder = 1.
          CONCATENATE '0' barcode_data INTO barcode_data.
        ENDIF.
        CONCATENATE text1 barcode_data INTO text1.
      ELSEIF codetype = 'C'.                                " Code 128
        xpc = G_PC_NBTCODE128.
        if_pdl_adrv~adrv_util->output_data( xpc ).
        DATA automode TYPE c.
        automode = im_otf_bp-tdprintpar+10(1).
        IF automode = 'N'.
          text2 = mapbc128_n( im_barcodestring ).
          "CONCATENATE text1 '>H' INTO text1. " start code B
          "text2 = MAPCODE128B( im_barcodestring ).
          CONCATENATE text1 text2 INTO text1.
        ELSEIF automode = 'A'.
          text2 = mapbc128_auto( im_barcodestring ).
          CONCATENATE text1 text2 INTO text1.
        ENDIF.
      ENDIF.

      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
      IF NOT textx IS INITIAL.
        if_pdl_adrv~adrv_util->output_data( textx ).
      ENDIF.
    ELSEIF codetype = '7' .  " PDF417


      DATA: nrows TYPE i, ncols TYPE i, tranc TYPE c, security TYPE c.
      security = im_otf_bp-tdprintpar+4(1).
      ncols = im_otf_bp-tdprintpar+15(2).
      nrows = im_otf_bp-tdprintpar+17(2).
      tranc = im_otf_bp-tdprintpar+19(1).
      height_px = im_otf_bp-tdprintpar+10(5).
      height_px = height_px * g_pixel2dot_factor.
      UNPACK width_px TO chstr2.
      CONCATENATE '' chstr2 INTO text1."aa
      UNPACK height_px TO chstr2.
      data textx2 type xstring.
      textx2 = mappdf417( im_barcodestring ).
      len = xstrlen( textx2 ).
      if G_ARG_OPT = 'J'. " bc_cmd-PCPREFIX <> bc_cmd-PCSUFFIX .
        " 2D10 Command
          xpc = G_PC_NBTPDF417_J. "2D10
        if_pdl_adrv~adrv_util->output_data( xpc ).
        CONCATENATE text1 ',' chstr2 INTO text1. "aa,bb
        CONCATENATE text1 ',' security INTO text1. "aa,bb,c
        UNPACK ncols TO chstr2.
        CONCATENATE text1 ',' chstr2 INTO text1. "aa,bb,c,dd
        UNPACK nrows TO chstr2.
        CONCATENATE text1 ',' chstr2 INTO text1."aa,bb,c,dd,ee
        IF tranc = 'X'.
          CONCATENATE text1 ',1' INTO text1."aa,bb,c,dd,ee,f
        ELSE.
          CONCATENATE text1 ',' INTO text1. " truncate token can omit
        ENDIF.

        if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
        "ESC_DN
        xpc = G_PC_NBTDNCMD.
        if_pdl_adrv~adrv_util->output_data( xpc ).
        UNPACK len TO chstr4.
        CONCATENATE chstr4 ',' INTO text1. "mmmm
        if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
        "if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
        if_pdl_adrv~adrv_util->output_data( textx2 ).

      ELSE. "BK Command
         xpc = G_PC_NBTPDF417.
         if_pdl_adrv~adrv_util->output_data( xpc )."ESC_BK
        CONCATENATE text1 chstr2 INTO text1. "aabb
        CONCATENATE text1 security INTO text1. "aabbc
        UNPACK ncols TO chstr2.
        CONCATENATE text1 chstr2 INTO text1. "aabbcdd
        UNPACK nrows TO chstr2.
        CONCATENATE text1 chstr2 INTO text1. "aabbcddee

        UNPACK len TO chstr4.
        CONCATENATE text1 chstr4 INTO text1. "aabbcddeeffff
        if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
        "aabbcddeeffffg~g
        "if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
        if_pdl_adrv~adrv_util->output_data( textx2 ).
        IF tranc = 'X'.
          text1 = 'T'. "aabbcddeeffffg~gh
          if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
        ENDIF.
       ENDIF.
    ENDIF.

  ELSE.
* Old Barcode technology starts here
* Example:
* BCYST2OF5 011340113412SB103SB1032OF5    000 00012
* BS123456
    width_tw = im_otf_bc-tdprintpar+8(5).
    height_tw = im_otf_bc-tdprintpar+13(5).
    sapbarcode = im_otf_bc-tdprintpar+0(8).
    barctype = im_otf_bc-tdprintpar+30(8).
    barcrot = im_otf_bc-tdprintpar+38(3).

    CONDENSE sapbarcode NO-GAPS.

    width_dots = ( width_tw * g_resolution ) DIV 1440.
    height_dots = ( height_tw * g_resolution ) DIV 1440.

    CONDENSE width_dots NO-GAPS.
    CONDENSE height_dots NO-GAPS.

* Rotation handling for old barcode
    IF barcrot = '000'.
      rotation = '0'.
      y_dots = y_dots - height_dots.
    ELSEIF barcrot = '090'.
      rotation = '1'.
    ELSEIF barcrot = '180'.
      rotation = '2'.
      "x_dots = x_dots + ( width_dots * len * barspercode ).
    ELSEIF barcrot = '270'.
      rotation = '3'.
      "y_dots = y_dots - ( width_dots * len * barspercode ).
      x_dots = x_dots + height_dots.
    ENDIF.

    IF x_dots < 0.
      x_dots = 0.
    ENDIF.
    IF y_dots < 0.
      y_dots = 0.
    ENDIF.

    if_pdl_adrv~adrv_util->output_data( g_esc_rot ).
    CONCATENATE rotation '' INTO text1.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
* end of Rotation handling
* Start of positioning of barcode
    if_pdl_adrv~adrv_util->output_data( ESC_H ).
    CONCATENATE x_dots '' INTO text1.
    CONDENSE text1 NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    if_pdl_adrv~adrv_util->output_data( ESC_V ).

    CONCATENATE y_dots '' INTO text1.
    CONDENSE text1 NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
* End of positioning of barcode

* The print control defines the command ESC+<cmd><narrow barcode width>
    if_pdl_adrv~adrv_util->output_printcontrol( name = g_printcontrol ).


* Processing of width value
* 16 Dec 2009. konghing: this part is needed. narrow bar width
*                        will be taken from print control
*   text1 = ''.
*   IF width_dots < 10.
*     CONCATENATE '0' width_dots INTO text1.
*   ELSEIF width_dots < 100.
*     CONCATENATE '' width_dots INTO text1.
*   ENDIF.
* end of width value processing
*    IF barctype EQ 'UNDEF'.
*      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
*    ENDIF.

* Processing of height value
    text1 = ''.
    IF height_dots < 10.
      CONCATENATE '00' height_dots INTO text1.
    ELSEIF height_dots < 100.
      CONCATENATE '0' height_dots INTO text1.
    ELSE.
      CONCATENATE '' height_dots INTO text1.
    ENDIF.

    IF barctype NE 'POSTNET' AND text1 NE '000' AND sapbarcode+0(6) NE 'YSTDMX' AND sapbarcode+0(6) NE 'YSTQR_'.
      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    ENDIF.
* end of height value processing

* Additional data processing based on barcode type
    text1 = ''.

    IF barctype = 'CODABAR'. " Start and end with A,B,C,D,E,N,T,a,b,c,d,e,n,t
      IF im_barcodestring+0(1) CA 'ABCDENTabcdent' AND
         im_barcodestring+tempidx(1) CA 'ABCDENTabcdent'.
        if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
      ELSE. "Make Start and end with A and A
        if_pdl_adrv~adrv_util->convert_and_output( text = 'A' ).
        if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
        if_pdl_adrv~adrv_util->convert_and_output( text = 'A' ).
      ENDIF.
    ELSEIF barctype = 'POSTNET'.
      if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
    ELSEIF barctype = '2OF5' OR sapbarcode EQ 'BC_I25' OR sapbarcode EQ 'BC_I25C'.
      CONCATENATE text1 im_barcodestring INTO text1.
      IF sapbarcode EQ 'BC_I25C'.
        checkdigit = barcode_checksum( barcodetype = '2OF5'
                          barcodestring = im_barcodestring ).
        CONCATENATE text1 checkdigit INTO text1.
      ENDIF.
      len = STRLEN( text1 ).
      remainder = len MOD 2.
      IF remainder = 1. " Add a 0 in front if the data is odd number
        CONCATENATE '0' text1 INTO text1.
      ENDIF.
      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    ELSEIF barctype = 'UPC_A'.
      if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
      IF STRLEN( im_barcodestring ) = 11. " generate check digit
        checkdigit = barcode_checksum( barcodetype = 'UPC_A'
                          barcodestring = im_barcodestring ).
        if_pdl_adrv~adrv_util->convert_and_output( text = checkdigit ).
      ENDIF.
    ELSEIF barctype = 'EAN13' OR sapbarcode EQ 'BC_EAN13'.
      if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
      IF STRLEN( im_barcodestring ) = 12. " generate check digit
        checkdigit = barcode_checksum( barcodetype = 'EAN13'
                          barcodestring = im_barcodestring ).
        if_pdl_adrv~adrv_util->convert_and_output( text = checkdigit ).
      ENDIF.
    ELSEIF barctype = 'EAN8' OR sapbarcode EQ 'BC_EAN8'.
      if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).
      IF STRLEN( im_barcodestring ) = 7. " generate check digit
        checkdigit = barcode_checksum( barcodetype = 'EAN8'
                          barcodestring = im_barcodestring ).
        if_pdl_adrv~adrv_util->convert_and_output( text = checkdigit ).
      ENDIF.
    ELSEIF barctype = 'C128' . "AUTOSWITCH B <=> C
      text2 = mapbc128_auto( im_barcodestring ).
      if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
    ELSEIF barctype = 'C128_A'. "Disabled
      text2 = bc128_invalidateinvo( im_barcodestring ).
      IF text2(1) <> '>'.
        CONCATENATE '>9' text2 INTO text2.
      ENDIF.
      text2 = mapcode128a( input = text2 st = 'X' ).
      if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
    ELSEIF barctype = 'C128_B' OR  barctype = 'C128'.
      "if_pdl_adrv~adrv_util->convert_and_output( text = '>H' ).
      text2 = bc128_invalidateinvo( im_barcodestring ).
      IF text2(1) <> '>'.
        CONCATENATE '>:' text2 INTO text2.
      ENDIF.
      text2 = mapcode128b( input = text2 ).
      if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
    ELSEIF barctype = 'C128_C'. "Disabled
      text2 = bc128_invalidateinvo( im_barcodestring ).
      IF text2(1) <> '>'.
        CONCATENATE '>;' text2 INTO text2.
      ENDIF.
      text2 = mapcode128c( input = text2 st = 'X' ).
      if_pdl_adrv~adrv_util->convert_and_output( text = text2 ).
    ELSEIF barctype = 'C93' OR sapbarcode EQ 'BC_93'.
      textx = mapcode93( im_barcodestring ).
      len = XSTRLEN( textx ).
      UNPACK len TO chstr2.

      CONCATENATE '' chstr2 INTO text1.
      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
      if_pdl_adrv~adrv_util->output_data( textx ).
    ELSEIF barctype EQ 'C39' OR barctype EQ 'C39X'
      OR sapbarcode EQ 'BC_CD39' OR sapbarcode EQ 'BC_CD39C'.
      IF im_barcodestring+1(1) NE '*' AND
          im_barcodestring+tempidx(1) NE '*'. " embed the data with *
        CONCATENATE text1 '*' INTO text1.
        CONCATENATE text1 im_barcodestring INTO text1.
        IF barctype EQ 'C39X' OR sapBarcode EQ 'BC_CD39C'.
          checkdigit = barcode_mod43_checksum( im_barcodestring ).
          CONCATENATE text1 checkdigit INTO text1.
        ENDIF.
        CONCATENATE text1 '*' INTO text1.
      ELSE.
        CONCATENATE text1 im_barcodestring INTO text1.
      ENDIF.
      if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).

    ELSEIF barctype EQ 'UNDEF'.
* 7 Aug 2013
* QR CODE put count and comma b4 bcode string

      IF sapbarcode+0(6) EQ 'YSTQR_'.
       " len = STRLEN( im_barcodestring ). previous

        "len = CL_ABAP_LIST_UTILITIES=>DYNAMIC_OUTPUT_LENGTH(  changed by Olaf's suggestion
             " EXPORTING
              "FIELD = im_barcodestring ).

         len = CL_ABAP_LIST_UTILITIES=>DYNAMIC_OUTPUT_LENGTH(
               FIELD = im_barcodestring ).

        barclen  = len.
        CONCATENATE barclen '' INTO text1.
        CONDENSE text1 NO-GAPS.
        CONCATENATE text1 ',' INTO text1.
        if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
      ENDIF.
      if_pdl_adrv~adrv_util->convert_and_output( text = im_barcodestring ).

* 18 Dec 2009
* Datamatrix processing: Esc+BX and ESC+DC
      IF sapbarcode+0(6) EQ 'YSTDMX'.
        if_pdl_adrv~adrv_util->output_printcontrol( name = g_printcontrol2 ).
      ENDIF.
    ENDIF.

* Old Barcode technology ends here
  ENDIF.
  "if_pdl_adrv~adrv_util->output_data( c_crnl ).

ENDMETHOD.
method IF_PDL_ADRV~PROCESS_OTF_CMD.
  data errmsg(80) type c.
*  data msg(80) type c.
*  data devtype type rspoptype.
*  data text1 type string.
*  data L_STMODE type c value ' '.
* IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
*                            MESSAGE = 'Process OTF Command' ).

  RE_RC = c_retcode_ok. "ok

  clear errmsg.
  case im_otf-tdprintcom.
     when '//'. "(Start and End) = Start and end of OTF data stream
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process // Command' ). "#EC NOTEXT

    when '/P'. "(Position) = Current position for display
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process /P Command' ). "#EC NOTEXT

    when 'OP'. "(OpenPage) = Open, first command on page
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process OP Command' ). "#EC NOTEXT
      ConvertOP( im_otf-TDPRINTPAR ).

    when 'IN'. "Information
      G_CUR_XPOS_TW = 0. G_CUR_YPOS_TW = 0.
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process IN Command' ). "#EC NOTEXT
      NEWST_PROCESS( ).
      ConvertIN( im_otf-TDPRINTPAR ).

    when 'EP'. "End Page, Close, last command on page
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process EP Command' ). "#EC NOTEXT
      NEWST_PROCESS( ).
      ConvertEP( ).

    when 'MT'. "(Move to) = set cursor
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process MT Command' ). "#EC NOTEXT
      NEWST_PROCESS( ).
      ConvertMT( im_otf-TDPRINTPAR ).
*      clear G_STMODE_FLAG .

    when 'ST'. "(String) = Character String
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process ST Command' ). "#EC NOTEXT
*      L_STMODE = 'X'.
      "ConvertST( im_otf-TDPRINTPAR ).
      NEWST_STOREDATA( OTF_DATA_STRING = im_otf-TDPRINTPAR X = G_CUR_XPOS_TW Y = G_CUR_YPOS_TW ).


    when 'FC'. "(Font Call)
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process FC Command' ). "#EC NOTEXT
      CONVERT_FC( im_otf-TDPRINTPAR ).
*      L_STMODE = 'X'.

    when 'BC'. "Barcode Output
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process BC Command' ). "#EC NOTEXT

    when 'BS'. "Barcode Output
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process BS Command' ). "#EC NOTEXT

    when 'UL'. "Underline
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process UL Command' ). "#EC NOTEXT
*      L_STMODE = 'X'.

      " = im_otf-TDPRINTPAR(1). "record if it was X

    when 'SW'. "Space Width
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process SW Command' ). "#EC NOTEXT
      "ConvertSW( im_otf-TDPRINTPAR ).
*      L_STMODE = 'X'.

    when 'SU'. "Superscript/subscript
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process SU Command' ). "#EC NOTEXT
*      L_STMODE = 'X'.

    when 'CP'. "(Codepage) = Switch codepage
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process CP Command' ). "#EC NOTEXT
      "Convert_CP( im_otf-TDPRINTPAR ).
    when 'CH'. "SAP character
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process CH Command' ). "#EC NOTEXT
      "CONVERTCH( im_otf-TDPRINTPAR ).
      NEWST_STOREDATA( OTF_DATA_STRING = im_otf-TDPRINTPAR
      X = G_CUR_XPOS_TW
      Y = G_CUR_YPOS_TW IsSAPChar = 'X' ).

    when 'MK'. "(Marked) = Selected text for display
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process MK Command' ). "#EC NOTEXT

    when 'RD'. "(Raw Data) = Printer specific Data
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process RD Command' ). "#EC NOTEXT

    when 'MC'. "(Microfiche Cold) = Microfiche cold information
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process MC Command' ). "#EC NOTEXT

    when 'PC'. "(Print Control)= Print Control from T022D
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process PC Command' ). "#EC NOTEXT

    when 'BX'. "(Box)= Box Character
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process BX Command' ). "#EC NOTEXT

    when 'BM'. "Bitmap information
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process BM Command' ). "#EC NOTEXT
      ConvertLI( im_otf-TDPRINTPAR ).

    when 'CB'. "Color Box
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process CB Command' ). "#EC NOTEXT

    when 'CT'. "Color Text
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process CT Command' ). "#EC NOTEXT
*      L_STMODE = 'X'.

    when 'LI'. "Line
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process LI Command' ). "#EC NOTEXT
      ConvertLI( im_otf-TDPRINTPAR ).

    when 'LB'. "Link Begin
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process LB Command' ). "#EC NOTEXT

    when 'LE'. "Link End
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process LE Command' ). "#EC NOTEXT

    when 'LK'. "Link
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process LK Command' ). "#EC NOTEXT

     when 'RT'. "Raw Text
      IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                            MESSAGE = 'Process RT Command' ).  "#EC NOTEXT
    when others.
*  don't know
      concatenate 'Unknown OTF cmd' im_otf-tdprintcom       "#EC NOTEXT
        into errmsg separated by space.
  endcase.

  G_PREV_COMMAND = im_otf-tdprintcom.
*  if L_STMODE = 'X' and not G_STMODE_FLAG is INITIAL.
*    G_STMODE_FLAG = 'X'.
*  else.
*    clear G_STMODE_FLAG.
*  endif.
  if errmsg is initial.
    re_rc = c_retcode_ok.
  else.
    IF_PDL_ADRV~ADRV_UTIL->TRCERR( CALLER  = C_MYCLASSNAME
                                   MESSAGE = errmsg ).
    re_rc = c_retcode_ok.
  endif.
endmethod.
method IF_PDL_ADRV~PROCESS_OTF_RAWDATA.

  data: tmpi type i, tmpfloat type f,
        hex1 type x,
        hex2(2) type x,
        hex4(4) type x, bmp_info type Y_BMP_INFO,
        "bmp_info-sato_width type i,
        "bmp_info-sato_height type i,
        text1 TYPE STRING,"chstr2(2) type c,
        chstr3(3) type c, chstr4(4) type c, chstr5(5) type c,
          pad_data type xstring.



  DATA XBMP_DATA TYPE XSTRING.
  IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = c_myclassname
                          MESSAGE = 'Process Raw Data' ).  "#EC NOTEXT


  data: x_dots type i, y_dots type i.
  x_dots = g_cur_xpos_tw * G_TWIP2DOT_FACTOR.
  y_dots = g_cur_ypos_tw * G_TWIP2DOT_FACTOR.

  " Rotate by 0 degree, by default
  "G_0_DEGREE = '1B2530'.
  "if_pdl_adrv~adrv_util->output_data( G_0_DEGREE ).
  OUTPUT_ROTATION( ).

  if_pdl_adrv~adrv_util->output_data( ESC_H ).
  unpack x_dots to chstr4.
  CONCATENATE chstr4 '' INTO text1.
  CONDENSE text1 NO-GAPS.
  if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
  if_pdl_adrv~adrv_util->output_data( ESC_V ).
  unpack y_dots to chstr5.
  CONCATENATE chstr5 '' INTO text1.
  CONDENSE text1 NO-GAPS.
  if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).



  hex4 = IM_RAWDATA+24(4).
  bmp_info-PIX_WIDTH = hex4.
  hex4 = IM_RAWDATA+28(4).
  bmp_info-PIX_HEIGHT = hex4.

  hex2 = IM_RAWDATA+32(2).
  bmp_info-DPI  = hex2.
  hex2 = IM_RAWDATA+34(2).
  bmp_info-BPP = hex2.
  hex2 = IM_RAWDATA+36(2).
  bmp_info-COLORTABLESIZE = hex2.

  hex4 = IM_RAWDATA+38(4).
  bmp_info-ByteSize = hex4.

  if IM_RAWDATA_TYPE = 'J'.
********************************************************
  if 1 = 2. "Resize Image by Hardware
    " data Esc_L type xstring.
    " Esc_L = '1B4C'.
    " if_pdl_adrv~adrv_util->output_data( Esc_L ).
    " tmpi = 1.
    " if g_resolution = G_8DOTS_DPI.
    "  tmpi = 2.
    " elseif g_resolution = G_12DOTS_DPI.
    "  tmpi = 3.
    " elseif g_resolution = G_24DOTS_DPI.
    "  tmpi = 6.
    " endif.
    "tmpi = 9.
    " unpack tmpi to chstr2.
    " CONCATENATE chstr2 chstr2 into text1.
    "if_pdl_adrv~adrv_util->convert_and_output( text = text1 ).
    bmp_info-sato_width = bmp_info-ByteSize / bmp_info-PIX_HEIGHT.
    tmpfloat = bmp_info-PIX_HEIGHT.
    bmp_info-sato_height = ceil( tmpfloat / 8 ).
   XBMP_DATA = IM_RAWDATA+132(bmp_info-ByteSize).
  else. " Resize Image by software
   data tmp_XBMP_DATA type xstring.
   clear xbmp_data.
   tmp_xbmp_data = IM_RAWDATA+132(bmp_info-ByteSize).
    call method BMP_RESIZE
    exporting
      bmp_info = bmp_info
      input = tmp_xbmp_data
   importing
      output = XBMP_DATA
      newwidth = bmp_info-pix_width
      newheight = bmp_info-pix_height.

    bmp_info-ByteSize = xstrlen( XBMP_DATA ).
    bmp_info-sato_width = bmp_info-ByteSize / bmp_info-PIX_HEIGHT.
    tmpfloat = bmp_info-PIX_HEIGHT.
    bmp_info-sato_height = ceil( tmpfloat / 8 ).
  endif.

    "data tmptest type xstring. "for debuging
    "tmptest = XBMP_DATA(bmp_info-sato_width).

    unpack bmp_info-sato_width to chstr3.
    CONCATENATE chstr3 '' into text1.
    unpack bmp_info-sato_height to chstr3.
    CONCATENATE text1 chstr3 into text1.
    if_pdl_adrv~adrv_util->output_data( G_ESC_GB ).
    if_pdl_adrv~adrv_util->Convert_and_output( text1 ).
    if_pdl_adrv~adrv_util->output_data( XBMP_DATA ).

    pad_data = BMP_PADLINE( bmp_info ).
    if_pdl_adrv~adrv_util->output_data( pad_data ).
    if_pdl_adrv~adrv_util->output_data( c_crnl ).


  elseif IM_RAWDATA_TYPE = 'I'.

    data xcolortable type xstring.

    data tsize type i.
    tsize = bmp_info-colortableSize * 6.

    xcolortable = IM_RAWDATA+132(tsize).

    tsize = 132 + tsize.
    XBMP_DATA = IM_RAWDATA+tsize(bmp_info-BYTESize).
    data len type i.
    len = xstrlen( XBMP_DATA ).
    data xval type x.
    data  outstr type  xstring.
    data ai type i.
    data idx8 type i.
    data idxline type i.
    data x8val type x.
    outstr = ''.
    data idx type i.
    idx = 0.
    x8val = 0.
    data tmpxval type i.
*    data linesize type i.    linesize = 0.
    "data x8valstr type c.

    while idx < len.

      xval = XBMP_DATA+idx(1).
      tmpxval = xval.
      tmpxval = tmpxval * 6.
      hex1 = xcolortable+tmpxval(1).
      tmpi = hex1. "(.3xRed) + (.59xGreen) + (.11xBlue)= Luminance/brightness
      ai = '0.3' * tmpi.

      tmpxval = tmpxval + 2.
      hex1 = xcolortable+tmpxval(1).
      tmpi = hex1. "(.3xRed) + (.59xGreen) + (.11xBlue)= Luminance/brightness
      ai = ai + ( '0.4' * tmpi ).

      tmpxval = tmpxval + 2.
      hex1 = xcolortable+tmpxval(1).
      tmpi = hex1. "(.3xRed) + (.59xGreen) + (.11xBlue)= Luminance/brightness
      ai = ai + ( '0.3' * tmpi ).
      "ai = xval.    "* 6.
      xval = 0.
      if ai < 128.                                          "128.
        xval = idx8 + 1.
        SET BIT xval OF X8VAL. xval = 1.
      endif.

      idx8 = idx8 + 1. idxline = idxline + 1.
      if idxline =  bmp_info-PIX_WIDTH.
        idx8 = 8. "pad data
      endif.
      if idx8 = 8.
        "unpack x8val to x8valstr.
        CONCATENATE outstr x8val into outstr in BYTE MODE.
        IDX8 = 0. x8val = 0.
      endif.
      idx = idx + 1.
    endwhile.


    if_pdl_adrv~adrv_util->output_data( G_ESC_GB ).
    "data text1 TYPE STRING.
    "data chstr3(3) type c.
    "data tmpi type i.
    tmpi = ceil( bmp_info-PIX_WIDTH / 8 ).

    unpack tmpi to chstr3.
    CONCATENATE chstr3 '' into text1.
    tmpi = ceil( bmp_info-PIX_HEIGHT / 8 ).
    unpack tmpi to chstr3.
    CONCATENATE text1 chstr3 into text1.
    if_pdl_adrv~adrv_util->Convert_and_output( text1 ).
    if_pdl_adrv~adrv_util->output_data( outstr ).

*    data modval type i.
    data hmodval type i.
    data tmpnu type i.
    hmodval = bmp_info-PIX_HEIGHT MOD 8.
    data wmodval type i.
    wmodval = bmp_info-PIX_WIDTH MOD 8.
    tmpnu = bmp_info-PIX_WIDTH / 8.
    if wmodval > 0.
      tmpnu = tmpnu + 1.
    endif.
    if hmodval > 0.
      tmpnu = tmpnu * 8.
      data loopi type i.
      loopi = 0.
      data pch type c.
      pch = 0.
      data padstr type string.
      data loopoi type i.
      padstr = ''.
      while loopoi < hmodval.
        while loopi < tmpnu.
          CONCATENATE padstr pch into padstr.
          loopi = loopi + 1.
        endwhile.
        loopoi = loopoi + 1.
      endwhile.
      if_pdl_adrv~adrv_util->Convert_and_output( padstr ).
    endif.
    "conv = CL_ABAP_CONV_IN_CE=>CREATE( input = XBMP_DATA ).
    "conv->READ( importing data = BMP_DATA ).

    "if_pdl_adrv~adrv_util->output_data( XBMP_DATA ).
    if_pdl_adrv~adrv_util->output_data( c_crnl ).
  endif.

  RE_RC = c_retcode_ok. "ok
endmethod.
method IF_PDL_ADRV~START_OTF_PROCESSING.
*data devtype type rspoptype.
data msg(80) type c.

msg = 'start otf processing'. "#EC NOTEXT
IF_PDL_ADRV~ADRV_UTIL->TRC( CALLER  = C_MYCLASSNAME
                            MESSAGE = msg ).

" Process the SmartForms Commands
Convert_Command( ).

if im_otf-tdprintcom <> '//'.
  msg = '1st OTF command is not //'. "#EC NOTEXT
  IF_PDL_ADRV~ADRV_UTIL->TRCERR( CALLER  = C_MYCLASSNAME
                                 MESSAGE = msg ).
  re_rc = c_retcode_err_any.
  exit.
endif.
if im_otf-tdprintpar(1) = 'X'.
  ConvertOpen( im_otf-tdprintpar ).

else.
  msg = '1st OTF cmd // does not have STARTFLAG set'. "#EC NOTEXT
  IF_PDL_ADRV~ADRV_UTIL->TRCERR( CALLER  = C_MYCLASSNAME
                                 MESSAGE = msg ).
  re_rc = c_retcode_err_any.
  exit.
endif.
* other housekeeping at start of OTF?
*
re_rc = c_retcode_ok.
endmethod.
method INIT_SJMAP.
  G_PATTERN_SJMAP = ''.
  data: xin type x length 2,
        xout type x length 2.

  do 10 times.
    xin = 47 + sy-index.
    xout = 33358 + sy-index. "0x8248
    CALL METHOD  ADD_TO_PATTERN EXPORTING:
      P_IN = xin P_OUT = xout.
  enddo.

  do 26 times.
    xin = 64 + sy-index.
    xout = 33375 + sy-index. "'825f'
    CALL METHOD  ADD_TO_PATTERN EXPORTING:
      P_IN = xin P_OUT = xout.
  enddo.

  do 26 times.
    xin = 96 + sy-index.
    xout = 33408 + sy-index. "'8280'
    CALL METHOD  ADD_TO_PATTERN EXPORTING:
      P_IN = xin P_OUT = xout.
  enddo.

  CALL METHOD  ADD_TO_PATTERN EXPORTING:
      P_IN = '0021' P_OUT = '8149',
      P_IN = '0022' P_OUT = '818D' ,
      P_IN = '0023' P_OUT = '8194',
      P_IN = '0024' P_OUT = '8190',
      P_IN = '0025' P_OUT = '8193',
      P_IN = '0026' P_OUT = '8195',
      P_IN = '0027' P_OUT = '818C',
      P_IN = '0028' P_OUT = '8169',
      P_IN = '0029' P_OUT = '816A',
      P_IN = '002A' P_OUT = '8143'
      .

G_PATTERN_SJMAP = ` `. "<=== must be this way to put 'space'0x2000 (32)
                        " without ` ` 2000 space will be gone in concat func
xin = 32.
xout = 12288.
CALL METHOD  ADD_TO_PATTERN EXPORTING:
      P_IN = xin P_OUT = xout. "
do 94 times. "U+0021 -> U+007E / U+FF01 -> U+FF5E
  xin = 32 + sy-index.
  xout = 65280 + sy-index.
  CALL METHOD  ADD_TO_PATTERN EXPORTING
      P_IN = xin P_OUT = xout.
enddo.

   CALL METHOD  ADD_TO_PATTERN EXPORTING:
  P_IN = 'FF61'  P_OUT = '3002' ,
  P_IN = 'FF62'  P_OUT = '300C' ,
  P_IN = 'FF63'  P_OUT = '300D' ,
  P_IN = 'FF64'  P_OUT = '3001' ,
  P_IN = 'FF65'  P_OUT = '30FB' ,
  P_IN = 'FF66'  P_OUT = '30F2' ,
  P_IN = 'FF67'  P_OUT = '30A1' ,
  P_IN = 'FF68'  P_OUT = '30A3' ,
  P_IN = 'FF69'  P_OUT = '30A5' ,
  P_IN = 'FF6A'  P_OUT = '30A7' ,
  P_IN = 'FF6B'  P_OUT = '30A9' ,
  P_IN = 'FF6C'  P_OUT = '30E3' ,
  P_IN = 'FF6D'  P_OUT = '30E5' ,
  P_IN = 'FF6E'  P_OUT = '30E7' ,
  P_IN = 'FF6F'  P_OUT = '30C3' ,
  P_IN = 'FF70'  P_OUT = '30FC' ,
  P_IN = 'FF71'  P_OUT = '30A2' ,
  P_IN = 'FF72'  P_OUT = '30A4' ,
  P_IN = 'FF73'  P_OUT = '30A6' ,
  P_IN = 'FF74'  P_OUT = '30A8' ,
  P_IN = 'FF75'  P_OUT = '30AA' ,
  P_IN = 'FF76'  P_OUT = '30AB' ,
  P_IN = 'FF77'  P_OUT = '30AD' ,
  P_IN = 'FF78'  P_OUT = '30AF' ,
  P_IN = 'FF79'  P_OUT = '30B1' ,
  P_IN = 'FF7A'  P_OUT = '30B3' ,
  P_IN = 'FF7B'  P_OUT = '30B5' ,
  P_IN = 'FF7C'  P_OUT = '30B7' ,
  P_IN = 'FF7D'  P_OUT = '30B9' ,
  P_IN = 'FF7E'  P_OUT = '30BB' ,
  P_IN = 'FF7F'  P_OUT = '30BD' ,
  P_IN = 'FF80'  P_OUT = '30BF' ,
  P_IN = 'FF81'  P_OUT = '30C1' ,
  P_IN = 'FF82'  P_OUT = '30C4' ,
  P_IN = 'FF83'  P_OUT = '30C6' ,
  P_IN = 'FF84'  P_OUT = '30C8' ,
  P_IN = 'FF85'  P_OUT = '30CA' ,
  P_IN = 'FF86'  P_OUT = '30CB' ,
  P_IN = 'FF87'  P_OUT = '30CC' ,
  P_IN = 'FF88'  P_OUT = '30CD' ,
  P_IN = 'FF89'  P_OUT = '30CE' ,
  P_IN = 'FF8A'  P_OUT = '30CF' ,
  P_IN = 'FF8B'  P_OUT = '30D2' ,
  P_IN = 'FF8C'  P_OUT = '30D5' ,
  P_IN = 'FF8D'  P_OUT = '30D8' ,
  P_IN = 'FF8E'  P_OUT = '30DB' ,
  P_IN = 'FF8F'  P_OUT = '30DE' ,
  P_IN = 'FF90'  P_OUT = '30DF' ,
  P_IN = 'FF91'  P_OUT = '30E0' ,
  P_IN = 'FF92'  P_OUT = '30E1' ,
  P_IN = 'FF93'  P_OUT = '30E2' ,
  P_IN = 'FF94'  P_OUT = '30E4' ,
  P_IN = 'FF95'  P_OUT = '30E6' ,
  P_IN = 'FF96'  P_OUT = '30E8' ,
  P_IN = 'FF97'  P_OUT = '30E9' ,
  P_IN = 'FF98'  P_OUT = '30EA' ,
  P_IN = 'FF99'  P_OUT = '30EB' ,
  P_IN = 'FF9A'  P_OUT = '30EC' ,
  P_IN = 'FF9B'  P_OUT = '30ED' ,
  P_IN = 'FF9C'  P_OUT = '30EF' ,
  P_IN = 'FF9D'  P_OUT = '30F3' ,
  P_IN = 'FF9E'  P_OUT = '309B' ,
  P_IN = 'FF9F'  P_OUT = '309C' .


*  CALL METHOD  ADD_TO_PATTERN EXPORTING:
*      P_IN = '2000' P_OUT = '3000'. "  ,
*      P_IN = '2000' P_OUT = '3000',
*      P_IN = 'FF61' P_OUT = '3002',
*      P_IN = 'FF62' P_OUT = '300C',
*      P_IN = 'FF63' P_OUT = '300D',
*      P_IN = 'FF64' P_OUT = '3001',
*      P_IN = 'FF65' P_OUT = '30FB',
*      P_IN = 'FF66' P_OUT = '30F2',
*      P_IN = 'FF67' P_OUT = '30A1',
*      P_IN = 'FF68' P_OUT = '30A3',
*      P_IN = 'FF69' P_OUT = '30A5',
*      P_IN = 'FF6A' P_OUT = '30A7',
*      P_IN = 'FF6B' P_OUT = '30A9',
*      P_IN = 'FF6C' P_OUT = '30E3',
*      P_IN = 'FF6D' P_OUT = '30E5',
*      P_IN = 'FF6E' P_OUT = '30E7',
*      P_IN = 'FF6F' P_OUT = '30C3'.



endmethod.
method MAPBC128_AUTO.
  data: "idx type i,
        len type i, numstr type string value '0123456789', tmpi type i,
        "tmpi1 type i, tmpi2 type i, tmpi3 type i,  numcnt type i,
        inputstr type string, bpref type string.
  inputstr = BC128_InvalidateInvo( input ).

* New Method----------------------------------------------------
  data: loopidx type i, f1 type i value 4, looplen type i,
        cpref type string, tmpout type string, fs type string.

  len  = strlen( inputstr ).
  loopidx = 0.
  output = ''.
  bpref = '>H'.
  cpref = '>I'.
  tmpout = ''.
  do.
    tmpi = loopidx + f1.
    if tmpi >= len.
      exit.
    endif.
*    TMPI = STRLEN( OUTPUT ).
*    IF TMPI > 0.
*      BPREF = '>d'.
*      CPREF = '>c'.
*    ENDIF.

    fs = inputstr+loopidx(f1) .
    if fs co numstr. " has numbers
      looplen = f1.
      while inputstr+tmpi(1) co numstr. " find more number behind
        looplen = looplen + 1.
        CONCATENATE fs inputstr+tmpi(1) into fs.
        tmpi = tmpi + 1.
        "loopidx = loopidx + 1.
        if tmpi >= len.
          exit.
        endif.
      endwhile.
      tmpi = looplen mod 2.
      if tmpi <> 0. "if not even ignore last number.
        tmpi = loopidx + looplen.
        if tmpi >= len. "Last is odd number numerics >D first
          CONCATENATE tmpout fs(1) into tmpout.
          "looplen = looplen - 1. looplen not change
          tmpi = looplen  - 1.
          "loopidx = loopidx - 1.
          CONCATENATE '' fs+1(tmpi) into fs.

        else. "normally last numeric will be skip
          looplen = looplen - 1.
          "loopidx = loopidx - 1.
          CONCATENATE '' fs(looplen) into fs.
        endif.
      endif.
      "here we have set of numbers.
      tmpi = strlen( tmpout ).
      if tmpi > 0. "prev block is text add that first.
        CONCATENATE output bpref tmpout into output.
        cpref = '>C'.
        tmpout = ''.
      endif.
      CONCATENATE output cpref fs into output.
      bpref = '>D'.
      cpref = '>C'.
      loopidx = loopidx + looplen.
    else. " no number just text.
      CONCATENATE tmpout inputstr+loopidx(1) into tmpout.
      loopidx = loopidx + 1.
    endif.
    "loopidx = loopidx + f1.
  enddo.
  tmpi = strlen( tmpout ).
  if tmpi > 0. "prev block is text add that first.
    CONCATENATE output bpref tmpout into output.
    bpref = ''.
  endif.
  if loopidx < len.
    tmpi = len - loopidx.
    CONCATENATE output bpref inputstr+loopidx(tmpi) into output.
  endif.
* End of New Method ---------------------------------------

*  DATA result_tab TYPE MATCH_RESULT_TAB.
*
*  FIND ALL OCCURRENCES OF REGEX '(\d{4,})'
*     IN inputstr RESULTS result_tab.
*  FIELD-SYMBOLS <fs> type MATCH_RESULT.
*  output = ''.
*  idx = 0.
*  bpref = '>H'.
*  loop at result_tab ASSIGNING <fs>.
*    if idx > 0.
*      bpref = '>D'.
*    endif.
*    if <fs>-offset = 0.
*      tmpi = <fs>-length mod 2.
*      if tmpi = 0.
*         CONCATENATE '>I' inputstr+<fs>-offset(<fs>-length) into output.
*      else.
*        tmpi2 = <fs>-length - 1.
*        CONCATENATE bpref inputstr(1) '>C' inputstr+1(tmpi2) into output.
*      endif.
*    else.
*      tmpi = <fs>-length mod 2.
*      tmpi1 = <fs>-offset .
*      tmpi2 = <fs>-length .
*      if tmpi <> 0.
*
*        tmpi1 = <fs>-offset + 1.
*        tmpi2 = <fs>-length - 1.
*      endif.
*      tmpi3 = tmpi1 - idx.
*      CONCATENATE output bpref inputstr+idx(tmpi3) '>C' inputstr+tmpi1(tmpi2) into output.
*
*    endif.
*    idx = <fs>-offset + <fs>-length. " add 2 plac for >C
*
*  endloop.
*
*  len = strlen( inputstr ).
*  if idx < len.
*    tmpi3 = len - idx.
*    CONCATENATE output bpref inputstr+idx(tmpi3) into output.
*  endif.

  output = BC128_MAPINVO( output ).
endmethod.
method MAPBC128_N.

  output = BC128_InvalidateInvo( input ). "Do error correction first

  if output(2) = '>9' .
     output = MAPCODE128A( input = output NFLAG = 1 ST = 'X' ).
  elseif output(2) = '>:' .
     output = MAPCODE128B( input = output NFLAG = 1 ).
  elseif output(2) = '>;' .
     output = MAPCODE128C( input = output NFLAG = 1 ST = 'X' ).
  else.
    CONCATENATE '>:' output into output.
   output = MAPCODE128B( input = output NFLAG = 1 ).
  endif.
  "----------------------------



endmethod.
method MAPCODE128A.
  "G_BC128A_TBL
  data: idx type i, len type i, indexer type i, tmpi type i.

  "--------------for auto switching ------
  data: moffb type i, moffc type i, switchout type string,
        moffc99 type i, normalout  type string, switchto type i.
  switchout = ''.
  switchto = 0.
  if NFLAG > 0. "do auto switch
    moffb = -1.
    find '>6' in input MATCH OFFSET moffb. "search switch code for A
    moffc = -1.
    find '>5' in input MATCH OFFSET moffc. "search switch code for C
    moffc99 = -1.
    moffc99 = BC128A_FIND99( input ). "search for switch code for C (code 99)
    if moffc > -1 and moffc99 > -1.
      if moffc99 < moffc.
        moffc = moffc99.
      endif.
    elseif moffc99 > -1.
      moffc = moffc99.
    endif.
    if moffb > -1 and moffc > -1. "both exist get smaller
      if moffb < moffc.
        switchto = 1.
      else.
        switchto = 2.
      endif.
    elseif moffb > -1. "only a
      switchto = 1.
    elseif moffc > -1. "only C
      switchto = 2.
    else. " no switchcode
      switchto = 0.
    endif.
  endif.

  if switchto = 1.
    switchout = input+moffb.
    switchout = MAPCODE128B( input = switchout NFLAG  = 1 ).
    normalout = input(moffb).
  elseif switchto = 2.
    switchout = input+moffc.
    if moffc = moffc99.
      CONCATENATE '>5' switchout+2 into switchout.
    endif.
    switchout = MAPCODE128C( input = switchout NFLAG  = 1 ).
    normalout = input(moffc).
  else.
    switchout = ''.
    normalout = input.
  endif.
  " --------------autoswitch -------------

  "CodeA MAPPING start ----------------------------
  output = ''.
  idx = 0.
  if normalout(2) = '>9' or normalout(2) = '>7'.
    idx = 2.
    if ST = 'X'.
      output = '>G'.
    else.
      output = '>E'.
    endif.
  endif.
  len = strlen( normalout ).
  len = len - idx.
  tmpi = len mod 2.
  if tmpi <> 0.
    len = len - 1.
  endif.
  if len < 0.
    len = 0.
  else.
    len = len / 2.
  endif.
  data numstr type string value '0123456789'.
  do len times.
    if normalout+idx(2) co numstr. "chk only numeric
      indexer = normalout+idx(2).
      if indexer > 63.
        indexer = indexer - 64.
        CONCATENATE output '>' into output.
      endif.
      CONCATENATE output G_BC128A_TBL+indexer(1) into output.
    endif.
    idx = idx + 2.
  enddo.
  "if number count is not even then last one print as it is.
  if tmpi <> 0.
    len = strlen( normalout ) - 1.
    CONCATENATE output normalout+len(1) into output.
  endif.
  CONCATENATE output switchout into output.
endmethod.
method MAPCODE128B.
  data: moffa type i, moffc type i, switchout type string,
        normalout  type string, switchto type i.
  switchout = ''.
  switchto = 0.
  if NFLAG > 0. "do auto switch
    moffa = -1.
    find '>7' in input MATCH OFFSET moffa. "search switch code for A
    moffc = -1.
    find '>5' in input MATCH OFFSET moffc. "search switch code for C

    if moffa > -1 and moffc > -1. "both exist get smaller
      if moffa < moffc.
        switchto = 1.
      else.
        switchto = 2.
      endif.
    elseif moffa > -1. "only a
      switchto = 1.
    elseif moffc > -1. "only C
      switchto = 2.
    else. " no switchcode
      switchto = 0.
    endif.
  endif.

  if switchto = 1.
    switchout = input+moffa.
    switchout = MAPCODE128A( input = switchout NFLAG  = 1 ).
    normalout = input(moffa).
  elseif switchto = 2.
    switchout = input+moffc.
    switchout = MAPCODE128C( input = switchout NFLAG  = 1 ).
    normalout = input(moffc).
  else.
    switchout = ''.
    normalout = input.
  endif.
  output = BC128_MapInvo( normalout ).
  CONCATENATE output switchout into output.
endmethod.
method MAPCODE128C.
  "--------------for auto switching ------
  data: moffb type i, moffa type i, switchout type string,
        normalout  type string, switchto type i.
  switchout = ''.
  switchto = 0.
  if NFLAG > 0. "do auto switch
    moffb = -1.
    find '>6' in input MATCH OFFSET moffb. "search switch code for A
    moffa = -1.
    find '>7' in input MATCH OFFSET moffa. "search switch code for C

    if moffb > -1 and moffa > -1. "both exist get smaller
      if moffb < moffa.
        switchto = 1.
      else.
        switchto = 2.
      endif.
    elseif moffb > -1. "only a
      switchto = 1.
    elseif moffa > -1. "only C
      switchto = 2.
    else. " no switchcode
      switchto = 0.
    endif.
  endif.

  if switchto = 1.
    switchout = input+moffb.
    switchout = MAPCODE128B( input = switchout NFLAG  = 1 ).
    normalout = input(moffb).
  elseif switchto = 2.
    switchout = input+moffa.
    switchout = MAPCODE128A( input = switchout NFLAG  = 1 ).
    normalout = input(moffa).
  else.
    switchout = ''.
    normalout = input.
  endif.
  " --------------autoswitch -------------
  data: len type i, tmpi type i, idx type i.
  len = strlen( normalout ).
  tmpi = len mod 2.
  idx = 0.
  output = ''.
  if normalout(2) = '>;' or normalout(2) = '>5'.
    idx = 2.
  endif.
  if tmpi <> 0.
    if ST = 'X'.
      output = '>H'.
    else.
      output = '>D'.
    endif.
    CONCATENATE output normalout+idx(1) into output.
    idx = idx + 1.
  endif.
  if ST = 'X'.
    if strlen( output ) = 0.
      CONCATENATE output '>I' normalout+idx into output.
    else.
      CONCATENATE output '>C' normalout+idx into output.
    endif.
  else.
    CONCATENATE output '>C' normalout+idx into output.
  endif.
  CONCATENATE output switchout into output.

  " Not confirmed. Please test this
  output = BC128_MAPINVO( output ).
endmethod.
method MAPCODE93.

    data: lutidx type i, oluf2 TYPE i value 1, tmphex type x,
          oluf3 TYPE i value 97, moff type i.

  DATA: slen type i, sidx type i, tmpi .
  slen = strlen( input ).

  if slen < 2.
    if slen = 1.
      FIELD-SYMBOLS <output> type x.
      data tmpinput type c.
      tmpinput = input(1).
      assign tmpinput to <output> casting.
      xoutput = ''.
      CONCATENATE xoutput <output> into xoutput in byte mode.
    endif.
    RETURN.
  endif.
  slen = slen - 1.

  xoutput = ''.
  sidx = 0.
  DO.

    lutidx = 0.
    do.
      moff = -1.
      find input+sidx(2) in G_CODE93_lut1+lutidx match OFFSET moff.

      if moff = 0 or moff = -1 .
        exit.
      endif.
      moff = moff + lutidx.
      tmpi = moff mod 2.
      if tmpi = 0.
        exit.
      endif.
      if tmpi > 0.
        lutidx = moff + 1.
      endif.
    enddo.
    if moff > -1.
      if moff > 0.
        moff = moff / 2.
      endif.
      CONCATENATE xoutput G_CODE93_luf1+moff(1) into xoutput in BYTE MODE.
      sidx = sidx + 1.
    else.
      lutidx = 0.
      do.
        moff = -1.
        find input+sidx(2) in G_CODE93_lut2+lutidx match OFFSET moff.

        if moff = 0 or moff = -1 .
          exit.
        endif.
        moff = moff + lutidx.
        tmpi = moff mod 2.
        if tmpi = 0.
          exit.
        endif.
        if tmpi > 0.
          lutidx = moff + 1.
        endif.
      enddo.

      if moff > -1.
        if moff > 0.
          moff = moff / 2.
        endif.
        tmphex = moff + oluf2.
        CONCATENATE xoutput tmphex into xoutput in BYTE MODE.
        sidx = sidx + 1.
      else.
        lutidx = 0.
        do.
          moff = -1.
          find input+sidx(2) in G_CODE93_lut3+lutidx match OFFSET moff.

          if moff = 0 or moff = -1 .
            exit.
          endif.
          moff = moff + lutidx.
          tmpi = moff mod 2.
          if tmpi = 0.
            exit.
          endif.
          if tmpi > 0.
            lutidx = moff + 1.
          endif.
        enddo.
        if moff > -1.
          if moff > 0.
            moff = moff / 2.
          endif.
          tmphex = moff + oluf3.
          CONCATENATE xoutput tmphex into xoutput in BYTE MODE.
          sidx = sidx + 1. "All lookup are two char, advance one
        else. "No replacement direct copy
          Field-SYMBOLS <fs> type x.
          data tmpc type c.
          tmpc = input+sidx(1) .
          assign tmpc to <fs> CASTING .
          move <fs> to tmpi.
          CONCATENATE xoutput <fs>(1) into xoutput in BYTE MODE .
        endif.
      endif.
    endif.





    sidx = sidx + 1.
    if sidx >= slen.
      exit.
    endif.
  ENDDO.

  if sidx <= slen .

    tmpc = input+sidx(1) .
    assign tmpc to <fs> CASTING .
    move <fs> to tmpi.
    CONCATENATE xoutput <fs>(1) into xoutput in BYTE MODE .
  endif.
endmethod.
method MAPPDF417.
  data: len type i, sidx type i, fstr type string, rstr type xstring,
        tmpi type i.
  field-SYMBOLS <fsx> type x.
  field-SYMBOLS <fsc> type c .
  len = strlen( input ).
  if len < 2.
    return.
  endif.

  sidx = 0.
  output = ''.
  do.
    fstr = input+sidx(2).
    rstr = ''.
    if fstr = '\&'.
      rstr = '0D0A'.
      sidx = sidx + 1.
    ELSEIF fstr = '\\'.
      assign '\' to <fsc> casting.
      assign <fsc> to <fsx> casting type x.
      rstr = <fsx>(1).
      sidx = sidx + 1.
    elseif fstr = '\0'.
      tmpi = sidx + 5.
      if tmpi <= len.
        if input+sidx(3) = '\0x'.
          tmpi = sidx + 3.
          fstr = input+tmpi(2).
          if fstr co '0123456789'.
            data hh(2) type x.
            hh  = fstr.

            rstr = hh(1).

            sidx = sidx + 4.
          endif.
        endif.
      endif.
    else.
      tmpi = sidx + 2.
      if tmpi = len.
        tmpi = 2.
      else.
        tmpi = 1.
      endif.
      data ch1 type c.
      ch1 = input+sidx(tmpi).
      assign ch1 to <fsc> casting.
      assign <fsc> to <fsx> casting type x.
      rstr = <fsx>(1).
    endif.
    CONCATENATE output rstr into output in BYTE MODE.
    sidx = sidx + 1.
    tmpi = sidx + 1.
    if tmpi >= len.
      if sidx < len.
        ch1 = input+sidx(1).
        assign ch1 to <fsc> casting.
        assign <fsc> to <fsx> casting type x.
        rstr = <fsx>(1).
        CONCATENATE output rstr into output in BYTE MODE.
        endif.
      exit.
    endif.

  enddo.


endmethod.
method NEWST_PROCESS.
  data tbllines type i.
  tbllines = lines( G_ST_TBL ).
  if tbllines <= 0 .
    return.
  endif.

  data curst type Y_ST_STORE.
  data fs type c value 'X'.
  data maxsize type i.

*  data tmpstrw type string.
*  data tmpstrh type string.
*  data ffs type string.
  DATA RDBFntHeight Type i.


  LOOP AT G_ST_TBL INTO curst.
    RDBFntHeight = curst-ST_FONT-fontsize.
    "    IF curst-ST_Font-fontfamily = 'HELVE'.
    "      ffs = curst-ST_FONT-fontsize.
    "      GETPREFIXEDFONTSIZERDB(
    "               EXPORTING
    "                 FONTSIZEPT = ffs
    "               IMPORTING
    "                 FWIDTH     = tmpstrw
    "                 FHEIGHT    = tmpstrh ).
    "      RDBFntHeight = tmpstrh.
    "    endif.
    if sy-tabix = 1.
      maxsize = RDBFntHeight. "curst-ST_Font-FontSize.
      continue.
    endif.
    if maxsize < RDBFntHeight. "curst-ST_Font-FontSize.
      maxsize = RDBFntHeight. "curst-ST_Font-FontSize.
    endif.
  ENDLOOP.
  data prevfs type i value 0.
  data curWindow type String.

  LOOP AT G_ST_TBL INTO curst.
    if sy-tabix > 1.
      fs = ' '.
    ELSE.
      curWindow = ''.
      CONCATENATE curWindow G_Cur_Window into curWindow.
    endif.

      "maxsize = curst-ST_Font-FontSize.
      NEWST_PROCESS_ST(
        EXPORTING
            ST_INFO   = curst
            MT_POS    = G_PREVLINE_MT
            FIRSTTIME = fs
            MaxFontSize = maxsize
            WindowName = curWindow
        CHANGING
            PrevFontSize = prevfs ).


  ENDLOOP.
  REFRESH G_ST_TBL.
  clear G_PREVLINE_MT.
endmethod.
method NEWST_PROCESS_ST.
 DATA st_bytecount(2) TYPE n.
*  DATA st_width_tw(5) TYPE n.
  DATA len TYPE i.
  DATA count TYPE i.

  DATA f_size TYPE i.
  DATA ch3(3) TYPE c.
*  DATA c_width(3) TYPE c.

  DATA mytext TYPE string.
  DATA mydata TYPE string.
  DATA unicodeMarkup TYPE string.
  unicodeMarkup = 'SFU'.

  Data proportional_outline_font_flag Type i.

  proportional_outline_font_flag = 0.

* 11 Feb 2009: Chan Kong Hing
* Normally HELVE uses ESC+RD. If PC1 is different from PC2,
* it means HELVE is using Outline font (ESC+$).
  if ST_Info-ST_Font-fontfamily = 'HELVE' AND
    ST_Info-ST_Font-pc1 NE ST_Info-ST_Font-pc2.
    proportional_outline_font_flag = 1.
  ENDIF.

  if ST_INFO-ST_SAPCHAR = 'X'.
    "Fixed 1 char for special char CH command
*    st_width_tw = 1.
    st_bytecount = 2.
    len = 1.
  else.
*    st_width_tw  = ST_Info(5).
    st_bytecount = ST_Info+5(2).
    len = st_bytecount DIV cl_abap_char_utilities=>charsize.
  endif.

  "DATA firsttime TYPE c VALUE ' '.
  "IF g_prev_command <> 'ST' .
  IF FirstTime = 'X'.
    Data Result Type String.

    Result = Process_Rotation_Cmd( Rotation_90 = G_WINDOW_90
                                    Rotation_180 = G_WINDOW_180
                                    Rotation_270 = G_WINDOW_270
                                    Window_name = WindowName
                                  ).

    IF Result EQ '90'.
      if_pdl_adrv~adrv_util->output_data( G_90_DEGREE ).
    ELSEIF Result EQ '180'.
       if_pdl_adrv~adrv_util->output_data( G_180_DEGREE ).
    ELSEIF Result EQ '270'.
      if_pdl_adrv~adrv_util->output_data( G_270_DEGREE ).
    ELSE.
      if_pdl_adrv~adrv_util->output_data( G_0_DEGREE ).
    ENDIF.

    " if it is COURIER, JPMINCHO AND DBGOTHIC
    " do not make it proportional
    " If it is a Chinese Font, make it fixed space
    IF ST_Info-ST_Font-fontfamily = 'CNSONG' OR
      ST_Info-ST_Font-fontfamily = 'CNHEI' OR
      ST_Info-ST_Font-fontfamily = 'CNKAI' OR
      ST_Info-ST_Font-fontfamily = 'TWSONG' OR
      ST_Info-ST_Font-fontfamily = 'TWDPHEI' OR
      ST_Info-ST_Font-fontfamily = 'TWMING'.
      " Release the Proportional pitch
      "if_pdl_adrv~adrv_util->output_printcontrol( name = 'ESCPR').
    ELSEIF ST_Info-ST_Font-fontfamily EQ 'DBMINCHO'.
      if_pdl_adrv~adrv_util->output_data( '1B503030' ).
    ELSEIF ST_Info-ST_Font-fontfamily NE 'COURIER' AND
      ST_Info-ST_Font-fontfamily NE 'JPMINCHO' AND
      ST_Info-ST_Font-fontfamily NE 'JPMINCHP' AND
      ST_Info-ST_Font-fontfamily NE 'DBGOTHIC'.
      " Proportional pitch
      if_pdl_adrv~adrv_util->output_data( ESCPS ).
    ENDIF.

    "KC Command was here

    if_pdl_adrv~adrv_util->output_data( ESC_H ).
    "CONCATENATE MT_POS-X '' INTO mytext.
    mytext = MT_POS-X.
    CONDENSE mytext NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = mytext ).
ENDIF.

*data tmpstrw type string.
*data tmpstrh type string.
data fs type string.
DATA RDBFntHeight Type i.
RDBFntHeight = ST_INFO-ST_FONT-fontsize.
"IF ST_Info-ST_Font-fontfamily = 'HELVE'.
"  fs = ST_INFO-ST_FONT-fontsize.
"  CALL METHOD  GETPREFIXEDFONTSIZERDB
"            EXPORTING
"              FONTSIZEPT = fs
"            IMPORTING
"              FWIDTH     = tmpstrw
"              FHEIGHT    = tmpstrh.
"  RDBFntHeight = tmpstrh.
"endif.
"if FirstTime = 'X' or ST_INFO-ST_FONT-fontsize <> MAXFONTSIZE.
if FirstTime = 'X' or RDBFntHeight <> PrevFontSize.
    if_pdl_adrv~adrv_util->output_data( ESC_V ).

    "f_size = ( ST_Info-ST_Font-fontsize / 10 * 20 * g_resolution ) / 1440.
    f_size = MAXFONTSIZE. "ST_INFO-ST_FONT-fontsize.
    f_size = f_size * g_fnth2dot_factor.
    " f_size = floor( f_size * G_FNTH2DOT_FACTOR ).
    "CONDENSE f_size NO-GAPS.
* DATA mt_baseline TYPE i.
    Data tmpii type i.
    tmpii = MT_POS-Y - ( f_size * 70 / 100 ).
    " precaution check
    IF tmpii < 0.
      tmpii = 0.
    ENDIF.

    tmpii = TRUNC( tmpii ).

    "the different
    f_size = MAXFONTSIZE - RDBFntHeight. "ST_INFO-ST_FONT-fontsize.
    f_size = f_size * g_fnth2dot_factor.
    tmpii = tmpii + ( f_size * 70 / 100 )  .
    "CONCATENATE y_dots '' INTO mytext.
    mytext = tmpii.
    CONDENSE mytext NO-GAPS.
    if_pdl_adrv~adrv_util->convert_and_output( text = mytext ).
  ENDIF.

  PrevFontSize = RDBFntHeight.
  "---------------
  IF FirstTime = 'X' OR g_prev_font <> ST_INFO-ST_FONT.
    g_prev_font = ST_INFO-ST_FONT.

    " Japanese fonts used Bitmap Fonts: 2 March 2009
    " Proportional fonts use scala font ESC+$
     IF ST_INFO-ST_FONT-fontfamily = 'JPMINCHP'.
      if_pdl_adrv~adrv_util->output_data( ESCP0 ).
      if_pdl_adrv~adrv_util->output_data( ESCKC ).
     ENDIF.

                  DATA : theData TYPE STRING.
                  theData = ST_Info-ST_Font-pc1(3).
                  "theData = ST_Info(len).


                  IF theData NS unicodeMarkup.
                    if_pdl_adrv~adrv_util->output_printcontrol( name = ST_Info-ST_Font-pc1 ).
                  ENDIF.


* scalable font processing
    "f_size = ( ST_Info-ST_Font-fontsize / 10 * 20 * g_resolution ) / 1440.
    f_size = RDBFntHeight."ST_Info-ST_Font-fontsize.
    f_size = f_size * g_fnth2dot_factor.
    "CONDENSE f_size NO-GAPS.
    IF ST_Info-ST_Font-fontfamily = 'TIMES' OR
      ST_Info-ST_Font-fontfamily = 'HELVE' OR
      ST_Info-ST_Font-fontfamily = 'COURIER' OR
      ST_Info-ST_Font-fontfamily = 'KPSAMMUL' OR
      ST_Info-ST_Font-fontfamily = 'CNSONG' OR
      ST_Info-ST_Font-fontfamily = 'CNSONGP' OR
      ST_Info-ST_Font-fontfamily = 'CNHEI' OR
      ST_Info-ST_Font-fontfamily = 'CNKAI' OR
      ST_Info-ST_Font-fontfamily = 'TWSONG' OR
      ST_Info-ST_Font-fontfamily = 'TWDPHEI' OR
      ST_Info-ST_Font-fontfamily = 'TWMING' OR
      ST_Info-ST_Font-fontfamily = 'TWMINGP' OR
      ST_Info-ST_Font-fontfamily = 'THANGSAN' OR
      ST_Info-ST_Font-fontfamily = 'KPBATANP' OR
      ST_Info-ST_Font-fontfamily = 'JPMINCHP' OR
      ST_Info-ST_Font-fontfamily = 'ZCOMIC'.
*      c_width = ( ST_Info-ST_Font-chwidth * g_resolution ) / 1440.
*      CONDENSE c_width NO-GAPS.

* construction font size
      mytext = ''.
      IF ( ST_Info-ST_Font-fontfamily = 'HELVE' AND
          proportional_outline_font_flag = 1 ) OR
        ST_Info-ST_Font-fontfamily = 'COURIER' OR
        ST_Info-ST_Font-fontfamily = 'JPMINCHP'.
        IF f_size < 24.  " minimum value is 24dots
          f_size = 24.
        ENDIF.
      ELSEIF ST_Info-ST_Font-fontfamily = 'TIMES' OR
        ST_Info-ST_Font-fontfamily = 'HELVE' OR
        ST_Info-ST_Font-fontfamily = 'KPSAMMUL' OR
        ST_Info-ST_Font-fontfamily = 'CNSONG' OR
        ST_Info-ST_Font-fontfamily = 'CNSONGP' OR
        ST_Info-ST_Font-fontfamily = 'CNHEI' OR
        ST_Info-ST_Font-fontfamily = 'CNKAI' OR
        ST_Info-ST_Font-fontfamily = 'TWSONG' OR
        ST_Info-ST_Font-fontfamily = 'TWDPHEI' OR
        ST_Info-ST_Font-fontfamily = 'TWMING' OR
        ST_Info-ST_Font-fontfamily = 'TWMINGP' OR
        ST_Info-ST_Font-fontfamily = 'THANGSAN' OR
        ST_Info-ST_Font-fontfamily = 'KPBATANP' OR
        ST_Info-ST_Font-fontfamily = 'JPMINCHP' OR
        ST_Info-ST_Font-fontfamily = 'ZCOMIC'.
        IF f_size < 4.  " minimum value is 4dots
          f_size = 4.
        ENDIF.
      ENDIF.
      UNPACK f_size TO ch3.
*     IF f_size < 100.
*       CONCATENATE '0' f_size INTO mytext.
*     ELSE.
*       CONCATENATE '' f_size INTO mytext.
*     ENDIF.
*     CONCATENATE mytext ',' INTO mydata.
      CONCATENATE ch3 ',' INTO mydata.
      IF ( ST_Info-ST_Font-fontfamily = 'HELVE' AND
           proportional_outline_font_flag NE 1 ) OR
        ST_Info-ST_Font-fontfamily = 'CNSONG' OR
        ST_Info-ST_Font-fontfamily = 'CNSONGP' OR
        ST_Info-ST_Font-fontfamily = 'CNHEI' OR
        ST_Info-ST_Font-fontfamily = 'CNKAI' OR
        ST_Info-ST_Font-fontfamily = 'TWDPHEI' OR
        ST_Info-ST_Font-fontfamily = 'TWMING' OR
        ST_Info-ST_Font-fontfamily = 'TWMINGP' OR
        ST_Info-ST_Font-fontfamily = 'KPBATANP' OR
        ST_Info-ST_Font-fontfamily = 'JPMINCHP' OR
        ST_Info-ST_Font-fontfamily = 'TWSONG'.
        DATA mydatah TYPE string.
        "data fs type string.
        fs = ST_Info-ST_Font-fontsize.
        CALL METHOD  GETPREFIXEDFONTSIZERDB
          EXPORTING
            FONTSIZEPT = fs
          IMPORTING
            FWIDTH     = mydata
            FHEIGHT    = mydatah.

        CONCATENATE mydata ',' into mydata.
        CONCATENATE mydatah ',' into mydatah.
        IF theData NS unicodeMarkup.
         if_pdl_adrv~adrv_util->convert_and_output( text = mydata ).
         if_pdl_adrv~adrv_util->convert_and_output( text = mydatah ).
        ENDIF.
      else.
        IF theData NS unicodeMarkup.
         if_pdl_adrv~adrv_util->convert_and_output( text = mydata ).
        ENDIF.

*   Proportional character. Height = width
        IF theData NS unicodeMarkup.
         if_pdl_adrv~adrv_util->convert_and_output( text = mydata ).
        ENDIF.
      endif.

      IF ( ST_Info-ST_Font-fontfamily = 'HELVE' AND
           proportional_outline_font_flag = 1
         )
        OR
        ST_Info-ST_Font-fontfamily = 'COURIER' OR
        ST_Info-ST_Font-fontfamily = 'JPMINCHP'.
        IF ST_Info-ST_Font-italic = 'X'.
          IF theData NS unicodeMarkup.
           if_pdl_adrv~adrv_util->output_data( ESC_8_OUTLINE ).
          ENDIF.
        ELSE.
          IF theData NS unicodeMarkup.
           if_pdl_adrv~adrv_util->output_data( ESC_0_OUTLINE ).
          ENDIF.
        ENDIF.
      ENDIF.

* construction character width
*      myText = ''.
*      myData = ''.
*      IF c_width < 10.
*        CONCATENATE '00' c_width into myText.
*      elseif c_width < 100.
*        CONCATENATE '0' c_width into myText.
*      else.
*        CONCATENATE '' c_width into myText.
*      ENDIF.
*      CONCATENATE myText ',' into myData.
*
*      if_pdl_adrv~adrv_util->convert_and_output( text = myData ).

    ENDIF.
  ENDIF.
  " ENDIF.
  "------------- ori end here
  IF ST_Info-ST_Font-fontfamily(3) = 'OCR' .
    DATA xmydata TYPE xstring.

    FIELD-SYMBOLS <fs> TYPE x.
    DATA tmpc TYPE c.
    DATA tmpi TYPE i.
    tmpi = 7.
    xmydata = ''.
    DO len TIMES.

      tmpc = ST_Info+tmpi(1).
      tmpi = tmpi + 1.
      ASSIGN tmpc TO <fs> CASTING .
      "move <fs> to tmpi.
      CONCATENATE xmydata <fs> INTO xmydata IN BYTE MODE .
    ENDDO.

    "xmydata = ST_Info+7(len).
     IF theData NS unicodeMarkup.
      if_pdl_adrv~adrv_util->output_data( xmydata ).
     ENDIF.
  ELSEIF ST_INFO-ST_SAPCHAR = 'X'.
    CONVERTCH( ST_INFO-ST_OTF ).
  ELSE.
    mydata = ''.
    mydata = ST_Info+7(len).
    count = len - STRLEN( mydata ).

    DO count TIMES.
      CONCATENATE mydata ` ` INTO mydata.
    ENDDO.
    if  ST_Info-ST_Font-fontfamily = 'JPMINCHP'.
      TRANSLATE mydata using G_PATTERN_SJMAP.
    endif.

    IF ST_Info-ST_Font-fontfamily = 'KPBATANP' AND
       ST_Info-ST_Font-PC1 <> ST_Info-ST_Font-PC2.
        TRANSLATE mydata using G_PATTERN_KPMAP.
    endif.

"---------------------------------------------------------------
"It replaced the below section, could not print more than 31 characters when wrapped up with Unicode tag in a SmartForm (Croatian case/supported by Holger of SAP)
   IF theData NS unicodeMarkup .
     "DATA : dataNew TYPE XSTRING.
     "CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
                        "EXPORTING
                         " text     = mydata
                       "IMPORTING
                        "  buffer   = dataNew
                       " EXCEPTIONS
                        "  failed   = 1
                         " OTHERS   = 2.
       "IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( dataNew  ).
    if_pdl_adrv~adrv_util->convert_and_output( text = mydata ).
   ENDIF.
  ENDIF.

  "The original, replaced one
   "IF theData NS unicodeMarkup .
    "if_pdl_adrv~adrv_util->convert_and_output( text = mydata ).
   "ENDIF.
  "ENDIF.

"----------------------------------------------------------------



 "*From
 "IF ST_Info-ST_Font-pc1(3) CS unicodeMarkup .
 IF theData CS unicodeMarkup .

                  DATA : strCont TYPE XSTRING.
                  DATA : strCommand TYPE XSTRING.
                  DATA : strValue TYPE XSTRING.
                  DATA : data TYPE XSTRING.
                  DATA : mydata1 TYPE STRING.
                  mydata1 = mydata .

                 "REPLACE ALL OCCURRENCES OF unicodeMarkup IN mydata1 WITH ''. CONDENSE mydata1.
                  "strValue = 'E38293E382A1'. "UTF-8 value
                  "strValue = '3093'.    "UTF-16 value
                  "strCommand = '1B5247302C352C302C32302C32302C'. "UTF-8 command
                  "strCommand = '1B5247312C352C302C32302C32302C'."UTF-16 command
                  "data = ''.

                 CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
                        EXPORTING
                          text     = mydata1
                       IMPORTING
                          buffer   = data
                        EXCEPTIONS
                          failed   = 1
                          OTHERS   = 2.


                    "DATA :uuu TYPE STRING.
                    "uuu = ''.
                    "DATA :uuu1 TYPE STRING.
                    "uuu1 =  ST_Info-ST_Font-pc1.
                    "DATA :uuu2 TYPE XSTRING.
                    "uuu2 = ''.

                     "CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
                                          " EXPORTING
                                           "  text     = uuu1
                                         " IMPORTING
                                            " buffer   = uuu2
                                           "EXCEPTIONS
                                            " failed   = 1
                                            " OTHERS   = 2.

                      " CONCATENATE strCommand data  INTO strCont IN BYTE MODE.
                      "IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( strCont ).

               IF_PDL_ADRV~ADRV_UTIL->output_printcontrol( name = ST_Info-ST_Font-pc1 ).

                              "if_pdl_adrv~adrv_util->convert_and_output( text = data ). this generates hashes ####
               IF_PDL_ADRV~ADRV_UTIL->OUTPUT_DATA( data  ).

ENDIF.
"*To here



endmethod.
method NEWST_STOREDATA.
  data linecnt type i.
  linecnt = lines( G_ST_TBL ).
  if linecnt = 0.
    G_PREVLINE_MT-X = X * G_TWIP2DOT_FACTOR.
    G_PREVLINE_MT-Y = Y * G_TWIP2DOT_FACTOR.
  endif.

  data curdata type Y_ST_STORE .
  curdata-ST_OTF = OTF_DATA_STRING.
  curdata-ST_FONT = G_FONTINFO.
  curdata-ST_SAPCHAR = ISSAPCHAR.
  Append curdata to G_ST_TBL.
endmethod.
method OUTPUT_NEWLINE.
  if_pdl_adrv~adrv_util->output_data( '0D0A' ).
endmethod.
method OUTPUT_ROTATION.
    Data Result Type String.

    Result = Process_Rotation_Cmd( Rotation_90 = G_WINDOW_90
                                    Rotation_180 = G_WINDOW_180
                                    Rotation_270 = G_WINDOW_270
                                    Window_name = G_Cur_Window
                                  ).

    IF Result EQ '90'.
      if_pdl_adrv~adrv_util->output_data( G_90_DEGREE ).
    ELSEIF Result EQ '180'.
      if_pdl_adrv~adrv_util->output_data( G_180_DEGREE ).
    ELSEIF Result EQ '270'.
      if_pdl_adrv~adrv_util->output_data( G_270_DEGREE ).
    ELSE.
      if_pdl_adrv~adrv_util->output_data( G_0_DEGREE ).
    ENDIF.
endmethod.
METHOD process_rfid.
  DATA print_control(5) TYPE c.
  DATA satolockmask(5) TYPE c.
  DATA epc TYPE string.
  DATA usr TYPE string.
  DATA pc  TYPE string.

  " ESC+IP0,e:z  free mapping
  if_pdl_adrv~adrv_util->output_data( g_pc_nbtrfid ).

  IF lockmask = '01'.
    satolockmask = '00001'.
  ELSEIF lockmask = '04'.
    satolockmask = '10000'.
  ELSE. " Not supported
    satolockmask = ''.
  ENDIF.

  " Process BS command
  DATA: test2 TYPE string, test3 TYPE string.
  Data: curCmd Type String, prevCmd Type String, dataCmd Type String.

  DATA: tbl1 TYPE TABLE OF string,   tbl2 TYPE TABLE OF string.

  SPLIT BS_Command AT ';' INTO: TABLE tbl1.
  dataCmd = ''.
  LOOP AT tbl1 INTO test2.
    " WRITE: / test2.
    SPLIT test2 AT ':' INTO TABLE tbl2.
    " WRITE: / 'detail : '.
    prevCmd = ''.
    LOOP AT tbl2 INTO test3.
       IF prevCmd = ''.
         prevCmd = test3.
       ELSE.
         IF prevCmd = 'EPC'.
           CONCATENATE dataCmd ',d:' test3 INTO dataCmd.
         ELSEIF prevCmd = 'USR'.
           CONCATENATE dataCmd ',u:' test3 INTO dataCmd.
         ELSEIF prevCmd = 'ACS'.
           CONCATENATE dataCmd ',a:' test3 INTO dataCmd.
         ELSEIF prevCmd = 'LM'.
           IF test3 = '01'.
             CONCATENATE dataCmd ',m:00001' INTO dataCmd.
           ELSEIF test3 = '04'.
             CONCATENATE dataCmd ',m:10000' INTO dataCmd.
           ENDIF.
         ELSEIF prevCmd = 'KILL:'.
           CONCATENATE dataCmd ',k:' test3 INTO dataCmd.
         ENDIF.
         prevCmd = ''.
       ENDIF.
    ENDLOOP.
  ENDLOOP.

  IF acscode NE '' AND dataCmd NS ',a:'.
    CONCATENATE dataCmd ',a:' acsCode INTO dataCmd.
  ENDIF.
  IF satolockmask NE '' AND dataCmd NS ',m:'.
    CONCATENATE dataCmd ',m:' satolockMask INTO dataCmd.
  ENDIF.
  IF killCode NE '' AND dataCmd NS ',k:'.
    CONCATENATE dataCmd ',k:' killCode INTO dataCmd.
  ENDIF.

  CONCATENATE text1 dataCmd ';' INTO text1.
ENDMETHOD.
method PROCESS_ROTATION_CMD.
   DATA: tbl1 TYPE TABLE OF string.
   Data: test TYPE String.

   Result = ''.

   SPLIT ROTATION_90 AT ':' INTO: TABLE tbl1.
   LOOP AT tbl1 INTO test.
     IF test EQ WINDOW_NAME.
       RESULT = '90'.
       EXIT.
     ENDIF.
   ENDLOOP.

   IF Result EQ ''.
     CLEAR test.
     CLEAR tbl1.
     SPLIT ROTATION_180 AT ':' INTO: TABLE tbl1.
     LOOP AT tbl1 INTO test.
       IF test EQ WINDOW_NAME.
          RESULT = '180'.
          EXIT.
       ENDIF.
     ENDLOOP.
   ENDIF.

   IF Result EQ ''.
     CLEAR test.
     CLEAR tbl1.
     SPLIT ROTATION_270 AT ':' INTO: TABLE tbl1.
     LOOP AT tbl1 INTO test.
       IF test EQ WINDOW_NAME.
          RESULT = '270'.
          EXIT.
       ENDIF.
     ENDLOOP.
   ENDIF.
endmethod.
method SAVEPAGENUMBERS.
  DATA: tbrows TYPE TABLE OF string,
        tbitems TYPE TABLE OF string,
        tmpstr TYPE string,
        tmprec TYPE Y_PAGENUMS.

  SPLIT INPUT AT ',' INTO TABLE tbrows.

  LOOP AT tbrows INTO tmpstr.
    SPLIT tmpstr AT ':' INTO TABLE tbitems.
    READ TABLE tbitems index 1 INTO tmprec-Name.
    READ TABLE tbitems index 2 INTO tmprec-Num.
    INSERT tmprec INTO Table G_PAGENUMS.
  ENDLOOP.

endmethod.
