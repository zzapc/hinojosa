<?xml version="1.0" encoding="utf-8"?> <ENHO enhancement_id="ZSSD_ENH_CANT_MIN_M2" shorttext="Mantenimiento de cantidad mínima por M2" tooltype_id="HOOK_IMPL" orig_object="R3TR-SAPMV45A-PROG-SAPMV45A">  <asx:abap xmlns:asx="http://www.sap.com/abapxml" ver
sion="1.0">   <asx:values>    <IMPLS>     <ENH_HOOK_IMPL>      <SPOTNAME/>      <PROGRAMNAME>SAPMV45A</PROGRAMNAME>      <EXTID>1</EXTID>      <ID>1</ID>      <OVERWRITE/>      <METHOD/>      <ENHMODE>S</ENHMODE>      <FULL_NAME>\PR:SAPMV45A\FO:USEREXIT_S
AVE_DOCUMENT_PREPARE\SE:END\EI</FULL_NAME>      <SOURCE>       <item/>       <item>&quot; BG: Validación cantidad mínima por M2. Implementación EXIT para el chequeo de cantidad mínima de referencia por M2</item>       <item>&quot; 27.05.2024 - Esta valida
ción, se trae del original, en el perform USEREXIT_MOVE_FIELD_TO_VBEP enho ZSD_GAPSD022</item>       <item>DATA: lr_cnfidx        TYPE REF TO ycl_hp_idx,</item>       <item>lt_cm            TYPE TABLE OF zssdt_cm,</item>       <item>lv_calculo_x(10) TYPE
p DECIMALS 5,</item>       <item>lv_sblar(10)     TYPE p DECIMALS 5,</item>       <item>lv_wmeng(10)     TYPE p DECIMALS 5,</item>       <item>lv_zwmeng(10)    TYPE p DECIMALS 5,</item>       <item>lv_posnr_x       TYPE vbap-posnr,</item>       <item>lv_i
ndex         TYPE MESG-ZEILE,</item>       <item>lv_v1            TYPE SYST_MSGV,</item>       <item>lv_v2            TYPE SYST_MSGV,</item>       <item>t_rte            TYPE yhp_omp_tt_rte,</item>       <item>s_vbap_x         TYPE vbap,</item>       <ite
m>t_msg            TYPE esp1_message_tab_type,</item>       <item>s_msg            TYPE esp1_message_wa_type.</item>       <item/>       <item>IF sy-tcode = &apos;VA21&apos; OR sy-tcode = &apos;VA22&apos;.</item>       <item/>       <item>SELECT * FROM zs
sdt_cm INTO TABLE lt_cm</item>       <item>WHERE vkorg = vbak-vkorg</item>       <item>AND vtweg = vbak-vtweg</item>       <item>AND auart = vbak-auart.</item>       <item>IF sy-subrc EQ 0.</item>       <item>CLEAR lv_index.</item>       <item>REFRESH t_m
sg.</item>       <item>LOOP AT xvbap INTO DATA(ls_xvbap_aux).</item>       <item>CLEAR: lv_calculo_x, lr_cnfidx, lv_sblar, lv_wmeng, lv_zwmeng, t_rte,  s_vbap_x.</item>       <item>&quot; Datos Actualizados</item>       <item>READ TABLE xvbep INTO DATA(ls
_xvbep_aux) WITH KEY vbeln = ls_xvbap_aux-vbeln</item>       <item>posnr = ls_xvbap_aux-posnr.</item>       <item>IF sy-subrc EQ 0.</item>       <item>IF ls_xvbap_aux-bedae &lt;&gt; &apos;KSV&apos;.</item>       <item>MOVE-CORRESPONDING ls_xvbap_aux TO s_
vbap_x.</item>       <item/>       <item>TRY.</item>       <item>ycl_hp_sdu=&gt;pricing_prepare_tkomp_mv45a( EXPORTING is_vbap  = s_vbap_x</item>       <item>it_xvbap = xvbap[]</item>       <item>CHANGING cs_tkomp = tkomp ).</item>       <item>CATCH /vcxi
/cx_ckx.</item>       <item>ENDTRY.</item>       <item/>       <item>TRY.</item>       <item>lr_cnfidx ?= ycl_hp_idx=&gt;/vcxi/if_ckx_object~get_instance( if_guid = CONV /vcxi/ckx_guid( ls_xvbap_aux-cuobj ) ).</item>       <item>CHECK lr_cnfidx IS BOUND.<
/item>       <item>lr_cnfidx-&gt;get_data(</item>       <item>IMPORTING</item>       <item>et_spec_db  = DATA(lt_spec)  &quot; HP: IndexDB - Specification - DB</item>       <item>et_board_db = DATA(lt_board) &quot; HP: IndexDB - Board - DB</item>       <i
tem>et_print_db = DATA(lt_print) &quot; HP: IndexDB - Printing- DB</item>       <item>et_shipu_db = DATA(lt_shipu)  &quot; HP: IndexDB - Shipping Units - DB &quot;SMT - Añadir campo Container a Tkomp</item>       <item>et_rte_db   = DATA(lt_rte_db)     &q
uot; HP: IndexDB - Routing - DB</item>       <item>).</item>       <item/>       <item>t_rte = CORRESPONDING #( lt_rte_db ).</item>       <item/>       <item>TRY.</item>       <item>&quot;Specification data</item>       <item>SORT lt_spec BY sblar DESCEND
ING.</item>       <item>CHECK lt_spec[] IS NOT INITIAL.</item>       <item>DATA(ls_spec) = lt_spec[ 1 ].</item>       <item>CATCH cx_sy_itab_line_not_found.</item>       <item>ENDTRY.</item>       <item/>       <item>CATCH /vcxi/cx_ckx.</item>       <item
>ENDTRY.</item>       <item/>       <item>CHECK lt_board[] IS NOT INITIAL.</item>       <item>DATA(ls_board) = lt_board[ 1 ].</item>       <item/>       <item/>       <item>CLEAR lt_cm[].</item>       <item/>       <item>IF t_rte[] IS NOT INITIAL.</item>
      <item/>       <item>SELECT * FROM zssdt_cm INTO TABLE lt_cm</item>       <item>FOR ALL ENTRIES IN t_rte</item>       <item>WHERE vkorg = vbak-vkorg</item>       <item>AND vtweg = vbak-vtweg</item>       <item>AND werks = ls_xvbap_aux-werks</item>
    <item>AND auart = vbak-auart</item>       <item>AND pstyv = ls_xvbap_aux-pstyv</item>       <item>AND board = ls_board-board</item>       <item>AND flute = ls_board-flute</item>       <item>AND arbpl = t_rte-arbpl.</item>       <item/>       <item>END
IF.</item>       <item/>       <item>IF lt_cm[] IS INITIAL.</item>       <item/>       <item>SELECT * FROM zssdt_cm INTO TABLE lt_cm</item>       <item>FOR ALL ENTRIES IN t_rte</item>       <item>WHERE vkorg = vbak-vkorg</item>       <item>AND vtweg = vba
k-vtweg</item>       <item>AND werks = ls_xvbap_aux-werks</item>       <item>AND auart = vbak-auart</item>       <item>AND pstyv = ls_xvbap_aux-pstyv</item>       <item>AND arbpl = t_rte-arbpl.</item>       <item/>       <item>ENDIF.</item>       <item/>
      <item>IF lt_cm[] IS INITIAL .</item>       <item/>       <item>SELECT * FROM zssdt_cm INTO TABLE lt_cm</item>       <item>WHERE vkorg = vbak-vkorg</item>       <item>AND vtweg = vbak-vtweg</item>       <item>AND werks = ls_xvbap_aux-werks</item>
   <item>AND auart = vbak-auart</item>       <item>AND pstyv = ls_xvbap_aux-pstyv</item>       <item>AND board = ls_board-board</item>       <item>AND flute = ls_board-flute.</item>       <item/>       <item>ENDIF.</item>       <item/>       <item>IF lt_c
m[] IS NOT INITIAL.</item>       <item>SORT lt_cm BY zwmeng ASCENDING.</item>       <item>DATA(ls_cm) = lt_cm[ 1 ].</item>       <item/>       <item>lv_sblar = ls_spec-sblar.</item>       <item>lv_wmeng = ls_xvbep_aux-wmeng.</item>       <item>lv_calculo_
x = lv_sblar * lv_wmeng.</item>       <item>lv_calculo_x = lv_calculo_x / 1000.</item>       <item>lv_zwmeng = ls_cm-zwmeng * 100.</item>       <item/>       <item>IF lv_calculo_x LT lv_zwmeng.</item>       <item/>       <item>CLEAR: lv_v1, lv_v2.</item>
      <item/>       <item>CALL FUNCTION &apos;CONVERSION_EXIT_ALPHA_OUTPUT&apos;</item>       <item>EXPORTING</item>       <item>input  = ls_xvbep_aux-posnr</item>       <item>IMPORTING</item>       <item>output = lv_posnr_x.</item>       <item/>       <i
tem>lv_index = lv_index + 1.</item>       <item>lv_v1 = |{ &apos;POS&apos; } { lv_posnr_x }| &amp;&amp; &apos;,&apos; &amp;&amp; |{ &apos;NO supera la cantidad &apos; }|.</item>       <item>lv_v2 = |{ &apos;mínima en M2, referencia&apos; } { ls_cm-zwmeng
}|.</item>       <item/>       <item>s_msg-msgid  = &apos;ZSD&apos;.</item>       <item>s_msg-msgty  = &apos;W&apos;.</item>       <item>*                s_msg-msgno  = &apos;229&apos;.</item>       <item>*                s_msg-msgv1  = lv_posnr_x.</item>
       <item>*                s_msg-msgv2  = ls_cm-zwmeng.</item>       <item>s_msg-msgno  = &apos;056&apos;.</item>       <item>s_msg-msgv1  = lv_v1.</item>       <item>s_msg-msgv2  = lv_v2.</item>       <item>s_msg-lineno = lv_index.</item>       <item>
APPEND s_msg TO t_msg.</item>       <item>ENDIF.</item>       <item>ENDIF.</item>       <item>ENDIF.</item>       <item>ENDIF.</item>       <item>ENDLOOP.</item>       <item>IF t_msg[] IS NOT INITIAL.</item>       <item>CALL FUNCTION &apos;C14Z_MESSAGES_S
HOW_AS_POPUP&apos;</item>       <item>TABLES</item>       <item>i_message_tab = t_msg[].</item>       <item>ENDIF.</item>       <item>ENDIF.</item>       <item>ENDIF.</item>       <item/>      </SOURCE>      <PARENT_FULL_NAME/>     </ENH_HOOK_IMPL>    </I
MPLS>   </asx:values>  </asx:abap> </ENHO>
