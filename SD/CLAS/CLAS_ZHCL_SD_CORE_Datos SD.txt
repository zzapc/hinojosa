
class ZHCL_SD_CORE definition
  public
  inheriting from ZHCL_CORE
  create public .

public section.

  types:
    BEGIN OF t_reparto_entrega,
        vbeln        TYPE vbep-vbeln,
        posnr        TYPE vbep-posnr,
        kwmeng       TYPE vbap-kwmeng,
        vrkme        TYPE vbep-vrkme,
        etenr        TYPE vbep-etenr,
        ettyp        TYPE vbep-ettyp,
        edatu        TYPE vbep-edatu,
        wmeng        TYPE vbep-wmeng,
        bmeng        TYPE vbep-bmeng,
        entrega      TYPE vbeln_vl,
        entrega_pos  TYPE posnr,
        lfdat        TYPE likp-lfdat,
        wbstk        TYPE vbuk-wbstk,
        wadat_ist    TYPE likp-wadat_ist,
        icon_sm      TYPE string,
        lfimg        TYPE lips-lfimg,
        ctd_asignada TYPE cmm_alloc_qty,
      END OF t_reparto_entrega .
  types:
    tt_reparto_entrega TYPE STANDARD TABLE OF t_reparto_entrega WITH KEY vbeln posnr etenr entrega entrega_pos .
  types:
    BEGIN OF t_datos_ordenes,
        aufnr               TYPE aufnr,
        kdauf               TYPE caufv-kdauf,
        kdpos               TYPE caufv-kdpos,
        gltrs               TYPE caufv-gltrs,           " Fin programado
        gstrs               TYPE caufv-gstrs,           " Inicio programado
        gluzs               TYPE caufv-gsuzs,
        gstrp               TYPE caufv-gstrp,           " Fecha inicio extrema
        gltrp               TYPE caufv-gltrp,
        aufpl               TYPE caufv-aufpl,
        objnr               TYPE caufv-objnr,
        plnbez              TYPE caufv-plnbez,
        mtart_of            TYPE mara-mtart,
        stat_txt            TYPE bsvx-sttxt,
        situacion           TYPE zssd_de_situacion,
        situacion_txt       TYPE ddtext,
        steus               TYPE afvc-steus,
        afpo_ped            TYPE abap_bool,
        wemng               TYPE afpo-wemng,
        cant_prod_lib       TYPE zssd_de_cant_prod_lib,
        charg               TYPE afpo-charg,
        cant_tol_exceso     TYPE afpo-wemng,
        cant_tol_falta      TYPE afpo-wemng,
        zz_fecha_asignacion TYPE zz_fecha_asignacion,   " Fecha asignación cliente dinámica: Días de inicio orden + Días transito ruta
        ruta                TYPE zssd_ruta,
        sichz               TYPE caufvd-sichz,
      END OF t_datos_ordenes .
  types:
    tt_datos_ordenes TYPE STANDARD TABLE OF t_datos_ordenes WITH KEY aufnr .
  types:
    BEGIN OF t_necesidad_ordenes,
        kdauf        TYPE caufv-kdauf,
        kdpos        TYPE caufv-kdpos,
        tipo         TYPE zed_tipo_nec_of,
        werks        TYPE werks_d,
        bedae        TYPE bedae,
        of_necesaria TYPE zzcrear_of,
        aufnr        TYPE caufv-aufnr,
        auart        TYPE caufv-auart,
        matnr        TYPE matnr,
        mtart        TYPE mtart,
        beskz        TYPE marc-beskz,
        sobsl        TYPE marc-sobsl,
        origen       TYPE kedrident,
      END OF t_necesidad_ordenes .
  types:
    tt_necesidad_ordenes TYPE STANDARD TABLE OF t_necesidad_ordenes WITH KEY kdauf kdpos tipo werks bedae of_necesaria aufnr auart matnr mtart beskz sobsl origen .
  types:
    BEGIN OF t_repartos_base,
        vbeln                 TYPE vbep-vbeln,
        vbtyp                 TYPE vbak-vbtyp,
        auart                 TYPE vbak-auart,
        audat                 TYPE vbak-audat,
        vdatu                 TYPE vbak-vdatu,
        erdat                 TYPE vbak-erdat,
        kunnr                 TYPE kunnr_kh,
        name1_kunnr           TYPE zzname1_cliente,
        backoffice            TYPE zed_backoffice,
        backoffice_cliente    TYPE zed_backoffice,
        backoffice_nombre     TYPE zed_backoffice_nombre,
        comercial             type ZSSD_COMERCIAL, "APC20250227
        comercial_nombre      type ZZNAME1_COMER, "APC20250227
        kunwe                 TYPE kunwe,
        name1_kunwe           TYPE zzname1_dest,
        regio                 TYPE kna1-regio,
        pstlz                 TYPE kna1-pstlz,
        ORT01                 type kna1-ORT01, "APC20250227
        bstnk                 TYPE vbak-bstnk,
        bstdk_e               TYPE vbkd-bstdk_e,
        bstkd                 TYPE vbkd-bstkd,
        ihrez                 TYPE vbak-ihrez,
        vkorg                 TYPE vbak-vkorg,
        vtweg                 TYPE vbak-vtweg,
        spart                 TYPE vbak-spart,
        lifsk                 TYPE vbak-lifsk,
        faksk                 TYPE vbak-faksk,
        uvall                 TYPE vbuk-uvall,
        cmgst                 TYPE vbuk-cmgst,
        zzbrsch               TYPE knvv-zzbrsch,
        klabc                 TYPE knvv-klabc,
        posnr                 TYPE vbep-posnr,
        pstyv                 TYPE vbap-pstyv,
        bedae                 TYPE vbap-bedae,
        gbsta                 TYPE vbup-gbsta,
        matnr                 TYPE vbap-matnr,
        arktx                 TYPE vbap-arktx,
        mtart                 TYPE mara-mtart,
        matkl                 TYPE mara-matkl,
        maktx                 TYPE makt-maktx,
        kwmeng                TYPE vbap-kwmeng,
        abgru                 TYPE vbap-abgru,
        kdmat                 TYPE vbap-kdmat,
        werks                 TYPE vbap-werks,
        lgort                 TYPE vbap-lgort,
        uvallp                TYPE vbup-uvall,
        etenr                 TYPE vbep-etenr,
        ettyp                 TYPE vbep-ettyp,
        edatu                 TYPE vbep-edatu, " Fecha reparto a cliente
        wmeng                 TYPE vbep-wmeng, " Cantidad pedida por el cliente en UMV
        bmeng                 TYPE vbep-bmeng, " Cantidad confirmada
        vrkme                 TYPE vbep-vrkme,
        lifsp                 TYPE vbep-lifsp,
        meins                 TYPE vbap-meins,
        vstel                 TYPE vbap-vstel,
        route                 TYPE vbap-route,
        traztd                TYPE tvro-traztd,
        zzfechaconfirmacion   TYPE vbap-zzfconfs, " Fecha confirmacion cliente
        bloqueo               TYPE ztipo_bloqueo_rep,
        omeng                 TYPE vbbe-omeng, " Ctd.pendiente en UMA p.transf.necesidades a planif.nec.
        zm2_venta             TYPE zssd_m2_venta,
        zm2_venta_rep         TYPE zssd_m2_venta_rep,
        tipo_pedido           TYPE zed_tipo_pedido,
        cuobj                 TYPE vbap-cuobj,
        vgbel                 TYPE vbap-vgbel,
        vgpos                 TYPE vbap-vgpos,
        vgtyp_ref             TYPE vbak-vbtyp,
        ctd_prevista_contrato TYPE vbap-zmeng,
        beskz                 TYPE marc-beskz,
        sobsl                 TYPE marc-sobsl,
        fabkl                 TYPE t001w-fabkl,
        origen                TYPE char1, " Origen (C)ompras/(V)entas/(O)rdnes
        bsakz                 TYPE ekko-bsakz,
        semi                  TYPE zed_semi,
        semi_sobsl            TYPE marc-sobsl,
        semi_beskz            TYPE marc-beskz,
        etenr_unif            TYPE etenr, " A veces unificadmos repartos, si es así, este campo contendrá el reparto que hemos fusionado
        zvbep_tipo_pedido     TYPE zed_tipo_pedido,
        zvbep_estado          TYPE zed_estado_reparto,
        zvbep_semi            TYPE zed_semi,
        zvbep_etenr_unif      TYPE etenr,
        n_repartos            TYPE zvbap_hpg-n_repartos,
      END OF t_repartos_base .
  types:
    tt_repartos_base TYPE STANDARD TABLE OF t_repartos_base WITH KEY vbeln posnr etenr .
  types:
    BEGIN OF t_clave_ped,
        vbeln TYPE vbeln_va,
      END OF t_clave_ped .
  types:
    BEGIN OF t_clave_ped_pos,
        vbeln TYPE vbeln_va,
        posnr TYPE posnr,
      END OF t_clave_ped_pos .
  types:
    BEGIN OF t_interlocutores_ped,
        lifnr       TYPE lifnr,
        name1_lifnr TYPE name1,
        parvw_p1    TYPE kunnr,
        name1_p1    TYPE name1,
        parvw_p2    TYPE kunnr,
        name1_p2    TYPE name1,
        parvw_p3    TYPE kunnr,
        name1_p3    TYPE name1,
        parvw_ve    TYPE kunnr,
        name1_ve    TYPE name1,
        parvw_a1    TYPE lifnr,
        name1_a1    TYPE name1,
      END OF t_interlocutores_ped .
  types:
    BEGIN OF t_entregas,
        entrega                 TYPE vbeln_vl,
        entrega_pos             TYPE posnr,
        lfdat                   TYPE likp-lfdat,
        wbstk                   TYPE vbuk-wbstk,
        wadat_ist               TYPE likp-wadat_ist,
        zz_fecha_servicio_final TYPE dats,
        lfimg                   TYPE zctd_entrega_ps,      " Cantidad entrega pendiente de servir
        entrega_und             TYPE lips-vrkme,
        wbsta                   TYPE vbup-wbsta,
        lfimg_servido           TYPE zctd_entrega_servida, " Cantidad entrega servida
        resto                   TYPE lips-lfimg,
        num_entregas            TYPE int4,                 " Nº entregas asociadas a reparto
        num_entregas_dif        TYPE int4,                 " Nº entregas diferentes asociadas a repart
        estado_resto            TYPE char1,
      END OF t_entregas .
  types:
    BEGIN OF t_entregas_sel.
             INCLUDE TYPE t_clave_ped_pos.
             INCLUDE TYPE t_entregas.
           TYPES: END OF t_entregas_sel .
  types:
    tt_entregas_sel TYPE STANDARD TABLE OF t_entregas_sel WITH KEY vbeln posnr entrega entrega_pos .
  types:
    BEGIN OF t_ped_status,
        stat_fecha  TYPE zssd_de_fecha_fin_vs_fech_entr,
        stat_cant   TYPE zssd_de_pedido_vs_prod,
        estado      TYPE zed_estado_reparto,
        tipo_estado TYPE zed_tipo_estado_reparto,
      END OF t_ped_status .
  types:
    BEGIN OF t_medidas,
        hoehe         TYPE marm-hoehe,
        breit         TYPE marm-breit,
        laeng         TYPE marm-laeng,
        packp         TYPE yhp_idx_td151-packp,
        prqty         TYPE yhp_idx_td151-prqty,
        prqty_uom     TYPE yhp_idx_td151-prqty_uom,
        tbqty         TYPE yhp_idx_td151-tbqty,
        tbqty_uom     TYPE yhp_idx_td151-tbqty_uom,
        length        TYPE yhp_idx_td151-length,
        length_uom    TYPE yhp_idx_td151-length_uom,
        width         TYPE yhp_idx_td151-width,
        width_uom     TYPE yhp_idx_td151-width_uom,
        height        TYPE yhp_idx_td151-height,
        height_uom    TYPE yhp_idx_td151-height_uom,
        weigth        TYPE yhp_idx_td151-weigth,
        weigth_uom    TYPE yhp_idx_td151-weigth_uom,
        palets        TYPE zui5_cm_num_pallets,
        cajas_paquete TYPE zzsqm_cajas_paq,
      END OF t_medidas .
  types:
    BEGIN OF t_rep_stocks,
        labst            TYPE mard-labst,
        cant_stock_cli   TYPE mard-labst,
        cant_stock_tcli  TYPE mard-labst,
        ctd_ord_abiertas TYPE mard-labst,
        cant_stock       TYPE mard-labst,
        semi_stock_mm    TYPE p LENGTH 15 DECIMALS 3,
        semi_ctd_ord     TYPE p LENGTH 15 DECIMALS 3,
      END OF t_rep_stocks .
  types:
    BEGIN OF t_rep_ped_compra,
        ebeln      TYPE ebeln,
        ebelp      TYPE ebelp,
        zzcrear_of TYPE ekpo-zzcrear_of,
        zzaufnr    TYPE ekpo-zzaufnr,
      END OF t_rep_ped_compra .
  types:
    BEGIN OF t_repartos.
             INCLUDE TYPE t_repartos_base.
             INCLUDE TYPE t_datos_ordenes.
             INCLUDE TYPE t_interlocutores_ped.
             INCLUDE TYPE t_entregas.
             INCLUDE TYPE t_ped_status.
             INCLUDE TYPE t_medidas.
             INCLUDE TYPE t_rep_stocks.
             INCLUDE TYPE t_rep_ped_compra.
           TYPES: END OF t_repartos .
  types:
    tt_repartos TYPE STANDARD TABLE OF t_repartos WITH KEY vbeln posnr etenr
                                                                                    WITH NON-UNIQUE SORTED KEY posnr_key COMPONENTS vbeln posnr .
  types:
    BEGIN OF t_ordenes_reparto,
        aufnr TYPE aufnr,
      END OF t_ordenes_reparto .
  types:
    tt_ordenes_reparto TYPE TABLE OF t_ordenes_reparto WITH KEY aufnr .
  types:
    BEGIN OF  t_rango_kdmat,
        sign   TYPE char1,
        option TYPE char2,
        low    TYPE vbap-kdmat,
        high   TYPE vbap-kdmat,
      END OF t_rango_kdmat .
  types:
    tt_rango_kdmat TYPE STANDARD TABLE OF t_rango_kdmat .

  data O_PP type ref to ZHCL_PP_CORE .
  data R_BLOQUEO_FINAL type LMBP_RANGE_C2_T .
  data R_BLOQUEO_TEMPORAL type LMBP_RANGE_C2_T .
  data O_PAR_Z360 type ref to ZCL_AP_PARAMETROS .

  methods CONSTRUCTOR .
  methods GET_VKORG_AUT_USUARIO
    importing
      !UNAME type SY-UNAME default SY-UNAME
    exporting
      !MESSAGE type BAPI_MSG
    returning
      value(R_VKORG) type SD_VKORG_RANGES .
  methods GET_CATALOGO
    importing
      !FECHA type SY-DATUM default SY-DATUM
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !SOLO_MAT_SIN_BLOQUEOS type ABAP_BOOL default 'X'
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
    returning
      value(I_CATALOGO) type ZTT_SD_CATALOGO .
  methods GET_DATOS_ORDENES_PEDIDOS
    importing
      !I_REPARTOS type TT_REPARTOS_BASE optional
      !ORDENES type ABAP_BOOL default ''
      !I_ORDENES_REPARTO type TT_ORDENES_REPARTO optional
    returning
      value(I_ORDENES) type TT_DATOS_ORDENES .
  methods GET_REPARTOS
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !HISTORICO type ABAP_BOOL default ''
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !DATOS_ORDENES type ABAP_BOOL default 'X'
      !DATOS_ENTREGAS type ABAP_BOOL default 'X'
      !DATOS_MEDIDAS type ABAP_BOOL default 'X'
      !DATOS_INTERLOCUTORES type ABAP_BOOL default 'X'
      !ADD_ORDENES type ABAP_BOOL default 'X'
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !DATOS_STOCKS type ABAP_BOOL default 'X'
      !STOCK_SEMIS type ABAP_BOOL default ''
      !R_POSNR type ZRG_POSNR optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !DATOS_PED_COMPRA type ABAP_BOOL default 'X'
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_AUFNR type RANGE_T_AUFNR optional
      !ADD_PEDIDOS_TRASLADO type ABAP_BOOL default ''
      !ADD_PEDIDOS_VENTAS type ABAP_BOOL default 'X'
      !R_LGORT type ZTTPP_RANGE_LGORT optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !ADD_CONTRATOS_SIN_PEDIDO type ABAP_BOOL default ''
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !USAR_PRECALCULOS type ABAP_BOOL default ''
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !ORIGEN type SY-TCODE default ''
      !R_KDMAT type TT_RANGO_KDMAT optional
      !R_COMERCIAL type TRTY_KUNNR_RANGE optional
    exporting
      !I_NEC_ORDENES type TT_NECESIDAD_ORDENES
    returning
      value(I_REPARTOS) type TT_REPARTOS .
  methods GET_INTERLOCUTORES
    changing
      !I_REPARTOS type TT_REPARTOS .
  methods GET_DATOS_ENTREGAS_PEDIDOS
    importing
      !I_REPARTOS type TT_REPARTOS_BASE
      !R_WADAT type DATE_T_RANGE optional
    returning
      value(I_ENTREGAS) type TT_ENTREGAS_SEL .
  methods ASIGNACION_REPARTO_ENTREGA
    importing
      !I_REPARTOS type TT_REPARTOS optional
      !I_ENTREGAS type TT_ENTREGAS_SEL optional
      !VBELN type VBELN_VA optional
      !POSNR type POSNR optional
      !POPUP type ABAP_BOOL default ''
    returning
      value(I_REPARTO_ENTREGA) type TT_REPARTO_ENTREGA .
  methods ASIGNACION_REPARTOS_ENTREGAS
    changing
      !I_REPARTOS type TT_REPARTOS
      !I_ENTREGAS type TT_ENTREGAS_SEL .
  methods CALC_REPARTOS_BASE
    changing
      !I_REPARTOS type TT_REPARTOS_BASE .
  methods DIAS_RUTA
    importing
      !TRAZTD type TVRO-TRAZTD optional
      !ROUTE type TVRO-ROUTE optional
    returning
      value(DIAS) type INT4 .
  methods GET_MEDIDAS
    exporting
      !I_UNIDADES type ZHCL_MM_CORE=>TT_UNIDADES
    changing
      !I_REPARTOS type TT_REPARTOS .
  methods GET_TIPO_PEDIDO
    importing
      !VBELN type VBELN_VA optional
      !REP type T_REPARTOS optional
      !POSNR type POSNR optional
      !ETENR type ETENR optional
      !NO_SEMI type ABAP_BOOL default ''
    preferred parameter VBELN
    changing
      !I_NEC_ORDENES type TT_NECESIDAD_ORDENES optional
    returning
      value(TIPO_PEDIDO) type ZED_TIPO_PEDIDO .
  methods GET_BACKOFFICE_USUARIO
    importing
      !UNAME type SY-UNAME default SY-UNAME
    returning
      value(R_BACKOFFICE) type MD_RANGE_T_LIFNR .
  methods GET_PEDIDOS_FICTICIOS_ORDEN
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_AUFNR type RANGE_T_AUFNR optional
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !R_KDMAT type TT_RANGO_KDMAT optional
    returning
      value(I_REPARTOS) type TT_REPARTOS_BASE .
  methods GET_ESTADO_REPARTO
    importing
      !VBELN type VBELN_VA optional
      !POSNR type POSNR optional
      !ETENR type ETENR optional
      !I_NEC_ORDEN type TT_NECESIDAD_ORDENES optional
    exporting
      !ESTADO type ZED_ESTADO_REPARTO
    changing
      !REPARTO type T_REPARTOS optional .
  methods GET_DATOS_STOCK
    importing
      !SEMIS type ABAP_BOOL default ''
    changing
      !I_REPARTOS type TT_REPARTOS .
  methods GET_DATOS_PED_COMPRA
    changing
      !I_REPARTOS type TT_REPARTOS .
  methods GET_NECESIDAD_ORDENES
    importing
      !I_REPARTOS type TT_REPARTOS
    returning
      value(I_NEC_ORDENES) type TT_NECESIDAD_ORDENES .
  methods GET_WERKS_AUT_USUARIO
    importing
      !UNAME type SY-UNAME default SY-UNAME
    exporting
      !MESSAGE type BAPI_MSG
    returning
      value(R_WERKS) type WERKS_T_RANGE .
  methods GET_PEDIDOS_DESDE_ORDENES
    importing
      !R_AUFNR type RANGE_T_AUFNR
      !R_VBELN_SEL type SD_VBELN_RANGES optional
    returning
      value(R_VBELN) type SD_VBELN_RANGES .
  methods GET_REPARTO
    importing
      !VBELN type VBELN_VA
      !POSNR type POSNR
      !ETENR type ETENR optional
      !DATOS_ORDENES type ABAP_BOOL default ''
      !DATOS_ENTREGAS type ABAP_BOOL default ''
      !DATOS_MEDIDAS type ABAP_BOOL default ''
      !DATOS_INTERLOCUTORES type ABAP_BOOL default ''
      !DATOS_PED_COMPRA type ABAP_BOOL default ''
    returning
      value(REPARTO) type T_REPARTOS .
  methods GET_FECHA_ASIGNACION
    importing
      !VBELN type VBELN_VA
      !POSNR type POSNR
      !ETENR type ETENR optional
    returning
      value(FECHA_ASIGNACION) type ZZ_FECHA_ASIGNACION .
  methods GET_PEDIDOS_TRASLADO
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_AUFNR type RANGE_T_AUFNR optional
      !R_LGORT type ZTTPP_RANGE_LGORT optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !R_KDMAT type TT_RANGO_KDMAT optional
      !R_COMERCIAL type TRTY_KUNNR_RANGE optional
    returning
      value(I_REPARTOS) type TT_REPARTOS .
  methods GET_M2
    importing
      !SPEC type YHP_IDX_TT_SPEC_DB optional
      !LINK type YHP_IDX_TT_LINK_DB optional
      !CUOBJ type CUOBJ
      !TEST type ABAP_BOOL default ''
      !VBAP type VBAP optional
    returning
      value(M2) type ZVCXI_PXS_SBLAR .
  methods GET_DATOS_INCOMPLETOS
    importing
      !VBELN type VBELN
      !POSNR type POSNR optional
    returning
      value(DATOS) type STRING .
  methods GET_PEDIDOS_DESDE_ENTREGAS
    importing
      !R_VBELN_SEL type SD_VBELN_RANGES optional
      !R_WADAT type DATE_T_RANGE
      !TIPO type CHAR1
    returning
      value(R_VBELN) type SD_VBELN_RANGES .
  PROTECTED SECTION.

private section.

  methods GET_REPARTOS_VIVOS
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !R_POSNR type ZRG_POSNR optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_LGORT type ZTTPP_RANGE_LGORT optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !R_KDMAT type TT_RANGO_KDMAT optional
      !R_COMERCIAL type TRTY_KUNNR_RANGE optional
    returning
      value(I_REPARTOS) type TT_REPARTOS_BASE .
  methods GET_REPARTOS_TODOS
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !R_POSNR type ZRG_POSNR optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_LGORT type ZTTPP_RANGE_LGORT optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !R_KDMAT type TT_RANGO_KDMAT optional
      !R_COMERCIAL type TRTY_KUNNR_RANGE optional
    returning
      value(I_REPARTOS) type TT_REPARTOS_BASE .
  methods GET_CONTRATOS
    importing
      !R_KUNNR type TRTY_KUNNR_RANGE optional
      !R_VKORG type SD_VKORG_RANGES optional
      !R_MATNR type RANGES_MATNR optional
      !R_MTART type GDS_SELRANGE_MTART_TAB optional
      !UNAME type SY-UNAME default SY-UNAME
      !R_EDATU type DATE_T_RANGE optional
      !R_BRSCH type ZRG_BRSCH optional
      !R_VBELN type SD_VBELN_RANGES optional
      !R_WERKS type WERKS_T_RANGE optional
      !R_BACKOFFICE type TRTY_KUNNR_RANGE optional
      !R_PSTLZ type ZRG_PSTLZ optional
      !R_AUDAT type DATE_T_RANGE optional
      !R_REGIO type ZRG_REGIO optional
      !R_CONTRATO type SD_VBELN_RANGES optional
      !R_BSTNK type /SPE/RET_RANGE_C20_T optional
      !R_KUNWE type TRTY_KUNNR_RANGE optional
      !R_POSNR type ZRG_POSNR optional
      !R_AUART type TMS_T_AUART_RANGE optional
      !R_BEDAE type GDS_SELRANGE_MTART_TAB optional
      !R_ERDAT type DATE_T_RANGE optional
      !R_MATKL type GDS_SELRANGE_MATKL_TAB optional
      !R_KLABC type ZSD_TT_RANGE_KLABC optional
      !R_LGORT type ZTTPP_RANGE_LGORT optional
      !R_TIPO_PEDIDO type LMBP_RANGE_C2_T optional
      !R_RFGSA type LXHME_RANGE_C1_T optional
      !R_ESTADO type TMS_T_AUART_RANGE optional
      !R_TIPO_ESTADO type LMBP_RANGE_C2_T optional
      !R_WADAT type DATE_T_RANGE optional
      !R_SEMI type RANGES_MATNR optional
      !R_KDMAT type TT_RANGO_KDMAT optional
    exporting
      !I_NEC_ORDENES type TT_NECESIDAD_ORDENES
    returning
      value(I_REPARTOS) type TT_REPARTOS_BASE .
  methods GET_REPARTOS_NO_SEL
    importing
      !R_EDATU type DATE_T_RANGE
    changing
      !I_REPARTOS type TT_REPARTOS_BASE .
endclass. "ZHCL_SD_CORE definition
class ZHCL_SD_CORE implementation.
  METHOD asignacion_reparto_entrega.
    TYPES: BEGIN OF t_alv.
             INCLUDE TYPE t_reparto_entrega.
             TYPES:   tknum   TYPE tknum,
             tdlnr   TYPE tdlnr,
             tdlnr_t TYPE tdlnr_txt,
           END OF t_alv.

    DATA i_repb    TYPE tt_repartos_base.
    DATA l_rep_ent TYPE t_reparto_entrega.
    DATA l_etenr   TYPE vbep-etenr.
    DATA i_alv     TYPE TABLE OF t_alv.

    CLEAR i_reparto_entrega.

    IF NOT i_repartos IS INITIAL.
      DATA(i_repl) = i_repartos.
    ELSE.
      SELECT * FROM vbep
        INTO CORRESPONDING FIELDS OF TABLE i_repl
       WHERE vbeln = vbeln
         AND posnr = posnr.
      IF sy-subrc <> 0.
* Busqueda de entregas asociadas a pedidos de traslado
        SELECT eket~ebeln AS vbeln eket~ebelp AS posnr etenr eindt AS edatu
               eket~menge AS kwmeng ekpo~meins AS vrkme eket~glmng AS bmeng
          FROM eket JOIN ekpo ON  ekpo~ebeln = eket~ebeln
                              AND ekpo~ebelp = eket~ebelp
          INTO CORRESPONDING FIELDS OF TABLE i_repl
         WHERE eket~ebeln = vbeln
           AND eket~ebelp = posnr+1.
      ENDIF.
    ENDIF.

    IF NOT i_entregas IS INITIAL.
      DATA(i_entl) = i_entregas.
    ELSE.
      MOVE-CORRESPONDING i_repl TO i_repb.
      i_entl = get_datos_entregas_pedidos( i_repartos = i_repb ).
    ENDIF.

    LOOP AT i_entl ASSIGNING FIELD-SYMBOL(<ent>).
      IF <ent>-wadat_ist IS INITIAL.
        <ent>-wadat_ist = <ent>-lfdat.
      ENDIF.
    ENDLOOP.

    SORT i_entl BY vbeln posnr wadat_ist entrega.
    SORT i_repl BY vbeln posnr etenr.

    LOOP AT i_entl ASSIGNING <ent>.
      <ent>-lfimg         = <ent>-lfimg + <ent>-lfimg_servido.
      <ent>-lfimg_servido = <ent>-lfimg.
      DATA(l_ctd_pend) = <ent>-lfimg.
      CLEAR l_rep_ent.
      MOVE-CORRESPONDING <ent> TO l_rep_ent.

      LOOP AT i_repl ASSIGNING FIELD-SYMBOL(<rep>) WHERE bmeng > 0.
        l_rep_ent-etenr = <rep>-etenr.
        l_rep_ent-ettyp = <rep>-ettyp.
        l_rep_ent-edatu = <rep>-edatu.
        l_rep_ent-wmeng = <rep>-wmeng.
        l_rep_ent-bmeng = <rep>-bmeng.
        IF <rep>-bmeng >= l_ctd_pend.
          l_rep_ent-ctd_asignada = l_ctd_pend.
          <rep>-bmeng = <rep>-bmeng - l_ctd_pend.
          CLEAR l_ctd_pend.
        ELSE.
          l_rep_ent-ctd_asignada = <rep>-bmeng.
          l_ctd_pend = l_ctd_pend - <rep>-bmeng.
          CLEAR <rep>-bmeng.
          DELETE i_repl.
        ENDIF.
        APPEND l_rep_ent TO i_reparto_entrega.
        IF l_ctd_pend <= 0.
          EXIT.
        ENDIF.
      ENDLOOP.

* Queda un resto de la entrega por asignar, lo hacemos la ultimo reparto.
      IF l_ctd_pend > 0.
        DATA(l_ultimo) = lines( i_reparto_entrega ).
        IF l_ultimo > 0.
          ASSIGN i_reparto_entrega[ l_ultimo ] TO FIELD-SYMBOL(<repent>).
          IF sy-subrc = 0.
            <repent>-ctd_asignada = <repent>-ctd_asignada + l_ctd_pend.
            CLEAR l_ctd_pend.
          ENDIF.
        ENDIF.
        IF l_ctd_pend > 0.
          l_rep_ent-ctd_asignada = l_ctd_pend.
          CLEAR l_rep_ent-lfimg.
          APPEND l_rep_ent TO i_reparto_entrega.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF popup = 'X'.
      SORT i_reparto_entrega BY etenr edatu wadat_ist.
      LOOP AT i_reparto_entrega ASSIGNING <repent>.
        SELECT SINGLE kwmeng vrkme FROM vbap
          INTO CORRESPONDING FIELDS OF <repent>
         WHERE vbeln = <repent>-vbeln
           AND posnr = <repent>-posnr.
        IF sy-subrc <> 0.
          SELECT SINGLE menge AS kwmeng meins AS vrkme FROM ekpo
            INTO CORRESPONDING FIELDS OF <repent>
           WHERE ebeln = <repent>-vbeln
             AND ebelp = <repent>-posnr+1.
        ENDIF.
        EXIT.
      ENDLOOP.

      LOOP AT i_reparto_entrega ASSIGNING <repent>.
        IF l_etenr = <repent>-etenr.
          CLEAR: <repent>-bmeng, <repent>-wmeng.
        ENDIF.
        l_etenr = <repent>-etenr.

        IF <repent>-wbstk = 'C'.
          <repent>-icon_sm = zcl_ap_alv=>set_icono( icono = icon_import_all_requests mensaje = |SM efectuada el { <repent>-wadat_ist DATE = USER }| ).
        ENDIF.

      ENDLOOP.

      MOVE-CORRESPONDING i_reparto_entrega TO i_alv.
      LOOP AT i_alv ASSIGNING FIELD-SYMBOL(<alv>).
        SELECT vttp~tknum, vttk~tdlnr, lfa1~name1 AS tdlnr_t
          FROM vttp
          JOIN vttk ON vttk~tknum = vttp~tknum LEFT OUTER
          JOIN lfa1 ON lfa1~lifnr = vttk~tdlnr
          WHERE vttp~vbeln = @<alv>-entrega
          ORDER BY vttk~tknum
          INTO CORRESPONDING FIELDS OF @<alv>
          UP TO 1 ROWS.
        ENDSELECT.
      ENDLOOP.

      CALL FUNCTION 'Z_POPUP_ALV_AP'
        EXPORTING
          titulo         = |Entregas asociadas a posición { vbeln ALPHA = OUT } { posnr ALPHA = OUT }|
          campos_noout   = 'VBELN,POSNR,ETTYP,LFDAT,VRKME,WBSTK,WMENG,ENTREGA_POS'
          campos_sum     = 'CTD_ASIGNADA,KWMENG,BMENG,LFIMG'
          campos_texto   = 'WADAT_IST=F.Entrega&&EDATU=F.Reparto&&ICON_SM=SM'
          campos_orden   = 'ETENR,EDATU,WADAT_IST'
          campos_hotspot = 'ENTREGA,TKNUM'
          botones        = 'OK'
        TABLES
          t_datos        = i_alv.
    ENDIF.
  ENDMETHOD.
  METHOD asignacion_repartos_entregas.
    DATA: l_bmeng    TYPE vbep-bmeng,
          l_ped      TYPE t_clave_ped_pos,
          i_ped      TYPE TABLE OF t_clave_ped_pos,
          i_repl     TYPE tt_repartos,
          i_rep      TYPE tt_repartos,
          i_ent      TYPE tt_entregas_sel,
          i_ent_asig TYPE TABLE OF t_clave_ped_pos.

* Si detectamos que un reparto no tiene cantidad confirmada, pero el resto de repartos de la posición llenan la petición,
* los marcamos
    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<reparto>) WHERE     (    omeng > 0
                                                                     OR wmeng > 0 )
                                                               AND bmeng = 0
                                                               AND lifsp IS INITIAL.
      CLEAR l_bmeng.
      LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep2>) USING KEY posnr_key WHERE vbeln = <reparto>-vbeln AND posnr = <reparto>-posnr.
        l_bmeng = l_bmeng + <rep2>-bmeng.
      ENDLOOP.
      IF l_bmeng >= <reparto>-kwmeng. " La cantidad confirmada del resto de peticiones es >= a la cantidad pedida, por tanto ignoraremos este reparto
        <reparto>-estado_resto = 'D'. " No lo queremos sacar
        <reparto>-resto        = 0.
      ENDIF.
    ENDLOOP.

* Si no hay entregas, el resto está pendiente
    LOOP AT i_repartos ASSIGNING <reparto> WHERE estado_resto <> 'D' AND lifsp IS INITIAL.
      IF <reparto>-bmeng > 0. " El reparto tiene cantidad confirmada
        LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<reparto_anulado>) USING KEY posnr_key WHERE vbeln = <reparto>-vbeln AND posnr = <reparto>-posnr AND estado_resto = 'D'.
          <reparto>-estado_resto = 'C'.
          <reparto>-etenr_unif   = <reparto_anulado>-etenr. " Nos guardamos el reparto que fusionamos por si marcamos como rechazo, que marque las dos posiciones*
          <reparto_anulado>-etenr_unif = <reparto>-etenr.
*          Acumulamos las cantidades de los dos repartos
          <reparto>-omeng = <reparto>-omeng + <reparto_anulado>-omeng. " Ctd.pendiente en UMA p.transf.necesidades a planif.nec.
          <reparto>-bmeng = <reparto>-bmeng + <reparto_anulado>-bmeng. " Cantidad confirmada
          <reparto>-wmeng = <reparto>-wmeng + <reparto_anulado>-wmeng. " Cantidad pedida por el cliente en UMV
*          IF <reparto>-omeng IS INITIAL.
*            IF <reparto>-bmeng > <reparto_anulado>-omeng.
*              <reparto>-omeng = <rep2>-omeng.
*            ELSE.
*              <reparto>-omeng = <reparto>-bmeng.
*              if <reparto>-wmeng is initial.
*                <reparto>-wmeng = <reparto>-bmeng.
*              endif.
*            ENDIF.
*          ENDIF.
          EXIT.
        ENDLOOP.
        IF sy-subrc <> 0.
* Es posible que no se hayan seleccionado todos los repartos de los que agrupamos si es así añadimos las posiciones que falatn
          IF <reparto>-omeng = 0 AND <reparto>-wmeng = 0.
            SELECT etenr, bmeng, wmeng FROM vbep
              INTO TABLE @DATA(i_vbep)
             WHERE vbeln  = @<reparto>-vbeln
               AND posnr  = @<reparto>-posnr
               AND etenr <> @<reparto>-etenr
               AND bmeng  = 0
               AND wmeng  > 0.
            LOOP AT i_vbep ASSIGNING FIELD-SYMBOL(<vbep>).
              IF NOT line_exists( i_repartos[ vbeln = <reparto>-vbeln posnr = <reparto>-posnr etenr = <vbep>-etenr ]  ). "#EC *
                <reparto>-estado_resto = 'C'.
                <reparto>-etenr_unif   = <vbep>-etenr. " Nos guardamos el reparto que fusionamos por si marcamos como rechazo, que marque las dos posiciones*
                <reparto>-bmeng        = <reparto>-bmeng + <vbep>-bmeng. " Cantidad confirmada
                <reparto>-wmeng        = <reparto>-wmeng + <vbep>-wmeng. " Cantidad pedida por el cliente en UMV
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDIF.

      IF NOT <reparto>-omeng IS INITIAL.
        <reparto>-resto = <reparto>-omeng.
      ELSE.
        <reparto>-resto = <reparto>-wmeng.
      ENDIF.
    ENDLOOP.

* Agrupamos por posición
    LOOP AT i_entregas ASSIGNING FIELD-SYMBOL(<entrega>).
      l_ped-vbeln = <entrega>-vbeln.
      l_ped-posnr = <entrega>-posnr.
      COLLECT l_ped INTO i_ped.
    ENDLOOP.

    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

* Hacemos esto para aegurarnos de que tenemos todas
    SELECT * FROM vbep
      INTO CORRESPONDING FIELDS OF TABLE i_repl
      FOR ALL ENTRIES IN i_ped
     WHERE vbeln = i_ped-vbeln
       AND posnr = i_ped-posnr.

* Buscamos repartos a nivel de posición
    LOOP AT i_ped ASSIGNING FIELD-SYMBOL(<ped>).
      CLEAR: i_rep, i_ent.
      LOOP AT i_repl ASSIGNING FIELD-SYMBOL(<rep>) USING KEY posnr_key WHERE vbeln = <ped>-vbeln AND posnr = <ped>-posnr.
        APPEND <rep> TO i_rep.
      ENDLOOP.
      LOOP AT i_entregas ASSIGNING <entrega> WHERE vbeln = <ped>-vbeln AND posnr = <ped>-posnr.
        APPEND <entrega> TO i_ent.
      ENDLOOP.

      DATA(i_rep_ent) = asignacion_reparto_entrega( vbeln = <ped>-vbeln posnr = <ped>-posnr i_repartos = i_rep i_entregas = i_ent ).
      CLEAR i_ent_asig.
      LOOP AT i_repartos ASSIGNING <reparto> USING KEY posnr_key WHERE vbeln = <ped>-vbeln AND posnr = <ped>-posnr.
        LOOP AT i_rep_ent ASSIGNING FIELD-SYMBOL(<rep_ent>) WHERE vbeln = <ped>-vbeln AND posnr = <ped>-posnr AND etenr = <reparto>-etenr.
          <reparto>-num_entregas = <reparto>-num_entregas + 1.
          IF NOT line_exists( i_ent_asig[ vbeln = <rep_ent>-entrega ] ).
            <reparto>-num_entregas_dif = <reparto>-num_entregas_dif + 1.
            APPEND VALUE #( vbeln = <rep_ent>-entrega ) TO i_ent_asig.
          ENDIF.

* Mostramos a nivel de reparto sólo la última asignada.
          <reparto>-entrega     = <rep_ent>-entrega.
          <reparto>-entrega_pos = <rep_ent>-entrega_pos.

          ASSIGN i_entregas[ entrega     = <rep_ent>-entrega
                             entrega_pos = <rep_ent>-entrega_pos ] TO <entrega>.
          <reparto>-lfdat                   = <entrega>-lfdat.
          <reparto>-wbstk                   = <entrega>-wbstk.
          <reparto>-wadat_ist               = <entrega>-wadat_ist.
          <reparto>-zz_fecha_servicio_final = <entrega>-zz_fecha_servicio_final.

          IF <rep_ent>-wbstk = 'C'.
            <reparto>-lfimg_servido = <reparto>-lfimg_servido + <rep_ent>-ctd_asignada. " Cantidad entregas con SM
          ELSE.
            <reparto>-lfimg = <reparto>-lfimg + <rep_ent>-ctd_asignada. " Cantidad entregas sin SM
          ENDIF.
        ENDLOOP.

        IF <reparto>-gbsta = 'C'.
          CLEAR <reparto>-resto.
        ELSE.
*          IF <reparto>-wmeng > 0.
* Cantidad pendiente de servir a cliente = cantidad pedida - cantidad en entregas pendiente de SM - cantidad entregas con SM
          <reparto>-resto = <reparto>-wmeng - <reparto>-lfimg - <reparto>-lfimg_servido.
*          ELSE.
*            <reparto>-resto = <reparto>-bmeng - <reparto>-lfimg - <reparto>-lfimg_servido.
*          ENDIF.
        ENDIF.
        IF <reparto>-wadat_ist > <reparto>-bstdk_e.
          <reparto>-stat_fecha = 'R'.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD calc_repartos_base.
    DATA l_repc TYPE t_repartos.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>).
      <rep>-origen = 'V'.
      IF NOT <rep>-lifsk IS INITIAL.
        <rep>-bloqueo = |CAB={ <rep>-lifsk }|.
      ELSEIF NOT <rep>-abgru IS INITIAL.
        <rep>-bloqueo = |POS={ <rep>-abgru }|.
      ELSEIF NOT <rep>-lifsp IS INITIAL.
        <rep>-bloqueo = |REP={ <rep>-lifsp }|.
      ELSEIF <rep>-cmgst = 'B' OR <rep>-cmgst = 'C'.
        <rep>-bloqueo = |CRE={ <rep>-cmgst }|.
      ELSEIF NOT <rep>-faksk IS INITIAL.
        <rep>-bloqueo = |FAC={ <rep>-faksk }|.
      ENDIF.

      IF NOT <rep>-kwmeng IS INITIAL.
        <rep>-zm2_venta_rep = <rep>-zm2_venta * <rep>-wmeng / <rep>-kwmeng.
      ENDIF.

* Si es subcontracion, igualamos la cantidad a "confirmada" a la cantidad de entrega
      IF <rep>-omeng = 0 AND <rep>-ettyp = 'Z1'.
        <rep>-omeng = <rep>-wmeng.
      ENDIF.

      MOVE-CORRESPONDING <rep> TO l_repc.
      <rep>-tipo_pedido = get_tipo_pedido( rep = l_repc no_semi = 'X' ).

      IF <rep>-backoffice IS INITIAL AND NOT <rep>-backoffice_cliente IS INITIAL.
        <rep>-backoffice = <rep>-backoffice_cliente.
        IF NOT <rep>-backoffice IS INITIAL.
          SELECT SINGLE name1 FROM lfa1
            INTO <rep>-backoffice_nombre
           WHERE lifnr = <rep>-backoffice.
        ENDIF.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.
  METHOD constructor.
    super->constructor( ).

    clave_parametros = 'CORE_SD'.
  ENDMETHOD.
  METHOD dias_ruta.
    DATA: lv_dist TYPE c LENGTH 10,
          lv_i    TYPE p LENGTH 8 DECIMALS 0.

    CLEAR dias.
    IF traztd IS INITIAL AND NOT route IS INITIAL.
      SELECT SINGLE traztd FROM tvro
        INTO @DATA(l_traztd)
       WHERE route = @route.
    ELSEIF traztd IS INITIAL.
      RETURN.
    ELSE.
      l_traztd = traztd.
    ENDIF.

    CALL FUNCTION 'CONVERSION_EXIT_TSTRG_OUTPUT'
      EXPORTING
        input  = l_traztd
      IMPORTING
        output = lv_dist.

    CALL FUNCTION 'MOVE_CHAR_TO_NUM'
      EXPORTING
        chr             = lv_dist
      IMPORTING
        num             = lv_i
      EXCEPTIONS
        convt_no_number = 1
        convt_overflow  = 2
        OTHERS          = 3.

    IF sy-subrc = 0.
      dias = lv_i.
    ENDIF.
  ENDMETHOD.
  METHOD get_backoffice_usuario.
    DATA l_backoffice TYPE lifnr.

    DATA(r_vkorg) = get_vkorg_aut_usuario( uname = uname ).

    SELECT atributo1 FROM zparametros
      INTO TABLE @DATA(l_back)
     WHERE clave  = 'CORE_BODEF'
       AND campo  = @uname
       AND valor IN @r_vkorg
     ORDER BY PRIMARY KEY.
    IF sy-subrc <> 0.
      SELECT atributo1 FROM zparametros
      INTO TABLE @l_back
       WHERE clave = 'CORE_BODEF'
         AND campo = @uname
         AND valor = ''
       ORDER BY PRIMARY KEY.
    ENDIF.
    IF NOT l_back IS INITIAL.
      LOOP AT l_back ASSIGNING FIELD-SYMBOL(<back>).
        l_backoffice = <back>.
        __poner_ceros l_backoffice.
        SELECT SINGLE lifnr FROM lfa1
          INTO l_backoffice
         WHERE lifnr = l_backoffice.
        IF sy-subrc = 0.
          APPEND VALUE #( option = 'EQ' sign = 'I' low = l_backoffice ) TO r_backoffice.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD get_catalogo.
    DATA r_mstae TYPE RANGE OF mara-mstae.

    CLEAR i_catalogo.

* Siempre tienen que haber un filtro por usuario para verificar permisos por organización de ventas
    IF uname IS INITIAL.
      RETURN.
    ENDIF.

    DATA(r_vkorg_usuario) = get_vkorg_aut_usuario( uname = uname ).

    IF solo_mat_sin_bloqueos = 'X'.
      r_mstae = VALUE #( option = 'EQ'
                         sign = 'I'
                         ( low = '' )
                         ( low = '00' ) ).
    ENDIF.

    SELECT kotg933~kunnr, kotg933~vkorg, kotg933~vtweg, kotg933~spart, kotg933~matnr,
           kna1~name1 AS kunnr_nombre,
           knvp~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           makt~maktx
      FROM kotg933
      INNER JOIN kna1 ON kna1~kunnr = kotg933~kunnr
      INNER JOIN mara ON mara~matnr = kotg933~matnr
      LEFT OUTER JOIN makt ON  makt~matnr = kotg933~matnr
                           AND makt~spras = @sy-langu
      LEFT OUTER JOIN knvp ON  knvp~kunnr = kotg933~kunnr
                           AND knvp~vkorg = kotg933~vkorg
                           AND knvp~vtweg = kotg933~vtweg
                           AND knvp~spart = kotg933~spart
                           AND knvp~parvw = 'A1'
      LEFT OUTER JOIN lfa1 ON lfa1~lifnr = knvp~lifnr "#EC CI_BUFFJOIN.
      INTO CORRESPONDING FIELDS OF TABLE @i_catalogo
      WHERE kotg933~kappl  = 'V'
        AND kotg933~kschl  = 'ZA01'
        AND kotg933~vkorg IN @r_vkorg
        AND kotg933~vkorg IN @r_vkorg_usuario
        AND kotg933~kunnr IN @r_kunnr
        AND kotg933~matnr IN @r_matnr
        AND kotg933~datbi >= @fecha
        AND kotg933~datab <= @fecha
        AND knvp~lifnr    IN @r_backoffice
        AND mara~mtart    IN @r_mtart
        AND mara~mstae    IN @r_mstae
        AND mara~lvorm     = '' " No borrados
     ORDER BY kotg933~kunnr, kotg933~vkorg, kotg933~vtweg, kotg933~spart, kotg933~matnr.
  ENDMETHOD.
  METHOD get_contratos.
    " TODO: parameter I_NEC_ORDENES is never cleared or assigned (ABAP cleaner)

    CLEAR i_repartos.

    IF NOT r_wadat IS INITIAL.
      RETURN.
    ENDIF.

* Siempre tienen que haber un filtro por usuario para verificar permisos por organización de ventas
    IF uname IS INITIAL.
      RETURN.
    ENDIF.

    DATA(r_vkorg_usuario) = get_vkorg_aut_usuario( uname = uname ).

    zcl_ap_fechas=>rango2fechas( EXPORTING r_fechas = r_edatu
                                 IMPORTING fecha_desde = DATA(l_fdesde)
                                           fecha_hasta = DATA(l_fhasta) ).

    SELECT vbak~vbeln, vbap~posnr, vbap~vrkme, vbap~zmeng AS wmeng,
           vbak~auart, vbak~kunnr, vbak~vkorg, vbak~vtweg, vbak~spart, vbak~bstnk, vbak~audat, vbak~vdatu, vbak~lifsk, vbak~faksk, vbak~erdat, vbak~vbtyp,
           vbuk~uvall, vbuk~cmgst,
           vbap~matnr, vbap~arktx, vbap~kdmat, vbap~kwmeng, vbap~route, vbap~meins, vbap~werks, vbap~lgort, vbap~abgru,
           vbap~zzfconfs AS zzfechaconfirmacion, vbap~cuobj, vbap~kzwi4 AS zm2_venta, vbap~bedae, vbap~pstyv, vbap~vstel,
           vbap~vgbel, vbap~vgpos,
           vbup~gbsta, vbup~uvall AS uvallp,
           vbkd~bstdk_e,
           vbkd_p~ihrez, vbkd_p~bstkd,
           kna1~name1 AS name1_kunnr,
           knvv~zzbrsch, knvv~klabc,
           kna1_we~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe, kna1_we~regio, kna1_we~pstlz,
           knvp~lifnr AS backoffice_cliente,
           vbpa_a1~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           tvro~traztd,
           mara~mtart, mara~matkl,
           marc~beskz, marc~sobsl,
           t001w~fabkl,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi,
      makt~maktx
      FROM vbak JOIN vbuk ON vbuk~vbeln = vbak~vbeln
                JOIN vbkd ON  vbkd~vbeln = vbak~vbeln
                          AND vbkd~posnr = '000000'
                JOIN kna1 ON kna1~kunnr = vbak~kunnr
                JOIN vbap ON vbap~vbeln = vbak~vbeln
                JOIN vbup ON  vbup~vbeln = vbap~vbeln
                          AND vbup~posnr = vbap~posnr
                JOIN mara ON mara~matnr = vbap~matnr
                JOIN knvv ON  knvv~kunnr = vbak~kunnr
                          AND knvv~vkorg = vbak~vkorg
                          AND knvv~vtweg = vbak~vtweg
                          AND knvv~spart = vbak~spart
                LEFT OUTER JOIN vbkd AS vbkd_p ON  vbkd_p~vbeln = vbap~vbeln
                                               AND vbkd_p~posnr = vbap~posnr
                LEFT OUTER JOIN vbpa AS vbpa_we ON  vbpa_we~vbeln = vbap~vbeln
                                                AND vbpa_we~parvw = 'WE'
                                                AND vbpa_we~posnr = '000000'
                LEFT OUTER JOIN kna1 AS kna1_we ON kna1_we~kunnr = vbpa_we~kunnr
                LEFT OUTER JOIN knvp ON  knvp~kunnr = vbak~kunnr
                                     AND knvp~vkorg = vbak~vkorg
                                     AND knvp~vtweg = vbak~vtweg
                                     AND knvp~spart = vbak~spart
                                     AND knvp~parvw = 'A1'
                LEFT OUTER JOIN vbpa AS vbpa_a1 ON  vbpa_a1~vbeln = vbap~vbeln
                                                AND vbpa_a1~parvw = 'A1'
                                                AND vbpa_a1~posnr = '000000'
               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa_a1~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN tvro ON tvro~route = vbap~route
               LEFT OUTER JOIN marc ON  marc~matnr = vbap~matnr
                                    AND marc~werks = vbap~werks
               LEFT OUTER JOIN t001w ON t001w~werks = vbap~werks
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = vbap~vbeln
                                     AND zvbep~posnr = vbap~posnr
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = vbap~matnr
                                    AND makt~spras = @sy-langu
      INTO CORRESPONDING FIELDS OF TABLE @i_repartos
      WHERE vbap~matnr IN @r_matnr
        AND vbak~kunnr IN @r_kunnr
        AND vbak~vbeln IN @r_vbeln
        AND vbak~vbeln IN @r_contrato
        AND vbak~guebg <= @l_fhasta  " Valido de
        AND vbak~gueen >= @l_fdesde  " Valido a
        AND vbap~werks IN @r_werks
        AND vbap~lgort IN @r_lgort
        AND vbap~kdmat IN @r_kdmat
        AND vbak~vbtyp  = 'G'
        AND vbak~vkorg IN @r_vkorg
        AND vbak~vkorg IN @r_vkorg_usuario
        AND vbak~audat IN @r_audat
        AND vbak~auart IN @r_auart
        AND (    vbak~bstnk   IN @r_bstnk
              OR vbkd_p~bstkd IN @r_bstnk )
        AND vbak~erdat   IN @r_erdat
        AND mara~mtart   IN @r_mtart
        AND mara~matkl   IN @r_matkl
        AND knvv~zzbrsch IN @r_brsch
        AND knvv~klabc   IN @r_klabc
        AND (    knvp~lifnr    IN @r_backoffice
              OR vbpa_a1~lifnr IN @r_backoffice )
        AND kna1_we~pstlz IN @r_pstlz
        AND kna1_we~regio IN @r_regio
        AND vbpa_we~kunnr IN @r_kunwe
        AND vbap~posnr    IN @r_posnr
        AND vbap~bedae    IN @r_bedae
        AND vbup~rfgsa    IN @r_rfgsa " Utilizado en otros documentos
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
     ORDER BY vbap~vbeln, vbap~posnr.

    DELETE ADJACENT DUPLICATES FROM i_repartos.

    calc_repartos_base( CHANGING i_repartos = i_repartos ).
    DELETE i_repartos WHERE NOT backoffice IN r_backoffice.
    DELETE i_repartos WHERE NOT tipo_pedido IN r_tipo_pedido.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>).
      <rep>-vgbel                 = <rep>-vbeln.
      <rep>-kwmeng                = <rep>-wmeng.
      <rep>-ctd_prevista_contrato = <rep>-kwmeng.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_entregas_pedidos.
    DATA: l_ped TYPE t_clave_ped_pos,
          i_ped TYPE TABLE OF t_clave_ped_pos.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>) WHERE vbeln <> '' AND posnr <> ''.
      l_ped-vbeln = <rep>-vbeln.
      l_ped-posnr = <rep>-posnr.
      COLLECT l_ped INTO i_ped.
    ENDLOOP.

    IF i_ped IS INITIAL.
      RETURN.
    ENDIF.

    SELECT lips~vgbel AS vbeln, lips~vgpos AS posnr,
           lips~vbeln AS entrega, lips~posnr AS entrega_pos,
           likp~lfdat, likp~wadat_ist,
           vbuk~wbstk,
           lips~lfimg, lips~vrkme AS entrega_und,
           vbup~wbsta
       FROM lips JOIN likp ON likp~vbeln = lips~vbeln
                 JOIN vbuk ON vbuk~vbeln = lips~vbeln
                 JOIN vbup ON  vbup~vbeln = lips~vbeln
                           AND vbup~posnr = lips~posnr
      INTO CORRESPONDING FIELDS OF TABLE @i_entregas
      FOR ALL ENTRIES IN @i_ped
     WHERE vgbel       = @i_ped-vbeln
       AND vgpos       = @i_ped-posnr
       AND wadat      IN @r_wadat
       AND likp~vbtyp  = 'J'. " Sólo queremos entregas de salida, no de traslado
    SORT i_entregas BY vbeln posnr entrega entrega_pos.

* Si hay posiciones de partición de lotes las agrupamos con la principal.
    LOOP AT i_entregas ASSIGNING FIELD-SYMBOL(<ent>) WHERE entrega_pos >= '900000'.
      SELECT SINGLE uecha FROM lips
        INTO @DATA(l_uecha)
       WHERE vbeln = @<ent>-entrega
         AND posnr = @<ent>-entrega_pos.
      IF sy-subrc = 0 AND NOT l_uecha IS INITIAL.
        ASSIGN i_entregas[ entrega     = <ent>-entrega
                           entrega_pos = l_uecha ] TO FIELD-SYMBOL(<ent2>).
        IF sy-subrc = 0.
          <ent2>-lfimg = <ent2>-lfimg + <ent>-lfimg.
          DELETE i_entregas.
        ENDIF.
      ENDIF.
    ENDLOOP.

    LOOP AT i_entregas ASSIGNING <ent> WHERE wbsta = 'C'.
      <ent>-lfimg_servido = <ent>-lfimg.
      CLEAR <ent>-lfimg.
    ENDLOOP.

    LOOP AT i_entregas ASSIGNING <ent> WHERE wbstk <> 'C' AND NOT wadat_ist IS INITIAL.
      CLEAR <ent>-wadat_ist.
    ENDLOOP.

    LOOP AT i_entregas ASSIGNING <ent> WHERE wbstk = 'C'.
      ASSIGN i_repartos[ vbeln = <ent>-vbeln
                         posnr = <ent>-posnr ] TO <rep>.
      IF sy-subrc = 0.
        <ent>-zz_fecha_servicio_final = <ent>-wadat_ist + dias_ruta( traztd = <rep>-traztd ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_incompletos.
    DATA dfies TYPE dfies.

    CLEAR datos.

    IF NOT posnr IS INITIAL.
      SELECT tbnam, fdnam, fehgr, statg FROM vbuv
        INTO TABLE @DATA(i_vbuv)
       WHERE vbeln = @vbeln
         AND posnr = @posnr
      ORDER BY PRIMARY KEY.
      IF sy-subrc <> 0.
        SELECT tbnam, fdnam, fehgr, statg FROM vbuv
          INTO TABLE @i_vbuv
         WHERE vbeln = @vbeln
           AND posnr = '000000'
        ORDER BY PRIMARY KEY.
      ENDIF.
    ELSE.
      SELECT tbnam, fdnam, fehgr, statg FROM vbuv
        INTO TABLE @i_vbuv
       WHERE vbeln = @vbeln
      ORDER BY PRIMARY KEY.
    ENDIF.

    LOOP AT i_vbuv ASSIGNING FIELD-SYMBOL(<vbuv>).
      IF <vbuv>-fdnam IS INITIAL.
        CONTINUE.
      ENDIF.

      CALL FUNCTION 'RV_FIELD_READ'
        EXPORTING
          fdr_field       = <vbuv>-fdnam
          fdr_langu       = sy-langu
          fdr_table       = <vbuv>-tbnam
        IMPORTING
          fdr_dfies       = dfies
        EXCEPTIONS
          field_not_found = 1
          OTHERS          = 2.
      IF sy-subrc = 0.
        __add_lista datos dfies-scrtext_l.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_ordenes_pedidos.
    TYPES: BEGIN OF t_ped,
             kdauf TYPE caufv-kdauf,
             kdpos TYPE caufv-kdpos,
             aufnr TYPE caufv-aufnr,
           END OF t_ped,
           BEGIN OF t_mat_cli,
             kunnr TYPE kunnr,
             matnr TYPE matnr,
             vkorg TYPE vkorg,
             vtweg TYPE vtweg,
           END OF t_mat_cli.

    DATA: l_ped     TYPE t_ped,
          i_ped     TYPE TABLE OF t_ped,
          l_mat_cli TYPE t_mat_cli,
          i_mat_cli TYPE TABLE OF t_mat_cli,
          l_orden   TYPE t_datos_ordenes.

    IF i_ordenes_reparto IS INITIAL.
      LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>) WHERE vbeln <> ''.
        l_ped-kdauf = <rep>-vbeln.
        l_ped-kdpos = <rep>-posnr.
        IF ordenes = 'X'.
          l_ped-aufnr = <rep>-vbeln.
          __poner_ceros l_ped-aufnr.
        ENDIF.
        COLLECT l_ped INTO i_ped.

        l_mat_cli-matnr = <rep>-matnr.
        l_mat_cli-kunnr = <rep>-kunnr.
        l_mat_cli-vkorg = <rep>-vkorg.
        l_mat_cli-vtweg = <rep>-vtweg.
        COLLECT l_mat_cli INTO i_mat_cli.
      ENDLOOP.

      IF i_ped IS INITIAL.
        RETURN.
      ENDIF.

      IF ordenes IS INITIAL.
        SELECT caufv~kdauf, caufv~kdpos, caufv~aufnr,
               caufv~gltrs, caufv~gstrs, caufv~gluzs, caufv~gstrp, caufv~gltrp,
               caufv~aufpl, caufv~objnr, caufv~plnbez,
               caufv~sichz,
               mara~mtart AS mtart_of
           FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
          INTO CORRESPONDING FIELDS OF TABLE @i_ordenes
          FOR ALL ENTRIES IN @i_ped
         WHERE kdauf = @i_ped-kdauf
           AND kdpos = @i_ped-kdpos
           AND loekz = ''.

        SELECT caufv~zzvbeln AS kdauf, caufv~zzposnr AS kdpos, caufv~aufnr,
               caufv~gltrs, caufv~gstrs, caufv~gluzs, caufv~gstrp, caufv~gltrp,
               caufv~aufpl, caufv~objnr, caufv~plnbez,
               caufv~sichz,
               mara~mtart AS mtart_of
           FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
          APPENDING CORRESPONDING FIELDS OF TABLE @i_ordenes
          FOR ALL ENTRIES IN @i_ped
         WHERE zzvbeln = @i_ped-kdauf
           AND zzposnr = @i_ped-kdpos
           AND loekz = ''.

* Es posible que el pedido no tenga ordenes directamente, pero si el contrato asociado
        LOOP AT i_repartos ASSIGNING <rep> WHERE vbeln <> '' AND vgbel <> '' AND vbtyp = 'C'.
          IF line_exists( i_ordenes[ kdauf = <rep>-vbeln kdpos = <rep>-posnr ] ).
            CONTINUE.
          ENDIF.

          SELECT caufv~zzvbeln AS kdauf, caufv~zzposnr AS kdpos, caufv~aufnr,
                 caufv~gltrs, caufv~gstrs, caufv~gluzs, caufv~gstrp, caufv~gltrp,
                 caufv~aufpl, caufv~objnr, caufv~plnbez,
                 caufv~sichz,
                 mara~mtart AS mtart_of
             FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
            APPENDING CORRESPONDING FIELDS OF TABLE @i_ordenes
           WHERE zzvbeln = @<rep>-vgbel
             AND zzposnr = @<rep>-vgpos
             AND loekz = ''.
          IF sy-subrc = 0.
            LOOP AT i_ordenes ASSIGNING FIELD-SYMBOL(<or>) WHERE     kdauf = <rep>-vgbel
                                                                 AND kdpos = <rep>-vgpos.
              <or>-kdauf = <rep>-vbeln.
              <or>-kdpos = <rep>-posnr.
            ENDLOOP.
          ENDIF.
        ENDLOOP.

        SELECT aufnr, posnr, kdauf, kdpos, wemng, charg
          FROM afpo
          INTO TABLE @DATA(i_afpo)
          FOR ALL ENTRIES IN @i_ped
         WHERE kdauf = @i_ped-kdauf
           AND kdpos = @i_ped-kdpos.

      ELSE.
        SELECT caufv~kdauf, caufv~kdpos, caufv~aufnr,
               caufv~gltrs, caufv~gstrs, caufv~gluzs, caufv~gstrp, caufv~gltrp,
               caufv~aufpl, caufv~objnr, caufv~plnbez,
               caufv~sichz,
               mara~mtart AS mtart_of
           FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
          INTO CORRESPONDING FIELDS OF TABLE @i_ordenes
          FOR ALL ENTRIES IN @i_ped
         WHERE aufnr = @i_ped-aufnr
           AND loekz = ''.

        SELECT aufnr, posnr, kdauf, kdpos, wemng, charg
          FROM afpo
          INTO TABLE @i_afpo
          FOR ALL ENTRIES IN @i_ped
         WHERE aufnr = @i_ped-aufnr.
      ENDIF.
    ELSE.
      " Recuperamos los datos de la orden a partir de la orden directamente
      SELECT caufv~kdauf, caufv~kdpos, caufv~aufnr,
            caufv~gltrs, caufv~gstrs, caufv~gluzs,
            caufv~aufpl, caufv~objnr, caufv~plnbez,
            caufv~sichz,
            mara~mtart AS mtart_of
        FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
       INTO CORRESPONDING FIELDS OF TABLE @i_ordenes
       FOR ALL ENTRIES IN @i_ordenes_reparto
      WHERE aufnr = @i_ordenes_reparto-aufnr.

      SELECT aufnr, posnr, kdauf, kdpos, wemng, charg
        FROM afpo
        INTO TABLE @i_afpo
        FOR ALL ENTRIES IN @i_ordenes_reparto
       WHERE aufnr = @i_ordenes_reparto-aufnr.
    ENDIF.
    SORT i_ordenes BY aufnr.

    IF i_afpo IS NOT INITIAL.
      IF NOT i_mat_cli IS INITIAL.
        SELECT vkorg, vtweg, matnr, kunnr, untto, uebto
          FROM knmt
          INTO TABLE @DATA(i_tolerancia)
           FOR ALL ENTRIES IN @i_mat_cli
          WHERE matnr = @i_mat_cli-matnr
            AND kunnr = @i_mat_cli-kunnr
            AND vkorg = @i_mat_cli-vkorg
            AND vtweg = @i_mat_cli-vtweg.
      ENDIF.

      LOOP AT i_afpo ASSIGNING FIELD-SYMBOL(<afpo>).
        ASSIGN i_ordenes[ aufnr = <afpo>-aufnr ] TO FIELD-SYMBOL(<orden>).
        IF sy-subrc = 0.
          <orden>-afpo_ped = 'X'.
          IF NOT <afpo>-charg IS INITIAL.
            <orden>-charg = <afpo>-charg.
          ENDIF.
          <orden>-wemng         = <orden>-wemng + <afpo>-wemng.
          <orden>-cant_prod_lib = <orden>-cant_prod_lib + <afpo>-wemng.
        ELSE.
          MOVE-CORRESPONDING <afpo> TO l_orden.
          l_orden-afpo_ped      = 'X'.
          l_orden-cant_prod_lib = <afpo>-wemng.
          APPEND l_orden TO i_ordenes.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF o_pp IS INITIAL.
      o_pp = NEW zhcl_pp_core( ).
    ENDIF.

* Cogemos los datos de situación precalculados
    DATA: r_aufnr TYPE RANGE OF aufnr,
          i_zaufk TYPE SORTED TABLE OF zaufk WITH UNIQUE KEY aufnr.

    LOOP AT i_ordenes ASSIGNING <orden> WHERE NOT aufnr IS INITIAL.
      IF NOT line_exists( r_aufnr[ low = <orden>-aufnr ] ).
        APPEND VALUE #( option = 'EQ' sign = 'I' low = <orden>-aufnr ) TO r_aufnr.
      ENDIF.
    ENDLOOP.
    IF NOT r_aufnr IS INITIAL.
* Por si acaso, sólo cogemos la caché de las ordenes terminadas o con situación modificada en la última hora
      DATA ultima_hora TYPE sy-uzeit.
      IF sy-uzeit > '010000'.
        ultima_hora = sy-uzeit - 3600.
      ENDIF.

      SELECT aufnr, situacion, aedat FROM zaufk
        INTO CORRESPONDING FIELDS OF TABLE @i_zaufk
       WHERE aufnr IN @r_aufnr
         AND ( ( situacion = '02' OR situacion = '06' )
             OR ( aedat_sc = @sy-datum AND aezet_sc > @ultima_hora )
             ).
    ENDIF.


    LOOP AT i_ordenes ASSIGNING <orden>.
*      <orden>-stat_txt = zcl_ap_orden_pp=>get_status_st( <orden>-aufnr ). "Lo comento porque tarda macho y no se está usando en Z360
      IF <orden>-afpo_ped = 'X'.
        <orden>-cant_tol_exceso = <orden>-wemng.
        <orden>-cant_tol_falta  = <orden>-wemng.
        ASSIGN i_repartos[ vbeln = <orden>-kdauf
                           posnr = <orden>-kdpos ] TO <rep>.
        ASSIGN i_tolerancia[ matnr = <rep>-matnr
                             kunnr = <rep>-kunnr ] TO FIELD-SYMBOL(<tol>).
        IF sy-subrc = 0.
          <orden>-cant_tol_exceso = <orden>-cant_tol_exceso + ( <orden>-cant_tol_exceso * <tol>-uebto / 100 ).
          <orden>-cant_tol_falta  = <orden>-cant_tol_falta + ( <orden>-cant_tol_falta * <tol>-untto / 100 ).
        ENDIF.
      ENDIF.
      SELECT steus
        FROM afvc
        WHERE aufpl = @<orden>-aufnr
          AND steus = 'PP02'
        ORDER BY PRIMARY KEY
        INTO @<orden>-steus
        UP TO 1 ROWS.
      ENDSELECT.

      ASSIGN i_zaufk[ aufnr = <orden>-aufnr ] TO FIELD-SYMBOL(<aufk>).
      IF sy-subrc = 0.
        <orden>-situacion = <aufk>-situacion.
      ELSE.
        <orden>-situacion     = o_pp->get_situacion_of( aufnr = <orden>-aufnr ).
      ENDIF.

      <orden>-situacion_txt = o_cache->get( tabla = 'D ZSSD_DO_SITUACION' clave = <orden>-situacion ).

      ASSIGN i_repartos[ vbeln = <orden>-kdauf
                         posnr = <orden>-kdpos ] TO <rep>.
      IF sy-subrc = 0.
        <orden>-ruta = o_pp->get_ruta( matnr = <rep>-matnr
                                       werks = <rep>-werks ).

      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_ped_compra.
    DATA: l_ped TYPE t_clave_ped_pos,
          i_ped TYPE TABLE OF t_clave_ped_pos.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>) WHERE tipo_pedido = 'SU' OR ( tipo_pedido >= 'P1' AND tipo_pedido <= 'P9' ).
      l_ped-vbeln = <rep>-vbeln.
      l_ped-posnr = <rep>-posnr.
      COLLECT l_ped INTO i_ped.
    ENDLOOP.

    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    SELECT ekkn~vbeln, ekkn~vbelp, ekpo~ebeln, ekpo~ebelp, zzaufnr, zzcrear_of FROM ekkn JOIN ekpo ON  ekpo~ebeln = ekkn~ebeln
                                                                                                   AND ekpo~ebelp = ekkn~ebelp
      INTO TABLE @DATA(i_pc)
     FOR ALL ENTRIES IN @i_ped
     WHERE vbeln = @i_ped-vbeln
       AND vbelp = @i_ped-posnr.
    SORT i_pc BY vbeln vbelp zzaufnr DESCENDING ebeln ASCENDING ebelp ASCENDING.

    LOOP AT i_repartos ASSIGNING <rep> WHERE tipo_pedido = 'SU' OR ( tipo_pedido >= 'P1' AND tipo_pedido <= 'P9' ).
      READ TABLE i_pc ASSIGNING FIELD-SYMBOL(<pc>) WITH KEY vbeln = <rep>-vbeln
                                                            vbelp = <rep>-posnr
           BINARY SEARCH.
      IF sy-subrc = 0.
        MOVE-CORRESPONDING <pc> TO <rep>.
        IF <rep>-aufnr IS INITIAL AND NOT <pc>-zzaufnr IS INITIAL.
          <rep>-aufnr = <pc>-zzaufnr.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_stock.
    DATA l_stock_t TYPE mard-labst.
*    DATA l_lgort   TYPE lgort_d.
*    DATA r_lgort   TYPE RANGE OF lgort_d.
    DATA: r_werks_sel TYPE RANGE OF werks_d,
          r_matnr_sel TYPE RANGE OF matnr,
          lr_werks    LIKE LINE OF r_werks_sel,
          lr_matnr    LIKE LINE OF r_matnr_sel.

    lr_werks-option = 'EQ'.
    lr_matnr-option = lr_werks-option.
    lr_werks-sign = 'I'.
    lr_matnr-sign = lr_werks-sign.
    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<reparto>).
      lr_matnr-low = <reparto>-matnr.
      COLLECT lr_matnr INTO r_matnr_sel.
      lr_werks-low = <reparto>-werks.
      COLLECT lr_werks INTO r_werks_sel.
    ENDLOOP.

    IF NOT r_werks_sel IS INITIAL AND NOT r_matnr_sel IS INITIAL.
      o_pp->export_datos_globales( ).
      NEW zhcl_mm_core( )->get_zstocks( EXPORTING r_matnr = r_matnr_sel
                                                  r_werks = r_werks_sel
                                                  ordenes_fabricacion = 'X'
                                                  opt = 'X'
                                        IMPORTING i_zstocks = DATA(i_zstocks_ordenes) ).

      NEW zhcl_mm_core( )->get_zstocks( EXPORTING r_matnr = r_matnr_sel
                                                  r_werks = r_werks_sel
                                                  stock_mm = 'X'
                                                  stock_wm = 'X'
                                                  stock_transito = 'X'
                                                  stock_subcontratacion = 'X'
                                                  bloqueado = 'X'
                                                  calidad = 'X'
                                                  semis = semis
                                                  opt = 'X'
                                        IMPORTING i_zstocks = DATA(i_zstocks_anonimo) ).

      NEW zhcl_mm_core( )->get_zstocks( EXPORTING r_matnr = r_matnr_sel
                                                  r_werks = r_werks_sel
                                                  stock_wm = 'X'
                                                  stock_cliente = 'X'
                                                  bloqueado = 'X'
                                                  calidad = 'X'
                                                  detalle = 'X'
                                                  opt = 'X'
                                        IMPORTING i_zstocks_detalle = DATA(i_zstocks_cliente) ).

      o_pp->import_datos_globales( ).
    ENDIF.

    zcl_mm_material_master=>s_get_ramos( EXPORTING get_rango_mtart = 'X'
                                         " TODO: variable is assigned but only used in commented-out code (ABAP cleaner)
                                         IMPORTING i_sets = DATA(i_set_ramos) ).

    LOOP AT i_repartos ASSIGNING <reparto>.
*      SELECT kalab, lgort
*        FROM mska
*        JOIN vbak ON mska~vbeln = vbak~vbeln
*        WHERE kunnr      = @<reparto>-kunnr
*          AND matnr      = @<reparto>-matnr
*          AND werks      = @<reparto>-werks
*          AND mska~vbeln = @<reparto>-vbeln
*          AND mska~posnr = @<reparto>-posnr
*        ORDER BY mska~vbeln, mska~posnr
*        INTO (@<reparto>-cant_stock_cli, @l_lgort)
*        UP TO 1 ROWS.
*      ENDSELECT.
*
*      IF NOT <reparto>-lgort IS INITIAL.
*        l_lgort = <reparto>-lgort.
*      ENDIF.
*      IF l_lgort IS INITIAL.
*        LOOP AT i_set_ramos ASSIGNING FIELD-SYMBOL(<set_ramo>) WHERE NOT r_mtart IS INITIAL.
*          IF <reparto>-mtart IN <set_ramo>-r_mtart.
*            DATA(l_tipo_mat) = <set_ramo>-id.
*          ENDIF.
*        ENDLOOP.
*        l_lgort = zcl_ap_parametros=>get_atributo1( clave = 'ZSTOCKS'
*                                                    campo = 'ALMACEN_DEFECTO'
*                                                    valor = <reparto>-werks
*                                                    valor2 = l_tipo_mat ).
*      ENDIF.
*      IF l_lgort IS INITIAL.
*        CLEAR r_lgort.
*      ELSE.
*        r_lgort = VALUE #( ( option = 'EQ' sign = 'I' low = l_lgort ) ).
*      ENDIF.
*
*      IF <reparto>-charg IS INITIAL.
*        SELECT labst
*          FROM mard
*          WHERE matnr  = @<reparto>-matnr
*            AND werks  = @<reparto>-werks
*            AND lgort IN @r_lgort
*          ORDER BY PRIMARY KEY
*          INTO (@<reparto>-labst)
*          UP TO 1 ROWS.
*        ENDSELECT.
*      ELSE.
*        SELECT clabs
*          FROM mchb
*          WHERE matnr  = @<reparto>-matnr
*            AND werks  = @<reparto>-werks
*            AND lgort IN @r_lgort
*            AND charg  = @<reparto>-charg
*          ORDER BY PRIMARY KEY
*          INTO (@<reparto>-labst)
*          UP TO 1 ROWS.
*        ENDSELECT.
*      ENDIF.
*
*      SELECT SUM( kalab ) FROM mska JOIN vbak ON mska~vbeln = vbak~vbeln
*        INTO (<reparto>-cant_stock_cli)
*       WHERE kunnr = <reparto>-kunnr
*         AND matnr = <reparto>-matnr
*         AND werks = <reparto>-werks.
*
*      SELECT SUM( kalab ) FROM mska
*        INTO (<reparto>-cant_stock_tcli)
*       WHERE matnr  = <reparto>-matnr
*         AND werks  = <reparto>-werks
*         AND lgort IN r_lgort.
*
*      <reparto>-cant_stock = <reparto>-labst + <reparto>-cant_stock_cli.

      LOOP AT i_zstocks_anonimo ASSIGNING FIELD-SYMBOL(<zstocks>) WHERE     matnr = <reparto>-matnr
                                                                        AND werks = <reparto>-werks.
        <reparto>-labst         = <reparto>-labst + <zstocks>-stock_mm + <zstocks>-stock_transito + <zstocks>-stock_subcont.
        <reparto>-semi_stock_mm = <zstocks>-semi_stock_mm.
        <reparto>-semi_ctd_ord  = <zstocks>-semi_ctd_ord.
      ENDLOOP.

      LOOP AT i_zstocks_ordenes ASSIGNING <zstocks> WHERE     matnr = <reparto>-matnr
                                                          AND werks = <reparto>-werks.
        <reparto>-ctd_ord_abiertas = <reparto>-ctd_ord_abiertas + <zstocks>-ctd_ord.
      ENDLOOP.

      LOOP AT i_zstocks_cliente ASSIGNING FIELD-SYMBOL(<zstocks_det>) WHERE     matnr = <reparto>-matnr
                                                                            AND werks = <reparto>-werks
                                                                            AND tipo  = 'SC'.
        IF <zstocks_det>-kunnr = <reparto>-kunnr.
          <reparto>-cant_stock_cli = <reparto>-cant_stock_cli + <zstocks_det>-clabs + <zstocks_det>-cinsm + <zstocks_det>-cspem.
        ENDIF.
        <reparto>-cant_stock_tcli = <reparto>-cant_stock_tcli + <zstocks_det>-clabs + <zstocks_det>-cinsm + <zstocks_det>-cspem.
      ENDLOOP.

      <reparto>-cant_stock = <reparto>-labst + <reparto>-cant_stock_cli.

* Calculamos la stuación para los pedidos que contra stock
      IF <reparto>-tipo_pedido = 'CS'. " Contra stock
        l_stock_t = <reparto>-cant_stock + <reparto>-ctd_ord_abiertas.
        IF <reparto>-resto > l_stock_t.
          <reparto>-situacion = '00'.
        ELSE.
          <reparto>-situacion = '01'.
        ENDIF.
        <reparto>-situacion_txt = zcl_ap_utils=>get_texto_dominio( dominio = 'ZSSD_DO_SITUACION' valor = <reparto>-situacion ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_estado_reparto.
    CLEAR estado.

    IF reparto IS INITIAL.
      IF NOT vbeln IS INITIAL.
        reparto = get_reparto( vbeln = vbeln
                              posnr = posnr
                              etenr = etenr
                              datos_entregas   = 'X'
                              datos_ordenes    = 'X'
                              datos_ped_compra = 'X' ).

        estado = reparto-estado.
        RETURN.
      ENDIF.
    ENDIF.

    IF reparto IS INITIAL.
      RETURN.
    ENDIF.
    IF    reparto-tipo_pedido = 'PT' " Estados pedidos de traslados
       OR reparto-tipo_pedido = 'P3'
       OR reparto-tipo_pedido = 'P4'.
      " TODO: variable is assigned but only used in commented-out code (ABAP cleaner)
      DATA(cantidad_total) = reparto-ctd_ord_abiertas + reparto-cant_stock.
      " Estados validos para pedidos de traslado
      IF reparto-resto <= 0. " No queda nada por entregar
        estado = '8050'.
      ELSE.
        SELECT SINGLE @abap_true FROM ekpo
          INTO @DATA(pedido_finalizado)
                 WHERE ebeln = @reparto-vbeln
                   AND ebelp = @reparto-posnr
                   AND ( elikz = 'X' OR eglkz = 'X' ).
        IF    reparto-lfimg         > 0  " Cantidad en entrega pendiente de servir
           OR reparto-lfimg_servido > 0. " Cantidad en entrega servida
          estado = '3050'.
        ELSEIF pedido_finalizado = abap_true.
          estado = '8050'.
        ELSE.
          SELECT docnum
            FROM zidocs_ped                            "#EC CI_NOFIRST.
            WHERE vbeln = @reparto-vbeln
            ORDER BY PRIMARY KEY
            INTO @DATA(l_docnum)
            UP TO 1 ROWS.
          ENDSELECT.

          SELECT SINGLE zzcrear_of FROM ekpo
            INTO @DATA(lv_zzcrear_of)
            WHERE ebeln = @reparto-vbeln
              AND ebelp = @reparto-posnr.
          " 1070: Error si OF  Pedido Compras
          IF reparto-aufnr IS INITIAL AND lv_zzcrear_of = 'X'.
            estado = '1070'.
          ELSEIF reparto-aufnr IS INITIAL AND lv_zzcrear_of = ''.
            estado = '2030'. " Pedido sin order servido desde stock
          ELSEIF NOT l_docnum IS INITIAL.
            estado = '1080'. " Error comunicaciones
*        ELSEIF reparto-lfimg > cantidad_total.
*          estado = '2010'.
*          "2010: Sin planificar
*          "No hay ni stock ni ofs para satisfacer pedido Cantida Pendiente de servir > ( Stock an + cli + Cantdidad OF's)
*        ELSEIF reparto-lfimg <= cantidad_total.
*          estado = '2020'.
*          "2020: Planificado
            " Hay stock o ofs para satisfacer pedido Cantida Pendiente de servir < ( Stock an + cli + Cantdidad OF's)
          ELSE.
            " 30XX
            " Estado de la OF asocidada si la tiene
            CASE reparto-situacion.
              WHEN '00'.  " Sin planificar
                estado = '2010'. "->SIN PLANIFICART
              WHEN '01'.  " Planificado
                estado = '2020'. "->PLANIFICADO
              WHEN '02'.  " Terminado
                estado = '3040'. " FABRICADO
              WHEN '03'.  " Cerrada y sin fabricar
                estado = '3030'. " CERRADA Y SIN FABRICAR
              WHEN '04'.  " Lanzado a máquina
                estado = '3010'. "->LANZADO A MAQUINA
              WHEN '05'.  " Fabricado parcialmente
                estado = '3020'. "->FABRICADO PARCIALMENTE
              WHEN '06'.  " Cierre administrativo
                estado = '3040'. " FABRICADO
            ENDCASE.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE. " Resto de casos
************************** TERMINADOS ************************************
      IF    NOT reparto-abgru IS INITIAL " Motivo de rechazo posición
         OR     ( reparto-lifsp IN r_bloqueo_final ). " Motivo de rechazo reparto
        IF reparto-wadat_ist <= reparto-edatu. " Fecha SM <= fecha reparto
          estado = '8030'. "->TERMINADO INCOMPLETO A TIEMPO
        ELSE.
          estado = '8040'. "->TERMINADO INCOMPLETO CON RETRASO
        ENDIF.
      ENDIF.

      IF estado IS NOT INITIAL.
        RETURN.
      ENDIF.

      IF reparto-gbsta = 'C' " Posición de pedido cerrada
        AND reparto-wbstk = 'C'. "Entregado
        IF reparto-wadat_ist <= reparto-edatu. " Fecha SM <= fecha reparto
          estado = '8010'. "->TERMINADO COMPLETO A TIEMPO
        ELSE.
          estado = '8020'. "->TERMINADO COMPLETO CON RETRASO
        ENDIF.
      ENDIF.

      IF estado IS NOT INITIAL.
        RETURN.
      ENDIF.

** Bloqueo de reparto
      IF     NOT reparto-lifsp IS INITIAL
         AND NOT reparto-lifsp IN r_bloqueo_final
         AND NOT reparto-lifsp IN r_bloqueo_temporal.
        IF reparto-resto = 0.
          estado = '8060'. "->REPARTO CERRADO MANUALMENTE
        ELSE.
          estado = '8005'. " Terminado sin entregar
        ENDIF.
        RETURN.
      ENDIF.

      IF reparto-resto = '0'.
        estado = '8050'. "-> SIN NECESIDAD
        RETURN.
      ENDIF.

************************* EN EJECUCION  Y PLANIFICADOS ****************************************
      IF reparto-lfimg_servido > 0.
        estado = '3050'. " EN EJECUCION
        RETURN.
      ENDIF.

      IF    NOT reparto-lifsk IS INITIAL " Bloqueo de entrega cabecera
         OR NOT reparto-faksk IS INITIAL " Bloqueo de factura cabecera
         OR     reparto-cmgst  = 'B' " Verificación de crédito efectuada, operación no OK
         OR     reparto-cmgst  = 'C'. " Verificación de crédito efectuada, operación no OK, LibParc
        estado = '1020'. "->BLOQUEADO
        RETURN.
      ENDIF.

      IF reparto-uvall <> 'C' OR reparto-uvallp <> 'C'.
        estado = '1010'. "->INCOMPLETO
        RETURN.
      ENDIF.

      SELECT docnum
        FROM zidocs_ped                                "#EC CI_NOFIRST.
        WHERE vbeln = @reparto-vbeln
        ORDER BY PRIMARY KEY
        INTO @l_docnum
        UP TO 1 ROWS.
      ENDSELECT.
      IF NOT l_docnum IS INITIAL.
        estado = '1080'.  "->ERROR COMUNICACIONES
        RETURN.
      ENDIF.

      CASE reparto-tipo_pedido.
        WHEN 'A1' OR 'A2' OR 'A3' OR 'A4'
          OR 'CO'  " Consigna
          OR 'SU'  " Subcontratación
          OR 'P1' OR 'P2' OR 'P3' OR 'P4' OR 'P5' OR 'P6'.
          IF reparto-tipo_pedido = 'SU'.
            ASSIGN i_nec_orden[ tipo = 'SU' ] TO FIELD-SYMBOL(<nec_orden>).
            IF sy-subrc = 0.
              IF <nec_orden>-of_necesaria = 'X' AND <nec_orden>-aufnr IS INITIAL.
                estado = '1050'.  "->ERROR NO HAY ORDEN SUBCO
              ENDIF.
            ENDIF.
          ELSEIF reparto-tipo_pedido = 'A3' OR reparto-tipo_pedido = 'A4'.
            IF reparto-ebeln IS INITIAL.
              estado = '1060'.  "->ERROR SIN PEDIDO DE COMPRA
            ENDIF.
          ELSE.
            ASSIGN i_nec_orden[ tipo = 'AN' ] TO <nec_orden>.
            IF sy-subrc = 0.
              IF <nec_orden>-of_necesaria = 'X' AND <nec_orden>-aufnr IS INITIAL.
                estado = '1030'.  "->ERROR NO HAY ORDEN ASSEMBLY
              ENDIF.
            ENDIF.
            IF estado IS INITIAL.
              ASSIGN i_nec_orden[ tipo = 'AF' ] TO <nec_orden>.
              IF sy-subrc = 0.
                IF <nec_orden>-of_necesaria = 'X' AND <nec_orden>-aufnr IS INITIAL.
                  estado = '1040'.  "->ERROR NO HAY ORDEN PACS
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.

          IF estado IS INITIAL.
            CASE reparto-situacion.
              WHEN '00'.  " Sin planificar
                estado = '2010'. "->SIN PLANIFICART
              WHEN '01'.  " Planificado
                estado = '2020'. "->PLANIFICADO
              WHEN '02'.  " Terminado
                estado = '3040'. " FABRICADO
              WHEN '03'.  " Cerrada y sin fabricar
                estado = '3030'. " CERRADA Y SIN FABRICAR
              WHEN '04'.  " Lanzado a máquina
                estado = '3010'. "->LANZADO A MAQUINA
              WHEN '05'.  " Fabricado parcialmente
                estado = '3020'. "->FABRICADO PARCIALMENTE
              WHEN '06'.  " Cierre administrativo
                estado = '3040'. " FABRICADO
            ENDCASE.
          ENDIF.

        WHEN OTHERS.
          CASE reparto-situacion.
            WHEN '00'.  " Sin planificar
              estado = '2010'. "->SIN PLANIFICAR
            WHEN '01'.  " Planificado
              estado = '2020'. "->PLANIFICADO
          ENDCASE.
      ENDCASE.

* Si está en estado 20 o 30, verificamos por si acaso que no sea error de reparto 0
      IF estado(1) = '2' OR estado(1) = '3'.
        SELECT SUM( bmeng ) FROM vbep
          INTO @DATA(l_bmeng)
         WHERE vbeln = @reparto-vbeln
           AND posnr = @reparto-posnr.
        IF l_bmeng = 0.
          estado = '1090'. "->ERROR REPARTO 0
          RETURN.
        ENDIF.
      ENDIF.

      IF estado IS NOT INITIAL.
        RETURN.
      ENDIF.

************************** ERROR O BLOQUEO
* TODO: Detectar pedidos sin órdenes de plancha o pedidos de venta sin OF generada

      IF estado IS INITIAL.
        estado = '0010'. " Sin determinar
        RETURN.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_fecha_asignacion.
    DATA(reparto) = get_reparto( vbeln = vbeln
                                 posnr = posnr
                                 etenr = etenr
                                 datos_ordenes    = 'X' ).

    fecha_asignacion = reparto-zz_fecha_asignacion.
  ENDMETHOD.
  METHOD get_interlocutores.
    DATA: l_vbeln TYPE t_clave_ped,
          i_vbeln TYPE TABLE OF t_clave_ped.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>).
      l_vbeln-vbeln = <rep>-vbeln.
      COLLECT l_vbeln INTO i_vbeln.
    ENDLOOP.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    SELECT vbeln, parvw, vbpa~kunnr, kna1~name1
      FROM vbpa
      LEFT OUTER JOIN kna1 ON kna1~kunnr = vbpa~kunnr
      INTO TABLE @DATA(i_inter_cli)
      FOR ALL ENTRIES IN @i_vbeln
     WHERE vbeln       = @i_vbeln-vbeln
       AND posnr       = '000000'
       AND vbpa~kunnr <> ''
       AND parvw      IN ( 'A1', 'P1', 'P2', 'P3', 'VE' ).
    SORT i_inter_cli BY vbeln parvw kunnr.

    SELECT vbeln, parvw, vbpa~lifnr, lfa1~name1
      FROM vbpa
      LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa~lifnr
      INTO TABLE @DATA(i_inter_prov)
      FOR ALL ENTRIES IN @i_vbeln
     WHERE vbeln       = @i_vbeln-vbeln
       AND posnr       = '000000'
       AND vbpa~lifnr <> ''
       AND parvw      IN ('Y0').
    SORT i_inter_prov BY vbeln parvw lifnr.

    LOOP AT i_repartos ASSIGNING <rep>.
      ASSIGN i_inter_prov[ vbeln = <rep>-vbeln ] TO FIELD-SYMBOL(<prov>).
      IF sy-subrc = 0.
        <rep>-lifnr       = <prov>-lifnr.
        <rep>-name1_lifnr = <prov>-name1.
      ENDIF.
      LOOP AT i_inter_cli ASSIGNING FIELD-SYMBOL(<cli>) WHERE vbeln = <rep>-vbeln.
        ASSIGN COMPONENT |PARVW_{ <cli>-parvw }| OF STRUCTURE <rep> TO FIELD-SYMBOL(<parvw>).
        IF sy-subrc = 0.
          <parvw> = <cli>-kunnr.
        ENDIF.
        ASSIGN COMPONENT |NAME1_{ <cli>-parvw }| OF STRUCTURE <rep> TO FIELD-SYMBOL(<name1>).
        IF sy-subrc = 0.
          <name1> = <cli>-name1.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_m2.
    DATA: r_werks TYPE RANGE OF vbap-werks,
          l_clows TYPE yhp_idx_clows,
          l_m2    TYPE zvcxi_pxs_sblar,
          l_m2p   TYPE zvcxi_pxs_sblar.

    CLEAR m2.

    IF NOT spec IS INITIAL.
      DATA(i_spec) = spec.
    ELSE.
      SELECT cself ablag noupt FROM yhp_idx_td100
        INTO CORRESPONDING FIELDS OF TABLE i_spec
       WHERE cuobj = cuobj
       ORDER BY PRIMARY KEY.
    ENDIF.

* Si es PT solo tendremos un componente
    IF lines( i_spec ) = 1.
      IF test = 'X'.
        WRITE / 'Sólo hay una entrada en SPEC'.
      ENDIF.
      ASSIGN i_spec[ 1 ] TO FIELD-SYMBOL(<spec>).

      IF <spec>-noupt <> 0.
        m2 = <spec>-ablag / <spec>-noupt.
      ELSE.
        m2 = <spec>-ablag.
      ENDIF.

      IF test = 'X'.
        WRITE: / 'Un sólo componente, valor m2=', m2.       "#EC *
      ENDIF.

* Excepción, sí solo llega un componente con valor 0, intentamos buscar por el caso del assembled set
      IF <spec>-ablag = 0 AND NOT link IS INITIAL.
        DATA(l_spec_tmp) = i_spec[ 1 ].
        l_spec_tmp-ablag = 1.
        APPEND l_spec_tmp TO i_spec.
        m2 = get_m2( spec = i_spec link = link cuobj = cuobj test = test ).
      ENDIF.

* Pero si Assembled Set, tendremos más de uno tenemos que coger la suma de los componentes multiplicado por el ratio
    ELSEIF lines( i_spec ) > 1.
      IF test = 'X'.
        WRITE: / 'Hay', lines( i_spec ), 'en SPEC'.
      ENDIF.
      IF NOT vbap-werks IS INITIAL.
        r_werks = VALUE #( ( option = 'EQ' sign = 'I' low = vbap-werks ) ).
      ENDIF.
      IF NOT link IS INITIAL.
        DATA(i_link) = link.
      ELSE.
        SELECT cself clows parat matnr FROM yhp_idx_td101
          INTO CORRESPONDING FIELDS OF TABLE i_link
         WHERE cuobj = cuobj
          ORDER BY PRIMARY KEY.
      ENDIF.

      IF i_link IS INITIAL.
* Si no hay entradas en la tabla de entrada de componentes de assembled set
        IF test = 'X'.
          WRITE / 'No hay componentes de assembled set'.
        ENDIF.
        ASSIGN i_spec[ 1 ] TO <spec>.

        IF <spec>-noupt <> 0.
          m2 = <spec>-ablag / <spec>-noupt.
        ELSE.
          m2 = <spec>-ablag.
        ENDIF.

        IF test = 'X'.
          WRITE: / 'Valor m2 de la primera posición=', m2.  "#EC *
        ENDIF.
      ELSE.
        LOOP AT i_spec ASSIGNING <spec>.
          IF <spec>-ablag = 0.
            CONTINUE.
          ENDIF.

          l_clows = sy-tabix.
          ASSIGN i_link[ clows = l_clows ] TO FIELD-SYMBOL(<link>).
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.

          IF <link>-matnr IS INITIAL.
            IF NOT <spec>-noupt IS INITIAL.
              DATA(l_poses) = <spec>-noupt.
            ELSE.
              l_poses = 1.
            ENDIF.
            l_m2 = ( <spec>-ablag / l_poses ) * <link>-parat.
            m2 = m2 + l_m2.
            IF test = 'X'.
              WRITE: / 'Material de enlace nuevo con', l_poses, 'poses, valor m2=', l_m2, 'Acumulado m2=', m2. "#EC *
            ENDIF.
          ELSE.
            SELECT cuobj
              FROM marc
              WHERE matnr = @<link>-matnr
                AND werks IN @r_werks
                AND cuobj <> ''
              ORDER BY PRIMARY KEY
              INTO @DATA(l_cuobj_mat_existente)
              UP TO 1 ROWS.
            ENDSELECT.
            IF sy-subrc = 0 AND NOT l_cuobj_mat_existente IS INITIAL.
              IF test = 'X'.
                WRITE: / 'Material existente', <link>-matnr.
              ENDIF.
              l_m2 = get_m2( cuobj = l_cuobj_mat_existente test = test ).
              l_m2p = l_m2 * <link>-parat.
              IF test = 'X'.
                WRITE: / '->Valor m2 del material existente=', l_m2, "#EC *
                         'Nº parat=', <link>-parat, 'Resultado=', l_m2p. "#EC *
              ENDIF.

              m2 = m2 + l_m2p.
              IF test = 'X'.
                WRITE: / '->Acumulado m2=', m2.             "#EC *
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.
* Es posible que haya enlaces a materiales ya fabricados
        LOOP AT i_link ASSIGNING <link> WHERE clows > l_clows AND matnr <> ''.
          SELECT cuobj
            FROM marc
            WHERE matnr = @<link>-matnr
              AND werks IN @r_werks
              AND cuobj <> ''
            ORDER BY PRIMARY KEY
            INTO @l_cuobj_mat_existente
            UP TO 1 ROWS.
          ENDSELECT.
          IF sy-subrc <> 0 OR l_cuobj_mat_existente IS INITIAL.
            CONTINUE.
          ENDIF.

          IF test = 'X'.
            WRITE: / 'Material existente', <link>-matnr.
          ENDIF.
          l_m2 = get_m2( cuobj = l_cuobj_mat_existente test = test ).
          l_m2p = l_m2 * <link>-parat.
          IF test = 'X'.
            WRITE: / '->Valor m2 del material existente=', l_m2, "#EC *
                     'Nº parat=', <link>-parat, 'Resultado=', l_m2p. "#EC *
          ENDIF.

          m2 = m2 + l_m2p.
          IF test = 'X'.
            WRITE: / '->Acumulado m2=', m2.                 "#EC *
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_medidas.
    DATA: i_mara        TYPE TABLE OF mara,
          yhp_idx_td151 TYPE yhp_idx_td151.

    CLEAR i_unidades.
    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>).
      IF NOT <rep>-cuobj IS INITIAL.
        APPEND VALUE #( cuobj = <rep>-cuobj shuty = 'UNIT' ) TO i_unidades.
        APPEND VALUE #( cuobj = <rep>-cuobj shuty = 'GROUP' ) TO i_unidades.
      ENDIF.
      IF NOT <rep>-matnr IS INITIAL.
        IF NOT line_exists( i_mara[ matnr = <rep>-matnr ] ).
          APPEND VALUE #( matnr = <rep>-matnr ) TO i_mara.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF NOT i_unidades IS INITIAL.
      NEW zhcl_mm_core( )->get_unidades( CHANGING unidades = i_unidades ).
      SORT i_unidades BY cuobj shuty.
    ENDIF.

    IF NOT i_mara IS INITIAL.
      SELECT matnr, laeng, breit, hoehe FROM mara
        INTO TABLE @DATA(i_mat)
       FOR ALL ENTRIES IN @i_mara
       WHERE matnr = @i_mara-matnr.
      SORT i_mat BY matnr.
    ENDIF.

    DATA(o_mat) = NEW zcl_ap_cache( ).

    LOOP AT i_repartos ASSIGNING <rep> WHERE NOT cuobj IS INITIAL.
      READ TABLE i_unidades ASSIGNING FIELD-SYMBOL(<uni>) WITH KEY cuobj = <rep>-cuobj
                                                                   shuty = 'UNIT'
           BINARY SEARCH.
      IF sy-subrc = 0.
        MOVE-CORRESPONDING <uni> TO yhp_idx_td151.
        MOVE-CORRESPONDING yhp_idx_td151 TO <rep>.
        IF <uni>-tbqty > 0.
          DATA(l_ctd_st) = o_mat->get_mat( matnr          = <rep>-matnr
                                           cantidad       = <rep>-bmeng
                                           unidad_origen  = <rep>-vrkme
                                           unidad_destino = 'ST' ).

          <rep>-palets = l_ctd_st / <uni>-tbqty.
        ENDIF.
      ENDIF.

      READ TABLE i_unidades ASSIGNING <uni> WITH KEY cuobj = <rep>-cuobj
                                                     shuty = 'GROUP'
           BINARY SEARCH.
      IF sy-subrc = 0.
        <rep>-cajas_paquete = <uni>-prqty.
      ENDIF.

      READ TABLE i_mat ASSIGNING FIELD-SYMBOL(<mat>) WITH KEY matnr = <rep>-matnr
           BINARY SEARCH.
      IF sy-subrc = 0.
        MOVE-CORRESPONDING <mat> TO <rep>.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_necesidad_ordenes.
    DATA: l_ped    TYPE t_clave_ped_pos,
          i_ped    TYPE TABLE OF t_clave_ped_pos,
          l_nec    TYPE t_necesidad_ordenes,
          i_ped_su TYPE TABLE OF t_clave_ped_pos,
          i_nec_of TYPE tt_necesidad_ordenes.

    CLEAR i_nec_ordenes.
* Buscamos ordenes ASSEMBLY primero
    DATA(r_bedae) = get_rango_par2( campo = 'PLANCHA PACS'
                                    valor = 'OF_PEDIDO_CLASE_NEC' ).
    DATA(r_werks) = get_rango_par2( campo = 'PLANCHA PACS'
                                    valor = 'OF_PEDIDO_CENTRO' ).
    DATA(r_mtart) = get_rango_par2( campo = 'PLANCHA PACS'
                                    valor = 'OF_PEDIDO_TIPO_MAT' ).

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>) WHERE     vbeln <> ''
                                                           AND (    tipo_pedido    = ''
                                                                 OR tipo_pedido(1) = 'A'
                                                                 OR tipo_pedido    = 'CO'
                                                                 OR tipo_pedido    = 'SU' ).
      CLEAR l_ped.
      MOVE-CORRESPONDING <rep> TO l_ped.
      COLLECT l_ped INTO i_ped.

      CLEAR l_nec.
      MOVE-CORRESPONDING <rep> TO l_nec.
      l_nec-kdauf = <rep>-vbeln.
      l_nec-kdpos = <rep>-posnr.
      IF NOT <rep>-tipo_pedido IS INITIAL.
        DATA(l_tipo_pedido) = <rep>-tipo_pedido.
      ELSE.
        l_tipo_pedido = get_tipo_pedido( rep = <rep> ).
      ENDIF.
      IF l_tipo_pedido(1) = 'A' AND <rep>-beskz = 'F'.
        l_nec-tipo = 'AC'.
        COLLECT l_nec INTO i_nec_ordenes.
      ELSEIF l_tipo_pedido(1) = 'A' OR l_tipo_pedido = 'CO'.
        l_nec-tipo         = 'AN'.
        l_nec-of_necesaria = 'X'.
        COLLECT l_nec INTO i_nec_ordenes.
      ELSEIF l_tipo_pedido(1) = 'SU'.
        l_nec-tipo = 'SU'.
        COLLECT l_ped INTO i_ped_su.
        COLLECT l_nec INTO i_nec_ordenes.
      ENDIF.
    ENDLOOP.

    IF i_ped IS INITIAL.
      RETURN.
    ENDIF.

* Buscamos ordenes de todos estos pedidos
    SELECT caufv~kdauf, caufv~kdpos, caufv~aufnr, caufv~auart,
           caufv~plnbez, mara~mtart AS mtart_of
       FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
      INTO TABLE @DATA(i_ordenes)
      FOR ALL ENTRIES IN @i_ped
     WHERE kdauf       = @i_ped-vbeln
       AND kdpos       = @i_ped-posnr
       AND caufv~loekz = ''.

    SELECT caufv~zzvbeln AS kdauf, caufv~zzposnr AS kdpos, caufv~aufnr, caufv~auart,
           caufv~plnbez, mara~mtart AS mtart_of
       FROM caufv JOIN mara ON mara~matnr = caufv~plnbez
      APPENDING CORRESPONDING FIELDS OF TABLE @i_ordenes
      FOR ALL ENTRIES IN @i_ped
     WHERE zzvbeln     = @i_ped-vbeln
       AND zzposnr     = @i_ped-posnr
       AND caufv~loekz = ''.

    LOOP AT i_ordenes ASSIGNING FIELD-SYMBOL(<orden>).
      IF <orden>-mtart_of NOT IN r_mtart.
        CONTINUE.
      ENDIF.

      ASSIGN i_nec_ordenes[ kdauf = <orden>-kdauf
                            kdpos = <orden>-kdpos
                            tipo  = 'AN' ] TO FIELD-SYMBOL(<nec>).
      IF sy-subrc = 0.
        IF <nec>-aufnr IS INITIAL.
          <nec>-aufnr = <orden>-aufnr.
          <nec>-auart = <orden>-auart.
          <nec>-mtart = <orden>-mtart_of.
        ELSE.
          l_nec = <nec>.
          l_nec-aufnr = <orden>-aufnr.
          l_nec-auart = <orden>-auart.
          l_nec-mtart = <orden>-mtart_of.
          APPEND l_nec TO i_nec_ordenes.
        ENDIF.

        IF     <nec>-bedae IN r_bedae
           AND <nec>-werks IN r_werks
           AND <nec>-mtart IN r_mtart.
          APPEND <nec> TO i_nec_of.
        ENDIF.
      ENDIF.
      DELETE i_ordenes.
    ENDLOOP.

    IF NOT i_nec_of IS INITIAL.
      DATA(r_mtart_pacs) = get_rango_par2( campo = 'PLANCHA PACS'
                                           valor = 'OF_PEDIDO_TIPO_MAT_SEMI' ).

* Buscamos si es necesario crear ordenes de plancha
      SELECT caufv~kdauf, caufv~kdpos, caufv~aufnr,   "#EC CI_BUFFJOIN.
             resb~matnr, resb~werks,
             marc~beskz, marc~sobsl, mara~mtart,
             t460a~wrk02
        FROM resb JOIN mara  ON resb~matnr = mara~matnr
                  JOIN marc  ON  marc~matnr = resb~matnr  " El material existe en el centro del que se tiene que aprovisionar
                             AND marc~werks = resb~werks
                  JOIN caufv ON caufv~aufnr = resb~aufnr
                  JOIN t460a ON  t460a~beskz = marc~beskz " La clase de necesidad del matertial es aprovisionamiento en otro centro
                             AND t460a~werks = marc~werks
                             AND t460a~sobsl = marc~sobsl
        INTO TABLE @DATA(i_pacs)
        FOR ALL ENTRIES IN @i_nec_of
        WHERE resb~aufnr   = @i_nec_of-aufnr
          AND mara~mtart  IN @r_mtart_pacs
*          AND resb~xloek = ''.
          AND t460a~wrk02 <> ''.

      LOOP AT i_pacs ASSIGNING FIELD-SYMBOL(<pacs>).
        CLEAR l_nec.
        MOVE-CORRESPONDING <pacs> TO l_nec.
        CLEAR l_nec-aufnr.
        l_nec-tipo         = 'AF'.
        l_nec-of_necesaria = 'X'.
        l_nec-origen       = <pacs>-aufnr.
        __quitar_ceros l_nec-origen.

        SELECT aufk~aufnr, aufk~auart FROM aufk JOIN afpo ON afpo~aufnr = aufk~aufnr
          INTO TABLE @DATA(i_ord_semi)
         WHERE afpo~matnr = @l_nec-matnr
           AND afpo~kdauf = @l_nec-kdauf
           AND afpo~kdpos = @l_nec-kdpos
           AND loekz      = ''.
        IF sy-subrc <> 0.
          COLLECT l_nec INTO i_nec_ordenes.
        ELSE.
          LOOP AT i_ord_semi ASSIGNING FIELD-SYMBOL(<ord>).
            l_nec-aufnr = <ord>-aufnr.
            l_nec-auart = <ord>-auart.
            COLLECT l_nec INTO i_nec_ordenes.
            DELETE i_ordenes WHERE aufnr = <ord>-aufnr.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF NOT i_ped_su IS INITIAL.
      SELECT ekkn~vbeln AS kdauf, ekkn~vbelp AS kdpos, ekpo~ebeln AS origen, zzaufnr AS aufnr, zzcrear_of AS of_necesaria,
             caufv~plnbez, caufv~auart, mara~mtart
        FROM ekkn JOIN ekpo ON  ekpo~ebeln = ekkn~ebeln
                            AND ekpo~ebelp = ekkn~ebelp
                  LEFT OUTER JOIN caufv ON caufv~aufnr = ekpo~zzaufnr
                  JOIN mara  ON mara~matnr = caufv~plnbez
        INTO TABLE @DATA(i_ord_ped_su)
       FOR ALL ENTRIES IN @i_ped_su
       WHERE vbeln = @i_ped_su-vbeln
         AND vbelp = @i_ped_su-posnr.

      LOOP AT i_ord_ped_su ASSIGNING FIELD-SYMBOL(<ord_ped_su>).
        ASSIGN i_nec_ordenes[ kdauf = <ord_ped_su>-kdauf
                              kdpos = <ord_ped_su>-kdpos
                              tipo  = 'SU' ] TO <nec>.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.

        IF <nec>-aufnr IS INITIAL.
          <nec>-aufnr        = <ord_ped_su>-aufnr.
          <nec>-auart        = <ord_ped_su>-auart.
          <nec>-mtart        = <ord_ped_su>-mtart.
          <nec>-of_necesaria = <ord_ped_su>-of_necesaria.
        ELSE.
          l_nec = <nec>.
          l_nec-aufnr        = <ord_ped_su>-aufnr.
          l_nec-auart        = <ord_ped_su>-auart.
          l_nec-mtart        = <ord_ped_su>-mtart.
          l_nec-of_necesaria = <ord_ped_su>-of_necesaria.
          APPEND l_nec TO i_nec_ordenes.
        ENDIF.
      ENDLOOP.
    ENDIF.

    LOOP AT i_ordenes ASSIGNING <orden>.
      CLEAR l_nec.
      MOVE-CORRESPONDING <orden> TO l_nec.
      l_nec-matnr = <orden>-plnbez.
      l_nec-mtart = <orden>-mtart_of.
      l_nec-tipo  = '?'.
      APPEND l_nec TO i_nec_ordenes.
    ENDLOOP.

    SORT i_nec_ordenes.
  ENDMETHOD.
  METHOD get_pedidos_desde_entregas.
    CLEAR r_vbeln.

    IF NOT r_wadat[] IS INITIAL.
      IF tipo = 'V'.
        SELECT lips~vgbel AS vbeln FROM lips JOIN likp ON lips~vbeln = likp~vbeln
                                        JOIN vbak ON vbak~vbeln = lips~vgbel
          INTO TABLE @DATA(i_pedidos)
         WHERE wadat_ist  IN @r_wadat
           AND lips~vgbel IN @r_vbeln_sel.
      ELSEIF tipo = 'C'.
        SELECT lips~vgbel AS vbeln FROM lips JOIN likp ON lips~vbeln = likp~vbeln
                                        JOIN ekko ON ekko~ebeln = lips~vgbel
          INTO TABLE @i_pedidos
         WHERE wadat_ist  IN @r_wadat
           AND lips~vgbel IN @r_vbeln_sel.
      ENDIF.

      SORT i_pedidos BY vbeln.
      DELETE ADJACENT DUPLICATES FROM i_pedidos COMPARING ALL FIELDS.
      LOOP AT i_pedidos ASSIGNING FIELD-SYMBOL(<ped>).
        APPEND VALUE #( option = 'EQ' sign = 'I' low = <ped>-vbeln ) TO r_vbeln.
      ENDLOOP.
    ENDIF.

    IF r_vbeln IS INITIAL.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = '?' ) TO r_vbeln.
    ENDIF.
  ENDMETHOD.
  METHOD get_pedidos_desde_ordenes.
    CLEAR r_vbeln.
    IF NOT r_aufnr[] IS INITIAL.
      SELECT caufv~kdauf AS vbeln FROM caufv
        INTO TABLE @DATA(i_pedidos)
       WHERE aufnr IN @r_aufnr
         AND kdauf IN @r_vbeln_sel
         AND loekz  = ''.

      SELECT afpo~kdauf AS vbeln FROM aufk JOIN afpo ON afpo~aufnr = aufk~aufnr
        APPENDING TABLE @i_pedidos
       WHERE aufk~aufnr IN @r_aufnr
         AND aufk~kdauf IN @r_vbeln_sel
         AND loekz       = ''.

      SELECT ekkn~vbeln
        FROM ekkn JOIN ekpo ON  ekpo~ebeln = ekkn~ebeln
                            AND ekpo~ebelp = ekkn~ebelp
                  JOIN caufv ON caufv~aufnr = ekpo~zzaufnr
       APPENDING TABLE @i_pedidos
       WHERE ekpo~zzaufnr IN @r_aufnr
         AND ekpo~loekz    = ''
         AND vbeln        IN @r_vbeln_sel.

      SORT i_pedidos BY vbeln.
      DELETE ADJACENT DUPLICATES FROM i_pedidos COMPARING ALL FIELDS.
      LOOP AT i_pedidos ASSIGNING FIELD-SYMBOL(<ped>).
        APPEND VALUE #( option = 'EQ' sign = 'I' low = <ped>-vbeln ) TO r_vbeln.
      ENDLOOP.
    ENDIF.

    IF r_vbeln IS INITIAL.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = '?' ) TO r_vbeln.
    ENDIF.
  ENDMETHOD.
  METHOD get_pedidos_ficticios_orden.
    CLEAR i_repartos.

* Siempre tienen que haber un filtro por usuario para verificar permisos por organización de ventas
    IF uname IS INITIAL.
      RETURN.
    ENDIF.

* Si han filtrado por algún filtro no posible, no buscamso
    IF    NOT r_brsch IS INITIAL OR NOT r_pstlz IS INITIAL OR NOT r_regio IS INITIAL OR NOT r_contrato IS INITIAL
       OR NOT r_kunwe IS INITIAL OR NOT r_auart IS INITIAL OR NOT r_bedae IS INITIAL OR NOT r_klabc    IS INITIAL
       OR NOT r_wadat IS INITIAL.
      RETURN.
    ENDIF.

    DATA(r_vkorg_usuario) = get_vkorg_aut_usuario( uname = uname ).

    SELECT zcds_caufv_p~vbeln, zcds_caufv_p~zzcliente AS kunnr, zcds_caufv_p~plnbez AS matnr,
           zcds_caufv_p~auart, zcds_caufv_p~gstrp AS audat,
           zcds_caufv_p~gstrp AS edatu,  zcds_caufv_p~gmein AS vrkme,
           zcds_caufv_p~werks, zcds_caufv_p~bstnk, zcds_caufv_p~erdat,
           makt~maktx AS arktx, zcds_caufv_p~gmein AS meins,
           kna1~name1 AS name1_kunnr,
      zcds_caufv_p~vkorg, zcds_caufv_p~backoffice,
           lfa1~name1 AS backoffice_nombre,
           mara~mtart, mara~matkl,
           'OR' AS tipo_pedido, 'O' AS origen,
           knmt~kdmat,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi
      FROM zcds_caufv_p JOIN mara ON mara~matnr = zcds_caufv_p~plnbez
      LEFT OUTER JOIN makt ON  makt~matnr = zcds_caufv_p~plnbez
                           AND makt~spras = @sy-langu
                 JOIN kna1 ON kna1~kunnr = zcds_caufv_p~zzcliente
              LEFT OUTER JOIN lfa1 ON lfa1~lifnr = zcds_caufv_p~backoffice
              LEFT OUTER JOIN zvbep ON zvbep~vbeln = zcds_caufv_p~vbeln
              LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
      LEFT OUTER JOIN knmt ON  knmt~kunnr = zcds_caufv_p~zzcliente
                           AND knmt~matnr = zcds_caufv_p~plnbez
      INTO CORRESPONDING FIELDS OF TABLE @i_repartos
      WHERE zcds_caufv_p~plnbez     IN @r_matnr
        AND zcds_caufv_p~zzcliente  IN @r_kunnr
        AND zcds_caufv_p~vbeln      IN @r_vbeln
        AND zcds_caufv_p~werks      IN @r_werks
        AND zcds_caufv_p~gstrp      IN @r_edatu
        AND zcds_caufv_p~gstrp      IN @r_audat
        AND zcds_caufv_p~vkorg      IN @r_vkorg
        AND zcds_caufv_p~vkorg      IN @r_vkorg_usuario
        AND zcds_caufv_p~backoffice IN @r_backoffice
        AND zcds_caufv_p~bstnk      IN @r_bstnk
        AND zcds_caufv_p~erdat      IN @r_erdat
        AND zcds_caufv_p~aufnr      IN @r_aufnr
        AND mara~mtart              IN @r_mtart
        AND mara~matkl              IN @r_matkl
        AND knmt~kdmat              IN @r_kdmat
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
      ORDER BY zcds_caufv_p~aufnr.
  ENDMETHOD.
  METHOD get_pedidos_traslado.
    " TODO: parameter R_MTART is never used (ABAP cleaner)
    " TODO: parameter UNAME is never used (ABAP cleaner)
    " TODO: parameter R_BACKOFFICE is never used (ABAP cleaner)
    " TODO: parameter R_AUDAT is never used (ABAP cleaner)
    " TODO: parameter R_MATKL is never used (ABAP cleaner)
    " TODO: parameter R_WADAT is never used (ABAP cleaner)

    DATA r_centros         TYPE RANGE OF werks_d.
    DATA i_ordenes_reparto TYPE tt_ordenes_reparto.

    CLEAR i_repartos.

* Si han filtrado por algún filtro no posible, no buscamso
    IF    NOT r_brsch IS INITIAL OR NOT r_pstlz IS INITIAL OR NOT r_regio IS INITIAL OR NOT r_contrato IS INITIAL
       OR NOT r_bedae IS INITIAL OR NOT r_klabc IS INITIAL or not r_comercial is initial.
      RETURN.
    ENDIF.

    r_centros = r_werks.
    IF r_vkorg IS NOT INITIAL.
      SELECT 'I' AS sign, 'EQ' AS option, valor
        FROM zparametros
        APPENDING TABLE @r_centros
        WHERE clave  = 'CORE_WRK'
          AND valor IN @r_vkorg.
    ENDIF.

    SELECT ekko~ebeln AS vbeln, ekpo~ebelp AS posnr, ekpo~werks, ekpo~lgort, ekpo~menge AS kwmeng, ekko~lifnr, ekko~bsakz,
      ekpo~zzped_cliente AS bstnk, ekpo~reslo,
      ekpo~matnr, ekpo~meins, ekpo~matkl, ekpo~mtart, b~maktx AS arktx, " ekpo~zzaufnr AS aufnr,
      ekpo~pstyp AS pstyv, ekpo~zzcliente,
      ekko~bsart AS auart, ekko~aedat AS erdat, ekpo~zzcliente AS kunnr, c~name1 AS name1_kunnr,
      tl~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe,
      ek~belnr AS entrega, ek~budat AS zzfechaconfirmacion,
      yhp~prole AS length, yhp~prole_uom AS length_uom, yhp~prowi AS width, yhp~prowi_uom AS width_uom, yhp~prohe AS height, yhp~prohe_uom AS height_uom,
      'PT' AS tipo_pedido,
      aufk~aufnr,
      zvbep~tipo_pedido AS tipo_pedido_zvbep, zvbep~estado AS estado_zvbep,
      makt~maktx,
      knmt~kdmat
    FROM ekko JOIN ekpo ON ekko~ebeln = ekpo~ebeln
      LEFT JOIN makt AS b ON b~matnr = ekpo~matnr AND b~spras = @sy-langu
      LEFT JOIN t001l AS tl ON tl~werks = ekpo~werks AND tl~lgort = ekpo~lgort
      LEFT JOIN ekbe AS ek ON ek~ebeln = ekko~ebeln AND ek~ebelp = ekpo~ebelp AND ek~vgabe = '8'
      LEFT JOIN marc AS mc ON mc~matnr = ekpo~matnr AND mc~werks = ekpo~werks
      LEFT JOIN yhp_idx_td100  AS yhp ON yhp~cuobj = mc~cuobj
      LEFT JOIN kna1 AS c ON c~kunnr = ekpo~zzcliente
      LEFT JOIN kna1 AS kna1_we ON kna1_we~kunnr = tl~kunnr
      LEFT OUTER JOIN knmt ON  knmt~kunnr = c~kunnr
                           AND knmt~matnr = ekpo~matnr
      LEFT OUTER JOIN aufk ON  aufk~zzsubco_ebeln = ekpo~ebeln
                           AND aufk~zzsubco_ebelp = ekpo~ebelp
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = ekpo~ebeln
                                     AND zvbep~posnr = ekpo~ebelp
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = ekpo~matnr "#EC CI_BUFFJOIN
                                    AND makt~spras = @sy-langu
      INTO TABLE @DATA(lt_datos)
      WHERE ekko~ebeln         IN @r_vbeln
        AND ekpo~matnr         IN @r_matnr
        AND ekpo~werks         IN @r_centros
        AND ekpo~lgort         IN @r_lgort
        AND ekko~aedat         IN @r_erdat
        AND tl~kunnr           IN @r_kunwe
        AND ekko~bsart         IN @r_auart
        AND ekpo~zzped_cliente IN @r_bstnk
        AND ekpo~zzcliente     IN @r_kunnr
*        AND ekpo~zzaufnr IN @r_aufnr
*        AND ekko~bsart  IN ('ZPT4', "Traslado
*                            'ZPE1') "Subco Peris
        AND (    ekko~bsart IN ('ZPT4') " Traslado almacenes
              OR (     ekko~bsart IN ( 'ZPE1',  " Estándar
                                       'ZPE2' )  " Imputados
                   AND ekpo~pstyp  = '3'  " Subcontratación
                   AND ekko~lifnr  = '0000100944' ) ) " Peris
        AND ekpo~loekz  = @space
        AND aufk~aufnr IN @r_aufnr
        AND knmt~kdmat IN @r_kdmat
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
        ORDER BY ekko~ebeln, ekpo~ebelp, ek~belnr DESCENDING.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    DELETE ADJACENT DUPLICATES FROM lt_datos COMPARING vbeln posnr.

    LOOP AT lt_datos ASSIGNING FIELD-SYMBOL(<dat>).
      IF <dat>-pstyv = '3'.
        <dat>-pstyv = 'L'. " El 3 es un L (subcobtración)
      ELSEIF <dat>-pstyv = '7' AND NOT <dat>-reslo IS INITIAL. " En traslados nos interesa el almacén origen
        <dat>-lgort = <dat>-reslo.
      ENDIF.

      IF ( <dat>-auart = 'ZPE1' OR <dat>-auart = 'ZPE2' ) AND <dat>-pstyv = 'L' AND <dat>-lifnr = '0000100944'.
        <dat>-tipo_pedido = 'P3'. " Envío a peris para manipular
      ELSEIF <dat>-auart = 'ZPT4' AND <dat>-lifnr = 'P2000' AND <dat>-lgort = 'P001'.
        <dat>-tipo_pedido = 'P4'. " Almacén regulador
      ELSE.
        <dat>-tipo_pedido = 'PT'. " Pedidos de traslado
      ENDIF.

      IF NOT <dat>-tipo_pedido IN r_tipo_pedido.
        DELETE lt_datos.
        CONTINUE.
      ENDIF.

      IF NOT <dat>-zzcliente IS INITIAL.
        <dat>-kunnr       = <dat>-zzcliente.
        <dat>-name1_kunnr = o_cache->get( tabla = 'KNA1' clave = <dat>-zzcliente ).
      ENDIF.
    ENDLOOP.

    MOVE-CORRESPONDING lt_datos TO i_repartos.
    MOVE-CORRESPONDING lt_datos TO i_ordenes_reparto.

    " Recuperamos los datos de la orden
    DATA(it_ordenes) = get_datos_ordenes_pedidos( i_ordenes_reparto = i_ordenes_reparto ).

    " Recuperamos cantidades
    " Documento compras  EBELN
    " Posición EBELP
    " Reparto  ETENR
    " Fecha de entrega EINDT
    " Cantidad de reparto  MENGE
    " Cantidad entregada WEMNG
    " Cantidad de salida WAMNG
    SELECT ebeln, ebelp, eindt, menge, wemng, wamng, glmng "#EC CI_NO_TRANSFORM
      FROM eket
      INTO TABLE @DATA(lt_repartos)
      FOR ALL ENTRIES IN @lt_datos
      WHERE ebeln  = @lt_datos-vbeln
        AND ebelp  = @lt_datos-posnr
        AND eindt IN @r_edatu.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<ls_rep>).
      DATA(lv_tabix) = sy-tabix.

      <ls_rep>-origen = 'C'.
      <ls_rep>-ebeln  = <ls_rep>-vbeln.
      <ls_rep>-ebelp  = <ls_rep>-posnr+1.

      " asignamos los valores de las ordenes
      IF it_ordenes IS NOT INITIAL.
        LOOP AT it_ordenes ASSIGNING FIELD-SYMBOL(<ls_ordenes>) WHERE aufnr = <ls_rep>-aufnr.
          MOVE-CORRESPONDING <ls_ordenes> TO <ls_rep>.
        ENDLOOP.
      ENDIF.

      " Asignamos las cantidades de los repartos
      LOOP AT lt_repartos INTO DATA(ls_reparto) WHERE ebeln = <ls_rep>-vbeln AND ebelp = <ls_rep>-posnr.
        <ls_rep>-bmeng = <ls_rep>-bmeng + ls_reparto-menge. " Cantidad de reparto  MENGE
*        <ls_rep>-lfimg_servido = <ls_rep>-lfimg_servido + ls_reparto-wemng " Cantidad entregada  WEMNG

        IF <ls_rep>-bsakz = 'T'. " Pedido de traslado
          <ls_rep>-lfimg_servido = <ls_rep>-lfimg_servido + ls_reparto-wamng. " Cantidad de salida WAMNG
          <ls_rep>-lfimg         = <ls_rep>-lfimg + ls_reparto-glmng - ls_reparto-wamng.  " La cantidad pendiente de entrega es la cantidad entregada procedente de traspaso
        ELSE.
          <ls_rep>-lfimg_servido = <ls_rep>-lfimg_servido + ls_reparto-wemng. " Cantidad EM
          <ls_rep>-lfimg         = 0.
        ENDIF.
        "-cantidad de salida
        <ls_rep>-etenr = <ls_rep>-etenr + 1.
        <ls_rep>-edatu = ls_reparto-eindt.
      ENDLOOP.
      IF sy-subrc <> 0 AND r_edatu IS NOT INITIAL.
        DELETE i_repartos INDEX lv_tabix.
        CONTINUE.
      ENDIF.

      IF <ls_rep>-entrega IS INITIAL AND <ls_rep>-bsakz = 'T'. " Si no existe Entrega la cantidad Servido y Pendiente Entrega debe ser cero
        CLEAR : <ls_rep>-lfimg_servido, <ls_rep>-lfimg.
      ELSE.
*        <ls_rep>-lfimg = <ls_rep>-bmeng - <ls_rep>-lfimg_servido. "APC20241017 "LFIMG es cantidad servida pendiente de entregar, no cantidad pendiete
        IF <ls_rep>-lfimg < 0.
          CLEAR <ls_rep>-lfimg.
        ENDIF.

        SELECT DISTINCT lips~vbeln FROM lips JOIN likp ON likp~vbeln = lips~vbeln
          INTO TABLE @DATA(i_ent)
         WHERE vgbel = @<ls_rep>-vbeln
           AND vgpos = @<ls_rep>-posnr
           AND vbtyp = 'J'.
        <ls_rep>-num_entregas_dif = lines( i_ent ).
        <ls_rep>-num_entregas     = <ls_rep>-num_entregas_dif.
      ENDIF.

      " Calculamos resto:
*      <ls_rep>-resto = <ls_rep>-kwmeng - <ls_rep>-lfimg - <ls_rep>-lfimg_servido.
      <ls_rep>-resto = <ls_rep>-kwmeng - <ls_rep>-lfimg_servido.
      IF <ls_rep>-resto < 0.
        CLEAR <ls_rep>-resto.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_reparto.
    CLEAR reparto.
    DATA(i_rep) = get_repartos( r_vbeln = VALUE #( ( option = 'EQ' sign = 'I' low = vbeln ) )
                                r_posnr = VALUE #( ( option = 'EQ' sign = 'I' low = posnr ) )
                                historico = 'X'
                                datos_ordenes = datos_ordenes
                                datos_entregas = datos_entregas
                                datos_medidas = datos_medidas
                                datos_interlocutores = datos_interlocutores
                                datos_ped_compra = datos_ped_compra ).
    IF etenr IS INITIAL.
      READ TABLE i_rep INTO reparto INDEX 1.
    ELSE.
      READ TABLE i_rep INTO reparto WITH KEY etenr = etenr.
    ENDIF.
  ENDMETHOD.
  METHOD get_repartos.
    " TODO: parameter USAR_PRECALCULOS is never used (ABAP cleaner)

    DATA: i_rep     TYPE tt_repartos_base,
          i_rep_ord TYPE tt_repartos.
    DATA l_reparto   TYPE t_repartos.
    DATA i_mat_cuobj TYPE zhcl_mm_core=>tt_mat_cuobj.
    DATA i_nec_orden TYPE tt_necesidad_ordenes.
    DATA zvbep       TYPE zvbep.
    DATA zvbeph      TYPE zvbeph.

    CLEAR i_repartos.

* Control por si acaso....
    IF origen(2) = 'WF'.
      IF r_vbeln IS INITIAL OR lines( r_vbeln ) > 100.
        RETURN.
      ENDIF.
    ENDIF.

**********************************************   VENTAS ************************
    IF add_pedidos_ventas = 'X'.
      IF historico = 'X'.
        DATA(l_metodo) = 'GET_REPARTOS_TODOS'.
      ELSE.
        l_metodo = 'GET_REPARTOS_VIVOS'.
      ENDIF.

      DATA(r_vbelnl) = r_vbeln.
      IF NOT r_aufnr IS INITIAL.
        r_vbelnl = get_pedidos_desde_ordenes( r_aufnr = r_aufnr
                                              r_vbeln_sel = r_vbeln ).
      ENDIF.

      IF NOT r_wadat IS INITIAL.
        r_vbelnl = get_pedidos_desde_entregas( r_wadat = r_wadat
                                               r_vbeln_sel = r_vbelnl
                                               tipo = 'V' ).
      ENDIF.

      CALL METHOD (l_metodo)
        EXPORTING
          r_kunnr       = r_kunnr
          r_vkorg       = r_vkorg
          r_matnr       = r_matnr
          r_mtart       = r_mtart
          r_kdmat       = r_kdmat
          uname         = uname
          r_edatu       = r_edatu
          r_brsch       = r_brsch
          r_vbeln       = r_vbelnl
          r_werks       = r_werks
          r_backoffice  = r_backoffice
          r_comercial   = r_comercial
          r_pstlz       = r_pstlz
          r_audat       = r_audat
          r_regio       = r_regio
          r_contrato    = r_contrato
          r_bstnk       = r_bstnk
          r_kunwe       = r_kunwe
          r_posnr       = r_posnr
          r_auart       = r_auart
          r_bedae       = r_bedae
          r_erdat       = r_erdat
          r_matkl       = r_matkl
          r_klabc       = r_klabc
          r_lgort       = r_lgort
          r_tipo_pedido = r_tipo_pedido
          r_estado      = r_estado
          r_tipo_estado = r_tipo_estado
          r_semi        = r_semi
          r_wadat       = r_wadat
        RECEIVING
          i_repartos    = i_rep.

      MOVE-CORRESPONDING i_rep TO i_repartos.

      IF add_contratos_sin_pedido = 'X' AND 'CT' IN r_tipo_pedido.
        DATA(i_contratos) = get_contratos(           r_kunnr       = r_kunnr
          r_vkorg       = r_vkorg
          r_matnr       = r_matnr
          r_mtart       = r_mtart
          r_kdmat       = r_kdmat
          uname         = uname
          r_edatu       = r_edatu
          r_brsch       = r_brsch
          r_vbeln       = r_vbelnl
          r_werks       = r_werks
          r_backoffice  = r_backoffice
          r_pstlz       = r_pstlz
          r_audat       = r_audat
          r_regio       = r_regio
          r_contrato    = r_contrato
          r_bstnk       = r_bstnk
          r_kunwe       = r_kunwe
          r_posnr       = r_posnr
          r_auart       = r_auart
          r_bedae       = r_bedae
          r_erdat       = r_erdat
          r_matkl       = r_matkl
          r_klabc       = r_klabc
          r_lgort       = r_lgort
          r_tipo_pedido = r_tipo_pedido
          r_estado      = r_estado
          r_tipo_estado = r_tipo_estado
          r_semi        = r_semi
          r_wadat       = r_wadat
          r_rfgsa       = VALUE #( ( option = 'EQ' sign = 'E' low = 'C' ) ) ).

        LOOP AT i_contratos ASSIGNING FIELD-SYMBOL(<contrato>).
          APPEND <contrato> TO i_rep.
          CLEAR l_reparto.
          MOVE-CORRESPONDING <contrato> TO l_reparto.
          APPEND l_reparto TO i_repartos.
        ENDLOOP.
      ENDIF.

      IF datos_interlocutores = 'X'.
        get_interlocutores( CHANGING i_repartos = i_repartos ).
      ENDIF.
      IF datos_ordenes = 'X' OR NOT r_aufnr IS INITIAL.
        DATA(i_ordenes) = get_datos_ordenes_pedidos( i_repartos = i_rep ).

        DATA(r_mtart_of) = get_rango_par( 'TIPO_MAT_SEL_ORDEN' ).
        LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<reparto>).
          LOOP AT i_ordenes ASSIGNING FIELD-SYMBOL(<orden>) WHERE     kdauf     = <reparto>-vbeln
                                                                  AND kdpos     = <reparto>-posnr
*                                                            AND mtart_of = 'ZPTO'. "Sólo queremos la OFs de producto terminado
                                                                  AND mtart_of IN r_mtart_of. " Sólo queremos la OFs de producto terminado
            IF <orden>-stat_txt CS 'PTBO'.         "#EC EMPTY_IF_BRANCH
* N queremos las borradas
            ELSE.
              MOVE-CORRESPONDING <orden> TO <reparto>.
              IF <reparto>-cant_tol_falta > <reparto>-kwmeng OR <reparto>-kwmeng > <reparto>-cant_tol_exceso.
                <reparto>-stat_cant = 'N'.
              ENDIF.
*              <reparto>-zz_fecha_asignacion = <orden>-gltrs + dias_ruta( traztd = <reparto>-traztd ).
              <reparto>-zz_fecha_asignacion = <orden>-gstrp + dias_ruta( traztd = <reparto>-traztd ). " APC20241025 Calculamos con fecha de inicio extream

              IF <reparto>-pstyv = 'ZSC1'.
                <reparto>-zz_fecha_asignacion = <reparto>-zz_fecha_asignacion + 1.
              ENDIF.

              IF NOT <reparto>-fabkl IS INITIAL.
                <reparto>-zz_fecha_asignacion = zcl_ap_fechas=>primer_dia_lab_desde_fecha( fecha = <reparto>-zz_fecha_asignacion
                                                                                           calid = <reparto>-fabkl ).
              ENDIF.

* La fecha de asignació nunca puede ser menor que la de reparto
              IF <reparto>-zz_fecha_asignacion < <reparto>-edatu.
                <reparto>-zz_fecha_asignacion = <reparto>-edatu.
              ENDIF.

            ENDIF.
          ENDLOOP.
        ENDLOOP.
      ENDIF.
      IF datos_entregas = 'X'.
        DATA(i_entregas) = get_datos_entregas_pedidos( i_repartos = i_rep
                                                       r_wadat = r_wadat ).

        asignacion_repartos_entregas( CHANGING i_repartos = i_repartos
                                               i_entregas = i_entregas ).

      ENDIF.

      IF datos_ped_compra = 'X' OR NOT r_aufnr IS INITIAL.
        get_datos_ped_compra( CHANGING i_repartos = i_repartos ).
      ENDIF.

    ENDIF.

**********************************************   ORDENES FICTICIAS ************************
    IF add_ordenes = 'X' AND 'OR' IN r_tipo_pedido.
      DATA(i_rep_ord_tmp) = get_pedidos_ficticios_orden(
        r_kunnr      = r_kunnr
        r_vkorg      = r_vkorg
        r_matnr      = r_matnr
        r_mtart      = r_mtart
        r_kdmat       = r_kdmat
        uname        = uname
        r_edatu      = r_edatu
        r_brsch      = r_brsch
        r_vbeln      = r_vbeln
        r_werks      = r_werks
        r_backoffice = r_backoffice
        r_pstlz      = r_pstlz
        r_audat      = r_audat
        r_regio      = r_regio
        r_contrato   = r_contrato
        r_bstnk      = r_bstnk
        r_kunwe      = r_kunwe
        r_auart      = r_auart
        r_bedae      = r_bedae
        r_erdat      = r_erdat
        r_matkl      = r_matkl
        r_aufnr      = r_aufnr
        r_tipo_pedido = r_tipo_pedido
        r_estado     = r_estado
        r_tipo_estado = r_tipo_estado ).

      LOOP AT i_rep_ord_tmp ASSIGNING FIELD-SYMBOL(<repord>).
* Si tengo un reparto real de esta orden no queremos esta entrada
        IF line_exists( i_repartos[ matnr = <repord>-matnr
                                    werks = <repord>-werks ] ).
          DELETE i_rep_ord_tmp.
        ENDIF.
      ENDLOOP.

      MOVE-CORRESPONDING i_rep_ord_tmp TO i_rep_ord.
      IF datos_ordenes IS INITIAL.
        i_ordenes = get_datos_ordenes_pedidos( i_repartos = i_rep_ord_tmp ordenes = 'X' ).
      ENDIF.

      LOOP AT i_rep_ord ASSIGNING <reparto>.
        ASSIGN i_ordenes[ kdauf = <reparto>-vbeln ] TO <orden>.
        IF sy-subrc = 0.
          MOVE-CORRESPONDING <orden> TO <reparto>.
          IF <reparto>-cant_tol_falta > <reparto>-kwmeng OR <reparto>-kwmeng > <reparto>-cant_tol_exceso.
            <reparto>-stat_cant = 'N'.
          ENDIF.
        ENDIF.
        APPEND <reparto> TO i_repartos.
      ENDLOOP.

    ENDIF.

**********************************************   PEDIDOS TRASLADOS ************************
    IF    add_pedidos_traslado = 'X'
       OR ( lines( r_vbeln ) = 1 AND lines( r_posnr ) = 1 AND i_repartos IS INITIAL ). " Han filtrado por exáctmente una posición y no han encontrado ventas

      r_vbelnl = r_vbeln.
      IF NOT r_wadat IS INITIAL.
        r_vbelnl = get_pedidos_desde_entregas( r_wadat = r_wadat
                                               r_vbeln_sel = r_vbeln
                                               tipo = 'C' ).
      ENDIF.

      DATA(i_pedidos_traslado) = get_pedidos_traslado(
        r_kunnr      = r_kunnr
        r_vkorg      = r_vkorg
        r_matnr      = r_matnr
        r_mtart      = r_mtart
        r_kdmat       = r_kdmat
        uname        = uname
        r_edatu      = r_edatu
        r_brsch      = r_brsch
        r_vbeln      = r_vbelnl
        r_werks      = r_werks
        r_backoffice = r_backoffice
        r_comercial  = r_comercial
        r_pstlz      = r_pstlz
        r_audat      = r_audat
        r_regio      = r_regio
        r_contrato   = r_contrato
        r_bstnk      = r_bstnk
        r_kunwe      = r_kunwe
        r_auart      = r_auart
        r_bedae      = r_bedae
        r_erdat      = r_erdat
        r_matkl      = r_matkl
        r_aufnr      = r_aufnr
        r_lgort       = r_lgort
        r_tipo_pedido = r_tipo_pedido
        r_estado      = r_estado
        r_tipo_estado = r_tipo_estado
        r_semi        = r_semi
        r_wadat       = r_wadat ).

      APPEND LINES OF i_pedidos_traslado TO i_repartos.

    ENDIF.

**********************************************   BUSQUEDAS COMUNES ************************
    DELETE i_repartos WHERE NOT aufnr IN r_aufnr.

    IF NOT r_wadat IS INITIAL.
      DELETE i_repartos WHERE num_entregas = 0.
    ENDIF.

    IF i_repartos IS INITIAL.
      RETURN.
    ENDIF.

    IF datos_medidas = 'X'.
      get_medidas( CHANGING i_repartos = i_repartos ).
    ENDIF.

    IF datos_stocks = 'X'.
      get_datos_stock( EXPORTING semis = stock_semis CHANGING i_repartos = i_repartos ).
    ENDIF.

* Calculamos estados
    SELECT estado, tipo_estado FROM ztsd0010           "#EC CI_NOWHERE.
      INTO TABLE @DATA(i_estados)
     ORDER BY estado.

    i_nec_ordenes = get_necesidad_ordenes( i_repartos = i_repartos ).

    o_par_z360 = NEW #( clave = 'ZRSD0041' ).
    LOOP AT o_par_z360->i_par ASSIGNING FIELD-SYMBOL(<par>) WHERE campo = 'BLOQUEO_FINAL' AND atributo1 = 'X'.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = <par>-valor ) TO r_bloqueo_final.
    ENDLOOP.
    IF sy-subrc <> 0.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = '?' ) TO r_bloqueo_final.
    ENDIF.
    LOOP AT o_par_z360->i_par ASSIGNING <par> WHERE campo = 'BLOQUEO_TEMPORAL' AND atributo1 = 'X'.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = <par>-valor ) TO r_bloqueo_temporal.
    ENDLOOP.
    IF sy-subrc <> 0.
      APPEND VALUE #( option = 'EQ' sign = 'I' low = '?' ) TO r_bloqueo_temporal.
    ENDIF.

    LOOP AT i_repartos ASSIGNING <reparto>.

* Búsqueda del semielaborado
      IF NOT <reparto>-aufnr IS INITIAL.
        SELECT matnr FROM resb                          "#EC CI_NOFIELD
          UP TO 1 ROWS
          INTO <reparto>-semi
         WHERE aufnr = <reparto>-aufnr
           AND prvbe = 'SEMIS'
          ORDER BY matnr.
        ENDSELECT.
      ENDIF.

      IF <reparto>-semi IS INITIAL AND NOT <reparto>-ebeln IS INITIAL AND <reparto>-mtart = 'ZPTO'.
        SELECT matnr FROM resb                          "#EC CI_NOFIELD
          UP TO 1 ROWS
          INTO <reparto>-semi
         WHERE ebeln = <reparto>-ebeln
           AND ebelp = <reparto>-ebelp
           AND prvbe = 'SEMIS'
           ORDER BY matnr.
        ENDSELECT.
      ENDIF.

* Busco SEMIS que no vengan de orden
      IF     sy-tcode       IS INITIAL " Optimización de tiempos
         AND <reparto>-semi IS INITIAL AND NOT <reparto>-cuobj IS INITIAL AND <reparto>-mtart = 'ZPTO'.
        o_cache->get_cache_mem( EXPORTING tabla = 'SEMI' clave = <reparto>-cuobj IMPORTING valor = <reparto>-semi ).
        IF o_cache->enc IS INITIAL.
          i_mat_cuobj = VALUE #( ( cuobj = <reparto>-cuobj ) ).
          NEW zhcl_mm_core( )->get_semis( EXPORTING i_mat = i_mat_cuobj
                                          IMPORTING semis = DATA(semis) ).
          LOOP AT semis ASSIGNING FIELD-SYMBOL(<semi>).
            <reparto>-semi = <semi>-semi.
            EXIT.
          ENDLOOP.

          o_cache->set_cache_mem( tabla = 'SEMI' clave = <reparto>-cuobj valor = <reparto>-semi ).
        ENDIF.
      ELSEIF NOT <reparto>-zvbep_semi IS INITIAL.
        <reparto>-semi = <reparto>-zvbep_semi.
      ENDIF.

      IF NOT <reparto>-semi IS INITIAL.
        o_cache->get_cache_mem( EXPORTING tabla = 'SEMI_MARC' clave = <reparto>-semi clave2 = <reparto>-werks
                                IMPORTING valor = <reparto>-semi_sobsl valor2 = <reparto>-semi_beskz ).
        IF o_cache->enc IS INITIAL.
          SELECT SINGLE sobsl beskz FROM marc
            INTO (<reparto>-semi_sobsl, <reparto>-semi_beskz )
           WHERE matnr = <reparto>-semi
             AND werks = <reparto>-werks.

          o_cache->set_cache_mem( tabla = 'SEMI_MARC' clave = <reparto>-semi clave2 = <reparto>-werks
                                  valor = <reparto>-semi_sobsl valor2 = <reparto>-semi_beskz ).
        ENDIF.
      ENDIF.

* Cálculo tipo de pedido
      CLEAR i_nec_orden.
      LOOP AT i_nec_ordenes ASSIGNING FIELD-SYMBOL(<nec>) WHERE     kdauf = <reparto>-vbeln
                                                                AND kdpos = <reparto>-posnr.
        APPEND <nec> TO i_nec_orden.
      ENDLOOP.

      IF <reparto>-origen = 'V'. " Los pedidos de traslado calculan su tipo de pedido internamente en el método
        <reparto>-tipo_pedido = get_tipo_pedido( EXPORTING rep = <reparto>
                                                 CHANGING  i_nec_ordenes = i_nec_orden ).
      ENDIF.

* Cálculo estado
      get_estado_reparto( EXPORTING i_nec_orden = i_nec_orden
                          IMPORTING estado = <reparto>-estado
                          CHANGING reparto = <reparto> ).
      IF NOT <reparto>-estado IS INITIAL.
        READ TABLE i_estados ASSIGNING FIELD-SYMBOL(<estado>) WITH KEY estado = <reparto>-estado BINARY SEARCH.
        IF sy-subrc = 0.
          <reparto>-tipo_estado = <estado>-tipo_estado.
        ENDIF.
      ENDIF.

* Grabamos cambios en datos precalculados
      IF     r_wadat      IS INITIAL
         AND datos_stocks  = 'X'. " Puede afectar a cálculos
        IF    <reparto>-tipo_pedido <> <reparto>-zvbep_tipo_pedido
           OR <reparto>-estado      <> <reparto>-zvbep_estado
           OR <reparto>-semi        <> <reparto>-zvbep_semi
           OR <reparto>-etenr_unif  <> <reparto>-zvbep_etenr_unif.

* Verifico si no ha cambiado desde la selección inicial.
          SELECT SINGLE tipo_pedido AS zvbep_tipo_pedido
                        estado AS zvbep_estado
                        semi AS zvbep_semi
                        etenr_unif AS zvbep_etenr_unif
          FROM zvbep
           INTO CORRESPONDING FIELDS OF <reparto>
         WHERE vbeln = <reparto>-vbeln
           AND posnr = <reparto>-posnr
           AND etenr = <reparto>-etenr.
          IF    <reparto>-tipo_pedido <> <reparto>-zvbep_tipo_pedido
             OR <reparto>-estado      <> <reparto>-zvbep_estado
             OR <reparto>-semi        <> <reparto>-zvbep_semi
             OR <reparto>-etenr_unif  <> <reparto>-zvbep_etenr_unif.

            MOVE-CORRESPONDING <reparto> TO zvbep.
            zvbep-aedat = sy-datum.
            zvbep-aezet = sy-uzeit.
            zvbep-aenam = sy-uname.
            IF NOT origen IS INITIAL.
              zvbep-tcode = origen.
            ELSE.
              zvbep-tcode = sy-tcode.
            ENDIF.

            DATA(l_reintentos) = 0.
            TRY.
                MODIFY zvbep FROM zvbep.

* Grabamos esta tabla temporalmente para poder analizar datos
                MOVE-CORRESPONDING zvbep TO zvbeph.
                MODIFY zvbeph FROM zvbeph.
              CATCH cx_root.                                "#EC *
                IF l_reintentos < 3.
                  l_reintentos = l_reintentos + 1.
                  RETRY.
                ENDIF.
            ENDTRY.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_repartos_no_sel.
    TYPES: BEGIN OF t_vbep,
             vbeln TYPE vbeln_va,
             posnr TYPE posnr,
             etenr TYPE etenr,
           END OF t_vbep.

    DATA i_vbep TYPE TABLE OF t_vbep.

    CHECK NOT r_edatu IS INITIAL.

    LOOP AT i_repartos ASSIGNING FIELD-SYMBOL(<rep>) WHERE NOT zvbep_etenr_unif IS INITIAL OR n_repartos > 1.
      IF NOT line_exists( i_vbep[ vbeln = <rep>-vbeln posnr = <rep>-posnr ] ). "etenr = <rep>-zvbep_etenr_unif ] ).
        APPEND VALUE #( vbeln = <rep>-vbeln
                        posnr = <rep>-posnr
*                        etenr = <rep>-zvbep_etenr_unif
                      ) TO i_vbep.
      ENDIF.
    ENDLOOP.

    IF i_vbep IS INITIAL.
      RETURN.
    ENDIF.

    SELECT vbep~vbeln, vbep~posnr, vbep~etenr, vbep~ettyp, vbep~edatu, vbep~wmeng, vbep~bmeng, vbep~vrkme, vbep~lifsp,
           vbak~auart, vbak~kunnr, vbak~vkorg, vbak~vtweg, vbak~spart, vbak~bstnk, vbak~audat, vbak~vdatu, vbak~lifsk, vbak~faksk, vbak~erdat, vbak~vbtyp,
           vbuk~uvall, vbuk~cmgst,
           vbap~matnr, vbap~arktx, vbap~kdmat, vbap~kwmeng, vbap~route, vbap~meins, vbap~werks, vbap~lgort, vbap~abgru,
           vbap~zzfconfs AS zzfechaconfirmacion, vbap~cuobj, vbap~kzwi4 AS zm2_venta, vbap~bedae, vbap~pstyv, vbap~vstel,
           vbap~vgbel, vbap~vgpos, vbak_ref~vgtyp AS vgtyp_ref, vbap_ref~zmeng AS ctd_prevista_contrato,
           vbup~gbsta, vbup~uvall AS uvallp,
           vbkd~bstdk_e,
           vbkd_p~ihrez, vbkd_p~bstkd,
           kna1~name1 AS name1_kunnr,
           knvv~zzbrsch, knvv~klabc,
           kna1_we~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe, kna1_we~regio, kna1_we~pstlz,
           knvp~lifnr AS backoffice_cliente,
           vbpa_a1~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           tvro~traztd,
           mara~mtart, mara~matkl,
           marc~beskz, marc~sobsl,
           vbbe~omeng,
           t001w~fabkl,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi, zvbep~etenr_unif AS zvbep_etenr_unif,
           makt~maktx
      FROM vbep JOIN vbak ON vbak~vbeln = vbep~vbeln
                JOIN vbuk ON vbuk~vbeln = vbak~vbeln
                JOIN vbkd ON  vbkd~vbeln = vbak~vbeln
                          AND vbkd~posnr = '000000'
                JOIN kna1 ON kna1~kunnr = vbak~kunnr
                JOIN vbap ON  vbap~vbeln = vbep~vbeln
                          AND vbap~posnr = vbep~posnr
                JOIN vbup ON  vbup~vbeln = vbap~vbeln
                          AND vbup~posnr = vbap~posnr
                JOIN mara ON mara~matnr = vbap~matnr
                JOIN knvv ON  knvv~kunnr = vbak~kunnr
                          AND knvv~vkorg = vbak~vkorg
                          AND knvv~vtweg = vbak~vtweg
                          AND knvv~spart = vbak~spart
                LEFT OUTER JOIN vbbe ON  vbep~vbeln = vbbe~vbeln
                                     AND vbep~posnr = vbbe~posnr
                                     AND vbep~etenr = vbbe~etenr
                LEFT OUTER JOIN vbkd AS vbkd_p ON  vbkd_p~vbeln = vbap~vbeln
                                               AND vbkd_p~posnr = vbap~posnr
                LEFT OUTER JOIN vbpa AS vbpa_we ON  vbpa_we~vbeln = vbep~vbeln
                                                AND vbpa_we~parvw = 'WE'
                                                AND vbpa_we~posnr = '000000'
                LEFT OUTER JOIN kna1 AS kna1_we ON kna1_we~kunnr = vbpa_we~kunnr
                LEFT OUTER JOIN knvp ON  knvp~kunnr = vbak~kunnr
                                     AND knvp~vkorg = vbak~vkorg
                                     AND knvp~vtweg = vbak~vtweg
                                     AND knvp~spart = vbak~spart
                                     AND knvp~parvw = 'A1'
                LEFT OUTER JOIN vbpa AS vbpa_a1 ON  vbpa_a1~vbeln = vbap~vbeln
                                                AND vbpa_a1~parvw = 'A1'
                                                AND vbpa_a1~posnr = '000000'
               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa_a1~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN tvro ON tvro~route = vbap~route
               LEFT OUTER JOIN vbak AS vbak_ref ON  vbak_ref~vbeln = vbap~vgbel
                                                AND vbak_ref~vbtyp = 'G'
               LEFT OUTER JOIN vbap AS vbap_ref ON  vbap_ref~vbeln = vbak_ref~vbeln
                                                AND vbap_ref~posnr = vbap~vgpos
               LEFT OUTER JOIN marc ON  marc~matnr = vbap~matnr
                                    AND marc~werks = vbap~werks
               LEFT OUTER JOIN t001w ON t001w~werks = vbap~werks
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = vbep~vbeln
                                     AND zvbep~posnr = vbep~posnr
                                     AND zvbep~etenr = vbep~etenr
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = vbap~matnr
                                    AND makt~spras = @sy-langu
      APPENDING CORRESPONDING FIELDS OF TABLE @i_repartos
      FOR ALL ENTRIES IN @i_vbep
      WHERE vbep~vbeln = @i_vbep-vbeln
        AND vbep~posnr = @i_vbep-posnr
*        AND vbep~etenr = @i_vbep-etenr.
        AND NOT vbep~edatu IN @r_edatu.

  ENDMETHOD.
  METHOD get_repartos_todos.
    " TODO: parameter R_WADAT is never used (ABAP cleaner)

    CLEAR i_repartos.

* Siempre tienen que haber un filtro por usuario para verificar permisos por organización de ventas
    IF uname IS INITIAL.
      RETURN.
    ENDIF.

    DATA(r_vkorg_usuario) = get_vkorg_aut_usuario( uname = uname ).

    SELECT vbep~vbeln, vbep~posnr, vbep~etenr, vbep~ettyp, vbep~edatu, vbep~wmeng, vbep~bmeng, vbep~vrkme, vbep~lifsp,
           vbak~auart, vbak~kunnr, vbak~vkorg, vbak~vtweg, vbak~spart, vbak~bstnk, vbak~audat, vbak~vdatu, vbak~lifsk, vbak~faksk, vbak~erdat, vbak~vbtyp,
           vbuk~uvall, vbuk~cmgst,
           vbap~matnr, vbap~arktx, vbap~kdmat, vbap~kwmeng, vbap~route, vbap~meins, vbap~werks, vbap~lgort, vbap~abgru,
           vbap~zzfconfs AS zzfechaconfirmacion, vbap~cuobj, vbap~kzwi4 AS zm2_venta, vbap~bedae, vbap~pstyv, vbap~vstel,
           vbap~vgbel, vbap~vgpos, vbak_ref~vgtyp AS vgtyp_ref, vbap_ref~zmeng AS ctd_prevista_contrato,
           vbup~gbsta, vbup~uvall AS uvallp,
           vbkd~bstdk_e,
           vbkd_p~ihrez, vbkd_p~bstkd,
           kna1~name1 AS name1_kunnr,
           knvv~zzbrsch, knvv~klabc,
           kna1_we~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe, kna1_we~regio, kna1_we~pstlz, kna1_we~ort01,
           knvp~lifnr AS backoffice_cliente,
           vbpa_a1~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           vbpa_y0~lifnr AS comercial,
           lfa1_y0~name1 AS comercial_nombre,
           tvro~traztd,
           mara~mtart, mara~matkl,
           marc~beskz, marc~sobsl,
           vbbe~omeng,
           t001w~fabkl,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi, zvbep~etenr_unif AS zvbep_etenr_unif,
           makt~maktx,
           zvbap_hpg~n_repartos
      FROM vbep JOIN vbak ON vbak~vbeln = vbep~vbeln
                JOIN vbuk ON vbuk~vbeln = vbak~vbeln
                JOIN vbkd ON  vbkd~vbeln = vbak~vbeln
                          AND vbkd~posnr = '000000'
                JOIN kna1 ON kna1~kunnr = vbak~kunnr
                JOIN vbap ON  vbap~vbeln = vbep~vbeln
                          AND vbap~posnr = vbep~posnr
                JOIN vbup ON  vbup~vbeln = vbap~vbeln
                          AND vbup~posnr = vbap~posnr
                JOIN mara ON mara~matnr = vbap~matnr
                JOIN knvv ON  knvv~kunnr = vbak~kunnr
                          AND knvv~vkorg = vbak~vkorg
                          AND knvv~vtweg = vbak~vtweg
                          AND knvv~spart = vbak~spart
                LEFT OUTER JOIN vbbe ON  vbep~vbeln = vbbe~vbeln
                                     AND vbep~posnr = vbbe~posnr
                                     AND vbep~etenr = vbbe~etenr
                LEFT OUTER JOIN vbkd AS vbkd_p ON  vbkd_p~vbeln = vbap~vbeln
                                               AND vbkd_p~posnr = vbap~posnr
                LEFT OUTER JOIN vbpa AS vbpa_we ON  vbpa_we~vbeln = vbep~vbeln
                                                AND vbpa_we~parvw = 'WE'
                                                AND vbpa_we~posnr = '000000'
                LEFT OUTER JOIN kna1 AS kna1_we ON kna1_we~kunnr = vbpa_we~kunnr

                LEFT OUTER JOIN knvp ON  knvp~kunnr = vbak~kunnr
                                     AND knvp~vkorg = vbak~vkorg
                                     AND knvp~vtweg = vbak~vtweg
                                     AND knvp~spart = vbak~spart
                                     AND knvp~parvw = 'A1'
                LEFT OUTER JOIN vbpa AS vbpa_a1 ON  vbpa_a1~vbeln = vbap~vbeln
                                                AND vbpa_a1~parvw = 'A1'
                                                AND vbpa_a1~posnr = '000000'
               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa_a1~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN vbpa AS vbpa_y0 ON  vbpa_y0~vbeln = vbap~vbeln
                                               AND vbpa_y0~parvw = 'Y0'
                                               AND vbpa_y0~posnr = '000000'
               LEFT OUTER JOIN lfa1 as lfa1_y0 ON lfa1_y0~lifnr = vbpa_y0~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN tvro ON tvro~route = vbap~route
               LEFT OUTER JOIN vbak AS vbak_ref ON  vbak_ref~vbeln = vbap~vgbel
                                                AND vbak_ref~vbtyp = 'G'
               LEFT OUTER JOIN vbap AS vbap_ref ON  vbap_ref~vbeln = vbak_ref~vbeln
                                                AND vbap_ref~posnr = vbap~vgpos
               LEFT OUTER JOIN marc ON  marc~matnr = vbap~matnr
                                    AND marc~werks = vbap~werks
               LEFT OUTER JOIN t001w ON t001w~werks = vbap~werks
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = vbep~vbeln
                                     AND zvbep~posnr = vbep~posnr
                                     AND zvbep~etenr = vbep~etenr
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = vbap~matnr
                                    AND makt~spras = @sy-langu
               LEFT OUTER JOIN zvbap_hpg ON zvbap_hpg~vbeln = vbap~vbeln
                                        AND zvbap_hpg~posnr = vbap~posnr
      INTO CORRESPONDING FIELDS OF TABLE @i_repartos
      WHERE vbap~matnr IN @r_matnr
        AND vbak~kunnr IN @r_kunnr
        AND vbep~vbeln IN @r_vbeln
        AND vbep~edatu IN @r_edatu
        AND vbap~werks IN @r_werks
        AND vbap~lgort IN @r_lgort
        AND vbap~kdmat IN @r_kdmat
        AND vbak~vbtyp  = 'C'
        AND vbak~vkorg IN @r_vkorg
        AND vbak~vkorg IN @r_vkorg_usuario
        AND vbak~audat IN @r_audat
        AND vbak~auart IN @r_auart
        AND (    vbak~bstnk   IN @r_bstnk
              OR vbkd_p~bstkd IN @r_bstnk )
        AND vbak~erdat   IN @r_erdat
        AND mara~mtart   IN @r_mtart
        AND mara~matkl   IN @r_matkl
        AND knvv~zzbrsch IN @r_brsch
        AND knvv~klabc   IN @r_klabc
        AND (    knvp~lifnr    IN @r_backoffice
              OR vbpa_a1~lifnr IN @r_backoffice )
        and vbpa_y0~lifnr in @r_comercial
        AND kna1_we~pstlz  IN @r_pstlz
        AND kna1_we~regio  IN @r_regio
        AND vbak_ref~vbeln IN @r_contrato
        AND vbpa_we~kunnr  IN @r_kunwe
        AND vbap~posnr     IN @r_posnr
        AND vbap~bedae     IN @r_bedae
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
     ORDER BY vbep~vbeln, vbep~posnr, vbep~etenr.

    get_repartos_no_sel( EXPORTING r_edatu = r_edatu CHANGING i_repartos = i_repartos ).

    SORT i_repartos BY vbeln posnr etenr.
    DELETE ADJACENT DUPLICATES FROM i_repartos.

    calc_repartos_base( CHANGING i_repartos = i_repartos ).
    DELETE i_repartos WHERE NOT backoffice IN r_backoffice.
*    DELETE i_repartos WHERE NOT tipo_pedido IN r_tipo_pedido.
  ENDMETHOD.
  METHOD get_repartos_vivos.
    " TODO: parameter R_LGORT is never used (ABAP cleaner)
    " TODO: parameter R_WADAT is never used (ABAP cleaner)

    CLEAR i_repartos.

* Siempre tienen que haber un filtro por usuario para verificar permisos por organización de ventas
    IF uname IS INITIAL.
      RETURN.
    ENDIF.

    DATA(r_vkorg_usuario) = get_vkorg_aut_usuario( uname = uname ).

    SELECT vbbe~vbeln, vbbe~kunnr, vbbe~posnr, vbbe~matnr, vbbe~etenr, vbbe~omeng,
           vbak~auart, vbak~vkorg, vbak~vtweg, vbak~spart, vbak~bstnk, vbak~audat, vbak~vdatu, vbak~lifsk, vbak~faksk, vbak~erdat, vbak~vbtyp,
           vbuk~uvall, vbuk~cmgst,
           vbep~ettyp, vbep~edatu, vbep~wmeng, vbep~bmeng, vbep~vrkme, vbep~lifsp,
           vbap~werks, vbap~lgort, vbap~abgru, vbap~cuobj, vbap~kzwi4 AS zm2_venta, vbap~bedae, vbap~pstyv, vbap~vstel,
           vbap~arktx, vbap~kdmat, vbap~kwmeng, vbap~route, vbap~meins, vbap~zzfconfs AS zzfechaconfirmacion,
           vbap~vgbel, vbap~vgpos, vbak_ref~vgtyp AS vgtyp_ref, vbap_ref~zmeng AS ctd_prevista_contrato,
           vbup~gbsta, vbup~uvall AS uvallp,
           vbkd~bstdk_e,
           vbkd_p~ihrez, vbkd_p~bstkd,
           kna1~name1 AS name1_kunnr,
           knvv~zzbrsch, knvv~klabc,
           kna1_we~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe, kna1_we~regio, kna1_we~pstlz,
           knvp~lifnr AS backoffice_cliente,
           vbpa_a1~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           tvro~traztd,
           mara~mtart, mara~matkl,
           marc~beskz, marc~sobsl,
           t001w~fabkl,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi, zvbep~etenr_unif AS zvbep_etenr_unif,
           makt~maktx,
           zvbap_hpg~n_repartos
      FROM vbbe JOIN mara ON mara~matnr = vbbe~matnr
                JOIN vbak ON vbak~vbeln = vbbe~vbeln
                JOIN vbuk ON vbuk~vbeln = vbak~vbeln
                JOIN kna1 ON kna1~kunnr = vbbe~kunnr
                JOIN vbkd ON  vbkd~vbeln = vbak~vbeln
                          AND vbkd~posnr = '000000'
                JOIN vbap ON  vbap~vbeln = vbbe~vbeln
                          AND vbap~posnr = vbbe~posnr
                JOIN vbup ON  vbup~vbeln = vbbe~vbeln
                          AND vbup~posnr = vbbe~posnr
                JOIN vbep ON  vbep~vbeln = vbbe~vbeln
                          AND vbep~posnr = vbbe~posnr
                          AND vbep~etenr = vbbe~etenr
                JOIN knvv ON  knvv~kunnr = vbak~kunnr
                          AND knvv~vkorg = vbak~vkorg
                          AND knvv~vtweg = vbak~vtweg
                          AND knvv~spart = vbak~spart
                LEFT OUTER JOIN vbkd AS vbkd_p ON  vbkd_p~vbeln = vbap~vbeln
                                               AND vbkd_p~posnr = vbap~posnr
                LEFT OUTER JOIN vbpa AS vbpa_we ON  vbpa_we~vbeln = vbbe~vbeln
                                                AND vbpa_we~parvw = 'WE'
                                                AND vbpa_we~posnr = '000000'
                LEFT OUTER JOIN kna1 AS kna1_we ON kna1_we~kunnr = vbpa_we~kunnr
                LEFT OUTER JOIN knvp ON  knvp~kunnr = vbak~kunnr
                                     AND knvp~vkorg = vbak~vkorg
                                     AND knvp~vtweg = vbak~vtweg
                                     AND knvp~spart = vbak~spart
                                     AND knvp~parvw = 'A1'
                LEFT OUTER JOIN vbpa AS vbpa_a1 ON  vbpa_a1~vbeln = vbbe~vbeln
                                                AND vbpa_a1~parvw = 'A1'
                                                AND vbpa_a1~posnr = '000000'
               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa_a1~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN tvro ON tvro~route = vbap~route
               LEFT OUTER JOIN vbak AS vbak_ref ON  vbak_ref~vbeln = vbap~vgbel
                                                AND vbak_ref~vbtyp = 'G'
               LEFT OUTER JOIN vbap AS vbap_ref ON  vbap_ref~vbeln = vbak_ref~vbeln
                                                AND vbap_ref~posnr = vbap~vgpos
               LEFT OUTER JOIN marc ON  marc~matnr = vbbe~matnr
                                    AND marc~werks = vbbe~werks
               LEFT OUTER JOIN t001w ON t001w~werks = vbap~werks
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = vbep~vbeln
                                     AND zvbep~posnr = vbep~posnr
                                     AND zvbep~etenr = vbep~etenr
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = vbap~matnr
                                    AND makt~spras = @sy-langu
               LEFT OUTER JOIN zvbap_hpg ON zvbap_hpg~vbeln = vbap~vbeln
                                        AND zvbap_hpg~posnr = vbap~posnr
      INTO CORRESPONDING FIELDS OF TABLE @i_repartos
      WHERE vbbe~matnr IN @r_matnr
        AND vbbe~kunnr IN @r_kunnr
        AND vbbe~vbeln IN @r_vbeln
        AND vbbe~werks IN @r_werks
        AND vbep~edatu IN @r_edatu
        AND vbap~kdmat IN @r_kdmat
        AND vbak~vbtyp  = 'C'
        AND vbak~vkorg IN @r_vkorg
        AND vbak~vkorg IN @r_vkorg_usuario
        AND vbak~audat IN @r_audat
        AND vbak~auart IN @r_auart
        AND (    vbak~bstnk   IN @r_bstnk
              OR vbkd_p~bstkd IN @r_bstnk )
        AND vbak~erdat   IN @r_erdat
        AND mara~mtart   IN @r_mtart
        AND mara~matkl   IN @r_matkl
        AND knvv~zzbrsch IN @r_brsch
        AND knvv~klabc   IN @r_klabc
        AND (    knvp~lifnr    IN @r_backoffice
              OR vbpa_a1~lifnr IN @r_backoffice )
        AND kna1_we~pstlz  IN @r_pstlz
        AND kna1_we~regio  IN @r_regio
        AND vbak_ref~vbeln IN @r_contrato
        AND vbpa_we~kunnr  IN @r_kunwe
        AND vbap~posnr     IN @r_posnr
        AND vbap~bedae     IN @r_bedae
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
      ORDER BY vbep~vbeln, vbep~posnr, vbep~etenr.

* Añadimos posiciones de la LIPS sin SM contabilizada
    SELECT vbep~vbeln, vbep~posnr, vbep~etenr, vbep~ettyp, vbep~edatu, vbep~wmeng, vbep~bmeng, vbep~vrkme, vbep~lifsp,
           vbak~auart, vbak~kunnr, vbak~vkorg, vbak~vtweg, vbak~spart, vbak~bstnk, vbak~audat, vbak~vdatu, vbak~lifsk, vbak~faksk, vbak~erdat,
           vbukp~uvall, vbuk~cmgst,
           vbap~matnr, vbap~arktx, vbap~kdmat, vbap~kwmeng, vbap~route, vbap~meins, vbap~werks, vbap~lgort, vbap~abgru,
           vbap~zzfconfs AS zzfechaconfirmacion, vbap~cuobj, vbap~kzwi4 AS zm2_venta, vbap~bedae, vbap~pstyv, vbap~vstel,
           vbap~vgbel, vbap~vgpos, vbak_ref~vgtyp AS vgtyp_ref, vbap_ref~zmeng AS ctd_prevista_contrato,
           vbup~gbsta,
           vbkd_p~ihrez, vbkd_p~bstkd,
           kna1~name1 AS name1_kunnr,
           knvv~zzbrsch, knvv~klabc,
           kna1_we~kunnr AS kunwe, kna1_we~name1 AS name1_kunwe, kna1_we~regio, kna1_we~pstlz,
           knvp~lifnr AS backoffice_cliente,
           vbpa_a1~lifnr AS backoffice,
           lfa1~name1 AS backoffice_nombre,
           tvro~traztd,
           mara~mtart, mara~matkl,
           marc~beskz, marc~sobsl,
           vbbe~omeng,
           t001w~fabkl,
           zvbep~tipo_pedido AS zvbep_tipo_pedido, zvbep~estado AS zvbep_estado, zvbep~semi AS zvbep_semi, zvbep~etenr_unif AS zvbep_etenr_unif,
      makt~maktx
      FROM vbep JOIN vbak ON vbak~vbeln = vbep~vbeln
                JOIN vbuk AS vbukp ON vbukp~vbeln = vbak~vbeln
                JOIN vbkd ON  vbkd~vbeln = vbak~vbeln
                          AND vbkd~posnr = '000000'
                JOIN kna1 ON kna1~kunnr = vbak~kunnr
                JOIN vbap ON  vbap~vbeln = vbep~vbeln
                          AND vbap~posnr = vbep~posnr
                JOIN vbup ON  vbup~vbeln = vbap~vbeln
                          AND vbup~posnr = vbap~posnr
                JOIN lips ON  lips~vgbel = vbap~vbeln
                          AND lips~vgpos = vbap~posnr
                JOIN vbuk ON  vbuk~vbeln  = lips~vbeln
                          AND vbuk~wbstk <> 'C'
                JOIN mara ON mara~matnr = vbap~matnr
                JOIN knvv ON  knvv~kunnr = vbak~kunnr
                          AND knvv~vkorg = vbak~vkorg
                          AND knvv~vtweg = vbak~vtweg
                          AND knvv~spart = vbak~spart
                LEFT OUTER JOIN vbkd AS vbkd_p ON  vbkd_p~vbeln = vbap~vbeln
                                               AND vbkd_p~posnr = vbap~posnr
                LEFT OUTER JOIN vbbe ON  vbep~vbeln = vbbe~vbeln
                                     AND vbep~posnr = vbbe~posnr
                                     AND vbep~etenr = vbbe~etenr
                LEFT OUTER JOIN vbpa AS vbpa_we ON  vbpa_we~vbeln = vbep~vbeln
                                                AND vbpa_we~parvw = 'WE'
                                                AND vbpa_we~posnr = '000000'
                LEFT OUTER JOIN kna1 AS kna1_we ON kna1_we~kunnr = vbpa_we~kunnr
                LEFT OUTER JOIN knvp ON  knvp~kunnr = vbak~kunnr
                                     AND knvp~vkorg = vbak~vkorg
                                     AND knvp~vtweg = vbak~vtweg
                                     AND knvp~spart = vbak~spart
                                     AND knvp~parvw = 'A1'
                LEFT OUTER JOIN vbpa AS vbpa_a1 ON  vbpa_a1~vbeln = vbep~vbeln
                                                AND vbpa_a1~parvw = 'A1'
                                                AND vbpa_a1~posnr = '000000'
*               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = knvp~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN lfa1 ON lfa1~lifnr = vbpa_a1~lifnr "#EC CI_BUFFJOIN.
               LEFT OUTER JOIN tvro ON tvro~route = vbap~route
               LEFT OUTER JOIN vbak AS vbak_ref ON  vbak_ref~vbeln = vbap~vgbel
                                                AND vbak_ref~vbtyp = 'G'
               LEFT OUTER JOIN vbap AS vbap_ref ON  vbap_ref~vbeln = vbak_ref~vbeln
                                                AND vbap_ref~posnr = vbap~vgpos
               LEFT OUTER JOIN marc ON  marc~matnr = vbbe~matnr
                                    AND marc~werks = vbbe~werks
               LEFT OUTER JOIN t001w ON t001w~werks = vbap~werks
               LEFT OUTER JOIN zvbep ON  zvbep~vbeln = vbep~vbeln
                                     AND zvbep~posnr = vbep~posnr
                                     AND zvbep~etenr = vbep~etenr
               LEFT OUTER JOIN ztsd0010 ON ztsd0010~estado = zvbep~estado
               LEFT OUTER JOIN makt ON  makt~matnr = vbap~matnr
                                    AND makt~spras = @sy-langu
      APPENDING CORRESPONDING FIELDS OF TABLE @i_repartos
      WHERE vbap~matnr IN @r_matnr
        AND vbak~kunnr IN @r_kunnr
        AND vbep~vbeln IN @r_vbeln
        AND vbep~edatu IN @r_edatu
        AND vbap~werks IN @r_werks
        AND vbap~kdmat IN @r_kdmat
        AND vbak~vbtyp  = 'C'
        AND vbak~vkorg IN @r_vkorg
        AND vbak~vkorg IN @r_vkorg_usuario
        AND vbak~audat IN @r_audat
        AND vbak~auart IN @r_auart
        AND (    vbak~bstnk   IN @r_bstnk
              OR vbkd_p~bstkd IN @r_bstnk )
        AND vbak~erdat   IN @r_erdat
        AND mara~mtart   IN @r_mtart
        AND mara~matkl   IN @r_matkl
        AND knvv~zzbrsch IN @r_brsch
        AND knvv~klabc   IN @r_klabc
        AND (    knvp~lifnr    IN @r_backoffice
              OR vbpa_a1~lifnr IN @r_backoffice )
        AND kna1_we~pstlz  IN @r_pstlz
        AND kna1_we~regio  IN @r_regio
        AND vbak_ref~vbeln IN @r_contrato
        AND vbpa_we~kunnr  IN @r_kunwe
        AND vbap~posnr     IN @r_posnr
        AND vbap~bedae     IN @r_bedae
        AND (    (     zvbep~tipo_pedido    IN @r_tipo_pedido
                   AND zvbep~estado         IN @r_estado
                   AND zvbep~semi           IN @r_semi
                   AND ztsd0010~tipo_estado IN @r_tipo_estado )
              OR (     zvbep~tipo_pedido     = ''   " Por si no se ha procesado nunca anteriormente
                   AND zvbep~estado          = '' ) )
     ORDER BY vbep~vbeln, vbep~posnr, vbep~etenr.

    get_repartos_no_sel( EXPORTING r_edatu = r_edatu CHANGING i_repartos = i_repartos ).

    SORT i_repartos BY vbeln posnr etenr.
    DELETE ADJACENT DUPLICATES FROM i_repartos.

    calc_repartos_base( CHANGING i_repartos = i_repartos ).
    DELETE i_repartos WHERE NOT backoffice IN r_backoffice.
*    DELETE i_repartos WHERE NOT tipo_pedido IN r_tipo_pedido.
  ENDMETHOD.
  METHOD get_tipo_pedido.
    " TODO: parameter I_NEC_ORDENES is never used or assigned (ABAP cleaner)

    CLEAR tipo_pedido.

    IF rep IS INITIAL.
      DATA(reparto) = get_reparto( vbeln = vbeln
                             posnr = posnr
                             etenr = etenr
                            datos_entregas   = 'X'
                            datos_ordenes    = 'X'
                            datos_ped_compra = 'X' ).

      tipo_pedido = reparto-tipo_pedido.
      RETURN.
    ENDIF.

    IF rep-vbtyp = 'G'.
      tipo_pedido = 'CT'. " Contrato
    ELSEIF rep-pstyv = 'ZTAS'.
      tipo_pedido = 'ME'. " Mercadería
    ELSEIF rep-pstyv = 'ZT0S' OR rep-bedae = 'KSV'.
      tipo_pedido = 'CS'. " Contra stock
    ELSEIF rep-auart = 'ZKB'.
      tipo_pedido = 'CO'. " Consigna
    ELSEIF rep-auart = 'ZTA3' AND rep-lgort(2) = 'CM'.
      tipo_pedido = 'CM'. " Centro de montaje
    ELSEIF rep-pstyv = 'ZSC1' AND rep-vstel = '2000'.
      tipo_pedido = 'P1'. " Manipula Peris, expide HPX
    ELSEIF rep-pstyv = 'ZSC1' AND rep-vstel = 'P001'.
      tipo_pedido = 'P2'. " Manipula Peris, expide Peris
    ELSEIF rep-auart = 'ZTA3' AND rep-vstel = 'P001'.
      tipo_pedido = 'P5'. " Pedido creado por Peris\CM
    ELSEIF rep-pstyv = 'ZSC2'.
      tipo_pedido = 'P6'. " Peris, retorno a fabrica
    ELSEIF rep-auart = 'ZF2' OR rep-auart = 'ZTA6'.
      tipo_pedido = 'SE'. " Servicios
    ELSEIF rep-pstyv = 'ZSC1'.
      tipo_pedido = 'SU'. " Subco
    ELSEIF rep-auart = 'ZRED'.
      tipo_pedido = 'DE'. " Devoluciones
    ELSE.
      IF no_semi IS INITIAL.
        IF NOT rep-semi IS INITIAL.
          IF rep-semi_sobsl = '30'.
            tipo_pedido = 'A4'. " Assembly Semi Subco
          ELSEIF rep-semi_beskz = 'F' AND rep-semi_sobsl <> '40'.
            tipo_pedido = 'A3'. " Assembly Semi Comprado
          ELSE.
            tipo_pedido = 'A2'. " Assembly Semi Fabricado
          ENDIF.
        ELSE.
          tipo_pedido = 'A1'. " Assembly Normal
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_vkorg_aut_usuario.
    DATA: l_all    TYPE abap_bool,
          i_values TYPE TABLE OF usvalues.

    CLEAR: r_vkorg, message.
    CALL FUNCTION 'SUSR_USER_AUTH_FOR_OBJ_GET'
      EXPORTING
*       NEW_BUFFERING       = 3
*       MANDANT             = SY-MANDT
        user_name           = uname
        sel_object          = 'M_MATE_VKO'
*       NO_TRACE            =
        optimize            = 'X'
*       RESPECT_DISABLEMNT_4_AUTH_CHK       =
      IMPORTING
        fully_authorized    = l_all
      TABLES
        values              = i_values
*       IT_FILTERS          =
      EXCEPTIONS
        user_name_not_exist = 1
        not_authorized      = 2
        internal_error      = 3
        OTHERS              = 4.
    IF sy-subrc <> 0.
      r_vkorg = VALUE #( ( option = 'EQ' sign = 'I' low = '?' ) ).
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO message.
    ELSEIF l_all IS INITIAL.
      LOOP AT i_values ASSIGNING FIELD-SYMBOL(<values>) WHERE field = 'VKORG'.
        IF <values>-von = '*'.
          CLEAR r_vkorg.
          RETURN.
        ELSEIF <values>-bis IS INITIAL.
          APPEND VALUE #( option = 'EQ' sign = 'I' low = <values>-von ) TO r_vkorg.
        ELSE.
          APPEND VALUE #( option = 'BT' sign = 'I' low = <values>-von high = <values>-bis ) TO r_vkorg.
        ENDIF.
      ENDLOOP.
      IF sy-subrc <> 0.
        r_vkorg = VALUE #( ( option = 'EQ' sign = 'I' low = '?' ) ).
      ELSE.
        SORT r_vkorg.
        DELETE ADJACENT DUPLICATES FROM r_vkorg.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_werks_aut_usuario.
    DATA: l_all    TYPE abap_bool,
          i_values TYPE TABLE OF usvalues.

    CLEAR: r_werks, message.
    CALL FUNCTION 'SUSR_USER_AUTH_FOR_OBJ_GET'
      EXPORTING
*       NEW_BUFFERING       = 3
*       MANDANT             = SY-MANDT
        user_name           = uname
        sel_object          = 'M_MATE_WRK'
*       NO_TRACE            =
        optimize            = 'X'
*       RESPECT_DISABLEMNT_4_AUTH_CHK       =
      IMPORTING
        fully_authorized    = l_all
      TABLES
        values              = i_values
*       IT_FILTERS          =
      EXCEPTIONS
        user_name_not_exist = 1
        not_authorized      = 2
        internal_error      = 3
        OTHERS              = 4.
    IF sy-subrc <> 0.
      r_werks = VALUE #( ( option = 'EQ' sign = 'I' low = '?' ) ).
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO message.
    ELSEIF l_all IS INITIAL.
      DELETE i_values WHERE von CS ''''.
      LOOP AT i_values ASSIGNING FIELD-SYMBOL(<values>) WHERE field = 'WERKS'.
        IF <values>-von = '*'.
          CLEAR r_werks.
          RETURN.
        ELSEIF <values>-bis IS INITIAL.
          APPEND VALUE #( option = 'EQ' sign = 'I' low = <values>-von ) TO r_werks.
        ELSE.
          APPEND VALUE #( option = 'BT' sign = 'I' low = <values>-von high = <values>-bis ) TO r_werks.
        ENDIF.
      ENDLOOP.
      IF sy-subrc <> 0.
        r_werks = VALUE #( ( option = 'EQ' sign = 'I' low = '?' ) ).
      ELSE.
        SORT r_werks.
        DELETE ADJACENT DUPLICATES FROM r_werks.
      ENDIF.
    ENDIF.
  ENDMETHOD.
