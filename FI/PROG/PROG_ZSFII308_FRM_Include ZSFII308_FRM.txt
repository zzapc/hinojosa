*&---------------------------------------------------------------------*
*&  Include           ZSFII308_FRM
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  initialize_variant
*&---------------------------------------------------------------------*
FORM initialize_variant  USING numero.
  x_save = 'A'.
  CASE numero.
    WHEN 1.
      CLEAR is_variant1.
      is_variant1-report = g_repid.
      CONCATENATE is_variant1-report numero INTO is_variant1-report.
      CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
        EXPORTING
          i_save     = x_save
        CHANGING
          cs_variant = is_variant1
        EXCEPTIONS
          not_found  = 2.
    WHEN 2.
      CLEAR is_variant2.
      is_variant2-report = g_repid.
      CONCATENATE is_variant2-report numero INTO is_variant2-report.
      CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
        EXPORTING
          i_save     = x_save
        CHANGING
          cs_variant = is_variant2
        EXCEPTIONS
          not_found  = 2.
    WHEN 3.
      CLEAR is_variant3.
      is_variant3-report = g_repid.
      CONCATENATE is_variant3-report numero INTO is_variant3-report.
      CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
        EXPORTING
          i_save     = x_save
        CHANGING
          cs_variant = is_variant3
        EXCEPTIONS
          not_found  = 2.
  ENDCASE.
ENDFORM.                    " initialize_variant

*&---------------------------------------------------------------------*
*&      Form  recoger_datos1
*&---------------------------------------------------------------------*
FORM recoger_datos1 .

  CLEAR: tdatos1, tdatos2, tdatos1[], tdatos2[], tcomp1, tcomp1[], tcomp2, tcomp2[], t_reldocs, t_reldocs[],
         v_waers1, v_waers2, v_waers3.

* OBtener relación clase documentos internos-externos
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE t_reldocs
  FROM zsfit308_c
  WHERE bukrs = p_bukrs AND
        hbkid = p_banco.

* Obtener claves de cuentas para bancos propios elegidos
  CLEAR: r_hkont, r_hkont[].
  SELECT * FROM t012k
  WHERE bukrs = p_bukrs AND
        hbkid = p_banco.
    r_hkont-sign = 'I'.
    cuenta = t012k-wekon.
    r_hkont-low = t012k-wekon.
    r_hkont-option = 'EQ'.
    APPEND r_hkont.
    v_waers1 = t012k-waers.

*Se amplia a wikon
    r_hkont-low = t012k-wikon.
    APPEND r_hkont.
  ENDSELECT.

  v_waers2 = v_waers1.
  v_waers3 = v_waers1.

* Obtener descriptivos
  SELECT SINGLE butxt INTO desc_soc FROM t001
  WHERE bukrs = p_bukrs.
  SELECT SINGLE txt20 INTO desc_cue FROM skat
  WHERE spras = sy-langu AND saknr = cuenta.
  SELECT SINGLE text1 INTO desc_ban FROM t012t
  WHERE spras = sy-langu AND bukrs = p_bukrs AND hbkid = p_banco.

* Obtener datos de la BSIS
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE tdatos1 FROM bsis
  WHERE bukrs = p_bukrs AND
        hkont IN r_hkont AND
        budat IN p_budat.

* Recorremos la tabla. Los docs. cuya clase sea un numérico se quedan en el 1er alv
* el resto los pasamos al 2º
  LOOP AT tdatos1.
    moneda = tdatos1-waers.
* Obtener moneda de la sociedad para moneda local
    SELECT SINGLE waers INTO tdatos1-mon_local FROM t001
    WHERE bukrs = tdatos1-bukrs.

* Poner signo al importe
    IF tdatos1-shkzg = 'H'.
      tdatos1-dmbtr = - tdatos1-dmbtr.
      tdatos1-wrbtr = - tdatos1-wrbtr.
    ENDIF.
* Obtener denominación de la clase de doc.
    SELECT SINGLE ltext INTO tdatos1-ltext FROM t003t
    WHERE blart = tdatos1-blart AND
          spras = 'S'.

    IF tdatos1-blart = 'EA' OR tdatos1-blart =  'EC' OR tdatos1-blart = 'ED' OR tdatos1-blart = 'EF' OR tdatos1-blart = 'EI' OR tdatos1-blart = 'EJ' OR tdatos1-blart ='EL' OR tdatos1-blart = 'EN' OR tdatos1-blart = 'ER'
      OR tdatos1-blart = 'ET' OR tdatos1-blart = 'EU' OR tdatos1-blart = 'EX' OR tdatos1-blart = 'EY'.
      MODIFY tdatos1.
    ELSEIF tdatos1-augdt IS INITIAL AND tdatos1-augbl IS INITIAL.
      MOVE-CORRESPONDING tdatos1 TO tdatos2.
      APPEND tdatos2.
      DELETE tdatos1.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " recoger_datos1

*&---------------------------------------------------------------------*
*&      Form  mostrar_datos1
*&---------------------------------------------------------------------*
FORM mostrar_datos1 .

* Inicializamos campos de cabecera a mostrar en pantalla.
  PERFORM rellenar_fieldcat1.

* Inicializamos formato de salida
  PERFORM rellenar_layout.

* Eliminamos botones
  PERFORM rellenar_toolbar_excl.

  CALL METHOD grid1->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZSFIS308_B'
      is_layout            = is_layout
      it_toolbar_excluding = t_toolbar_excl
      is_variant           = is_variant1
      i_save               = x_save
      i_default            = 'X'
    CHANGING
      it_outtab            = tdatos1[]
      it_fieldcatalog      = it_fieldcat1[]
      it_sort              = it_sort.

  SET HANDLER g_application->handle_hotspot1        FOR grid1.
  SET HANDLER g_application->handle_double_click1   FOR grid1.
  CALL METHOD grid1->set_toolbar_interactive.

ENDFORM.                    " mostrar_datos

*&---------------------------------------------------------------------*
*&      Form  rellenar_fieldcat1
*&---------------------------------------------------------------------*
FORM rellenar_fieldcat1.

  DATA h_fieldcat_wa TYPE slis_fieldcat_alv.
  DATA h_index LIKE sy-tabix.

  REFRESH g_fieldcat_tab1.
  REFRESH it_fieldcat1.

  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = g_repid
      i_internal_tabname     = 'TDATOS1'
      i_structure_name       = 'ZSFIS308_B'
      i_client_never_display = ' '
    CHANGING
      ct_fieldcat            = g_fieldcat_tab1[]
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  LOOP AT g_fieldcat_tab1.
    CASE g_fieldcat_tab1-fieldname.

      WHEN 'BELNR'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        it_fieldcat1-coltext = 'Documento'.
        it_fieldcat1-hotspot = 'X'.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab1.
      WHEN 'DMBTR'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        it_fieldcat1-coltext = 'Importe'.
        it_fieldcat1-cfieldname = 'MON_LOCAL'.
        it_fieldcat1-tabname    = 'TDATOS1'.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab1.
      WHEN 'WRBTR'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        it_fieldcat1-coltext = 'Importe en moneda del documento'.
        it_fieldcat1-cfieldname = 'WAERS'.
        it_fieldcat1-tabname    = 'TDATOS1'.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab1.
      WHEN 'BUDAT'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        it_fieldcat1-coltext = 'Operación'.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab1.
      WHEN 'VALUT'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        it_fieldcat1-coltext = 'Valor / Documento'.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab1.
      WHEN 'SGTXT'.
        MODIFY g_fieldcat_tab1.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat1.
        APPEND it_fieldcat1. CLEAR it_fieldcat1.
        CLEAR g_fieldcat_tab2.
    ENDCASE.
  ENDLOOP.
  REFRESH g_fieldcat_tab1.

ENDFORM.                    " rellenar_fieldcat1

*&---------------------------------------------------------------------*
*&      Form  mostrar_datos2
*&---------------------------------------------------------------------*
FORM mostrar_datos2 .

* Inicializamos campos de cabecera a mostrar en pantalla.
  PERFORM rellenar_fieldcat2.
* Inicializamos formato de salida
  PERFORM rellenar_layout.
* Eliminamos botones
  PERFORM rellenar_toolbar_excl.

  CALL METHOD grid2->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZSFIS308_B'
      is_layout            = is_layout
      it_toolbar_excluding = t_toolbar_excl
      is_variant           = is_variant2
      i_save               = x_save
      i_default            = 'X'
    CHANGING
      it_outtab            = tdatos2[]
      it_fieldcatalog      = it_fieldcat1[]
      it_sort              = it_sort.

  SET HANDLER g_application->handle_hotspot2        FOR grid2.
  SET HANDLER g_application->handle_double_click2   FOR grid2.
  CALL METHOD grid2->set_toolbar_interactive.

ENDFORM.                    " mostrar_datos2

*&---------------------------------------------------------------------*
*&      Form  rellenar_fieldcat2
*&---------------------------------------------------------------------*
FORM rellenar_fieldcat2.

  DATA h_fieldcat_wa TYPE slis_fieldcat_alv.
  DATA h_index LIKE sy-tabix.

  REFRESH g_fieldcat_tab2.
  REFRESH it_fieldcat2.

  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = g_repid
      i_internal_tabname     = 'TDATOS2'
      i_structure_name       = 'ZSFIS308_B'
      i_client_never_display = ' '
    CHANGING
      ct_fieldcat            = g_fieldcat_tab2[]
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  LOOP AT g_fieldcat_tab2.
    CASE g_fieldcat_tab2-fieldname.

      WHEN 'BELNR'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        it_fieldcat2-coltext = 'Documento'.
        it_fieldcat2-hotspot = 'X'.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
      WHEN 'DMBTR'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        it_fieldcat1-coltext = 'Importe'.
        it_fieldcat1-cfieldname = 'MON_LOCAL'.
        it_fieldcat1-tabname    = 'TDATOS1'.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
      WHEN 'WRBTR'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        it_fieldcat1-coltext = 'Importe en moneda del documento'.
        it_fieldcat1-cfieldname = 'WAERS'.
        it_fieldcat1-tabname    = 'TDATOS1'.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
      WHEN 'BUDAT'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        it_fieldcat2-coltext = 'Operación'.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
      WHEN 'VALUT'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        it_fieldcat2-coltext = 'Valor / Documento'.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
      WHEN 'SGTXT'.
        MODIFY g_fieldcat_tab2.
        MOVE-CORRESPONDING g_fieldcat_tab1 TO it_fieldcat2.
        APPEND it_fieldcat2. CLEAR it_fieldcat2.
        CLEAR g_fieldcat_tab2.
    ENDCASE.

  ENDLOOP.
  REFRESH g_fieldcat_tab2.

ENDFORM.                    " rellenar_fieldcat2

*&---------------------------------------------------------------------*
*&      Form  rellenar_layout
*&---------------------------------------------------------------------*
FORM rellenar_layout .

  is_layout-totals_bef = 'X'.
  is_layout-sel_mode   = 'D'.
  is_layout-zebra      = 'X'.

ENDFORM.                    " rellenar_layout

*&---------------------------------------------------------------------*
*&      Form  rellenar_toolbar_excl
*&---------------------------------------------------------------------*
FORM rellenar_toolbar_excl.

  DATA: l_toolbar TYPE ui_functions WITH HEADER LINE.

  REFRESH: t_toolbar_excl.

  CLEAR: l_toolbar.

  l_toolbar = '&CHECK'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&CUT'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&COPY'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&PASTE'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&PASTE_NEW_ROW'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&UNDO'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&&SEP02'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&APPEND'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&INSERT_ROW'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&DELETE_ROW'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&LOCAL&COPY_ROW'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&&SEP03'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&&SEP07'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&INFO'.
  APPEND l_toolbar TO t_toolbar_excl.
  l_toolbar = '&GRAPH'.
  APPEND l_toolbar TO t_toolbar_excl.

ENDFORM.                    " rellenar_toolbar_excl

*&---------------------------------------------------------------------*
*&      Form  calcular_totales
*&---------------------------------------------------------------------*
*       Recorre tablas internas, calculando totales
*----------------------------------------------------------------------*
FORM calcular_totales .

  CLEAR: movs_banco, movs_previ, desviacion, tcomp1, tcomp1[], tcomp2, tcomp2[],
         et_index_rows1[], et_index_rows2[].

* OBtener líneas seleccionadas grid1
  CALL METHOD grid1->get_selected_rows
    IMPORTING
      et_index_rows = et_index_rows1
      et_row_no     = et_row_no1.

* Recorremos las líneas seleccionadas en el grid1
  LOOP AT et_index_rows1 INTO l_index_rows1.
    READ TABLE tdatos1 INDEX l_index_rows1-index.

    IF mon_local = 'X'.
      ADD tdatos1-dmbtr TO movs_banco.
    ELSE.
      ADD tdatos1-wrbtr TO movs_banco.
    ENDIF.

    MOVE-CORRESPONDING tdatos1 TO tcomp1.
    APPEND tcomp1.
  ENDLOOP.

* obtener líneas seleccionadas grid2
  CALL METHOD grid2->get_selected_rows
    IMPORTING
      et_index_rows = et_index_rows2
      et_row_no     = et_row_no2.
* recorremos las líneas seleccionadas en el grid2
  LOOP AT et_index_rows2 INTO l_index_rows2.
    READ TABLE tdatos2 INDEX l_index_rows2-index.
    IF mon_local = 'X'.
      ADD tdatos2-dmbtr TO movs_previ.
    ELSE.
      ADD tdatos2-wrbtr TO movs_previ.
    ENDIF.
    MOVE-CORRESPONDING tdatos2 TO tcomp2.
    APPEND tcomp2.
  ENDLOOP.

  desviacion = movs_banco + movs_previ.

ENDFORM.                    " calcular_totales
*&---------------------------------------------------------------------*
*&      Form  compensar
*&---------------------------------------------------------------------*
*       Si los importes cuadran, hace la compensación
*----------------------------------------------------------------------*
FORM compensar .
* Tabla interna donde guardamos los documentos compensados
  DATA: t_compensados LIKE zsfit308_a OCCURS 0 WITH HEADER LINE.

  DATA: blntab  TYPE blntab OCCURS 0 WITH HEADER LINE,
        ftclear TYPE ftclear OCCURS 0 WITH HEADER LINE,
        ftpost  TYPE ftpost OCCURS 0 WITH HEADER LINE,
        fttax   TYPE fttax OCCURS 0 WITH HEADER LINE,
        auglv   LIKE t041a-auglv.

  DATA l_group LIKE apqi-groupid VALUE 'FB05'.
  DATA l_datum(10).

* Define para rellenar ftpost (aquí se indican los campos a pasar al batch input)
  DEFINE rellena_ftpost.
    ftpost-stype = &1.
    ftpost-count = &2.
    ftpost-fnam  = &3.
    ftpost-fval  = &4.
    append ftpost.
  END-OF-DEFINITION.

* Define para rellenar ftclear (aquí se pasan los datos)
  DEFINE rellena_ftclear.
    select single *
      from bseg
     where belnr = &1
       and bukrs = &2
       and gjahr = &3
       and buzei = &4.
    ftclear-agkoa = bseg-koart.
    ftclear-agbuk = bseg-bukrs.
    ftclear-selfd = 'BELNR'.
    if bseg-umskz is initial.
      ftclear-xnops = 'X'.
    else.
      ftclear-agums = bseg-umskz.
    endif.
    concatenate bseg-belnr
                bseg-gjahr
                bseg-buzei
           into ftclear-selvon.
    append ftclear.

  END-OF-DEFINITION.

  DATA: i_mode LIKE rfpdo-allgazmd.
  i_mode = 'E'.
  DATA: mon_doc TYPE waers.
******* Recorrer tablas internas rellenando las de las funciones
* Rellenar tablas a pasar al módulo de funciones a partir de las líneas seleccionadas
  LOOP AT tcomp1.
    rellena_ftclear tcomp1-belnr
                    tcomp1-bukrs
                    tcomp1-gjahr
                    tcomp1-buzei.
    MOVE-CORRESPONDING tcomp1 TO t_compensados.
    APPEND t_compensados.
  ENDLOOP.
  LOOP AT tcomp2.
    mon_doc = tcomp2-waers.
    rellena_ftclear tcomp2-belnr
                    tcomp2-bukrs
                    tcomp2-gjahr
                    tcomp2-buzei.
    MOVE-CORRESPONDING tcomp2 TO t_compensados.
    APPEND t_compensados.
  ENDLOOP.

  rellena_ftpost 'K' 1 'BKPF-BUKRS' p_bukrs.
  IF cont_auxi = 'X'.
    rellena_ftpost 'K' 1 'BKPF-BLART' 'SA'.
  ELSE.
    rellena_ftpost 'K' 1 'BKPF-BLART' 'SA'.
  ENDIF.
  WRITE fecha_com TO l_datum.
  rellena_ftpost 'K' 1 'BKPF-BLDAT' l_datum.
  rellena_ftpost 'K' 1 'BKPF-BUDAT' l_datum.

  DATA l_moneda TYPE waerk.
  "l_moneda = 'EUR'.
  "Paso la moneda del banco propio
  IF mon_local = 'X'.
    SELECT SINGLE waers INTO l_moneda FROM t012k
      WHERE bukrs = p_bukrs
        AND hbkid = p_banco.
  ELSE.
    "Moneda del documento
    l_moneda = mon_doc.
  ENDIF.

  rellena_ftpost 'K' 1 'BKPF-WAERS' l_moneda."'EUR'.

  IF desviacion IS NOT INITIAL.
    DATA: importe_gasto(20).
    WRITE desviacion TO importe_gasto.
    CONDENSE importe_gasto NO-GAPS.
    rellena_ftpost 'P' 1 'RF05A-NEWKO' cuenta2.
    IF desviacion < 0.
      rellena_ftpost 'P' 1 'RF05A-NEWBS'    '50'.
    ELSE.
      rellena_ftpost 'P' 1 'RF05A-NEWBS'    '40'.
    ENDIF.
    REPLACE ALL OCCURRENCES OF '-' IN importe_gasto WITH space.
    CONDENSE importe_gasto NO-GAPS.
    rellena_ftpost 'P' 1 'BSEG-WRBTR'  importe_gasto       .
    rellena_ftpost 'P' 1 'BSEG-SGTXT'  'Posición de Gastos'.
    rellena_ftpost 'P' 1 'COBL-KOSTL' kostl.
  ENDIF.
  "Rellenamos la orden
  IF aufnr IS NOT INITIAL.
    rellena_ftpost 'P' 1 'COBL-AUFNR' aufnr."COBL-AUFNR
  ENDIF.

  IF cont_auxi = 'X'.
    rellena_ftpost 'K' 6 'BDC_OKCODE' '=AKZP'.
  ENDIF.


  IF cont_auxi = 'X'.
    auglv = 'UMBUCHNG'. "Traslado con compensación
  ELSE.
    auglv = 'EINGZAHL'. "Entrada de Pagos
  ENDIF.
************ LLAMADA A FUNCIONES ********************
****** Rellenar características del batch input
  CALL FUNCTION 'POSTING_INTERFACE_START'
    EXPORTING
      i_client           = sy-mandt
      i_function         = 'C'    " Using Call Transaction
      i_group            = l_group
      i_mode             = i_mode
      i_update           = 'S'
      i_user             = sy-uname
      i_xbdcc            = 'X'
    EXCEPTIONS
      client_incorrect   = 1
      function_invalid   = 2
      group_name_missing = 3
      mode_invalid       = 4
      update_invalid     = 5
      OTHERS             = 6.

****** Compensar
  CALL FUNCTION 'POSTING_INTERFACE_CLEARING'
    EXPORTING
      i_auglv                    = auglv
      i_tcode                    = 'FB05'
    IMPORTING
      e_msgid                    = sy-msgid
      e_msgno                    = sy-msgno
      e_msgty                    = sy-msgty
      e_msgv1                    = sy-msgv1
      e_msgv2                    = sy-msgv2
      e_msgv3                    = sy-msgv3
      e_msgv4                    = sy-msgv4
    TABLES
      t_blntab                   = blntab
      t_ftclear                  = ftclear
      t_ftpost                   = ftpost
      t_fttax                    = fttax
    EXCEPTIONS
      clearing_procedure_invalid = 1
      clearing_procedure_missing = 2
      table_t041a_empty          = 3
      transaction_code_invalid   = 4
      amount_format_error        = 5
      too_many_line_items        = 6
      company_code_invalid       = 7
      screen_not_found           = 8
      no_authorization           = 9
      OTHERS                     = 10.

****** Acabar el proceso
  CALL FUNCTION 'POSTING_INTERFACE_END'
    EXPORTING
      i_bdcimmed              = 'X'
    EXCEPTIONS
      session_not_processable = 1
      OTHERS                  = 2.

*********** Finalizar Batch Input para contabilidad Auxiliar
* Si se compensa bien, guardamos los documentos con su doc de compensación en la tabla zgfi_404
  READ TABLE blntab INDEX 1.
  IF sy-subrc IS INITIAL.
    LOOP AT t_compensados.
      t_compensados-augbl = blntab-belnr.
      t_compensados-augdt = fecha_com.
      t_compensados-uname = sy-uname.
      t_compensados-moddate = sy-datum.
      t_compensados-modtime = sy-uzeit.
      MOVE-CORRESPONDING t_compensados TO zsfit308_a.
      MODIFY zsfit308_a.
    ENDLOOP.
    SET PARAMETER ID 'BUK' FIELD blntab-bukrs.
    SET PARAMETER ID 'BLN' FIELD blntab-belnr.
    SET PARAMETER ID 'GJR' FIELD blntab-gjahr.
  ENDIF.

* Limpiar tablas de líneas seleccionadas
  CLEAR: tcomp1, tcomp1[], tcomp2, tcomp2[].

* Refrescar pantalla
  PERFORM refrescar.

ENDFORM.                    " contabilizar

*&---------------------------------------------------------------------*
*&      Form  seleccion_automatica
*&---------------------------------------------------------------------*
*       Comprueba parámetros introducidos y recorre las tablas internas
*       borrando las líneas que no los cumplen
*----------------------------------------------------------------------*
FORM seleccion_automatica USING fech_val TYPE dats
                                fech_ope TYPE dats
                                import   LIKE zsfis308_b-dmbtr
                                txt      LIKE zsfis308_b-sgtxt
                                tipo     TYPE c.
  REFRESH: et_index_rows1, et_index_rows2.
  DATA: importe_neg LIKE importe.
  importe_neg = - import.

  CHECK fech_val IS NOT INITIAL OR fech_ope IS NOT INITIAL OR import IS NOT INITIAL OR txt IS  NOT INITIAL OR tipo <> 'B' .

* Fecha valor
  IF fech_val IS NOT INITIAL.
    LOOP AT tdatos1 WHERE valut <> fech_val.
      DELETE tdatos1.
    ENDLOOP.
    LOOP AT tdatos2 WHERE valut <> fech_val.
      DELETE tdatos2.
    ENDLOOP.
  ENDIF.
* Fecha operación
  IF fech_ope IS NOT INITIAL.
    LOOP AT tdatos1 WHERE budat <> fech_ope.
      DELETE tdatos1.
    ENDLOOP.
    LOOP AT tdatos2 WHERE budat <> fech_ope.
      DELETE tdatos2.
    ENDLOOP.
  ENDIF.
* Importe
  IF import IS NOT INITIAL AND import <> 0.
    IF mon_local = 'X'.
      LOOP AT tdatos1 WHERE dmbtr <> import."dmbtr <> import.
        DELETE tdatos1.
      ENDLOOP.
      LOOP AT tdatos2 WHERE dmbtr <> importe_neg."dmbtr <> importe_neg.
        DELETE tdatos2.
      ENDLOOP.
    ELSE.
      LOOP AT tdatos1 WHERE wrbtr <> import."dmbtr <> import.
        DELETE tdatos1.
      ENDLOOP.
      LOOP AT tdatos2 WHERE wrbtr <> importe_neg."dmbtr <> importe_neg.
        DELETE tdatos2.
      ENDLOOP.
    ENDIF.
  ENDIF.
* TEXTO
  IF txt IS NOT INITIAL OR tipo = 'H'.
    IF txt CA '*'.
      REPLACE ALL OCCURRENCES OF '*' IN txt WITH space.
*    CONDENSE txt NO-GAPS.
      LOOP AT tdatos1.
        IF tdatos1-sgtxt CS txt.
        ELSE.
          DELETE tdatos1.
        ENDIF.
      ENDLOOP.
      LOOP AT tdatos2.
        IF tdatos2-sgtxt CS txt.
        ELSE.
          DELETE tdatos2.
        ENDIF.
      ENDLOOP.
    ELSE.
      LOOP AT tdatos1.
        IF tdatos1-sgtxt = txt.
        ELSE.
          DELETE tdatos1.
        ENDIF.
      ENDLOOP.
      LOOP AT tdatos2.
        IF tdatos2-sgtxt = txt.
        ELSE.
          DELETE tdatos2.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

** Refrescar
  CALL METHOD grid1->refresh_table_display.
  CALL METHOD grid2->refresh_table_display.

** Recorrer tablas marcando líneas
  DATA: wa_index_row LIKE LINE OF et_index_rows1.
  LOOP AT tdatos1.
    wa_index_row-index = sy-tabix.
    APPEND wa_index_row TO et_index_rows1.
  ENDLOOP.
  LOOP AT tdatos2.
    wa_index_row-index = sy-tabix.
    APPEND wa_index_row TO et_index_rows2.
  ENDLOOP.

  CALL METHOD grid1->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows1
      it_row_no     = et_row_no1.
  CALL METHOD grid2->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows2
      it_row_no     = et_row_no2.

* Calculamos totales y si hay desviación se desmarcan las líneas
  PERFORM calcular_totales.
  IF desviacion <> 0.
    CLEAR: et_index_rows1, et_index_rows1[], et_index_rows2, et_index_rows2[].
    CALL METHOD grid1->refresh_table_display.
    CALL METHOD grid2->refresh_table_display.
  ENDIF.

ENDFORM.                    " seleccion_automatica

*&---------------------------------------------------------------------*
*&      Form  refrescar
*&---------------------------------------------------------------------*
FORM refrescar .
  REFRESH tavisos.
  PERFORM recoger_datos1.
* Si estamos en contabilidad auxiliar cambiamos la 2ª tabla por las PAs
  IF cont_auxi = 'X'.
    PERFORM obtener_pas USING space.
  ENDIF.
  PERFORM mostrar_datos1.
  PERFORM mostrar_datos2.
  PERFORM calcular_totales.

  REFRESH: et_index_rows1, et_index_rows2.

* DESMarcar las líneas
  CALL METHOD grid1->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows1
      it_row_no     = et_row_no1.
  CALL METHOD grid2->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows2
      it_row_no     = et_row_no2.

  CALL METHOD grid1->refresh_table_display.
  CALL METHOD grid2->refresh_table_display.
ENDFORM.                    " refrescar

*&---------------------------------------------------------------------*
*&      Form  obtener_avisos_tesorería
*&---------------------------------------------------------------------*
*       Obtener avisos de tesorería abiertos
*----------------------------------------------------------------------*
FORM obtener_avisos_tesoreria .
* Obtener líneas marcadas
  CLEAR: et_index_rows_avi[], et_index_rows1[], tavisos, tclasedoc, tavisos[], tclasedoc[], zsfit308_b.

* OBtener líneas seleccionadas grid1
  CALL METHOD grid1->get_selected_rows
    IMPORTING
      et_index_rows = et_index_rows1
      et_row_no     = et_row_no1.

* Recorremos tabla con las líneas marcadas en el grid1
  LOOP AT et_index_rows1 INTO l_index_rows1.
    READ TABLE tdatos1 INDEX l_index_rows1-index.

* Obtener relación entre la clase de documento y la clase de doc de tesorería
    SELECT SINGLE * FROM zsfit308_b
    WHERE bukrs = tdatos1-bukrs AND
          blart = tdatos1-blart.

* Añadir entradas a tabla interna de clases de documento
    MOVE-CORRESPONDING zsfit308_b TO tclasedoc.
    tclasedoc-importe = abs( tdatos1-dmbtr ).
    tclasedoc-shkzg   = tdatos1-shkzg.
    COLLECT tclasedoc.

* Obtener avisos de la clase obtenida
    SELECT * APPENDING CORRESPONDING FIELDS OF TABLE tavisos
    FROM fdes
    WHERE bukrs = zsfit308_b-bukrs AND
          dsart = zsfit308_b-dsart AND
          archk = ' '.
  ENDLOOP.

* Recorremos tabla comprobando el banco propio (en el campo bnkko. Este campo llevará siempre una T seguida del banco propio
* y luego un espacio, para que la búsqueda vaya bien, ya puede haber bancos de 4 y de 5 posiciones)
  LOOP AT tavisos.
    IF tavisos-bnkko+1(5) CS p_banco.
      tavisos-moneda = tdatos1-mon_local.
      MODIFY tavisos.
    ELSE.
      DELETE tavisos.
    ENDIF.
  ENDLOOP.

  SORT tavisos.
  DELETE ADJACENT DUPLICATES FROM tavisos.

ENDFORM.                    " obtener_avisos_tesorería

*&---------------------------------------------------------------------*
*&      Form  mostrar_avisos
*&---------------------------------------------------------------------*
FORM mostrar_avisos .

* Inicializamos campos de cabecera a mostrar en pantalla.
  PERFORM rellenar_fieldcat_avi.
* Inicializamos formato de salida
  PERFORM rellenar_layout.
* Eliminamos botones
  PERFORM rellenar_toolbar_excl.

  CALL METHOD grid_avi->set_table_for_first_display
    EXPORTING
      i_structure_name     = 'ZSFIS308_C'
      is_layout            = is_layout
      it_toolbar_excluding = t_toolbar_excl
      is_variant           = is_variant3
      i_save               = x_save
      i_default            = 'X'
    CHANGING
      it_outtab            = tavisos[]
      it_fieldcatalog      = it_fieldcat_avi[]
      it_sort              = it_sort.

  SET HANDLER g_application->handle_toolbar        FOR grid_avi.
  SET HANDLER g_application->handle_user_command   FOR grid_avi.

  CALL METHOD grid_avi->set_toolbar_interactive.

ENDFORM.                    " mostrar_avisos

*&---------------------------------------------------------------------*
*&      Form  rellenar_fieldcat_avi
*&---------------------------------------------------------------------*
FORM rellenar_fieldcat_avi.

  DATA h_fieldcat_wa TYPE slis_fieldcat_alv.
  DATA h_index LIKE sy-tabix.

  REFRESH g_fieldcat_tab_avi.
  REFRESH it_fieldcat_avi.

  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = g_repid
      i_internal_tabname     = 'TAVISOS'
      i_structure_name       = 'ZSFIS308_C'
      i_client_never_display = ' '
    CHANGING
      ct_fieldcat            = g_fieldcat_tab_avi[]
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  LOOP AT g_fieldcat_tab_avi.
    CASE g_fieldcat_tab_avi-fieldname.
      WHEN 'IDENR'.
        MODIFY g_fieldcat_tab_avi.
        MOVE-CORRESPONDING g_fieldcat_tab_avi TO it_fieldcat_avi.
        APPEND it_fieldcat_avi. CLEAR it_fieldcat_avi.
        CLEAR g_fieldcat_tab_avi.
      WHEN 'DMSHB'.
        MODIFY g_fieldcat_tab_avi.
        MOVE-CORRESPONDING g_fieldcat_tab_avi TO it_fieldcat_avi.
        it_fieldcat_avi-coltext = 'Importe'.
        APPEND it_fieldcat_avi. CLEAR it_fieldcat_avi.
        CLEAR g_fieldcat_tab_avi.
      WHEN 'ARCHIVAR'.
        MODIFY g_fieldcat_tab_avi.
        MOVE-CORRESPONDING g_fieldcat_tab_avi TO it_fieldcat_avi.
        it_fieldcat_avi-coltext = 'Archivar sin comprobar importe'.
        it_fieldcat_avi-checkbox = 'X'.
        it_fieldcat_avi-edit = 'X'.
        APPEND it_fieldcat_avi. CLEAR it_fieldcat_avi.
        CLEAR g_fieldcat_tab_avi.
    ENDCASE.

  ENDLOOP.
  REFRESH g_fieldcat_tab_avi.

ENDFORM.                    " rellenar_fieldcat_Avi

*&---------------------------------------------------------------------*
*&      Form  recorrer_avisos
*&---------------------------------------------------------------------*
*       Recorre los avisos seleccionados modificándolos y
*       restando importes
*----------------------------------------------------------------------*
FORM recorrer_avisos .
  DATA: wa_aviso    LIKE LINE OF tavisos,
        wa_clasedoc LIKE LINE OF tclasedoc,
        fallo       TYPE         c. "para saber si el importe del aviso se ha modificado bien

  CALL METHOD grid_avi->check_changed_data.

* Valor absoluto del importe
  DATA: imp_abs TYPE bp_wgl.
* Obtener líneas marcadas
  CLEAR: et_index_rows_avi[], et_index_rows1[].

* En importe_rest tendremos el importe que nos queda del total
  importe_rest = movs_banco.

* OBtener líneas seleccionadas grid1
  CALL METHOD grid_avi->get_selected_rows
    IMPORTING
      et_index_rows = et_index_rows_avi
      et_row_no     = et_row_no_avi.

* Recorremos tabla con las líneas marcadas en el grid_avi
  LOOP AT et_index_rows_avi INTO l_index_rows_avi.
* Leemos el aviso
    READ TABLE tavisos INDEX l_index_rows_avi-index INTO wa_aviso.
    CHECK wa_aviso-archivar = ' '.
* Leemos la tabla con importe restante para el tipo de aviso, para el indicador debe/haber que tocque
    IF wa_aviso-dmshb < 0.
      READ TABLE tclasedoc WITH KEY dsart = wa_aviso-dsart shkzg = 'H' INTO wa_clasedoc.
      CHECK sy-subrc = 0.
    ELSE.
      READ TABLE tclasedoc WITH KEY dsart = wa_aviso-dsart shkzg = 'S' INTO wa_clasedoc.
      CHECK sy-subrc = 0.
    ENDIF.
*Transformamos el importe a valor absoluto
    imp_abs = abs( wa_aviso-dmshb ).
* Si el importe es menor o igual, se clasifica el aviso
    IF imp_abs <= wa_clasedoc-importe.
      PERFORM archivar_aviso USING wa_aviso CHANGING fallo.
      IF fallo = ' '.
        wa_clasedoc-importe = wa_clasedoc-importe - imp_abs.
        READ TABLE tclasedoc WITH KEY dsart = wa_aviso-dsart.
        MODIFY tclasedoc FROM wa_clasedoc INDEX sy-tabix. "establecer nuevo importe restante
      ENDIF.
    ELSE.
* Si es mayor, se reduce su importe
      IF wa_aviso-dmshb < 0.
        wa_aviso-dmshb = wa_aviso-dmshb + wa_clasedoc-importe.
        wa_aviso-wrshb = wa_aviso-wrshb + wa_clasedoc-importe.
      ELSE.
        wa_aviso-dmshb = wa_aviso-dmshb - wa_clasedoc-importe.
        wa_aviso-wrshb = wa_aviso-wrshb - wa_clasedoc-importe.
        PERFORM reducir_importe_aviso USING wa_aviso CHANGING fallo.
      ENDIF.
      IF fallo = ' '.
        wa_clasedoc-importe = 0.
        READ TABLE tclasedoc WITH KEY dsart = wa_aviso-dsart.
        MODIFY tclasedoc FROM wa_clasedoc INDEX sy-tabix. "establecer nuevo importe restante
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " recorrer_avisos

*&---------------------------------------------------------------------*
*&      Form  archivar_aviso
*&---------------------------------------------------------------------*
*       llama a la bapi de cancelar avisos
*----------------------------------------------------------------------*
FORM archivar_aviso USING wa_aviso STRUCTURE zsfis308_c
                    CHANGING fallo.
  DATA: xfdes LIKE fdes.
  DATA: tab_fdesdist LIKE fdesdist  OCCURS 0  WITH HEADER LINE.

  SELECT SINGLE * INTO xfdes FROM  fdes CLIENT SPECIFIED
         WHERE  mandt  = sy-mandt
         AND    bukrs  = p_bukrs
         AND    idenr  = wa_aviso-idenr.

  CLEAR: tab_fdesdist. REFRESH: tab_fdesdist.
  MOVE-CORRESPONDING xfdes TO tab_fdesdist. APPEND tab_fdesdist.

  tab_fdesdist-archk = 'A'.
  tab_fdesdist-aenus = sy-uname.
  tab_fdesdist-aendt = sy-datum.
  tab_fdesdist-avdat = sy-datum. APPEND tab_fdesdist.

  CALL FUNCTION 'CASH_FORECAST_MEMO_RECORD_UPD'
    EXPORTING
      aktion       = '2'
    TABLES
      tab_fdesdist = tab_fdesdist.
  COMMIT WORK.

* Comprobamos que se ha archivado el aviso...
  SELECT SINGLE * INTO xfdes FROM  fdes CLIENT SPECIFIED
         WHERE  mandt  = sy-mandt
         AND    archk  = 'A'
         AND    bukrs  = p_bukrs
         AND    idenr  = wa_aviso-idenr.
  IF sy-subrc <> 0.
    fallo = 'X'.
  ENDIF.
ENDFORM.                    " archivar_aviso

*&---------------------------------------------------------------------*
*&      Form  reducir_importe_aviso
*&---------------------------------------------------------------------*
*       Reduce el importe de un aviso, para ello archiva el existente
*       y crea uno nuevo con el nuevo importe
*----------------------------------------------------------------------*
FORM reducir_importe_aviso USING wa_aviso STRUCTURE zsfis308_c CHANGING fallo.
  DATA: xfdes     LIKE fdes,
        xfdes_ant LIKE fdes.   " para guardar lo anterior.
* Obtenemos datos originales del aviso para poder crear uno igual
  SELECT SINGLE * INTO xfdes FROM  fdes CLIENT SPECIFIED
         WHERE  mandt  = sy-mandt
         AND    bukrs  = p_bukrs
         AND    idenr  = wa_aviso-idenr.
* Modificar importes
  xfdes-dmshb = wa_aviso-dmshb.
  xfdes-wrshb = wa_aviso-wrshb.
* Se archiva el aviso
  PERFORM archivar_aviso USING wa_aviso CHANGING fallo.
* Si se ha archivado bien, se crea el nuevo
  IF fallo = ' '.
    PERFORM crear_aviso USING xfdes CHANGING fallo.
  ENDIF.

ENDFORM.                    " reducir_importe_Aviso

*&---------------------------------------------------------------------*
*&      Form  crear_aviso
*&---------------------------------------------------------------------*
FORM crear_aviso USING xfdes STRUCTURE fdes CHANGING fallo.

  DATA: cdmbtr(15) TYPE c,
        cwrbtr(15) TYPE c,
        fecha(10).
  DATA BEGIN OF itab OCCURS 10.
          INCLUDE STRUCTURE bdcmsgcoll.
  DATA END OF itab.

  WRITE xfdes-dmshb       TO cdmbtr.
  WRITE xfdes-wrshb       TO cwrbtr.
  WRITE xfdes-datum       TO fecha.

  CLEAR bdc_tab.
  REFRESH bdc_tab.

  PERFORM bdc_dynpro      USING 'SAPMF40E'   '0100'.
  PERFORM bdc_field       USING 'BDC_CURSOR' 'FDES-BUKRS'.
  PERFORM bdc_field       USING 'BDC_OKCODE' '=ONE'.
  PERFORM bdc_field       USING 'FDES-BUKRS' xfdes-bukrs.
  PERFORM bdc_field       USING 'FDES-DSART' xfdes-dsart.

  PERFORM bdc_dynpro      USING 'SAPMF40E'    '0101'.
  PERFORM bdc_field       USING 'BDC_OKCODE'  '=UPD'.
  PERFORM bdc_field       USING 'FDES-DATUM'  fecha.
  PERFORM bdc_field       USING 'RF40L-DISKB' xfdes-bnkko.
  PERFORM bdc_field       USING 'FDES-WRSHB'  cdmbtr. "Importe
  PERFORM bdc_field       USING 'FDES-DISPW'  xfdes-dispw.
*  IF xfdes-pswsl NE waers.
  PERFORM bdc_field       USING 'FDES-WRSHB'  cwrbtr. "Importe
  PERFORM bdc_field       USING 'FDES-DISPW'  xfdes-dispw.
*  PERFORM bdc_field       USING 'RF40L-KURSF' xfdes-kursf.
  PERFORM bdc_field       USING 'FDES-DMSHB'  cdmbtr. "Importe ML
*    PERFORM bdc_field       USING 'T001-WAERS'  vwaers.
*  ENDIF.
  PERFORM bdc_field       USING 'FDES-ZUONR'  xfdes-zuonr.
  PERFORM bdc_field       USING 'FDES-MERKM'  xfdes-merkm.
*  PERFORM bdc_field       USING 'FDES-AUSTG'  xfdes-austg.
  PERFORM bdc_field       USING 'FDES-SGTXT'  xfdes-sgtxt.

  CALL TRANSACTION 'FF63' USING bdc_tab
                          MODE  'E'
                          MESSAGES INTO itab
                          UPDATE 'S'.

  IF sy-subrc NE 0.
    WRITE:/ 'No se ha creado el nuevo aviso para el aviso:', xfdes-idenr.
    fallo = 'X'.
  ENDIF.

ENDFORM.                    " crear_aviso

*&---------------------------------------------------------------------*
*&      Form  filtrar_importes
*&---------------------------------------------------------------------*
*       Filtrar importes en las 2 tablas
*----------------------------------------------------------------------*
FORM filtrar_importes .
  DATA: indice1 LIKE sy-tabix,
        indice2 LIKE sy-tabix.

  DATA: BEGIN OF taux1 OCCURS 0.
          INCLUDE STRUCTURE zsfis308_b.
  DATA: flag TYPE c.
  DATA: END OF taux1.

  DATA: BEGIN OF taux2 OCCURS 0.
          INCLUDE STRUCTURE zsfis308_b.
  DATA: flag TYPE c.
  DATA: END OF taux2.

  DATA: waux1 LIKE LINE OF taux1,
        waux2 LIKE LINE OF taux2.

  DATA: importe_neg LIKE zsfis308_b-dmbtr.

  DATA: wa_index_row LIKE LINE OF et_index_rows1.

  CLEAR: taux1, taux1[], taux2, taux2[], et_index_rows1, et_index_rows1[], et_index_rows2, et_index_rows2[].

* Pasar datos a tablas auxiliares
  LOOP AT tdatos1.
    MOVE-CORRESPONDING tdatos1 TO taux1.
    APPEND taux1.
  ENDLOOP.

  LOOP AT tdatos2.
    MOVE-CORRESPONDING tdatos2 TO taux2.
    APPEND taux2.
  ENDLOOP.

  REFRESH: tdatos1, tdatos2.

* Recorrer tabla de un lado y buscando importes en el otro
  LOOP AT taux1 INTO waux1.
    indice1 = sy-tabix.
    IF mon_local = 'X'.
      importe_neg = - waux1-dmbtr.
    ELSE.
      importe_neg = - waux1-wrbtr."waux1-dmbtr.
    ENDIF.
* Si tienen rellena la relación de clases de doc para el banco propio
    IF t_reldocs[] IS NOT INITIAL.
      READ TABLE t_reldocs WITH KEY blart_int = waux1-blart.
      IF sy-subrc = 0.
        IF mon_local = 'X'.
          READ TABLE taux2 INTO waux2 WITH KEY dmbtr = importe_neg flag = ' ' blart = t_reldocs-blart_ext."dmbtr
          IF sy-subrc = 0.
            indice2 = sy-tabix.
            waux2-flag = 'X'.
            MODIFY taux2 FROM waux2 INDEX indice2.
            MOVE-CORRESPONDING waux1 TO tdatos1.
            APPEND tdatos1.
            MOVE-CORRESPONDING waux2 TO tdatos2.
            APPEND tdatos2.
          ENDIF.
        ELSE.
          READ TABLE taux2 INTO waux2 WITH KEY wrbtr = importe_neg flag = ' ' blart = t_reldocs-blart_ext."dmbtr
          IF sy-subrc = 0.
            indice2 = sy-tabix.
            waux2-flag = 'X'.
            MODIFY taux2 FROM waux2 INDEX indice2.
            MOVE-CORRESPONDING waux1 TO tdatos1.
            APPEND tdatos1.
            MOVE-CORRESPONDING waux2 TO tdatos2.
            APPEND tdatos2.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
* Si no tienen rellena la relación, sólo se tiene en cuenta el importe
      IF mon_local = 'X'.
        READ TABLE taux2 INTO waux2 WITH KEY dmbtr = importe_neg flag = ' '."dmbtr = importe_neg flag = ' '.
        IF sy-subrc = 0.
          indice2 = sy-tabix.
          waux2-flag = 'X'.
          MODIFY taux2 FROM waux2 INDEX indice2.
          MOVE-CORRESPONDING waux1 TO tdatos1.
          APPEND tdatos1.
          MOVE-CORRESPONDING waux2 TO tdatos2.
          APPEND tdatos2.
        ENDIF.
      ELSE.
        READ TABLE taux2 INTO waux2 WITH KEY wrbtr = importe_neg flag = ' '."dmbtr = importe_neg flag = ' '.
        IF sy-subrc = 0.
          indice2 = sy-tabix.
          waux2-flag = 'X'.
          MODIFY taux2 FROM waux2 INDEX indice2.
          MOVE-CORRESPONDING waux1 TO tdatos1.
          APPEND tdatos1.
          MOVE-CORRESPONDING waux2 TO tdatos2.
          APPEND tdatos2.
        ENDIF.
      ENDIF.
    ENDIF.

* Marcar como tratado
    taux1-flag = 'X'.
    MODIFY taux1 FROM waux1 INDEX indice1.
  ENDLOOP.

  REFRESH: et_index_rows1, et_index_rows2.
  IF mon_local = 'X'.
    SORT tdatos1 BY dmbtr.
    SORT tdatos2 BY dmbtr DESCENDING.
  ELSE.
    SORT tdatos1 BY wrbtr."dmbtr.
    SORT tdatos2 BY wrbtr DESCENDING."dmbtr DESCENDING.
  ENDIF.
  LOOP AT tdatos1.
    wa_index_row-index = sy-tabix.
    APPEND wa_index_row TO et_index_rows1.
    APPEND wa_index_row TO et_index_rows2.
  ENDLOOP.

** Establecer líneas marcadas
  CALL METHOD grid1->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows1
      it_row_no     = et_row_no1.
  CALL METHOD grid2->set_selected_rows
    EXPORTING
      it_index_rows = et_index_rows2
      it_row_no     = et_row_no2.

  IF et_index_rows2[] IS INITIAL.
*    MESSAGE i000 WITH 'No existen registros que cumplan las condiciones'.
    MESSAGE i005(zsfi308) . " 'No existen registros que cumplan las condiciones
  ENDIF.

  PERFORM mostrar_datos1.
  PERFORM mostrar_datos2.

ENDFORM.                    " filtrar_importes

*&---------------------------------------------------------------------*
*&      Form  imprimir
*&---------------------------------------------------------------------*
FORM imprimir.

* OBtener datos hasta fecha indicada
* Obtener datos de la BSIS
  CLEAR: tform1[], tform2[].
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE tform1
  FROM bsis
  WHERE bukrs = p_bukrs AND
        hkont IN r_hkont AND
        budat <= fecha_form.

* Obtener datos de la BSAS
* Permiet obtener las partidas abiertas a la fecha del extracto
  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE tform1
  FROM bsas
  WHERE bukrs = p_bukrs AND
        hkont IN r_hkont AND
        budat <= fecha_form AND
        augdt > fecha_form.

* Recorremos la tabla. Los docs. cuya clase sea un numérico se quedan en el 1er alv
* el resto los pasamos al 2º
  LOOP AT tform1.
    moneda = tform1-waers.

* Obtener moneda de la sociedad para moneda local
    SELECT SINGLE waers INTO tform1-mon_local FROM t001
    WHERE bukrs = tform1-bukrs.

* Poner signo al importe
    IF tform1-shkzg = 'H'.
      tform1-dmbtr = - tform1-dmbtr.
      tform1-wrbtr = - tform1-wrbtr.
    ENDIF.
* Obtener denominación de la clase de doc.
    SELECT SINGLE ltext INTO tform1-ltext FROM t003t
    WHERE blart = tform1-blart AND
          spras = 'S'.

    IF tform1-blart = 'EA' OR tform1-blart =  'EC' OR tform1-blart = 'ED' OR tform1-blart = 'EF' OR tform1-blart = 'EI' OR tform1-blart = 'EJ' OR tform1-blart ='EL' OR tform1-blart = 'EN' OR tform1-blart = 'ER'
      OR tform1-blart = 'ET' OR tform1-blart = 'EU' OR tform1-blart = 'EX' OR tform1-blart = 'EY'.
      MODIFY tform1.
    ELSE.
      MOVE-CORRESPONDING tform1 TO tform2.
      APPEND tform2.
      DELETE tform1.
    ENDIF.
  ENDLOOP.

  DATA: funcion TYPE rs38l_fnam.

  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
    EXPORTING
      formname = 'ZSFI308_FORM'
    IMPORTING
      fm_name  = funcion.

*** Borrar entradas en tabla cuya fecha de contabilización sea mayor que la de pantalla
  DELETE tform1 WHERE budat > fecha_form.
  DELETE tform2 WHERE budat > fecha_form.

  CALL FUNCTION funcion
    EXPORTING
      fecha_fin        = fecha_form
      titulo           = title
      cuenta           = cuenta
      bukrs            = p_bukrs
      hbkid            = p_banco
    TABLES
      tdatos1          = tform1
      tdatos2          = tform2
    EXCEPTIONS
      formatting_error = 1
      internal_error   = 2
      send_error       = 3
      user_canceled    = 4
      OTHERS           = 5.
* Si se produce un error, reportarlo.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  PERFORM refrescar.
ENDFORM.                    " imprimir

*&---------------------------------------------------------------------*
*&      Form  crear_rangos_pas
*&---------------------------------------------------------------------*
FORM crear_rangos_pas.

  CLEAR: raux_agums[], raux_agums, raux_aviso, raux_aviso[].

  IF caux_agums IS NOT INITIAL.
    raux_agums-low  = caux_agums.
    raux_agums-sign   = 'I'.
    raux_agums-option = 'EQ'.
    APPEND raux_agums.
  ENDIF.

  IF caux_aviso IS NOT INITIAL.
    raux_aviso-low  = caux_aviso.
    raux_aviso-sign   = 'I'.
    raux_aviso-option = 'EQ'.
    APPEND raux_aviso.
  ENDIF.

ENDFORM.                    " crear_rangos_pas

*&---------------------------------------------------------------------*
*&      Form  obtener_pas
*&---------------------------------------------------------------------*
FORM obtener_pas USING p_auxi.

  REFRESH tdatos2.
* Definimos este rango con saknr que tiene 10 de longitud
* (válido para cuentas de mayor, deudor y acreedor)
  RANGES: r_cuenta FOR ska1-saknr.
  r_cuenta[] = r_agkon[].
  LOOP AT r_cuenta.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = r_cuenta-low
      IMPORTING
        output = r_cuenta-low.
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = r_cuenta-high
      IMPORTING
        output = r_cuenta-high.
    MODIFY r_cuenta.
  ENDLOOP.

  RANGES: r_hbkid FOR bsik-hbkid.
  CLEAR r_hbkid.
  REFRESH r_hbkid.
  IF zsfis308_a-solo EQ 'X'.
    r_hbkid+0(3) = 'IEQ'.
    r_hbkid-low  = p_banco.
    APPEND r_hbkid.
  ENDIF.
* Según la clase de cuenta se busca una tabla u otra
  CASE caux_agkoa.
* Acreedores
    WHEN 'K'.
      SELECT * FROM bsik
      WHERE bukrs = p_bukrs AND
            hbkid IN r_hbkid AND
            budat IN p_budat AND
            lifnr IN r_cuenta AND
            umskz IN raux_agums.

        MOVE-CORRESPONDING bsik TO tdatos2.
        tdatos2-valut = bsik-bldat.
* Obtener moneda
        SELECT SINGLE waers INTO tdatos2-mon_local
        FROM t001
        WHERE bukrs = tdatos2-bukrs.
        IF tdatos2-shkzg = 'H'.
          tdatos2-dmbtr = - tdatos2-dmbtr.
          tdatos2-wrbtr = - tdatos2-wrbtr.
        ENDIF.

* Obtener denominación de la clase de doc.
        SELECT SINGLE ltext INTO tdatos2-ltext
        FROM t003t
        WHERE blart = tdatos2-blart AND
              spras = 'S'.

        tdatos2-acr = bsik-lifnr.

* OBtener nombre acreedor
        SELECT SINGLE name1 INTO tdatos2-name1
        FROM lfa1
        WHERE lifnr = tdatos2-acr.

*       JGS
*       Recalculamos la fecha de vencimiento
        CALL FUNCTION 'NET_DUE_DATE_GET'
          EXPORTING
            i_zfbdt = tdatos2-zfbdt
            i_zbd1t = bsik-zbd1t
            i_zbd2t = bsik-zbd2t
            i_zbd3t = bsik-zbd3t
            i_shkzg = tdatos2-shkzg
            i_rebzg = bsik-rebzg
            i_koart = 'K'
          IMPORTING
            e_faedt = tdatos2-zfbdt.
*       FJGS

        APPEND tdatos2.

      ENDSELECT.

* Deudores
    WHEN 'D'.
      SELECT * FROM bsid
      WHERE bukrs = p_bukrs AND
            hbkid IN r_hbkid AND
            budat IN p_budat AND
            kunnr IN r_cuenta AND
            umskz IN raux_agums.

        MOVE-CORRESPONDING bsid TO tdatos2.
        tdatos2-valut = bsid-bldat.

* Obtener moneda
        SELECT SINGLE waers INTO tdatos2-mon_local
        FROM t001
        WHERE bukrs = tdatos2-bukrs.
        IF tdatos2-shkzg = 'H'.
          tdatos2-dmbtr = - tdatos2-dmbtr.
          tdatos2-wrbtr = - tdatos2-wrbtr.
        ENDIF.

* Obtener denominación de la clase de doc.
        SELECT SINGLE ltext INTO tdatos2-ltext
        FROM t003t
        WHERE blart = tdatos2-blart AND
              spras = 'S'.

        tdatos2-acr = bsid-kunnr.

* OBtener nombre cliente
        SELECT SINGLE name1 INTO tdatos2-name1
        FROM kna1
        WHERE kunnr = tdatos2-acr.

*       Recalculamos la fecha de vencimiento
        CALL FUNCTION 'NET_DUE_DATE_GET'
          EXPORTING
            i_zfbdt = tdatos2-zfbdt
            i_zbd1t = bsid-zbd1t
            i_zbd2t = bsid-zbd2t
            i_zbd3t = bsid-zbd3t
            i_shkzg = tdatos2-shkzg
            i_rebzg = bsid-rebzg
            i_koart = 'D'
          IMPORTING
            e_faedt = tdatos2-zfbdt.
*       FJGS

        APPEND tdatos2.

      ENDSELECT.
    WHEN 'S'.
  ENDCASE.

ENDFORM.                    " obtener_pas

*&---------------------------------------------------------------------*
*&      Form  SH_INTERFACE
*&---------------------------------------------------------------------*
*       Modify einer Zeile der Tabelle  INTERFACE:
*       VALFIELD:  Dynprofeldname, FIELDVALUE: dessen Inhalt
*       SHLPFIELD: Feld im Suchhilfe-Interface
*----------------------------------------------------------------------*
FORM sh_interface
     USING VALUE(shlpfield) TYPE c
           VALUE(valfield) TYPE c
           VALUE(fieldvalue) TYPE c.
  READ TABLE shlp_mf05a-interface WITH KEY shlpfield = shlpfield
                                  INTO interface.
  IF sy-subrc EQ 0.
    interface-valfield = valfield.
    interface-value    = fieldvalue.
    MODIFY shlp_mf05a-interface INDEX sy-tabix FROM interface.
  ENDIF.
ENDFORM.                    " SH_INTERFACE

*---------------------------------------------------------------------*
*       FORM  DYNP_VALUES_READ                                        *
*---------------------------------------------------------------------*
*       Leer valores de la dynpro                                     *
*---------------------------------------------------------------------*
*  -->  FNAME                                                         *
*  <--  RC         SY-SUBRC                                           *
*---------------------------------------------------------------------*
FORM dynp_values_read USING
     fname LIKE dynpread-fieldname
     dv_rc LIKE sy-subrc.
  REFRESH f4hlp.
  CLEAR   f4hlp.
  f4hlp-fieldname = fname.
  APPEND f4hlp.

  CALL FUNCTION 'DYNP_VALUES_READ'
    EXPORTING
      dyname     = sy-cprog
      dynumb     = sy-dynnr
    TABLES
      dynpfields = f4hlp
    EXCEPTIONS
      OTHERS     = 01.
  dv_rc = sy-subrc.
ENDFORM.                    "dynp_values_read

*&---------------------------------------------------------------------*
*&      Form  matchcode_agkon
*&---------------------------------------------------------------------*
FORM matchcode_agkon  USING fieldname LIKE f4hlp-fieldname.
  DATA: f4rc LIKE sy-subrc.

  REFRESH f4hlp.
  CLEAR   f4hlp.
  f4hlp-fieldname = fieldname.
  APPEND f4hlp.

  PERFORM dynp_values_read USING 'CAUX_AGKOA' f4rc.
  READ TABLE f4hlp INDEX 1.
  IF sy-subrc = 0.
    caux_agkoa = f4hlp-fieldvalue.
  ENDIF.

  CASE caux_agkoa.
    WHEN 'K'.
      mcobjekt = 'KRED'.
      shlpname = 'KRED'.
    WHEN 'D'.
      mcobjekt = 'DEBI'.
      shlpname = 'DEBI'.
    WHEN 'S'.
      mcobjekt = 'SAKO'.
      shlpname = 'SAKO'.
  ENDCASE.


  CALL FUNCTION 'F4IF_GET_SHLP_DESCR'
    EXPORTING
      shlpname = shlpname
    IMPORTING
      shlp     = shlp_mf05a
    EXCEPTIONS
      OTHERS   = 1.

  PERFORM dynp_values_read USING 'CAUX_AGKON' f4rc.
  READ TABLE f4hlp INDEX 1.
  IF sy-subrc = 0.
    caux_agkon = f4hlp-fieldvalue.
  ENDIF.

  CASE caux_agkoa.
    WHEN 'D'.
      PERFORM sh_interface USING 'KUNNR'
                                 'RF05A-AGKON' f4hlp-fieldvalue.
    WHEN 'K'.
      PERFORM sh_interface USING 'LIFNR'
                                 'RF05A-AGKON' f4hlp-fieldvalue.
    WHEN 'S'.
      PERFORM sh_interface USING 'SAKNR'
                                 'RF05A-AGKON' f4hlp-fieldvalue.
      PERFORM sh_interface USING 'SAKAN'
                                 'RF05A-AGKON' f4hlp-fieldvalue.
    WHEN 'A'.
      PERFORM sh_interface USING 'ANLN1'
                                 'RF05A-AGKON' f4hlp-fieldvalue.
      PERFORM sh_interface USING 'ANLN2'                   "Note 160362
                                 'RF05A-AGKON' f4hlp-fieldvalue."Note 160362
  ENDCASE.

  CALL FUNCTION 'F4IF_START_VALUE_REQUEST'
    EXPORTING
      shlp          = shlp_mf05a
    TABLES
      return_values = return_values
    EXCEPTIONS
      OTHERS        = 1.

  CLEAR f4hlp.
  REFRESH f4hlp.
  READ TABLE return_values INDEX 1.
  IF sy-subrc = 0.
    f4hlp-fieldname  = fieldname.
    f4hlp-fieldvalue = return_values-fieldval.
    APPEND f4hlp.
    CALL FUNCTION 'DYNP_VALUES_UPDATE'
      EXPORTING
        dyname     = sy-cprog
        dynumb     = sy-dynnr
      TABLES
        dynpfields = f4hlp
      EXCEPTIONS
        OTHERS     = 8.
  ENDIF.

ENDFORM.                    " matchcode_agkon

*&---------------------------------------------------------------------*
*&      Form  sel_multiple
*&---------------------------------------------------------------------*
FORM sel_multiple.

  DATA: struc_tab_and_field TYPE rstabfield.

  struc_tab_and_field-fieldname    = 'RF05A'.
  struc_tab_and_field-tablename = 'AGKON'.

  CALL FUNCTION 'COMPLEX_SELECTIONS_DIALOG'
    EXPORTING
      title             = 'Cuenta'
    TABLES
      range             = r_agkon
    EXCEPTIONS
      no_range_tab      = 1
      cancelled         = 2
      internal_error    = 3
      invalid_fieldname = 4
      OTHERS            = 5.

ENDFORM.                    " sel_multiple

*&---------------------------------------------------------------------*
*&      Form  VISUALIZAR_DESTINO_UTILIZACION
*&---------------------------------------------------------------------*
FORM visualizar_destino_utilizacion.

  DATA ir TYPE i.

  CLEAR et_index_rows1[].
  CLEAR ir.

* OBtener líneas seleccionadas grid1
  CALL METHOD grid1->get_selected_rows
    IMPORTING
      et_index_rows = et_index_rows1.

  DELETE et_index_rows1 WHERE rowtype IS NOT INITIAL.

  DESCRIBE TABLE et_index_rows1 LINES ir.
  IF ir <> 1.
    MESSAGE s368(00) WITH 'Seleccione sólo una línea'.
  ELSE.
    LOOP AT et_index_rows1 INTO l_index_rows1.
      READ TABLE tdatos1 INDEX l_index_rows1-index.
      IF sy-subrc = 0.
        CLEAR: lt_n2p[].
        DATA l_febep TYPE febep. CLEAR l_febep.
        SELECT SINGLE a~kukey a~esnum INTO (l_febep-kukey, l_febep-esnum) FROM febep AS a
          INNER JOIN febko AS b ON a~kukey = b~kukey
          WHERE a~belnr = tdatos1-belnr
            AND a~gjahr = tdatos1-gjahr
            AND b~bukrs = tdatos1-bukrs.
        IF l_febep-kukey IS NOT INITIAL.
          SELECT vwezw FROM febre
            INTO TABLE lt_n2p
            WHERE kukey = l_febep-kukey AND
                  esnum = l_febep-esnum.
        ENDIF.
        IF lt_n2p[] IS NOT INITIAL.
          CALL SCREEN 0990 STARTING AT 5 5.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.
