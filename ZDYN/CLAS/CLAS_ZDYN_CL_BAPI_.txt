
class ZDYN_CL_BAPI definition
  public
  create public .

public section.

  types:
    yt_range_bukrs  TYPE RANGE OF bukrs .
  types:
    yt_range_ebeln  TYPE RANGE OF ebeln .
  types:
    yt_range_erdat  TYPE RANGE OF erdat .
  types:
    yt_range_waers  TYPE RANGE OF waers .
  types:
    yt_range_saknr  TYPE RANGE OF saknr .
  types:
    yt_range_kostl  TYPE RANGE OF kostl .
  types:
    yt_range_pspnr  TYPE RANGE OF ps_posnr .
  types:
    yt_range_lifnr  TYPE RANGE OF lifnr .
  types:
    yt_range_kunnr  TYPE RANGE OF kunnr .
  types:
    yt_range_zterm  TYPE RANGE OF dzterm .
  types:
    yt_ebeln        TYPE STANDARD TABLE OF ebeln .
  types:
    yt_range_mwskz  TYPE RANGE OF mwskz .
  types:
    yt_range_aufnr  TYPE RANGE OF aufnr .
  types:
    yt_range_vbeln  TYPE RANGE OF vbeln .
  types:
    yt_range_kappl  TYPE RANGE OF sna_kappl .
  types:
    yt_range_kschl  TYPE RANGE OF sna_kschl .
  types:
    yt_range_fkart  TYPE RANGE OF fkart .
  types:
    yt_range_langu  TYPE RANGE OF sy-langu .
  types:
    yt_range_belnr TYPE RANGE OF bkpf-belnr .
  types:
    yt_range_xblnr TYPE RANGE OF bkpf-xblnr .
  types:
    yt_range_blart TYPE RANGE OF bkpf-blart .
  types:
    yt_range_cpudt TYPE RANGE OF bkpf-cpudt .
  types:
    yt_range_gjahr TYPE RANGE OF bkpf-gjahr .
  types:
    BEGIN OF yst_sales_doc,
*        docno         TYPE zdyn_ddocno, " PDAP document (not used)
        sales_doc_nr  TYPE vbeln_vf,     " sales invoice (billing)
        doc_cr_date   TYPE erdat,
        doc_cr_time   TYPE erzet,
        doc_date      TYPE fkdat,
        doc_status    TYPE rfbsk,
        ap_doc_nr     TYPE belnr_d,
        ar_doc_nr     TYPE belnr_d,
        comp_code     TYPE bukrs,
        comp_code_vat TYPE stceg,
        partner       TYPE kunrg,
        ref_doc_no    TYPE xblnr,       " ref_doc_num
      END OF yst_sales_doc .
  types:
    yt_sales_docs TYPE STANDARD TABLE OF yst_sales_doc .
  types:
    yt_vendors TYPE STANDARD TABLE OF zdyn_ws_vmd .
  types:
    yt_vendor_banks TYPE STANDARD TABLE OF lfbk .
  types:
    yt_customers TYPE STANDARD TABLE OF zdyn_ws_cmd .
  types:
    yt_customer_banks TYPE STANDARD TABLE OF knbk .
  types:
    BEGIN OF yst_tax_code,
        tax_code  TYPE mwskz,
        procedure TYPE kalsm_d,
        comp_code TYPE bukrs,
      END OF yst_tax_code .
  types:
    yt_tax_codes  TYPE STANDARD TABLE OF yst_tax_code .
  types:
    yt_ids TYPE STANDARD TABLE OF i .
  types:
    BEGIN OF yst_existing_func,
        name   TYPE rs38l-name,
        exists TYPE abap_bool,
      END OF yst_existing_func .
  types:
    yt_existing_func TYPE SORTED TABLE OF yst_existing_func WITH UNIQUE KEY name .

  class-data MO type ref to ZDYN_CL_BAPI read-only .
  data MT_EXISTING_FUNC type YT_EXISTING_FUNC .
  data MT_VBRP type TT_VBRP .

  methods GET_PAYMENT_DATA
    importing
      !IC_BILLING_PARTNER type ANY
      !IC_BILLING_DOC type ANY
      !IC_COMPANY_CODE type ANY
    exporting
      !ET_PAYMENT_METHODS type ZDYN_LSTRING
      !EC_BANK_ID type HBKID .
  methods GET_BILLING_PARTNER
    importing
      !IC_BILLING_DOC type ANY
      !IC_ROLE type ANY
    exporting
      !EC_BILLING_PARTNER type KUNNR .
  methods IS_FUNCTION_EXIST
    importing
      !IC_NAME type RS38L-NAME
    returning
      value(RB_RESULT) type ABAP_BOOL .
  methods IS_TABLE_EXIST
    importing
      !IC_NAME type ANY
    returning
      value(RB_RESULT) type ABAP_BOOL .
  methods GET_TEXTS
    importing
      !IC_NUMBER type ANY
      !IC_LANGU type SY-LANGU default SY-LANGU
    exporting
      !ET_LINES type TLINE_TAB .
  methods MAP_INT_TO_EXT_STRUCTURE
    importing
      !IT_VBAK type VBAK_T
      !IT_KOMV type TY_KOMV
    exporting
      !ET_CONDITIONS type ZDYN_TBAPISDCOND .
  methods GET_VBRPS
    importing
      !IC_DOC_NUMBER type ANY
    exporting
      !ET_VBRP type TT_VBRP .
  methods GET_VBRP
    importing
      !IC_DOC_NUMBER type ANY
      !IC_ITM_NUMBER type ANY optional
    exporting
      !EST_VBRP type VBRP .
  methods GET_VBAK
    importing
      !IN_DOC_NUMBER type ANY
    exporting
      !ET_VBAK type VBAK_T .
  methods GET_TEXT_FROM_DOMAIN
    importing
      !IC_DOMAIN type ANY
      !IC_VALUE type ANY
      !IC_LANGU type ANY default SY-LANGU
    exporting
      !EC_TEXT type DDTEXT
      !EC_RC type SY-SUBRC .
  methods ARCHIVE_IS_FILE_ATTR_ACTIVE
    returning
      value(EB_RESULT) type ABAP_BOOL .
  methods GET_KONV
    importing
      !IN_COND_NUMB type ANY
    exporting
      !ET_KONV type KONV_TTY
      !ET_KOMV type TY_KOMV .
  methods GET_DUEDATE
    importing
      !ID_BASELINE_DATE type DZFBDT
      !II_DISCOUNT_DAYS_1 type DZBD1T
      !II_DISCOUNT_DAYS_2 type DZBD2T
      !II_DISCOUNT_DAYS_3 type DZBD3T
    exporting
      !ED_DUEDATE type NETDT .
  methods GET_CUSTOMER_TAX_CODE
    importing
      !IC_NUMBER type KUNNR
    returning
      value(RST_CODES) type ZDYN_WS_STAX_CODES .
  methods GET_COMPANY_DETAILS
    importing
      !IC_COMPANY_CODE type ANY
    exporting
      !EST_COMPANY type T001
    exceptions
      ERROR_OCCURRED .
  methods GET_BSID_BSAD
    importing
      !IC_DOC_NUM type ANY
      !IC_COMP_CODE type ANY
    exporting
      !EST_BSEG type BSEG .
  methods GET_BSEG
    importing
      !IC_DOC_NUM type ANY
      !IC_ACCOUNT_TYPE type ANY
    exporting
      !EST_BSEG type BSEG .
  methods GET_BILLING_DOC
    importing
      !IC_DOC_NUMBER type NAST-OBJKY
      !IC_DATA_SELECTION type LBBIL_PRINT_DATA_TO_READ
      !IC_PARTNER type NAST-PARVW
      !IC_PARTNER_ROLE type NAST-PARNR
      !IC_LANGU type NAST-SPRAS
    exporting
      !EST_DATA type LBBIL_INVOICE
    exceptions
      RECORDS_NOT_FOUND
      ERROR_OCCURRED .
  methods GET_ACCOUNT_DETERMINATION
    importing
      !IC_COMPANY_CODE type ANY
      !IT_ZLSCH type ZDYN_LSTRING optional
    exporting
      !ET_RULES type ZDYN_LT042I .
  methods GET_BANK_DETAILS
    importing
      !IC_COMPANY_CODE type ANY
      !IC_BANK_KEY type ANY
      !IC_ACCOUNT_ID type ANY
    exporting
      !EST_HOUSE_BANK type T012
      !EST_ACCOUNT type T012K
      !EST_BANK_MASTER type BNKA
    exceptions
      ERROR_OCCURRED .
  methods BIN_TO_BASE64
    importing
      !IT_BINARY type ZDYN_LTBL1024
      !I_LENGTH type ANY
    exporting
      !ET_BASE64 type ZDYN_LXML_NOTE_CONTENT
    exceptions
      ERROR_OCCURRED .
  methods BAPISDORDER_GETDETAILEDLIST
    importing
      !IT_SALES_DOCUMENTS type MDS_SALES_KEY_TAB
      !IST_VIEW type ORDER_VIEW
    exporting
      !ET_HEADERS type ZDYN_TBAPISDHD
      !ET_ITEMS type ZDYN_TBAPISDIT
      !ET_CONDITIONS type ZDYN_TBAPISDCOND .
  class-methods SET_MO
    importing
      !IO_MO type ref to ZDYN_CL_BAPI optional .
  methods GET_ATTACHMENTS
    importing
      !IC_DOC_NUMBER type ANY
      !IC_DOC_TYPE type ANY
    changing
      !CT_ATTACHMENTS type ZDYN_LATTACHMENT
    exceptions
      ERROR_OCCURRED .
  methods GET_LOCAL_CURRENCY
    importing
      !IC_COMP_CODE type BUKRS
    returning
      value(RC_CURRENCY) type WAERS .
  methods GET_EXCHANGE_RATE
    importing
      !ID_DATE type SY-DATLO default SY-DATLO
      !IC_FOREIGN_CURRENCY type WAERS
      !IC_LOCAL_CURRENCY type WAERS
      !IB_EXACT_DATE type ABAP_BOOL default ABAP_TRUE
    exporting
      !EC_EXCHANGE_RATE type UKURS_CURR
    exceptions
      ERROR_OCCURRED .
  methods ARCHIVE_GET_DATA
    importing
      !IC_ARCHIVE_ID type SAEARCHIVI
      !IC_DOC_TYPE type SAEDOKTYP
      !IC_ARC_DOC_ID type SAEARDOID
    exporting
      !ET_DATA type RMPS_T_1024
    exceptions
      ERROR_OCCURRED .
  methods GET_SALES_DOC_NUMBERS
    importing
      !IT_SEL_SALES_DOC type YT_RANGE_VBELN optional
      !IT_SEL_DOC_TYPE type YT_RANGE_FKART optional
      !IT_SEL_COMP_CODE type YT_RANGE_BUKRS optional
      !IT_SEL_CUSTOMER type YT_RANGE_KUNNR optional
      !IT_SEL_APPLICATION type YT_RANGE_KAPPL optional
      !IT_SEL_MSG_TYPE type YT_RANGE_KSCHL optional
      !IT_DYN_SEL type RSDS_TRANGE optional
      !IT_SEL_CREATE_DATE type YT_RANGE_ERDAT optional
      !IC_DOC_TYPE type ANY optional
      !IB_USE_REGISTER type ABAP_BOOL default ABAP_TRUE
    exporting
      !ET_SALES_DOCS type TT_VBELN .
  methods GET_SALES_DOCUMENTS2
    importing
      !IT_SEL_SALES_DOC type YT_RANGE_VBELN
      !IT_SEL_COMP_CODE type YT_RANGE_BUKRS optional
      !ID_CREATE_DATE type ERDAT
    exporting
      !ET_SALES_DOCS type YT_SALES_DOCS .
  methods GET_SALES_DOCUMENTS
    importing
      !IT_SEL_SALES_DOC type YT_RANGE_VBELN
      !IT_SEL_COMP_CODE type YT_RANGE_BUKRS optional
      !ID_CREATE_DATE type ERDAT
    exporting
      !ET_SALES_DOCS type YT_SALES_DOCS .
  methods IDOC_INBOUND_XML_VIA_HTTP
    importing
      !IS_XML type STRING
      !IS_REMOTE_ADDR type STRING optional
    exceptions
      ERROR_OCCURRED .
  methods GET_BILLING_DOC_PDF_NAST
    importing
      !IST_NAST type NAST
      !IC_SMARTFORM type NA_FNAME
      !IC_LANGU type SY-LANGU default SY-LANGU
    exporting
      !ET_DATA type RMPS_T_1024
      !EI_BIN_LENGTH type I
      !EX_STREAM type XSTRING
    exceptions
      ERROR_OCCURRED .
  methods GET_IDOC_CONTROL_RECORD
    importing
      !IS_EXTERNAL_DOC_ID type STRING
    exporting
      !ES_RECORD type EDIDC .
  methods GET_CURRENT_TIMESTAMP
    returning
      value(RD_TIMESTAMP) type TIMESTAMPL .
  methods GET_BANK_NAME
    importing
      !IC_COUNTRY_KEY type BANKS
      !IC_KEYS type BANKL
    returning
      value(RC_NAME) type BANKA .
  methods GET_ADDRESS
    importing
      !IC_ADDRESS_NO type CADNR
    exporting
      !EST_ADDRESS type SZADR_ADDR1_COMPLETE
      !EI_SUBRC type SY-SUBRC .
  methods ARCHIVE_GET_CONNECTIONS
    importing
      !IC_SAP_OBJECT type SAEANWDID
      !IC_OBJECT_ID type SAEOBJID
    exporting
      !ET_CONNECTIONS type CONNECTION_TAB
    exceptions
      NOT_FOUND
      SYSTEM_ERROR .
  methods GET_PO_LIST
    importing
      !IT_SEL_PO type YT_RANGE_EBELN
      !IC_COMP_CODE type BUKRS optional
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
      !IT_SEL_CREATE_DATE type YT_RANGE_ERDAT optional
      !ID_CHANGE_DATE type FC_DATUM optional
    exporting
      !ET_PO_LIST type ZDYN_LEBELN .
  methods GET_NAPR
    importing
      !IC_OUTPUT_TYPE type TNAPR-KSCHL
      !IC_APPLICATION type TNAPR-KAPPL
      !IC_TRANS_MEDIUM type TNAPR-NACHA
    returning
      value(RC_SMARTFORM) type TNAPR-SFORM .
  methods GET_WBS_ELEMENTS
    importing
      !IT_SEL_OPT type YT_RANGE_PSPNR
      !IC_COMP_CODE type BUKRS optional
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
      !IB_ACTIVE_ONLY type ABAP_BOOL default ABAP_TRUE
    exporting
      !ET_WBS_ELEMENTS type ZDYN_LSTR_WBS_ELEMENTS .
  methods GET_NAST
    importing
      !IC_DOC_NUMBER type NAST-OBJKY
      !IC_APPLICATION type NAST-KAPPL
      !IC_OUTPUT_TYPE type NAST-KSCHL optional
    exporting
      !EST_NAST type NAST .
  methods GET_ORDERS
    importing
      !IT_SEL_OPT type YT_RANGE_AUFNR
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
    exporting
      !ET_ORDERS type ZDYN_LSTR_ORDERS .
  methods GET_CONTROLLING_AREA
    importing
      !IC_COMP_CODE type BUKRS
    exporting
      !EC_CTRL_AREA type KOKRS
    exceptions
      ERROR_OCCURRED .
  methods CONVERT_255_TO_1024
    importing
      !IT_255 type SOLIX_TAB
    returning
      value(RT_1024) type ZDYN_LTBL1024 .
  methods GET_COST_CENTERS
    importing
      !IC_COMP_CODE type BUKRS optional
      !IC_CTRL_AREA type KOKRS optional
      !IT_SEL_LANGU type YT_RANGE_LANGU optional
      !IT_SEL_OPT type YT_RANGE_KOSTL
    exporting
      !ET_COST_CENTERS type ZDYN_LSTR_MKOSTS .
  methods GET_TAX_CODES
    importing
      !IT_SEL_OPT type YT_RANGE_MWSKZ
      !IC_COMP_CODE type BUKRS optional
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
    exporting
      !ET_TAX_CODES type YT_TAX_CODES
      !EC_PROCEDURE type KALSM_D .
  methods GET_TAX_CODE_TEXT
    importing
      !IC_TAX_CODE type MWSKZ
      !IC_PROCEDURE type KALSM_D
      !IT_SEL_LANGU type YT_RANGE_LANGU optional
    exporting
      !EC_TEXT type T007S-TEXT1 .
  methods FI_PRINT_ZTERM
    importing
      !IC_ZTERM type DZTERM
      !IT_SEL_LANGU type YT_RANGE_LANGU
    exporting
      !ET_TEXTS type ZDYN_LSTR_TTEXT
    exceptions
      ERROR_OCCURRED .
  methods GET_CURRENCY_TEXTS
    importing
      !IT_SEL_OPT type YT_RANGE_WAERS
      !IT_SEL_LANGU type YT_RANGE_LANGU optional
    exporting
      !ET_TEXTS type ZDYN_LSTR_TCURT .
  methods GET_GL_ACCOUNTS
    importing
      !IT_SEL_OPT type YT_RANGE_SAKNR
      !IC_COMP_CODE type BUKRS optional
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
    exporting
      !ET_GL_ACCOUNTS type ZDYN_LSTR_TGL_ACCT_CC .
  methods GET_GL_ACCOUNT_DETAILS
    importing
      !IC_CHART_OF_ACCOUNTS type KTOPL
      !IC_GL_ACCOUNT type SAKNR
      !IT_SEL_LANGU type YT_RANGE_LANGU optional
    exporting
      !EST_DETAILS type SKAT .
  methods GET_IBAN
    importing
      !IC_BANKS type BANKS
      !IC_BANKL type BANKK
      !IC_BANKN type ANY
      !IC_BKONT type BKONT
    exporting
      !EST_IBAN type TIBAN
      !EC_IBAN type IBAN .
  methods GET_PAYMENT_TERMS
    importing
      !IT_SEL_OPT type YT_RANGE_ZTERM
    exporting
      !ET_TERMS type ZDYN_LSTR_T052 .
  methods GET_SWIFT
    importing
      !IC_BANKS type BANKS
      !IC_BANKL type BANKK
    returning
      value(RC_SWIFT) type SWIFT .
  methods GET_VENDORS
    importing
      !IT_SEL_OPT type YT_RANGE_LIFNR
      !IC_COMP_CODE type BUKRS optional
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS optional
      !IT_DYN_SEL type RSDS_TRANGE optional
    exporting
      !ET_VENDORS type YT_VENDORS .
  methods GET_CUSTOMERS
    importing
      !IT_SEL_OPT type YT_RANGE_KUNNR
      !IT_SEL_COMP_CODES type YT_RANGE_BUKRS
      !IT_DYN_SEL type RSDS_TRANGE optional
    exporting
      !ET_CUSTOMERS type YT_CUSTOMERS .
  methods GET_CUSTOMER_BANKS
    importing
      !IC_CUSTOMER type KUNNR
    exporting
      !ET_BANKS type YT_CUSTOMER_BANKS .
  methods GET_VENDOR_BANKS
    importing
      !IC_VENDOR type LIFNR
    exporting
      !ET_BANKS type YT_VENDOR_BANKS .
  methods IS_OBJECT_MODIFIED
    importing
      !IC_OBJECT_ID type ANY
      !IC_OBJECT_CLASS type ANY
      !ID_DATE type FC_DATUM
    returning
      value(RB_RESULT) type ABAP_BOOL .
  methods GET_COMPANY_CODES
    importing
      !IT_SEL_OPT type YT_RANGE_BUKRS
    exporting
      !ET_COMPANY_CODES type ZDYN_LBUKRS .
  methods BAPI_COMPANYCODE_GETDETAIL
    importing
      !IC_COMPANYCODE_ID type BAPI0002_2-COMP_CODE
    exporting
      !EST_COMPANYCODE_DETAIL type BAPI0002_2
      !EST_COMPANYCODE_ADDRESS type BAPI0002_3
      !EST_RETURN type BAPIRETURN .
  methods BAPI_PO_GETDETAIL
    importing
      !IC_PO_NUMBER type EBELN
      !IB_ITEMS type ABAP_BOOL default ABAP_TRUE
      !IB_HISTORY type ABAP_BOOL default ABAP_TRUE
    exporting
      !ES_HEADER type BAPIEKKOL
      !ET_ITEMS type ZDYN_LSTRU_BAPIEKPO
      !ET_ITEM_HISTORY type ZDYN_LSTRU_BAPIEKBE
      !ET_ITEM_HISTORY_TOTALS type ZDYN_LSTRU_BAPIEKBES .
  methods EBY_PDBO_RFC_DATA_RECEIVE
    importing
      !IC_OBJ type ZDYN_DOBJ_PD
      !IC_ENV type ANY
      !IC_MAPID type ZDYN_DMAPID_PD
      !IT_EXTDATA type ZDYN_LSTRU_EXTDATA
      !IT_ARCHIVING type ZDYN_LSTRU_ARCHIVE
      !IT_CONTENT type RMPS_T_1024
    exporting
      !ES_BO_HDR type ZDYN_STRU_BO_HDR
      !ES_STATUS type ZDYN_STRU_BO_RFCSTATUS
      !ET_MESSAGES type ZDYN_LSTRU_PD_MESSAGE .
  methods ARCHIVE_EXTERNAL_DATA
    importing
      !IST_ARC type ZDYN_STRU_ARCHIVE
      !IT_CONTENT type RMPS_T_1024
    exporting
      !EC_ARC_DOC_ID type SAEARDOID
    exceptions
      ERROR_OCCURRED .
  class-methods CLASS_CONSTRUCTOR .
  methods GET_EMAIL_FROM_ADR6
    importing
      !IC_ADRNR type ADRNR optional
      !IC_PERNR type PERNR_D optional
    returning
      value(RS_EMAIL) type STRING .
  methods ARCHIVE_CREATE_LINK
    importing
      !IST_ARC type ZDYN_STRU_ARCHIVE
    returning
      value(RB_OK) type ABAP_BOOL .
  methods ARCHIVE_PREPARE
    changing
      !CST_ARC type ZDYN_STRU_ARCHIVE .
  methods GET_CUSTOMER_DETAILS
    importing
      !IC_CUSTOMER type KUNNR
    exporting
      !EST_DETAILS type KNA1 .
  PROTECTED SECTION.

    METHODS find_for_langu
      IMPORTING
        !ic_bus_key_1 TYPE string
        !ic_bus_key_2 TYPE string OPTIONAL
        !ic_langu_key TYPE string
        !it_sel_langu TYPE yt_range_langu
      CHANGING
        !ct_records   TYPE table .
  PRIVATE SECTION.
endclass. "ZDYN_CL_BAPI definition
class ZDYN_CL_BAPI implementation.
  METHOD archive_create_link.

    DATA: lc_function TYPE funcname VALUE 'ARCHIV_CONNECTION_INSERT'.

    IF 1 = 2. CALL FUNCTION 'ARCHIV_CONNECTION_INSERT'. ENDIF. "#EC *
    CALL FUNCTION lc_function
      EXPORTING
        archiv_id             = ist_arc-archiv_id
        arc_doc_id            = ist_arc-arc_doc_id
        ar_date               = ist_arc-ar_date
        ar_object             = ist_arc-ar_object
        object_id             = ist_arc-object_id
        sap_object            = ist_arc-sap_object
        filename              = ist_arc-filename     "SFA
        descr                 = ist_arc-descr        "SFA
        creator               = ist_arc-creator      "SFA
      EXCEPTIONS
        error_connectiontable = 1
        error_message         = 2
        OTHERS                = 3.
    IF sy-subrc = 0.
      rb_ok = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD archive_external_data.

* no archiving if already archived
    CHECK ist_arc-arc_doc_id IS INITIAL.
* check mandatory values
    CHECK: ist_arc-archiv_id IS NOT INITIAL,
           ist_arc-document_type IS NOT INITIAL,
           ist_arc-binlength IS NOT INITIAL.

    CALL FUNCTION 'ARCHIVOBJECT_CREATE_TABLE'
      EXPORTING
        archiv_id       = ist_arc-archiv_id
        document_type   = ist_arc-document_type
        length          = ist_arc-binlength
      IMPORTING
        archiv_doc_id   = ec_arc_doc_id
      TABLES
        binarchivobject = it_content
      EXCEPTIONS
        OTHERS          = 1.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD archive_get_connections.

* Not used at that moment

*  CALL FUNCTION 'ARCHIV_GET_CONNECTIONS'
*    EXPORTING
*      objecttype    = ic_sap_object
*      object_id     = ic_object_id
*    TABLES
*      connections   = et_connections
*    EXCEPTIONS
*      nothing_found = 1
*      error_message = 2
*      OTHERS        = 3.
*  IF sy-subrc = 1.
*    RAISE not_found.
*  ELSEIF sy-subrc <> 0.
*    RAISE system_error.
*  ENDIF.

  ENDMETHOD.
  METHOD archive_get_data.

* Not used at that moment

*  CALL FUNCTION 'ARCHIVOBJECT_GET_TABLE'
*    EXPORTING
*      archiv_id                = ic_archive_id
*      document_type            = ic_doc_type
*      archiv_doc_id            = ic_arc_doc_id
**     IMPORTING
**     LENGTH                   =
**     BINLENGTH                =
*    TABLES
**     ARCHIVOBJECT             =
*      binarchivobject          = et_data
*    EXCEPTIONS
*      error_archiv             = 1
*      error_communicationtable = 2
*      error_kernel             = 3
*      error_message            = 4
*      OTHERS                   = 5.
*  IF sy-subrc <> 0.
*    RAISE error_occurred.
*  ENDIF.

  ENDMETHOD.
  METHOD archive_is_file_attr_active.

* Verifies if Save the Files Attributes flag is set in OAG1

    DATA: li_subrc  TYPE sy-subrc,
          lst_toacu TYPE toacu.
    FIELD-SYMBOLS: <attr> TYPE any.

    eb_result = abap_false.

    CALL FUNCTION 'DD_EXIST_TABLE'
      EXPORTING
        tabname      = 'TOAAT'
        status       = 'A'
      IMPORTING
        subrc        = li_subrc
      EXCEPTIONS
        wrong_status = 1
        OTHERS       = 2.
    IF sy-subrc <> 0 OR li_subrc <> 0.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM toacu INTO lst_toacu.

    ASSIGN COMPONENT 'RESERV1' OF STRUCTURE lst_toacu TO <attr>.
    IF <attr> IS ASSIGNED AND <attr> = 'X'.
      eb_result = abap_true.
      RETURN.
    ENDIF.

  ENDMETHOD.
  METHOD archive_prepare.

    DATA: lst_toaom TYPE toaom.

* this requires sap_object and ar_object info
* Get archive link from table TOAOM
    SELECT SINGLE * FROM toaom INTO lst_toaom
      WHERE sap_object EQ cst_arc-sap_object
      AND ar_object    EQ cst_arc-ar_object
      AND ar_status    EQ abap_true.

    CHECK sy-subrc = 0.
    cst_arc-archiv_id = lst_toaom-archiv_id.
    cst_arc-document_type = lst_toaom-doc_type.

    IF cst_arc-document_type IS INITIAL.
      SELECT SINGLE doc_type FROM toadv INTO cst_arc-document_type
        WHERE ar_object = cst_arc-ar_object.
    ENDIF.

  ENDMETHOD.
  METHOD bapi_companycode_getdetail.

    CALL FUNCTION 'BAPI_COMPANYCODE_GETDETAIL'
      EXPORTING
        companycodeid       = ic_companycode_id
      IMPORTING
        companycode_detail  = est_companycode_detail
        companycode_address = est_companycode_address
        return              = est_return.

  ENDMETHOD.
  METHOD bapi_po_getdetail.

    CALL FUNCTION 'BAPI_PO_GETDETAIL'
      EXPORTING
        purchaseorder          = ic_po_number
        items                  = ib_items
        history                = ib_history
      IMPORTING
        po_header              = es_header
      TABLES
        po_items               = et_items
        po_item_history        = et_item_history
        po_item_history_totals = et_item_history_totals.

  ENDMETHOD.
  METHOD bapisdorder_getdetailedlist.

    CALL FUNCTION 'BAPISDORDER_GETDETAILEDLIST'
      EXPORTING
        i_bapi_view          = ist_view
*       I_MEMORY_READ        =
*       I_WITH_HEADER_CONDITIONS       = ' '
      TABLES
        sales_documents      = it_sales_documents
        order_headers_out    = et_headers
        order_items_out      = et_items
*       ORDER_SCHEDULES_OUT  =
*       ORDER_BUSINESS_OUT   =
*       ORDER_PARTNERS_OUT   =
*       ORDER_ADDRESS_OUT    =
*       ORDER_STATUSHEADERS_OUT        =
*       ORDER_STATUSITEMS_OUT          =
        order_conditions_out = et_conditions
*       ORDER_COND_HEAD      =
*       ORDER_COND_ITEM      =
*       ORDER_COND_QTY_SCALE =
*       ORDER_COND_VAL_SCALE =
*       ORDER_CONTRACTS_OUT  =
*       ORDER_TEXTHEADERS_OUT          =
*       ORDER_TEXTLINES_OUT  =
*       ORDER_FLOWS_OUT      =
*       ORDER_CFGS_CUREFS_OUT          =
*       ORDER_CFGS_CUCFGS_OUT          =
*       ORDER_CFGS_CUINS_OUT =
*       ORDER_CFGS_CUPRTS_OUT          =
*       ORDER_CFGS_CUVALS_OUT          =
*       ORDER_CFGS_CUBLBS_OUT          =
*       ORDER_CFGS_CUVKS_OUT =
*       ORDER_BILLINGPLANS_OUT         =
*       ORDER_BILLINGDATES_OUT         =
*       ORDER_CREDITCARDS_OUT          =
*       EXTENSIONOUT         =
      .

  ENDMETHOD.
  METHOD bin_to_base64.

    DATA: lx_stream      TYPE xstring,
          li_stream_len  TYPE i,
          li_stream_xlen TYPE i,
          li_input_len   TYPE i,
          li_pos         TYPE i,
          li_chunk_len   TYPE i,
          lst_line       LIKE LINE OF et_base64,
          ls_stream      TYPE string.

    li_input_len = i_length.
    CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
      EXPORTING
        input_length = li_input_len
      IMPORTING
        buffer       = lx_stream
      TABLES
        binary_tab   = it_binary
      EXCEPTIONS
        failed       = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

    li_stream_xlen = xstrlen( lx_stream ).

    CALL FUNCTION 'SSFC_BASE64_ENCODE'
      EXPORTING
        bindata = lx_stream
        binleng = li_stream_xlen
      IMPORTING
        b64data = ls_stream
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

    IF ls_stream IS NOT INITIAL.
      li_stream_len = strlen( ls_stream ).
      DO.
        li_chunk_len = li_stream_len - li_pos.
        IF li_chunk_len > 200.
          li_chunk_len = 200.
        ELSEIF li_chunk_len <= 0.
          EXIT.
        ENDIF.
        lst_line-content = ls_stream+li_pos(li_chunk_len).
        APPEND lst_line TO et_base64.
        li_pos = li_pos + li_chunk_len.
      ENDDO.
    ENDIF.

  ENDMETHOD.
  METHOD class_constructor.

    set_mo( ).

  ENDMETHOD.
  METHOD convert_255_to_1024.

    DATA: lst_it_255      LIKE LINE OF it_255,
          lx_line_content TYPE xstring,
          lst_rt_1024     LIKE LINE OF rt_1024,
          li_abs_char     TYPE i,
          li_act_char     TYPE i.

    LOOP AT it_255 INTO lst_it_255.
      IF sy-tabix = 1.
        lx_line_content =  lst_it_255-line.
      ELSE.
        CONCATENATE lx_line_content lst_it_255-line INTO lx_line_content IN BYTE MODE .
      ENDIF.
    ENDLOOP.

    li_abs_char  = xstrlen( lx_line_content ).

    DO.
      MOVE lx_line_content TO lst_rt_1024-line.
      APPEND lst_rt_1024 TO rt_1024.
      SHIFT lx_line_content LEFT BY 1024 PLACES IN BYTE MODE .
      CLEAR lst_rt_1024.
      li_act_char = li_act_char + 1024.
      IF li_act_char > li_abs_char.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.
  METHOD eby_pdbo_rfc_data_receive.

    CONSTANTS: con_function  TYPE funcnam  VALUE '/EBY/PDBO_RFC_DATA_RECEIVE',
               con_bo_hdr    TYPE char30   VALUE '/EBY/PDBO_THDR',
               con_status    TYPE char30   VALUE '/EBY/PDBO_SRFCSTATUS',
               con_archiving TYPE char30   VALUE '/EBY/_LARCHIVE',
               con_extdata   TYPE char30   VALUE '/EBY/PDBO_LEXTDATA'.
    DATA: lr_bo_hdr    TYPE REF TO data,
          lr_status    TYPE REF TO data,
          lr_archiving TYPE REF TO data,
          lr_extdata   TYPE REF TO data.
    FIELD-SYMBOLS: <s_bo_hdr>    TYPE any,
                   <s_status>    TYPE any,
                   <t_archiving> TYPE table,
                   <t_extdata>   TYPE table.
* The structures may be strictly validated in some systems, even causing shortdumps.
* E.g. ZDYN_STRU_BO_HDR and /EBY/PDBO_THR are not compatible in S/4HANA systems
    TRY.
        CREATE DATA lr_bo_hdr TYPE (con_bo_hdr).
        ASSIGN lr_bo_hdr->* TO <s_bo_hdr>.
        CREATE DATA lr_status TYPE (con_status).
        ASSIGN lr_status->* TO <s_status>.
        CREATE DATA lr_archiving TYPE (con_archiving).
        ASSIGN lr_archiving->* TO <t_archiving>.
        CREATE DATA lr_extdata TYPE (con_extdata).
        ASSIGN lr_extdata->* TO <t_extdata>.

        zdyn_cl_system=>mo->move_corresponding_tab( EXPORTING it_input  = it_extdata
                                                    CHANGING  ct_output = <t_extdata> ).
        zdyn_cl_system=>mo->move_corresponding_tab( EXPORTING it_input  = it_archiving
                                                    CHANGING  ct_output = <t_archiving> ).
      CATCH cx_root.
        RETURN.
    ENDTRY.

    CALL FUNCTION 'RH_FUNCTION_EXIST'
      EXPORTING
        name   = con_function
      EXCEPTIONS
        OTHERS = 1.
    CHECK sy-subrc = 0.

    CALL FUNCTION con_function
      DESTINATION 'NONE'
      EXPORTING
        ic_obj     = ic_obj
        ic_env     = ic_env
        ic_mapid   = ic_mapid
      IMPORTING
        es_bo_hdr  = <s_bo_hdr>
        es_status  = <s_status>
      TABLES
        it_data    = <t_extdata>
        it_arc_hdr = <t_archiving>
        it_arc_obj = it_content
        et_msg_txt = et_messages.

    MOVE-CORRESPONDING <s_bo_hdr> TO es_bo_hdr.
    MOVE-CORRESPONDING <s_status> TO es_status.

  ENDMETHOD.
  METHOD fi_print_zterm.

    DATA: lst_langu    LIKE LINE OF it_sel_langu.

* start with the first position, of the highest priority
    LOOP AT it_sel_langu INTO lst_langu.
      CALL FUNCTION 'FI_PRINT_ZTERM'
        EXPORTING
          i_zterm = ic_zterm
          i_langu = lst_langu-low
        TABLES
          t_ztext = et_texts
        EXCEPTIONS
          OTHERS  = 1.
      IF sy-subrc <> 0.
        RAISE error_occurred.
      ENDIF.
*   take the first texts returned
      IF et_texts IS NOT INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD find_for_langu.

* This method is supposed to remove all records from the the CT_RECORDS list
* with languages that are either not on the IT_SEL_LANGU list or have lower priority among
* those in the IT_SEL_LANGU list
* (the higher the language is on the list the higher pririty it has)

    DATA: lt_sel_langu LIKE it_sel_langu,
          lst_langu    LIKE LINE OF lt_sel_langu,
          li_len       TYPE i,
          li_pos       TYPE i,
          lb_delete    TYPE abap_bool.
    FIELD-SYMBOLS: <st_rec_low>       TYPE any,
                   <st_rec_high>      TYPE any,
                   <s_langu_key_low>  TYPE any,
                   <s_langu_key_high> TYPE any,
                   <s_bus_key_high_1> TYPE any,
                   <s_bus_key_low_1>  TYPE any,
                   <s_bus_key_high_2> TYPE any,
                   <s_bus_key_low_2>  TYPE any.

    li_len = lines( it_sel_langu ).
    li_pos = li_len.
    li_len = li_len - 1.

* add case when there is only one langu
* add case when there are more records with different langus

* remove all records with langu not on the list
    LOOP AT ct_records ASSIGNING <st_rec_low>.
      ASSIGN COMPONENT ic_langu_key OF STRUCTURE <st_rec_low> TO <s_langu_key_low>.
      CHECK sy-subrc = 0 AND <s_langu_key_low> IS ASSIGNED
        AND <s_langu_key_low> NOT IN it_sel_langu.
      DELETE ct_records.
    ENDLOOP.

* remove all records with languages of lower priority
    DO li_len TIMES.
      READ TABLE it_sel_langu INTO lst_langu INDEX li_pos.
      LOOP AT ct_records ASSIGNING <st_rec_low>.
        ASSIGN COMPONENT ic_langu_key OF STRUCTURE <st_rec_low> TO <s_langu_key_low>.
        CHECK <s_langu_key_low> IS ASSIGNED
          AND <s_langu_key_low> = lst_langu-low.

        ASSIGN COMPONENT ic_bus_key_1 OF STRUCTURE <st_rec_low> TO <s_bus_key_low_1>.
        CHECK <s_bus_key_low_1> IS ASSIGNED.

        IF ic_bus_key_2 IS NOT INITIAL.
          ASSIGN COMPONENT ic_bus_key_2 OF STRUCTURE <st_rec_low> TO <s_bus_key_low_2>.
          CHECK <s_bus_key_low_2> IS ASSIGNED.
        ENDIF.

        lb_delete = abap_false.
*     find record with language of a higher priority
        LOOP AT ct_records ASSIGNING <st_rec_high>.
          ASSIGN COMPONENT ic_langu_key OF STRUCTURE <st_rec_high> TO <s_langu_key_high>.
          CHECK <s_langu_key_high> IS ASSIGNED
            AND <s_langu_key_high> <> lst_langu-low
            AND <s_langu_key_high> IN it_sel_langu.

          ASSIGN COMPONENT ic_bus_key_1 OF STRUCTURE <st_rec_high> TO <s_bus_key_high_1>.
          CHECK <s_bus_key_high_1> IS ASSIGNED
            AND <s_bus_key_high_1> = <s_bus_key_low_1>.

          IF ic_bus_key_2 IS NOT INITIAL.
            ASSIGN COMPONENT ic_bus_key_2 OF STRUCTURE <st_rec_high> TO <s_bus_key_high_2>.
            CHECK <s_bus_key_high_2> IS ASSIGNED
              AND <s_bus_key_high_2> = <s_bus_key_low_2>.
          ENDIF.

          UNASSIGN: <s_langu_key_high>, <s_bus_key_high_1>, <s_bus_key_high_2>.
          lb_delete = abap_true.
          EXIT.
        ENDLOOP.
*     if found, remove the one with lowest priority
        IF lb_delete = abap_true.
          DELETE ct_records.
        ENDIF.
        UNASSIGN: <s_langu_key_low>, <s_bus_key_low_1>, <s_bus_key_low_2>.
      ENDLOOP.
      li_pos = li_pos - 1.
    ENDDO.

  ENDMETHOD.
METHOD get_account_determination.

  DATA: lc_company_code TYPE bukrs,
        lc_zlsch        LIKE LINE OF it_zlsch,
        lt_zlsch_selopt TYPE RANGE OF t042i-zlsch,
        lst_zlsch       LIKE LINE OF lt_zlsch_selopt,
        lt_zlsch        LIKE it_zlsch.

  lc_company_code = ic_company_code.
  lt_zlsch = it_zlsch.
  IF it_zlsch IS INITIAL.
    SPLIT 'U, X, R, P, A, T, F' AT ',' INTO TABLE lt_zlsch.
  ENDIF.

  lst_zlsch-sign    = 'I'.
  lst_zlsch-option  = 'EQ'.
  LOOP AT lt_zlsch INTO lc_zlsch.
    CONDENSE lc_zlsch.
    lst_zlsch-low = lc_zlsch.
    APPEND lst_zlsch TO lt_zlsch_selopt.
  ENDLOOP.

  SELECT * FROM t042i
    INTO TABLE et_rules
    WHERE zbukr = lc_company_code
      AND zlsch IN lt_zlsch_selopt.

ENDMETHOD.
  METHOD get_address.

    CALL FUNCTION 'ADDR_GET_COMPLETE'
      EXPORTING
        addrnumber              = ic_address_no
      IMPORTING
        addr1_complete          = est_address
      EXCEPTIONS
        parameter_error         = 1
        address_not_exist       = 2
        internal_error          = 3
        wrong_access_to_archive = 4
        address_blocked         = 5
        OTHERS                  = 6.

    ei_subrc = sy-subrc.

  ENDMETHOD.
  METHOD get_attachments.

    DATA: lt_connections   TYPE TABLE OF toav0,
          lst_connection   LIKE LINE OF lt_connections,
          ln_length        TYPE sapb-length,
          lt_content       TYPE TABLE OF tbl1024,
          lc_obj_type      TYPE toav0-sap_object,
          lc_obj_id        TYPE toav0-object_id,
          lst_toadv        TYPE toadv,
          lst_toadd        TYPE toadd,
          lc_objecttext    TYPE saearoname,
          lc_filename(255) TYPE c,
          lc_descr(60)     TYPE c,
          lst_attachment   LIKE LINE OF ct_attachments,
          lt_base64        LIKE lst_attachment-content,
          lt_mimetypes     LIKE STANDARD TABLE OF lst_attachment-mimetype.

    lc_obj_type = ic_doc_type.
    lc_obj_id   = ic_doc_number.
    CALL FUNCTION 'ARCHIV_GET_CONNECTIONS'
      EXPORTING
        objecttype    = lc_obj_type
        object_id     = lc_obj_id
      TABLES
        connections   = lt_connections
      EXCEPTIONS
        nothing_found = 1.
    CHECK sy-subrc = 0.
    SORT lt_connections BY ar_date DESCENDING.

    LOOP AT lt_connections INTO lst_connection.
      CLEAR: lst_attachment.

      SELECT SINGLE * FROM toadv
                      INTO lst_toadv
                      WHERE ar_object EQ lst_connection-ar_object.
      CHECK sy-subrc = 0.

      SELECT SINGLE *
             FROM toadd
             INTO CORRESPONDING FIELDS OF lst_toadd
             WHERE doc_type EQ lst_toadv-doc_type.
      CHECK sy-subrc = 0.

      lst_attachment-mimetype = lst_toadd-mimetype.
*   take only one attachment per MIMETYPE
      READ TABLE lt_mimetypes TRANSPORTING NO FIELDS WITH KEY table_line = lst_attachment-mimetype.
      IF sy-subrc = 0.
        CONTINUE.
      ELSE.
        APPEND lst_attachment-mimetype TO lt_mimetypes.
      ENDIF.

      IF zdyn_cl_bapi=>mo->archive_is_file_attr_active( ) = abap_true.
        SELECT SINGLE descr filename FROM ('TOAAT')
          INTO (lc_descr, lc_filename)
          WHERE arc_doc_id = lst_connection-arc_doc_id.
      ENDIF.

      SELECT SINGLE objecttext
             FROM toasp
             INTO lc_objecttext
             WHERE ar_object EQ lst_connection-ar_object
               AND language  EQ sy-langu.

      lst_attachment-name = lc_filename.
      IF lst_attachment-name IS INITIAL.
        CONCATENATE 'Invoice'(002) '_' ic_doc_number '.pdf' INTO lst_attachment-name.
      ENDIF.
      IF lc_descr IS NOT INITIAL.
        lst_attachment-description = lc_descr.
      ELSE.
        lst_attachment-description = lc_objecttext.
      ENDIF.

      CALL FUNCTION 'ARCHIVOBJECT_GET_TABLE'
        EXPORTING
          archiv_id                = lst_connection-archiv_id
          document_type            = lst_toadd-doc_type
          archiv_doc_id            = lst_connection-arc_doc_id
          compid                   = space
        IMPORTING
          binlength                = ln_length
        TABLES
          binarchivobject          = lt_content
        EXCEPTIONS
          error_archiv             = 1
          error_communicationtable = 2
          error_kernel             = 3
          OTHERS                   = 4.
      IF sy-subrc <> 0.
        RAISE error_occurred.
      ENDIF.

      bin_to_base64( EXPORTING  it_binary = lt_content
                                i_length  = ln_length
                     IMPORTING  et_base64 = lt_base64
                     EXCEPTIONS OTHERS    = 1 ).
      IF sy-subrc <> 0.
        RAISE error_occurred.
      ENDIF.
      lst_attachment-content = lt_base64.

      APPEND lst_attachment TO ct_attachments.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_bank_details.

    DATA: lc_company_code TYPE bukrs,
          lc_bank_key     TYPE t042i-hbkid,
          lc_account_id   TYPE t042i-hktid.

    lc_company_code = ic_company_code.
    lc_bank_key     = ic_bank_key.
    lc_account_id   = ic_account_id.

    CALL FUNCTION 'FKK_BANK_DATA_READ'
      EXPORTING
        i_bukrs         = lc_company_code
        i_hbkid         = lc_bank_key
        i_hktid         = lc_account_id
      IMPORTING
        e_t012          = est_house_bank
        e_t012k         = est_account
        e_bnka          = est_bank_master
      EXCEPTIONS
        not_found_t012  = 1
        not_found_t012k = 2
        not_found_bnka  = 3
        OTHERS          = 4.

  ENDMETHOD.
  METHOD get_bank_name.

    SELECT SINGLE banka INTO rc_name FROM bnka
            WHERE banks = ic_country_key
              AND bankl = ic_keys.

  ENDMETHOD.
  METHOD get_billing_doc.

    CALL FUNCTION 'LB_BIL_INV_OUTP_READ_PRTDATA'
      EXPORTING
        if_bil_number         = ic_doc_number
        is_print_data_to_read = ic_data_selection
        if_parvw              = ic_partner
        if_parnr              = ic_partner_role
        if_language           = ic_langu
      IMPORTING
        es_bil_invoice        = est_data
      EXCEPTIONS
        records_not_found     = 1
        records_not_requested = 2
        error_message         = 3
        OTHERS                = 4.
    IF sy-subrc = 1.
      RAISE records_not_found.
    ELSEIF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD get_billing_doc_pdf_nast.

    DATA: lst_print_data_to_read TYPE lbbil_print_data_to_read,
          lst_bill_data          TYPE lbbil_invoice,
          li_retcode             TYPE i,
          lc_function_name       TYPE rs38l_fnam,
          lc_device_type         TYPE rspoptype,
          lx_stream              TYPE xstring,
          li_size                TYPE sytabix,
          lst_nast               LIKE ist_nast,
          lst_control_param      TYPE ssfctrlop,
          lst_composer_param     TYPE ssfcompop,
          lst_recipient          TYPE swotobjid,
          lst_sender             TYPE swotobjid,
          lst_addr_key           TYPE addr_key,
          lst_lland              TYPE lland,
          lst_job_info           TYPE ssfcrescl,
          lt_pdf                 TYPE rsfbtltab,
          lx_root                TYPE REF TO cx_root.
    FIELD-SYMBOLS: <nast> TYPE any.

    lst_nast = ist_nast.

    PERFORM set_print_data_to_read IN PROGRAM rlb_invoice USING ic_smartform
                                   CHANGING lst_print_data_to_read
                                   li_retcode.
    IF li_retcode <> 0.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                      ic_msgno = '090'
                                      ic_msgv1 = 'SET_PRINT_DATA_TO_READ'
                                      ic_msgv2 = li_retcode ).
*   message e090(abadr).
      RAISE error_occurred.
    ENDIF.

    get_billing_doc( EXPORTING  ic_doc_number      = lst_nast-objky
                                ic_data_selection  = lst_print_data_to_read
                                ic_partner         = lst_nast-parvw
                                ic_partner_role    = lst_nast-parnr
                                ic_langu           = lst_nast-spras
                     IMPORTING  est_data           = lst_bill_data
                     EXCEPTIONS records_not_found  = 1
                     OTHERS                        = 2 ).
    IF sy-subrc = 1.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ZDYN_WS'
                                      ic_msgno = '021' ).
*   message e021(zdyn_ws).
      RAISE error_occurred.
    ELSEIF sy-subrc <> 0.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                      ic_msgno = '090'
                                      ic_msgv1 = 'LB_BIL_INV_OUTP_READ_PRTDATA'
                                      ic_msgv2 = sy-subrc ).
*   message e090(abadr).
      RAISE error_occurred.
    ENDIF.

    ASSIGN ('(RLB_INVOICE)NAST') TO <nast>.
    IF <nast> IS ASSIGNED.
      <nast> = lst_nast.
    ENDIF.

* partner adress
    PERFORM get_addr_key IN PROGRAM  rlb_invoice
                            USING    lst_bill_data-hd_adr
                            CHANGING lst_addr_key.

* delivery land
* this form name depends on the SAP system version
    TRY.
        PERFORM get_dlv_land IN PROGRAM  rlb_invoice
                                USING    lst_bill_data-hd_gen
                                CHANGING lst_lland.
      CATCH cx_root INTO lx_root.
        PERFORM get_dlv-land IN PROGRAM  rlb_invoice
                                USING    lst_bill_data-hd_gen
                                CHANGING lst_lland.
    ENDTRY.
* control parameters, sender, recipient
    PERFORM set_print_param IN PROGRAM rlb_invoice
                            USING    lst_addr_key
                                     lst_lland
                            CHANGING lst_control_param
                                     lst_composer_param
                                     lst_recipient
                                     lst_sender
                                     li_retcode.
    IF li_retcode <> 0.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                      ic_msgno = '090'
                                      ic_msgv1 = 'SET_PRINT_PARAM'
                                      ic_msgv2 = li_retcode ).
*   message e090(abadr).
      RAISE error_occurred.
    ENDIF.

    CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
      EXPORTING
        formname           = ic_smartform
      IMPORTING
        fm_name            = lc_function_name
      EXCEPTIONS
        no_form            = 1
        no_function_module = 2
        OTHERS             = 3.
    IF sy-subrc = 1.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ZDYN_WS'
                                      ic_msgno = '022' ).
*   message e022(zdyn_ws).
      RAISE error_occurred.
    ELSEIF sy-subrc <> 0.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                      ic_msgno = '090'
                                      ic_msgv1 = 'SSF_FUNCTION_MODULE_NAME'
                                      ic_msgv2 = sy-subrc ).
*   message e090(abadr).
      RAISE error_occurred.
    ENDIF.

    lst_composer_param-tdcopies  = 1.
* Printing, no archiving
    lst_composer_param-tdarmod   = 1.

    IF lst_nast-anzal = 0.
      lst_nast-anzal = 1.
    ENDIF.
    DO lst_nast-anzal TIMES.
*   In case of repetition only one time archiving
*   TDARMODE = 1 - print only, 2 - archive only, 3 - print and archive
      IF sy-index > 1 AND lst_nast-tdarmod = 3.
        lst_nast-tdarmod = 1.
        lst_composer_param-tdarmod = 1.
      ENDIF.

      lst_composer_param-xsfoutmode = 'A'.
      lst_composer_param-xsfcmode   = 'X'.
      lst_composer_param-tdimmed    = 'X'.

      lst_control_param-no_dialog   = 'X'.
      lst_control_param-getotf      = 'X'.

*   Actual smartform call
      CALL FUNCTION lc_function_name
        EXPORTING
          control_parameters = lst_control_param
          output_options     = lst_composer_param
          is_bil_invoice     = lst_bill_data
          is_nast            = lst_nast
          is_repeat          = lst_nast-repet
        IMPORTING
          job_output_info    = lst_job_info
        EXCEPTIONS
          formatting_error   = 1
          internal_error     = 2
          send_error         = 3
          user_canceled      = 4
          OTHERS             = 5.
      IF sy-subrc <> 0.
        zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                        ic_msgno = '090'
                                        ic_msgv1 = lc_function_name
                                        ic_msgv2 = sy-subrc ).
*     message e090(abadr).
        RAISE error_occurred.
      ENDIF.
    ENDDO.

    CALL FUNCTION 'CONVERT_OTF'
      EXPORTING
        format                = 'PDF'
      IMPORTING
        bin_filesize          = li_size
        bin_file              = ex_stream
      TABLES
        otf                   = lst_job_info-otfdata
        lines                 = lt_pdf
      EXCEPTIONS
        err_max_linewidth     = 1
        err_format            = 2
        err_conv_not_possible = 3
        err_bad_otf           = 4
        OTHERS                = 5.
    IF sy-subrc <> 0.
      zdyn_cl_msg=>add_msg( EXPORTING ic_msgid = 'ABADR'
                                      ic_msgno = '090'
                                      ic_msgv1 = 'CONVERT_OTF'
                                      ic_msgv2 = sy-subrc ).
*   message e090(abadr).
      RAISE error_occurred.
    ENDIF.

    CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
      EXPORTING
        buffer        = ex_stream
      IMPORTING
        output_length = ei_bin_length
      TABLES
        binary_tab    = et_data.

  ENDMETHOD.
METHOD get_billing_partner.

  DATA: lc_parvw TYPE parvw,
        lc_vbeln TYPE vbeln.

  lc_parvw = ic_role.
  lc_vbeln = ic_billing_doc.

  SELECT SINGLE kunnr FROM vbpa INTO ec_billing_partner
    WHERE vbeln = lc_vbeln AND
          posnr = '00000'  AND
          parvw = lc_parvw.

ENDMETHOD.
  METHOD get_bseg.

    DATA: lc_belnr TYPE bseg-belnr,
          lc_koart TYPE bseg-koart.

    lc_belnr = ic_doc_num.
    lc_koart = ic_account_type.

    SELECT SINGLE * FROM bseg INTO est_bseg
      WHERE belnr = lc_belnr
        AND koart = lc_koart.                           "#EC CI_NOFIRST

  ENDMETHOD.
  METHOD get_bsid_bsad.

    DATA: lc_vbeln TYPE bseg-vbeln,
          lc_bukrs TYPE bseg-bukrs.

    lc_vbeln = ic_doc_num.

    IF ic_comp_code IS INITIAL.
      SELECT SINGLE * FROM bsid INTO CORRESPONDING FIELDS OF est_bseg
        WHERE vbeln = lc_vbeln.                         "#EC CI_NOFIELD
      IF sy-subrc <> 0.
        SELECT SINGLE * FROM bsad INTO CORRESPONDING FIELDS OF est_bseg
          WHERE vbeln = lc_vbeln.                       "#EC CI_NOFIELD
      ENDIF.
    ELSE.
      lc_bukrs = ic_comp_code.
      SELECT SINGLE * FROM bsid INTO CORRESPONDING FIELDS OF est_bseg
        WHERE bukrs = lc_bukrs
          AND vbeln = lc_vbeln.                         "#EC CI_NOFIRST
      IF sy-subrc <> 0.
        SELECT SINGLE * FROM bsad INTO CORRESPONDING FIELDS OF est_bseg
          WHERE bukrs = lc_bukrs
            AND vbeln = lc_vbeln.                       "#EC CI_NOFIRST
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD get_company_codes.

    SELECT bukrs FROM t001 INTO TABLE et_company_codes WHERE bukrs IN it_sel_opt.

  ENDMETHOD.
  METHOD get_company_details.

    DATA: lc_company_code TYPE bukrs.

    lc_company_code = ic_company_code.

    CALL FUNCTION 'FI_COMPANY_CODE_DATA'
      EXPORTING
        i_bukrs      = lc_company_code
      IMPORTING
        e_t001       = est_company
      EXCEPTIONS
        system_error = 1
        OTHERS       = 2.

    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD get_controlling_area.

    CALL FUNCTION 'KOKRS_GET_FROM_BUKRS'
      EXPORTING
        i_bukrs = ic_comp_code
      IMPORTING
        e_kokrs = ec_ctrl_area
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD get_cost_centers.

    IF NOT ic_ctrl_area IS INITIAL.
      SELECT * FROM m_kosts
        INTO TABLE et_cost_centers
        WHERE spras IN it_sel_langu AND
              kokrs = ic_ctrl_area AND
              bukrs = ic_comp_code AND
              datbi >= sy-datlo AND
              kostl IN it_sel_opt.
    ELSE.
      SELECT * FROM m_kosts
        INTO TABLE et_cost_centers
        WHERE spras IN it_sel_langu AND
              datbi >= sy-datlo AND
              kostl IN it_sel_opt.
    ENDIF.

    find_for_langu( EXPORTING ic_bus_key_1 = 'KOSTL'
                              ic_bus_key_2 = 'BUKRS'
                              ic_langu_key = 'SPRAS'
                              it_sel_langu = it_sel_langu
                    CHANGING  ct_records   = et_cost_centers ).

  ENDMETHOD.
  METHOD get_currency_texts.

    SELECT * FROM tcurt INTO TABLE et_texts
      WHERE spras IN it_sel_langu
        AND waers IN it_sel_opt.                        "#EC CI_GENBUFF

    find_for_langu( EXPORTING ic_bus_key_1 = 'WAERS'
                              ic_langu_key = 'SPRAS'
                              it_sel_langu = it_sel_langu
                    CHANGING  ct_records   = et_texts ).

  ENDMETHOD.
  METHOD get_current_timestamp.

    GET TIME STAMP FIELD rd_timestamp.

  ENDMETHOD.
  METHOD get_customer_banks.

    SELECT * FROM knbk INTO TABLE et_banks
      WHERE kunnr = ic_customer.

  ENDMETHOD.
  METHOD get_customer_details .

    CHECK ic_customer IS NOT INITIAL.

    CALL FUNCTION 'KNA1_SINGLE_READ'
      EXPORTING
        kna1_kunnr = ic_customer
      IMPORTING
        wkna1      = est_details
      EXCEPTIONS
        OTHERS     = 0.

  ENDMETHOD.
METHOD get_customer_tax_code.

  DATA: lst_kna1 TYPE kna1.

  get_customer_details( EXPORTING ic_customer = ic_number
                        IMPORTING est_details = lst_kna1 ).

  MOVE-CORRESPONDING lst_kna1 TO rst_codes.

ENDMETHOD.
  METHOD get_customers.

    DATA: lt_where    TYPE rsds_where_tab,
          lt_safe_where TYPE rsds_where_tab,
          lc_where    type string,
          lc_safe_where    type string,
          lt_dyn_sel  LIKE it_dyn_sel,
          lt_tabnames TYPE tttabname.

    IF it_dyn_sel IS NOT INITIAL.
      lt_dyn_sel = it_dyn_sel.
      APPEND 'KNA1' TO lt_tabnames.
      zdyn_cl_db=>mo->select_tables_in_dyn_sel( EXPORTING it_tabnames = lt_tabnames
                                                CHANGING  ct_dyn_sel  = lt_dyn_sel ).
      zdyn_cl_db=>mo->get_where_clause( EXPORTING it_dyn_sel  = lt_dyn_sel
                                        IMPORTING et_where    = lt_where ).
      loop at lt_where into lc_where.
        lc_safe_where = cl_abap_dyn_prg=>ESCAPE_QUOTES_STR( lc_where ).
        append lc_safe_where to lt_safe_where.
      ENDLOOP.
    ENDIF.

    IF it_sel_comp_codes IS NOT INITIAL.
      SELECT * FROM zdyn_ws_cmd JOIN kna1 ON kna1~kunnr = zdyn_ws_cmd~kunnr
        INTO CORRESPONDING FIELDS OF TABLE et_customers
        WHERE zdyn_ws_cmd~bukrs IN it_sel_comp_codes
          AND zdyn_ws_cmd~kunnr IN it_sel_opt
          AND (lt_safe_where).
    ELSE.
      SELECT * FROM zdyn_ws_cmd JOIN kna1 ON kna1~kunnr = zdyn_ws_cmd~kunnr
        INTO CORRESPONDING FIELDS OF TABLE et_customers
        WHERE zdyn_ws_cmd~kunnr IN it_sel_opt
          AND (lt_safe_where).
      SORT et_customers BY kunnr erdat DESCENDING nation ASCENDING.
      DELETE ADJACENT DUPLICATES FROM et_customers COMPARING kunnr.
      RETURN.
    ENDIF.

    SORT et_customers BY kunnr bukrs nation ASCENDING.
    DELETE ADJACENT DUPLICATES FROM et_customers COMPARING kunnr bukrs.

  ENDMETHOD.
  METHOD get_duedate.

    DATA: lst_faede TYPE faede.

    lst_faede-koart = 'D'. " customer
    lst_faede-zfbdt = id_baseline_date.
    lst_faede-zbd1t = ii_discount_days_1.
    lst_faede-zbd2t = ii_discount_days_2.
    lst_faede-zbd3t = ii_discount_days_3.

    CALL FUNCTION 'DETERMINE_DUE_DATE'
      EXPORTING
        i_faede = lst_faede
      IMPORTING
        e_faede = lst_faede
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    ed_duedate = lst_faede-netdt.

  ENDMETHOD.
  METHOD get_email_from_adr6.

    DATA: lc_email TYPE ad_smtpadr.

    IF ic_adrnr IS NOT INITIAL.
      SELECT SINGLE smtp_addr FROM adr6 INTO lc_email
              WHERE addrnumber = ic_adrnr.
      IF sy-subrc = 0.
        rs_email = lc_email.
      ENDIF.
    ELSEIF ic_pernr IS NOT INITIAL.
      SELECT SINGLE smtp_addr FROM adr6 INTO lc_email
              WHERE persnumber = ic_pernr.              "#EC CI_NOFIRST
      IF sy-subrc = 0.
        rs_email = lc_email.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD get_exchange_rate.

    CALL FUNCTION 'READ_EXCHANGE_RATE'
      EXPORTING
        date             = id_date
        foreign_currency = ic_foreign_currency
        local_currency   = ic_local_currency
        exact_date       = ib_exact_date
      IMPORTING
        exchange_rate    = ec_exchange_rate
      EXCEPTIONS
        OTHERS           = 1.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD get_gl_account_details.

    DATA: lt_skat TYPE STANDARD TABLE OF skat.

    SELECT * FROM skat INTO TABLE lt_skat
      WHERE spras IN it_sel_langu AND
            ktopl = ic_chart_of_accounts AND
            saknr = ic_gl_account.                      "#EC CI_GENBUFF

    CHECK lt_skat IS NOT INITIAL.

    find_for_langu( EXPORTING ic_bus_key_1 = 'SAKNR'
                              ic_bus_key_2 = 'KTOPL'
                              ic_langu_key = 'SPRAS'
                              it_sel_langu = it_sel_langu
                    CHANGING  ct_records   = lt_skat ).
    READ TABLE lt_skat INTO est_details INDEX 1.

  ENDMETHOD.
  METHOD get_gl_accounts.

    IF NOT ic_comp_code IS INITIAL.
      SELECT * FROM gl_acct_cc
        INTO TABLE et_gl_accounts
        WHERE bukrs = ic_comp_code AND
              saknr IN it_sel_opt.
    ELSE.
      SELECT * FROM gl_acct_cc
        INTO TABLE et_gl_accounts
        WHERE bukrs IN it_sel_comp_codes AND
              saknr IN it_sel_opt.
    ENDIF.

  ENDMETHOD.
  METHOD get_iban.

    DATA: lc_bankl TYPE bankn35.

    lc_bankl = ic_bankl.

    IF est_iban IS REQUESTED.
      CLEAR est_iban.
      SELECT SINGLE * INTO est_iban FROM tiban
              WHERE banks = ic_banks
                AND bankl = lc_bankl
                AND bankn = ic_bankn
                AND bkont = ic_bkont.
    ELSE.
      SELECT SINGLE iban INTO ec_iban FROM tiban
              WHERE banks = ic_banks
                AND bankl = lc_bankl
                AND bankn = ic_bankn
                AND bkont = ic_bkont.
    ENDIF.

  ENDMETHOD.
  METHOD get_idoc_control_record.

    DATA: lc_arckey     TYPE idoccarkey.

    CONCATENATE 'Remote Addr:' is_external_doc_id
                ';Content_Type:' zdyn_if_rest_data=>con_mimetype_xml '%' INTO lc_arckey.
    SELECT SINGLE * FROM edidc INTO es_record
                    WHERE arckey LIKE lc_arckey.        "#EC CI_NOFIELD
    IF sy-subrc <> 0.
      CLEAR lc_arckey.
      CONCATENATE 'Address' is_external_doc_id
                  ';Content%' INTO lc_arckey.
      SELECT SINGLE * FROM edidc INTO es_record
                      WHERE arckey LIKE lc_arckey.      "#EC CI_NOFIELD
    ENDIF.

  ENDMETHOD.
  METHOD get_konv.

    DATA: ln_cond_numb TYPE knumv.

    ln_cond_numb = in_cond_numb.

    SELECT * FROM konv INTO TABLE et_konv
      WHERE knumv = in_cond_numb.

    zdyn_cl_system=>mo->move_corresponding_tab( EXPORTING it_input  = et_konv
                                                CHANGING  ct_output = et_komv ).

  ENDMETHOD.
  METHOD get_local_currency.

    SELECT SINGLE waers FROM t001 INTO rc_currency
          WHERE bukrs = ic_comp_code.

  ENDMETHOD.
  METHOD get_napr.

    SELECT SINGLE sform FROM tnapr INTO rc_smartform
      WHERE kschl = ic_output_type
        AND nacha = ic_trans_medium
        AND kappl = ic_application.

  ENDMETHOD.
  METHOD get_nast.

    IF ic_output_type IS NOT INITIAL.
      SELECT SINGLE * FROM nast INTO est_nast
        WHERE objky = ic_doc_number
          AND kappl = ic_application
          AND kschl = ic_output_type.
    ELSE.
      SELECT SINGLE * FROM nast INTO est_nast
        WHERE objky = ic_doc_number
          AND kappl = ic_application.
    ENDIF.

  ENDMETHOD.
  METHOD get_orders.

    SELECT aufnr bukrs ktext loekz erdat aedat FROM aufk INTO TABLE et_orders
         WHERE aufnr IN it_sel_opt
           AND bukrs IN it_sel_comp_codes.

  ENDMETHOD.
METHOD get_payment_data.

  DATA: lc_vbeln TYPE vbeln,
        lc_zlsch TYPE schzw_bseg,  " payment means
        lc_kunnr TYPE kunnr,
        lc_bukrs TYPE bukrs,
        lc_zwels TYPE dzwels.

  lc_vbeln = ic_billing_doc.
  lc_kunnr = ic_billing_partner.
  lc_bukrs = ic_company_code.

  SELECT SINGLE zlsch FROM vbrk INTO lc_zlsch
         WHERE  vbeln  = lc_vbeln.

  IF lc_zlsch IS NOT INITIAL.
    SELECT SINGLE hbkid INTO ec_bank_id FROM knb1
           WHERE  kunnr  = lc_kunnr
           AND    bukrs  = lc_bukrs.
    APPEND lc_zlsch TO et_payment_methods.
  ELSE.
    SELECT SINGLE zwels hbkid INTO (lc_zwels, ec_bank_id) FROM  knb1
           WHERE  kunnr  = lc_kunnr
           AND    bukrs  = lc_bukrs.

    DO 10 TIMES.
      IF lc_zwels+0(1) EQ space.
        EXIT.
      ELSE.
        MOVE lc_zwels+0(1) TO lc_zlsch.
        APPEND lc_zlsch TO et_payment_methods.
      ENDIF.
      SHIFT lc_zwels  LEFT.
    ENDDO.
    CLEAR lc_zwels.
  ENDIF.

ENDMETHOD.
  METHOD get_payment_terms.

    SELECT * FROM t052 INTO TABLE et_terms
             WHERE zterm IN it_sel_opt.

  ENDMETHOD.
  METHOD get_po_list.

    DATA: BEGIN OF lst_po,
            ebeln TYPE ebeln,
          END OF lst_po.
    DATA: lt_po          LIKE STANDARD TABLE OF lst_po,
          lt_objectid    TYPE STANDARD TABLE OF cdobjectv,
          ld_change_date LIKE id_change_date,
          lt_sel_bukrs   TYPE yt_range_bukrs,
          lst_sel_bukrs  LIKE LINE OF lt_sel_bukrs.

    FIELD-SYMBOLS: <objectid> TYPE cdobjectv.

    lt_sel_bukrs = it_sel_comp_codes.
    IF ic_comp_code IS NOT INITIAL.
      lst_sel_bukrs-sign = 'I'.
      lst_sel_bukrs-option = 'EQ'.
      lst_sel_bukrs-low = ic_comp_code.
      APPEND lst_sel_bukrs TO lt_sel_bukrs.
    ENDIF.

    IF NOT id_change_date IS INITIAL.
      ld_change_date = id_change_date.
      IF ld_change_date = sy-datlo.
        ld_change_date = sy-datlo - 1.
      ENDIF.
    ENDIF.

    IF ld_change_date IS NOT INITIAL.
*   new entries in PO history
      SELECT ebeln FROM ekbe INTO CORRESPONDING FIELDS OF TABLE lt_po
            WHERE budat >= ld_change_date.              "#EC CI_NOFIELD
*   changed POs
      SELECT objectid FROM cdhdr INTO TABLE lt_objectid
        WHERE objectclas EQ 'EINKBELEG'
          AND udate      >= ld_change_date.
      IF sy-subrc = 0.
        SORT lt_objectid.
        DELETE ADJACENT DUPLICATES FROM lt_objectid.
        LOOP AT lt_objectid ASSIGNING <objectid>.
          lst_po-ebeln = <objectid>.
          APPEND lst_po TO lt_po.
        ENDLOOP.
      ENDIF.
      IF lt_po IS NOT INITIAL.
        SORT lt_po.
        DELETE ADJACENT DUPLICATES FROM lt_po.
        SELECT ebeln FROM ekko INTO TABLE et_po_list
                     FOR ALL ENTRIES IN lt_po
                     WHERE ebeln = lt_po-ebeln
                       AND ebeln IN it_sel_po
                       AND bukrs IN lt_sel_bukrs
                       AND loekz  = abap_false
                       AND memory = abap_false.
      ENDIF.
*   add new POs
      CLEAR lt_po.
      SELECT ebeln FROM ekko INTO TABLE lt_po
                   WHERE ebeln IN it_sel_po
                     AND bukrs IN lt_sel_bukrs
                     AND aedat >= ld_change_date
                     AND loekz  = abap_false
                     AND memory = abap_false.
      APPEND LINES OF lt_po TO et_po_list.
      SORT et_po_list.
      DELETE ADJACENT DUPLICATES FROM et_po_list.
    ELSEIF it_sel_create_date IS NOT INITIAL.
      SELECT ebeln FROM ekko INTO TABLE et_po_list
                   WHERE ebeln IN it_sel_po
                     AND bukrs IN lt_sel_bukrs
                     AND aedat IN it_sel_create_date
                     AND loekz  = abap_false
                     AND memory = abap_false.
    ELSE.
      SELECT ebeln FROM ekko INTO TABLE et_po_list
                   WHERE ebeln IN it_sel_po
                     AND bukrs IN lt_sel_bukrs
                     AND loekz  = abap_false
                     AND memory = abap_false.
    ENDIF.

  ENDMETHOD.
  METHOD get_sales_doc_numbers.

    TYPES: BEGIN OF yst_doc_with_date,
             doc_no        TYPE vbrk-vbeln,
             creation_date TYPE vbrk-erdat,
             creation_time TYPE vbrk-erzet,
           END OF yst_doc_with_date.
    DATA: lt_doc_with_date TYPE STANDARD TABLE OF yst_doc_with_date,
          lt_dyn_sel       LIKE it_dyn_sel,
          lt_tabnames      TYPE tttabname,
          lt_where         TYPE rsds_where_tab.
    FIELD-SYMBOLS: <st_doc_with_date> TYPE yst_doc_with_date.

    zdyn_cl_msg=>add_to_call_stack( ).

* just in case to not to select too much
    CHECK it_sel_sales_doc    IS NOT INITIAL
       OR it_sel_doc_type     IS NOT INITIAL
       OR it_sel_comp_code    IS NOT INITIAL
       OR it_sel_customer     IS NOT INITIAL
       OR it_sel_create_date  IS NOT INITIAL
       OR it_sel_application  IS NOT INITIAL
       OR it_sel_msg_type     IS NOT INITIAL
       OR it_dyn_sel          IS NOT INITIAL.

    IF it_dyn_sel IS NOT INITIAL.
      lt_dyn_sel = it_dyn_sel.
*   just in case the dynamic selection contained unwanted tables
      APPEND 'VBRK' TO lt_tabnames.
      APPEND 'KNA1' TO lt_tabnames.
      zdyn_cl_db=>mo->select_tables_in_dyn_sel( EXPORTING it_tabnames = lt_tabnames
                                                CHANGING  ct_dyn_sel  = lt_dyn_sel ).
      zdyn_cl_db=>mo->get_where_clause( EXPORTING it_dyn_sel  = lt_dyn_sel
                                        IMPORTING et_where    = lt_where ).
    ENDIF.

    TRY.
*   if NAST keys are provided, the JOIN should be INNER
*   but if they are not, there should be no join with NAST at all
        IF it_sel_application IS NOT INITIAL OR it_sel_msg_type IS NOT INITIAL.
          SELECT DISTINCT vbrk~vbeln vbrk~erdat vbrk~erzet FROM vbrk
              JOIN nast ON nast~objky = vbrk~vbeln
              JOIN vbpa ON vbpa~vbeln = vbrk~vbeln AND vbpa~posnr = '000000' AND vbpa~parvw = 'RE'
              JOIN kna1 ON kna1~kunnr = vbpa~kunnr
              INTO TABLE lt_doc_with_date
              WHERE vbrk~vbeln IN it_sel_sales_doc
                AND vbrk~fkart IN it_sel_doc_type
                AND vbrk~bukrs IN it_sel_comp_code
                AND vbpa~kunnr IN it_sel_customer
                AND vbrk~erdat IN it_sel_create_date
                AND nast~kappl IN it_sel_application
                AND nast~kschl IN it_sel_msg_type
                AND (lt_where)
              ORDER BY vbrk~vbeln.
        ELSE.
          SELECT DISTINCT vbrk~vbeln vbrk~erdat vbrk~erzet FROM vbrk
              JOIN vbpa ON vbpa~vbeln = vbrk~vbeln AND vbpa~posnr = '000000' AND vbpa~parvw = 'RE'
              JOIN kna1 ON kna1~kunnr = vbpa~kunnr
              INTO TABLE lt_doc_with_date
              WHERE vbrk~vbeln IN it_sel_sales_doc
                AND vbrk~fkart IN it_sel_doc_type
                AND vbrk~bukrs IN it_sel_comp_code
                AND vbpa~kunnr IN it_sel_customer
                AND vbrk~erdat IN it_sel_create_date
                AND (lt_where)
              ORDER BY vbrk~vbeln.
        ENDIF.
      CATCH cx_sy_open_sql_db.
        zdyn_cl_msg=>add_msg( EXPORTING ic_msgty = 'E'
                                        ic_msgid = 'ZDYN_WS'
                                        ic_msgno = '039' ).
    ENDTRY.

    LOOP AT lt_doc_with_date ASSIGNING <st_doc_with_date>.
      IF ib_use_register = abap_true.
        CHECK zdyn_cl_db=>mo->is_document_valid( ic_doc_type    = ic_doc_type
                                                 ic_number      = <st_doc_with_date>-doc_no
                                                 id_create_date = <st_doc_with_date>-creation_date
                                                 id_create_time = <st_doc_with_date>-creation_time ) = abap_true.
      ENDIF.
      APPEND <st_doc_with_date>-doc_no TO et_sales_docs.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_sales_documents.

    DATA: lst_sales_doc LIKE LINE OF et_sales_docs,
          lt_vbrk       TYPE SORTED TABLE OF zdyn_ws_vbrk WITH NON-UNIQUE KEY vbeln blart,
          lt_sel_date   LIKE RANGE OF id_create_date,
          lst_sel_date  LIKE LINE OF lt_sel_date.
    FIELD-SYMBOLS: <st_vbrk>    TYPE zdyn_ws_vbrk,
                   <st_vbrk_rv> TYPE zdyn_ws_vbrk.

    zdyn_cl_msg=>add_to_call_stack( ).

* just in case to not to select too much
    CHECK it_sel_sales_doc IS NOT INITIAL
      OR id_create_date IS NOT INITIAL.

* Find first the documents that have RE accounting document
    IF id_create_date IS NOT INITIAL.
      lst_sel_date-sign   = 'I'.
      lst_sel_date-option = 'EQ'.
      lst_sel_date-low    = id_create_date.
      APPEND lst_sel_date TO lt_sel_date.
    ENDIF.

* A key field from BKPF (BUKRS) has to be used as the first one in the JOIN clause.
* If join is done on XBLNR, the selection takes plenty of time.
* But to find AP and AR documents in BKPF, different reference fields from VBRK have to be used:
* - to find an AP document in BKPF, the BUKRS field from VBRK has to be used.
* - to find an AR document in BKPF, the KUNRG field from VBRK has to be used.
* That means two SELECTs finally, since it's not possible to create a JOIN with OR.
    SELECT vbrk~vbeln vbrk~erdat vbrk~erzet vbrk~fkdat vbrk~rfbsk vbrk~bukrs vbrk~stceg vbrk~kunrg bkpf~belnr bkpf~blart
      FROM vbrk
      JOIN bkpf ON vbrk~bukrs = bkpf~bukrs
                AND vbrk~xblnr = bkpf~xblnr
      INTO CORRESPONDING FIELDS OF TABLE lt_vbrk
       WHERE vbrk~vbeln IN it_sel_sales_doc
         AND vbrk~bukrs IN it_sel_comp_code
         AND vbrk~erdat IN lt_sel_date
         AND bkpf~blart = 'RV'.

    SELECT vbrk~vbeln vbrk~erdat vbrk~erzet vbrk~fkdat vbrk~rfbsk vbrk~bukrs vbrk~stceg vbrk~kunrg bkpf~belnr bkpf~blart
      FROM vbrk
      JOIN bkpf ON vbrk~kunrg = bkpf~bukrs
                AND vbrk~xblnr = bkpf~xblnr
      APPENDING CORRESPONDING FIELDS OF TABLE lt_vbrk
       WHERE vbrk~vbeln IN it_sel_sales_doc
         AND vbrk~bukrs IN it_sel_comp_code
         AND vbrk~erdat IN lt_sel_date
         AND bkpf~blart = 'RE'.

* find pairs where records with both RE and RV document type exist
    LOOP AT lt_vbrk ASSIGNING <st_vbrk> WHERE blart = 'RE'. "#EC CI_SORTSEQ
      READ TABLE lt_vbrk ASSIGNING <st_vbrk_rv>
        WITH KEY vbeln = <st_vbrk>-vbeln
                 blart = 'RV'.
      CHECK sy-subrc = 0.
      CLEAR lst_sales_doc.
      lst_sales_doc-sales_doc_nr  = <st_vbrk>-vbeln.
      lst_sales_doc-doc_cr_date   = <st_vbrk>-erdat.
      lst_sales_doc-doc_cr_time   = <st_vbrk>-erzet.
      lst_sales_doc-doc_date      = <st_vbrk>-fkdat.
      lst_sales_doc-doc_status    = <st_vbrk>-rfbsk.
      lst_sales_doc-comp_code     = <st_vbrk>-bukrs.
      lst_sales_doc-comp_code_vat = <st_vbrk>-stceg.
      lst_sales_doc-partner       = <st_vbrk>-kunrg.
      lst_sales_doc-ap_doc_nr     = <st_vbrk>-belnr.
      lst_sales_doc-ar_doc_nr     = <st_vbrk_rv>-belnr.
      APPEND lst_sales_doc TO et_sales_docs.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_sales_documents2.

    TYPES: BEGIN OF yt_vbeln,
             vbeln TYPE vbeln,
           END OF yt_vbeln.
    DATA: lc_ref_doc_no TYPE xblnr,
          lst_sales_doc LIKE LINE OF et_sales_docs,
          lt_vbeln      TYPE STANDARD TABLE OF yt_vbeln,
          lt_vbrk       TYPE SORTED TABLE OF zdyn_ws_vbrk WITH NON-UNIQUE KEY vbeln blart.
    FIELD-SYMBOLS: <st_vbrk>    TYPE zdyn_ws_vbrk,
                   <st_vbrk_rv> TYPE zdyn_ws_vbrk.

    zdyn_cl_msg=>add_to_call_stack( ).

* just in case to not to select too much
    CHECK it_sel_sales_doc IS NOT INITIAL
      OR id_create_date IS NOT INITIAL.

* Find first the documents that have RE accounting document
    IF id_create_date IS NOT INITIAL.
      SELECT DISTINCT vbeln FROM zdyn_ws_vbrk
        INTO TABLE lt_vbeln
        WHERE vbeln IN it_sel_sales_doc
          AND bukrs IN it_sel_comp_code
          AND erdat = id_create_date
          AND blart = 'RE'
        ORDER BY vbeln.
    ELSE.
      SELECT DISTINCT vbeln FROM zdyn_ws_vbrk
        INTO TABLE lt_vbeln
       WHERE vbeln IN it_sel_sales_doc
         AND bukrs IN it_sel_comp_code
         AND blart = 'RE'
       ORDER BY vbeln.
    ENDIF.

    IF lt_vbeln IS INITIAL.
      RETURN.
    ENDIF.

    SELECT DISTINCT vbeln erdat erzet fkdat rfbsk bukrs stceg kunrg belnr blart FROM zdyn_ws_vbrk
      INTO CORRESPONDING FIELDS OF TABLE lt_vbrk
      FOR ALL ENTRIES IN lt_vbeln
      WHERE vbeln = lt_vbeln-vbeln
        AND ( blart = 'RV' OR blart = 'RE' ).

* find pairs where records with both RE and RV document type exist
    LOOP AT lt_vbrk ASSIGNING <st_vbrk> WHERE blart = 'RE'. "#EC CI_SORTSEQ
      READ TABLE lt_vbrk ASSIGNING <st_vbrk_rv>
        WITH KEY vbeln = <st_vbrk>-vbeln
                 blart = 'RV'.
      CHECK sy-subrc = 0.
      CLEAR lst_sales_doc.
      lst_sales_doc-sales_doc_nr  = <st_vbrk>-vbeln.
      lst_sales_doc-doc_cr_date   = <st_vbrk>-erdat.
      lst_sales_doc-doc_cr_time   = <st_vbrk>-erzet.
      lst_sales_doc-doc_date      = <st_vbrk>-fkdat.
      lst_sales_doc-doc_status    = <st_vbrk>-rfbsk.
      lst_sales_doc-comp_code     = <st_vbrk>-bukrs.
      lst_sales_doc-comp_code_vat = <st_vbrk>-stceg.
      lst_sales_doc-partner       = <st_vbrk>-kunrg.
      lst_sales_doc-ap_doc_nr     = <st_vbrk>-belnr.
      lst_sales_doc-ar_doc_nr     = <st_vbrk_rv>-belnr.
      APPEND lst_sales_doc TO et_sales_docs.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_swift.

    SELECT SINGLE swift INTO rc_swift FROM bnka
            WHERE banks = ic_banks
              AND bankl = ic_bankl.

  ENDMETHOD.
  METHOD get_tax_code_text.

    DATA: lt_texts TYPE STANDARD TABLE OF t007s,
          lst_text LIKE LINE OF lt_texts.

    SELECT * FROM t007s INTO TABLE lt_texts
                        WHERE spras IN it_sel_langu
                          AND kalsm = ic_procedure
                          AND mwskz = ic_tax_code.      "#EC CI_GENBUFF
    CHECK lt_texts IS NOT INITIAL.

    find_for_langu( EXPORTING ic_bus_key_1 = 'MWSKZ'
                              ic_bus_key_2 = 'KALSM'
                              ic_langu_key = 'SPRAS'
                              it_sel_langu = it_sel_langu
                    CHANGING  ct_records   = lt_texts ).

    READ TABLE lt_texts INTO lst_text INDEX 1.
    ec_text = lst_text-text1.

  ENDMETHOD.
  METHOD get_tax_codes.

    TYPES:
      BEGIN OF yst_procedure,
        kalsm TYPE kalsm_d,
        bukrs TYPE bukrs,
      END OF yst_procedure.

    DATA: lst_procedure TYPE yst_procedure,
          lt_procedures LIKE STANDARD TABLE OF lst_procedure,
          lst_tax_code  LIKE LINE OF et_tax_codes,
          lc_mwskz      TYPE mwskz,
          lt_mwskz      LIKE STANDARD TABLE OF lc_mwskz.

    SELECT DISTINCT t5~kalsm t1~bukrs FROM t005 AS t5 INNER JOIN t001 AS t1 ON t1~land1 = t5~land1
           INTO CORRESPONDING FIELDS OF TABLE lt_procedures
           WHERE t1~bukrs IN it_sel_comp_codes
           ORDER BY kalsm bukrs.                       "#EC CI_BUFFJOIN

    CHECK NOT lt_procedures IS INITIAL.
    LOOP AT lt_procedures INTO lst_procedure.
      AT NEW kalsm.
        CLEAR lt_mwskz.
        SELECT mwskz FROM t007ac INTO TABLE lt_mwskz
                 WHERE kalsm = lst_procedure-kalsm
                   AND ( vorgg = space OR vorgg = 'MMIV' OR vorgg = 'FIAP' )
                   AND mwskz IN it_sel_opt.

        IF lt_mwskz IS INITIAL.
          SELECT mwskz FROM t007a INTO TABLE lt_mwskz
                       WHERE kalsm = lst_procedure-kalsm
                         AND mwart = 'V'
                         AND mwskz IN it_sel_opt.
        ENDIF.
      ENDAT.

      IF lt_mwskz IS NOT INITIAL.
        lst_tax_code-comp_code = lst_procedure-bukrs.
        lst_tax_code-procedure = lst_procedure-kalsm.
        LOOP AT lt_mwskz INTO lc_mwskz.
          lst_tax_code-tax_code = lc_mwskz.
          APPEND lst_tax_code TO et_tax_codes.
        ENDLOOP.
      ENDIF.
    ENDLOOP.


  ENDMETHOD.
  METHOD get_text_from_domain.

    DATA: lc_domain TYPE dd07l-domname,
          lc_value  TYPE dd07l-domvalue_l,
          lc_langu  TYPE dd07t-ddlanguage,
          lst_dd07v TYPE dd07v.

    lc_domain   = ic_domain.
    lc_value    = ic_value.
    lc_langu    = ic_langu.

    CALL FUNCTION 'DD_DOMVALUE_TEXT_GET'
      EXPORTING
        domname  = lc_domain
        value    = lc_value
        langu    = lc_langu
      IMPORTING
        dd07v_wa = lst_dd07v
        rc       = ec_rc.

    IF ec_rc = 0.
      ec_text = lst_dd07v-ddtext.
    ENDIF.

  ENDMETHOD.
  METHOD get_texts.

    TYPES: BEGIN OF yst_text,
             object TYPE tdobject,
             id     TYPE tdid,
           END OF yst_text.

    DATA: lc_number TYPE tdobname,
          lt_texts  TYPE STANDARD TABLE OF yst_text,
          lst_text  LIKE LINE OF lt_texts,
          lt_lines  TYPE STANDARD TABLE OF tline,
          lst_line  LIKE LINE OF lt_lines.

    lc_number = ic_number.

    SELECT tdobject tdid FROM stxh INTO TABLE lt_texts
      WHERE tdname   = lc_number
        AND tdspras  = ic_langu.                       "#EC CI_NOFIRST.

    LOOP AT lt_texts INTO lst_text.
      CLEAR lt_lines.
      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = lst_text-id
          language                = ic_langu
          name                    = lc_number
          object                  = lst_text-object
        TABLES
          lines                   = lt_lines
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.
      IF sy-subrc <> 0 AND sy-subrc <> 4.
        zdyn_cl_msg=>add_sysmsg( ).
      ENDIF.

      IF lt_lines IS INITIAL.
        CONTINUE.
      ENDIF.

      APPEND LINES OF lt_lines TO et_lines.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_vbak.

    DATA: ln_vbeln TYPE vbeln.

    ln_vbeln = in_doc_number.

    SELECT * FROM vbak INTO TABLE et_vbak
      WHERE vbeln = ln_vbeln.

  ENDMETHOD.
METHOD get_vbrp.

  DATA: lc_vbeln TYPE vbeln,
        lc_posnr TYPE posnr.

* this method is never used for one item only during the session
* it is reasonable then to buffer all the items at once
* it will never jump back to the same doc, that's why we can replace one doc with another

  lc_vbeln = ic_doc_number.
  lc_posnr = ic_itm_number.

  READ TABLE mt_vbrp INTO est_vbrp
    WITH KEY vbeln = lc_vbeln
             posnr = lc_posnr.
  IF sy-subrc <> 0.
    SELECT * FROM vbrp INTO TABLE mt_vbrp
      WHERE vbeln = lc_vbeln.
    READ TABLE mt_vbrp INTO est_vbrp
      WITH KEY vbeln = lc_vbeln
               posnr = lc_posnr.
  ENDIF.

ENDMETHOD.
METHOD get_vbrps.

  DATA: lc_vbeln TYPE vbeln.

  lc_vbeln = ic_doc_number.

  SELECT * FROM vbrp
    INTO TABLE mt_vbrp
    WHERE vbeln = lc_vbeln.

ENDMETHOD.
  METHOD get_vendor_banks.

    SELECT * FROM lfbk INTO TABLE et_banks
      WHERE lifnr = ic_vendor.

  ENDMETHOD.
  METHOD get_vendors.

    DATA: lt_where    TYPE rsds_where_tab,
          lt_dyn_sel  LIKE it_dyn_sel,
          lt_tabnames TYPE tttabname.

    IF it_dyn_sel IS NOT INITIAL.
      lt_dyn_sel = it_dyn_sel.
      APPEND 'LFA1' TO lt_tabnames.
      zdyn_cl_db=>mo->select_tables_in_dyn_sel( EXPORTING it_tabnames = lt_tabnames
                                                CHANGING  ct_dyn_sel  = lt_dyn_sel ).
      zdyn_cl_db=>mo->get_where_clause( EXPORTING it_dyn_sel  = lt_dyn_sel
                                        IMPORTING et_where    = lt_where ).
    ENDIF.

    IF ic_comp_code IS NOT INITIAL.
      SELECT * FROM zdyn_ws_vmd JOIN lfa1 ON lfa1~lifnr = zdyn_ws_vmd~lifnr
        INTO CORRESPONDING FIELDS OF TABLE et_vendors
        WHERE zdyn_ws_vmd~bukrs = ic_comp_code
          AND zdyn_ws_vmd~lifnr IN it_sel_opt
          AND (lt_where).
    ELSEIF it_sel_comp_codes IS NOT INITIAL.
      SELECT * FROM zdyn_ws_vmd JOIN lfa1 ON lfa1~lifnr = zdyn_ws_vmd~lifnr
        INTO CORRESPONDING FIELDS OF TABLE et_vendors
        WHERE zdyn_ws_vmd~bukrs IN it_sel_comp_codes
          AND zdyn_ws_vmd~lifnr IN it_sel_opt
          AND (lt_where).
    ELSE.
      SELECT * FROM zdyn_ws_vmd JOIN lfa1 ON lfa1~lifnr = zdyn_ws_vmd~lifnr
        INTO CORRESPONDING FIELDS OF TABLE et_vendors
        WHERE zdyn_ws_vmd~lifnr IN it_sel_opt
          AND (lt_where).
      SORT et_vendors BY lifnr erdat DESCENDING nation ASCENDING.
      DELETE ADJACENT DUPLICATES FROM et_vendors COMPARING lifnr.
      RETURN.
    ENDIF.

    SORT et_vendors BY lifnr bukrs nation ASCENDING.
    DELETE ADJACENT DUPLICATES FROM et_vendors COMPARING lifnr bukrs.

  ENDMETHOD.
  METHOD get_wbs_elements.

    DATA: lt_sel_loevm  TYPE RANGE OF loevm,
          lst_sel_loevm LIKE LINE OF lt_sel_loevm.

    IF ib_active_only = abap_true.
      lst_sel_loevm-sign = 'I'.
      lst_sel_loevm-option = 'EQ'.
      lst_sel_loevm-low = ' '.
      APPEND lst_sel_loevm TO lt_sel_loevm.
    ENDIF.

    IF ic_comp_code IS NOT INITIAL.
      SELECT pspnr posid pbukr post1 loevm erdat aedat FROM prps INTO TABLE et_wbs_elements
             WHERE pspnr IN it_sel_opt AND
                   loevm IN lt_sel_loevm AND
                   pbukr = ic_comp_code.
    ELSE.
      SELECT pspnr posid pbukr post1 loevm erdat aedat FROM prps INTO TABLE et_wbs_elements
           WHERE pspnr IN it_sel_opt AND
                 loevm IN lt_sel_loevm AND
                 pbukr IN it_sel_comp_codes.
    ENDIF.

  ENDMETHOD.
  METHOD idoc_inbound_xml_via_http.

    DATA: li_len TYPE i,
          ls_len TYPE string.

    li_len = strlen( is_xml ).
    CHECK li_len > 0.
    ls_len = li_len.
    CONDENSE ls_len NO-GAPS.

    CALL FUNCTION 'IDOC_INBOUND_XML_VIA_HTTP'
      EXPORTING
        xml_stream     = is_xml
        content_length = ls_len
        content_type   = zdyn_if_rest_data=>con_mimetype_xml
        remote_addr    = is_remote_addr
      EXCEPTIONS
        OTHERS         = 1.
    IF sy-subrc <> 0.
      RAISE error_occurred.
    ENDIF.

  ENDMETHOD.
  METHOD is_function_exist.

    DATA: lst_existing_func LIKE LINE OF mt_existing_func.
    FIELD-SYMBOLS: <st_existing_func> LIKE LINE OF mt_existing_func.

    READ TABLE mt_existing_func ASSIGNING <st_existing_func>
      WITH KEY name = ic_name
      BINARY SEARCH.
    IF sy-subrc = 0.
      rb_result = <st_existing_func>-exists.
    ELSE.
      lst_existing_func-name = ic_name.
      CALL FUNCTION 'FUNCTION_EXISTS'
        EXPORTING
          funcname           = ic_name
        EXCEPTIONS
          function_not_exist = 1
          OTHERS             = 2.
      IF sy-subrc = 0.
        lst_existing_func-exists = abap_true.
      ELSE.
        lst_existing_func-exists = abap_false.
      ENDIF.
      INSERT lst_existing_func INTO TABLE mt_existing_func.
      rb_result = lst_existing_func-exists.
    ENDIF.

  ENDMETHOD.
  METHOD is_object_modified.

    DATA: lc_object_id    TYPE  cdobjectv,
          lc_object_class TYPE  cdobjectcl.

    lc_object_id    = ic_object_id.
    lc_object_class = ic_object_class.

    SELECT SINGLE objectid FROM cdhdr INTO lc_object_id
                           WHERE objectclas = lc_object_class
                             AND objectid   = lc_object_id
                             AND udate      >= id_date.
    IF sy-subrc = 0.
      rb_result = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD is_table_exist.

    DATA: lc_name  TYPE dd02l-tabname,
          li_count TYPE i.

    lc_name = ic_name.

    SELECT COUNT(*) FROM dd02l INTO li_count WHERE tabname = lc_name.

    IF li_count > 0.
      rb_result = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD map_int_to_ext_structure.

    CALL FUNCTION 'MAP_INT_TO_EXT_STRUCTURE'
      TABLES
        fxvbak     = it_vbak
        fxkomv     = it_komv
        fxbapikomv = et_conditions.

  ENDMETHOD.
  METHOD set_mo.

    IF io_mo IS INITIAL.
      CREATE OBJECT mo.
    ELSE.
      mo = io_mo.
    ENDIF.

  ENDMETHOD.
