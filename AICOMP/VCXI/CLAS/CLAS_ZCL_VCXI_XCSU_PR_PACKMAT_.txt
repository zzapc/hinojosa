
class ZCL_VCXI_XCSU_PR_PACKMAT definition
  public
  inheriting from /VCXI/CL_VKSR_CLSPR
  create public .

public section.

  constants C_IPRVT_XCS_PACKMAT type /VCXI/VKSC_IPRVT value 'ZVCXI_XCSU_PACKMAT' ##NO_TEXT.
  constants C_PARID_PAMAI type /VCXI/VKS_PARID value 'ZVCXI_XC_PAMAI' ##NO_TEXT.
  constants C_PARID_PMATY type /VCXI/VKS_PARID value 'ZVCXI_XC_PMATY' ##NO_TEXT.
  data F_MATNR_DUMMY type MATNR .

  methods GET_PIREM
    returning
      value(RF_PIREM) type ZVCXI_XCSU_PIREM
    raising
      /VCXI/CX_CKX .
  methods CALC_ADJ_DIMEN
    importing
      !IT_DIMEN type ZVCXI_XCSU_TT_DIMEN
    returning
      value(RT_DIMEN) type ZVCXI_XCSU_TT_DIMEN
    raising
      /VCXI/CX_CKX .
  methods CALC_ADJ_LIMIT
    importing
      !IT_LIMIT type ZVCXI_XCSU_TT_LIMIT
    returning
      value(RT_LIMIT) type ZVCXI_XCSU_TT_LIMIT
    raising
      /VCXI/CX_CKX .
  methods CALC_DETAILS
    raising
      /VCXI/CX_CKX .
  methods CALL_SHLP_CONSC
    importing
      !IF_DISPLAY type ABAP_BOOL default ABAP_FALSE
    returning
      value(RF_CONSC) type ZVCXI_XCSU_CONSC
    raising
      /VCXI/CX_CKX .
  methods CALL_SHLP_PAMAI
    importing
      !IF_DISPLAY type ABAP_BOOL default ABAP_FALSE
    returning
      value(RF_PAMAI) type ZVCXI_XCSU_PAMAI
    raising
      /VCXI/CX_CKX .
  methods CALL_SHLP_PMATN
    importing
      !IF_DISPLAY type ABAP_BOOL default ABAP_FALSE
    returning
      value(RF_PMATN) type ZVCXI_XCSU_PMATN
    raising
      /VCXI/CX_CKX .
  methods CALL_SHLP_PMATY
    importing
      !IF_DISPLAY type ABAP_BOOL default ABAP_FALSE
    returning
      value(RF_PMATY) type ZVCXI_XCSU_PMATY
    raising
      /VCXI/CX_CKX .
  methods CONSTRUCTOR
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_CONSC
    exporting
      !EF_CONSC type ZVCXI_XCSU_CONSC
      !EF_SETBY type /VCXI/VKSR_SETBY
    raising
      /VCXI/CX_CKX .
  methods GET_CONSC_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_COUNT
    returning
      value(RF_COUNT) type /VCXI/VKS_POSID
    raising
      /VCXI/CX_CKX .
  methods GET_DETAIL_SHIPMGR
    exporting
      !EF_CPACK type ZVCXI_XCSU_CPACK
      !EF_SHSCH type ZVCXI_XCSU_SHSCH
      !ER_DFLT_SHIPU type ref to ZCL_VCXI_XCSU_DFLT_SHIPU
    raising
      /VCXI/CX_CKX .
  methods GET_DETAIL_SHIPUNIT
    exporting
      !EF_SHUNT type ZVCXI_XCSU_SHUNT
      !ET_DIMEN type ZVCXI_XCSU_TT_DIMEN
      !ER_NEXT_PACKMAT type ref to /VCXI/CL_VKSR_GATE
      !ER_PREV_PACKMAT type ref to /VCXI/CL_VKSR_GATE
      !EF_SHUTY type ZVCXI_XCSU_SHUTY
    raising
      /VCXI/CX_CKX .
  methods GET_EFFCT
    exporting
      !ET_EFFCT type ZVCXI_XCSU_TT_EFFCT
      !EF_SETBY type /VCXI/VKSR_SETBY
    raising
      /VCXI/CX_CKX .
  methods GET_FOVRR_CONSC
    returning
      value(RF_FOVRR) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_FOVRR_EFFCT
    returning
      value(RF_FOVRR) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_FOVRR_PMQTY
    returning
      value(RF_FOVRR) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_LIFNR
    returning
      value(RF_LIFNR) type LIFNR
    raising
      /VCXI/CX_CKX .
  methods GET_LIFNR_DESCR
    returning
      value(RF_LIFNR_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_PAMAI
    returning
      value(RF_PAMAI) type ZVCXI_XCSU_PAMAI
    raising
      /VCXI/CX_CKX .
  methods GET_PAMAI_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_PMATN
    returning
      value(RF_MATNR) type MATNR
    raising
      /VCXI/CX_CKX .
  methods GET_PMATN_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_PMATN_SETBY
    returning
      value(RF_SETBY) type /VCXI/VKSR_SETBY
    raising
      /VCXI/CX_CKX .
  methods GET_PMATY
    returning
      value(RF_PMATY) type ZVCXI_XCSU_PMATY
    raising
      /VCXI/CX_CKX .
  methods GET_PMATY_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_PMQTY
    exporting
      !ES_PMQTY type ZVCXI_XCSU_S_PMQTY
      !EF_SETBY type /VCXI/VKSR_SETBY
    raising
      /VCXI/CX_CKX .
  methods GET_PRICE
    returning
      value(RS_PRICE) type ZVCXI_XCS_S_PRICE
    raising
      /VCXI/CX_CKX .
  methods GET_PRICP
    returning
      value(RS_PRICP) type ZVCXI_XCS_S_PRICP
    raising
      /VCXI/CX_CKX .
  methods GET_PURCH
    returning
      value(RF_PURCH) type ZVCXI_XCS_PURCH
    raising
      /VCXI/CX_CKX .
  methods GET_SCALE
    returning
      value(RF_SCALE) type ZVCXI_XCSU_SCALE
    raising
      /VCXI/CX_CKX .
  methods GET_TEXT
    returning
      value(RF_TEXT) type TEXT30
    raising
      /VCXI/CX_CKX .
  methods GET_WERKS
    returning
      value(RF_WERKS) type WERKS_D
    raising
      /VCXI/CX_CKX .
  methods INIT_PMATY
    raising
      /VCXI/CX_CKX .
  methods IS_DUMMY
    returning
      value(RF_RETURN) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_SCALE_ACTIVE
    returning
      value(RF_ACTIVE) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods SET_CONSC
    importing
      !IF_CONSC type ZVCXI_XCSU_CONSC optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_EFFCT
    importing
      !IT_EFFCT type ZVCXI_XCSU_TT_EFFCT optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_FOVRR_CONSC
    importing
      !IF_FOVRR type ABAP_BOOL optional
    raising
      /VCXI/CX_CKX .
  methods SET_FOVRR_EFFCT
    importing
      !IF_FOVRR type ABAP_BOOL optional
    raising
      /VCXI/CX_CKX .
  methods SET_FOVRR_PMQTY
    importing
      !IF_FOVRR type ABAP_BOOL optional
    raising
      /VCXI/CX_CKX .
  methods SET_LIFNR
    importing
      !IF_LIFNR type LIFNR
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PAMAI
    importing
      !IF_PAMAI type ZVCXI_XCSU_PAMAI optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PMATN
    importing
      !IF_PMATN type MATNR
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PMATY
    importing
      !IF_PMATY type ZVCXI_XCSU_PMATY
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PMQTY
    importing
      !IS_PMQTY type ZVCXI_XCSU_S_PMQTY optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PRICE
    importing
      !IS_PRICE type ZVCXI_XCS_S_PRICE optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PRICP
    importing
      !IS_PRICP type ZVCXI_XCS_S_PRICP optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_PURCH
    importing
      !IF_PURCH type ZVCXI_XCS_PURCH
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_SCALE
    importing
      value(IF_SCALE) type ZVCXI_XCSU_SCALE
    raising
      /VCXI/CX_CKX .
  methods SET_TEXT
    importing
      !IF_TEXT type TEXT30
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .

  methods GET_DESCR
    redefinition .
  methods GET_STATUS
    redefinition .
  methods GET_STATUS_MSG
    redefinition .
  methods HANDLE_EVENT
    redefinition .
protected section.

  constants C_ATTID_VALID_MATNR type /VCXI/VKS_ATTID value 'VALID_MATNR' ##NO_TEXT.
  constants C_DIMID_DIMLESS type DIMID value 'AAAADL' ##NO_TEXT.
  constants C_IEVNT_I_INIT_CUST_MATNR type /VCXI/VKSC_IEVNT value 'INIT_CUST_MATNR' ##NO_TEXT.
  constants C_IEVNT_I_INIT_PRICE type /VCXI/VKSC_IEVNT value 'INIT_PRICE' ##NO_TEXT.
  constants C_IEVNT_I_INIT_PURCH type /VCXI/VKSC_IEVNT value 'INIT_PURCH' ##NO_TEXT.
  constants C_IEVNT_I_INIT_REFERENCES type /VCXI/VKSC_IEVNT value 'INIT_REFERENCES' ##NO_TEXT.
  constants C_IEVNT_I_RECALC_DETAILS type /VCXI/VKSC_IEVNT value 'RECALC_DETAILS' ##NO_TEXT.
  constants C_IEVNT_I_RESET_EFFCT type /VCXI/VKSC_IEVNT value 'RESET_EFFCT' ##NO_TEXT.
  constants C_IEVNT_I_RESET_PMATN type /VCXI/VKSC_IEVNT value 'RESET_PMATN' ##NO_TEXT.
  constants C_IEVNT_I_RESET_PMATY type /VCXI/VKSC_IEVNT value 'RESET_PMATY' ##NO_TEXT.
  constants C_IEVNT_I_SET_DEFAULT type /VCXI/VKSC_IEVNT value 'SET_DEFAULT' ##NO_TEXT.
  constants C_IEVNT_O_CONSC_CHANGED type /VCXI/VKSC_IEVNT value 'CONSC_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_EFFCT_CHANGED type /VCXI/VKSC_IEVNT value 'EFFCT_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_LIFNR_CHANGED type /VCXI/VKSC_IEVNT value 'LIFNR_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PAMAI_CHANGED type /VCXI/VKSC_IEVNT value 'PAMAI_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PMATN_CHANGED type /VCXI/VKSC_IEVNT value 'PMATN_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PMATY_CHANGED type /VCXI/VKSC_IEVNT value 'PMATY_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PMQTY_CHANGED type /VCXI/VKSC_IEVNT value 'PMQTY_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PRICE_CHANGED type /VCXI/VKSC_IEVNT value 'PRICE_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_PURCH_CHANGED type /VCXI/VKSC_IEVNT value 'PURCH_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_REQUEST_RESET_EFFCT type /VCXI/VKSC_IEVNT value 'REQUEST_RESET_EFFCT' ##NO_TEXT.
  constants C_IEVNT_O_REQUEST_SET_DEFAULT type /VCXI/VKSC_IEVNT value 'REQUEST_SET_DEFAULT' ##NO_TEXT.
  constants C_PARID_CONSC type /VCXI/VKS_PARID value 'ZVCXI_XC_CONSC' ##NO_TEXT.
  constants C_PARID_EFFCT type /VCXI/VKS_PARID value 'ZVCXI_XC_EFFCT' ##NO_TEXT.
  constants C_PARID_LIFNR type /VCXI/VKS_PARID value 'ZVCXI_XC_LIFNR' ##NO_TEXT.
  constants C_PARID_PMQTY_A type /VCXI/VKS_PARID value 'ZVCXI_XC_PMQTY_A' ##NO_TEXT.
  constants C_PARID_PMQTY_L type /VCXI/VKS_PARID value 'ZVCXI_XC_PMQTY_L' ##NO_TEXT.
  constants C_PARID_PMQTY_P type /VCXI/VKS_PARID value 'ZVCXI_XC_PMQTY_P' ##NO_TEXT.
  constants C_PARID_PMQTY_W type /VCXI/VKS_PARID value 'ZVCXI_XC_PMQTY_W' ##NO_TEXT.
  constants C_PARID_PRICE type /VCXI/VKS_PARID value 'ZVCXI_XC_PRICE' ##NO_TEXT.
  constants C_PARID_PRICP_A type /VCXI/VKS_PARID value 'ZVCXI_XC_PRICP_A' ##NO_TEXT.
  constants C_PARID_PRICP_L type /VCXI/VKS_PARID value 'ZVCXI_XC_PRICP_L' ##NO_TEXT.
  constants C_PARID_PRICP_P type /VCXI/VKS_PARID value 'ZVCXI_XC_PRICP_P' ##NO_TEXT.
  constants C_PARID_PRICP_W type /VCXI/VKS_PARID value 'ZVCXI_XC_PRICP_W' ##NO_TEXT.
  constants C_PARID_PURCH type /VCXI/VKS_PARID value 'ZVCXI_XC_PURCH' ##NO_TEXT.
  constants C_PARID_TEXT type /VCXI/VKS_PARID value 'ZVCXI_XC_TEXT' ##NO_TEXT.
  constants C_VALID_MATNR_A type CHAR04 value 'ALL' ##NO_TEXT.
  constants C_VALID_MATNR_C type CHAR04 value 'CUST' ##NO_TEXT.
  data F_DIMID type DIMID .
  data F_PARID_PMQTY type /VCXI/VKS_PARID .
  data F_PARID_PRICP type /VCXI/VKS_PARID .
  data R_CUST_PACKMAT type ref to ZCL_VCXI_XCSU_CUST_PACKMAT .
  data R_CUST_SHIPU type ref to ZCL_VCXI_XCSU_CUST_SHIPU .
  data R_PR_SHIPMGR type ref to ZCL_VCXI_XCSU_PR_SHIPMGR .
  data S_COMOD type ZVCXI_XCSU_S_COMOD .

  methods CHECK_CONSC
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_LIFNR
    importing
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE optional
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_PMATN
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_PMATY
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_PMQTY
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_PRICE
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CLEAR_FOR_PMATN
    raising
      /VCXI/CX_CKX .
  methods CLEAR_FOR_PMATY
    raising
      /VCXI/CX_CKX .
  methods GET_PSCALE_MGR
    importing
      !IF_CREATE type ABAP_BOOL default ABAP_FALSE
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_CUST_MATNR
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_PRICE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_PURCH
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_REFERENCES
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RECALC_DETAILS
    importing
      !IT_GATE type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RESET_EFFCT
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RESET_PMATN
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RESET_PMATY
    raising
      /VCXI/CX_CKX .
  methods HANDLE_SET_DEFAULT
    raising
      /VCXI/CX_CKX .
  methods INIT_CUST_SHIPU
    raising
      /VCXI/CX_CKX .
  methods INIT_DIM_PARAM
    raising
      /VCXI/CX_CKX .
  methods INIT_EFFCT
    raising
      /VCXI/CX_CKX .
  methods INIT_MATNR_DUMMY
    raising
      /VCXI/CX_CKX .
  methods INIT_VALID_MATNR
    raising
      /VCXI/CX_CKX .
  methods IS_VALID_UNIT
    importing
      !IF_MATNR type MATNR
      !IF_UNIT type UNIT
    returning
      value(RF_VALID) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods LOAD_DFLT_FOR_PMATN
    raising
      /VCXI/CX_CKX .
  methods SET_PMATN_EFFCT
    raising
      /VCXI/CX_CKX .
private section.

  data F_VALID_MATNR type CHAR04 .
endclass. "ZCL_VCXI_XCSU_PR_PACKMAT definition
class ZCL_VCXI_XCSU_PR_PACKMAT implementation.
method CALC_ADJ_DIMEN.

  data: LF_MSGV1 type SYMSGV,
        LF_MSGV2 type SYMSGV,
        LF_FMNDI type ZVCXI_XCSU_FMNDI.
  data: LS_EFFCT type ZVCXI_XCSU_S_EFFCT,
        LS_DIMEN type ZVCXI_XCSU_S_DIMEN.
  data: LT_EFFCT type ZVCXI_XCSU_TT_EFFCT.
  data: LR_CX_ILLEGAL_FUNC    type ref to CX_SY_DYN_CALL_ILLEGAL_FUNC,
        LR_CX_PARAM_NOT_FOUND type ref to CX_SY_DYN_CALL_PARAM_NOT_FOUND,
        LR_CX_PARAM_MISSING   type ref to CX_SY_DYN_CALL_PARAM_MISSING,
        LR_CX_DYN_CALL_ERROR  type ref to CX_SY_DYN_CALL_ERROR.

  check ME->R_CUST_SHIPU is bound.

*** All dimension input should be retained (although possibly adjusted later)
  append lines of IT_DIMEN to RT_DIMEN.

  ME->GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).

  loop at LT_EFFCT into LS_EFFCT.
    LF_FMNDI = ME->R_CUST_SHIPU->GET_FMNDI_FOR_EFFCT( IF_EFFCT = LS_EFFCT-EFFCT ).
    if LF_FMNDI is initial.
      continue.
    endif.

    read table RT_DIMEN into LS_DIMEN with key DIMEN = LS_EFFCT-DIMEN.
    if SY-SUBRC ne 0.
      continue.
    endif.

    try.
        call function LF_FMNDI
          exporting
            IS_DIMEN = LS_DIMEN
            IS_EFFCT = LS_EFFCT
          importing
            ES_DIMEN = LS_DIMEN.

      catch CX_SY_DYN_CALL_ILLEGAL_FUNC into LR_CX_ILLEGAL_FUNC.
***     Function Module call failed: Could not call the function &1.
        move LR_CX_ILLEGAL_FUNC->FUNCTION to LF_MSGV1.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '001'
                          F_MSGV1 = LF_MSGV1.

      catch CX_SY_DYN_CALL_PARAM_NOT_FOUND into LR_CX_PARAM_NOT_FOUND.
***     Function Module call failed: Parameter &1 in function &2 missing.
        move LR_CX_PARAM_NOT_FOUND->PARAMETER to LF_MSGV1.
        move LR_CX_PARAM_NOT_FOUND->FUNCTION  to LF_MSGV2.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '003'
                          F_MSGV1 = LF_MSGV1
                          F_MSGV2 = LF_MSGV2.

      catch CX_SY_DYN_CALL_PARAM_MISSING into LR_CX_PARAM_MISSING.
***     Function Module call failed: Obligatory parameter &2 of &2 not filled.
        move LR_CX_PARAM_MISSING->PARAMETER to LF_MSGV1.
        move LR_CX_PARAM_MISSING->FUNCTION  to LF_MSGV2.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '003'
                          F_MSGV1 = LF_MSGV1
                          F_MSGV2 = LF_MSGV2.

      catch CX_SY_DYN_CALL_ERROR into LR_CX_DYN_CALL_ERROR.
***     Function Module call failed: Unknown Error while calling function &1.
        move LR_CX_DYN_CALL_ERROR->FUNCTION  to LF_MSGV1.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '004'
                          F_MSGV1 = LF_MSGV1.
    endtry.
    modify RT_DIMEN from LS_DIMEN transporting DIMVA where DIMEN = LS_DIMEN-DIMEN.
  endloop.

endmethod.
method CALC_ADJ_LIMIT.

  data:          LF_MSGV1              type        SYMSGV,
                 LF_MSGV2              type        SYMSGV,
                 LF_INITIAL_VALID      type        ABAP_BOOL.
  data:          LS_EFFCT              type        ZVCXI_XCSU_S_EFFCT,
                 LS_LIMIT              type        ZVCXI_XCSU_S_LIMIT,
                 LS_EFFCT_LIMIT        type        ZVCXI_XCS_TC131.
  data:          LT_EFFCT              type        ZVCXI_XCSU_TT_EFFCT,
                 LT_EFFCT_LIMIT        type        ZVCXI_XCSU_TT_EFFCT_LIMIT.
  data:          LR_CX_ILLEGAL_FUNC    type ref to CX_SY_DYN_CALL_ILLEGAL_FUNC,
                 LR_CX_PARAM_NOT_FOUND type ref to CX_SY_DYN_CALL_PARAM_NOT_FOUND,
                 LR_CX_PARAM_MISSING   type ref to CX_SY_DYN_CALL_PARAM_MISSING,
                 LR_CX_DYN_CALL_ERROR  type ref to CX_SY_DYN_CALL_ERROR.
  field-symbols: <S_LIMIT>             type        ZVCXI_XCSU_S_LIMIT.

  check ME->R_CUST_SHIPU is bound.

*** All limits input should be retained (although possibly adjusted later)
  append lines of IT_LIMIT to RT_LIMIT.

  ME->GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).

  loop at LT_EFFCT into LS_EFFCT.
    LT_EFFCT_LIMIT = ME->R_CUST_SHIPU->GET_LIMIT_SET_FOR_EFFCT( IF_EFFCT = LS_EFFCT-EFFCT ).

    loop at LT_EFFCT_LIMIT into LS_EFFCT_LIMIT.
      clear LS_LIMIT.
      read table RT_LIMIT into LS_LIMIT with key DIMEN = LS_EFFCT-DIMEN
                                                 LIMIT = LS_EFFCT_LIMIT-LIMIT.
      if SY-SUBRC ne 0.
        LS_LIMIT-LIMIT      = LS_EFFCT_LIMIT-LIMIT.
        LS_LIMIT-DIMVA      = LS_EFFCT-DIMVA.
        LS_LIMIT-DIMVA_UOM  = LS_EFFCT-DIMVA_UOM.
      endif.

      if LS_EFFCT_LIMIT-FMNLI is not initial.
        try.
            call function LS_EFFCT_LIMIT-FMNLI
              exporting
                IS_LIMIT         = LS_LIMIT
                IS_EFFCT         = LS_EFFCT
              importing
                ES_LIMIT         = LS_LIMIT
                ES_INITIAL_VALID = LF_INITIAL_VALID.

          catch CX_SY_DYN_CALL_ILLEGAL_FUNC into LR_CX_ILLEGAL_FUNC.
***         Function Module call failed: Could not call the function &1.
            move LR_CX_ILLEGAL_FUNC->FUNCTION to LF_MSGV1.
            raise exception type /VCXI/CX_CKX
                            exporting
                              F_MSGTY = 'E'
                              F_MSGID = 'ZVCXI_XCS'
                              F_MSGNO = '001'
                              F_MSGV1 = LF_MSGV1.

          catch CX_SY_DYN_CALL_PARAM_NOT_FOUND into LR_CX_PARAM_NOT_FOUND.
***         Function Module call failed: Parameter &1 in function &2 missing.
            move LR_CX_PARAM_NOT_FOUND->PARAMETER to LF_MSGV1.
            move LR_CX_PARAM_NOT_FOUND->FUNCTION  to LF_MSGV2.
            raise exception type /VCXI/CX_CKX
                            exporting
                              F_MSGTY = 'E'
                              F_MSGID = 'ZVCXI_XCS'
                              F_MSGNO = '003'
                              F_MSGV1 = LF_MSGV1
                              F_MSGV2 = LF_MSGV2.

          catch CX_SY_DYN_CALL_PARAM_MISSING into LR_CX_PARAM_MISSING.
***         Function Module call failed: Obligatory parameter &2 of &2 not filled.
            move LR_CX_PARAM_MISSING->PARAMETER to LF_MSGV1.
            move LR_CX_PARAM_MISSING->FUNCTION  to LF_MSGV2.
            raise exception type /VCXI/CX_CKX
                            exporting
                              F_MSGTY = 'E'
                              F_MSGID = 'ZVCXI_XCS'
                              F_MSGNO = '003'
                              F_MSGV1 = LF_MSGV1
                              F_MSGV2 = LF_MSGV2.

          catch CX_SY_DYN_CALL_ERROR into LR_CX_DYN_CALL_ERROR.
***         Function Module call failed: Unknown Error while calling function &1.
            move LR_CX_DYN_CALL_ERROR->FUNCTION  to LF_MSGV1.
            raise exception type /VCXI/CX_CKX
                            exporting
                              F_MSGTY = 'E'
                              F_MSGID = 'ZVCXI_XCS'
                              F_MSGNO = '004'
                              F_MSGV1 = LF_MSGV1.
        endtry.
      else.
        LF_INITIAL_VALID = ABAP_FALSE.
      endif.

***   only update return limits with intial valids if function deems it to be ok
      if LS_LIMIT-DIMVA is not initial or LF_INITIAL_VALID eq ABAP_TRUE.
        read table RT_LIMIT assigning <S_LIMIT> with key LIMIT = LS_LIMIT-LIMIT
                                                         DIMEN = LS_LIMIT-DIMEN.
        if SY-SUBRC eq 0.
          <S_LIMIT>-DIMVA = LS_LIMIT-DIMVA.
          <S_LIMIT>-DIMVA_UOM  = LS_LIMIT-DIMVA_UOM.
        else.
          append LS_LIMIT to RT_LIMIT.
        endif.
      endif.
    endloop.
  endloop.

endmethod.
method CALC_DETAILS.

  data:          LF_MSGV1              type        SYMSGV,
                 LF_MSGV2              type        SYMSGV,
                 LF_PMATY              type        ZVCXI_XCSU_PMATY,
                 LF_PMATN              type        ZVCXI_XCSU_PMATN,
                 LF_CONSC              type        ZVCXI_XCSU_CONSC,
                 LF_FMNPA              type        ZVCXI_XCSU_FMNPA,
                 LF_FOVRR_CONSC        type        ZVCXI_XCS_FOVRR,
                 LF_FOVRR_PMQTY        type        ZVCXI_XCS_FOVRR,
                 LF_FOVRR_EFFCT        type        ZVCXI_XCS_FOVRR,
                 LF_UPDATE_CONSC       type        ABAP_BOOL,
                 LF_UPDATE_PMQTY       type        ABAP_BOOL,
                 LF_UPDATE_EFFCT       type        ABAP_BOOL.
  data:          LS_PMQTY              type        ZVCXI_XCSU_S_PMQTY.
  data:          LT_EFFCT              type        ZVCXI_XCSU_TT_EFFCT,
                 LT_DIMEN              type        ZVCXI_XCSU_TT_DIMEN.
  data:          LR_CX_ILLEGAL_FUNC    type ref to CX_SY_DYN_CALL_ILLEGAL_FUNC,
                 LR_CX_PARAM_NOT_FOUND type ref to CX_SY_DYN_CALL_PARAM_NOT_FOUND,
                 LR_CX_PARAM_MISSING   type ref to CX_SY_DYN_CALL_PARAM_MISSING,
                 LR_CX_DYN_CALL_ERROR  type ref to CX_SY_DYN_CALL_ERROR.
  field-symbols: <S_EFFCT>             type        ZVCXI_XCSU_S_EFFCT.

  check ME->R_CUST_SHIPU is bound.

  LF_PMATY = GET_PMATY( ).
  LF_PMATN = GET_PMATN( ).
  GET_CONSC( importing EF_CONSC = LF_CONSC ).
  GET_PMQTY( importing ES_PMQTY = LS_PMQTY ).
  GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).

  LF_FMNPA = ME->R_CUST_SHIPU->GET_FMNPA_FOR_PMATY( IF_PMATY = LF_PMATY ).

  LF_FOVRR_CONSC = ME->GET_FOVRR_CONSC( ).
  LF_FOVRR_EFFCT = ME->GET_FOVRR_EFFCT( ).
  LF_FOVRR_PMQTY = ME->GET_FOVRR_PMQTY( ).

*** retrieve dimensions of shipping unit
  ME->GET_DETAIL_SHIPUNIT( importing ET_DIMEN = LT_DIMEN ).

*** only execute if type and material are entered and a function moduel exists
  if LF_PMATY is not initial and
     LF_PMATN is not initial and
     LF_FMNPA is not initial.

    try.
        call function LF_FMNPA
          exporting
            IF_PMATY        = LF_PMATY
            IF_PMATN        = LF_PMATN
            IF_CONSC        = LF_CONSC
            IF_FOVRR_CONSC  = LF_FOVRR_CONSC
            IS_PMQTY        = LS_PMQTY
            IF_FOVRR_PMQTY  = LF_FOVRR_PMQTY
            IT_EFFCT        = LT_EFFCT
            IF_FOVRR_EFFCT  = LF_FOVRR_EFFCT
            IT_DIMEN        = LT_DIMEN
            IR_CUST_SHIPU   = ME->R_CUST_SHIPU
            IR_CUST_PACKMAT = ME->R_CUST_PACKMAT
            IS_COMOD        = ME->S_COMOD
          importing
            EF_CONSC        = LF_CONSC
            EF_UPDATE_CONSC = LF_UPDATE_CONSC
            ES_PMQTY        = LS_PMQTY
            EF_UPDATE_PMQTY = LF_UPDATE_PMQTY
            ET_EFFCT        = LT_EFFCT
            EF_UPDATE_EFFCT = LF_UPDATE_EFFCT.

      catch CX_SY_DYN_CALL_ILLEGAL_FUNC into LR_CX_ILLEGAL_FUNC.
***     Function Module call failed: Could not call the function &1.
        move LR_CX_ILLEGAL_FUNC->FUNCTION to LF_MSGV1.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '001'
                          F_MSGV1 = LF_MSGV1.

      catch CX_SY_DYN_CALL_PARAM_NOT_FOUND into LR_CX_PARAM_NOT_FOUND.
***     Function Module call failed: Parameter &1 in function &2 missing.
        move LR_CX_PARAM_NOT_FOUND->PARAMETER to LF_MSGV1.
        move LR_CX_PARAM_NOT_FOUND->FUNCTION  to LF_MSGV2.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '003'
                          F_MSGV1 = LF_MSGV1
                          F_MSGV2 = LF_MSGV2.

      catch CX_SY_DYN_CALL_PARAM_MISSING into LR_CX_PARAM_MISSING.
***     Function Module call failed: Obligatory parameter &2 of &2 not filled.
        move LR_CX_PARAM_MISSING->PARAMETER to LF_MSGV1.
        move LR_CX_PARAM_MISSING->FUNCTION  to LF_MSGV2.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '003'
                          F_MSGV1 = LF_MSGV1
                          F_MSGV2 = LF_MSGV2.

      catch CX_SY_DYN_CALL_ERROR into LR_CX_DYN_CALL_ERROR.
***     Function Module call failed: Unknown Error while calling function &1.
        move LR_CX_DYN_CALL_ERROR->FUNCTION  to LF_MSGV1.
        raise exception type /VCXI/CX_CKX
                        exporting
                          F_MSGTY = 'E'
                          F_MSGID = 'ZVCXI_XCS'
                          F_MSGNO = '004'
                          F_MSGV1 = LF_MSGV1.

    endtry.

    if LF_UPDATE_CONSC eq ABAP_TRUE and LF_FOVRR_CONSC ne ABAP_TRUE.
      ME->SET_CONSC( IF_CONSC = LF_CONSC ).
    endif.

    if LF_UPDATE_PMQTY eq ABAP_TRUE and LF_FOVRR_PMQTY ne ABAP_TRUE.
***   Packaging Material Quantity can not be less than zero after function call
      if LS_PMQTY-PMQTY lt 0.
        LS_PMQTY-PMQTY = 0.
      endif.
      ME->SET_PMQTY( IS_PMQTY = LS_PMQTY ).
    endif.

    if LF_UPDATE_EFFCT eq ABAP_TRUE and LF_FOVRR_EFFCT ne ABAP_TRUE.
***   Dimension Effects should not be zero after function call
      loop at LT_EFFCT assigning <S_EFFCT>.
        if <S_EFFCT>-DIMVA lt 0.
          <S_EFFCT>-DIMVA = 0.
        endif.
      endloop.

      ME->SET_EFFCT( IT_EFFCT = LT_EFFCT ).
    endif.

  endif.

endmethod.
method CALL_SHLP_CONSC.

  data: LF_PMATY   type ZVCXI_XCSU_PMATY,
        LF_WERKS   type WERKS_D,
        LF_LOCKED  type /VCXI/CKX_LOCKED,
        LF_DISPLAY type ABAP_BOOL.

  move IF_DISPLAY to LF_DISPLAY.

  LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
  if LF_LOCKED ne ABAP_TRUE.
    move ABAP_TRUE to LF_DISPLAY.
  endif.

  LF_WERKS = ME->GET_WERKS( ).
  LF_PMATY = ME->GET_PMATY( ).

  RF_CONSC = ZCL_VCXI_XCSU_SHLP_CONSC=>CALL_SHLP( IF_PMATY   = LF_PMATY
                                                  IF_DISPLAY = LF_DISPLAY
                                                  IF_WERKS   = LF_WERKS ).

endmethod.
method CALL_SHLP_PAMAI.

  data: LF_PMATY   type ZVCXI_XCSU_PMATY,
        LF_WERKS   type WERKS_D,
        LF_CPACK   type ZVCXI_XCSU_CPACK,
        LF_SHUTY   type ZVCXI_XCSU_SHUTY,
        LF_SHUNT   type ZVCXI_XCSU_SHUNT,
        LF_LOCKED  type /VCXI/CKX_LOCKED,
        LF_DISPLAY type ABAP_BOOL.

  move IF_DISPLAY to LF_DISPLAY.

  LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
  if LF_LOCKED ne ABAP_TRUE.
    move ABAP_TRUE to LF_DISPLAY.
  endif.

  LF_PMATY = ME->GET_PMATY( ).
  LF_WERKS = ME->GET_WERKS( ).

  ME->GET_DETAIL_SHIPMGR( importing EF_CPACK = LF_CPACK ).

  ME->GET_DETAIL_SHIPUNIT( importing EF_SHUNT = LF_SHUNT
                                     EF_SHUTY = LF_SHUTY ).



  RF_PAMAI = ZCL_VCXI_XCSU_SHLP_PAMAI=>CALL_SHLP( IF_WERKS   = LF_WERKS
                                                  IF_CPACK   = LF_CPACK
                                                  IF_SHUTY   = LF_SHUTY
                                                  IF_SHUNT   = LF_SHUNT
                                                  IF_PMATY   = LF_PMATY
                                                  IF_DISPLAY = LF_DISPLAY ).

endmethod.
method CALL_SHLP_PMATN.

  data: LF_PMATY   type ZVCXI_XCSU_PMATY,
        LF_WERKS   type WERKS_D,
        LF_LOCKED  type /VCXI/CKX_LOCKED,
        LF_DISPLAY type ABAP_BOOL,
        LF_ALL     type ABAP_BOOL.

  move IF_DISPLAY to LF_DISPLAY.

  LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
  if LF_LOCKED ne ABAP_TRUE.
    move ABAP_TRUE to LF_DISPLAY.
  endif.

  LF_PMATY = ME->GET_PMATY( ).
  LF_WERKS = ME->GET_WERKS( ).

*** Check Type of searchhelp
  if ME->F_VALID_MATNR eq C_VALID_MATNR_C.
    LF_ALL = ABAP_FALSE.
  elseif ME->F_VALID_MATNR eq C_VALID_MATNR_A.
    LF_ALL = ABAP_TRUE.
  endif.

*** Call Searchhelp
  RF_PMATN = ZCL_VCXI_XCSU_SHLP_PMATN=>CALL_SHLP( IF_PMATY   = LF_PMATY
                                                  IF_WERKS   = LF_WERKS
                                                  IF_DISPLAY = LF_DISPLAY
                                                  IF_ALL     = LF_ALL ).
endmethod.
method CALL_SHLP_PMATY.

  data: LF_SHUNT   type ZVCXI_XCSU_SHUNT,
        LF_LOCKED  type /VCXI/CKX_LOCKED,
        LF_DISPLAY type ABAP_BOOL.

  move IF_DISPLAY to LF_DISPLAY.

  LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
  if LF_LOCKED ne ABAP_TRUE.
    move ABAP_TRUE to LF_DISPLAY.
  endif.

  ME->GET_DETAIL_SHIPUNIT( importing EF_SHUNT = LF_SHUNT ).

  RF_PMATY = ZCL_VCXI_XCSU_SHLP_PMATY=>CALL_SHLP( IF_SHUNT   = LF_SHUNT
                                                  IF_DISPLAY = LF_DISPLAY ).

endmethod.
method CHECK_CONSC.
*** RF_SUBRC = 0 => Consumption Scheme is maintained.
*** RF_SUBRC = 1 => Consumption Scheme is not maintained.
*** RF_SUBRC = 2 => Consumption Scheme is not vaild for Packaging Material Type.
*** RF_SUBRC = 3 => Shipping & Unitizing Customizing is not instantiated.
*** RF_SUBRC = 4 => Consumption Scheme is not vaild for Packaging Material Type and Plant.

  data:          LF_PMATY  type ZVCXI_XCSU_PMATY,
                 LF_WERKS  type WERKS_D,
                 LF_CONSC  type ZVCXI_XCSU_CONSC.
  data:          LT_CONSC  type ZVCXI_XCSU_TT_CONSC.

  LF_WERKS = ME->GET_WERKS( ).
  LF_PMATY = ME->GET_PMATY( ).
  ME->GET_CONSC( importing EF_CONSC = LF_CONSC ).

***--------------------------------------------------------------------------------------
*** Start Positiv
  RF_SUBRC = 0.

***--------------------------------------------------------------------------------------
*** Check if it is initial or not
  if LF_CONSC is initial.
    RF_SUBRC = 1.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Shipping & Unitizing Customizing is instantiated.
  if ME->R_CUST_SHIPU is not bound.
    RF_SUBRC = 3.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check if it is valid vor Packaging Material Type
  LT_CONSC = ME->R_CUST_SHIPU->GET_CONSC_FOR_PMATY( IF_PMATY = LF_PMATY ).
  read table LT_CONSC with key CONSC = LF_CONSC transporting no fields.

  if SY-SUBRC ne 0.
    RF_SUBRC = 2.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check if it is valid vor Packaging Material Type and Plant
  LT_CONSC = ME->R_CUST_SHIPU->GET_CONSC_FOR_PMATY( IF_PMATY = LF_PMATY
                                                    IF_WERKS = LF_WERKS ).
  read table LT_CONSC with key CONSC = LF_CONSC transporting no fields.

  if SY-SUBRC ne 0.
    RF_SUBRC = 4.
    exit.
  endif.

endmethod.
method CHECK_LIFNR.

*** 0 - No Check
*** 1 - Vendor is maintained and correct
*** 2 - Vendor is not maintained.   (not in use)
*** 3 - Vendor is not correct.

  data: LF_LIFNR type        LIFNR,
        LF_WERKS type        WERKS_D.
  data: LR_CX_CKX   type ref to /VCXI/CX_CKX.

***----------------------------------------------------------------------------
*** Get Vendor and check if maintained
  move ME->GET_LIFNR( ) to LF_LIFNR.
  if LF_LIFNR is initial.
    move 0 to RF_SUBRC.    " No Check
    exit.
  endif.

***----------------------------------------------------------------------------
*** Get Plant
  move ME->GET_WERKS( ) to LF_WERKS.

***----------------------------------------------------------------------------
*** Perform Check
  try.
      ZCL_VCXI_XCS_SERVICE=>CHECK_LIFNR( IF_LIFNR = LF_LIFNR
                                         IF_WERKS = LF_WERKS ).
    catch /VCXI/CX_CKX into LR_CX_CKX.
      move 3 to RF_SUBRC.
      if IR_MSG is bound.
        IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endif.
      exit.
  endtry.

***----------------------------------------------------------------------------
*** Check was successful
  move 1 to RF_SUBRC.
  if IR_MSG is bound.
    IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSS'
                         IF_MSGTY = 'S'
                         IF_MSGNO = '008' ).
  endif.

endmethod.
method CHECK_PMATN.
*** RF_SUBRC = 0 => Material is maintained and valid.
*** RF_SUBRC = 1 => Material Number is not maintained.
*** RF_SUBRC = 2 => Material Instance was not created.
*** RF_SUBRC = 3 => Material Number is not valid.
*** RF_SUBRC = 4 => Material Number is not valid in Plant.
*** RF_SUBRC = 5 => Material Number is not valid for Packaging Material Type.
*** RF_SUBRC = 6 => Material Number do not Support Packaging Material Quantity.
*** RF_SUBRC = 7 => Shipping & Unitizing Customizing is not instantiated.

  data: LF_PMATN type ZVCXI_XCSU_PMATN,
        LF_PMATY type ZVCXI_XCSU_PMATY.
  data: LS_PMQTY type ZVCXI_XCSU_S_PMQTY.
  data: LT_PMATN type ZVCXI_XCSU_TT_PMATN.

  LF_PMATN = ME->GET_PMATN( ).

***--------------------------------------------------------------------------------------
*** Start Positiv
  RF_SUBRC = 0.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Number is maintained
  if LF_PMATN is initial.
    RF_SUBRC = 1.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Instance was created
  if ME->R_CUST_PACKMAT is not bound.
    RF_SUBRC = 2.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Number is valid
  if ME->R_CUST_PACKMAT->F_CHECK_MATNR ne ABAP_TRUE.
    RF_SUBRC = 3.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Number is valid in Plant
  if ME->R_CUST_PACKMAT->F_CHECK_MAT_MARC ne ABAP_TRUE.
    RF_SUBRC = 4.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Do check against Customizing only if Attribute defines it
  if ME->F_VALID_MATNR eq C_VALID_MATNR_C.
***--------------------------------------------------------------------------------------
*** Check Shipping & Unitizing Customizing is instantiated.
    if ME->R_CUST_SHIPU is not bound.
      RF_SUBRC = 7.
      exit.
    endif.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Number is in customizing
    LF_PMATY = ME->GET_PMATY( ).
    LT_PMATN = ME->R_CUST_SHIPU->GET_PMATN_FOR_PMATY( IF_PMATY = LF_PMATY ).
    read table LT_PMATN with key PMATN = LF_PMATN transporting no fields.
    if SY-SUBRC ne 0.
      RF_SUBRC = 5.
      exit.
    endif.
  endif.

***--------------------------------------------------------------------------------------
*** Check that Packaginag Material Supports the Element's Unit
  ME->GET_PMQTY( importing ES_PMQTY = LS_PMQTY ).
  if ME->IS_VALID_UNIT( IF_MATNR = LF_PMATN
                        IF_UNIT  = LS_PMQTY-PMQTY_UOM ) eq ABAP_FALSE.
    RF_SUBRC = 6.
    exit.
  endif.

endmethod.
method CHECK_PMATY.
*** RF_SUBRC = 0 => Packaging Material Type is maintained.
*** RF_SUBRC = 1 => Packaging Material Type is not maintained.
*** RF_SUBRC = 2 => Packaging Material Type is not valid for Shipping Unit.
*** RF_SUBRC = 3 => Packaging Material Type is not valid for SmartVC Element.
*** RF_SUBRC = 4 => Shipping & Unitizing Customizing is not instantiated.
*** RF_SUBRC = 5 => Packaging Material Type is not valid for Packaging Code

  data:          LF_SHUNT type          ZVCXI_XCSU_SHUNT,
                 LF_ISVCE type          ZVCXI_XCS_ISVCE,
                 LF_PMATY type          ZVCXI_XCSU_PMATY,
                 LF_SHUTY type          ZVCXI_XCSU_SHUTY,
                 LF_WERKS type          WERKS_D,
                 LF_CPACK type          ZVCXI_XCSU_CPACK,
                 LF_GUID  type          /VCXI/CKX_GUID.
  data:          LT_PMATY type          ZVCXI_XCSU_TT_PMATY.
  data:          LR_CPACK type ref to   ZCL_VCXI_XCSUC_CPACK.

***--------------------------------------------------------------------------------------
*** Start Positiv
  RF_SUBRC = 0.

  ME->GET_DETAIL_SHIPUNIT( importing EF_SHUNT = LF_SHUNT ).
  LF_ISVCE = ME->R_GATE->F_ID.
  LF_PMATY = ME->GET_PMATY( ).

***--------------------------------------------------------------------------------------
*** Check if packaging Material Type is initial or not
  if LF_PMATY is initial.
    RF_SUBRC = 1.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Shipping & Unitizing Customizing is instantiated.
  if ME->R_CUST_SHIPU is not bound.
    RF_SUBRC = 4.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** make sure it is valid for shipping unit
  LT_PMATY = ME->R_CUST_SHIPU->GET_PMATY_FOR_SHUNT( IF_SHUNT = LF_SHUNT ).
  read table LT_PMATY with key PMATY = LF_PMATY transporting no fields.
  if SY-SUBRC ne 0.
    RF_SUBRC = 2.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** make sure it is valid for selected SVC Element
  LT_PMATY = ME->R_CUST_SHIPU->GET_PMATY_FOR_ISVCE( IF_ISVCE = LF_ISVCE ).
  read table LT_PMATY with key PMATY = LF_PMATY transporting no fields.
  if SY-SUBRC ne 0.
    RF_SUBRC = 3.
    exit.
  endif.

***--------------------------------------------------------------------------------------
*** Check Packaging Material Type is valid for Packaging Code in case it is a Packaging Code
*** relevant type
  read table ZCL_VCXI_XCSUC_CPACK=>T_PMATY_CPACK_V with key TABLE_LINE = LF_PMATY transporting no fields.
  if SY-SUBRC eq 0.
    ME->GET_DETAIL_SHIPMGR( importing EF_CPACK = LF_CPACK ).

    if LF_CPACK is not initial.
      LF_WERKS = ME->GET_WERKS( ).
      ME->GET_DETAIL_SHIPUNIT( importing EF_SHUTY = LF_SHUTY ).

      move LF_CPACK to LF_GUID.

      try.
          LR_CPACK ?= ZCL_VCXI_XCSUC_CPACK=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_CPACK.
      endtry.

      check LR_CPACK is bound.

      if LR_CPACK->IS_PMATY_VALID( IF_WERKS = LF_WERKS
                                   IF_SHUTY = LF_SHUTY
                                   IF_SHUNT = LF_SHUNT
                                   IF_PMATY = LF_PMATY ) eq ABAP_FALSE.
        RF_SUBRC = 5.
        exit.
      endif.
    endif.
  endif.

endmethod.
method CHECK_PMQTY.
*** RF_SUBRC = 0 => Packaging Material Quantity is maintained.
*** RF_SUBRC = 1 => Packaging Material Quantity is not maintained.

  data: LS_PMQTY  type ZVCXI_XCSU_S_PMQTY.

*** start Positiv
  RF_SUBRC = 0.

  ME->GET_PMQTY( importing ES_PMQTY = LS_PMQTY ).

  if LS_PMQTY-PMQTY is initial.
    RF_SUBRC = 1.
    exit.
  endif.

endmethod.
method CHECK_PRICE.

*** RF_SUBRC = 0 => Price is maintained.
*** RF_SUBRC = 1 => Price is not maintained.

  data: LS_PRICE             type        ZVCXI_XCS_S_PRICE,
        LS_PRICP             type        ZVCXI_XCS_S_PRICP.
  data: LT_GATE              type        /VCXI/VKSR_TT_GATE.
  data: LR_GATE              type ref to /VCXI/CL_VKSR_GATE,
        LR_PSCALE_MGR        type ref to ZIF_VCXI_XCS_PSCALE_MGR.

  LR_GATE = ME->GET_PSCALE_MGR( ).

  if LR_GATE is bound.
*** Start negative
    move 1 to RF_SUBRC.
    try.
        move LR_GATE->R_CLSPR ?to LR_PSCALE_MGR.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PSCALE_MGR.
    endtry.
    check LR_PSCALE_MGR is bound.

*** Price Scale Manager found
    RF_SUBRC = 0.

  else.

*** start Positiv
    RF_SUBRC = 0.

    LS_PRICE = ME->GET_PRICE( ).
    LS_PRICP = ME->GET_PRICP( ).

*** Price is not defined correctly
    if LS_PRICE-PRICE is initial or
       LS_PRICP-PRICP is initial.
      RF_SUBRC = 1.
      exit.
    endif.

  endif.

endmethod.
method CLEAR_FOR_PMATN.

  data:          LS_PRICE      type ZVCXI_XCS_S_PRICE,
                 LS_PRICP      type ZVCXI_XCS_S_PRICP.
  data:          LT_EFFCT      type ZVCXI_XCSU_TT_EFFCT.
  field-symbols: <S_EFFCT>     type ZVCXI_XCSU_S_EFFCT.

  check ME->GET_PMATN( ) is initial.

*** Clear Material data only if it is not maintained.
  if ME->GET_PMATN( ) is initial.
    LS_PRICE = ME->GET_PRICE( ).
    LS_PRICP = ME->GET_PRICP( ).

    LS_PRICE-PRICE = 0.
    LS_PRICP-PRICP = 0.

    ME->SET_PRICE( IS_PRICE = LS_PRICE ).
    ME->SET_PRICP( IS_PRICP = LS_PRICP ).
    ME->SET_TEXT(  IF_TEXT  = SPACE ).
    ME->SET_LIFNR( IF_LIFNR = SPACE ).
    ME->SET_PURCH( IF_PURCH = ABAP_FALSE ).
  endif.

*** Get current Dimension Effects and Clear
  ME->GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).
  loop at LT_EFFCT assigning <S_EFFCT>.
    <S_EFFCT>-DIMVA = 0.
  endloop.
  ME->SET_EFFCT( IT_EFFCT = LT_EFFCT ).

endmethod.
method CLEAR_FOR_PMATY.

  data: LS_PMQTY     type ZVCXI_XCSU_S_PMQTY.

  check ME->GET_PMATY( ) is initial.

*** Clear all values related to pmaty
  ME->SET_PMATN( IF_PMATN = SPACE ).
  ME->SET_CONSC( IF_CONSC = SPACE ).

  ME->GET_PMQTY( importing ES_PMQTY = LS_PMQTY ).
  LS_PMQTY-PMQTY = 0.
  ME->SET_PMQTY( IS_PMQTY = LS_PMQTY ).

endmethod.
method CONSTRUCTOR.

  data: LF_SYSOM type /VCXI/VKS_SYSOM.
  data: LS_CMPRK type /VCXI/VKC_S_CMPRK.

  SUPER->CONSTRUCTOR( IR_GATE = IR_GATE ).

*** Initialize right Pramameter dimensions
  ME->INIT_DIM_PARAM( ).

*** Initialize Valid Material
  ME->INIT_VALID_MATNR( ).

*** Initialize Configuratin informations
  ME->R_GATE->GET_CONFIG_INFO( importing ES_CMPRK = LS_CMPRK
                                         EF_SYSOM = LF_SYSOM ).

  ME->S_COMOD-CMATN = LS_CMPRK-CMATN.
  ME->S_COMOD-PRFID = LS_CMPRK-PRFID.
  ME->S_COMOD-MSYST = LF_SYSOM.

endmethod.
method GET_CONSC.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_CONSC ).
  move LS_PARAM-ATWRT to EF_CONSC.
  move LS_PARAM-SETBY to EF_SETBY.

endmethod.
method GET_CONSC_DESCR.

  data: LF_CONSC type ZVCXI_XCSU_CONSC.

  check ME->R_CUST_SHIPU is bound.
  ME->GET_CONSC( importing EF_CONSC = LF_CONSC ).
  RF_DESCR = ME->R_CUST_SHIPU->GET_DESCR_FOR_CONSC( IF_CONSC = LF_CONSC ).

endmethod.
method GET_COUNT.

  data:          LS_PRVDR_DEF       type        /VCXI/VKSR_S_PRVDR_DEF.
  data:          LT_GATE_TMP        type        /VCXI/VKSR_TT_GATE,
                 LT_GATE            type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_DEF       type        /VCXI/VKSR_TT_PRVDR_DEF.
  data:          LR_GATE            type ref to /VCXI/CL_VKSR_GATE.

*** Get Provider Definitions -> Sibling
  LT_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_SIBLING ).
  delete adjacent duplicates from LT_PRVDR_DEF comparing IPRVT.

*** Get all my Siblings
  try.
      loop at LT_PRVDR_DEF into LS_PRVDR_DEF.
        LT_GATE_TMP = ME->R_GATE->GET_PRVDR( IF_IPRVT = LS_PRVDR_DEF-IPRVT
                                             IF_INUSE  = ABAP_TRUE ).
        append lines of LT_GATE_TMP to LT_GATE.
      endloop.

      ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE ).

      loop at LT_GATE into LR_GATE.
        add 10 to RF_COUNT.
        if ME->R_GATE = LR_GATE.
          exit.
        endif.
      endloop.

    catch /VCXI/CX_CKX.
      exit.
  endtry.

endmethod.
method GET_DESCR.

  data: LF_PMATN_DESCR type /VCXI/CKX_DESCR,
        LF_PMATY_DESCR type /VCXI/CKX_DESCR.

  LF_PMATN_DESCR = ME->GET_PMATN_DESCR( ).

*** First Try Packaging Material Descripition
  if LF_PMATN_DESCR is not initial.
    RF_DESCR = LF_PMATN_DESCR.
  else.
*** Then Packaging Material Type Description
    LF_PMATY_DESCR = ME->GET_PMATY_DESCR( ).
    if LF_PMATY_DESCR is not initial.
      RF_DESCR = LF_PMATY_DESCR.
*** And Last Element Description
    else.
      RF_DESCR = SUPER->GET_DESCR( ).
    endif.
  endif.

endmethod.
method GET_DETAIL_SHIPMGR.

  clear: EF_CPACK, EF_SHSCH, ER_DFLT_SHIPU.
  check ME->R_PR_SHIPMGR is bound.

  if EF_CPACK is requested.
    EF_CPACK = ME->R_PR_SHIPMGR->GET_CPACK( ).
  endif.

  if EF_SHSCH is requested.
    EF_SHSCH = ME->R_PR_SHIPMGR->GET_SHSCH( ).
  endif.

  if ER_DFLT_SHIPU is requested.
    ER_DFLT_SHIPU = ME->R_PR_SHIPMGR->GET_DFLT_SHIPU( ).
  endif.

endmethod.
method GET_DETAIL_SHIPUNIT.

  data:          LT_GATE               type        /VCXI/VKSR_TT_GATE.
  data:          LR_GATE               type ref to /VCXI/CL_VKSR_GATE,
                 LR_PR_SHIPUNIT        type ref to ZCL_VCXI_XCSU_PR_SHIPUNIT.

  try.

      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPUNIT=>C_IPRVT_XCS_SHIPUNIT
                                       IF_INUSE = ABAP_TRUE ).

      loop at LT_GATE into LR_GATE.
        try.
            if LR_GATE->R_CLSPR is bound.
              move LR_GATE->R_CLSPR ?to LR_PR_SHIPUNIT.
              check LR_PR_SHIPUNIT is bound.
              exit.
            endif.
          catch CX_SY_MOVE_CAST_ERROR.
            clear: ET_DIMEN, EF_SHUNT.
        endtry.
      endloop.

    catch /VCXI/CX_CKX.
      clear: ET_DIMEN, EF_SHUNT.
  endtry.

  check LR_PR_SHIPUNIT is bound.
  if ET_DIMEN is requested.
    ET_DIMEN = LR_PR_SHIPUNIT->CALC_ADJ_DIMEN_UPTO( IR_GATE = ME->R_GATE ).
  endif.

  if EF_SHUNT is requested.
    EF_SHUNT = LR_PR_SHIPUNIT->GET_SHUNT( ).
  endif.


  if EF_SHUTY is requested.
    EF_SHUTY = LR_PR_SHIPUNIT->GET_SHUTY( ).
  endif.

  if ER_PREV_PACKMAT is requested.
    ER_PREV_PACKMAT = LR_PR_SHIPUNIT->GET_PREV_PACKMAT( IR_GATE = ME->R_GATE ).
  endif.

  if ER_NEXT_PACKMAT is requested.
    ER_NEXT_PACKMAT = LR_PR_SHIPUNIT->GET_NEXT_PACKMAT( IR_GATE = ME->R_GATE ).
  endif.

endmethod.
method GET_EFFCT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.
  data:  LR_ERROR   type ref to CX_TRANSFORMATION_ERROR.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_EFFCT ).

  try.
      if LS_PARAM-STRNG is not initial.
        call transformation ID
               source xml LS_PARAM-STRNG
               result TABLE = ET_EFFCT.
      endif.

    catch CX_TRANSFORMATION_ERROR into LR_ERROR.
      /VCXI/CX_CKX=>RAISE_CKX_BY_PREVIOUS( IR_PREVIOUS = LR_ERROR ).
  endtry.

  move LS_PARAM-SETBY to EF_SETBY.

endmethod.
method GET_FOVRR_CONSC.

  data: LF_SETBY type /VCXI/VKSR_SETBY.

*** Get setby from Consumption Scheme
  ME->GET_CONSC( importing EF_SETBY = LF_SETBY ).

  case LF_SETBY.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_USER.
      move ABAP_TRUE to RF_FOVRR.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
      move ABAP_FALSE to RF_FOVRR.
  endcase.

endmethod.
method GET_FOVRR_EFFCT.

  data: LF_SETBY type /VCXI/VKSR_SETBY.

*** Get setby from Effects
  ME->GET_EFFCT( importing EF_SETBY = LF_SETBY ).

  case LF_SETBY.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_USER.
      move ABAP_TRUE to RF_FOVRR.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
      move ABAP_FALSE to RF_FOVRR.
  endcase.

endmethod.
method GET_FOVRR_PMQTY.

  data: LF_SETBY type /VCXI/VKSR_SETBY.

*** Get setby from Packaging Material Quantity
  ME->GET_PMQTY( importing EF_SETBY = LF_SETBY ).

  case LF_SETBY.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_USER.
      move ABAP_TRUE to RF_FOVRR.
    when /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
      move ABAP_FALSE to RF_FOVRR.
  endcase.

endmethod.
method GET_LIFNR.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_LIFNR ).
  move LS_PARAM-ATWRT to RF_LIFNR.

endmethod.
method GET_LIFNR_DESCR.

  data: LF_LIFNR       type LIFNR,
        LF_LIFNR_DESCR type /VCXI/CKX_DESCR.

  LF_LIFNR = ME->GET_LIFNR( ).
  check LF_LIFNR is not initial.

  select single NAME1
         from LFA1
         into LF_LIFNR_DESCR
        where LIFNR eq LF_LIFNR.

  if SY-SUBRC = 0.
    move LF_LIFNR_DESCR to RF_LIFNR_DESCR.
  endif.

endmethod.
method GET_PAMAI.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PAMAI ).
  move LS_PARAM-ATWRT to RF_PAMAI.

endmethod.
method GET_PAMAI_DESCR.

  data: LF_PAMAI type ZVCXI_XCSU_PAMAI.
  data: LS_DESCR type ZVCXI_XCS_TC360T.

  LF_PAMAI = ME->GET_PAMAI( ).
  read table ZCL_VCXI_XCSUC_CPACK=>T_PAMAI_DESCR into LS_DESCR with key PAMAI = LF_PAMAI
                                                                        LANGU = SY-LANGU.

  check SY-SUBRC = 0.
  move LS_DESCR-DESCR to RF_DESCR.

endmethod.
  method GET_PIREM.

    check ME->R_CUST_SHIPU is bound.
    RF_PIREM = ME->R_CUST_SHIPU->GET_PIREM_FOR_PMATY( IF_PMATY = ME->GET_PMATY( ) ).

  endmethod.
method GET_PMATN.

  data:  LS_LEOKY  type  /VCXI/VKSR_S_LEOKY.

  LS_LEOKY = ME->R_GATE->GET_LEOKY( ).

  move LS_LEOKY-LEOKY to RF_MATNR.

endmethod.
method GET_PMATN_DESCR.

  data:  LF_MATNR type MATNR.
  data:  LS_MAKT  type MAKT.

  LF_MATNR = ME->GET_PMATN( ).

  call function 'MAKT_SINGLE_READ'
    exporting
      MATNR      = LF_MATNR
      SPRAS      = SY-LANGU
    importing
      WMAKT      = LS_MAKT
    exceptions
      WRONG_CALL = 1
      NOT_FOUND  = 2
      others     = 3.

  if SY-SUBRC ne 0.
    clear RF_DESCR.
  else.
    move LS_MAKT-MAKTX to RF_DESCR.
  endif.

endmethod.
method GET_PMATN_SETBY.

  data:  LS_LEOKY  type  /VCXI/VKSR_S_LEOKY.

  LS_LEOKY = ME->R_GATE->GET_LEOKY( ).
  move LS_LEOKY-SETBY to RF_SETBY.

endmethod.
method GET_PMATY.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PMATY ).
  move LS_PARAM-ATWRT to RF_PMATY.

endmethod.
method GET_PMATY_DESCR.

  data: LF_PMATY type ZVCXI_XCSU_PMATY.

  check ME->R_CUST_SHIPU is bound.
  LF_PMATY = ME->GET_PMATY( ).
  RF_DESCR = ME->R_CUST_SHIPU->GET_DESCR_FOR_PMATY( IF_PMATY = LF_PMATY ).

endmethod.
method GET_PMQTY.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = ME->F_PARID_PMQTY ).
  move LS_PARAM-ATFLV to ES_PMQTY-PMQTY.
  move LS_PARAM-UNIT  to ES_PMQTY-PMQTY_UOM.
  move LS_PARAM-SETBY to EF_SETBY.

endmethod.
method GET_PRICE.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PRICE ).
  move LS_PARAM-ATFLV to RS_PRICE-PRICE.
  move LS_PARAM-CURKY to RS_PRICE-PRICE_CURR.

endmethod.
method GET_PRICP.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = ME->F_PARID_PRICP ).
  move LS_PARAM-ATFLV to RS_PRICP-PRICP.
  move LS_PARAM-UNIT  to RS_PRICP-PRICP_UOM.

endmethod.
method GET_PSCALE_MGR.

  data:  LS_PRVDR_DEF       type        /VCXI/VKSR_S_PRVDR_DEF.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE,
         LT_PRVDR_DEF       type        /VCXI/VKSR_TT_PRVDR_DEF.

***------------------------------------------------------------------------------------------------
*** Get Gate of Price Scale Manager
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZIF_VCXI_XCS_PSCALE_MGR=>C_IPRVT_XCS_PSCALE_MGR
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = ABAP_TRUE ).

  read table LT_GATE into RR_GATE index 1.

***------------------------------------------------------------------------------------------------
  if RR_GATE is not bound and
     IF_CREATE   eq ABAP_TRUE.
*** Get Provider definition for Price Scale Manager
    LT_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( IF_IPRVT = ZIF_VCXI_XCS_PSCALE_MGR=>C_IPRVT_XCS_PSCALE_MGR
                                              IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD ).

    read table LT_PRVDR_DEF into LS_PRVDR_DEF index 1.
    check SY-SUBRC eq 0.
    RR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = LS_PRVDR_DEF-ID ).
    if RR_GATE->GET_USYNC( ) eq ABAP_FALSE.
      RR_GATE->SET_INUSE( IF_INUSE = ABAP_TRUE ).
    endif.
  endif.

endmethod.
method GET_PURCH.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PURCH ).
  move LS_PARAM-ATWRT to RF_PURCH.

endmethod.
method GET_SCALE.

*** Check if Price Scale Manager is activated
  check ME->GET_PSCALE_MGR( ) is bound.
  move ABAP_TRUE to RF_SCALE.

endmethod.
method GET_STATUS.

  RF_ELMST = SUPER->GET_STATUS( ).

***------------------------------------------------------------------
*** Check Material
  if ME->CHECK_PMATN( ) eq 0.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check Packaging Material Type
  case ME->CHECK_PMATY( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

***------------------------------------------------------------------
*** Check Packaging Material Quantity
  case ME->CHECK_PMQTY( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

***------------------------------------------------------------------
*** Check Consumption Scheme
  case ME->CHECK_CONSC( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

***------------------------------------------------------------------
  if ME->GET_PURCH( ) ne ZCL_VCXI_XCSS_PR_MS=>C_PURCH_STOCK.
*** Check Vendor - only for Purchased Material
    case ME->CHECK_LIFNR( ).
      when 0.  " No Check
      when 1.  " Vendor is maintained and correct
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
      when others.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
    endcase.
  endif.

*** Only for Direct Procurement & Price
  if ME->GET_PURCH( ) eq ZCL_VCXI_XCSS_PR_MS=>C_PURCH_DIRECT_PRICE.
*** Check Price
    case ME->CHECK_PRICE( ).
      when 0.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
      when others.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
    endcase.
  endif.

endmethod.
method GET_STATUS_MSG.

  data: LF_WERKS type WERKS_D.

  SUPER->GET_STATUS_MSG( IR_MESSAGE = IR_MESSAGE ).

***------------------------------------------------------------------
*** Check Packaging Material
  case ME->CHECK_PMATN( ).
    when 1.
***   Material Number is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '001' ).
    when 2.
***   Material Instance was not created.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '002' ).
    when 3.
***   Material Number is not valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '003' ).
    when 4.
***   Material Number is not valid in Plant.
      LF_WERKS = ME->GET_WERKS( ).
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '004'
                               IF_MSGV1 = LF_WERKS ).
    when 5.
***   Material Number is not valid for Packaging Material Type.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '006' ).
    when 6.
***   Material Number do not Support Packaging Material Quantity.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '007' ).
    when 7.
***   Shipping & Unitizing Customizing is not instantiated.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '118' ).
    when others.
***   Material is maintained and valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '005' ).
  endcase.

***------------------------------------------------------------------
*** Check Packaging Material Type
  case ME->CHECK_PMATY( ).
    when 0.
***   Packaging Material Type is maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '008' ).
    when 1.
***   Packaging Material Type is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '009' ).
    when 2.
***   Packaging Material Type is not valid for Shipping Unit.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '010' ).
    when 3.
***   Packaging Material Type is not valid for SmartVC Element.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '011' ).
    when 4.
***   Shipping & Unitizing Customizing is not instantiated.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '118' ).

    when 5.
***   Packaging Material Type is not valid for Packaging Code.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '022' ).
  endcase.

***------------------------------------------------------------------
*** Check Packaging Material Quantity
  case ME->CHECK_PMQTY( ).
    when 0.
***   Packaging Material Quantity is maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '012' ).
    when 1.
***   Packaging Material Quantity is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '013' ).
  endcase.

***------------------------------------------------------------------
*** Check Consumption Scheme
  case ME->CHECK_CONSC( ).
    when 0.
***   Consumption Scheme is maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '014' ).
    when 1.
***   Consumption Scheme is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '015' ).
    when 2.
***   Consumption Scheme is not vaild for Packaging Material Type.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '016' ).
    when 3.
***   Shipping & Unitizing Customizing is not instantiated.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '118' ).
    when 4.
***   Consumption Scheme is not vaild for Packaging Material Type and Plant.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '023' ).
  endcase.

***------------------------------------------------------------------
  if ME->GET_PURCH( ) ne ZCL_VCXI_XCSS_PR_MS=>C_PURCH_STOCK.
*** Check Vendor - only for Purchased Material
    ME->CHECK_LIFNR( IR_MSG = IR_MESSAGE ).
  endif.

*** Only for Direct Procurement & Price
  if ME->GET_PURCH( ) eq ZCL_VCXI_XCSS_PR_MS=>C_PURCH_DIRECT_PRICE.
*** Check Price
    case ME->CHECK_PRICE( ).
      when 0.
***     Price is maintained.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                                 IF_MSGTY = 'S'
                                 IF_MSGNO = '020' ).
      when 1.
***     Price is not maintained.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_XCSU'
                                 IF_MSGTY = 'E'
                                 IF_MSGNO = '021' ).
    endcase.
  endif.

endmethod.
method GET_TEXT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TEXT ).
  move LS_PARAM-ATWRT to RF_TEXT.

endmethod.
  method GET_WERKS.

    data: LT_GATE type /VCXI/VKSR_TT_GATE.

    if ME->R_PR_SHIPMGR is bound.
      RF_WERKS = ME->R_PR_SHIPMGR->GET_WERKS( ).
    else.
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_IPRVT_XCS_SHIPMGR
                                       IF_INUSE = ABAP_TRUE ).
      check LT_GATE is not initial.
      RF_WERKS = cast ZCL_VCXI_XCSU_PR_SHIPMGR( LT_GATE[ 1 ]->R_CLSPR )->GET_WERKS( ).
    endif.

  endmethod.
method HANDLE_EVENT.

  data: LF_OWN_EVENT      type        ABAP_BOOL,
        LF_SHIPUNIT_EVENT type        ABAP_BOOL.
  data: LR_GATE_SHIPUNIT type ref to /VCXI/CL_VKSR_GATE.

*** ----------------------------------------------------------------------
*** Try to catch own events
  read table IT_GATE_PROVIDER with key TABLE_LINE = ME->R_GATE
                              transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to LF_OWN_EVENT.
  endif.

*** Try to Get Shipping Manager Event
  move ME->R_GATE->GET_PARENT( ) to LR_GATE_SHIPUNIT.
  if LR_GATE_SHIPUNIT is bound.
    read table IT_GATE_PROVIDER with key TABLE_LINE = LR_GATE_SHIPUNIT
                                transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to LF_SHIPUNIT_EVENT.
    endif.
  endif.

*** ----------------------------------------------------------------------
*** Do Event Handling
  SUPER->HANDLE_EVENT( IF_IEVNT         = IF_IEVNT
                       IT_GATE_PROVIDER = IT_GATE_PROVIDER ).

  case IF_IEVNT.
    when C_IEVNT_I_INIT_CUST_MATNR.
      ME->HANDLE_INIT_CUST_MATNR( ).

    when C_IEVNT_I_INIT_PURCH.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_INIT_PURCH( ).

    when C_IEVNT_I_INIT_PRICE.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_INIT_PRICE( ).

    when C_IEVNT_I_SET_DEFAULT.
      check LF_OWN_EVENT     eq ABAP_TRUE or
            LF_SHIPUNIT_EVENT eq ABAP_TRUE.
      ME->HANDLE_SET_DEFAULT( ).

    when C_IEVNT_I_INIT_REFERENCES.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_INIT_REFERENCES( ).

    when C_IEVNT_I_RESET_PMATN.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_RESET_PMATN( ).

    when C_IEVNT_I_RESET_PMATY.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_RESET_PMATY( ).

    when C_IEVNT_I_RESET_EFFCT.
      check LF_OWN_EVENT eq ABAP_TRUE.
      ME->HANDLE_RESET_EFFCT( ).

    when C_IEVNT_I_RECALC_DETAILS.
      ME->HANDLE_RECALC_DETAILS( IT_GATE = IT_GATE_PROVIDER ).
  endcase.

endmethod.
method HANDLE_INIT_CUST_MATNR.

  data:  LF_MATNR type MATNR,
         LF_WERKS type WERKS_D.

  move ME->GET_PMATN( )            to LF_MATNR.
  move ME->GET_WERKS( )            to LF_WERKS.

  if ME->R_CUST_PACKMAT          is bound    and
     ME->R_CUST_PACKMAT->F_MATNR eq LF_MATNR and
     ME->R_CUST_PACKMAT->F_WERKS eq LF_WERKS.
*** Everything was loaded already...
    exit.
  endif.

  clear ME->R_CUST_PACKMAT.

*** Catch Error while Material Customizing Instanziation
  try.

***   Load the Customizing
      ME->R_CUST_PACKMAT = ZCL_VCXI_XCSU_CUST_PACKMAT=>GET_INSTANCE_XCSU_PACKMAT( IF_MATNR = LF_MATNR
                                                                                  IF_WERKS = LF_WERKS
                                                                                  IF_DATE  = SY-DATUM ).

    catch /VCXI/CX_CKX.
***   It is not needed to handle Exception
      exit.
  endtry.

endmethod.
  method HANDLE_INIT_PRICE.

    data: LS_PRICE type ZVCXI_XCS_S_PRICE,
          LS_PRICP type ZVCXI_XCS_S_PRICP.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.


*** Different behavior based on Procurement Option
    case ME->GET_PURCH( ).

***------------------------------------------------------------------------------------------------
***   Stock Items
      when ZCL_VCXI_XCSS_PR_MS=>C_PURCH_STOCK.
***     Clear Price Data
        ME->SET_PRICE( IF_SETBY = SPACE ).
        ME->SET_PRICP( IF_SETBY = SPACE ).

***     Free Price Scale Manager
        LR_GATE = ME->GET_PSCALE_MGR( IF_CREATE = ABAP_FALSE ).
        if LR_GATE is bound.
          LR_GATE->DO_FREE( ).
        endif.

***     Clear Vendor
        ME->SET_LIFNR( IF_LIFNR = SPACE
                       IF_SETBY = SPACE ).

***------------------------------------------------------------------------------------------------
***  Direct Procurement
      when ZCL_VCXI_XCSS_PR_MS=>C_PURCH_DIRECT.
***     Clear Price Data
        ME->SET_PRICE( IF_SETBY = SPACE ).
        ME->SET_PRICP( IF_SETBY = SPACE ).

***     Free Price Scale Manager
        LR_GATE = ME->GET_PSCALE_MGR( IF_CREATE = ABAP_FALSE ).
        if LR_GATE is bound.
          LR_GATE->DO_FREE( ).
        endif.

***------------------------------------------------------------------------------------------------
***  Direct Procurement & Price
      when ZCL_VCXI_XCSS_PR_MS=>C_PURCH_DIRECT_PRICE.
***     Check if we have the Material Instance
        check ME->R_CUST_PACKMAT is bound.

        move ME->GET_PRICE( ) to LS_PRICE.
        if LS_PRICE-PRICE is initial.
          ME->SET_PRICE( IS_PRICE = ME->R_CUST_PACKMAT->S_PRICE ).
        endif.

        move ME->GET_PRICP( ) to LS_PRICP.
        if LS_PRICP-PRICP is initial.
          if ME->R_CUST_PACKMAT->S_PRICP-PRICP_UOM is not initial.
***         Do Material Conversion
            ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_MATNR_UNIT( exporting IF_UOM_OUT   = LS_PRICP-PRICP_UOM
                                                                     IF_UOM_IN    = ME->R_CUST_PACKMAT->S_PRICP-PRICP_UOM
                                                                     IF_VALUE_IN  = ME->R_CUST_PACKMAT->S_PRICP-PRICP
                                                                     IF_MATNR     = ME->GET_PMATN( )
                                                           importing EF_VALUE_OUT = LS_PRICP-PRICP
                                                                     EF_UOM_OUT   = LS_PRICP-PRICP_UOM ).
          else.
***         Can't be converted
            clear LS_PRICP-PRICP.
          endif.

          ME->SET_PRICP( IS_PRICP = LS_PRICP ).
        endif.
    endcase.

  endmethod.
method HANDLE_INIT_PURCH.

  data: LF_MATNR type MATNR.

  move ME->GET_PMATN( ) to LF_MATNR.

*** Is Matrial a Dummy -> Set Purchase Flag!
  if ZCL_VCXI_XCS_CUST_MATNR=>IS_DUMMY_MATNR( IR_GATE  = ME->R_GATE
                                              IF_MATNR = LF_MATNR   ) eq ABAP_TRUE.
    ME->SET_PURCH( IF_PURCH = ZCL_VCXI_XCSS_PR_MS=>C_PURCH_DIRECT_PRICE ).
  else.
    ME->SET_PURCH( IF_PURCH = ZCL_VCXI_XCSS_PR_MS=>C_PURCH_STOCK ).
  endif.

endmethod.
method HANDLE_INIT_REFERENCES.

  data:          LT_GATE               type        /VCXI/VKSR_TT_GATE.
  data:          LR_GATE               type ref to /VCXI/CL_VKSR_GATE.

*** Get Shipping Manager
  try.
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_IPRVT_XCS_SHIPMGR
                                       IF_INUSE = ABAP_TRUE ).

      loop at LT_GATE into LR_GATE.
        try.
            if LR_GATE->R_CLSPR is bound.
              move LR_GATE->R_CLSPR ?to ME->R_PR_SHIPMGR.
              check ME->R_PR_SHIPMGR is bound.
              exit.
            endif.
          catch CX_SY_MOVE_CAST_ERROR.
            clear: ME->R_PR_SHIPMGR.
        endtry.
      endloop.

    catch /VCXI/CX_CKX.
      clear: ME->R_PR_SHIPMGR.
  endtry.

*** Get Customizing Reference
  if ME->R_CUST_SHIPU is not bound.
    ME->INIT_CUST_SHIPU( ).
  endif.

*** Send Event -> Request Set Default
  ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_REQUEST_SET_DEFAULT ).

endmethod.
method HANDLE_RECALC_DETAILS.

  data:  LF_DO_RECALC      type        ABAP_BOOL.
  data:  LR_GATE           type ref to /VCXI/CL_VKSR_GATE,
         LR_PREV_PACKMAT   type ref to /VCXI/CL_VKSR_GATE,
         LR_NEXT_PACKMAT   type ref to /VCXI/CL_VKSR_GATE.

***  Get Previous and next Packmat
  ME->GET_DETAIL_SHIPUNIT( importing ER_NEXT_PACKMAT = LR_NEXT_PACKMAT
                                     ER_PREV_PACKMAT = LR_PREV_PACKMAT ).

  loop at IT_GATE into LR_GATE.
*** Gate is Parent
    if LR_GATE eq ME->R_GATE->GET_PARENT( ).
***   Do always recalc if Parent was changed!
      LF_DO_RECALC = ABAP_TRUE.
    else.
***   Gate has same ID as me
      if LR_GATE->F_ID eq ME->R_GATE->F_ID.
***     Only Recalc if it is next, previous, me or deleted
        check LR_GATE              eq LR_NEXT_PACKMAT or
              LR_GATE              eq LR_PREV_PACKMAT or
              LR_GATE              eq ME->R_GATE      or
              LR_GATE->IS_INUSE( ) eq ABAP_FALSE.
        LF_DO_RECALC = ABAP_TRUE.
      endif.
    endif.

    check LF_DO_RECALC eq ABAP_TRUE.
    exit.

  endloop.

  check LF_DO_RECALC eq ABAP_TRUE.

  ME->CALC_DETAILS( ).

endmethod.
method HANDLE_RESET_EFFCT.

*** Initialize Effects
  ME->INIT_EFFCT( ).

*** Reset Effects depending on Packaging Material
  ME->SET_PMATN_EFFCT( ).

endmethod.
method HANDLE_RESET_PMATN.

*** Clear values influenced by Packaging Material
    ME->CLEAR_FOR_PMATN( ).

*** Load Defaults for Packaging Material
    ME->LOAD_DFLT_FOR_PMATN( ).

endmethod.
method HANDLE_RESET_PMATY.

*** Initialize Packaging Material
  ME->INIT_PMATY( ).

endmethod.
method HANDLE_SET_DEFAULT.

*** Make it only if we have the ref to our shipping Manager
  check ME->R_PR_SHIPMGR is bound.

  ZCL_VCXI_XCDR_SERVICE=>SET_DEFAULT( IR_GATE = ME->R_GATE ).

endmethod.
method INIT_CUST_SHIPU.

  data:  LT_GATE         type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE         type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_SHIPMGR   type ref to ZCL_VCXI_XCSU_PR_SHIPMGR.

*** Get Reference to Shipping Manager
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_IPRVT_XCS_SHIPMGR
                                   IF_INUSE = ABAP_TRUE ).
  read table LT_GATE into LR_GATE index 1.
  if SY-SUBRC eq 0.
    try.
        if LR_GATE->R_CLSPR is bound.
          move LR_GATE->R_CLSPR ?to LR_PR_SHIPMGR.
        endif.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_SHIPMGR.
    endtry.
  endif.

  if LR_PR_SHIPMGR is bound.
    if LR_PR_SHIPMGR->R_CUST_SHIPU is not bound.
***   Process Events to ensure Shipping Manager has initialized its References
      ME->R_GATE->RAISE_EVENTS( IF_LEVNT = 9 ).
    endif.
*** Use same Reference to Shipping & Unitization Customizing
    move LR_PR_SHIPMGR->R_CUST_SHIPU to ME->R_CUST_SHIPU.
  else.
    clear ME->R_CUST_SHIPU.
  endif.

endmethod.
method INIT_DIM_PARAM.

  data:  LS_PARAM    type /VCXI/VKSR_S_PARAM.
  data:  LT_PARAM    type /VCXI/VKSR_TT_PARAM.

  LT_PARAM = ME->R_GATE->GET_PARAM_ALL( ).

  loop at LT_PARAM into LS_PARAM
                  where PARTY eq /VCXI/CL_VKSC_PARAM=>C_PARTY_NUMC
                   and  ( PARID eq C_PARID_PMQTY_A or
                          PARID eq C_PARID_PMQTY_L or
                          PARID eq C_PARID_PMQTY_P or
                          PARID eq C_PARID_PMQTY_W ).
    move LS_PARAM-PARID to ME->F_PARID_PMQTY.
*** Get dimension key matches parameter unit dimension key.
    call function 'DIMENSION_GET_FOR_UNIT'
      exporting
        LANGUAGE       = SY-LANGU
        UNIT           = LS_PARAM-UNIT
      importing
        DIMENSION      = ME->F_DIMID
      exceptions
        UNIT_NOT_FOUND = 1
        others         = 2.

    check SY-SUBRC = 0.
    exit.
  endloop.

  loop at LT_PARAM into LS_PARAM
                  where PARTY eq /VCXI/CL_VKSC_PARAM=>C_PARTY_NUMC
                   and  ( PARID eq C_PARID_PRICP_A or
                          PARID eq C_PARID_PRICP_L or
                          PARID eq C_PARID_PRICP_P or
                          PARID eq C_PARID_PRICP_W ).
    move LS_PARAM-PARID to ME->F_PARID_PRICP.
    exit.
  endloop.

endmethod.
method INIT_EFFCT.

  data:          LT_EFFCT      type ZVCXI_XCSU_TT_EFFCT,
                 LT_EFFCT_CUST type ZVCXI_XCSU_TT_PMATY_EFFCT.
  data:          LS_EFFCT_CUST type ZVCXI_XCS_TC191.
  data:          LF_PMATY      type ZVCXI_XCSU_PMATY.
  field-symbols: <S_EFFCT>     type ZVCXI_XCSU_S_EFFCT.

  check ME->R_CUST_SHIPU is bound.
  LF_PMATY = ME->GET_PMATY( ).
  check LF_PMATY is not initial.

*** Load Effects if it is initial.
  LT_EFFCT_CUST = ME->R_CUST_SHIPU->GET_EFFCT_FOR_PMATY( IF_PMATY = LF_PMATY ).
  check LT_EFFCT_CUST is not initial.

  loop at LT_EFFCT_CUST into LS_EFFCT_CUST.
    append initial line to LT_EFFCT assigning <S_EFFCT>.
    move-corresponding LS_EFFCT_CUST to <S_EFFCT>.
    case ME->S_COMOD-MSYST.
      when /VCXI/CL_VKSR_RUNTIME=>C_SYSOM_METRIC.
        move LS_EFFCT_CUST-UOMME to <S_EFFCT>-DIMVA_UOM.
      when /VCXI/CL_VKSR_RUNTIME=>C_SYSOM_IMPERIAL.
        move LS_EFFCT_CUST-UOMIM to <S_EFFCT>-DIMVA_UOM.
    endcase.
  endloop.

  ME->SET_EFFCT( IT_EFFCT = LT_EFFCT ).

endmethod.
method INIT_MATNR_DUMMY.

*** Get Dummy Material
  ME->F_MATNR_DUMMY = ZCL_VCXI_XCS_CUST_MATNR=>GET_DUMMY_MATNR( IR_GATE  = ME->R_GATE ).

endmethod.
method INIT_PMATY.

  if ME->R_CUST_SHIPU is not bound.
    ME->INIT_CUST_SHIPU( ).
  endif.

*** Clear values influenced by Packaging Material Type
  ME->CLEAR_FOR_PMATY( ).

*** Initialize Effects
  ME->INIT_EFFCT( ).

endmethod.
method INIT_VALID_MATNR.

  data:  LS_ATTRI    type /VCXI/VKS_S_ATTRI.

  LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_VALID_MATNR ).
  move LS_ATTRI-ATTVA to ME->F_VALID_MATNR.

endmethod.
method IS_DUMMY.

  data: LF_MATNR type MATNR.

  move ME->GET_PMATN( ) to LF_MATNR.

*** Is Matrial a Dummy -> Set Purchase Flag!
  if ZCL_VCXI_XCS_CUST_MATNR=>IS_DUMMY_MATNR( IR_GATE  = ME->R_GATE
                                              IF_MATNR = LF_MATNR   ) eq ABAP_TRUE.
    RF_RETURN = ABAP_TRUE.
  else.
    RF_RETURN = ABAP_FALSE.
  endif.

endmethod.
method IS_SCALE_ACTIVE.

  data:  LT_PRVDR_DEF       type        /VCXI/VKSR_TT_PRVDR_DEF.

***------------------------------------------------------------------------------------------------
*** Get Provider Definitions
    LT_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( IF_IPRVT = ZIF_VCXI_XCS_PSCALE_MGR=>C_IPRVT_XCS_PSCALE_MGR
                                              IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD ).
  check lines( LT_PRVDR_DEF ) is not initial.
  move ABAP_TRUE to RF_ACTIVE.

endmethod.
method IS_VALID_UNIT.

  data: LF_DIMID type DIMID.
  data: LS_MARA  type MARA.

*** Start Positiv
  move ABAP_TRUE to RF_VALID.

  call function 'MARA_SINGLE_READ'
    exporting
      MATNR             = IF_MATNR
    importing
      WMARA             = LS_MARA
    exceptions
      LOCK_ON_MATERIAL  = 1
      LOCK_SYSTEM_ERROR = 2
      WRONG_CALL        = 3
      NOT_FOUND         = 4
      others            = 5.

*** if material is not found, unit is not valid
  if SY-SUBRC ne 0.
    move ABAP_FALSE to RF_VALID.
    exit.
  endif.

*** if base unit is equal to passed unit, unit is valid
  if IF_UNIT eq LS_MARA-MEINS.
    move ABAP_TRUE to RF_VALID.
    exit.
  endif.

  call function 'DIMENSION_GET_FOR_UNIT'
    exporting
      LANGUAGE       = SY-LANGU
      UNIT           = IF_UNIT
    importing
      DIMENSION      = LF_DIMID
    exceptions
      UNIT_NOT_FOUND = 1
      others         = 2.

*** if dimension key not found for unit, invalid
  if SY-SUBRC ne 0.
    move ABAP_FALSE to RF_VALID.
    exit.
  endif.


  if ME->F_DIMID eq C_DIMID_DIMLESS.

*** Check if Base Unit can be converted properly to PMQTY unit
    if IF_UNIT ne LS_MARA-MEINS.
      call function 'MARM_SINGLE_READ'
        exporting
          MATNR      = IF_MATNR
          MEINH      = IF_UNIT
        exceptions
          WRONG_CALL = 1
          NOT_FOUND  = 2
          others     = 3.

***   no alternative unit found for passed unit, invalid
      if SY-SUBRC ne 0.
        move ABAP_FALSE to RF_VALID.
        exit.
      endif.
    endif.

  else.
*** units dimension key does not match attribute defined dimension key
    if LF_DIMID ne ME->F_DIMID.
      call function 'MARM_SINGLE_READ'
        exporting
          MATNR      = IF_MATNR
          MEINH      = IF_UNIT
        exceptions
          WRONG_CALL = 1
          NOT_FOUND  = 2
          others     = 3.

***   no alternative unit found for passed unit, invalid
      if SY-SUBRC ne 0.
        move ABAP_FALSE to RF_VALID.
        exit.
      endif.
    endif.
  endif.

endmethod.
method LOAD_DFLT_FOR_PMATN.

  ME->SET_PMATN_EFFCT( ).

endmethod.
method SET_CONSC.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_CONSC ).

  if IF_CONSC is supplied.
    move IF_CONSC to LS_PARAM-ATWRT.
  else.
    if IF_SETBY is initial.
      clear LS_PARAM-ATWRT.
    endif.
  endif.
  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_CONSC_CHANGED ).
    if IF_SETBY is initial.
***   Send Event -> Request Set Default
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_REQUEST_SET_DEFAULT ).
    endif.
  endif.

endmethod.
method SET_EFFCT.

  data:          LF_CHANGED type        ABAP_BOOL.
  data:          LS_PARAM   type        /VCXI/VKSR_S_PARAM,
                 LS_EFFCT   type        ZVCXI_XCSU_S_EFFCT.
  data:          LT_EFFCT   type        ZVCXI_XCSU_TT_EFFCT.
  data:          LR_ERROR   type ref to CX_TRANSFORMATION_ERROR.
  field-symbols: <S_EFFCT>  type        ZVCXI_XCSU_S_EFFCT.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_EFFCT ).

  if IT_EFFCT is supplied.
    if LS_PARAM-STRNG is not initial.

***   Set Effects with defined System of Measure
      ME->GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).

      loop at LT_EFFCT assigning <S_EFFCT>.
        read table IT_EFFCT with key DIMEN = <S_EFFCT>-DIMEN
                                     EFFCT = <S_EFFCT>-EFFCT
                            into LS_EFFCT.
        check SY-SUBRC = 0.

***     Do Unit Converison
        ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_UNIT( exporting IF_UOM_OUT   = <S_EFFCT>-DIMVA_UOM
                                                           IF_UOM_IN    = LS_EFFCT-DIMVA_UOM
                                                           IF_VALUE_IN  = LS_EFFCT-DIMVA
                                                 importing EF_VALUE_OUT = <S_EFFCT>-DIMVA
                                                           EF_UOM_OUT   = <S_EFFCT>-DIMVA_UOM ).
      endloop.

    else.
      move IT_EFFCT to LT_EFFCT.
    endif.

    try.
        call transformation ID
               source TABLE = LT_EFFCT
               result xml LS_PARAM-STRNG.

      catch CX_TRANSFORMATION_ERROR into LR_ERROR.
        /VCXI/CX_CKX=>RAISE_CKX_BY_PREVIOUS( IR_PREVIOUS = LR_ERROR ).
    endtry.

  else.
    if IF_SETBY is initial.
      clear LS_PARAM-STRNG.
    endif.
  endif.

  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_EFFCT_CHANGED ).
    if IF_SETBY is initial.
***   Send Event -> Request Set Default
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_REQUEST_SET_DEFAULT ).
      if LS_PARAM-STRNG is initial.
***     Send Event -> Request Reset Effects
        ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_REQUEST_RESET_EFFCT ).
      endif.
    endif.
  endif.

endmethod.
method SET_FOVRR_CONSC.

*** Set Setby for Consumption Scheme
  case IF_FOVRR.
    when ABAP_TRUE.
      ME->SET_CONSC( IF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_USER ).
    when ABAP_FALSE.
      ME->SET_CONSC( IF_SETBY = SPACE ).
  endcase.

endmethod.
method SET_FOVRR_EFFCT.

*** Set Setby for Effects
  case IF_FOVRR.
    when ABAP_TRUE.
      ME->SET_EFFCT( IF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_USER ).
    when ABAP_FALSE.
      ME->SET_EFFCT( IF_SETBY = SPACE ).
  endcase.

endmethod.
method SET_FOVRR_PMQTY.

*** Set Setby for Packaging Material Quantity
  case IF_FOVRR.
    when ABAP_TRUE.
      ME->SET_PMQTY( IF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_USER ).
    when ABAP_FALSE.
      ME->SET_PMQTY( IF_SETBY = SPACE ).
  endcase.

endmethod.
method SET_LIFNR.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_LIFNR ).

  move IF_LIFNR to LS_PARAM-ATWRT.
  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_LIFNR_CHANGED ).
  endif.

endmethod.
method SET_PAMAI.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PAMAI ).

  if IF_PAMAI is supplied.
    move IF_PAMAI to LS_PARAM-ATWRT.
  endif.
  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PAMAI_CHANGED ).
  endif.

endmethod.
method SET_PMATN.

  data:  LF_CHANGED  type ABAP_BOOL.
  data:  LS_LEOKY    type /VCXI/VKSR_S_LEOKY.

  move IF_PMATN to LS_LEOKY-LEOKY.
  move IF_SETBY to LS_LEOKY-SETBY.

  LF_CHANGED = ME->R_GATE->SET_LEOKY( IS_LEOKY = LS_LEOKY ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PMATN_CHANGED ).
  endif.

endmethod.
method SET_PMATN_EFFCT.

  data:          LF_PMATY       type ZVCXI_XCSU_PMATY,
                 LF_PMATN       type ZVCXI_XCSU_PMATN.
  data:          LS_PMATN_EFFCT type ZVCXI_XCS_TD102,
                 LS_CALCV       type ZVCXI_XCS_S_CALCV.
  data:          LT_PMATN_EFFCT type ZVCXI_XCSU_TT_PMATN_EFFCT,
                 LT_EFFCT       type ZVCXI_XCSU_TT_EFFCT.
  field-symbols: <S_EFFCT>      type ZVCXI_XCSU_S_EFFCT.

*** ---------------------------------------------------------------------
*** Get current Dimensions
  ME->GET_EFFCT( importing ET_EFFCT = LT_EFFCT ).

*** ---------------------------------------------------------------------
*** Load Material Definition
  if ME->R_CUST_PACKMAT is bound.
*** Set Dimension parameters
    loop at LT_EFFCT assigning <S_EFFCT>.
      case <S_EFFCT>-DIMEN.
        when ZCL_VCXI_XCSU_CUST_SHIPU=>C_DIMEN_LENGTH.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-LAENG to LS_CALCV-CALCV.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-MEABM to LS_CALCV-CALCV_UOM.

        when ZCL_VCXI_XCSU_CUST_SHIPU=>C_DIMEN_WIDTH.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-BREIT to LS_CALCV-CALCV.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-MEABM to LS_CALCV-CALCV_UOM.

        when ZCL_VCXI_XCSU_CUST_SHIPU=>C_DIMEN_HEIGHT.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-HOEHE to LS_CALCV-CALCV.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-MEABM to LS_CALCV-CALCV_UOM.

        when ZCL_VCXI_XCSU_CUST_SHIPU=>C_DIMEN_WEIGHT.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-BRGEW to LS_CALCV-CALCV.
          move ME->R_CUST_PACKMAT->S_PACKMAT_DIM-GEWEI to LS_CALCV-CALCV_UOM.
      endcase.

      ZCL_VCXI_XCS_SERVICE_CALC=>CONVERT_UNIT( exporting IF_UOM   = <S_EFFCT>-DIMVA_UOM
                                               changing  CS_CALCV = LS_CALCV ).
      move LS_CALCV-CALCV     to <S_EFFCT>-DIMVA.
      move LS_CALCV-CALCV_UOM to <S_EFFCT>-DIMVA_UOM.

    endloop.
  endif.

*** ---------------------------------------------------------------------
*** Load Customizing Effects

*** Packaging Material Type and Packaging Material
  LF_PMATY = ME->GET_PMATY( ).
  LF_PMATN = ME->GET_PMATN( ).

*** Retrieve Packaging Material Dimensions
  LT_PMATN_EFFCT = ME->R_CUST_SHIPU->GET_EFFCT_FOR_PMATN( IF_SYSOM = ME->S_COMOD-MSYST
                                                          IF_PMATN = LF_PMATN
                                                          IF_PMATY = LF_PMATY ).

*** Set default Dimensions to Dimension parameters
  loop at LT_EFFCT assigning <S_EFFCT>.
    read table LT_PMATN_EFFCT into LS_PMATN_EFFCT with key DIMEN = <S_EFFCT>-DIMEN
                                                           EFFCT = <S_EFFCT>-EFFCT.

    if SY-SUBRC eq 0 and
       LS_PMATN_EFFCT-EFFVA is not initial.
      move LS_PMATN_EFFCT-EFFVA     to LS_CALCV-CALCV.
      move LS_PMATN_EFFCT-EFFVA_UOM to LS_CALCV-CALCV_UOM.
      ZCL_VCXI_XCS_SERVICE_CALC=>CONVERT_UNIT( exporting IF_UOM   = <S_EFFCT>-DIMVA_UOM
                                               changing  CS_CALCV = LS_CALCV ).
      move LS_CALCV-CALCV     to <S_EFFCT>-DIMVA.
      move LS_CALCV-CALCV_UOM to <S_EFFCT>-DIMVA_UOM.
    endif.
  endloop.

*** ---------------------------------------------------------------------
*** Set Effects
  ME->SET_EFFCT( IT_EFFCT = LT_EFFCT ).

endmethod.
method SET_PMATY.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PMATY ).

  move IF_PMATY to LS_PARAM-ATWRT.
  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PMATY_CHANGED ).
  endif.

endmethod.
method SET_PMQTY.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = ME->F_PARID_PMQTY ).

  if IS_PMQTY is supplied.
    move IS_PMQTY-PMQTY     to LS_PARAM-ATFLV.
    move IS_PMQTY-PMQTY_UOM to LS_PARAM-UNIT.
  else.
    if IF_SETBY is initial.
      clear LS_PARAM-ATFLV.
    endif.
  endif.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PMQTY_CHANGED ).
    if IF_SETBY is initial.
***   Send Event -> Request Set Default
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_REQUEST_SET_DEFAULT ).
    endif.
  endif.

endmethod.
  method SET_PRICE.

    data: LF_CHANGED type ABAP_BOOL.
    data: LS_PARAM   type /VCXI/VKSR_S_PARAM.


    LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PRICE ).

    if IS_PRICE is supplied.
      LS_PARAM-ATFLV = IS_PRICE-PRICE.
      LS_PARAM-CURKY = IS_PRICE-PRICE_CURR.
    endif.

    LS_PARAM-SETBY = IF_SETBY.
    if LS_PARAM-SETBY is initial.
      clear LS_PARAM-ATFLV.
    endif.

    LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

    if LF_CHANGED eq ABAP_TRUE.
***   Send Event
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PRICE_CHANGED ).
    endif.

  endmethod.
  method SET_PRICP.

    data: LF_CHANGED type ABAP_BOOL.
    data: LS_PARAM   type /VCXI/VKSR_S_PARAM.


    LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = ME->F_PARID_PRICP ).

    if IS_PRICP is supplied.
      LS_PARAM-ATFLV = IS_PRICP-PRICP.
      LS_PARAM-UNIT = IS_PRICP-PRICP_UOM.
    endif.

    LS_PARAM-SETBY = IF_SETBY.
    if LS_PARAM-SETBY is initial.
      clear LS_PARAM-ATFLV.
    endif.

    LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

    if LF_CHANGED eq ABAP_TRUE.
***   Send Event
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PRICE_CHANGED ).
    endif.

  endmethod.
method SET_PURCH.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_PURCH ).

  move IF_PURCH to LS_PARAM-ATWRT.
  move IF_SETBY to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_PURCH_CHANGED ).
  endif.

*** Force Scale Deletion
  check IF_PURCH eq ABAP_FALSE.
  ME->SET_SCALE( IF_SCALE = IF_PURCH ).

endmethod.
  method SET_SCALE.

    data: LR_GATE        type ref to /VCXI/CL_VKSR_GATE.


*** Initialize Price Data
    ME->SET_PRICE( IF_SETBY = SPACE ).
    ME->SET_PRICP( IF_SETBY = SPACE ).

*** Get Instance of Price Scale Manager
    LR_GATE = ME->GET_PSCALE_MGR( IF_CREATE = IF_SCALE ).
    check LR_GATE is bound.

    if IF_SCALE eq ABAP_FALSE.
***   Delete Print
      LR_GATE->DO_FREE( ).
    endif.

  endmethod.
method SET_TEXT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TEXT ).

  move IF_TEXT  to LS_PARAM-ATWRT.
  move IF_SETBY to LS_PARAM-SETBY.

  ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

endmethod.
