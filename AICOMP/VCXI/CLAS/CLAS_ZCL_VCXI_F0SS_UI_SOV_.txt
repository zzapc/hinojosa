
class ZCL_VCXI_F0SS_UI_SOV definition
  public
  inheriting from /VCXI/CL_VKSRU_CLSUI
  abstract
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !IR_UIFW type ref to /VCXI/IF_VKSU_UIFW
      !IR_UIGATE type ref to /VCXI/CL_VKSRU_UIGATE
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods DO_PBO
    raising
      /VCXI/CX_CKX .
  methods GET_ID_BY_IPRVT
    importing
      !IF_IPRVT type /VCXI/VKSC_IPRVT
    returning
      value(RF_ID) type /VCXI/CKX_ID
    raising
      /VCXI/CX_CKX .

  methods ACTIVATE
    redefinition .
  methods DEACTIVATE
    redefinition .
  methods DO_USER_COMMAND
    redefinition .
protected section.

  types:
    begin of YS_CLSTR_BUFFER,
      R_GATE   type ref to /VCXI/CL_VKSR_GATE,
      NETOBJID type        NETOBJID,
    end   of YS_CLSTR_BUFFER .
  types:
    YT_CLSTR_BUFFER type standard table of YS_CLSTR_BUFFER .
  types:
    begin of YS_NODE_BUFFER,
      R_GATE   type ref to /VCXI/CL_VKSR_GATE,
      NETOBJID type        NETOBJID,
      CLSTR_ID type        NETOBJID,
    end   of YS_NODE_BUFFER .
  types:
    YT_NODE_BUFFER type standard table of YS_NODE_BUFFER .
  types:
    begin of YS_LINE_BUFFER,
      R_GATE_OUT type ref to  /VCXI/CL_VKSR_GATE,
      R_GATE_IN  type ref to  /VCXI/CL_VKSR_GATE,
      NETOBJID   type        NETOBJID,
      FIX        type        ABAP_BOOL,
    end   of YS_LINE_BUFFER .
  types:
    YT_LINE_BUFFER type standard table of YS_LINE_BUFFER .
  types:
    begin of YS_POPUP_MENU,
      ID    type          GRMODE,
      FCODE type          SYUCOMM,
      TEXT  type          NETVALSVAL,
      R_ND  type ref to   ZCL_VCXI_F0SS_ND,
    end of YS_POPUP_MENU .
  types:
    YT_POPUP_MENU type standard table of YS_POPUP_MENU .

  constants C_BTYPE_BUTTON type TB_BTYPE value 0 ##NO_TEXT.
  constants C_BTYPE_SEPARATOR type TB_BTYPE value 3 ##NO_TEXT.
  constants C_FCODE_COLLAPSE type UI_FUNC value 'CCTO' ##NO_TEXT.
  constants C_FCODE_MERGE type UI_FUNC value 'MERGE' ##NO_TEXT.
  constants C_FCODE_CONNECT type UI_FUNC value 'CCON' ##NO_TEXT.
  constants C_FCODE_DELETE type UI_FUNC value 'CDEL' ##NO_TEXT.
  constants C_FCODE_EXPAND type UI_FUNC value 'CECM' ##NO_TEXT.
  constants C_FCODE_OVERVIEW type UI_FUNC value 'VCMP' ##NO_TEXT.
  constants C_FCODE_ZOOM_IN type UI_FUNC value 'OZIN' ##NO_TEXT.
  constants C_FCODE_ZOOM_OUT type UI_FUNC value 'OZOU' ##NO_TEXT.
  constants C_FL_CLSTR type NETVALSFL value 'C' ##NO_TEXT.
  constants C_OBJTY_CLSTR type NETOBJTYPE value 'c' ##NO_TEXT.
  constants C_OBJTY_LINE type NETOBJTYPE value 'l' ##NO_TEXT.
  constants C_OBJTY_NODE type NETOBJTYPE value 'n' ##NO_TEXT.
  constants C_STAT_WAIT type GRSTAT value '4' ##NO_TEXT.
  constants C_UC_COLLAPSE type SYUCOMM value 'ACLUS5' ##NO_TEXT.
  constants C_UC_CONNECT type UI_FUNC value 'ACON' ##NO_TEXT.
  constants C_UC_DELETE type UI_FUNC value 'ADEL' ##NO_TEXT.
  constants C_UC_DOUBLE_CLICK type SYUCOMM value 'ADBCL' ##NO_TEXT.
  constants C_UC_EXPAND type SYUCOMM value 'ACLUS0' ##NO_TEXT.
  constants C_UC_INSERT type UI_FUNC value 'AINS' ##NO_TEXT.
  constants C_UC_MODIFY type UI_FUNC value 'AMOD' ##NO_TEXT.
  constants C_UC_SELECT type UI_FUNC value 'SELECT' ##NO_TEXT.
  constants C_UC_DPOPUP type UI_FUNC value 'DPOPUP' ##NO_TEXT.
  constants C_UC_POPUP type UI_FUNC value 'POPUP' ##NO_TEXT.
  data F_ABAP_CMD type GRABAPCMD .
  data F_LAST_UCOMM type SYUCOMM .
  data F_STAT type GRSTAT .
  data R_CONTAINER_GRAPHIC type ref to CL_GUI_CONTAINER .
  data R_CONTAINER_SPLITTER type ref to CL_GUI_SPLITTER_CONTAINER .
  data R_CONTAINER_TOOLBAR type ref to CL_GUI_CONTAINER .
  data R_NETCHART type ref to CL_GUI_NETCHART .
  data R_PR_SOV type ref to ZCL_VCXI_F0SS_PR_SOV .
  data R_TOOLBAR type ref to CL_GUI_TOOLBAR .
  data S_PROFILE type NET_PROFIL .
  data T_CLSTR_BUFFER type YT_CLSTR_BUFFER .
  data T_INODE type CNG_INODES_TAB .
  data T_INVAL type NET_NVALS_TAB .
  data T_LINE_BUFFER type YT_LINE_BUFFER .
  data T_NODE_BUFFER type YT_NODE_BUFFER .
  data T_PRVDR_DEF type /VCXI/VKSR_TT_PRVDR_DEF .
  data T_POPUP_MENU type YT_POPUP_MENU .
  data R_NETGRAPH type ref to ZCL_VCXI_XCS_NETGRAPH .

  methods HANDLE_UC_MERGE_COMP
    importing
      !IS_POPUP_MENU type YS_POPUP_MENU optional
      !IT_NODE type CNG_NODES_TAB optional
      !IT_CLSTR type CNG_CLUSTR_TAB optional
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_SPLIT_COMP
    importing
      !IS_POPUP_MENU type YS_POPUP_MENU
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_POPUP_SEL
    importing
      !IF_GR_MODE type GRMODE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_POPUP_MENU
    importing
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods CHECK_DELETION
    changing
      !CT_DELETION type NET_DELETE_TAB
      !CF_GR_MES type GRMES
    raising
      /VCXI/CX_CKX .
  methods IS_INOUT
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE optional
    returning
      value(RF_RESULT) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_SPEC_GATE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_SPEC_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods ADD_AS_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_CLSTR type CNG_CLUSTR_TAB
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_AS_LINE
    importing
      !IR_GATE_OUT type ref to /VCXI/CL_VKSR_GATE
      !IR_GATE_IN type ref to /VCXI/CL_VKSR_GATE
      !IF_FIX type ABAP_BOOL
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_LINE type CNG_LINES_TAB
      !CT_LVAL type LVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_AS_NODE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_NODE_TO_CLUSTER
    importing
      !IF_NETOBJID_CLSTR type NETOBJID
      !IF_NETOBJID_NODE type NETOBJID
    changing
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods GET_GATE_BY_NODEID
    importing
      !IF_NETOBJID type NETOBJID
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_GRAPHIC_CHANGES
    exporting
      !ET_CLSTR type CNG_CLUSTR_TAB
      !ET_CVAL type CVALS_TAB
      !ET_DELETION type NET_DELETE_TAB
      !ET_LINE type CNG_LINES_TAB
      !ET_LVAL type LVALS_TAB
      !ET_NODE type CNG_NODES_TAB
      !ET_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods GET_NEXT_NETOBJID
    returning
      value(RF_NETOBJID) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods GET_NODEID_BY_GATE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_NETOBJID) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods GET_XCONI_BY_NODEID
    importing
      !IF_NETOBJID type NETOBJID
      !IR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE optional
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_XCONO_BY_NODEID
    importing
      !IF_NETOBJID type NETOBJID
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_TOOLBAR_FCODE
    for event FUNCTION_SELECTED of CL_GUI_TOOLBAR
    importing
      !FCODE .
  methods HANDLE_UC_COLLAPSE
    importing
      !IT_NODE type CNG_NODES_TAB
      !IT_CLSTR type CNG_CLUSTR_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_CONNECT
    importing
      !IT_LINE type CNG_LINES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_DELETE
    importing
      !IT_DELETION type NET_DELETE_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_DOUBLE_CLICK
    importing
      !IT_CLSTR type CNG_CLUSTR_TAB
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_EXPAND
    importing
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_INSERT
    importing
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods INIT_CONTAINERS
    raising
      /VCXI/CX_CKX .
  methods INIT_NETCHART
    raising
      /VCXI/CX_CKX .
  methods INIT_TOOLBAR
    raising
      /VCXI/CX_CKX .
  methods IS_EXPANDED
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_RESULT) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_INLINE
    changing
      !CR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods REFRESH_GRAPHIC
    raising
      /VCXI/CX_CKX .
  methods UPDATE_CLUSTER
    importing
      !IF_NETOBJID type NETOBJID
    changing
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods UPDATE_NODE
    importing
      !IF_NETOBJID type NETOBJID
    changing
      !CT_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods CONNECT_BY_XCON
    importing
      !IR_XCON_IN type ref to ZIF_VCXI_F0SS_ANCHI
      !IR_XCON_OUT type ref to ZIF_VCXI_F0SS_ANCHO
    raising
      /VCXI/CX_CKX .
  methods INIT_INODES
    raising
      /VCXI/CX_CKX .
  methods INIT_PROFILE
    raising
      /VCXI/CX_CKX .
private section.

  data F_NETOBJID_LAST type NETOBJID .
endclass. "ZCL_VCXI_F0SS_UI_SOV definition
class ZCL_VCXI_F0SS_UI_SOV implementation.
  method ACTIVATE.

    SUPER->ACTIVATE( ).

***--------------------------------------------------------------------------------------
*** Initialize Profile for Net Graphic
    ME->INIT_PROFILE( ).

*** Initialize Nodes to insert
    ME->INIT_INODES( ).

***--------------------------------------------------------------------------------------
*** Bind UI to Dynpro
    call function 'ZVCXI_F0SS_UI_SOV_BIND'
      exporting
        IR_UI_SOV = ME
      importing
        ES_DYNP   = ME->S_DYNP.

*** Create Network Graphic
    create object ME->R_NETGRAPH
      exporting
        IR_GATE   = ME->R_GATE
        IR_UIGATE = ME->R_UIGATE.
*        IF_CONTAINER_NAME = '0100CC_NETGRAPH'.

  endmethod.
  method ADD_AS_CLUSTER.

    data:           LS_NVALS        type        ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data:           LR_ND           type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_CLSTR_BUFFER> type        YS_CLSTR_BUFFER,
                   <S_CLSTR>        type        CNG_CLUSTR,
                   <S_CVAL>         type        NET_CVALS.

*** Get Node instance for Gate
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = IR_GATE ).

*** If Customizing is not in place => Do not add the node to Graphic
    check LR_ND is bound.

*** Get next free Object ID
    move ME->GET_NEXT_NETOBJID( ) to EF_NETOBJID.

*** Add to Buffer
    append initial line to ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
    move IR_GATE     to <S_CLSTR_BUFFER>-R_GATE.
    move EF_NETOBJID to <S_CLSTR_BUFFER>-NETOBJID.

*** Add to Graphic
    append initial line to CT_CLSTR assigning <S_CLSTR>.
    move EF_NETOBJID to <S_CLSTR>-ID.

*** Set Cluster Type depending on SVC Node Type
    move LR_ND->F_NETTYPE to <S_CLSTR>-TYPE.

*** Set Cluster Attributes
    loop at LR_ND->T_NVALS into LS_NVALS.
      append initial line to CT_CVAL assigning <S_CVAL>.
      <S_CVAL>-ID   = EF_NETOBJID.
      <S_CVAL>-FL   = LS_NVALS-FL.
      <S_CVAL>-VAL  = LS_NVALS-VAL.
    endloop.

  endmethod.
  method ADD_AS_LINE.

    field-symbols: <S_LINE_BUFFER> type        YS_LINE_BUFFER,
                   <S_LINE>        type        CNG_LINES,
                   <S_LVAL>        type        NET_LVALS.

    check IR_GATE_IN is bound and
          IR_GATE_OUT is bound.

*** Get next free Object ID
    move ME->GET_NEXT_NETOBJID( ) to EF_NETOBJID.

*** Add to Buffer
    append initial line to ME->T_LINE_BUFFER assigning <S_LINE_BUFFER>.
    move IR_GATE_OUT to <S_LINE_BUFFER>-R_GATE_OUT.
    move IR_GATE_IN  to <S_LINE_BUFFER>-R_GATE_IN.
    move EF_NETOBJID to <S_LINE_BUFFER>-NETOBJID.
    move IF_FIX      to <S_LINE_BUFFER>-FIX.

*** Add to Graphic
    append initial line to CT_LINE assigning <S_LINE>.
    move EF_NETOBJID                                     to <S_LINE>-ID.
    move ME->GET_NODEID_BY_GATE( IR_GATE = IR_GATE_OUT ) to <S_LINE>-PRE.
    move ME->GET_NODEID_BY_GATE( IR_GATE = IR_GATE_IN )  to <S_LINE>-SUC.
    move '0'                                             to <S_LINE>-TYPE.
    move 'AA'                                            to <S_LINE>-AB.

*** Description
    append initial line to CT_LVAL assigning <S_LVAL>.
    <S_LVAL>-ID    = EF_NETOBJID.
    <S_LVAL>-FL    = '0'.
    <S_LVAL>-VAL   = IR_GATE_OUT->R_CLSPR->GET_DESCR( ).

  endmethod.
  method ADD_AS_NODE.

    data: LS_NVALS type ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data: LR_ND type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_NODE_BUFFER> type YS_NODE_BUFFER,
                   <S_NODE>        type CNG_NODES,
                   <S_NVAL>        type NET_NVALS.


*** Get Node instance for Gate
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = IR_GATE ).

    check LR_ND is bound.

*** Get next free Object ID
    move ME->GET_NEXT_NETOBJID( ) to EF_NETOBJID.

*** Add to Buffer
    append initial line to ME->T_NODE_BUFFER assigning <S_NODE_BUFFER>.
    move IR_GATE     to <S_NODE_BUFFER>-R_GATE.
    move EF_NETOBJID to <S_NODE_BUFFER>-NETOBJID.

*** Add to Graphic
    append initial line to CT_NODE assigning <S_NODE>.
    move EF_NETOBJID to <S_NODE>-ID.

*** Set Node Type depending on SVC Node Type
    move LR_ND->F_NETTYPE to <S_NODE>-TYPE.

    loop at LR_ND->T_NVALS into LS_NVALS.
      append initial line to CT_NVAL assigning <S_NVAL>.
      <S_NVAL>-ID   = EF_NETOBJID.
      <S_NVAL>-FL   = LS_NVALS-FL.
      <S_NVAL>-VAL  = LS_NVALS-VAL.
    endloop.

  endmethod.
  method ADD_NODE_TO_CLUSTER.

    data: LR_ND   type ref to ZCL_VCXI_F0SS_ND,
          LR_GATE type ref to /VCXI/CL_VKSR_GATE.
    data: LT_NVALS type NVALS_TAB.
    field-symbols: <S_CVAL>        type NET_CVALS,
                   <S_NVAL>        type NET_NVALS,
                   <S_NODE_BUFFER> type YS_NODE_BUFFER.


*** Get Cluster Gate
    LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID_CLSTR ).

*** Get Node instance for Gate
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = LR_GATE ).
    check LR_ND is bound.

*** Add Cluster Attribute
    append initial line to LT_NVALS assigning <S_NVAL>.
    <S_NVAL>-ID    = IF_NETOBJID_CLSTR.
    <S_NVAL>-FL    = 'A'.
    <S_NVAL>-VAL   = IF_NETOBJID_NODE.

    LR_ND->ADD_NVALS( IT_NVALS = LT_NVALS ).

*** Update Node Buffer table wth cluster
    read table ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> with key NETOBJID = IF_NETOBJID_NODE.
    if SY-SUBRC eq 0.
      move IF_NETOBJID_CLSTR to <S_NODE_BUFFER>-CLSTR_ID.
    endif.

*** Add Node to Return Table
    append initial line to CT_CVAL assigning <S_CVAL>.
    move-corresponding <S_NVAL> to <S_CVAL>.

  endmethod.
  method CHECK_DELETION.

    data: LF_RETURN type I,
          LF_UCOMM  type SYUCOMM.
    data: LS_CVALS type NET_CVALS,
          LT_CVALS type CVALS_TAB.
    field-symbols: <S_DELETION> type NET_DELETE.


***--------------------------------------------------------------------------------------
*** If Deletion table is empty check if a cluster is involved
    check LINES( CT_DELETION ) is initial.

*** Send Function Code Expand to NETGraphic
    move C_FCODE_EXPAND to LF_UCOMM.
    ME->R_NETCHART->SET_FUNCTION_CODE( exporting FUNCTION_CODE = LF_UCOMM
                                       importing RETURN        = LF_RETURN ).
    if LF_RETURN ne 0.
      CL_GUI_CFW=>FLUSH( ).
      return.
    endif.

*** Process after Input for Graphic
    ME->R_NETCHART->GRAPHIC_PAI( importing GR_MES       = CF_GR_MES
                                 changing  CVALS        = LT_CVALS ).

*** Check for Cluster values involved
    loop at LT_CVALS into LS_CVALS.
      insert initial line into table CT_DELETION assigning <S_DELETION>.
      move: C_OBJTY_CLSTR to <S_DELETION>-OBJ_TYPE,
            LS_CVALS-ID   to <S_DELETION>-ID.
    endloop.

    move C_UC_DELETE to CF_GR_MES.

  endmethod.
  method CONNECT_BY_XCON.

    data: LT_XCONR      type ZVCXI_F0SS_TT_XCONR.
    data: LR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCONI type ref to /VCXI/CL_VKSR_GATE.
    field-symbols:  <S_XCONR> type ZVCXI_F0SS_S_XCONR.


***--------------------------------------------------------------------------------------
*** Get current Connections
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

***--------------------------------------------------------------------------------------
*** Get Connections
    move IR_XCON_IN->ADD_XCON( ) to LR_GATE_XCONI.
    move IR_XCON_OUT->ADD_XCON( )  to LR_GATE_XCONO.

*** Add Connection
    append initial line to LT_XCONR assigning <S_XCONR>.
    move LR_GATE_XCONO to <S_XCONR>-R_GATE_OUT.
    move LR_GATE_XCONI to <S_XCONR>-R_GATE_IN.

***--------------------------------------------------------------------------------------
*** Send to backend
    ME->R_PR_SOV->SET_XCONR( IT_XCONR = LT_XCONR ).

  endmethod.
  method CONSTRUCTOR.

    SUPER->CONSTRUCTOR( IR_UIFW   = IR_UIFW
                        IR_UIGATE = IR_UIGATE
                        IR_GATE   = IR_GATE ).

*** Assign th RP Class to the UI Class
    try.
        move IR_GATE->R_CLSPR ?to ME->R_PR_SOV.
      catch CX_SY_MOVE_CAST_ERROR.
***     UI ABAP Class is not compatible with PR ABAP Class.
        raise exception type /VCXI/CX_CKX
          exporting
            F_MSGTY = 'E'
            F_MSGID = '/VCXI/VKSR'
            F_MSGNO = '801'.
    endtry.

*** Force Suppress deletion confirmation
    call function 'CNET_SET_OPTIONS'
      exporting
        NODELPOP = '1'.

  endmethod.
  method DEACTIVATE.

    SUPER->DEACTIVATE( ).

    if ME->R_NETCHART is bound.
***   Clean up
      ME->R_NETCHART->GRAPHIC_PAI( exporting AT_CONTROL_DESTROY = 'X' ).

***   Free Control
      ME->R_NETCHART->FREE( ).
      free: ME->R_NETCHART.
    endif.

    if ME->R_CONTAINER_GRAPHIC is bound.
***   Free Container for Graphic
      ME->R_CONTAINER_GRAPHIC->FREE( ).
      free: ME->R_CONTAINER_GRAPHIC.
    endif.

    if ME->R_CONTAINER_TOOLBAR is bound.
***   Free Container for Toolbar
      ME->R_CONTAINER_TOOLBAR->FREE( ).
      free: ME->R_CONTAINER_TOOLBAR.
    endif.

    if ME->R_CONTAINER_SPLITTER is bound.
***   Free Container for Splitter
      ME->R_CONTAINER_SPLITTER->FREE( ).
      free: ME->R_CONTAINER_SPLITTER.
    endif.

*** Free Network Graphic
    if ME->R_NETGRAPH is bound.
      ME->R_NETGRAPH->DO_FREE( ).
      clear ME->R_NETGRAPH.
    endif.

  endmethod.
  method DO_PBO.

***--------------------------------------------------------------------------------------
*** Graphic component is not supported by SAP for MAC
    if ME->S_PROFILE is not initial and
       CL_GUI_CONTROL=>WWW_ACTIVE ne ABAP_TRUE and
       CL_GUI_FRONTEND_SERVICES=>GET_PLATFORM( ) ne CL_GUI_FRONTEND_SERVICES=>PLATFORM_MACOSX.

***   Initialize Containers: Splitter, Toolbar, Graphic
      ME->INIT_CONTAINERS( ).

***   Initialize Toolbar
      ME->INIT_TOOLBAR( ).

***   Initialize Netchart Object
      ME->INIT_NETCHART( ).

***   Refresh Graphic
      ME->REFRESH_GRAPHIC( ).


***--------------------------------------------------------------------------------------
*** Refresh Network Graphic (UI5)
    else.
      if ME->R_NETGRAPH is bound.
        move ABAP_TRUE to ME->R_NETGRAPH->F_REFRESH_REQ.
***     Refresh Network Graphic Component
        ME->R_NETGRAPH->REFRESH_NETGRAPH( ).
      endif.
    endif.

  endmethod.
  method DO_USER_COMMAND.

    data: LF_RETURN  type I,
          LF_GR_MES  type GRMES,
          LF_GR_MODE type GRMODE,
          LF_UCOMM   type SYUCOMM.
    data: LT_CLSTR    type CNG_CLUSTR_TAB,
          LT_NODE     type CNG_NODES_TAB,
          LT_LINE     type CNG_LINES_TAB,
          LT_DELETION type NET_DELETE_TAB,
          LT_CVALS    type CVALS_TAB,
          LT_NVALS    type NVALS_TAB,
          LT_FVALS    type NVALS_TAB.

    SUPER->DO_USER_COMMAND( IF_UCOMM = IF_UCOMM ).

    check ME->R_NETCHART is bound.

***--------------------------------------------------------------------------------------
*** Save incoming funtion code
    move IF_UCOMM to LF_UCOMM.

*** Expand node => simulate doubleclick to get feedback from graphic
    if LF_UCOMM eq C_FCODE_EXPAND or
       LF_UCOMM eq C_FCODE_COLLAPSE or
       LF_UCOMM eq C_FCODE_MERGE.

      move: LF_UCOMM    to ME->F_LAST_UCOMM,
            C_UC_MODIFY to LF_UCOMM.

***   Refresh Line Buffer to ensure a complete re-build
      refresh ME->T_LINE_BUFFER.
    endif.

***--------------------------------------------------------------------------------------
*** Send Function Code to Control if not Control- or Shell-Event
    if IF_UCOMM(4) ne '%_GC' and
       IF_UCOMM(4) ne '%_GS'.
      ME->R_NETCHART->SET_FUNCTION_CODE( exporting FUNCTION_CODE = LF_UCOMM
                                         importing RETURN        = LF_RETURN ).
      if LF_RETURN ne 0.
        CL_GUI_CFW=>FLUSH( ).
        return.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Process after Input for Graphic
    ME->R_NETCHART->GRAPHIC_PAI( importing GR_MES       = LF_GR_MES
                                           GR_MODE      = LF_GR_MODE
                                 changing  DELETIONS    = LT_DELETION
                                           FVALS        = LT_FVALS
                                           LINES        = LT_LINE
                                           NODES        = LT_NODE
                                           NVALS        = LT_NVALS
                                           CLUSTERS     = LT_CLSTR
                                           CVALS        = LT_CVALS ).

*** Set Back to expand to handle it correctly
    if ME->F_ABAP_CMD eq C_UC_SELECT.
      move ME->F_LAST_UCOMM to LF_GR_MES.
    endif.

    clear: ME->F_ABAP_CMD.
    move C_STAT_WAIT to ME->F_STAT.

***--------------------------------------------------------------------------------------
*** Process Action
    case LF_GR_MES.

***   Insert
      when C_UC_INSERT.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_INSERT( exporting IT_NODE = LT_NODE ).

***   Connect
      when C_UC_CONNECT.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_CONNECT( exporting IT_LINE = LT_LINE ).

***   Delete
      when C_UC_DELETE.
        ME->CHECK_DELETION( changing CT_DELETION = LT_DELETION
                                     CF_GR_MES   = LF_GR_MES ).

        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_DELETE( exporting IT_DELETION = LT_DELETION ).

***   Double Click
      when C_UC_DOUBLE_CLICK.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_DOUBLE_CLICK( exporting IT_CLSTR = LT_CLSTR
                                              IT_NODE  = LT_NODE ).
***   Expand Node/Cluster
      when C_FCODE_EXPAND.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_EXPAND( exporting IT_NODE  = LT_NODE ).

***   Collapse Cluster
      when C_FCODE_COLLAPSE.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_COLLAPSE( exporting IT_NODE  = LT_NODE
                                          IT_CLSTR = LT_CLSTR ).

***   Simulate Modify
      when C_UC_MODIFY.
        ME->F_ABAP_CMD = C_UC_SELECT.

***     Refresh UI here to get in next run the "selected" node
        ME->REFRESH_GRAPHIC( ).
        ME->R_UIGATE->REFRESH_SCREEN( ).

***   Dynamic Popup
      when C_UC_DPOPUP.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_POPUP_MENU( exporting IT_NODE = LT_NODE ).

***   Popup Message
      when C_UC_POPUP.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_POPUP_SEL( exporting IF_GR_MODE = LF_GR_MODE ).

***   Merge
      when C_FCODE_MERGE.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_MERGE_COMP( exporting IT_NODE  = LT_NODE
                                            IT_CLSTR = LT_CLSTR ).
    endcase.

  endmethod.
  method GET_GATE_BY_NODEID.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER.


*** Search for Match as Cluster
    read table ME->T_CLSTR_BUFFER with key NETOBJID = IF_NETOBJID
                                  into LS_CLSTR_BUFFER.
    if SY-SUBRC eq 0.
      move LS_CLSTR_BUFFER-R_GATE to RR_GATE.
      return.
    endif.

*** Search for Match as Node
    read table ME->T_NODE_BUFFER with key NETOBJID = IF_NETOBJID
                                 into LS_NODE_BUFFER.
    if SY-SUBRC eq 0.
      move LS_NODE_BUFFER-R_GATE to RR_GATE.
      return.
    endif.

  endmethod.
  method GET_GRAPHIC_CHANGES.

    data: LF_OBJID_XCLST type        NETOBJID,
          LF_OBJID_XNODE type        NETOBJID.
    data: LS_CLSTR_BUFFER type        YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type        YS_NODE_BUFFER,
          LS_LINE_BUFFER  type        YS_LINE_BUFFER,
          LS_SEQUENCE     type        ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE,
          LS_XCONR        type        ZVCXI_F0SS_S_XCONR.
    data: LT_GATE_SPEC   type        /VCXI/VKSR_TT_GATE,
          LT_GATE_XCOMP  type        /VCXI/VKSR_TT_GATE,
          LT_SEQUENCE    type        ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE,
          LT_XCONR       type        ZVCXI_F0SS_TT_XCONR,
          LT_LINE_BUFFER type        YT_LINE_BUFFER.
    data: LR_GATE_SPEC  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCOMP type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_SPEC    type ref to ZCL_VCXI_F0SS_PR_SPEC,
          LR_GATE_NEXT  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PREV  type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_DELETION>    type        NET_DELETE,
                   <S_NODE_BUFFER> type        YS_NODE_BUFFER.

***--------------------------------------------------------------------------------------
*** Get all Components
    LT_GATE_XCOMP = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_XCOMP=>C_IPRVT_XCOMP
                                           IF_INUSE = ABAP_TRUE ).

    loop at LT_GATE_XCOMP into LR_GATE_XCOMP.

***   Get Specification Gate
      LT_GATE_SPEC = LR_GATE_XCOMP->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_SPEC=>C_IPRVT_F0_SPEC
                                               IF_INUSE = ABAP_TRUE ).

      read table LT_GATE_SPEC into LR_GATE_SPEC index 1.
      check LR_GATE_SPEC is bound.

      move LR_GATE_SPEC->R_CLSPR ?to LR_PR_SPEC.
      check LR_PR_SPEC is bound.

***   Get sequence of Gates inside the Specification
      LT_SEQUENCE = LR_PR_SPEC->GET_SEQUENCE( ).

***   If Component Node is expanded add it to Cluster Table
      if ME->IS_EXPANDED( exporting IR_GATE = LR_GATE_XCOMP ) eq ABAP_TRUE.

***     Identify new or changed Cluster
        read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER
                                      with key R_GATE = LR_GATE_XCOMP.

        if SY-SUBRC is initial.
          move LS_CLSTR_BUFFER-NETOBJID to LF_OBJID_XCLST.
          ME->UPDATE_CLUSTER( exporting IF_NETOBJID = LS_CLSTR_BUFFER-NETOBJID
                              changing  CT_CVAL     = ET_CVAL ).
        else.
***       Add Gate as Cluster
          ME->ADD_AS_CLUSTER( exporting IR_GATE     = LR_GATE_XCOMP
                              importing EF_NETOBJID = LF_OBJID_XCLST
                              changing  CT_CLSTR    = ET_CLSTR
                                        CT_CVAL     = ET_CVAL ).
        endif.

***     Remove old Node of Component
        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
                                      with key R_GATE = LR_GATE_XCOMP.
        if SY-SUBRC eq 0.
          append initial line to ET_DELETION assigning <S_DELETION>.
          move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
          move LS_NODE_BUFFER-NETOBJID  to <S_DELETION>-ID.

          delete ME->T_NODE_BUFFER where R_GATE = LR_GATE_XCOMP.
          delete ET_NVAL where ID eq LS_NODE_BUFFER-NETOBJID.
        endif.

***     Handle all inner components
        loop at LT_SEQUENCE into LS_SEQUENCE.
***       Add the Next Nodes
          loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
            clear LF_OBJID_XNODE.

***         Identify new or changed Node
            read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
                                          with key R_GATE = LR_GATE_NEXT.
            if SY-SUBRC eq 0.
              move LS_NODE_BUFFER-NETOBJID to LF_OBJID_XNODE.
              ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
                               changing  CT_NVAL     = ET_NVAL ).
            else.
***           Add Gate as Node
              ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_NEXT
                               importing EF_NETOBJID = LF_OBJID_XNODE
                               changing  CT_NODE     = ET_NODE
                                         CT_NVAL     = ET_NVAL ).

***           Add Node to Cluster
              ME->ADD_NODE_TO_CLUSTER( exporting IF_NETOBJID_CLSTR = LF_OBJID_XCLST
                                                 IF_NETOBJID_NODE  = LF_OBJID_XNODE
                                       changing  CT_CVAL           = ET_CVAL ).

            endif.
          endloop.

***       Add the Previous Nodes
          loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.
            clear LF_OBJID_XNODE.

***         Identify new or changed Node
            read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
                                          with key R_GATE = LR_GATE_PREV.
            if SY-SUBRC eq 0.
              move LS_NODE_BUFFER-NETOBJID to LF_OBJID_XNODE.
              ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
                               changing  CT_NVAL     = ET_NVAL ).
            else.
***           Add Gate as Node
              ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_PREV
                               importing EF_NETOBJID = LF_OBJID_XNODE
                               changing  CT_NODE     = ET_NODE
                                         CT_NVAL     = ET_NVAL ).

***           Add Node to Cluster
              ME->ADD_NODE_TO_CLUSTER( exporting IF_NETOBJID_CLSTR = LF_OBJID_XCLST
                                                 IF_NETOBJID_NODE  = LF_OBJID_XNODE
                                       changing  CT_CVAL           = ET_CVAL ).

            endif.
          endloop.
        endloop.

***     Add Lines inside Component
        loop at LT_SEQUENCE into LS_SEQUENCE.
          loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
            loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.

***           Check Line isn't alread there
              read table ME->T_LINE_BUFFER with key R_GATE_OUT = LR_GATE_NEXT
                                                    R_GATE_IN  = LR_GATE_PREV
                                           transporting no fields.
              check SY-SUBRC is not initial.

***           Add Line
              ME->ADD_AS_LINE( exporting IR_GATE_OUT = LR_GATE_NEXT
                                         IR_GATE_IN  = LR_GATE_PREV
                                         IF_FIX      = ABAP_TRUE
                               changing  CT_LINE     = ET_LINE
                                         CT_LVAL     = ET_LVAL ).
            endloop.
          endloop.
        endloop.

      else.
***     Check if Component is a new Node
        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
                                     with key R_GATE = LR_GATE_XCOMP.
        if SY-SUBRC eq 0.
          ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
                           changing  CT_NVAL     = ET_NVAL ).
        else.
***       Add Component as Node
          ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_XCOMP
                           importing EF_NETOBJID = LF_OBJID_XNODE
                           changing  CT_NODE     = ET_NODE
                                     CT_NVAL     = ET_NVAL ).
        endif.

***     Remove old Cluster of Component
        read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER
                                      with key R_GATE = LR_GATE_XCOMP.
        if SY-SUBRC eq 0.
          append initial line to ET_DELETION assigning <S_DELETION>.
          move C_OBJTY_CLSTR            to <S_DELETION>-OBJ_TYPE.
          move LS_CLSTR_BUFFER-NETOBJID to <S_DELETION>-ID.

          delete ME->T_CLSTR_BUFFER where R_GATE = LR_GATE_XCOMP.
          delete ET_CVAL where ID eq LS_CLSTR_BUFFER-NETOBJID.

***       Delete all contained Nodes based on link to Cluster
          loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> where CLSTR_ID eq LS_CLSTR_BUFFER-NETOBJID.

***         Mark for Deletion
            append initial line to ET_DELETION assigning <S_DELETION>.
            move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
            move <S_NODE_BUFFER>-NETOBJID  to <S_DELETION>-ID.

***         Clear entry in node buffer
            delete ME->T_NODE_BUFFER.
          endloop.

        endif.

      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify deleted Nodes
    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
      check LS_NODE_BUFFER-R_GATE is not bound or
            LS_NODE_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
      move LS_NODE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_NODE_BUFFER.
    endloop.

***--------------------------------------------------------------------------------------
*** Get Connections between Film Components
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

    move ME->T_LINE_BUFFER to LT_LINE_BUFFER.
    delete LT_LINE_BUFFER where FIX eq ABAP_TRUE.

*** Delete Connections with missing Gate
    delete LT_XCONR where R_GATE_OUT is not bound.
    delete LT_XCONR where R_GATE_IN  is not bound.

***--------------------------------------------------------------------------------------
*** Complete Re-Build of the lines
    loop at LT_XCONR into LS_XCONR.

***--------------------------------------------------------------------------------------
***   If the Gate is not found in any Buffer check if belongs to a Film Component
      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_OUT ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_OUT ).
      endif.

      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_IN ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_IN ).
      endif.

***   Read info from Line Buffer table with the new gates (possible Film component)
      read table LT_LINE_BUFFER  with key R_GATE_OUT = LS_XCONR-R_GATE_OUT
                                          R_GATE_IN  = LS_XCONR-R_GATE_IN transporting no fields.
      if SY-SUBRC is initial.
        delete LT_LINE_BUFFER index SY-TABIX.
      else.
***     Add Line
        ME->ADD_AS_LINE( exporting IR_GATE_OUT = LS_XCONR-R_GATE_OUT
                                   IR_GATE_IN  = LS_XCONR-R_GATE_IN
                                   IF_FIX      = ABAP_FALSE
                         changing  CT_LINE     = ET_LINE
                                   CT_LVAL     = ET_LVAL ).
      endif.
    endloop.

*** Special case for deleting the lines when Cluster is seen as Node
    if ME->F_ABAP_CMD eq C_UC_DELETE.
***   Identify deleted Lines
      loop at LT_LINE_BUFFER into LS_LINE_BUFFER.

**      If node is not set to be freed
        check LS_LINE_BUFFER-R_GATE_IN->F_FREED is initial and
              LS_LINE_BUFFER-R_GATE_OUT->F_FREED is initial.

***     Only in the case when clusters are nodes
        check ME->IS_EXPANDED( exporting IR_GATE = LS_LINE_BUFFER-R_GATE_IN ) ne ABAP_TRUE.
        check ME->IS_EXPANDED( exporting IR_GATE = LS_LINE_BUFFER-R_GATE_OUT ) ne ABAP_TRUE.

***     Mark for Deletion
        append initial line to ET_DELETION assigning <S_DELETION>.
        move C_OBJTY_LINE            to <S_DELETION>-OBJ_TYPE.
        move LS_LINE_BUFFER-NETOBJID to <S_DELETION>-ID.

***     Remove from Buffer
        delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
      endloop.
    endif.

***--------------------------------------------------------------------------------------
*** Identify Deleted Clusters
    loop at ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER.
      check LS_CLSTR_BUFFER-R_GATE is not bound or
            LS_CLSTR_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_CLSTR             to <S_DELETION>-OBJ_TYPE.
      move LS_CLSTR_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_CLSTR_BUFFER.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify Deleted Lines
    loop at ME->T_LINE_BUFFER into LS_LINE_BUFFER where FIX eq ABAP_UNDEFINED.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_LINE             to <S_DELETION>-OBJ_TYPE.
      move LS_LINE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove from Buffer
      delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
    endloop.

  endmethod.
  method GET_ID_BY_IPRVT.

    data:  LS_PRVDR_DEF type /VCXI/VKSR_S_PRVDR_DEF.

***--------------------------------------------------------------------------------------
*** Get Provider Type Definitions if not already buffered
    if ME->T_PRVDR_DEF is initial.
      ME->T_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( ).
    endif.

***--------------------------------------------------------------------------------------
    read table ME->T_PRVDR_DEF into LS_PRVDR_DEF
                               with key IPRVT = IF_IPRVT.
    if SY-SUBRC eq 0.
      move LS_PRVDR_DEF-ID to RF_ID.
    else.
***   Provider Type &1 not defined for Specification Overview.
      /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                            IF_MSGID = 'ZVCXI_F0SS'
                                            IF_MSGNO = '301'
                                            IF_MSGV1 = IF_IPRVT ).
    endif.

  endmethod.
  method GET_NEXT_NETOBJID.

    add 1 to ME->F_NETOBJID_LAST.
    condense ME->F_NETOBJID_LAST.

    move ME->F_NETOBJID_LAST to RF_NETOBJID.

  endmethod.
  method GET_NODEID_BY_GATE.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER.

*** Search for direct Match as Cluster
    read table ME->T_CLSTR_BUFFER with key R_GATE = IR_GATE
                                  into LS_CLSTR_BUFFER.
    if SY-SUBRC eq 0.
      move LS_CLSTR_BUFFER-NETOBJID to RF_NETOBJID.
      return.
    endif.

*** Search for direct Match as Node
    read table ME->T_NODE_BUFFER with key R_GATE = IR_GATE
                                 into LS_NODE_BUFFER.
    if SY-SUBRC eq 0.
      move LS_NODE_BUFFER-NETOBJID to RF_NETOBJID.
      return.
    endif.

  endmethod.
  method GET_SPEC_GATE.

    data: LT_GATE type /VCXI/VKSR_TT_GATE.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.

    LT_GATE = IR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_SPEC=>C_IPRVT_F0_SPEC
                                  IF_INUSE = ABAP_TRUE ).

    loop at LT_GATE into LR_GATE.
      check IR_GATE->IS_IN_LINE( LR_GATE ) eq ABAP_TRUE.
      move LR_GATE to RR_SPEC_GATE.
    endloop.

  endmethod.
  method GET_XCONI_BY_NODEID.

    data: LR_GATE  type ref to /VCXI/CL_VKSR_GATE,
          LR_ANCHI type ref to ZIF_VCXI_F0SS_ANCHI.

***--------------------------------------------------------------------------------------
*** Get Gate of Node
    move ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID ) to LR_GATE.
    check LR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Check if gate is an anchorage for connection in
    try.
        move LR_GATE->R_CLSPR ?to LR_ANCHI.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_ANCHI.
    endtry.

    check LR_ANCHI is bound.

*** Creat new X-Connector
    RR_GATE = LR_ANCHI->ADD_XCON( ).

  endmethod.
  method GET_XCONO_BY_NODEID.

    data: LR_GATE  type ref to /VCXI/CL_VKSR_GATE,
          LR_ANCHO type ref to ZIF_VCXI_F0SS_ANCHO.

***--------------------------------------------------------------------------------------
*** Get Gate of Node
    move ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID ) to LR_GATE.
    check LR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Check if gate is an anchorage for connection out
    try.
        move LR_GATE->R_CLSPR ?to LR_ANCHO.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_ANCHO.
    endtry.

    check LR_ANCHO is bound.

*** Creat new X-Connector
    RR_GATE = LR_ANCHO->ADD_XCON( ).

  endmethod.
  method HANDLE_TOOLBAR_FCODE.

    data:  LR_CX_CKX type ref to /VCXI/CX_CKX.

    try.
***     Handle Function Code like normal User-Command
        ME->DO_USER_COMMAND( IF_UCOMM = FCODE ).

      catch /VCXI/CX_CKX into LR_CX_CKX.
        LR_CX_CKX->SHOW_MESSAGE( ).
    endtry.

  endmethod.
  method HANDLE_UC_COLLAPSE.

    data: LS_CLSTR       type CNG_CLUSTR,
          LS_NODES       type CNG_NODES,
          LS_NODE_BUFFER type YS_NODE_BUFFER.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE,
          LR_ND   type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER.


***--------------------------------------------------------------------------------------
*** Check whether all or only one selected Cluster should be collapsed
    if LINES( IT_NODE ) is not initial.
***   Get Gate for Cluster
      loop at IT_NODE into LS_NODES.

        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER with key NETOBJID = LS_NODES-ID.
        check LS_NODE_BUFFER-CLSTR_ID is not initial.

        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE_BUFFER-CLSTR_ID ) to LR_GATE.

        check LR_GATE is bound.
***--------------------------------------------------------------------------------------
***     Set Collapse Cluster Attribute
        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = LR_GATE ).
        check LR_ND is bound.

***     Set Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).

      endloop.

    elseif LINES( IT_CLSTR ) is not initial.

      loop at IT_CLSTR into LS_CLSTR.
        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_CLSTR-ID ) to LR_GATE.

        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = LR_GATE ).
        check LR_ND is bound.

***     Set Expand Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).

      endloop.

    else.
***   Collapse all Clusters
      loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = <S_CLSTR_BUFFER>-R_GATE ).
        check LR_ND is bound.

***     Set Expand Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).
      endloop.

    endif.

***--------------------------------------------------------------------------------------
*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_CONNECT.

    data: LS_LINE  type CNG_LINES,
          LS_XCONR type ZVCXI_F0SS_S_XCONR.
    data: LT_XCONR      type ZVCXI_F0SS_TT_XCONR,
          LT_SPEC_XCONR type ZVCXI_F0SS_TT_XCONR,
          LT_GATE_NEXT  type /VCXI/VKSR_TT_GATE,
          LT_GATE_TEMP  type /VCXI/VKSR_TT_GATE.
    data: LR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCONI type ref to /VCXI/CL_VKSR_GATE.
    data: LR_GATE_CURR_SPEC type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_NEXT_SPEC type ref to /VCXI/CL_VKSR_GATE.
    field-symbols:  <S_XCONR> type ZVCXI_F0SS_S_XCONR.


***--------------------------------------------------------------------------------------
*** Get current Connections
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

***--------------------------------------------------------------------------------------
*** Get Specification linkage relationships
    loop at LT_XCONR into LS_XCONR.
      insert initial line into table LT_SPEC_XCONR assigning <S_XCONR>.
      move ME->GET_SPEC_GATE( LS_XCONR-R_GATE_IN ) to <S_XCONR>-R_GATE_IN.
      move ME->GET_SPEC_GATE( LS_XCONR-R_GATE_OUT ) to <S_XCONR>-R_GATE_OUT.
    endloop.

*** Add new Connections
    loop at IT_LINE into LS_LINE.

***--------------------------------------------------------------------------------------
***   Get Outbound Connect
      move ME->GET_XCONO_BY_NODEID( IF_NETOBJID = LS_LINE-PRE ) to LR_GATE_XCONO.
      check LR_GATE_XCONO is bound.

***--------------------------------------------------------------------------------------
***   Get Inbound Connect
      move ME->GET_XCONI_BY_NODEID( IF_NETOBJID = LS_LINE-SUC ) to LR_GATE_XCONI.
      check LR_GATE_XCONI is bound.

***--------------------------------------------------------------------------------------
***   Get Current Spec Gate
      move ME->GET_SPEC_GATE( LR_GATE_XCONO ) to LR_GATE_CURR_SPEC.

***   Get Next Spec Gate
      move ME->GET_SPEC_GATE( LR_GATE_XCONI ) to LR_GATE_NEXT_SPEC.
      append LR_GATE_NEXT_SPEC  to LT_GATE_NEXT.

      do .
***     If Next Specification is the same with the starting point Specification
        loop at LT_GATE_NEXT into LR_GATE_NEXT_SPEC where TABLE_LINE eq LR_GATE_CURR_SPEC.
***       Clean up unnecessary created connections
          LR_GATE_XCONI->DO_FREE( ).
          LR_GATE_XCONO->DO_FREE( ).
          return.
        endloop.

***     Keep searching for a connection
        loop at LT_SPEC_XCONR into LS_XCONR.
          loop at LT_GATE_NEXT into LR_GATE_NEXT_SPEC where TABLE_LINE eq LS_XCONR-R_GATE_OUT.
            append LS_XCONR-R_GATE_IN to LT_GATE_TEMP.
          endloop.
        endloop.
        if LINES( LT_GATE_TEMP ) is initial.
          exit.
        else.
          move LT_GATE_TEMP[] to LT_GATE_NEXT[].
          refresh LT_GATE_TEMP.
        endif.
      enddo.

***--------------------------------------------------------------------------------------
***   Add Connection
      append initial line to LT_XCONR assigning <S_XCONR>.
      move LR_GATE_XCONO to <S_XCONR>-R_GATE_OUT.
      move LR_GATE_XCONI to <S_XCONR>-R_GATE_IN.
    endloop.

***--------------------------------------------------------------------------------------
*** Send to backend
    ME->R_PR_SOV->SET_XCONR( IT_XCONR = LT_XCONR ).

*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_DELETE.

    data: LF_NETOBJID    type NETOBJID.
    data: LS_DELETION    type NET_DELETE,
          LS_LINE_BUFFER type YS_LINE_BUFFER,
          LS_XCONR       type ZVCXI_F0SS_S_XCONR,
          LS_XCONR_READ  type ZVCXI_F0SS_S_XCONR,
          LS_NVALS       type ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data: LT_XCONR_DEL type ZVCXI_F0SS_TT_XCONR,
          LT_XCONR     type ZVCXI_F0SS_TT_XCONR,
          LT_GATE_FREE type /VCXI/VKSR_TT_GATE.
    data: LR_GATE      type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_NODE type ref to /VCXI/CL_VKSR_GATE,
          LR_ND        type ref to ZCL_VCXI_F0SS_ND.


***--------------------------------------------------------------------------------------
*** Process Deletion Requests
    loop at IT_DELETION into LS_DELETION.

      case LS_DELETION-OBJ_TYPE.

***     Nodes
        when C_OBJTY_NODE.
          LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_DELETION-ID ).
          check LR_GATE is bound.

***       Delete only if it`s not Input/Output
          check ME->IS_INOUT( IR_GATE = LR_GATE ) ne ABAP_TRUE.
          append LR_GATE to LT_GATE_FREE.

***     Lines
        when C_OBJTY_LINE.
          read table ME->T_LINE_BUFFER into LS_LINE_BUFFER
                                       with key NETOBJID = LS_DELETION-ID.
          check SY-SUBRC is initial.

          clear: LS_XCONR.
          move LS_LINE_BUFFER-R_GATE_IN   to LS_XCONR-R_GATE_IN.
          move LS_LINE_BUFFER-R_GATE_OUT  to LS_XCONR-R_GATE_OUT.
          append LS_XCONR to LT_XCONR_DEL.

***     Cluster
        when C_OBJTY_CLSTR.
          LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_DELETION-ID ).
          if LR_GATE is bound.
            append LR_GATE to LT_GATE_FREE.
          endif.

***       Get Node instance for Gate
          LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                  IR_GATE   = LR_GATE ).

***       Delete contained Nodes
          loop at LR_ND->T_NVALS into LS_NVALS where FL eq 'A'.

            move LS_NVALS-VAL to LF_NETOBJID.
            LR_GATE_NODE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LF_NETOBJID ).
            if LR_GATE_NODE is bound.
              append LR_GATE_NODE to LT_GATE_FREE.
            endif.

          endloop.
      endcase.
    endloop.

***--------------------------------------------------------------------------------------
*** Delete Connections collectively
    if LT_XCONR_DEL is not initial.
      LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

      loop at LT_XCONR into LS_XCONR.
        move LS_XCONR to LS_XCONR_READ.

***--------------------------------------------------------------------------------------
***     If the Gate is not found in any Buffer check if belongs to a Component
        if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR_READ-R_GATE_OUT ) is initial.
          ME->IS_INLINE( changing CR_GATE = LS_XCONR_READ-R_GATE_OUT ).
        endif.

        if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR_READ-R_GATE_IN ) is initial.
          ME->IS_INLINE( changing CR_GATE = LS_XCONR_READ-R_GATE_IN ).
        endif.

        read table LT_XCONR_DEL with key TABLE_LINE = LS_XCONR_READ
                                transporting no fields.
        if SY-SUBRC eq 0.
          delete LT_XCONR_DEL index SY-TABIX.
          delete LT_XCONR.
          append LS_XCONR-R_GATE_OUT to LT_GATE_FREE.
          append LS_XCONR-R_GATE_IN  to LT_GATE_FREE.
        endif.
      endloop.

      ME->R_PR_SOV->SET_XCONR( IT_XCONR = LT_XCONR ).
    endif.

***--------------------------------------------------------------------------------------
*** Free all collected Gates
    loop at LT_GATE_FREE into LR_GATE.
      LR_GATE->DO_FREE( ).
    endloop.

***--------------------------------------------------------------------------------------
*** Refresh UI
    ME->REFRESH_GRAPHIC( ).
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_DOUBLE_CLICK.

    data: LS_CLSTR type CNG_CLUSTR,
          LS_NODE  type CNG_NODES.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE,
          LR_ND   type ref to ZCL_VCXI_F0SS_ND.


***--------------------------------------------------------------------------------------
*** Double Click on Cluster
    loop at IT_CLSTR into LS_CLSTR.
      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_CLSTR-ID ) to LR_GATE.
***   Stop at first
      if LR_GATE is bound.
        exit.
      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Double Click on Node
    loop at IT_NODE into LS_NODE.
      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.
***   Stop at first
      if LR_GATE is bound.
        exit.
      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Open specific Node UI (Self, Child)
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = LR_GATE ).
    check LR_ND is bound.
*** Delegate Double Click to Node
    LR_ND->HANDLE_UC_DOUBLE_CLICK( ).

  endmethod.
  method HANDLE_UC_EXPAND.

    data: LS_NODE type CNG_NODES.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE,
          LR_ND   type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER,
                   <S_NODE_BUFFER>  type YS_NODE_BUFFER.


***--------------------------------------------------------------------------------------
*** Check whether all or only one selected Cluster should be collapsed
    if LINES( IT_NODE ) is not initial.

***   Get Gate for Node
      loop at IT_NODE into LS_NODE.
        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.

        check LR_GATE is bound.

***--------------------------------------------------------------------------------------
***     Set Collapse Cluster Attribute
        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = LR_GATE ).
        check LR_ND is bound.

***     Set Expand Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
      endloop.

    else.
***   Expand all clusters
      loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = <S_CLSTR_BUFFER>-R_GATE ).
        check LR_ND is bound.

***     Set Expand Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
      endloop.

***   Expand all current nodes
      loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER>.
        try.
            LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                    IR_GATE   = <S_NODE_BUFFER>-R_GATE ).
          catch CX_SY_MOVE_CAST_ERROR.
            clear: LR_ND.
        endtry.

        check LR_ND is bound.

***     Set Expand Value
        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
      endloop.

    endif.

***--------------------------------------------------------------------------------------
*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_INSERT.
    return.
  endmethod.
  method HANDLE_UC_MERGE_COMP.

    data: LS_XCONR type        ZVCXI_F0SS_S_XCONR,
          LS_NODE  type        CNG_NODES,
          LS_CLSTR type        CNG_CLUSTR.
    data: LT_XCONR type        ZVCXI_F0SS_TT_XCONR,
          LT_GATE  type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_SOURCE type ref to /VCXI/CL_VKSR_GATE,
          LR_XCOMP_OUT   type ref to /VCXI/CL_VKSR_GATE,
          LR_XCOMP_IN    type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_OUT    type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_IN     type ref to /VCXI/CL_VKSR_GATE,
          LR_XCOMP       type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_XCOMP    type ref to ZCL_VCXI_F0SS_PR_XCOMP,
          LR_GATE        type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE1       type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE2       type ref to /VCXI/CL_VKSR_GATE.

***--------------------------------------------------------------------------------------
*** Get current Connections
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

***--------------------------------------------------------------------------------------
*** Call from Context Menu
    if IS_POPUP_MENU is supplied.
***   Get Gate Source on which right-click was performed
      move IS_POPUP_MENU-R_ND->GET_GATE( ) to LR_GATE_SOURCE.

      if LR_GATE_SOURCE is bound.
***     Try to find if it`s a Connection In
        read table LT_XCONR into LS_XCONR with key R_GATE_IN = LR_GATE_SOURCE.
        if SY-SUBRC is initial.
          move LS_XCONR-R_GATE_OUT to LR_GATE_OUT.
          move LR_GATE_SOURCE      to LR_GATE_IN.
        endif.

***     Try to find if it`s a Connection Out
        read table LT_XCONR into LS_XCONR with key R_GATE_OUT = LR_GATE_SOURCE.
        if SY-SUBRC is initial.
          move LS_XCONR-R_GATE_IN to LR_GATE_IN.
          move LR_GATE_SOURCE     to LR_GATE_OUT.
        endif.
      endif.

***   Get all X-Comps
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_F0SS_PR_XCOMP=>C_IPRVT_XCOMP
                                       IF_INUSE  = ABAP_TRUE
                                       IF_SORTED = ABAP_TRUE ).
      loop at LT_GATE into LR_XCOMP.
        if LR_GATE_IN is bound.
***       Identify X-Comp In
          if LR_XCOMP->IS_IN_LINE( IR_GATE = LR_GATE_IN ) eq ABAP_TRUE.
            move LR_XCOMP to LR_XCOMP_IN.
          endif.
        endif.

        if LR_GATE_OUT is bound.
***       Identify X-Comp Out
          if LR_XCOMP->IS_IN_LINE( IR_GATE = LR_GATE_OUT ) eq ABAP_TRUE.
            move LR_XCOMP to LR_XCOMP_OUT.
          endif.
        endif.
      endloop.
    endif.

***--------------------------------------------------------------------------------------
*** Call from Toolbar Button
    if IT_NODE is supplied or IT_CLSTR is supplied.
***   Get the selected nodes if it`s at least a Node Selected
      loop at IT_NODE into LS_NODE.
        clear LR_GATE.

***     Get corresponding X-COMP based on Node
        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.
        check LR_GATE is bound.

        if LR_GATE1 is not bound.
          move LR_GATE to LR_GATE1.
        elseif LR_GATE2 is not bound.
          move LR_GATE to LR_GATE2.
        endif.
      endloop.

      loop at IT_CLSTR into LS_CLSTR.
        clear LR_GATE.

***     Get corresponding X-COMP based on Cluster
        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_CLSTR-ID ) to LR_GATE.
        check LR_GATE is bound.

        if LR_GATE1 is not bound.
          move LR_GATE to LR_GATE1.
        elseif LR_GATE2 is not bound.
          move LR_GATE to LR_GATE2.
        endif.
      endloop.

      check LR_GATE1 is bound and
            LR_GATE2 is bound.

***   Match the OUT->IN X-COMPs
      loop at LT_XCONR into LS_XCONR.
        if LR_GATE1->IS_IN_LINE( IR_GATE = LS_XCONR-R_GATE_OUT ) eq ABAP_TRUE and
           LR_GATE2->IS_IN_LINE( IR_GATE = LS_XCONR-R_GATE_IN ) eq ABAP_TRUE.

          move LR_GATE1 to LR_XCOMP_OUT.
          move LR_GATE2 to LR_XCOMP_IN.
        endif.

        if LR_GATE1->IS_IN_LINE( IR_GATE = LS_XCONR-R_GATE_IN ) eq ABAP_TRUE and
           LR_GATE2->IS_IN_LINE( IR_GATE = LS_XCONR-R_GATE_OUT ) eq ABAP_TRUE.

          move LR_GATE1 to LR_XCOMP_IN.
          move LR_GATE2 to LR_XCOMP_OUT.
        endif.
      endloop.
    endif.

***--------------------------------------------------------------------------------------
*** Call the 'MERGE'
    check LR_XCOMP_IN is bound and
          LR_XCOMP_OUT is bound.
    try.
        move LR_XCOMP_IN->R_CLSPR ?to LR_PR_XCOMP.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_XCOMP.
    endtry.
    if LR_PR_XCOMP is bound.
      LR_PR_XCOMP->MERGE( exporting IR_XCOMP_OUT = LR_XCOMP_OUT
                                    IR_GATE_SOV  = ME->R_GATE ).
    endif.

  endmethod.
  method HANDLE_UC_POPUP_MENU.

    data: LF_ID    type GRMODE,
          LF_ABCDE type SYABCDE,
          LF_POS   type I.
    data: LS_NODE       type CNG_NODES,
          LS_FCODE      type ZCL_VCXI_F0SS_ND=>YS_FCODE,
          LS_POPUP_MENU type YS_POPUP_MENU.
    data: LT_FCODE type ZCL_VCXI_F0SS_ND=>YT_FCODE.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE,
          LR_ND   type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_POPUP_MENU> type YS_POPUP_MENU.


    refresh: ME->T_POPUP_MENU.

***--------------------------------------------------------------------------------------
*** Right Click on Node
    loop at IT_NODE into LS_NODE.
      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.

***   Stop at first
      if LR_GATE is bound.
        exit.
      endif.
    endloop.

    check LR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Get Node Instance
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = LR_GATE ).
    check LR_ND is bound.
    refresh: LT_FCODE.

*** Get Node Popup Menu Entries
    LR_ND->GET_FCODE( importing ET_FCODE = LT_FCODE ).

    move SY-ABCDE to LF_ABCDE.

*** Add Cluster Popup Menu Entries
    loop at LT_FCODE into LS_FCODE.
      add 1 to LF_POS.
      move LF_ABCDE+LF_POS(1) to LF_ID.

      append initial line to ME->T_POPUP_MENU assigning <S_POPUP_MENU>.
      move LF_ID          to <S_POPUP_MENU>-ID.
      move LS_FCODE-FCODE to <S_POPUP_MENU>-FCODE.
      move LS_FCODE-TEXT  to <S_POPUP_MENU>-TEXT.
      move LR_ND          to <S_POPUP_MENU>-R_ND.
    endloop.

***--------------------------------------------------------------------------------------
*** Create Popup Menu Entries based on generated entries
    loop at ME->T_POPUP_MENU into LS_POPUP_MENU.
***   Set Popup Menu Entry
      call function 'CNET_SET_POPUP_DATA'
        exporting
          OBJECT = 'U3'
          ID     = LS_POPUP_MENU-ID
          TEXT   = LS_POPUP_MENU-TEXT
        exceptions
          others = 0.
    endloop.

  endmethod.
  method HANDLE_UC_POPUP_SEL.

    data: LS_POPUP_MENU  type        YS_POPUP_MENU.
    data: LR_PARENT_GATE type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_LINE_BUFFER> type YS_LINE_BUFFER.

***--------------------------------------------------------------------------------------
*** Read Popup Menu Table with selected item id
    read table ME->T_POPUP_MENU into LS_POPUP_MENU with key ID = IF_GR_MODE.

    check SY-SUBRC            is initial and
          LS_POPUP_MENU-R_ND  is bound.

    case LS_POPUP_MENU-FCODE.
      when ZCL_VCXI_F0SS_ND_CSTEP=>C_UC_SPLIT.
***     Special handling for Split option
        ME->HANDLE_UC_SPLIT_COMP( exporting IS_POPUP_MENU = LS_POPUP_MENU ).

      when ZCL_VCXI_F0SS_ND_CSTEP=>C_UC_MERGE.
***     Special handling for Merge option
        ME->HANDLE_UC_MERGE_COMP( exporting IS_POPUP_MENU = LS_POPUP_MENU ).

      when others.
***     Handle Popup Menu Selection
        LS_POPUP_MENU-R_ND->HANDLE_UC_POPUP_SEL( IF_FCODE = LS_POPUP_MENU-FCODE ).
        ME->R_UIGATE->REFRESH_SCREEN( ).

***     Only if it`s a conversion in place
        check LS_POPUP_MENU-FCODE cp '*CSTEP*'.

        move LS_POPUP_MENU-R_ND->GET_GATE( ) to LR_PARENT_GATE.
        loop at ME->T_LINE_BUFFER assigning <S_LINE_BUFFER> where R_GATE_OUT eq LR_PARENT_GATE.
          check <S_LINE_BUFFER>-R_GATE_IN is bound.
          move ABAP_UNDEFINED to <S_LINE_BUFFER>-FIX.
        endloop.

    endcase.

  endmethod.
  method HANDLE_UC_SPLIT_COMP.

    data: LS_XCONA        type        ZVCXI_F0SS_S_XCONA.
    data: LT_GATE  type        /VCXI/VKSR_TT_GATE,
          LT_XCONA type        ZVCXI_F0SS_TT_XCONA.
    data: LR_XCOMP_SOURCE type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_XCOMP     type ref to ZCL_VCXI_F0SS_PR_XCOMP,
          LR_GATE_SOURCE  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_DEST    type ref to /VCXI/CL_VKSR_GATE,
          LR_ND           type ref to ZCL_VCXI_F0SS_ND.

*** Get Gate Source on which right-click was performed
    move IS_POPUP_MENU-R_ND->GET_GATE( ) to LR_GATE_SOURCE.

***--------------------------------------------------------------------------------------
*** Get Source X-component
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_F0SS_PR_XCOMP=>C_IPRVT_XCOMP
                                     IF_INUSE  = ABAP_TRUE
                                     IF_SORTED = ABAP_TRUE ).
    loop at LT_GATE into LR_XCOMP_SOURCE.
      check LR_XCOMP_SOURCE->IS_IN_LINE( IR_GATE = LR_GATE_SOURCE ) eq ABAP_TRUE.
      exit.
    endloop.

***--------------------------------------------------------------------------------------
*** Split the X-Component
    if LR_XCOMP_SOURCE is bound.
      try .
          move LR_XCOMP_SOURCE->R_CLSPR ?to LR_PR_XCOMP.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_XCOMP.
      endtry.
      if LR_PR_XCOMP is bound.
        LR_PR_XCOMP->SPLIT( exporting IR_GATE_SOURCE = LR_GATE_SOURCE
                            importing ET_XCONA       = LT_XCONA
                                      ER_GATE_DEST   = LR_GATE_DEST ).
      endif.

      if LR_GATE_DEST is bound.
***     Set the new created X-Component as expanded
        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                                IR_GATE   = LR_GATE_DEST ).
        if LR_ND is bound.
          LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
        endif.
      endif.
    endif.

  endmethod.
  method INIT_CONTAINERS.

    check ME->R_CONTAINER_SPLITTER is not bound.

***--------------------------------------------------------------------------------------
*** Create Splitter
    create object ME->R_CONTAINER_SPLITTER
      exporting
        PARENT            = CL_GUI_CONTAINER=>DEFAULT_SCREEN
        ROWS              = 2
        COLUMNS           = 1
      exceptions
        CNTL_ERROR        = 1
        CNTL_SYSTEM_ERROR = 2
        others            = 3.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Get Toolbar Container
    ME->R_CONTAINER_TOOLBAR = ME->R_CONTAINER_SPLITTER->GET_CONTAINER( ROW       = 1
                                                                       COLUMN    = 1 ).

*** Get Graphic Container
    ME->R_CONTAINER_GRAPHIC = ME->R_CONTAINER_SPLITTER->GET_CONTAINER( ROW       = 2
                                                                       COLUMN    = 1 ).

***--------------------------------------------------------------------------------------
*** Make Row Absolute
    ME->R_CONTAINER_SPLITTER->SET_ROW_MODE( MODE = CL_GUI_SPLITTER_CONTAINER=>MODE_ABSOLUTE ).

*** Set Row Height
    ME->R_CONTAINER_SPLITTER->SET_ROW_HEIGHT( exporting  ID                = 1
                                                         HEIGHT            = CL_GUI_CFW=>COMPUTE_METRIC_FROM_DYNP( METRIC = CL_GUI_CONTROL=>METRIC_PIXEL
                                                                                                                   X_OR_Y = 'Y'
                                                                                                                   IN     = 1 ) " reserve space for supplied number of rows
                                              exceptions CNTL_ERROR        = 1
                                                         CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Make it not movable
    ME->R_CONTAINER_SPLITTER->SET_ROW_SASH( exporting  ID                = 1
                                                       TYPE              = CL_GUI_SPLITTER_CONTAINER=>TYPE_MOVABLE
                                                       VALUE             = CL_GUI_SPLITTER_CONTAINER=>FALSE
                                            exceptions CNTL_ERROR        = 1
                                                       CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Make Separator not visible
    ME->R_CONTAINER_SPLITTER->SET_ROW_SASH( exporting  ID                = 1
                                                       TYPE              = CL_GUI_SPLITTER_CONTAINER=>TYPE_SASHVISIBLE
                                                       VALUE             = CL_GUI_SPLITTER_CONTAINER=>FALSE
                                            exceptions CNTL_ERROR        = 1
                                                       CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method INIT_INODES.

*** Refresh Definition
    free: ME->T_INODE.

  endmethod.
  method INIT_NETCHART.

    check ME->R_NETCHART is not bound.

*** Create Netchart Object
    create object ME->R_NETCHART
      exporting
        PARENT                    = ME->R_CONTAINER_GRAPHIC
      exceptions
        CNTL_ERROR                = 1
        CNTL_SYSTEM_ERROR         = 2
        ILLEGAL_EVENT_COMBINATION = 3
        CREATE_ERROR              = 4
        others                    = 5.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method INIT_PROFILE.

    break HARDCODED_VALUES.
    move:
          'ZF0'                to ME->S_PROFILE-GRUPPE,
          '000000000001'       to ME->S_PROFILE-NAME,
          '1'                  to ME->S_PROFILE-INDEX.

*** Validate Profile
    select count( * )
           from TCNG
          where PRF_GRUPPE = ME->S_PROFILE-GRUPPE
           and  PRF_NAME   = ME->S_PROFILE-NAME
           and  PRF_INDEX  = ME->S_PROFILE-INDEX.
    if SY-SUBRC ne 0.
      clear ME->S_PROFILE.
    endif.

  endmethod.
  method INIT_TOOLBAR.

    data: LF_LOCKED   type        /VCXI/CKX_LOCKED,
          LF_INUSE    type        /VCXI/VKSR_INUSE,
          LF_DISABLED type        ABAP_BOOL.
    data:          LT_EVENT       type        CNTL_SIMPLE_EVENTS.
    field-symbols: <S_EVENT>      type        CNTL_SIMPLE_EVENT.

    check ME->R_TOOLBAR is not bound.

***--------------------------------------------------------------------------------------
*** Create Toolbar
    create object ME->R_TOOLBAR
      exporting
        PARENT             = ME->R_CONTAINER_TOOLBAR
      exceptions
        CNTL_INSTALL_ERROR = 1
        CNTL_ERROR         = 2
        CNTB_WRONG_VERSION = 3
        others             = 4.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Set Registered Events
    append initial line to LT_EVENT assigning <S_EVENT>.
    move CL_GUI_TOOLBAR=>M_ID_FUNCTION_SELECTED  to <S_EVENT>-EVENTID.

    ME->R_TOOLBAR->SET_REGISTERED_EVENTS( exporting
                                            EVENTS                    = LT_EVENT
                                          exceptions
                                            CNTL_ERROR                = 1
                                            CNTL_SYSTEM_ERROR         = 2
                                            ILLEGAL_EVENT_COMBINATION = 3
                                            others                    = 4 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Set Event Handler
    set handler ME->HANDLE_TOOLBAR_FCODE for ME->R_TOOLBAR.

***--------------------------------------------------------------------------------------
*** Get Disable-Status
    LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
    LF_INUSE  = ME->R_GATE->IS_INUSE( ).

    if LF_LOCKED ne ABAP_TRUE or
       LF_INUSE  ne ABAP_TRUE.
      move ABAP_TRUE to LF_DISABLED.
    endif.

***--------------------------------------------------------------------------------------
*** Add Button - Connect
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_CONNECT
                                          ICON             = ICON_CONNECT
                                          IS_DISABLED      = LF_DISABLED
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          TEXT             = text-B01
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Add Button - Merge
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_MERGE
                                          ICON             = ICON_PREVIOUS_HIERARCHY_LEVEL "ICON_WF_LINK
                                          IS_DISABLED      = LF_DISABLED
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          TEXT             = text-B08
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Add Button - Delete
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_DELETE
                                          ICON             = ICON_DELETE
                                          IS_DISABLED      = LF_DISABLED
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          TEXT             = text-B02
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Add Separator
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = ''
                                          ICON             = ''
                                          BUTN_TYPE        = C_BTYPE_SEPARATOR
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Add Button - Overview
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_OVERVIEW
                                          ICON             = ICON_OVERVIEW
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          QUICKINFO        = text-B03
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

****--------------------------------------------------------------------------------------
*** Add Button - Zoom In
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_ZOOM_IN
                                          ICON             = ICON_ZOOM_IN
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          QUICKINFO        = text-B04
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Add Button - Zoom Out
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_ZOOM_OUT
                                          ICON             = ICON_ZOOM_OUT
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          QUICKINFO        = text-B05
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Add Button - Collapse
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_COLLAPSE
                                          ICON             = ICON_COLLAPSE_ALL
                                          IS_DISABLED      = ABAP_FALSE
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          QUICKINFO        = text-B06
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Add Button - Expand
    ME->R_TOOLBAR->ADD_BUTTON( exporting  FCODE            = C_FCODE_EXPAND
                                          ICON             = ICON_EXPAND_ALL
                                          BUTN_TYPE        = C_BTYPE_BUTTON
                                          QUICKINFO        = text-B07
                               exceptions CNTL_ERROR       = 1
                                          CNTB_BTYPE_ERROR = 2
                                          CNTB_ERROR_FCODE = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method IS_EXPANDED.

    data LR_ND type ref to ZCL_VCXI_F0SS_ND.

    check IR_GATE is bound.

*** Get Node Instance
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = IR_GATE ).
    check LR_ND is bound.
    move LR_ND->F_EXPANDED to RF_RESULT.

  endmethod.
  method IS_INLINE.

    data: LS_NODE_BUFFER  type YS_NODE_BUFFER.

    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
***   Check if the Gate is inline with a Film Component
      check LS_NODE_BUFFER-R_GATE->IS_IN_LINE( IR_GATE = CR_GATE ) eq ABAP_TRUE.
      move LS_NODE_BUFFER-R_GATE to CR_GATE.
      exit.
    endloop.

  endmethod.
  method IS_INOUT.

    data: LR_FF_PR_INPUT  type ref to ZCL_VCXI_FFSS_PR_INPUT,
          LR_FF_PR_OUTPUT type ref to ZCL_VCXI_FFSS_PR_OUTPUT,
          LR_FB_PR_INPUT  type ref to ZCL_VCXI_FBSS_PR_INPUT,
          LR_FB_PR_OUTPUT type ref to ZCL_VCXI_FBSS_PR_OUTPUT.

    move ABAP_FALSE to RF_RESULT.

    if IR_GATE is supplied.
***   Try to cast to Film Input
      try .
          move IR_GATE->R_CLSPR ?to LR_FF_PR_INPUT.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_FF_PR_INPUT.
      endtry.
      if LR_FF_PR_INPUT is bound.
        move ABAP_TRUE to RF_RESULT.
        return.
      endif.

***   Try to cast to Bag Input
      try .
          move IR_GATE->R_CLSPR ?to LR_FB_PR_INPUT.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_FB_PR_INPUT.
      endtry.
      if LR_FB_PR_INPUT is bound.
        move ABAP_TRUE to RF_RESULT.
        return.
      endif.

***   Try to cast to Film Output
      try .
          move IR_GATE->R_CLSPR ?to LR_FF_PR_OUTPUT.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_FF_PR_OUTPUT.
      endtry.
      if LR_FF_PR_OUTPUT is bound.
        move ABAP_TRUE to RF_RESULT.
        return.
      endif.

***   Try to cast to Bag Output
      try .
          move IR_GATE->R_CLSPR ?to LR_FB_PR_OUTPUT.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_FB_PR_OUTPUT.
      endtry.
      if LR_FB_PR_OUTPUT is bound.
        move ABAP_TRUE to RF_RESULT.
        return.
      endif.
    endif.

  endmethod.
  method REFRESH_GRAPHIC.

    data: LT_CLSTR    type CNG_CLUSTR_TAB,
          LT_CVAL     type CVALS_TAB,
          LT_NODE     type CNG_NODES_TAB,
          LT_NVAL     type NVALS_TAB,
          LT_LINE     type CNG_LINES_TAB,
          LT_LVAL     type LVALS_TAB,
          LT_DELETION type NET_DELETE_TAB.

    check ME->R_NETCHART is bound.

*** Get Changes to the Graphic
    ME->GET_GRAPHIC_CHANGES( importing ET_CLSTR    = LT_CLSTR
                                       ET_CVAL     = LT_CVAL
                                       ET_NODE     = LT_NODE
                                       ET_NVAL     = LT_NVAL
                                       ET_LINE     = LT_LINE
                                       ET_LVAL     = LT_LVAL
                                       ET_DELETION = LT_DELETION ).

*** Add Initial Values to Node Values
    append lines of ME->T_INVAL to LT_NVAL.

*** Set user-defined values for nodes to display icons
    perform SET_USER_FVALS in program SAPLCNET using '0' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '1' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '2' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '3' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '4' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '5' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '6' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '7' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '8' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '9' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'A' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'B' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'C' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'D' 'b' 't' '9'.

    if LT_DELETION    is not initial and
       ME->F_ABAP_CMD is initial.
      move C_UC_DELETE to ME->F_ABAP_CMD.
    endif.


*** Process Graphic (clears tables, once processed)
    ME->R_NETCHART->GRAPHIC_NETWORK_PBO( exporting ABAP_CMD       = ME->F_ABAP_CMD
                                                   CONFIRM        = 'X'
                                                   PROFILE        = ME->S_PROFILE
                                                   STAT           = ME->F_STAT
                                                   STATUS_TEXT    = SPACE
                                         changing  INODES         = ME->T_INODE
                                                   DELETIONS      = LT_DELETION
                                                   LINES          = LT_LINE
                                                   LVALS          = LT_LVAL
                                                   NODES          = LT_NODE
                                                   NVALS          = LT_NVAL
                                                   CLUSTERS       = LT_CLSTR
                                                   CVALS          = LT_CVAL ).
*** Initial Display Overview
    ME->DO_USER_COMMAND( IF_UCOMM = C_FCODE_OVERVIEW ).

    if ME->F_ABAP_CMD is not initial.
      ME->REFRESH_GRAPHIC( ).
    endif.

  endmethod.
  method UPDATE_CLUSTER.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NVALS        type ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data: LR_ND type ref to ZCL_VCXI_F0SS_ND.
    field-symbols:  <S_CVAL> type NET_CVALS.


*** Get Gate of Cluster
    read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER
                                  with key NETOBJID = IF_NETOBJID.
    check SY-SUBRC eq 0.

*** Get Node Instance for Gate
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = LS_CLSTR_BUFFER-R_GATE ).
    check LR_ND is bound.

    delete CT_CVAL where ID eq IF_NETOBJID.

    loop at LR_ND->T_NVALS into LS_NVALS.
      append initial line to CT_CVAL assigning <S_CVAL>.
      <S_CVAL>-ID   = IF_NETOBJID.
      <S_CVAL>-FL   = LS_NVALS-FL.
      <S_CVAL>-VAL  = LS_NVALS-VAL.
    endloop.

  endmethod.
  method UPDATE_NODE.

    data: LS_NODE_BUFFER type YS_NODE_BUFFER,
          LS_NVALS       type ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data: LR_ND type ref to ZCL_VCXI_F0SS_ND.
    field-symbols: <S_NVAL> type NET_NVALS.


*** Get Gate of Node
    read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
                                      with key NETOBJID = IF_NETOBJID.
    check SY-SUBRC eq 0.

*** Get Node Instance for Gate
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = LS_NODE_BUFFER-R_GATE ).

    check LR_ND is bound.

    delete CT_NVAL where ID eq IF_NETOBJID.

    loop at LR_ND->T_NVALS into LS_NVALS.
      append initial line to CT_NVAL assigning <S_NVAL>.
      <S_NVAL>-ID   = IF_NETOBJID.
      <S_NVAL>-FL   = LS_NVALS-FL.
      <S_NVAL>-VAL  = LS_NVALS-VAL.
    endloop.

  endmethod.
