
class ZCL_VCXI_FBSS_UI_SOV definition
  public
  inheriting from ZCL_VCXI_F0SS_UI_SOV
  create public .

public section.

  methods DO_USER_COMMAND
    redefinition .
protected section.

  constants C_INODE_BCOMP type NETOBJID value 'BCOMP' ##NO_TEXT.
  constants C_INODE_DUPLEX type NETOBJID value 'DUPLEX' ##NO_TEXT.
  constants C_INODE_MONO type NETOBJID value 'MONO' ##NO_TEXT.

  methods GET_UPPER_NODE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_ROOT_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
      !IT_CVAL type CVALS_TAB
    returning
      value(RF_CLUSTER) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods GET_PARENT_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
      !IF_OBJID type NETOBJID
      !IF_PARENT_LVL type I optional
    returning
      value(RF_CLUSTER) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods GET_FREE_BFILM_GATE
    changing
      !CR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods ADD_INNER_COMP
    importing
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
      !IF_ROOT type ABAP_BOOL optional
      !IF_PARENT_LVL type I optional
      !IF_PARENT_OBJID type NETOBJID optional
    changing
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_INNER_COMP_LINES
    importing
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
    changing
      !CT_LINE type CNG_LINES_TAB
      !CT_LVAL type LVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods CHECK_ALLOWED_CONNECTION
    importing
      !IR_GATE_XCONI type ref to /VCXI/CL_VKSR_GATE
      !IR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_RETURN) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods FILL_CLUSTER_BCOMP
    importing
      !IR_GATE_BCOMP type ref to /VCXI/CL_VKSR_GATE
      !IF_OBJID type NETOBJID
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
    changing
      !CT_CVAL type CVALS_TAB
      !CT_CLSTR type CNG_CLUSTR_TAB
      !CT_LINE type CNG_LINES_TAB
      !CT_LVAL type LVALS_TAB
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods FILL_CLUSTER_BMAKE
    importing
      !IR_GATE_BMAKE type ref to /VCXI/CL_VKSR_GATE
      !IF_OBJID type NETOBJID
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
    changing
      !CT_CVAL type CVALS_TAB
      !CT_CLSTR type CNG_CLUSTR_TAB
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods GET_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
      !IF_OBJID_PARENT type NETOBJID optional
    exporting
      !EF_OBJID type NETOBJID
    changing
      !CT_CVAL type CVALS_TAB
      !CT_CLSTR type CNG_CLUSTR_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_GATE_AS_NODE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
      !IF_PARENT_LVL type I optional
      !IF_ROOT type ABAP_BOOL optional
      !IF_PARENT_OBJID type NETOBJID
    changing
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods BFILM_EXIST
    importing
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
      !IR_GATE_BFILM type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_INDEX) type SYINDEX
    raising
      /VCXI/CX_CKX .
  methods GET_PREV_CORR
    importing
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RT_GATE_PREV) type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_PR_SPEC
    importing
      !IR_GATE_XCOMP type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_PR_SPEC) type ref to ZCL_VCXI_F0SS_PR_SPEC
    raising
      /VCXI/CX_CKX .
  methods LOOKUP_BMAKE_GATE
    importing
      !IT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
    returning
      value(RR_GATE_BMAKE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods REORDER_SEQUENCE
    changing
      !CT_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE
    raising
      /VCXI/CX_CKX .
  methods SET_COLLAPSE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE optional
      !IF_OBJID type NETOBJID optional
    raising
      /VCXI/CX_CKX .
  methods SET_CONNECTIONS
    changing
      !CT_LINE type CNG_LINES_TAB
      !CT_LVAL type LVALS_TAB
      !CT_DELETION type NET_DELETE_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_BCOMP
    importing
      !IF_DXCON type ZVCXI_F0SS_DXCON optional
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
      !ER_XCON_ANCHO type ref to ZIF_VCXI_F0SS_ANCHO
      !ER_XCON_ANCHI type ref to ZIF_VCXI_F0SS_ANCHI
    raising
      /VCXI/CX_CKX .
  methods CHECK_ADD_BFG
    returning
      value(RR_GATE_OUTPUT) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods ADD_DUPLEX
    raising
      /VCXI/CX_CKX .
  methods ADD_GLUE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods ADD_MONO
    importing
      !IF_DXCON type ZVCXI_F0SS_DXCON optional
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
      !ER_XCON_ANCHO type ref to ZIF_VCXI_F0SS_ANCHO
      !ER_XCON_ANCHI type ref to ZIF_VCXI_F0SS_ANCHI
    raising
      /VCXI/CX_CKX .

  methods GET_GRAPHIC_CHANGES
    redefinition .
  methods GET_XCONI_BY_NODEID
    redefinition .
  methods GET_XCONO_BY_NODEID
    redefinition .
  methods HANDLE_UC_COLLAPSE
    redefinition .
  methods HANDLE_UC_CONNECT
    redefinition .
  methods HANDLE_UC_INSERT
    redefinition .
  methods INIT_INODES
    redefinition .
  methods IS_INLINE
    redefinition .
private section.
endclass. "ZCL_VCXI_FBSS_UI_SOV definition
class ZCL_VCXI_FBSS_UI_SOV implementation.
  method ADD_BCOMP.

    data: LR_GATE_BCOMP  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_BFG    type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_OUTPUT type ref to /VCXI/CL_VKSR_GATE.

***--------------------------------------------------------------------------------------
*** Create Component
    LR_GATE_BCOMP = ME->R_GATE->CREATE_ELEMENT( IF_ID = 'BCOMP' ).

*** Set in Use
    if LR_GATE_BCOMP->GET_USYNC( ) eq ABAP_FALSE.
      LR_GATE_BCOMP->SET_INUSE( IF_INUSE = ABAP_TRUE ).
    endif.

***--------------------------------------------------------------------------------------
*** Check If Bag Finished Good needs to be created
    move ME->CHECK_ADD_BFG( ) to LR_GATE_OUTPUT.
    if LR_GATE_OUTPUT is bound.
***   Create Bag Finished Good
      LR_GATE_BFG = LR_GATE_OUTPUT->CREATE_ELEMENT( IF_ID = 'BFG' ).

***   Set in Use
      if LR_GATE_BFG->GET_USYNC( ) eq ABAP_FALSE.
        LR_GATE_BFG->SET_INUSE( IF_INUSE = ABAP_TRUE ).
      endif.
    endif.

    move LR_GATE_BCOMP to ER_GATE.

    check ER_XCON_ANCHO is requested or
          ER_XCON_ANCHI is requested.

    check ER_GATE is bound.

    try.
        case IF_DXCON.
          when ZIF_VCXI_F0SS_ANCHO=>C_DXCON_OUT.
            move ER_GATE->R_CLSPR ?to ER_XCON_ANCHO.
          when ZIF_VCXI_F0SS_ANCHI=>C_DXCON_IN.
            move ER_GATE->R_CLSPR ?to ER_XCON_ANCHI.
        endcase.

      catch CX_SY_MOVE_CAST_ERROR.
        return.
    endtry.

  endmethod.
  method ADD_DUPLEX.

    data: LR_GATE_RC type ref to /VCXI/CL_VKSR_GATE,
          LR_ANCHO1  type ref to ZIF_VCXI_F0SS_ANCHO,
          LR_ANCHO2  type ref to ZIF_VCXI_F0SS_ANCHO,
          LR_ANCHI   type ref to ZIF_VCXI_F0SS_ANCHI.

***--------------------------------------------------------------------------------------
*** Create the first Component
    ME->ADD_MONO( exporting IF_DXCON      = ZIF_VCXI_F0SS_ANCHO=>C_DXCON_OUT
                  importing ER_XCON_ANCHO = LR_ANCHO1 ).

*** Create the second Component
    ME->ADD_MONO( exporting IF_DXCON      = ZIF_VCXI_F0SS_ANCHO=>C_DXCON_OUT
                  importing ER_XCON_ANCHO = LR_ANCHO2 ).

*** Create the Result Component
    ME->ADD_MONO( exporting IF_DXCON      = ZIF_VCXI_F0SS_ANCHI=>C_DXCON_IN
                  importing ER_XCON_ANCHI = LR_ANCHI
                            ER_GATE       = LR_GATE_RC ).

***--------------------------------------------------------------------------------------
*** Connect first Component using the XCON
    ME->CONNECT_BY_XCON( IR_XCON_IN   = LR_ANCHI
                         IR_XCON_OUT  = LR_ANCHO1 ).

*** Add Glue (in between)
    ME->ADD_GLUE( exporting IR_GATE = LR_GATE_RC ).

*** Connect second Component using the XCON
    ME->CONNECT_BY_XCON( IR_XCON_IN   = LR_ANCHI
                         IR_XCON_OUT  = LR_ANCHO2 ).

  endmethod.
  method ADD_GATE_AS_NODE.

    data: LF_OBJID_XNODE type NETOBJID,
          LF_CLUSTER     type NETOBJID.
    data: LS_NODE_BUFFER  type YS_NODE_BUFFER.
    data: LR_ND           type ref to ZCL_VCXI_F0SS_ND.

    if ME->IS_EXPANDED( IR_GATE ) eq ABAP_TRUE.
***   If Gate is expanded, don`t add as node because it`s cluster
      return.

    else.
***   Get Node Instance for Gate
      LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                              IR_GATE   = IR_GATE ).
      if LR_ND is bound.
        case LR_ND->F_ASSIGN.
          when ZCL_VCXI_F0SS_ND=>C_PARENT_ASSIGN.
            check IF_PARENT_OBJID is not initial.
***         Get Parent Cluster
            LF_CLUSTER = ME->GET_PARENT_CLUSTER( exporting IR_GATE = IR_GATE
                                                           IF_OBJID = IF_PARENT_OBJID
                                                           IF_PARENT_LVL = IF_PARENT_LVL ).

          when ZCL_VCXI_F0SS_ND=>C_ROOT_ASSIGN.
            check IF_ROOT eq ABAP_TRUE.
***         Get Root Cluster
            LF_CLUSTER = ME->GET_ROOT_CLUSTER( exporting IR_GATE = IR_GATE
                                                         IT_CVAL = CT_CVAL ).

          when others.
            return.
        endcase.
      endif.
    endif.

    if LF_CLUSTER is initial.
      return.
    endif.

***--------------------------------------------------------------------------------------
*** Identify new or changed Node
    read table ME->T_NODE_BUFFER into LS_NODE_BUFFER with key R_GATE = IR_GATE.
    if SY-SUBRC is initial.
      move LS_NODE_BUFFER-NETOBJID to LF_OBJID_XNODE.
      ME->UPDATE_NODE( exporting IF_NETOBJID = LF_OBJID_XNODE
                       changing  CT_NVAL     = CT_NVAL ).
    else.
***   Add Gate as Node
      ME->ADD_AS_NODE( exporting IR_GATE     = IR_GATE
                       importing EF_NETOBJID = LF_OBJID_XNODE
                       changing  CT_NODE     = CT_NODE
                                 CT_NVAL     = CT_NVAL ).

***   Add Node to Cluster
      ME->ADD_NODE_TO_CLUSTER( exporting IF_NETOBJID_CLSTR = LF_CLUSTER
                                         IF_NETOBJID_NODE  = LF_OBJID_XNODE
                               changing  CT_CVAL           = CT_CVAL ).
    endif.

  endmethod.
  method ADD_GLUE.

    data: LT_GATE       type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_GLUE  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_INPUT type ref to /VCXI/CL_VKSR_GATE.

    LT_GATE = IR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FFSS_PR_INPUT=>ZIF_VCXI_F0SS_ANCHI~C_IPRVT_ANCHI
                                  IF_INUSE = ABAP_TRUE ).

    read table LT_GATE into LR_GATE_INPUT index 1.
    if LR_GATE_INPUT is bound.
      LR_GATE_GLUE = LR_GATE_INPUT->CREATE_ELEMENT( IF_ID = 'MS_GLUE' ).

***   Set in Use
      if LR_GATE_GLUE->GET_USYNC( ) eq ABAP_FALSE.
        LR_GATE_GLUE->SET_INUSE( IF_INUSE = ABAP_TRUE ).
      endif.
    endif.

  endmethod.
  method ADD_INNER_COMP.

    data: LS_SEQUENCE  type        ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.
    data: LR_GATE_NEXT type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PREV type ref to /VCXI/CL_VKSR_GATE.

***--------------------------------------------------------------------------------------
*** Handle all inner Components
    loop at IT_SEQUENCE into LS_SEQUENCE.
***   Add the Next Nodes
      loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
        ME->ADD_GATE_AS_NODE( exporting IR_GATE         = LR_GATE_NEXT
                                        IF_ROOT         = IF_ROOT
                                        IF_PARENT_OBJID = IF_PARENT_OBJID
                                        IF_PARENT_LVL   = IF_PARENT_LVL
                              changing  CT_NODE         = CT_NODE
                                        CT_NVAL         = CT_NVAL
                                        CT_CVAL         = CT_CVAL ).
      endloop.

***   Add the Previous Nodes
      loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.
        ME->ADD_GATE_AS_NODE( exporting IR_GATE         = LR_GATE_PREV
                                        IF_ROOT         = IF_ROOT
                                        IF_PARENT_OBJID = IF_PARENT_OBJID
                                        IF_PARENT_LVL   = IF_PARENT_LVL
                              changing  CT_NODE         = CT_NODE
                                        CT_NVAL         = CT_NVAL
                                        CT_CVAL         = CT_CVAL ).
      endloop.
    endloop.

  endmethod.
  method ADD_INNER_COMP_LINES.

    data: LS_SEQUENCE  type ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.
    data: LR_GATE_NEXT type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PREV type ref to /VCXI/CL_VKSR_GATE.


    loop at IT_SEQUENCE into LS_SEQUENCE.
      loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
        loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.

          read table ME->T_NODE_BUFFER with key R_GATE = LR_GATE_NEXT transporting no fields.
          check SY-SUBRC is initial.

          read table ME->T_NODE_BUFFER with key R_GATE = LR_GATE_PREV transporting no fields.
          check SY-SUBRC is initial.

***       Check Line isn't already there
          read table ME->T_LINE_BUFFER with key R_GATE_OUT = LR_GATE_NEXT
                                                R_GATE_IN  = LR_GATE_PREV
                                       transporting no fields.
          check SY-SUBRC ne 0.

***       Add Line
          ME->ADD_AS_LINE( exporting IR_GATE_OUT = LR_GATE_NEXT
                                     IR_GATE_IN  = LR_GATE_PREV
                                     IF_FIX      = ABAP_TRUE
                           changing  CT_LINE     = CT_LINE
                                     CT_LVAL     = CT_LVAL ).
        endloop.
      endloop.
    endloop.

  endmethod.
  method ADD_MONO.

    data: LR_GATE_FCOMP type ref to /VCXI/CL_VKSR_GATE.

***--------------------------------------------------------------------------------------
*** Create Component
    LR_GATE_FCOMP = ME->R_GATE->CREATE_ELEMENT( IF_ID = 'FCOMP' ).

*** Set in Use
    if LR_GATE_FCOMP->GET_USYNC( ) eq ABAP_FALSE.
      LR_GATE_FCOMP->SET_INUSE( IF_INUSE = ABAP_TRUE ).
    endif.

    move LR_GATE_FCOMP to ER_GATE.

    check ER_XCON_ANCHO is requested or
          ER_XCON_ANCHI is requested.

    check ER_GATE is bound.

    try.
        case IF_DXCON.
          when ZIF_VCXI_F0SS_ANCHO=>C_DXCON_OUT.
            move ER_GATE->R_CLSPR ?to ER_XCON_ANCHO.
          when ZIF_VCXI_F0SS_ANCHI=>C_DXCON_IN.
            move ER_GATE->R_CLSPR ?to ER_XCON_ANCHI.
        endcase.

      catch CX_SY_MOVE_CAST_ERROR.
        return.
    endtry.

  endmethod.
  method BFILM_EXIST.

    data: LF_TABIX      type        SYTABIX.
    data: LS_SEQUENCE   type        ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.

    loop at IT_SEQUENCE into LS_SEQUENCE.
      move SY-TABIX to LF_TABIX.
      read table LS_SEQUENCE-T_GATE_PREV with key TABLE_LINE = IR_GATE_BFILM
                                         transporting no fields.
      check SY-SUBRC is initial.

      move LF_TABIX to RF_INDEX.
      exit.
    endloop.

  endmethod.
  method CHECK_ADD_BFG.

    data: LS_SEQUENCE   type        ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.
    data: LT_GATE_BCOMP type        /VCXI/VKSR_TT_GATE,
          LT_GATE_SPEC  type        /VCXI/VKSR_TT_GATE,
          LT_SEQUENCE   type        ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE.
    data: LR_GATE_BCOMP type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_SPEC  type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_SPEC    type ref to ZCL_VCXI_F0SS_PR_SPEC,
          LR_PR_OUTPUT  type ref to ZCL_VCXI_FBSS_PR_OUTPUT,
          LR_GATE_PREV  type ref to /VCXI/CL_VKSR_GATE.

    LT_GATE_BCOMP = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BCOMP=>C_IPRVT_FB_BCOMP
                                           IF_INUSE = ABAP_TRUE
                                           IF_SORTED = ABAP_TRUE ).

    check LINES( LT_GATE_BCOMP ) eq 1.
    loop at LT_GATE_BCOMP into LR_GATE_BCOMP.

      LT_GATE_SPEC = LR_GATE_BCOMP->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_SPEC=>C_IPRVT_F0_SPEC
                                               IF_INUSE = ABAP_TRUE ).
      read table LT_GATE_SPEC into LR_GATE_SPEC index 1.

      try .
          move LR_GATE_SPEC->R_CLSPR ?to LR_PR_SPEC.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_SPEC.
      endtry.

      check LR_PR_SPEC is bound.

***   Get sequence of Gates inside the Specification
      LT_SEQUENCE = LR_PR_SPEC->GET_SEQUENCE( ).

      loop at LT_SEQUENCE into LS_SEQUENCE.

***     Return Output Gate
        loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.
          try.
              move LR_GATE_PREV->R_CLSPR ?to LR_PR_OUTPUT.
            catch CX_SY_MOVE_CAST_ERROR.
              continue.
          endtry.

          check LR_PR_OUTPUT is bound.
          move LR_GATE_PREV to RR_GATE_OUTPUT.
        endloop.

      endloop.
    endloop.

  endmethod.
  method CHECK_ALLOWED_CONNECTION.

    data: LR_PR_BCONO type ref to ZCL_VCXI_FBSS_PR_BCONO,
          LR_PR_BCONI type ref to ZCL_VCXI_FBSS_PR_BCONI,
          LR_PR_FCONI type ref to ZCL_VCXI_FFSS_PR_FCONI,
          LR_PR_FCONO type ref to ZCL_VCXI_FFSS_PR_FCONO.

    move ABAP_TRUE to RF_RETURN.

    try .
        move IR_GATE_XCONI->R_CLSPR ?to LR_PR_BCONI.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_BCONI.
    endtry.

    try .
        move IR_GATE_XCONO->R_CLSPR ?to LR_PR_BCONO.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_BCONO.
    endtry.

    try .
        move IR_GATE_XCONI->R_CLSPR ?to LR_PR_FCONI.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_FCONI.
    endtry.

    try .
        move IR_GATE_XCONO->R_CLSPR ?to LR_PR_FCONO.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_FCONO.
    endtry.

*** Bag to Film => not allowed
    if LR_PR_BCONO is bound and
       LR_PR_FCONI is bound.
      move ABAP_FALSE to RF_RETURN.
    endif.

*** Film to Bag without Bag Making => not allowed
    if LR_PR_BCONI is bound and
       LR_PR_FCONO is bound.
      move ABAP_FALSE to RF_RETURN.
    endif.

  endmethod.
  method DO_USER_COMMAND.

    data: LF_RETURN     type I,
          LF_GR_MES     type GRMES,
          LF_GR_MODE    type GRMODE,
          LF_UCOMM      type SYUCOMM,
          LF_INIT_UCOMM type SYUCOMM.
    data: LT_CLSTR    type CNG_CLUSTR_TAB,
          LT_NODE     type CNG_NODES_TAB,
          LT_LINE     type CNG_LINES_TAB,
          LT_DELETION type NET_DELETE_TAB,
          LT_CVALS    type CVALS_TAB,
          LT_NVALS    type NVALS_TAB,
          LT_FVALS    type NVALS_TAB.

    check ME->R_NETCHART is bound.

***--------------------------------------------------------------------------------------
*** Save incoming funtion code
    move IF_UCOMM to : LF_UCOMM, LF_INIT_UCOMM.

*** Expand node => simulate doubleclick to get feedback from graphic
    if LF_UCOMM eq C_FCODE_EXPAND or
       LF_UCOMM eq C_FCODE_COLLAPSE or
       LF_UCOMM eq C_FCODE_MERGE.

      move: LF_UCOMM    to ME->F_LAST_UCOMM,
            C_UC_MODIFY to LF_UCOMM.

***   Refresh Line Buffer to ensure a complete re-build
      refresh ME->T_LINE_BUFFER.
    endif.

***--------------------------------------------------------------------------------------
*** Send Function Code to Control if not Control- or Shell-Event
    if LF_INIT_UCOMM(4) ne '%_GC' and
       LF_INIT_UCOMM(4) ne '%_GS'.
      ME->R_NETCHART->SET_FUNCTION_CODE( exporting FUNCTION_CODE = LF_UCOMM
                                         importing RETURN        = LF_RETURN ).
      if LF_RETURN ne 0.
        CL_GUI_CFW=>FLUSH( ).
        return.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Process after Input for Graphic
    ME->R_NETCHART->GRAPHIC_PAI( importing GR_MES       = LF_GR_MES
                                           GR_MODE      = LF_GR_MODE
                                 changing  DELETIONS    = LT_DELETION
                                           FVALS        = LT_FVALS
                                           LINES        = LT_LINE
                                           NODES        = LT_NODE
                                           NVALS        = LT_NVALS
                                           CLUSTERS     = LT_CLSTR
                                           CVALS        = LT_CVALS ).

*** Set Back to expand to handle it correctly
    if ME->F_ABAP_CMD eq C_UC_SELECT.
      move ME->F_LAST_UCOMM to LF_GR_MES.
    endif.

    clear: ME->F_ABAP_CMD.
    move C_STAT_WAIT to ME->F_STAT.

***--------------------------------------------------------------------------------------
*** Process Action
    case LF_GR_MES.

***   Insert
      when C_UC_INSERT.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_INSERT( exporting IT_NODE = LT_NODE ).

***   Connect
      when C_UC_CONNECT.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_CONNECT( exporting IT_LINE = LT_LINE ).

***   Delete
      when C_UC_DELETE.
        ME->CHECK_DELETION( changing CT_DELETION = LT_DELETION
                                     CF_GR_MES   = LF_GR_MES ).

        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_DELETE( exporting IT_DELETION = LT_DELETION ).

***   Double Click
      when C_UC_DOUBLE_CLICK.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_DOUBLE_CLICK( exporting IT_CLSTR = LT_CLSTR
                                              IT_NODE  = LT_NODE ).
***   Expand Node/Cluster
      when C_FCODE_EXPAND.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_EXPAND( exporting IT_NODE = LT_NODE ).

***   Collapse Cluster
      when C_FCODE_COLLAPSE.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_COLLAPSE( exporting IT_NODE  = LT_NODE
                                          IT_CLSTR = LT_CLSTR ).

***   Simulate Modify
      when C_UC_MODIFY.
        ME->F_ABAP_CMD = C_UC_SELECT.

***     Refresh UI here to get in next run the "selected" node
        ME->REFRESH_GRAPHIC( ).
        ME->R_UIGATE->REFRESH_SCREEN( ).

***   Dynamic Popup
      when C_UC_DPOPUP.
        ME->F_ABAP_CMD = LF_GR_MES.
        ME->HANDLE_UC_POPUP_MENU( exporting IT_NODE = LT_NODE ).

***   Popup Message
      when C_UC_POPUP.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_POPUP_SEL( exporting IF_GR_MODE = LF_GR_MODE ).

***   Merge
      when C_FCODE_MERGE.
        ME->F_ABAP_CMD = C_UC_MODIFY.
        ME->HANDLE_UC_MERGE_COMP( exporting IT_NODE  = LT_NODE
                                            IT_CLSTR = LT_CLSTR ).
    endcase.

  endmethod.
  method FILL_CLUSTER_BCOMP.

    data: LF_OBJID_BCLST type NETOBJID.
    data: LR_GATE_BMAKE  type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER,
                   <S_NODE_BUFFER>  type YS_NODE_BUFFER.


***--------------------------------------------------------------------------------------
*** Lookup for a Bag Making Gate
    move ME->LOOKUP_BMAKE_GATE( exporting IT_SEQUENCE = IT_SEQUENCE ) to LR_GATE_BMAKE.

***--------------------------------------------------------------------------------------
*** Add Bag Making as Cluster and Link it to BCOMP
    if LR_GATE_BMAKE is bound.
      if ME->IS_EXPANDED( LR_GATE_BMAKE ) eq ABAP_TRUE.
        ME->GET_CLUSTER( exporting IR_GATE         = LR_GATE_BMAKE
                                   IF_OBJID_PARENT = IF_OBJID
                         importing EF_OBJID        = LF_OBJID_BCLST
                         changing  CT_CVAL         = CT_CVAL
                                   CT_CLSTR        = CT_CLSTR ).

***     Fill Bag Making Cluster
        ME->FILL_CLUSTER_BMAKE( exporting IT_SEQUENCE     = IT_SEQUENCE
                                          IR_GATE_BMAKE   = LR_GATE_BMAKE
                                          IF_OBJID        = LF_OBJID_BCLST
                                changing  CT_CVAL         = CT_CVAL
                                          CT_CLSTR        = CT_CLSTR
                                          CT_NVAL         = CT_NVAL
                                          CT_NODE         = CT_NODE  ).

***--------------------------------------------------------------------------------------
***     Add Nodes for Bag Making via the Sequence
        ME->ADD_INNER_COMP( exporting IT_SEQUENCE     = IT_SEQUENCE
                                      IF_ROOT         = ABAP_TRUE
                                      IF_PARENT_OBJID = LF_OBJID_BCLST
                                      IF_PARENT_LVL   = 1
                            changing  CT_NODE         = CT_NODE
                                      CT_NVAL         = CT_NVAL
                                      CT_CVAL         = CT_CVAL ).

      else.
***     Remove old Cluster Bag Making
        loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> where R_GATE eq LR_GATE_BMAKE or
                                                                    R_GATE is not bound.
          clear <S_CLSTR_BUFFER>-R_GATE.
          loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> where CLSTR_ID eq <S_CLSTR_BUFFER>-NETOBJID.
            clear <S_NODE_BUFFER>-R_GATE.
          endloop.
        endloop.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Add Nodes for XCLSTR via the Sequence
    ME->ADD_INNER_COMP( exporting IT_SEQUENCE     = IT_SEQUENCE
                                  IF_ROOT         = ABAP_TRUE
                                  IF_PARENT_OBJID = IF_OBJID
                                  IF_PARENT_LVL   = 3
                        changing  CT_NODE         = CT_NODE
                                  CT_NVAL         = CT_NVAL
                                  CT_CVAL         = CT_CVAL ).

***--------------------------------------------------------------------------------------
*** Add Lines inside Component
    ME->ADD_INNER_COMP_LINES( exporting IT_SEQUENCE = IT_SEQUENCE
                              changing  CT_LINE     = CT_LINE
                                        CT_LVAL     = CT_LVAL ).

  endmethod.
  method FILL_CLUSTER_BMAKE.

    data: LF_OBJID_PCLST type NETOBJID,
          LF_OBJID_HCLST type NETOBJID.
    data: LT_GATE type /VCXI/VKSR_TT_GATE.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER,
                   <S_NODE_BUFFER>  type YS_NODE_BUFFER.


***--------------------------------------------------------------------------------------
*** Add Bag Part as Cluster and Link it to Bag Making
    LT_GATE = IR_GATE_BMAKE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BPART=>C_IPRVT_BPART
                                        IF_INUSE = ABAP_TRUE ).

    loop at LT_GATE into LR_GATE.
      if ME->IS_EXPANDED( LR_GATE ) eq ABAP_TRUE.
        ME->GET_CLUSTER( exporting IR_GATE         = LR_GATE
                                   IF_OBJID_PARENT = IF_OBJID
                         importing EF_OBJID        = LF_OBJID_PCLST
                         changing  CT_CVAL         = CT_CVAL
                                   CT_CLSTR        = CT_CLSTR ).

***     Nodes will be added via Sequence with a parent cluster given
        ME->ADD_INNER_COMP( exporting IT_SEQUENCE     = IT_SEQUENCE
                                      IF_PARENT_OBJID = LF_OBJID_PCLST
                                      IF_PARENT_LVL   = 2
                            changing  CT_NODE         = CT_NODE
                                      CT_NVAL         = CT_NVAL
                                      CT_CVAL         = CT_CVAL ).
      else.

***     Remove old Cluster Bag Part if any
        read table ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> with key R_GATE = LR_GATE.
        if SY-SUBRC is initial.
          clear <S_CLSTR_BUFFER>-R_GATE.
          loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> where CLSTR_ID eq <S_CLSTR_BUFFER>-NETOBJID.
            clear <S_NODE_BUFFER>-R_GATE.
          endloop.
        endif.

      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Add Handles as Cluster and Link it to Bag Making
    refresh LT_GATE.
    LT_GATE = IR_GATE_BMAKE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HANDLE=>C_IPRVT_HANDLE
                                        IF_INUSE = ABAP_TRUE ).
    loop at LT_GATE into LR_GATE.
      if ME->IS_EXPANDED( LR_GATE ) eq ABAP_TRUE.
        ME->GET_CLUSTER( exporting IR_GATE         = LR_GATE
                                   IF_OBJID_PARENT = IF_OBJID
                         importing EF_OBJID        = LF_OBJID_HCLST
                         changing  CT_CVAL         = CT_CVAL
                                   CT_CLSTR        = CT_CLSTR ).

***     Nodes will be added via Sequence with a parent cluster given
        ME->ADD_INNER_COMP( exporting IT_SEQUENCE     = IT_SEQUENCE
                                      IF_PARENT_OBJID = LF_OBJID_HCLST
                                      IF_PARENT_LVL   = 3
                            changing  CT_NODE         = CT_NODE
                                      CT_NVAL         = CT_NVAL
                                      CT_CVAL         = CT_CVAL ).
      else.

***     Remove old Cluster Bag Part if any
        read table ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> with key R_GATE = LR_GATE.
        if SY-SUBRC is initial.
          clear <S_CLSTR_BUFFER>-R_GATE.
          loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> where CLSTR_ID eq <S_CLSTR_BUFFER>-NETOBJID.
            clear <S_NODE_BUFFER>-R_GATE.
          endloop.
        endif.

      endif.
    endloop.

  endmethod.
  method GET_CLUSTER.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER.
    field-symbols: <S_CVAL>        type NET_CVALS,
                   <S_NODE_BUFFER> type YS_NODE_BUFFER.

*** Identify new or changed Cluster
    read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER
                                  with key R_GATE = IR_GATE.
    if SY-SUBRC is initial.
      move LS_CLSTR_BUFFER-NETOBJID to EF_OBJID.
      ME->UPDATE_CLUSTER( exporting IF_NETOBJID = EF_OBJID
                          changing  CT_CVAL     = CT_CVAL ).
    else.
***   Add Gate as Cluster
      ME->ADD_AS_CLUSTER( exporting IR_GATE     = IR_GATE
                          importing EF_NETOBJID = EF_OBJID
                          changing  CT_CLSTR    = CT_CLSTR
                                    CT_CVAL     = CT_CVAL ).

      if IF_OBJID_PARENT is supplied.
***     Link Child cluster to Parent cluster
        insert initial line into table CT_CVAL assigning <S_CVAL>.
        move: IF_OBJID_PARENT to <S_CVAL>-ID,
              C_FL_CLSTR      to <S_CVAL>-FL,
              EF_OBJID        to <S_CVAL>-VAL.
      endif.
    endif.

*** Remove old Node of Component
    read table ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> with key R_GATE = IR_GATE.
    if SY-SUBRC is initial.
      clear <S_NODE_BUFFER>-R_GATE.
    endif.

  endmethod.
  method GET_FREE_BFILM_GATE.

    data: LT_GATE        type        /VCXI/VKSR_TT_GATE,
          LT_XCONR       type        ZVCXI_F0SS_TT_XCONR,
          LT_BPART_GATE  type        /VCXI/VKSR_TT_GATE,
          LT_HANDLE_GATE type        /VCXI/VKSR_TT_GATE,
          LT_HPART_GATE  type        /VCXI/VKSR_TT_GATE,
          LT_PARTS_GATE  type        /VCXI/VKSR_TT_GATE,
          LT_BFILM_GATE  type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE       type ref to /VCXI/CL_VKSR_GATE,
          LR_FCONI_GATE type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_BCOMP   type ref to ZCL_VCXI_FBSS_PR_BCOMP,
          LR_PR_BMAKE   type ref to ZCL_VCXI_FBSS_PR_BMAKE,
          LR_PR_BPART   type ref to ZCL_VCXI_FBSS_PR_BPART,
          LR_PR_HANDLE  type ref to ZCL_VCXI_FBSS_PR_HANDLE,
          LR_PR_BFILM   type ref to ZCL_VCXI_FBSS_PR_BFILM,
          LR_PR_FCONI   type ref to ZCL_VCXI_FFSS_PR_FCONI.

    check CR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Try to cast it as Bag Component
    try .
        move CR_GATE->R_CLSPR ?to LR_PR_BCOMP.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_BCOMP.
    endtry.
    if LR_PR_BCOMP is bound.
      move CR_GATE to LR_GATE.
    else.
      LT_GATE = CR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BCOMP=>C_IPRVT_FB_BCOMP
                                    IF_INUSE = ABAP_TRUE ).
      read table LT_GATE into LR_GATE index 1.
    endif.

    if LR_GATE is bound.
***   Search for a Bag Making
      refresh LT_GATE.
      LT_GATE = CR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BMAKE=>C_IPRVT_BMAKE
                                    IF_INUSE = ABAP_TRUE ).
      clear LR_GATE.
      read table LT_GATE into LR_GATE index 1.
      if LR_GATE is bound.
        move LR_GATE to CR_GATE.
      else.
***     Bag Making not in place
        return.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Try to cast it as Bag Making
    try .
        move CR_GATE->R_CLSPR ?to LR_PR_BMAKE.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_BMAKE.
    endtry.
    if LR_PR_BMAKE is bound.
***   Search for a Bag Part or Handle
      refresh: LT_BPART_GATE, LT_HANDLE_GATE.
      LT_BPART_GATE = CR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BPART=>C_IPRVT_BPART
                                          IF_INUSE = ABAP_TRUE
                                          IF_SORTED = ABAP_TRUE ).
      append lines of LT_BPART_GATE to LT_PARTS_GATE.

      LT_HANDLE_GATE = CR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HANDLE=>C_IPRVT_HANDLE
                                           IF_INUSE = ABAP_TRUE
                                           IF_SORTED = ABAP_TRUE ).

      loop at LT_HANDLE_GATE into LR_GATE.
        refresh LT_HPART_GATE.
        LT_HPART_GATE = LR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HPART=>C_IPRVT_HPART
                                            IF_INUSE = ABAP_TRUE
                                            IF_SORTED = ABAP_TRUE ).
        check LINES( LT_HPART_GATE ) is not initial.
        append lines of LT_HPART_GATE to LT_PARTS_GATE.
      endloop.

      clear CR_GATE.
    endif.

***--------------------------------------------------------------------------------------
*** Try to cast it as Bag Part
    if CR_GATE is bound.
      try .
          move CR_GATE->R_CLSPR ?to LR_PR_BPART.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_BPART.
      endtry.
      if LR_PR_BPART is bound.
***     Add Gate as a Bag Part Gate
        append CR_GATE to LT_PARTS_GATE.
        clear CR_GATE.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Try to cast it as Handle
    if CR_GATE is bound.
      try .
          move CR_GATE->R_CLSPR ?to LR_PR_HANDLE.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_HANDLE.
      endtry.
      if LR_PR_HANDLE is bound.
***     Search for the available Handle Parts
        LT_HPART_GATE = CR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HPART=>C_IPRVT_HPART
                                            IF_INUSE = ABAP_TRUE
                                            IF_SORTED = ABAP_TRUE ).
        check LINES( LT_HPART_GATE ) is not initial.

***     Add Gates as a Handle Parts Gate
        append lines of LT_HPART_GATE to LT_PARTS_GATE.

        clear LR_PR_HANDLE.
        clear CR_GATE.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Get current Connections
    if ME->R_PR_SOV is bound.
      LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).
    endif.

    if LINES( LT_PARTS_GATE ) is not initial.
***--------------------------------------------------------------------------------------
***   Search for the available Bag Films
      loop at LT_PARTS_GATE into LR_GATE.
        refresh: LT_GATE.
        LT_GATE = LR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BFILM=>C_IPRVT_BFILM
                                      IF_INUSE = ABAP_TRUE
                                      IF_SORTED = ABAP_TRUE ).

        check LINES( LT_GATE ) is not initial.
        append lines of LT_GATE to LT_BFILM_GATE.
      endloop.

    else.
      if CR_GATE is bound.
***     Try to cast it as Film Connection In
        try .
            move CR_GATE->R_CLSPR ?to LR_PR_FCONI.
          catch CX_SY_MOVE_CAST_ERROR.
            clear LR_PR_FCONI.
        endtry.
        if LR_PR_FCONI is bound.
***       Check if Bag Connection In is linked to a Connection Out
          read table LT_XCONR with key R_GATE_IN = CR_GATE transporting no fields.
          if SY-SUBRC is initial.
            clear CR_GATE.
          endif.
          return.
        endif.

***     Try to cast it as Bag Film
        try .
            move CR_GATE->R_CLSPR ?to LR_PR_BFILM.
          catch CX_SY_MOVE_CAST_ERROR.
            clear LR_PR_BFILM.
        endtry.
        if LR_PR_BFILM is bound.
***       Add the Bag Film to the table for later check
          append CR_GATE to LT_BFILM_GATE.
          clear CR_GATE.
        endif.
      endif.
    endif.

*** Search for the free Bag Films
    loop at LT_BFILM_GATE into LR_GATE.

***   If the Bag Film is not linked to any MS Film Procurement
      refresh LT_GATE.
      LT_GATE = LR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FFSS_PR_MS_FPROC=>C_IPRVT_MS_FPROC
                                    IF_INUSE = ABAP_TRUE ).
      check LINES( LT_GATE ) is initial.

***   If the Bag Film is not linked to any MS Estimation Material
      refresh LT_GATE.
      LT_GATE = LR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FFSS_PR_MS_EMAT=>C_IPRVT_MS_EMAT
                                    IF_INUSE = ABAP_TRUE ).
      check LINES( LT_GATE ) is initial.

***   Get Film Connection In Gates
      LT_GATE = LR_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FFSS_PR_FCONI=>C_IPRVT_FF_FCONI
                                    IF_INUSE = ABAP_TRUE ).
      clear LR_FCONI_GATE.
      read table LT_GATE into LR_FCONI_GATE index 1.
      if LR_FCONI_GATE is bound.
***     Check if Bag Connection In is linked to a Connection Out
        read table LT_XCONR with key R_GATE_IN = LR_FCONI_GATE transporting no fields.
        check SY-SUBRC is not initial.

***     If Film Connection In is not linked to any Connection Out
        move LR_FCONI_GATE to CR_GATE.
        return.
      else.
***     Return the Bag Film Gate because is free
        move LR_GATE to CR_GATE.
        return.
      endif.

    endloop.

  endmethod.
  method GET_GRAPHIC_CHANGES.

    data: LF_OBJID_XCLST  type NETOBJID.
    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_LINE_BUFFER  type YS_LINE_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER.
    data: LT_GATE_XCOMP type /VCXI/VKSR_TT_GATE,
          LT_SEQUENCE   type ZCL_VCXI_F0SS_PR_SPEC=>YT_SEQUENCE.
    data: LR_GATE_XCOMP type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_SPEC    type ref to ZCL_VCXI_F0SS_PR_SPEC.
    field-symbols: <S_DELETION>     type NET_DELETE,
                   <S_NODE_BUFFER>  type YS_NODE_BUFFER,
                   <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER.


***--------------------------------------------------------------------------------------
*** Get all Components
    LT_GATE_XCOMP = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_XCOMP=>C_IPRVT_XCOMP
                                           IF_INUSE = ABAP_TRUE ).

    loop at LT_GATE_XCOMP into LR_GATE_XCOMP.
***--------------------------------------------------------------------------------------
***   Get Specification Gate
      move ME->GET_PR_SPEC( LR_GATE_XCOMP ) to LR_PR_SPEC.
      check LR_PR_SPEC is bound.

***   Get sequence of Gates inside the Specification
      LT_SEQUENCE = LR_PR_SPEC->GET_SEQUENCE( ).

***   Re-order the Sequence of gates in order to include Bag Parts, Handles
      ME->REORDER_SEQUENCE( changing CT_SEQUENCE = LT_SEQUENCE ).

***   If Component Node is expanded add it to Cluster Table
      if ME->IS_EXPANDED( IR_GATE = LR_GATE_XCOMP ) eq ABAP_TRUE.
***     Get Cluster (add and link if needed)
        ME->GET_CLUSTER( exporting IR_GATE  = LR_GATE_XCOMP
                         importing EF_OBJID = LF_OBJID_XCLST
                         changing  CT_CVAL  = ET_CVAL
                                   CT_CLSTR = ET_CLSTR ).

***     Fill Bag Component Cluster
        ME->FILL_CLUSTER_BCOMP( exporting IR_GATE_BCOMP = LR_GATE_XCOMP
                                          IF_OBJID      = LF_OBJID_XCLST
                                          IT_SEQUENCE   = LT_SEQUENCE
                                changing  CT_CVAL       = ET_CVAL
                                          CT_CLSTR      = ET_CLSTR
                                          CT_LINE       = ET_LINE
                                          CT_LVAL       = ET_LVAL
                                          CT_NODE       = ET_NODE
                                          CT_NVAL       = ET_NVAL ).

      else.
***     Check if Component is a new Node
        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER with key R_GATE = LR_GATE_XCOMP.
        if SY-SUBRC is initial.
          ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
                           changing  CT_NVAL     = ET_NVAL ).
        else.
***       Add Component as Node
          ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_XCOMP
                           changing  CT_NODE     = ET_NODE
                                     CT_NVAL     = ET_NVAL ).
        endif.

***--------------------------------------------------------------------------------------
***     Remove old Cluster of Component
        loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> where R_GATE eq LR_GATE_XCOMP or
                                                                    R_GATE is not bound.
          clear <S_CLSTR_BUFFER>-R_GATE.
          loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> where CLSTR_ID eq <S_CLSTR_BUFFER>-NETOBJID.
            clear <S_NODE_BUFFER>-R_GATE.
          endloop.
        endloop.

      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify deleted Nodes
    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
      check LS_NODE_BUFFER-R_GATE is not bound or
            LS_NODE_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
      move LS_NODE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_NODE_BUFFER.
    endloop.

****--------------------------------------------------------------------------------------
**** Set Connections between Film Components
    ME->SET_CONNECTIONS( changing CT_LINE = ET_LINE
                                  CT_LVAL = ET_LVAL
                                  CT_DELETION = ET_DELETION ).

***--------------------------------------------------------------------------------------
*** Identify Deleted Clusters
    loop at ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER.
      check LS_CLSTR_BUFFER-R_GATE is not bound or
            LS_CLSTR_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_CLSTR             to <S_DELETION>-OBJ_TYPE.
      move LS_CLSTR_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_CLSTR_BUFFER.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify Deleted Lines
    loop at ME->T_LINE_BUFFER into LS_LINE_BUFFER where FIX eq ABAP_UNDEFINED.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_LINE             to <S_DELETION>-OBJ_TYPE.
      move LS_LINE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove from Buffer
      delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
    endloop.

  endmethod.
  method GET_PARENT_CLUSTER.

    data: LF_SCOPU        type /VCXI/CKX_SCOPU.
    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER.

    loop at ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER where R_GATE is bound and
                                                          NETOBJID eq IF_OBJID.
      do IF_PARENT_LVL times.
        add 1 to LF_SCOPU.

        check IR_GATE->IS_IN_SCOPE( IF_SCOPU = LF_SCOPU
                                    IR_GATE  = LS_CLSTR_BUFFER-R_GATE ) eq ABAP_TRUE.

        move LS_CLSTR_BUFFER-NETOBJID to RF_CLUSTER.
        if RF_CLUSTER is not initial.
          exit.
        endif.
      enddo.
    endloop.

  endmethod.
  method GET_PR_SPEC.

    data: LT_GATE_SPEC type        /VCXI/VKSR_TT_GATE,
          LR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE.

    LT_GATE_SPEC = IR_GATE_XCOMP->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_SPEC=>C_IPRVT_F0_SPEC
                                             IF_INUSE = ABAP_TRUE ).

    read table LT_GATE_SPEC into LR_GATE_SPEC index 1.
    check LR_GATE_SPEC is bound.

    try .
        move LR_GATE_SPEC->R_CLSPR ?to RR_PR_SPEC.
      catch CX_SY_MOVE_CAST_ERROR.
        clear RR_PR_SPEC.
    endtry.

  endmethod.
  method GET_PREV_CORR.

    data: LS_SEQUENCE type ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.

    loop at IT_SEQUENCE into LS_SEQUENCE.
      read table LS_SEQUENCE-T_GATE_NEXT with key TABLE_LINE = IR_GATE
                                         transporting no fields.
      check SY-SUBRC is initial.

      move LS_SEQUENCE-T_GATE_PREV[] to RT_GATE_PREV[].
      exit.
    endloop.

  endmethod.
  method GET_ROOT_CLUSTER.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER.

    loop at ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER where R_GATE is bound.

      check LS_CLSTR_BUFFER-R_GATE->IS_IN_LINE( IR_GATE ) eq ABAP_TRUE.

      read table IT_CVAL with key FL = C_FL_CLSTR
                                  VAL = LS_CLSTR_BUFFER-NETOBJID transporting no fields.
      check SY-SUBRC is not initial.
      move LS_CLSTR_BUFFER-NETOBJID to RF_CLUSTER.
    endloop.

  endmethod.
  method GET_UPPER_NODE.

    data: LF_SCOPU       type /VCXI/CKX_SCOPU.
    data: LS_NODE_BUFFER type YS_NODE_BUFFER.

*** Always FCONI will Scope Up 2/3 - BPART/HANDLE
    LF_SCOPU = 1.
    do 3 times.
      add 1 to LF_SCOPU.

      loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER where R_GATE is bound.
        check IR_GATE->IS_IN_SCOPE( IF_SCOPU = LF_SCOPU
                                    IR_GATE  = LS_NODE_BUFFER-R_GATE ) eq ABAP_TRUE.

        check ME->IS_EXPANDED( IR_GATE = LS_NODE_BUFFER-R_GATE ) ne ABAP_TRUE.

        move LS_NODE_BUFFER-R_GATE to RR_GATE.
        exit.
      endloop.

      if RR_GATE is bound.
        exit.
      endif.
    enddo.

  endmethod.
  method GET_XCONI_BY_NODEID.

    data: LR_GATE  type ref to /VCXI/CL_VKSR_GATE,
          LR_ANCHI type ref to ZIF_VCXI_F0SS_ANCHI.

***--------------------------------------------------------------------------------------
*** Get Gate of Node
    move ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID ) to LR_GATE.

*** Get available Free Bag Film Gate
    ME->GET_FREE_BFILM_GATE( changing CR_GATE = LR_GATE ).
    check LR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Check if gate is an anchorage for connection in
    try.
        move LR_GATE->R_CLSPR ?to LR_ANCHI.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_ANCHI.
    endtry.

    check LR_ANCHI is bound.

*** Creat new X-Connector
    RR_GATE = LR_ANCHI->ADD_XCON( ).

  endmethod.
  method GET_XCONO_BY_NODEID.

    data: LS_LINE_BUFFER type YS_LINE_BUFFER.
    data: LR_GATE     type ref to /VCXI/CL_VKSR_GATE,
          LR_ANCHO    type ref to ZIF_VCXI_F0SS_ANCHO,
          LR_PR_FCONO type ref to ZCL_VCXI_FFSS_PR_FCONO.

***--------------------------------------------------------------------------------------
*** Get Gate of Node
    move ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID ) to LR_GATE.

*** Check if Film Connection Out is not already used
    try .
        move LR_GATE->R_CLSPR ?to LR_PR_FCONO.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_PR_FCONO.
    endtry.
    if LR_PR_FCONO is bound.
      read table ME->T_LINE_BUFFER into LS_LINE_BUFFER with key R_GATE_OUT = LR_GATE.
      if LS_LINE_BUFFER-R_GATE_IN is bound.
***     When FCONO is already linked to another node => return
        clear LR_GATE.
        return.
      endif.
    endif.

*** Get Connection Gate
*    ME->CHECK_BMAKE_GATE( changing CR_GATE = LR_GATE ).
    check LR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Check if gate is an anchorage for connection out
    try.
        move LR_GATE->R_CLSPR ?to LR_ANCHO.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_ANCHO.
    endtry.

    check LR_ANCHO is bound.

*** Creat new X-Connector
    RR_GATE = LR_ANCHO->ADD_XCON( ).

  endmethod.
  method HANDLE_UC_COLLAPSE.

    data: LF_SCOPD        type /VCXI/CKX_SCOPD.
    data: LS_CLSTR        type CNG_CLUSTR,
          LS_NODES        type CNG_NODES,
          LS_NODE_BUFFER  type YS_NODE_BUFFER,
          LS_CLSTR_BUFFER type YS_CLSTR_BUFFER.
    data: LR_PARENT type ref to /VCXI/CL_VKSR_GATE,
          LR_TEMP   type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER.


***--------------------------------------------------------------------------------------
*** Check whether all or only one selected Cluster should be collapsed
    if LINES( IT_NODE ) is not initial.
***   Get Gate for Cluster
      loop at IT_NODE into LS_NODES.
        clear LR_PARENT.

        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER with key NETOBJID = LS_NODES-ID.
        check LS_NODE_BUFFER-R_GATE is bound.

        read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER with key NETOBJID = LS_NODE_BUFFER-CLSTR_ID.
        move LS_CLSTR_BUFFER-R_GATE to LR_PARENT.

        if LR_PARENT is bound.
          do 4 times.
            add 1 to LF_SCOPD.
            loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> where R_GATE is bound and
                                                                        NETOBJID ne LS_CLSTR_BUFFER-NETOBJID.

              check LR_PARENT->IS_IN_SCOPE( IF_SCOPD = LF_SCOPD
                                            IR_GATE = <S_CLSTR_BUFFER>-R_GATE ) eq ABAP_TRUE.

              ME->SET_COLLAPSE( IF_OBJID = <S_CLSTR_BUFFER>-NETOBJID ).
              move <S_CLSTR_BUFFER>-R_GATE to LR_TEMP.
              clear: <S_CLSTR_BUFFER>-R_GATE.
            endloop.

            if LR_TEMP is bound.
              move LR_TEMP to LR_PARENT.
              clear LF_SCOPD.
            endif.
          enddo.
        endif.

***     Set Collapse Gate
        ME->SET_COLLAPSE( IR_GATE = LS_CLSTR_BUFFER-R_GATE ).
      endloop.

    elseif LINES( IT_CLSTR ) is not initial.

      loop at IT_CLSTR into LS_CLSTR.

        read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER with key NETOBJID = LS_CLSTR-ID.
        move LS_CLSTR_BUFFER-R_GATE to LR_PARENT.
        if LR_PARENT is bound.

          do 4 times.
            add 1 to LF_SCOPD.
            loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER> where R_GATE is bound and
                                                                        NETOBJID ne LS_CLSTR-ID.

              check LR_PARENT->IS_IN_SCOPE( IF_SCOPD = LF_SCOPD
                                            IR_GATE = <S_CLSTR_BUFFER>-R_GATE ) eq ABAP_TRUE.

              ME->SET_COLLAPSE( IF_OBJID = <S_CLSTR_BUFFER>-NETOBJID ).
              move <S_CLSTR_BUFFER>-R_GATE to LR_TEMP.
              clear: <S_CLSTR_BUFFER>-R_GATE.
            endloop.

            if LR_TEMP is bound.
              move LR_TEMP to LR_PARENT.
              clear LF_SCOPD.
            endif.
          enddo.

        endif.

***     Set Collapse Gate
        ME->SET_COLLAPSE( IF_OBJID = LS_CLSTR-ID ).
      endloop.

    else.
***   Collapse all Clusters
      loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
***     Set Collapse Gate
        ME->SET_COLLAPSE( IF_OBJID = <S_CLSTR_BUFFER>-NETOBJID ).
        clear <S_CLSTR_BUFFER>-R_GATE.
      endloop.

    endif.

***--------------------------------------------------------------------------------------
*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_CONNECT.

    data: LS_LINE  type CNG_LINES,
          LS_XCONR type ZVCXI_F0SS_S_XCONR.
    data: LT_XCONR      type ZVCXI_F0SS_TT_XCONR,
          LT_SPEC_XCONR type ZVCXI_F0SS_TT_XCONR,
          LT_GATE_NEXT  type /VCXI/VKSR_TT_GATE,
          LT_GATE_TEMP  type /VCXI/VKSR_TT_GATE.
    data: LR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCONI type ref to /VCXI/CL_VKSR_GATE.
    data: LR_GATE_CURR_SPEC type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_NEXT_SPEC type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_XCONR> type ZVCXI_F0SS_S_XCONR.


***--------------------------------------------------------------------------------------
*** Get current Connections
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

***--------------------------------------------------------------------------------------
*** Get Specification linkage relationships
    loop at LT_XCONR into LS_XCONR.
      insert initial line into table LT_SPEC_XCONR assigning <S_XCONR>.
      move ME->GET_SPEC_GATE( LS_XCONR-R_GATE_IN ) to <S_XCONR>-R_GATE_IN.
      move ME->GET_SPEC_GATE( LS_XCONR-R_GATE_OUT ) to <S_XCONR>-R_GATE_OUT.
    endloop.

*** Add new Connections
    loop at IT_LINE into LS_LINE.
***--------------------------------------------------------------------------------------
***   Get Outbound Connect
      move ME->GET_XCONO_BY_NODEID( IF_NETOBJID = LS_LINE-PRE ) to LR_GATE_XCONO.
      check LR_GATE_XCONO is bound.

***--------------------------------------------------------------------------------------
***   Get Inbound Connect
      move ME->GET_XCONI_BY_NODEID( exporting IF_NETOBJID = LS_LINE-SUC ) to LR_GATE_XCONI.

      if LR_GATE_XCONI is not bound.
***     Free the Connection Out Gate so it does not get shown
        LR_GATE_XCONO->DO_FREE( ).
        continue.
      endif.

***   Check if it`s an Allowed Connection
      if ME->CHECK_ALLOWED_CONNECTION( exporting IR_GATE_XCONI = LR_GATE_XCONI
                                                 IR_GATE_XCONO = LR_GATE_XCONO ) ne ABAP_TRUE.
        if LR_GATE_XCONI is bound.
          LR_GATE_XCONI->DO_FREE( ).
        endif.

        if LR_GATE_XCONO is bound.
          LR_GATE_XCONO->DO_FREE( ).
        endif.

        continue.
      endif.

***--------------------------------------------------------------------------------------
***   Get Current Spec Gate
      move ME->GET_SPEC_GATE( LR_GATE_XCONO ) to LR_GATE_CURR_SPEC.

***   Get Next Spec Gate
      move ME->GET_SPEC_GATE( LR_GATE_XCONI ) to LR_GATE_NEXT_SPEC.
      append LR_GATE_NEXT_SPEC  to LT_GATE_NEXT.

      do .
***     If Next Specification is the same with the starting point Specification
        loop at LT_GATE_NEXT into LR_GATE_NEXT_SPEC where TABLE_LINE eq LR_GATE_CURR_SPEC.
***       Clean up unnecessary created connections
          LR_GATE_XCONI->DO_FREE( ).
          LR_GATE_XCONO->DO_FREE( ).
          return.
        endloop.

***     Keep searching for a connection
        loop at LT_SPEC_XCONR into LS_XCONR.
          loop at LT_GATE_NEXT into LR_GATE_NEXT_SPEC where TABLE_LINE eq LS_XCONR-R_GATE_OUT.
            append LS_XCONR-R_GATE_IN to LT_GATE_TEMP.
          endloop.
        endloop.
        if LINES( LT_GATE_TEMP ) is initial.
          exit.
        else.
          move LT_GATE_TEMP[] to LT_GATE_NEXT[].
          refresh LT_GATE_TEMP.
        endif.
      enddo.

***--------------------------------------------------------------------------------------
***   Add Connection
      append initial line to LT_XCONR assigning <S_XCONR>.
      move LR_GATE_XCONO to <S_XCONR>-R_GATE_OUT.
      move LR_GATE_XCONI to <S_XCONR>-R_GATE_IN.
    endloop.

***--------------------------------------------------------------------------------------
*** Send to backend
    ME->R_PR_SOV->SET_XCONR( IT_XCONR = LT_XCONR ).

*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_INSERT.

    data:  LS_NODE   type        CNG_NODES.

    SUPER->HANDLE_UC_INSERT( IT_NODE = IT_NODE ).

***--------------------------------------------------------------------------------------
    read table IT_NODE into LS_NODE index 1.

    case LS_NODE-SELID.
      when C_INODE_BCOMP.
***     Add Bag Component
        ME->ADD_BCOMP( ).
      when C_INODE_MONO.
***     Add Mono
        ME->ADD_MONO( ).
      when C_INODE_DUPLEX.
***     Add Duplex
        ME->ADD_DUPLEX( ).
    endcase.

***--------------------------------------------------------------------------------------
*** Raise Events
    ME->R_GATE->RAISE_EVENTS( ).

  endmethod.
  method INIT_INODES.

    field-symbols: <S_INODE> type        CNG_INODES,
                   <S_NVAL>  type        NET_NVALS.

    SUPER->INIT_INODES( ).

***--------------------------------------------------------------------------------------
*** Only add Items if in change mode
    check ME->R_GATE->IS_LOCKED( ) eq ABAP_TRUE.

***--------------------------------------------------------------------------------------
*** Add Bag Component Cluster
    append initial line to ME->T_INODE assigning <S_INODE>.
    <S_INODE>-ID   = C_INODE_BCOMP.
    <S_INODE>-TYPE = 7.

*** Description
    append initial line to ME->T_INVAL assigning <S_NVAL>.
    <S_NVAL>-ID    = <S_INODE>-ID.
    <S_NVAL>-FL    = '0'.
    <S_NVAL>-VAL   = text-D01.

***--------------------------------------------------------------------------------------
*** Add Mono Cluster
    append initial line to ME->T_INODE assigning <S_INODE>.
    <S_INODE>-ID   = C_INODE_MONO.
    <S_INODE>-TYPE = 7.

*** Description
    append initial line to ME->T_INVAL assigning <S_NVAL>.
    <S_NVAL>-ID    = <S_INODE>-ID.
    <S_NVAL>-FL    = '0'.
    <S_NVAL>-VAL   = text-D02.

***--------------------------------------------------------------------------------------
*** Add Duplex Cluster
    append initial line to ME->T_INODE assigning <S_INODE>.
    <S_INODE>-ID   = C_INODE_DUPLEX.
    <S_INODE>-TYPE = 8.

*** Description
    append initial line to ME->T_INVAL assigning <S_NVAL>.
    <S_NVAL>-ID    = <S_INODE>-ID.
    <S_NVAL>-FL    = '0'.
    <S_NVAL>-VAL   = text-D03.

  endmethod.
  method IS_INLINE.

    data: LS_NODE_BUFFER type YS_NODE_BUFFER.

    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
***   Check if the Gate is inline with a Film Component
      check LS_NODE_BUFFER-R_GATE->IS_IN_LINE( IR_GATE = CR_GATE ) eq ABAP_TRUE.

***   Get the upper uncollapsed Node
      move ME->GET_UPPER_NODE( CR_GATE ) to CR_GATE.
      if CR_GATE is bound.
        exit.
      endif.

      move LS_NODE_BUFFER-R_GATE to CR_GATE.
      exit.
    endloop.

  endmethod.
  method LOOKUP_BMAKE_GATE.

    data: LS_SEQUENCE  type ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.
    data: LR_GATE_NEXT type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_BMAKE  type ref to ZCL_VCXI_FBSS_PR_BMAKE.

    loop at IT_SEQUENCE into LS_SEQUENCE.
      loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
        try .
            move LR_GATE_NEXT->R_CLSPR ?to LR_PR_BMAKE.
          catch CX_SY_MOVE_CAST_ERROR.
            continue.
        endtry.
        check LR_PR_BMAKE is bound.

***     Pass the Bag Making Node Gate
        move LR_GATE_NEXT to RR_GATE_BMAKE.

        return.
      endloop.
    endloop.

  endmethod.
  method REORDER_SEQUENCE.

    data: LF_INDEX           type        SYINDEX.
    data: LS_SEQUENCE        type        ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.
    data: LT_GATE_BPART      type        /VCXI/VKSR_TT_GATE,
          LT_GATE_HANDLE     type        /VCXI/VKSR_TT_GATE,
          LT_GATE_MS_HPART_P type        /VCXI/VKSR_TT_GATE,
          LT_GATE_HPART      type        /VCXI/VKSR_TT_GATE,
          LT_GATE_BFILM      type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_BPART      type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_HANDLE     type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_MS_HPART_P type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_HPART      type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_BFILM      type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_BMAKE        type ref to ZCL_VCXI_FBSS_PR_BMAKE ##NEEDED,
          LR_PR_HANDLE       type ref to ZCL_VCXI_FBSS_PR_HANDLE,
          LR_GATE_NEXT       type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_SEQUENCE>     type      ZCL_VCXI_F0SS_PR_SPEC=>YS_SEQUENCE.

    loop at CT_SEQUENCE into LS_SEQUENCE.

      loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
***     Check if there is a Bag Making in place
        try.
            move LR_GATE_NEXT->R_CLSPR ?to LR_PR_BMAKE.
          catch CX_SY_MOVE_CAST_ERROR.
            clear LR_PR_BMAKE.
            continue.
        endtry.

        check LR_GATE_NEXT is bound.

        refresh: LT_GATE_BPART, LT_GATE_HANDLE, LT_GATE_HPART.
***     PR Bag Make found -> Find Bag Parts
        LT_GATE_BPART = LR_GATE_NEXT->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BPART=>C_IPRVT_BPART
                                                 IF_INUSE = ABAP_TRUE ).

***     PR Bag Make found -> Find Handles
        LT_GATE_HANDLE = LR_GATE_NEXT->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HANDLE=>C_IPRVT_HANDLE
                                                  IF_INUSE = ABAP_TRUE ).

        refresh LT_GATE_BFILM.
        loop at LT_GATE_BPART into LR_GATE_BPART.
          clear LF_INDEX.

***       Add the link between Bag Part and Bag Making
          insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
          append LR_GATE_BPART  to <S_SEQUENCE>-T_GATE_NEXT.

          if ME->IS_EXPANDED( IR_GATE = LR_GATE_NEXT ) eq ABAP_TRUE.
***         Search for the corresponding Gate in Prev Gate sequence
            <S_SEQUENCE>-T_GATE_PREV = ME->GET_PREV_CORR( exporting IR_GATE = LR_GATE_NEXT
                                                                    IT_SEQUENCE = CT_SEQUENCE ).
          else.
            append LR_GATE_NEXT to <S_SEQUENCE>-T_GATE_PREV.
          endif.


***       Get Bag Film Gates
          LT_GATE_BFILM = LR_GATE_BPART->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BFILM=>C_IPRVT_BFILM
                                                    IF_INUSE = ABAP_TRUE ).
***       If there are Bag Films available
          loop at LT_GATE_BFILM into LR_GATE_BFILM.
            clear LF_INDEX.

***         Search the Bag Film in Prev Gate sequence
            LF_INDEX = ME->BFILM_EXIST( exporting IR_GATE_BFILM = LR_GATE_BFILM
                                                  IT_SEQUENCE   = CT_SEQUENCE ).
            check LF_INDEX is not initial.

***         Add the link between Bag Film and Bag Part
            insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
            append LR_GATE_BFILM to <S_SEQUENCE>-T_GATE_NEXT.

            if ME->IS_EXPANDED( IR_GATE = LR_GATE_BPART ) eq ABAP_TRUE.
***           If Bag Part is expanded => Find the corresponding Prev Gate Sequence
              <S_SEQUENCE>-T_GATE_PREV = ME->GET_PREV_CORR( exporting IR_GATE = LR_GATE_BPART
                                                                      IT_SEQUENCE = CT_SEQUENCE ).
            else.
              append LR_GATE_BPART to <S_SEQUENCE>-T_GATE_PREV.
            endif.

***         Delete the Bag Film only if there is not attached to anything
            read table CT_SEQUENCE into LS_SEQUENCE index LF_INDEX.
            if SY-SUBRC is initial.
              if LINES( LS_SEQUENCE-T_GATE_NEXT ) is initial.
                delete CT_SEQUENCE index LF_INDEX.
              endif.
            endif.
          endloop.
        endloop.

***     If Handles are available
        loop at LT_GATE_HANDLE into LR_GATE_HANDLE.
***       Check if there is a Handle is in place
          try.
              move LR_GATE_HANDLE->R_CLSPR ?to LR_PR_HANDLE.
            catch CX_SY_MOVE_CAST_ERROR.
              clear LR_PR_HANDLE.
              continue.
          endtry.

          check LR_PR_HANDLE is bound.

***--------------------------------------------------------------------------------------
***       PR Handle found -> Find MS Handles (PC)
          LT_GATE_MS_HPART_P = LR_GATE_HANDLE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_MS_HPART_P=>C_IPRVT_MS_HPART_P
                                                          IF_INUSE = ABAP_TRUE ).

***       Add the link between Handle and Bag Making
          insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
          append LR_GATE_HANDLE to <S_SEQUENCE>-T_GATE_NEXT.

          if ME->IS_EXPANDED( IR_GATE = LR_GATE_NEXT ) eq ABAP_TRUE.
***         Search for the corresponding Gate in Prev Gate sequence
            <S_SEQUENCE>-T_GATE_PREV = ME->GET_PREV_CORR( exporting IR_GATE = LR_GATE_NEXT
                                                                    IT_SEQUENCE = CT_SEQUENCE ).
          else.
            append LR_GATE_NEXT to <S_SEQUENCE>-T_GATE_PREV.
          endif.

          loop at LT_GATE_MS_HPART_P into LR_GATE_MS_HPART_P.
***         Add the link between Handle Part (PC) and Handle
            insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
            append LR_GATE_MS_HPART_P to <S_SEQUENCE>-T_GATE_NEXT.

            if ME->IS_EXPANDED( IR_GATE = LR_GATE_HANDLE ) eq ABAP_TRUE.
              <S_SEQUENCE>-T_GATE_PREV = ME->GET_PREV_CORR( exporting IR_GATE = LR_GATE_HANDLE
                                                                      IT_SEQUENCE = CT_SEQUENCE ).
            else.
              append LR_GATE_HANDLE to <S_SEQUENCE>-T_GATE_PREV.
            endif.
          endloop.

***--------------------------------------------------------------------------------------
***       PR Handle found -> Find Handles (Length)
          LT_GATE_HPART = LR_GATE_HANDLE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_HPART=>C_IPRVT_HPART
                                                     IF_INUSE = ABAP_TRUE ).
          refresh LT_GATE_BFILM.
          loop at LT_GATE_HPART into LR_GATE_HPART.
            LT_GATE_BFILM = LR_GATE_HPART->GET_PRVDR( IF_IPRVT = ZCL_VCXI_FBSS_PR_BFILM=>C_IPRVT_BFILM
                                                      IF_INUSE = ABAP_TRUE ).

***         Add the link between Handle Part and Handle
            insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
            append LR_GATE_HPART      to <S_SEQUENCE>-T_GATE_NEXT.

            if ME->IS_EXPANDED( IR_GATE = LR_GATE_HANDLE ) eq ABAP_TRUE.
              <S_SEQUENCE>-T_GATE_PREV = ME->GET_PREV_CORR( exporting IR_GATE = LR_GATE_HANDLE
                                                                      IT_SEQUENCE = CT_SEQUENCE ).
            else.
              append LR_GATE_HANDLE to <S_SEQUENCE>-T_GATE_PREV.
            endif.

***         If there are Bag Films available
            loop at LT_GATE_BFILM into LR_GATE_BFILM.
              clear LF_INDEX.

***           Search the Bag Film in Prev Gate sequence
              LF_INDEX =  ME->BFILM_EXIST( exporting IR_GATE_BFILM = LR_GATE_BFILM
                                                     IT_SEQUENCE   = CT_SEQUENCE ).
              check LF_INDEX is not initial.

***           Add the link between Bag Film and Handle Part
              insert initial line into table CT_SEQUENCE assigning <S_SEQUENCE>.
              append LR_GATE_BFILM to <S_SEQUENCE>-T_GATE_NEXT.
              append LR_GATE_HPART to <S_SEQUENCE>-T_GATE_PREV.

***           Delete the Bag Film only if there is not attached to anything
              read table CT_SEQUENCE into LS_SEQUENCE index LF_INDEX.
              if SY-SUBRC is initial.
                if LINES( LS_SEQUENCE-T_GATE_NEXT ) is initial.
                  delete CT_SEQUENCE index LF_INDEX.
                endif.
              endif.
            endloop.

          endloop.
        endloop.
      endloop.
    endloop.

  endmethod.
  method SET_COLLAPSE.

    data: LF_OBJID     type NETOBJID.
    data: LS_CLSTR_BUF type YS_CLSTR_BUFFER.
    data: LR_ND        type ref to ZCL_VCXI_F0SS_ND.

    if IR_GATE is supplied and IR_GATE is bound.
***   Get Object ID
      read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUF with key R_GATE = IR_GATE.
      check SY-SUBRC is initial.
      move LS_CLSTR_BUF-NETOBJID to LF_OBJID.
    endif.

    if IF_OBJID is supplied.
      move IF_OBJID to LF_OBJID.
    endif.

*** Get ND instance
    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
                                            IR_GATE   = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LF_OBJID ) ).
    check LR_ND is bound.

*** Set Expand Value
    LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).

  endmethod.
  method SET_CONNECTIONS.

    data:           LS_XCONR          type  ZVCXI_F0SS_S_XCONR,
                    LS_LINE_BUFFER    type  YS_LINE_BUFFER.
    data:           LT_XCONR          type  ZVCXI_F0SS_TT_XCONR,
                    LT_LINE_BUFFER    type  YT_LINE_BUFFER.
    field-symbols:  <S_DELETION>      type  NET_DELETE.

***--------------------------------------------------------------------------------------
*** Get Connections between Film Components
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

    move ME->T_LINE_BUFFER to LT_LINE_BUFFER.
    delete LT_LINE_BUFFER where FIX eq ABAP_TRUE.

*** Delete Connections with missing Gate
    delete LT_XCONR where R_GATE_OUT is not bound.
    delete LT_XCONR where R_GATE_IN  is not bound.

***--------------------------------------------------------------------------------------
*** Complete Re-Build of the lines
    loop at LT_XCONR into LS_XCONR.

***--------------------------------------------------------------------------------------
***   If the Gate is not found in any Buffer check if belongs to a Film Component
      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_OUT ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_OUT ).
      endif.

      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_IN ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_IN ).
      endif.

***   Read info from Line Buffer table with the new gates (possible Film component)
      read table LT_LINE_BUFFER  with key R_GATE_OUT = LS_XCONR-R_GATE_OUT
                                          R_GATE_IN  = LS_XCONR-R_GATE_IN transporting no fields.
      if SY-SUBRC is initial.
        delete LT_LINE_BUFFER index SY-TABIX.
      else.
***     Add Line
        ME->ADD_AS_LINE( exporting IR_GATE_OUT = LS_XCONR-R_GATE_OUT
                                   IR_GATE_IN  = LS_XCONR-R_GATE_IN
                                   IF_FIX      = ABAP_FALSE
                         changing  CT_LINE     = CT_LINE
                                   CT_LVAL     = CT_LVAL ).
      endif.
    endloop.

*** Special case for deleting the lines when Cluster is seen as Node
    if ME->F_ABAP_CMD eq C_UC_DELETE.
***   Identify deleted Lines
      loop at LT_LINE_BUFFER into LS_LINE_BUFFER.

**      If node is not set to be freed
        check LS_LINE_BUFFER-R_GATE_IN->F_FREED is initial and
              LS_LINE_BUFFER-R_GATE_OUT->F_FREED is initial.

***     Only in the case when clusters are nodes
        check ME->IS_EXPANDED( IR_GATE = LS_LINE_BUFFER-R_GATE_IN ) ne ABAP_TRUE.
        check ME->IS_EXPANDED( IR_GATE = LS_LINE_BUFFER-R_GATE_OUT ) ne ABAP_TRUE.

***     Mark for Deletion
        append initial line to CT_DELETION assigning <S_DELETION>.
        move C_OBJTY_LINE            to <S_DELETION>-OBJ_TYPE.
        move LS_LINE_BUFFER-NETOBJID to <S_DELETION>-ID.

***     Remove from Buffer
        delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
      endloop.
    endif.

  endmethod.
