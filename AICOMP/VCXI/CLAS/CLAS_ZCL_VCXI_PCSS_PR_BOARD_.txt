
class ZCL_VCXI_PCSS_PR_BOARD definition
  public
  inheriting from /VCXI/CL_VKSR_CLSPR
  create public .

public section.

  interfaces ZIF_VCXI_P0SS_CALIP .
  interfaces ZIF_VCXI_P0SS_SUTYP .
  interfaces ZIF_VCXI_P0SS_WEIGHT .

  aliases C_IPRVT_P0_SUTYP
    for ZIF_VCXI_P0SS_SUTYP~C_IPRVT_P0_SUTYP .
  aliases GET_SUTYP
    for ZIF_VCXI_P0SS_SUTYP~GET_SUTYP .

  constants C_ATTID_TBOAR_LAMI_RTS type /VCXI/VKS_ATTID value 'VALID_BOARD_TYPES_LAMI_RTS' ##NO_TEXT.
  constants C_ATTID_VALID_TBOAR type /VCXI/VKS_ATTID value 'VALID_BOARD_TYPES' ##NO_TEXT.
  constants C_IEVNT_O_BOARD_CHANGED type /VCXI/VKSC_IEVNT value 'BOARD_CHANGED' ##NO_TEXT.
  constants C_IPRVT_PC_BOARD type /VCXI/VKSC_IPRVT value 'ZVCXI_PCSS_BOARD' ##NO_TEXT.
  constants C_MBOAR_P type ZVCXI_PCSS_MBOAR value 'P' ##NO_TEXT.
  constants C_MBOAR_S type ZVCXI_PCSS_MBOAR value 'S' ##NO_TEXT.
  constants C_PARID_ARBPL type /VCXI/VKS_PARID value 'ZVCXI_XC_ARBPL' ##NO_TEXT.
  constants C_PARID_BOARS type /VCXI/VKS_PARID value 'ZVCXI_PC_BOARS' ##NO_TEXT.
  constants C_PARID_CALIP type /VCXI/VKS_PARID value 'ZVCXI_P0_CALIP' ##NO_TEXT.
  constants C_PARID_FLUTE type /VCXI/VKS_PARID value 'ZVCXI_PC_FLUTE' ##NO_TEXT.
  constants C_PARID_MBOAR type /VCXI/VKS_PARID value 'ZVCXI_PC_MBOAR' ##NO_TEXT.
  constants C_PARID_SELFD type /VCXI/VKS_PARID value 'ZVCXI_PC_SELFD' ##NO_TEXT.
  constants C_PARID_STARC type /VCXI/VKS_PARID value 'ZVCXI_PC_STARC' ##NO_TEXT.
  constants C_PARID_WDRYA type /VCXI/VKS_PARID value 'ZVCXI_P0_WDRYA' ##NO_TEXT.
  constants C_PARID_WDRYW type /VCXI/VKS_PARID value 'ZVCXI_P0_WDRYW' ##NO_TEXT.
  constants C_PARID_WWETA type /VCXI/VKS_PARID value 'ZVCXI_P0_WWETA' ##NO_TEXT.
  constants C_PARID_WWETW type /VCXI/VKS_PARID value 'ZVCXI_P0_WWETW' ##NO_TEXT.

  methods GET_FENDL
    returning
      value(RF_FENDL) type ZVCXI_PCS_FENDL
    raising
      /VCXI/CX_CKX .
  methods IS_TLAMI_RTS_ALLOWED
    returning
      value(RF_RETURN) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_TLAMI
    returning
      value(RF_TLAMI) type ZVCXI_P0SS_TLAMI
    raising
      /VCXI/CX_CKX .
  methods IS_PREPR_ACTIVE
    returning
      value(RF_ACTIVE) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_PRPRP_STR
    returning
      value(RT_PRPRP_STR) type ZVCXI_PCSS_TT_PRPRP_STR
    raising
      /VCXI/CX_CKX .
  methods GET_BOARD_PAPER_STR
    returning
      value(RT_BOARD_PAPER_STR) type ZVCXI_PCSS_TT_BOARD_PAPER_STR
    raising
      /VCXI/CX_CKX .
  methods GET_VALID_TBOAR
    returning
      value(RF_VALID_TBOAR) type STRING
    raising
      /VCXI/CX_CKX .
  methods GET_LIMIT_SIDRU
    exporting
      !ES_SIDRU_MIN type ZVCXI_P0SS_S_SIDRU
      !ES_SIDRU_MAX type ZVCXI_P0SS_S_SIDRU
    raising
      /VCXI/CX_CKX .
  methods GET_COWID
    returning
      value(RT_COWID) type ZVCXI_PCS_TT_COWID
    raising
      /VCXI/CX_CKX .
  methods CONSTRUCTOR
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods DO_FREE
    raising
      /VCXI/CX_CKX .
  methods GET_ARBPL
    returning
      value(RF_ARBPL) type ARBPL
    raising
      /VCXI/CX_CKX .
  methods GET_DCONF
    returning
      value(RF_DCONF) type DATS
    raising
      /VCXI/CX_CKX .
  methods GET_BOARD
    returning
      value(RF_BOARD) type ZVCXI_PCS_BOARD
    raising
      /VCXI/CX_CKX .
  methods GET_BOARD_DESCR
    returning
      value(RT_BOARD_DESCR) type ZVCXI_PCSS_TT_BOARD_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_BOARS
    returning
      value(RF_BOARS) type ZVCXI_PCSS_BOARS
    raising
      /VCXI/CX_CKX .
  methods GET_BOARS_DESCR
    returning
      value(RF_BOARS_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_CALIP
    returning
      value(RS_CALIP) type ZVCXI_P0SS_S_CALIP
    raising
      /VCXI/CX_CKX .
  methods GET_CLASS_VALUE
    returning
      value(RT_CLASS_VALUE) type ZVCXI_PCSS_TT_CLASS_VALUE
    raising
      /VCXI/CX_CKX .
  methods GET_CLASS_VALUE_C
    returning
      value(RT_CLASS_VALUE_C) type ZVCXI_PCSS_TT_CLASS_VALUE_C
    raising
      /VCXI/CX_CKX .
  methods GET_FLUTE
    returning
      value(RF_FLUTE) type ZVCXI_PCS_FLUTE
    raising
      /VCXI/CX_CKX .
  methods GET_FLUTE_DESCR
    returning
      value(RF_FLUTE_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_MBOAR
    returning
      value(RF_MBOAR) type ZVCXI_PCSS_MBOAR
    raising
      /VCXI/CX_CKX .
  methods GET_SELFD
    exporting
      value(EF_SELFD) type ZVCXI_PCSS_SELFD
      value(EF_SETBY) type /VCXI/VKSR_SETBY
    raising
      /VCXI/CX_CKX .
  methods GET_STARC
    returning
      value(RF_STARC) type ZVCXI_PCSS_STARC
    raising
      /VCXI/CX_CKX .
  methods GET_STARC_DESCR
    returning
      value(RF_STARC_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_WDRYA
    returning
      value(RS_WDRYA) type ZVCXI_P0SS_S_WDRYA
    raising
      /VCXI/CX_CKX .
  methods GET_WDRYW
    returning
      value(RS_WDRYW) type ZVCXI_P0SS_S_WDRYW
    raising
      /VCXI/CX_CKX .
  methods GET_WWETA
    returning
      value(RS_WWETA) type ZVCXI_P0SS_S_WWETA
    raising
      /VCXI/CX_CKX .
  methods GET_WWETW
    returning
      value(RS_WWETW) type ZVCXI_P0SS_S_WWETW
    raising
      /VCXI/CX_CKX .
  methods SET_ARBPL
    importing
      !IF_ARBPL type ARBPL
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_BOARD
    importing
      !IF_BOARD type ZVCXI_PCS_BOARD
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_BOARS
    importing
      !IF_BOARS type ZVCXI_PCSS_BOARS
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_MBOAR
    importing
      !IF_MBOAR type ZVCXI_PCSS_MBOAR
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_SELFD
    importing
      !IF_SELFD type ZVCXI_PCSS_SELFD
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods IS_ACTIVE_BOARD
    returning
      value(RF_ACTIVE) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_CUST_NSTBG
    returning
      value(RF_NSTBG) type ZVCXI_PCSS_SELFD
    raising
      /VCXI/CX_CKX .
  methods GET_WERKS
    returning
      value(RF_WERKS) type WERKS_D
    raising
      /VCXI/CX_CKX .

  methods GET_DESCR
    redefinition .
  methods GET_STATUS
    redefinition .
  methods GET_STATUS_MSG
    redefinition .
  methods HANDLE_EVENT
    redefinition .
protected section.

  aliases C_IEVNT_O_SUTYP_CHANGED
    for ZIF_VCXI_P0SS_SUTYP~C_IEVNT_O_SUTYP_CHANGED .

  constants C_ATTID_CLASS type /VCXI/VKS_ATTID value 'CLASSIFICATION' ##NO_TEXT.
  constants C_ATTID_DESCR type /VCXI/VKS_ATTID value 'DESCRIPTION' ##NO_TEXT.
  constants C_IEVNT_I_INIT_CUST_BOARD type /VCXI/VKSC_IEVNT value 'INIT_CUST_BOARD' ##NO_TEXT.
  constants C_IEVNT_I_RECALC_CALIP type /VCXI/VKSC_IEVNT value 'RECALC_CALIP' ##NO_TEXT.
  constants C_IEVNT_I_RECALC_WDRYW type /VCXI/VKSC_IEVNT value 'RECALC_WDRYW' ##NO_TEXT.
  constants C_IEVNT_I_RECALC_WWETW type /VCXI/VKSC_IEVNT value 'RECALC_WWETW' ##NO_TEXT.
  constants C_IEVNT_I_SET_DEFAULT type /VCXI/VKSC_IEVNT value 'SET_DEFAULT' ##NO_TEXT.
  constants C_IEVNT_I_UPDATE_PAPER type /VCXI/VKSC_IEVNT value 'UPDATE_PAPER' ##NO_TEXT.
  constants C_IEVNT_I_UPDATE_SELFD type /VCXI/VKSC_IEVNT value 'UPDATE_SELFD' ##NO_TEXT.
  constants C_IEVNT_I_UPDATE_STARCH type /VCXI/VKSC_IEVNT value 'UPDATE_STARCH' ##NO_TEXT.
  constants C_IEVNT_I_UPDATE_WAX type /VCXI/VKSC_IEVNT value 'UPDATE_WAX' ##NO_TEXT.
  constants C_IEVNT_O_ARBPL_CHANGED type /VCXI/VKSC_IEVNT value 'ARBPL_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_BOARD_CUST_CHANGED type /VCXI/VKSC_IEVNT value 'BOARD_CUST_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_CALIP_CHANGED type /VCXI/VKSC_IEVNT value 'CALIP_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_FLUTE_CHANGED type /VCXI/VKSC_IEVNT value 'FLUTE_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_SELFD_CHANGED type /VCXI/VKSC_IEVNT value 'SELFD_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_WDRYW_CHANGED type /VCXI/VKSC_IEVNT value 'WDRYW_CHANGED' ##NO_TEXT.
  constants C_IEVNT_O_WWETW_CHANGED type /VCXI/VKSC_IEVNT value 'WWETW_CHANGED' ##NO_TEXT.
  constants C_ILTYP_DP_CORRTRIM type /VCXI/VSMC_ILTYP value 'PC_LT_DP_CORRTRIM' ##NO_TEXT.
  constants C_WA_1M2 type ZVCXI_P0SS_WWETA value 1 ##NO_TEXT.
  constants C_WA_1M2_UOM type UNIT value 'M2' ##NO_TEXT.
  data F_RENEW_PAPER type ABAP_BOOL .
  data F_TBOAR_LAMI_RTS type STRING .
  data F_VALID_TBOAR type STRING .
  data R_CUST_BOARD type ref to ZCL_VCXI_PCSS_CUST_BOARD .
  data T_BOARD_DESCR type ZVCXI_PCSS_TT_BOARD_DESCR .
  data T_CLASS_VALUE type ZVCXI_PCSS_TT_CLASS_VALUE .
  data T_CLASS_VALUE_C type ZVCXI_PCSS_TT_CLASS_VALUE_C .

  methods CHECK_TOOL_VALUES
    importing
      !IR_MESSAGE type ref to /VCXI/CL_CKXM_MESSAGE optional
    preferred parameter IR_MESSAGE
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods GET_TOOL
    returning
      value(RR_DIECUT_TOOL) type ref to ZCL_VCXI_XCS_CUST_MATNR
    raising
      /VCXI/CX_CKX .
  methods GET_BOARW
    returning
      value(RS_BOARW) type ZVCXI_PCSS_S_BOARW
    raising
      /VCXI/CX_CKX .
  methods INIT_DESCR_CLASS
    raising
      /VCXI/CX_CKX .
  methods CHECK_BOARD
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_FTBOA
    returning
      value(RF_SUBRC) type I
    raising
      /VCXI/CX_CKX .
  methods GET_MS_PAPERS
    importing
      !IF_SORTED type ABAP_BOOL default ABAP_FALSE
    returning
      value(RT_PAPER) type ZVCXI_PCSS_TT_MS_PAPER
    raising
      /VCXI/CX_CKX .
  methods GET_MS_STARCH
    returning
      value(RR_PR_STARCH) type ref to ZCL_VCXI_PCSS_PR_MS_STARCH
    raising
      /VCXI/CX_CKX .
  methods GET_MS_WAX
    returning
      value(RR_PR_WAX) type ref to ZCL_VCXI_PCSS_PR_MS_WAX
    raising
      /VCXI/CX_CKX .
  methods HANDLE_SET_DEFAULT
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UPDATE_SELFD
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_CUST_BOARD
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RECALC_CALIP
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RECALC_WDRYW
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RECALC_WWETW
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UPDATE_PAPER
    importing
      !IT_GATE type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UPDATE_STARCH
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UPDATE_WAX
    raising
      /VCXI/CX_CKX .
  methods SET_CALIP
    importing
      !IS_CALIP type ZVCXI_P0SS_S_CALIP
    raising
      /VCXI/CX_CKX .
  methods SET_FLUTE
    importing
      !IF_FLUTE type ZVCXI_PCS_FLUTE
    raising
      /VCXI/CX_CKX .
  methods SET_WDRYA
    importing
      !IS_WDRYA type ZVCXI_P0SS_S_WDRYA
    raising
      /VCXI/CX_CKX .
  methods SET_WDRYW
    importing
      !IS_WDRYW type ZVCXI_P0SS_S_WDRYW
    raising
      /VCXI/CX_CKX .
  methods SET_WWETA
    importing
      !IS_WWETA type ZVCXI_P0SS_S_WWETA
    raising
      /VCXI/CX_CKX .
  methods SET_WWETW
    importing
      !IS_WWETW type ZVCXI_P0SS_S_WWETW
    raising
      /VCXI/CX_CKX .
  methods CHECK_WERKS_ARBPL
    returning
      value(RF_SUBRC) type SY-SUBRC
    raising
      /VCXI/CX_CKX .
private section.

  methods INIT_ATTRI
    raising
      /VCXI/CX_CKX .
endclass. "ZCL_VCXI_PCSS_PR_BOARD definition
class ZCL_VCXI_PCSS_PR_BOARD implementation.
method CHECK_BOARD.

*** 0 = Board ID is maintained and valid
*** 1 = Board ID is maintained and not valid
*** 2 = Board ID has wrong Mode
*** 3 = Board ID is not valid and has wrong Mode
*** 4 = Board ID is not maintained
*** 5 = Board ID has wrong Board Type

  data: LF_BOARD       type ZVCXI_PCS_BOARD,
        LF_MBOAR       type ZVCXI_PCSS_MBOAR,
        LF_DCONF       type DATS,
        LF_VALID_TBOAR type STRING.

  LF_BOARD       = ME->GET_BOARD( ).
  LF_VALID_TBOAR = ME->GET_VALID_TBOAR( ).

  if LF_BOARD is initial.
    move 4 to RF_SUBRC.
    exit.
  endif.

  LF_DCONF = ME->GET_DCONF( ).
  LF_MBOAR = ME->GET_MBOAR( ).

  if ME->R_CUST_BOARD is bound.
    if     ME->R_CUST_BOARD->F_VALFR le LF_DCONF and
           ME->R_CUST_BOARD->F_VALTO ge LF_DCONF and
           ME->R_CUST_BOARD->F_MBOAR eq LF_MBOAR.
      move 0 to RF_SUBRC.

***   Make enhanced check of Board Type if needed.
      if LF_VALID_TBOAR is not initial and
         ME->R_CUST_BOARD->F_TBOAR na LF_VALID_TBOAR.
        move 5 to RF_SUBRC.
      endif.

    elseif ( ME->R_CUST_BOARD->F_VALFR gt LF_DCONF or
             ME->R_CUST_BOARD->F_VALTO lt LF_DCONF ) and
             ME->R_CUST_BOARD->F_MBOAR eq LF_MBOAR.
      move 1 to RF_SUBRC.
    elseif ME->R_CUST_BOARD->F_VALFR le LF_DCONF and
           ME->R_CUST_BOARD->F_VALTO ge LF_DCONF and
           ME->R_CUST_BOARD->F_MBOAR ne LF_MBOAR.
      move 2 to RF_SUBRC.
    elseif ( ME->R_CUST_BOARD->F_VALFR gt LF_DCONF or
             ME->R_CUST_BOARD->F_VALTO lt LF_DCONF ) and
             ME->R_CUST_BOARD->F_MBOAR ne LF_MBOAR.
      move 3 to RF_SUBRC.
    endif.
  else.
    move 1 to RF_SUBRC.
  endif.

endmethod.
method CHECK_FTBOA.

*** 0 Used Board ID is no Test Board Grade.
*** 1 Used Board ID is Test Board Grade.
*** 9 Board can't be a TestBoardID.

*** Board Mode is not Sales -> no TestBoardID
  if ME->GET_MBOAR( ) eq ZCL_VCXI_PCSSC_BOARD_G=>C_MBOAR_PROD.
    move 9 to RF_SUBRC.
    exit.
  endif.

*** Start positive
  move 0 to RF_SUBRC.

  if ME->R_CUST_BOARD->F_FTBOA eq ABAP_TRUE.
    move 1 to RF_SUBRC.
    exit.
  endif.

endmethod.
method CHECK_TOOL_VALUES.

  data:  LF_PARID        type        /VCXI/VKS_PARID,
         LF_CHECK        type        CHAR30,
         LF_INVALID      type        ABAP_BOOL,
         LF_MSGV1        type        SYMSGV.
  data:  LR_DIECUT_TOOL  type ref to ZCL_VCXI_XCS_CUST_MATNR.
  data:  LS_MAPSET       type        ZVCXI_XCS_S_MAPSET,
         LS_SETVA        type        /VCXI/CKXC_S_SETVA,
         LS_MAPVC        type        /VCXI/CKXC_S_MAPVC,
         LS_PARAM        type        /VCXI/VKSR_S_PARAM,
         LS_MAPVN        type        /VCXI/CKXC_S_MAPVN,
         LS_FUNCT        type        ZVCXI_XCDC_S_CR_FUNCT.
  data:  LT_SETID        type        ZVCXI_XCS_TT_SETID,
         LT_FUNCT        type        ZVCXI_XCDC_TT_CR_FUNCT.

*** Start Positiv
  RF_RETURN = 0.

*** Get Active Checks
  LT_FUNCT = ZCL_VCXI_XCDR_SERVICE=>GET_ACTIVE_FUNCTION( IR_GATE = ME->R_GATE ).

*** Check that we have someting to do
  check LT_FUNCT is not initial.

*** Get Tool
  LR_DIECUT_TOOL = ME->GET_TOOL( ).

*** Load Mapset of Die Cut Tool
  check LR_DIECUT_TOOL is bound.
  append ZCL_VCXI_PCSS_PR_SHEET=>C_SETID_PC_DCTO to LT_SETID.
  LR_DIECUT_TOOL->GET_MAPSET( IT_SETID = LT_SETID ).

*** Get Die Cut Tool Mapping Mapping
  read table LR_DIECUT_TOOL->T_MAPSET into LS_MAPSET with key SETID = ZCL_VCXI_PCSS_PR_SHEET=>C_SETID_PC_DCTO.
  check SY-SUBRC = 0.

*** Split check and get Parameter
  loop at LT_FUNCT into LS_FUNCT.
    clear: LF_INVALID.
    split LS_FUNCT-IFUNC at '@' into LF_CHECK LF_PARID.
    check LF_CHECK eq ZCL_VCXI_P0SS_PR_SHEET=>C_CHECK_TOOL and
          LF_PARID is not initial.


    clear: LS_PARAM, LF_MSGV1.
    try.
        LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = LF_PARID ).
      catch /VCXI/CX_CKX.
        clear: LS_PARAM.
    endtry.

*** Compare values
    read table LS_MAPSET-T_SETVA into LS_SETVA with key MAPID = LF_PARID.
    if SY-SUBRC = 0.

      move LS_SETVA-ATBEZ to LF_MSGV1.
***   Get the right Value
      if LS_SETVA-T_MAPVC is not initial.
        read table LS_SETVA-T_MAPVC into LS_MAPVC index 1.
        if LS_MAPVC-VAMAP ne LS_PARAM-ATWRT.
          move ABAP_TRUE to LF_INVALID.
        endif.

      elseif LS_SETVA-T_MAPVN is not initial.
        read table LS_SETVA-T_MAPVN into LS_MAPVN index 1.
***     Try Unit Conversion if we have a different one
        if LS_MAPVN-ATFLV_UOM ne LS_PARAM-UNIT.
          try.
              ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_UNIT( exporting IF_UOM_OUT   = LS_PARAM-UNIT
                                                                 IF_UOM_IN    = LS_MAPVN-ATFLV_UOM
                                                                 IF_VALUE_IN  = LS_MAPVN-ATFLV
                                                       importing EF_VALUE_OUT = LS_MAPVN-ATFLV ).
            catch /VCXI/CX_CKX.
              continue.
          endtry.
        endif.
        if LS_MAPVN-ATFLV ne LS_PARAM-ATFLV.
          move ABAP_TRUE to LF_INVALID.
        endif.
      endif.
    endif.

    if LF_INVALID eq ABAP_TRUE.
      move 1 to RF_RETURN.
      if IR_MESSAGE is supplied.
***     Value &1 do not match Tool Classification.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                                 IF_MSGTY = 'E'
                                 IF_MSGNO = '701'
                                 IF_MSGV1 = LF_MSGV1 ).
      else.
        exit.
      endif.
    else.
      if IR_MESSAGE is supplied.
***     Value &1 do match Tool Classification.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                                 IF_MSGTY = 'S'
                                 IF_MSGNO = '702'
                                 IF_MSGV1 = LF_MSGV1 ).
      endif.
    endif.

  endloop.

endmethod.
method CHECK_WERKS_ARBPL.

  data:  LF_WERKS type WERKS_D,
         LF_ARBPL type ARBPL,
         LF_COUNT type I.

  LF_WERKS = ME->GET_WERKS( ).
  LF_ARBPL = ME->GET_ARBPL( ).

  if LF_ARBPL is initial.
    move 1 to RF_SUBRC.
  else.
*** Check Plant and Work Center Combination
    select count(*)
           into LF_COUNT
           from CRHD
          where WERKS eq LF_WERKS
           and  ARBPL eq LF_ARBPL.
    if SY-SUBRC ne 0.
      move 2 to RF_SUBRC.
    else.
      move 0 to RF_SUBRC.
    endif.
  endif.

endmethod.
method CONSTRUCTOR.

  SUPER->CONSTRUCTOR( IR_GATE = IR_GATE ).

*** Init Attributes
  ME->INIT_ATTRI( ).

endmethod.
method DO_FREE.

  ME->R_GATE->DO_FREE( ).

endmethod.
method GET_ARBPL.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_ARBPL ).
  move LS_PARAM-ATWRT to RF_ARBPL.

endmethod.
method GET_BOARD.

  data:  LS_LEOKY  type  /VCXI/VKSR_S_LEOKY.

  LS_LEOKY = ME->R_GATE->GET_LEOKY( ).

  move LS_LEOKY-LEOKY to RF_BOARD.

endmethod.
method GET_BOARD_DESCR.

*** Return of Multiple Descriptions is possible
  move ME->T_BOARD_DESCR to RT_BOARD_DESCR.

endmethod.
method GET_BOARD_PAPER_STR.

  data:          LT_MS_PAPER         type        ZVCXI_PCSS_TT_MS_PAPER.
  data:          LR_PR_PAPER         type ref to ZCL_VCXI_PCSS_PR_MS_PAPER.
  field-symbols: <S_BOARD_PAPER_STR> type        ZVCXI_PCSS_S_BOARD_PAPER_STR.

  LT_MS_PAPER = ME->GET_MS_PAPERS( IF_SORTED = ABAP_TRUE ).

*** Fill returning Structure
  loop at LT_MS_PAPER into LR_PR_PAPER.
    check LR_PR_PAPER is bound.

*** Add Paper to Returning Tabel
    append initial line to RT_BOARD_PAPER_STR assigning <S_BOARD_PAPER_STR>.
    <S_BOARD_PAPER_STR>-BPAID = LR_PR_PAPER->GET_BPAID( ).
    <S_BOARD_PAPER_STR>-SUBPA = LR_PR_PAPER->GET_SUBPA( ).

  endloop.

  sort RT_BOARD_PAPER_STR by BPAID.

endmethod.
method GET_BOARS.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_BOARS ).
  move LS_PARAM-ATWRT to RF_BOARS.

endmethod.
method GET_BOARS_DESCR.

  constants: LC_DOMNAME type                   DOMNAME value 'ZVCXI_PCSS_BOARS'.
  data:      LT_D07V    type standard table of DD07V.
  data:      LS_D07V    type                   DD07V.
  data:      LF_BOARS   type                   ZVCXI_PCSS_BOARS.

  LF_BOARS = ME->GET_BOARS( ).

*** Return Board Restricted description
  call function 'DD_DOMVALUES_GET'
    exporting
      DOMNAME   = LC_DOMNAME
      TEXT      = 'X'
      LANGU     = SY-LANGU
    tables
      DD07V_TAB = LT_D07V.

  check LT_D07V is not initial.
  read table LT_D07V with key DOMVALUE_L = LF_BOARS into LS_D07V.
  check SY-SUBRC = 0.

  RF_BOARS_DESCR = LS_D07V-DDTEXT.

endmethod.
method GET_BOARW.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_GATE_PARENT     type ref to /VCXI/CL_VKSR_GATE,
         LR_SELFD           type ref to ZIF_VCXI_PCSS_SELFD.

***------------------------------------------------------------------
*** Get Sheet Ref
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_PCSS_SELFD=>C_IPRVT_PC_SELFD
                                   IF_INUSE = ABAP_TRUE ).

***----------------------------------------------------------------------------
*** Get Selfdeckling - inline with my parent
  LR_GATE_PARENT = ME->R_GATE->GET_PARENT( ).
  loop at LT_GATE into LR_GATE.
    check LR_GATE->IS_IN_LINE( IR_GATE = LR_GATE_PARENT ) eq ABAP_TRUE.
    try.
        move LR_GATE->R_CLSPR ?to LR_SELFD.
        check LR_SELFD is bound.
        exit.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_SELFD.
    endtry.
  endloop.

  check LR_SELFD is bound.

  LR_SELFD->GET_BOARW( importing ES_BOARW = RS_BOARW ).

endmethod.
method GET_CALIP.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_CALIP ).
  move LS_PARAM-ATFLV to RS_CALIP-CALIP.
  move LS_PARAM-UNIT  to RS_CALIP-CALIP_UOM.

endmethod.
method GET_CLASS_VALUE.

*** Get all needed Values from Board Customizing
  move ME->T_CLASS_VALUE to RT_CLASS_VALUE.

endmethod.
method GET_CLASS_VALUE_C.

*** Get all needed Values from Board Customizing
  move ME->T_CLASS_VALUE_C to RT_CLASS_VALUE_C.

endmethod.
method GET_COWID.

  check ME->R_CUST_BOARD is bound.
  RT_COWID = ME->R_CUST_BOARD->GET_COWID( ).

endmethod.
  method GET_CUST_NSTBG.

    data: LT_GATE     type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE     type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_BOARD type ref to ZCL_VCXI_PCSS_PR_BOARD.


***--------------------------------------------------------------------------------------
*** Check own Customizing
    if ME->R_CUST_BOARD is bound.
      move ME->R_CUST_BOARD->F_SELFD to RF_NSTBG.
    endif.
    check RF_NSTBG ne ABAP_TRUE.

***--------------------------------------------------------------------------------------
*** Get all Boards (siblings)
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_BOARD=>C_IPRVT_PC_BOARD
                                     IF_INUSE = ABAP_TRUE ).
    loop at LT_GATE into LR_GATE.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_BOARD.
          check LR_PR_BOARD is bound.

***       Check for non-standard board grade
          if LR_PR_BOARD->R_CUST_BOARD is bound and
             LR_PR_BOARD->R_CUST_BOARD->F_SELFD eq ABAP_TRUE.
            RF_NSTBG = ABAP_TRUE.
          endif.

        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_BOARD.
      endtry.
    endloop.

  endmethod.
method GET_DCONF.

  data: LR_APPDATA type ref to /VCXI/CL_VKSR_APPDATA.

  LR_APPDATA = ME->R_GATE->GET_APPDATA( ).

  RF_DCONF =  LR_APPDATA->F_DCONF.

endmethod.
method GET_DESCR.

  if ME->GET_MBOAR( ) is not initial.
    case ME->GET_MBOAR( ).
      when C_MBOAR_S.
        move 'Board ID Sales'(001)      to RF_DESCR.
      when C_MBOAR_P.
        move 'Board ID Production'(002) to RF_DESCR.
    endcase.
  else.
    RF_DESCR = SUPER->GET_DESCR( ).
  endif.

endmethod.
  method GET_FENDL.

    RF_FENDL = ME->R_GATE->GET_ATTRI( 'FENDL' )-ATTVA.

  endmethod.
method GET_FLUTE.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_FLUTE ).
  move LS_PARAM-ATWRT to RF_FLUTE.

endmethod.
method GET_FLUTE_DESCR.

  data:      LF_FLUTE   type                   ZVCXI_PCS_FLUTE.

  LF_FLUTE = ME->GET_FLUTE( ).

*** Return Flute Description
  RF_FLUTE_DESCR = ZCL_VCXI_PCSS_CUST_BOARD=>GET_FLUTE_DESCR( IF_FLUTE = LF_FLUTE ).

endmethod.
  method GET_LIMIT_SIDRU.

    data: LF_ARBPL_GUID type        /VCXI/CKX_GUID,
          LF_ARBPL      type        ARBPL,
          LF_WERKS      type        WERKS_D,
          LF_DCONF      type        DATS,
          LF_GLTYP      type        /VCXI/VSMC_GLTYP.
    data: LS_LDIM        type        /VCXI/VSMC_S_LDIM.
    data: LT_LTYPE       type        /VCXI/CKX_TT_OBJECT.
    data: LR_RTE_ARBPL type ref to /VCXI/CL_VSMR_RTE_ARBPL,
          LR_RTE_CMACH type ref to /VCXI/CL_VSMR_RTE_CMACH,
          LR_OBJECT    type ref to /VCXI/IF_CKX_OBJECT,
          LR_ARBPL     type ref to /VCXI/CL_VSMC_ARBPL,
          LR_LTYPE     type ref to /VCXI/CL_VSMC_LTYPE.

    LF_WERKS = ME->GET_WERKS( ).
    LF_ARBPL = ME->GET_ARBPL( ).
    LF_DCONF = ME->GET_DCONF( ).

***----------------------------------------------------------------------------
*** Get Instance of Workcenter
    if LF_ARBPL is not initial.
      create object LR_RTE_ARBPL
        exporting
          IR_ARBPL = LR_ARBPL.
      LF_ARBPL_GUID = /VCXI/CL_VSMC_ARBPL=>ENCRYPT_GUID( IF_WERKS = LF_WERKS
                                                         IF_ARBPL = LF_ARBPL ).

      LR_OBJECT = /VCXI/CL_VSMC_ARBPL=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_ARBPL_GUID ).

      try.
          move LR_OBJECT ?to LR_ARBPL.
        catch CX_SY_MOVE_CAST_ERROR.
          exit.
      endtry.
    endif.

    check LR_ARBPL is bound.
***----------------------------------------------------------------------------
*** Get Customizing Instance of Workcenter
    create object LR_RTE_ARBPL
      exporting
        IR_ARBPL = LR_ARBPL
        IF_LCVAL = 'PC'.

    check LR_RTE_ARBPL is bound.

***----------------------------------------------------------------------------
*** Get Customizing Instance of Machine
    LR_RTE_CMACH = /VCXI/CL_VSMR_RTE_CMACH=>GET_INSTANCE( IR_ARBPL = LR_RTE_ARBPL->R_ARBPL
                                                          IF_DATE  = LF_DCONF
                                                          IF_LCVAL = LR_RTE_ARBPL->F_LCVAL ).
    check LR_RTE_CMACH          is bound and
          LR_RTE_CMACH->R_MTYPE is bound.

***---------------------------------------------------------------------
*** Get Maximum and Minimum Side Trim Limit
*** Get right Limit GUID
    LT_LTYPE = LR_RTE_CMACH->R_MTYPE->/VCXI/IF_VSMC_LINK_LTYPE~GET_LINKED_LTYPE( ).
    loop at LT_LTYPE into LR_OBJECT.
      try.
          move LR_OBJECT ?to LR_LTYPE.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_LTYPE.
          continue.
      endtry.

***   Get Limit PC_LT_DP_CORRTRIM of Corrugator
      check LR_LTYPE is bound and
            LR_LTYPE->/VCXI/IF_CKX_OBJECT~GET_ID( ) eq C_ILTYP_DP_CORRTRIM.

      LF_GLTYP = LR_LTYPE->/VCXI/IF_CKX_OBJECT~GET_GUID( ).

      exit.
    endloop.

*** Read Values
    check LR_RTE_CMACH->R_MGRPV_LIMIT is bound.
    read table LR_RTE_CMACH->R_MGRPV_LIMIT->T_LDIM into LS_LDIM
    with key GLDIK = LR_RTE_CMACH->R_MGRPV_LIMIT->F_GLDIK
             GLTYP = LF_GLTYP.

    check SY-SUBRC = 0.
*** Export Dimension Limits
    move LS_LDIM-LDMIN to ES_SIDRU_MIN-SIDRU.
    move LS_LDIM-LDUOM to ES_SIDRU_MIN-SIDRU_UOM.
    move LS_LDIM-LDMAX to ES_SIDRU_MAX-SIDRU.
    move LS_LDIM-LDUOM to ES_SIDRU_MAX-SIDRU_UOM.

  endmethod.
method GET_MBOAR.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_MBOAR ).
  move LS_PARAM-ATWRT to RF_MBOAR.

endmethod.
method GET_MS_PAPERS.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_PAPER        type ref to ZCL_VCXI_PCSS_PR_MS_PAPER.

***------------------------------------------------------------------
*** Get all Material Specification
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PCSS_PR_MS_PAPER=>C_IPRVT_PC_MS_PAPER
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = IF_SORTED ).

***----------------------------------------------------------------------------
*** Get Paper
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_PAPER.
        check LR_PR_PAPER is bound.

***     Add paper to Returning Tabel
        append LR_PR_PAPER to RT_PAPER.

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.


endmethod.
method GET_MS_STARCH.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------
*** Get all Material Specification
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_STARCH=>C_IPRVT_PC_MS_STARCH
                                   IF_INUSE = ABAP_TRUE ).

***----------------------------------------------------------------------------
*** Get Starch
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to RR_PR_STARCH.
      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

endmethod.
method GET_MS_WAX.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------
*** Get all Material Specification
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_WAX=>C_IPRVT_PC_MS_WAX
                                   IF_INUSE = ABAP_TRUE ).

***----------------------------------------------------------------------------
*** Get Wax
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to RR_PR_WAX.
      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

endmethod.
method GET_PRPRP_STR.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_PREPR_MGR    type ref to ZCL_VCXI_PCSS_PR_PREPR_MGR.

***------------------------------------------------------------------
*** Preprint Manager
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PCSS_PR_PREPR_MGR=>C_IPRVT_PC_PREPR_MGR
                                   IF_INUSE  = ABAP_TRUE ).

***----------------------------------------------------------------------------
*** Get Preprint
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_PREPR_MGR.
        check LR_PR_PREPR_MGR is bound.
        exit.

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

  check LR_PR_PREPR_MGR is bound.
  RT_PRPRP_STR = LR_PR_PREPR_MGR->GET_PRPRP_STR( ).

endmethod.
method GET_SELFD.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SELFD ).
  move LS_PARAM-ATWRT to EF_SELFD.
  move LS_PARAM-SETBY to EF_SETBY.

endmethod.
method GET_STARC.

  data:  LR_PR_MS_STARCH   type ref to ZCL_VCXI_PCSS_PR_MS_STARCH.

  LR_PR_MS_STARCH = ME->GET_MS_STARCH( ).
  check LR_PR_MS_STARCH is bound.

  move LR_PR_MS_STARCH->GET_STARC( ) to RF_STARC.

endmethod.
method GET_STARC_DESCR.

  data:      LF_STARC   type                   ZVCXI_PCSS_STARC.

  LF_STARC = ME->GET_STARC( ).

*** Return Starch Code description
  RF_STARC_DESCR = ZCL_VCXI_PCSS_CUST_BOARD=>GET_STARC_DESCR( IF_STARC = LF_STARC ).

endmethod.
method GET_STATUS.

  data: LS_CALIP type ZVCXI_P0SS_S_CALIP.

  RF_ELMST = SUPER->GET_STATUS( ).

***------------------------------------------------------------------
*** Check Board ID is Maintained
  if ME->CHECK_BOARD( ) eq 0.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check Board Cust loaded
  if ME->R_CUST_BOARD is bound.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check BoardID is released
  if ME->R_CUST_BOARD                 is bound and
     ME->R_CUST_BOARD->IS_RELEASED( ) eq ABAP_TRUE.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).

  elseif ME->R_CUST_BOARD                 is bound and
         ME->R_CUST_BOARD->IS_RELEASED( ) eq ABAP_FALSE.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).

  endif.

***------------------------------------------------------------------
*** Check Caliper is calculated
  LS_CALIP = ME->GET_CALIP( ).
  if LS_CALIP-CALIP is not initial.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check Flute is Maintained
  if ME->GET_FLUTE( ) is not initial.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check Starch Code is Maintained
  if ME->GET_STARC( ) is not initial.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------
*** Check Tools
  case ME->CHECK_TOOL_VALUES( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

***------------------------------------------------------------------
*** Check Workcenter
  case ME->CHECK_WERKS_ARBPL( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

  if ME->R_CUST_BOARD is bound.
***------------------------------------------------------------------
*** Check if Test Board Flag should be checked. If so, make sure no Test BG is used.
    if ZCL_VCXI_XCDR_SERVICE=>IS_FUNCTION_ACTIVE( IR_GATE  = ME->R_GATE
                                                  IF_IFUNC = 'CHECK_FTBOA' ) eq ABAP_TRUE.

      case ME->CHECK_FTBOA( ).
        when 0 or 9.
          RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                         IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
        when others.
          RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                         IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
      endcase.
    endif.
  endif.

endmethod.
method GET_STATUS_MSG.

  data: LF_WERKS   type WERKS_D,
        LF_MSGV1   type SYMSGV,
        LF_MSGTY_1 type SYMSGTY,
        LF_MSGTY_2 type SYMSGTY.
  data: LS_CALIP type ZVCXI_P0SS_S_CALIP.

  SUPER->GET_STATUS_MSG( IR_MESSAGE = IR_MESSAGE ).

***------------------------------------------------------------------
*** Check Board ID is Maintained
  case ME->CHECK_BOARD( ).
    when 0.
*** Board ID is maintained and valid
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '101' ).
    when 1.
*** Board ID is maintained and not valid
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '111' ).

    when 2.
*** Board ID has wrong Mode
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '112' ).

    when 3.
*** Board ID is not valid and has wrong Mode
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '113' ).

    when 4.
***   Board ID is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '102' ).
    when 5.
***   Board ID has wrong Board Type.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '120' ).
  endcase.

***------------------------------------------------------------------
*** Check Board Cust loaded
  if ME->R_CUST_BOARD is bound.
*** Board Customizing is loaded.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '105' ).
  else.
*** Board Customizing can't be loaded.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '106' ).
  endif.

***------------------------------------------------------------------
*** Check BoardID is released
  if ME->R_CUST_BOARD                 is bound and
     ME->R_CUST_BOARD->IS_RELEASED( ) eq ABAP_TRUE.
*** Board ID is released.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '124' ).

  elseif ME->R_CUST_BOARD                 is bound and
         ME->R_CUST_BOARD->IS_RELEASED( ) eq ABAP_FALSE.
*** Board ID is not released!
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '125' ).
  endif.

***------------------------------------------------------------------
*** Check Caliper is calculated
  LS_CALIP = ME->GET_CALIP( ).
  if LS_CALIP-CALIP is not initial.
*** Caliper is calculated.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '103' ).
  else.
*** Caliper is not calculated.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '104' ).
  endif.

***------------------------------------------------------------------
*** Check Flute is Maintained
  if ME->GET_FLUTE( ) is not initial.
*** Flute is maintained.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '107' ).
  else.
*** Flute can't be read from Board Customizing.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '108' ).
  endif.

***------------------------------------------------------------------
*** Check Starch Code is Maintained
  if ME->GET_STARC( ) is not initial.
*** Starch Code is maintained.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '109' ).
  else.
*** Starch Code can't be read from Board Customizing.
    IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '110' ).
  endif.

***----------------------------------------------------------------------------
*** Check Tool Values
  ME->CHECK_TOOL_VALUES( IR_MESSAGE = IR_MESSAGE ).

***------------------------------------------------------------------
*** Check Workcenter
  case ME->CHECK_WERKS_ARBPL( ).
    when 0.
***   Work Center is maintained and valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '115' ).
    when 1.
***   Work Center is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '116' ).
    when 2.
      LF_WERKS = ME->GET_WERKS( ).
      LF_MSGV1 = LF_WERKS.
***   Maintained Work Center and Plant &1 combination not valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '117'
                               IF_MSGV1 = LF_MSGV1 ).
  endcase.

  if ME->R_CUST_BOARD is bound.
***------------------------------------------------------------------
*** Check if Test Board Flag should be checked. If so, make sure no Test BG is used.
    if ZCL_VCXI_XCDR_SERVICE=>IS_FUNCTION_ACTIVE( IR_GATE  = ME->R_GATE
                                                  IF_IFUNC = 'CHECK_FTBOA' ) eq ABAP_TRUE.

      LF_MSGTY_1 = 'S'.
      LF_MSGTY_2 = 'E'.
    else.
***   If check is not active -> return only Info Message
      LF_MSGTY_1 = 'I'.
      LF_MSGTY_2 = 'I'.
    endif.

    case ME->CHECK_FTBOA( ).
      when 0.
***     No Test BG is used.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                                 IF_MSGTY = LF_MSGTY_1
                                 IF_MSGNO = '130' ).
      when 1.
***     A Test BG is still in use.
        IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_PCSS'
                                 IF_MSGTY = LF_MSGTY_2
                                 IF_MSGNO = '131' ).

    endcase.
  endif.

endmethod.
method GET_TLAMI.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_LAMI         type ref to ZCL_VCXI_P0SS_PR_LAMI.

***------------------------------------------------------------------------------------------------
*** Get all Lamination
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_P0SS_PR_LAMI=>C_IPRVT_P0_LAMI
                                   IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_LAMI.
        check LR_PR_LAMI is bound and
              LR_PR_LAMI->GET_TLAMI( ) eq ZCL_VCXI_P0SS_CUST_LAMI=>C_TLAMI_RTS.
        move ZCL_VCXI_P0SS_CUST_LAMI=>C_TLAMI_RTS to RF_TLAMI.
        exit.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_LAMI.
    endtry.
  endloop.

endmethod.
method GET_TOOL.

  data:  LT_PRVDR          type        /VCXI/VKSR_TT_GATE.
  data:  LR_PRVDR          type ref to /VCXI/CL_VKSR_GATE,
         LR_APPDATA        type ref to /VCXI/CL_VKSR_APPDATA,
         LR_DCT            type ref to ZIF_VCXI_P0SS_DCT.
  data:  LF_DCUTT          type        ZVCXI_P0SS_DCUTT,
         LF_WERKS          type        WERKS_D.

*** Get Application Data
  move ME->R_GATE->GET_APPDATA( ) to LR_APPDATA.
  if LR_APPDATA is bound.
    move LR_APPDATA->F_WERKS to LF_WERKS.
  endif.

*** Get DCT Provider
  LT_PRVDR = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_P0SS_DCT=>C_IPRVT_P0_DCT
                                    IF_INUSE = ABAP_TRUE ).
  read table LT_PRVDR into LR_PRVDR index 1.
  check SY-SUBRC = 0.
  try.
      move LR_PRVDR->R_CLSPR ?to LR_DCT.
    catch CX_SY_MOVE_CAST_ERROR.
      clear LR_DCT.
  endtry.

  check LR_DCT is bound.
  move LR_DCT->GET_DCUTT( ) to LF_DCUTT.

*** Get Die Cut Tool Customizing Instance
  RR_DIECUT_TOOL = ZCL_VCXI_XCS_CUST_MATNR=>GET_INSTANCE( IF_MATNR = LF_DCUTT
                                                          IF_WERKS = LF_WERKS ).

endmethod.
method GET_VALID_TBOAR.

  if ME->GET_TLAMI( ) is initial.
    RF_VALID_TBOAR = ME->F_VALID_TBOAR.
  else.
    RF_VALID_TBOAR = ME->F_TBOAR_LAMI_RTS.
  endif.

endmethod.
method GET_WDRYA.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WDRYA ).
  move LS_PARAM-ATFLV to RS_WDRYA-WDRYA.
  move LS_PARAM-UNIT  to RS_WDRYA-WDRYA_UOM.

endmethod.
method GET_WDRYW.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WDRYW ).
  move LS_PARAM-ATFLV to RS_WDRYW-WDRYW.
  move LS_PARAM-UNIT  to RS_WDRYW-WDRYW_UOM.

endmethod.
method GET_WERKS.

  data: LR_APPDATA type ref to /VCXI/CL_VKSR_APPDATA.

  LR_APPDATA = ME->R_GATE->GET_APPDATA( ).

  RF_WERKS =  LR_APPDATA->F_WERKS.

endmethod.
method GET_WWETA.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WWETA ).
  move LS_PARAM-ATFLV to RS_WWETA-WWETA.
  move LS_PARAM-UNIT  to RS_WWETA-WWETA_UOM.

endmethod.
method GET_WWETW.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WWETW ).
  move LS_PARAM-ATFLV to RS_WWETW-WWETW.
  move LS_PARAM-UNIT  to RS_WWETW-WWETW_UOM.

endmethod.
method HANDLE_EVENT.

  SUPER->HANDLE_EVENT( IF_IEVNT         = IF_IEVNT
                       IT_GATE_PROVIDER = IT_GATE_PROVIDER ).

  case IF_IEVNT.
    when C_IEVNT_I_INIT_CUST_BOARD.
      ME->HANDLE_INIT_CUST_BOARD( ).

    when C_IEVNT_I_RECALC_WDRYW.
      ME->HANDLE_RECALC_WDRYW( ).

    when C_IEVNT_I_RECALC_WWETW.
      ME->HANDLE_RECALC_WWETW( ).

    when C_IEVNT_I_RECALC_CALIP.
      ME->HANDLE_RECALC_CALIP( ).

    when C_IEVNT_I_UPDATE_PAPER.
      ME->HANDLE_UPDATE_PAPER( IT_GATE = IT_GATE_PROVIDER ).

    when C_IEVNT_I_UPDATE_STARCH.
      ME->HANDLE_UPDATE_STARCH( ).

    when C_IEVNT_I_UPDATE_WAX.
      ME->HANDLE_UPDATE_WAX( ).

    when C_IEVNT_I_SET_DEFAULT.
      ME->HANDLE_SET_DEFAULT( ).

    when C_IEVNT_I_UPDATE_SELFD.
      ME->HANDLE_UPDATE_SELFD( ).
  endcase.

endmethod.
  method HANDLE_INIT_CUST_BOARD.

    data: LF_BOARD type ZVCXI_PCS_BOARD,
          LF_WERKS type WERKS_D,
          LF_MBOAR type ZVCXI_PCSS_MBOAR,
          LF_FLUTE type ZVCXI_PCS_FLUTE,
          LF_DCONF type DATS.
    data: LS_WWETA type ZVCXI_P0SS_S_WWETA,
          LS_WDRYA type ZVCXI_P0SS_S_WDRYA.

***--------------------------------------------------------------------------------------
    LF_BOARD = ME->GET_BOARD( ).
    LF_WERKS = ME->GET_WERKS( ).
    LF_MBOAR = ME->GET_MBOAR( ).
    LF_DCONF = ME->GET_DCONF( ).

    if ME->R_CUST_BOARD          is bound    and
       ME->R_CUST_BOARD->F_BOARD eq LF_BOARD and
       ME->R_CUST_BOARD->F_MBOAR eq LF_MBOAR and
       ME->R_CUST_BOARD->F_WERKS eq LF_WERKS.
***   Everything is already loaded
      exit.
    endif.

*** Initialize Board Customizing.
    try.
        clear ME->R_CUST_BOARD.
        ME->R_CUST_BOARD = ZCL_VCXI_PCSS_CUST_BOARD=>GET_INSTANCE( IF_BOARD = LF_BOARD
                                                                   IF_MBOAR = LF_MBOAR
                                                                   IF_WERKS = LF_WERKS
                                                                   IF_DATE  = LF_DCONF ).
      catch /VCXI/CX_CKX.
***     Will be shown on Status and not via exception.
    endtry.

***--------------------------------------------------------------------------------------
*** Initialize Board Description and Class Values which are needed and Set by Attribute
    ME->INIT_DESCR_CLASS( ).

*** Set Flute
    clear: LF_FLUTE.
    if ME->R_CUST_BOARD is bound.
      move ME->R_CUST_BOARD->F_FLUTE to LF_FLUTE.
    endif.
    ME->SET_FLUTE( IF_FLUTE = LF_FLUTE ).

***--------------------------------------------------------------------------------------
*** Request soft Board Paper Refresh
    move ABAP_UNDEFINED to ME->F_RENEW_PAPER.

*** Send Event about changed Customizing
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_BOARD_CUST_CHANGED ).
*** Send Event - Surface Type Changed
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_SUTYP_CHANGED ).

***--------------------------------------------------------------------------------------
*** Set Area of Wet Weight Default to 1 M2
    LS_WWETA-WWETA     = C_WA_1M2.
    LS_WWETA-WWETA_UOM = C_WA_1M2_UOM.
    ME->SET_WWETA( IS_WWETA = LS_WWETA ).

*** Set Area of Dry Weight Default to 1 M2
    LS_WDRYA-WDRYA     = C_WA_1M2.
    LS_WDRYA-WDRYA_UOM = C_WA_1M2_UOM.
    ME->SET_WDRYA( IS_WDRYA = LS_WDRYA ).

  endmethod.
method HANDLE_RECALC_CALIP.

  data:  LF_ARBPL          type        ARBPL,
         LF_BPAID          type        ZVCXI_PCS_BPAID.
  data:  LS_CALIP_TOTAL    type        ZVCXI_P0SS_S_CALIP,
         LS_CALIP_PAPER    type        ZVCXI_P0SS_S_CALIP,
         LS_BGWHT          type        ZVCXI_PCSS_S_BGWHT,
         LS_PRPRP_STR      type        ZVCXI_PCSS_S_PRPRP_STR.
  data:  LT_MS_PAPER       type        ZVCXI_PCSS_TT_MS_PAPER,
         LT_PRPRP_STR      type        ZVCXI_PCSS_TT_PRPRP_STR.
  data:  LR_PR_MS_PAPER    type ref to ZCL_VCXI_PCSS_PR_MS_PAPER.

***----------------------------------------------------------------------------
*** Get current Value
  LS_CALIP_TOTAL = ME->GET_CALIP( ).
  clear LS_CALIP_TOTAL-CALIP.

***----------------------------------------------------------------------------
*** Get all Preprinted Papers
  LT_PRPRP_STR = ME->GET_PRPRP_STR( ).

***----------------------------------------------------------------------------
*** For all Papers add Caliper
  LT_MS_PAPER = ME->GET_MS_PAPERS( ).
  loop at LT_MS_PAPER into LR_PR_MS_PAPER.
    check LR_PR_MS_PAPER->CHECK_CUST_MATNR( ) eq ABAP_FALSE or
          ME->R_CUST_BOARD                    is not bound.
    ME->R_GATE->RAISE_EVENTS( ).
    exit.
  endloop.

  loop at LT_MS_PAPER into LR_PR_MS_PAPER.
    LF_BPAID = LR_PR_MS_PAPER->GET_BPAID( ).

    read table LT_PRPRP_STR into LS_PRPRP_STR with key BPAID = LF_BPAID.
    if SY-SUBRC = 0.
      move-corresponding  LS_PRPRP_STR to LS_CALIP_PAPER.
    else.
      LS_CALIP_PAPER = LR_PR_MS_PAPER->GET_CALIP( ).
    endif.

    ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_CALIP_PAPER-CALIP
                                                        IF_CALCV_UOM_1 = LS_CALIP_PAPER-CALIP_UOM
                                                        IF_CALCV_2     = LS_CALIP_TOTAL-CALIP
                                                        IF_CALCV_UOM_2 = LS_CALIP_TOTAL-CALIP_UOM
                                                        IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                        IF_UOM         = LS_CALIP_TOTAL-CALIP_UOM
                                              importing EF_CALCV       = LS_CALIP_TOTAL-CALIP
                                                        EF_CALCV_UOM   = LS_CALIP_TOTAL-CALIP_UOM ).
  endloop.

***----------------------------------------------------------------------------
*** Add Board Wall Height
  LF_ARBPL = ME->GET_ARBPL( ).
  if ME->R_CUST_BOARD is bound.
    LS_BGWHT = ME->R_CUST_BOARD->GET_BGWHT( IF_ARBPL = LF_ARBPL ).
  endif.
  if LS_BGWHT-BGWHT_UOM is not initial.
    ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_BGWHT-BGWHT
                                                        IF_CALCV_UOM_1 = LS_BGWHT-BGWHT_UOM
                                                        IF_CALCV_2     = LS_CALIP_TOTAL-CALIP
                                                        IF_CALCV_UOM_2 = LS_CALIP_TOTAL-CALIP_UOM
                                                        IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                        IF_UOM         = LS_CALIP_TOTAL-CALIP_UOM
                                              importing EF_CALCV       = LS_CALIP_TOTAL-CALIP
                                                        EF_CALCV_UOM   = LS_CALIP_TOTAL-CALIP_UOM ).
  else.
    clear LS_CALIP_TOTAL-CALIP.
  endif.

***----------------------------------------------------------------------------
*** Set Caliper
  ME->SET_CALIP( IS_CALIP = LS_CALIP_TOTAL ).

endmethod.
method HANDLE_RECALC_WDRYW.

  data:  LF_BPAID           type        ZVCXI_PCS_BPAID,
         LF_BPFAC           type        ZVCXI_PCSS_BPFAC.
  data:  LS_WDRYW           type        ZVCXI_P0SS_S_WDRYW,
         LS_WDRYA           type        ZVCXI_P0SS_S_WDRYA,
         LS_BAWGT           type        ZVCXI_PCS_S_BAWGT,
         LS_BAWGP           type        ZVCXI_PCS_S_BAWGP,
         LS_PRPRP_STR       type        ZVCXI_PCSS_S_PRPRP_STR.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE,
         LT_PRPRP_STR       type        ZVCXI_PCSS_TT_PRPRP_STR.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_MS_PAPER     type ref to ZCL_VCXI_PCSS_PR_MS_PAPER.



  LS_WDRYA = ME->GET_WDRYA( ).
  LS_WDRYW = ME->GET_WDRYW( ).
  clear: LS_WDRYW-WDRYW.

***----------------------------------------------------------------------------
*** Get all Preprinted Papers
  LT_PRPRP_STR = ME->GET_PRPRP_STR( ).

***----------------------------------------------------------------------------
*** Get all Paper
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_PAPER=>C_IPRVT_PC_MS_PAPER ).

*** Do Calculation
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_MS_PAPER.
        check LR_PR_MS_PAPER is bound.

        LF_BPAID = LR_PR_MS_PAPER->GET_BPAID( ).

        read table LT_PRPRP_STR into LS_PRPRP_STR with key BPAID = LF_BPAID.
        if SY-SUBRC = 0.
          move-corresponding  LS_PRPRP_STR to LS_BAWGT.
          move-corresponding  LS_PRPRP_STR to LS_BAWGP.
        else.
          LS_BAWGT = LR_PR_MS_PAPER->GET_BAWGT( ).
          LS_BAWGP = LR_PR_MS_PAPER->GET_BAWGP( ).
        endif.

***     ( Basis Weight * Area of Dry Weight / Basis Weight per ) * Paper Factor
        LF_BPFAC = LR_PR_MS_PAPER->GET_BPFAC( ).

        ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_UNIT( exporting IF_UOM_OUT   = LS_WDRYA-WDRYA_UOM
                                                           IF_UOM_IN    = LS_BAWGP-BAWGP_UOM
                                                           IF_VALUE_IN  = LS_BAWGP-BAWGP
                                                 importing EF_VALUE_OUT = LS_BAWGP-BAWGP
                                                           EF_UOM_OUT   = LS_BAWGP-BAWGP_UOM ).

        check LS_BAWGP-BAWGP     is not initial and
              LS_BAWGP-BAWGP_UOM is not initial.

        LS_WDRYW-WDRYW = LS_WDRYW-WDRYW + ( ( LS_BAWGT-BAWGT * LS_WDRYA-WDRYA / LS_BAWGP-BAWGP ) * LF_BPFAC ).

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

*** Set Dry Weight
  ME->SET_WDRYW( IS_WDRYW = LS_WDRYW ).

endmethod.
method HANDLE_RECALC_WWETW.

  data:  LS_WDRYW        type        ZVCXI_P0SS_S_WDRYW,
         LS_WWETW        type        ZVCXI_P0SS_S_WWETW,
         LS_WWETA        type        ZVCXI_P0SS_S_WWETA,
         LS_AVGCO_STARCH type        ZVCXI_XCS_S_AVGCO,
         LS_AVGCO_WAX    type        ZVCXI_XCS_S_AVGCO,
         LS_AVGCP_STARCH type        ZVCXI_XCS_S_AVGCP,
         LS_AVGCP_WAX    type        ZVCXI_XCS_S_AVGCP.
  data:  LF_STARF        type        ZVCXI_PCS_STARF,
         LF_WAXFA        type        ZVCXI_PCS_WAXFA.
  data:  LT_GATE         type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE         type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_WAX       type ref to ZCL_VCXI_PCSS_PR_MS_WAX,
         LR_PR_STARCH    type ref to ZCL_VCXI_PCSS_PR_MS_STARCH.

*** Get Dry Weight and Wet Weight Area
  LS_WDRYW = ME->GET_WDRYW( ).
  LS_WWETA = ME->GET_WWETA( ).

*** Dry -> Wet.
*** Dry Weight
  LS_WWETW-WWETW     = LS_WDRYW-WDRYW.
  LS_WWETW-WWETW_UOM = LS_WDRYW-WDRYW_UOM.

*** Get Starch Data
*** Get all Starch
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_STARCH=>C_IPRVT_PC_MS_STARCH ).

*** Do Calculation
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_STARCH.
        check LR_PR_STARCH is bound.

***     Wet Weight + [( Starch Average Consu * Area of Wet Weight / Starch Average Consu per ) * Starch Factor]
        LS_AVGCO_STARCH = LR_PR_STARCH->GET_AVGCO( ).
        LS_AVGCP_STARCH = LR_PR_STARCH->GET_AVGCP( ).
        LF_STARF        = LR_PR_STARCH->GET_STARF( ).


        ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_UNIT( exporting IF_UOM_OUT   = LS_WWETA-WWETA_UOM
                                                           IF_UOM_IN    = LS_AVGCP_STARCH-AVGCP_UOM
                                                           IF_VALUE_IN  = LS_AVGCP_STARCH-AVGCP
                                                 importing EF_VALUE_OUT = LS_AVGCP_STARCH-AVGCP
                                                           EF_UOM_OUT   = LS_AVGCP_STARCH-AVGCP_UOM ).

        check LS_AVGCP_STARCH-AVGCP     is not initial and
              LS_AVGCP_STARCH-AVGCP_UOM is not initial.


        LS_WWETW-WWETW = LS_WWETW-WWETW  + ( ( LS_AVGCO_STARCH-AVGCO * LS_WWETA-WWETA / LS_AVGCP_STARCH-AVGCP ) * LF_STARF ).

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.


*** Get Wax Data
*** Get all Starch
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_WAX=>C_IPRVT_PC_MS_WAX ).

*** Do Calculation
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_WAX.
        check LR_PR_WAX is bound.

***     Wet Weight + [( Wax Average Consu * Area of Wet Weight / Wax Average Consu per ) * Wax Factor]
        LS_AVGCO_WAX = LR_PR_WAX->GET_AVGCO( ).
        LS_AVGCP_WAX = LR_PR_WAX->GET_AVGCP( ).
        LF_WAXFA     = LR_PR_WAX->GET_WAXFA( ).

        ZCL_VCXI_XCS_SERVICE_UNIT=>CONVERT_UNIT( exporting IF_UOM_OUT   = LS_WWETA-WWETA_UOM
                                                           IF_UOM_IN    = LS_AVGCP_WAX-AVGCP_UOM
                                                           IF_VALUE_IN  = LS_AVGCP_WAX-AVGCP
                                                 importing EF_VALUE_OUT = LS_AVGCP_WAX-AVGCP
                                                           EF_UOM_OUT   = LS_AVGCP_WAX-AVGCP_UOM ).


        check LS_AVGCP_WAX-AVGCP     is not initial and
              LS_AVGCP_WAX-AVGCP_UOM is not initial.

        LS_WWETW-WWETW = LS_WWETW-WWETW  + ( ( LS_AVGCO_WAX-AVGCO * LS_WWETA-WWETA / LS_AVGCP_WAX-AVGCP ) * LF_WAXFA ).
      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

*** Set Wet Weight
  ME->SET_WWETW( IS_WWETW = LS_WWETW ).

endmethod.
method HANDLE_SET_DEFAULT.

  ZCL_VCXI_XCDR_SERVICE=>SET_DEFAULT( IR_GATE = ME->R_GATE ).

endmethod.
method HANDLE_UPDATE_PAPER.

  data: LF_ARBPL       type        ARBPL,
        LF_RENEW_ALL   type        ABAP_BOOL,
        LF_RENEW_PAPER type        ABAP_BOOL,
        LF_SELFD       type        ZVCXI_PCSS_SELFD.
  data: LS_BPAP  type        ZVCXI_PCSS_S_BPAP,
        LS_BOARW type        ZVCXI_PCSS_S_BOARW.
  data: LT_GATE_ALL type        /VCXI/VKSR_TT_GATE,
        LT_BPAP     type        ZVCXI_PCSS_TT_BPAP.
  data: LR_GATE     type ref to /VCXI/CL_VKSR_GATE,
        LR_PR_PAPER type ref to ZCL_VCXI_PCSS_PR_MS_PAPER,
        LR_SELFD    type ref to ZIF_VCXI_PCSS_SELFD.

***------------------------------------------------------------------------------------------------
*** Check if Existing Papers should be Updated or completely renewed
  loop at IT_GATE into LR_GATE.
*** Own Full-Refresh Requested
    if LR_GATE           eq ME->R_GATE and
       ME->F_RENEW_PAPER eq ABAP_TRUE.
      LF_RENEW_ALL      = ABAP_TRUE.
      ME->F_RENEW_PAPER = ABAP_FALSE.
*** Own Partial-Refresh
    elseif LR_GATE           eq ME->R_GATE and
           ME->F_RENEW_PAPER eq ABAP_UNDEFINED.
      LF_RENEW_ALL      = ABAP_UNDEFINED.
      ME->F_RENEW_PAPER = ABAP_FALSE.
    else.
***   If Event comes from Selfdeckling -> Update all
      try.
          move LR_GATE->R_CLSPR ?to LR_SELFD.
          check LR_SELFD is bound.
          LF_RENEW_ALL = ABAP_TRUE.
          clear: LR_SELFD.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_SELFD.
          continue.
      endtry.
    endif.
  endloop.

***------------------------------------------------------------------------------------------------
  if ME->R_CUST_BOARD is bound.
*** Work Center
    move ME->GET_ARBPL( ) to LF_ARBPL.

*** If we have Self-Deckeling -> Consider also Board Grade Width
    ME->GET_SELFD( importing EF_SELFD = LF_SELFD ).
    if LF_SELFD eq ABAP_TRUE.
      move ME->GET_BOARW( ) to LS_BOARW.
      move ME->R_CUST_BOARD->GET_BPAP( IF_ARBPL = LF_ARBPL
                                       IS_BOARW = LS_BOARW ) to LT_BPAP.
    else.
      move ME->R_CUST_BOARD->GET_BPAP( IF_ARBPL = LF_ARBPL ) to LT_BPAP.
    endif.
  endif.

***------------------------------------------------------------------------------------------------
*** Get All Paper and update them
  LT_GATE_ALL = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PCSS_PR_MS_PAPER=>C_IPRVT_PC_MS_PAPER
                                       IF_INUSE  = ABAP_TRUE
                                       IF_SORTED = ABAP_TRUE ).

  loop at LT_BPAP into LS_BPAP.
    read table LT_GATE_ALL into LR_GATE index 1.
    if SY-SUBRC ne 0.
      LR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = 'MS_PAPER' ).
      LF_RENEW_PAPER = ABAP_TRUE.
    endif.
    delete LT_GATE_ALL where TABLE_LINE = LR_GATE.

    move LR_GATE->R_CLSPR ?to LR_PR_PAPER.

*** Set Paper Factor
    LR_PR_PAPER->SET_BPFAC( IF_BPFAC = LS_BPAP-BPFAC ).

    if LF_RENEW_ALL ne ABAP_TRUE.
***   Check if Updtate is needed
      if LF_RENEW_PAPER eq ABAP_FALSE and
         LF_RENEW_ALL   ne ABAP_UNDEFINED.
        read table IT_GATE with key TABLE_LINE = LR_GATE
                           transporting no fields.
        check SY-SUBRC eq 0.
      endif.
      check LR_PR_PAPER->GET_SUBPA( ) eq ABAP_FALSE.
    else.
      LR_PR_PAPER->SET_SUBPA( ABAP_FALSE ).
    endif.

*** Update Paper
    LR_PR_PAPER->SET_MATNR( IF_MATNR = LS_BPAP-BPMAT ).
    LR_PR_PAPER->SET_BPAID( IF_BPAID = LS_BPAP-BPAID ).

    LF_RENEW_PAPER = ABAP_FALSE.
  endloop.

***------------------------------------------------------------------------------------------------
*** Delete all unused Papers
  loop at LT_GATE_ALL into LR_GATE.
    LR_GATE->DO_FREE( ).
    delete LT_GATE_ALL.
  endloop.

endmethod.
  method HANDLE_UPDATE_SELFD.

    data: LF_CUST_NSTBG type        ZVCXI_PCSS_SELFD,
          LF_SELFD      type        ZVCXI_PCSS_SELFD,
          LF_SETBY      type        /VCXI/VKSR_SETBY.
    data: LT_GATE            type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE         type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_PREPR_MGR type ref to ZCL_VCXI_PCSS_PR_PREPR_MGR,
          LR_PR_BOARD     type ref to ZCL_VCXI_PCSS_PR_BOARD.

***----------------------------------------------------------------------------
*** Preprint Manager
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PCSS_PR_PREPR_MGR=>C_IPRVT_PC_PREPR_MGR
                                     IF_INUSE  = ABAP_TRUE ).
*** Get Preprint
    loop at LT_GATE into LR_GATE.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_PREPR_MGR.
          check LR_PR_PREPR_MGR is bound.
          exit.
        catch CX_SY_MOVE_CAST_ERROR.
          continue.
      endtry.
    endloop.

***----------------------------------------------------------------------------
    clear: LF_SELFD, LF_SETBY.

*** Get all Boards (siblings)
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_BOARD=>C_IPRVT_PC_BOARD
                                     IF_INUSE = ABAP_TRUE ).
    loop at LT_GATE into LR_GATE.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_BOARD.
          check LR_PR_BOARD is bound.

***       Check for non-standard board grade
          if LR_PR_BOARD->R_CUST_BOARD is bound and
             LR_PR_BOARD->R_CUST_BOARD->F_SELFD eq ABAP_TRUE.
            LF_CUST_NSTBG = ABAP_TRUE.
          endif.

***       Use active Board as "Source"
          if LR_PR_BOARD->IS_ACTIVE_BOARD( ).
            LR_PR_BOARD->GET_SELFD( importing EF_SELFD = LF_SELFD
                                              EF_SETBY = LF_SETBY ).
          endif.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_BOARD.
      endtry.
    endloop.

***----------------------------------------------------------------------------
*** Set Self Deckeling
    if LF_CUST_NSTBG eq ABAP_TRUE.
      LF_SELFD = ABAP_TRUE.
      LF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
    elseif LR_PR_PREPR_MGR is bound and
           LF_SETBY        ne /VCXI/CL_VKSR_GATE=>C_SETBY_USER.
      LF_SELFD = ABAP_TRUE.
      LF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
    else.
      if LF_SETBY eq /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.
        clear LF_SELFD.
      endif.
    endif.

*** Update Selfdeckling
    ME->SET_SELFD( IF_SELFD = LF_SELFD
                   IF_SETBY = LF_SETBY ).

  endmethod.
method HANDLE_UPDATE_STARCH.

  data:  LF_ARBPL           type        ARBPL.
  data:  LS_BSTA            type        ZVCXI_PCSS_S_BSTA.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_STARCH       type ref to ZCL_VCXI_PCSS_PR_MS_STARCH.

***------------------------------------------------------------------------------------------------
  if ME->R_CUST_BOARD is bound.
*** Work Center
    move ME->GET_ARBPL( ) to LF_ARBPL.

*** Get Starch
    move ME->R_CUST_BOARD->GET_BSTA( IF_ARBPL = LF_ARBPL ) to LS_BSTA.
  endif.

***------------------------------------------------------------------------------------------------
*** Get all existing Starch
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_STARCH=>C_IPRVT_PC_MS_STARCH ).

  read table LT_GATE into LR_GATE index 1.
  if SY-SUBRC ne 0.
    LR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = 'MS_STARCH' ).
  endif.
  delete LT_GATE where TABLE_LINE eq LR_GATE.

  move LR_GATE->R_CLSPR ?to LR_PR_STARCH.

  LR_PR_STARCH->SET_MATNR( IF_MATNR = LS_BSTA-STMAT ).
  LR_PR_STARCH->SET_STARC( IF_STARC = LS_BSTA-STARC ).
  LR_PR_STARCH->SET_STARF( IF_STARF = LS_BSTA-STARF ).

***------------------------------------------------------------------------------------------------
*** Delete all unused Starch
  loop at LT_GATE into LR_GATE.
    LR_GATE->DO_FREE( ).
    delete LT_GATE.
  endloop.

endmethod.
method HANDLE_UPDATE_WAX.

  data:  LF_ARBPL           type        ARBPL.
  data:  LS_BWAX            type        ZVCXI_PCSS_S_BWAX.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE,
         LT_BWAX            type        ZVCXI_PCSS_TT_BWAX.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_WAX          type ref to ZCL_VCXI_PCSS_PR_MS_WAX.

***------------------------------------------------------------------------------------------------
  if ME->R_CUST_BOARD is bound.
*** Work Center
    move ME->GET_ARBPL( ) to LF_ARBPL.

*** Get defined Wax
    move ME->R_CUST_BOARD->GET_BWAX( IF_ARBPL = LF_ARBPL ) to LT_BWAX.
  endif.

***------------------------------------------------------------------------------------------------
*** Get all existing Wax
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PCSS_PR_MS_WAX=>C_IPRVT_PC_MS_WAX ).

  loop at LT_BWAX into LS_BWAX.
    read table LT_GATE into LR_GATE index 1.
    if SY-SUBRC ne 0.
      LR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = 'MS_WAX' ).
    endif.
    delete LT_GATE where TABLE_LINE eq LR_GATE.

    move LR_GATE->R_CLSPR ?to LR_PR_WAX.

*** Update Wax
    LR_PR_WAX->SET_MATNR( IF_MATNR = LS_BWAX-WAMAT ).
    LR_PR_WAX->SET_WAXCO( IF_WAXCO = LS_BWAX-WAXCO ).
    LR_PR_WAX->SET_WAXFA( IF_WAXFA = LS_BWAX-WAXFA ).
  endloop.

***------------------------------------------------------------------------------------------------
*** Delete all unused Wax
  loop at LT_GATE into LR_GATE.
    LR_GATE->DO_FREE( ).
    delete LT_GATE.
  endloop.

endmethod.
method INIT_ATTRI.

  data:  LS_ATTRI    type        /VCXI/VKS_S_ATTRI.
  data:  LR_CX_CKX   type ref to /VCXI/CX_CKX.

*** Get Valid Board Types via Attribute
  try.
      LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_VALID_TBOAR ).
      move LS_ATTRI-ATTVA to ME->F_VALID_TBOAR.
    catch /VCXI/CX_CKX into LR_CX_CKX.
      ME->R_GATE->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
  endtry.

*** Get Valid Board Types for Inline Lamination via Attribute
  try.
      LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_TBOAR_LAMI_RTS ).
      move LS_ATTRI-ATTVA to ME->F_TBOAR_LAMI_RTS.
    catch /VCXI/CX_CKX into LR_CX_CKX.
      ME->R_GATE->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
  endtry.

endmethod.
method INIT_DESCR_CLASS.

  data:          LS_ATTRI           type        /VCXI/VKS_S_ATTRI,
                 LS_ATTVA           type        /VCXI/CKX_STRING.
  data:          LT_ATTVA           type        /VCXI/CKX_TT_STRING.
  field-symbols: <S_CLASS_VALUE>    type        ZVCXI_PCSS_S_CLASS_VALUE,
                 <S_CLASS_VALUE_C>  type        ZVCXI_PCSS_S_CLASS_VALUE_C,
                 <S_BOARD_DESCR>    type        ZVCXI_PCSS_S_BOARD_DESCR.

  clear: ME->T_CLASS_VALUE, ME->T_CLASS_VALUE_C, ME->T_BOARD_DESCR.

***----------------------------------------------------------------------------
*** Get Classificatioin Values (by Attribute)
  try.
      LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_CLASS ).
    catch /VCXI/CX_CKX.
      clear LS_ATTRI.
  endtry.

  if LS_ATTRI is not initial.
    condense LS_ATTRI-ATTVA no-gaps.
    split LS_ATTRI-ATTVA at ',' into table LT_ATTVA.
    if LT_ATTVA is not initial.
      loop at LT_ATTVA into LS_ATTVA.
        append initial line to ME->T_CLASS_VALUE assigning <S_CLASS_VALUE>.
        move LS_ATTVA to <S_CLASS_VALUE>-ICLAT.
        append initial line to ME->T_CLASS_VALUE_C assigning <S_CLASS_VALUE_C>.
        move LS_ATTVA to <S_CLASS_VALUE_C>-ICLAT.
      endloop.
    endif.
  endif.

  if ME->R_CUST_BOARD is bound.
    ME->R_CUST_BOARD->GET_CLASS_VALUE( changing CT_CLASS_VALUE   = ME->T_CLASS_VALUE
                                                CT_CLASS_VALUE_C = ME->T_CLASS_VALUE_C ).
  endif.


***----------------------------------------------------------------------------
*** Get Board Descriptions (by Customizing)
  if ME->R_CUST_BOARD is bound.
    ME->R_CUST_BOARD->GET_BOARD_DESCR( changing CT_BOARD_DESCR = ME->T_BOARD_DESCR ).
  endif.

endmethod.
method IS_ACTIVE_BOARD.

  data:  LF_ICONT      type        ZVCXI_P0S_ICONT.
  data:  LT_PRVDR      type        /VCXI/VKSR_TT_GATE.
  data:  LR_PRVDR      type ref to /VCXI/CL_VKSR_GATE,
         LR_ICONT      type ref to ZIF_VCXI_P0SS_ICONT.

*** Find Context Provider
  LT_PRVDR = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_P0SS_ICONT=>C_IPRVT_P0_ICONT
                                    IF_INUSE = ABAP_TRUE ).
  read table LT_PRVDR into LR_PRVDR index 1.
  check SY-SUBRC = 0.
  try.
      move LR_PRVDR->R_CLSPR ?to LR_ICONT.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_ICONT.
  endtry.

  check LR_ICONT is bound.
  move LR_ICONT->GET_ICONT( ) to LF_ICONT.
  check LF_ICONT is not initial.

*** Check Context
  if ( LF_ICONT             eq ZCL_VCXI_P0SS_PR_SPEC=>C_ICONT_SALES and
       ME->GET_MBOAR( )     eq C_MBOAR_S                                ) or
     ( LF_ICONT             eq ZCL_VCXI_P0SS_PR_SPEC=>C_ICONT_PROD  and
       ME->GET_MBOAR( )     eq C_MBOAR_P ).
    RF_ACTIVE = ABAP_TRUE.
  endif.


endmethod.
method IS_PREPR_ACTIVE.

  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_PREPR_MGR    type ref to ZCL_VCXI_PCSS_PR_PREPR_MGR.

***------------------------------------------------------------------
*** Preprint Manager
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PCSS_PR_PREPR_MGR=>C_IPRVT_PC_PREPR_MGR
                                   IF_INUSE  = ABAP_TRUE ).

***----------------------------------------------------------------------------
*** Get Preprint
  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_PREPR_MGR.
        check LR_PR_PREPR_MGR is bound.
        exit.

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

  check LR_PR_PREPR_MGR is bound.
  RF_ACTIVE = ABAP_TRUE.

endmethod.
method IS_TLAMI_RTS_ALLOWED.

*** Is Board Type compatible with RTS
  check ME->R_CUST_BOARD is bound and
        ME->R_CUST_BOARD->F_TBOAR ca ME->F_TBOAR_LAMI_RTS.
  move ABAP_TRUE to RF_RETURN.

endmethod.
method SET_ARBPL.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_ARBPL ).

  move IF_ARBPL  to LS_PARAM-ATWRT.
  move IF_SETBY  to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_ARBPL_CHANGED ).
  endif.

endmethod.
method SET_BOARD.

  data:  LF_CHANGED  type ABAP_BOOL.
  data:  LS_LEOKY    type /VCXI/VKSR_S_LEOKY.

  move IF_BOARD to LS_LEOKY-LEOKY.
  move IF_SETBY to LS_LEOKY-SETBY.

  LF_CHANGED = ME->R_GATE->SET_LEOKY( IS_LEOKY = LS_LEOKY ).

  if LF_CHANGED eq ABAP_TRUE.
*** Renew Papers on Update Event for Papers
    ME->F_RENEW_PAPER = ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_BOARD_CHANGED ).
  endif.

endmethod.
method SET_BOARS.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_BOARS ).

  move IF_BOARS  to LS_PARAM-ATWRT.
  move IF_SETBY  to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
**** Send Event
*    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_* ).
  endif.

endmethod.
method SET_CALIP.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_CALIP ).

  move IS_CALIP-CALIP                      to LS_PARAM-ATFLV.
  move IS_CALIP-CALIP_UOM                  to LS_PARAM-UNIT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_CALIP_CHANGED ).
  endif.

endmethod.
method SET_FLUTE.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_FLUTE ).

  move IF_FLUTE                            to LS_PARAM-ATWRT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_FLUTE_CHANGED ).
  endif.

endmethod.
method SET_MBOAR.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_MBOAR ).

  move IF_MBOAR  to LS_PARAM-ATWRT.
  move IF_SETBY  to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
**** Send Event
*    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_* ).
  endif.

endmethod.
method SET_SELFD.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SELFD ).

  if IF_SELFD is not initial.
    move IF_SELFD  to LS_PARAM-ATWRT.
    move IF_SETBY  to LS_PARAM-SETBY.
  else.
    clear: LS_PARAM-ATWRT, LS_PARAM-SETBY.
  endif.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_SELFD_CHANGED ).

*** Renew Papers on Update Event for Papers
    ME->F_RENEW_PAPER = ABAP_TRUE.
  endif.

endmethod.
method SET_WDRYA.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WDRYA ).

  move IS_WDRYA-WDRYA                      to LS_PARAM-ATFLV.
  move IS_WDRYA-WDRYA_UOM                  to LS_PARAM-UNIT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_WDRYW_CHANGED ).
  endif.

endmethod.
method SET_WDRYW.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WDRYW ).

  move IS_WDRYW-WDRYW                      to LS_PARAM-ATFLV.
  move IS_WDRYW-WDRYW_UOM                  to LS_PARAM-UNIT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_WDRYW_CHANGED ).
  endif.


endmethod.
method SET_WWETA.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WWETA ).

  move IS_WWETA-WWETA                      to LS_PARAM-ATFLV.
  move IS_WWETA-WWETA_UOM                  to LS_PARAM-UNIT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_WWETW_CHANGED ).
  endif.


endmethod.
method SET_WWETW.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_WWETW ).

  move IS_WWETW-WWETW                      to LS_PARAM-ATFLV.
  move IS_WWETW-WWETW_UOM                  to LS_PARAM-UNIT.
  move /VCXI/CL_VKSR_GATE=>C_SETBY_CALC    to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_WWETW_CHANGED ).
  endif.

endmethod.
method ZIF_VCXI_P0SS_CALIP~GET_CALIP.

  data: LF_POOTI    type          ZVCXI_P0S_POOTI,
        LF_CONTINUE type          ABAP_BOOL.
  data: LT_POOTI    type table of ZVCXI_P0S_POOTI.

  split IF_POOTI at ZIF_VCXI_P0SS_CALIP~C_POOTI_SEP into table LT_POOTI.

  loop at LT_POOTI into LF_POOTI.
    condense LF_POOTI.
    check LF_POOTI eq '*'     or
          LF_POOTI eq 'BASE'.

    LF_CONTINUE = ABAP_TRUE.
    exit.
  endloop.

  check LF_CONTINUE            eq ABAP_TRUE and
        ME->IS_ACTIVE_BOARD( ) eq ABAP_TRUE.

  RS_CALIP = ME->GET_CALIP( ).

endmethod.
method ZIF_VCXI_P0SS_SUTYP~GET_SUTYP.

  data: LT_BPAP  type ZVCXI_PCSS_TT_BPAP.
  data: LS_BPAP  type ZVCXI_PCSS_S_BPAP.
  data: LF_ARBPL type ARBPL.

  LF_ARBPL = ME->GET_ARBPL( ).

*** Get Default Value for Element
  check ME->R_CUST_BOARD is bound.
  LT_BPAP = ME->R_CUST_BOARD->GET_BPAP( IF_ARBPL = LF_ARBPL ).

  loop at LT_BPAP into LS_BPAP.
    if LS_BPAP-BPAID ca 'M'.
      delete LT_BPAP.
    endif.
  endloop.

  if IF_PRSID eq ZCL_VCXI_P0SS_CUST_PRINT=>C_PRSID_INSIDE.
    sort LT_BPAP descending by BPAID.
    read table LT_BPAP index 1 into LS_BPAP.
  else.
    sort LT_BPAP ascending by BPAID.
    read table LT_BPAP index 1 into LS_BPAP.
  endif.

  if LS_BPAP-WAXCO is not initial.
    move ZCL_VCXI_P0SS_CUST_PRINT=>C_SUTYP_WAX to RF_SUTYP.
  else.
    move ZCL_VCXI_P0SS_CUST_PRINT=>C_SUTYP_NORMAL to RF_SUTYP.
  endif.

endmethod.
method ZIF_VCXI_P0SS_WEIGHT~GET_WDRYW.

  check ME->IS_ACTIVE_BOARD( ) eq ABAP_TRUE.

  ES_WDRYW = ME->GET_WDRYW( ).
  ES_WDRYA = ME->GET_WDRYA( ).

endmethod.
method ZIF_VCXI_P0SS_WEIGHT~GET_WWETW.

  check ME->IS_ACTIVE_BOARD( ) eq ABAP_TRUE.

  ES_WWETW = ME->GET_WWETW( ).
  ES_WWETA = ME->GET_WWETA( ).

endmethod.
