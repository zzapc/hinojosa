
class ZCL_VCXI_PXSR_PR_RTESPV definition
  public
  inheriting from ZCL_VCXI_XCSR_PR_RTESPV
  abstract
  create public .

public section.

  constants C_IPRVT_PX_RTESPV type /VCXI/VKSC_IPRVT value 'ZVCXI_PXSR_RTESPV' ##NO_TEXT.

  methods CONSTRUCTOR
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
      !IR_BL_RTESPV type ref to ZCL_VCXI_XCSR_BL_RTESPV optional
    raising
      /VCXI/CX_CKX .
  methods GET_EVQTY_BY_GATE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    exporting
      !EF_NOUTT type ZVCXI_PXS_NOUTT
      !EF_NOUPS type ZVCXI_PXS_NOUPS
    returning
      value(RS_EVQTY) type ZVCXI_XCSR_S_EVQTY
    raising
      /VCXI/CX_CKX .
  methods GET_IMFXC
    importing
      !IT_GATE_EXCL type /VCXI/VKSR_TT_GATE optional
    exporting
      !ET_IMFXC_IN type ZVCXI_XCSP_TT_IMFXC
      !ET_IMFXC_OUT type ZVCXI_XCSP_TT_IMFXC
    raising
      /VCXI/CX_CKX .
  methods GET_MFRAT
    returning
      value(RF_MFRAT) type ZVCXI_XCSP_MFRAT
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_RTESPV_BY_XCONO
    importing
      !IR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE
      !IF_TABIX type I optional
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
      !EF_IMFXC type ZVCXI_XCSP_IMFXC
    returning
      value(RR_PR_RTESPV) type ref to ZCL_VCXI_PXSR_PR_RTESPV
    raising
      /VCXI/CX_CKX .
  methods GET_RHNDL_IN
    importing
      !IF_IMFXC type ZVCXI_XCSP_IMFXC
    returning
      value(RS_RHNDL) type ZVCXI_PXSR_S_RHNDL
    raising
      /VCXI/CX_CKX .

  methods CREATE_BL_PRTE
    redefinition .
  methods CREATE_BL_PSTEP_MANU
    redefinition .
  methods CREATE_BL_PSTEP_OUTSO
    redefinition .
  methods EVALUATE_BL_PRTE
    redefinition .
  methods FILL_PROD
    redefinition .
  methods GET_EVQTY_BY_IMFXC
    redefinition .
  methods GET_EXQTY
    redefinition .
  methods GET_STATUS
    redefinition .
  methods HANDLE_EVENT
    redefinition .
  methods IS_FILL_PROD_ALLOWED
    redefinition .
  methods REFRESH_AUTO
    redefinition .
  methods ZIF_VCXI_XCS_NGREP~FILL
    redefinition .
protected section.

  types:
    begin of YS_BUFFER,
           R_PR_RTESPV type ref to ZCL_VCXI_PXSR_PR_RTESPV,
           R_MFMI      type ref to DATA,
         end   of YS_BUFFER .
  types:
    YT_BUFFER type standard table of YS_BUFFER .

  data F_DESERIALIZE_REQ type ABAP_BOOL .
  data I_WERKS type /VCXI/CL_VSMR_RTE_PSTEP=>YI_WERKS .
  constants C_IEVNT_I_RECALC_EVQTY_IN type /VCXI/VKSC_IEVNT value 'RECALC_EVQTY_IN' ##NO_TEXT.
  constants C_IEVNT_O_EVQTY_IN_CHANGED type /VCXI/VKSC_IEVNT value 'EVQTY_IN_CHANGED' ##NO_TEXT.
  constants C_PARID_MFRAT type /VCXI/VKS_PARID value 'ZVCXI_XC_MFRAT' ##NO_TEXT.
  constants C_IEVNT_O_MFRAT_CHANGED type /VCXI/VKSC_IEVNT value 'MFRAT_CHANGED' ##NO_TEXT.

  methods GET_IMFXC_GATE_EXCL
    returning
      value(RT_GATE) type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods CONVERT_EVQTY_FOR_XCONI
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    changing
      !CS_EVQTY type ZVCXI_XCSR_S_EVQTY
    raising
      /VCXI/CX_CKX .
  methods CREATE_BL_PSTEP
    importing
      !IF_IPSTP type C
      !IT_PRVDR type /VCXI/VKSR_TT_GATE
      !IF_COMBW type ZVCXI_PXS_COMBW optional
    returning
      value(RR_BL_PSTEP) type ref to ZCL_VCXI_PXSR_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_CSTEP
    importing
      !IR_GATE_CSTEP type ref to /VCXI/CL_VKSR_GATE
    changing
      !CT_BL_PSTEP type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_INPUT
    importing
      !IR_GATE_INPUT type ref to /VCXI/CL_VKSR_GATE
    changing
      value(CT_BL_PSTEP) type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_OUTPUT
    changing
      !CT_BL_PSTEP type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_SHIPMGR
    changing
      !CT_BL_PSTEP type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_SHIPUNIT
    importing
      !IR_GATE_SHIPMGR type ref to /VCXI/CL_VKSR_GATE
      !IT_GATE_SHIPUNIT type /VCXI/VKSR_TT_GATE
      !IF_ATTID_SHUTY type /VCXI/VKS_ATTID
      !IF_IPSTP type /VCXI/VSMC_IPSTP
      !IF_COMBW type ZVCXI_PXS_COMBW optional
    changing
      !CT_BL_PSTEP type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_BL_PSTEP_SSTEP
    importing
      !IR_GATE_SSTEP type ref to /VCXI/CL_VKSR_GATE
      !IT_PRVDR_OUT type /VCXI/VKSR_TT_GATE
    changing
      !CT_BL_PSTEP type ZVCXI_XCSR_TT_BL_PSTEP
    raising
      /VCXI/CX_CKX .
  methods GET_EVQTY_BY_FG
    importing
      !IR_GATE_FG type ref to /VCXI/CL_VKSR_GATE
    exporting
      !ES_EVQTY type ZVCXI_XCSR_S_EVQTY
      !EF_NOUTT type ZVCXI_PXS_NOUTT
      !EF_NOUPS type ZVCXI_PXS_NOUPS
    raising
      /VCXI/CX_CKX .
  methods GET_EVQTY_BY_XCONO
    importing
      !IR_GATE_XCONO type ref to /VCXI/CL_VKSR_GATE
      !IF_TABIX type I
    exporting
      !ES_EVQTY type ZVCXI_XCSR_S_EVQTY
      !EF_NOUTT type ZVCXI_PXS_NOUTT
      !EF_NOUPS type ZVCXI_PXS_NOUPS
    raising
      /VCXI/CX_CKX .
  methods GET_ICELM
  abstract
    returning
      value(RF_ICELM) type /VCXI/CKX_ID
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_CSTEP
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE optional
    returning
      value(RT_PRVDR) type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_INPUT
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
      !ET_GATE_CHILD type /VCXI/VKSR_TT_GATE
    returning
      value(RR_PR_INPUT) type ref to ZCL_VCXI_PXSS_PR_INPUT
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_OUTPUT
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
      !ET_GATE_CHILD type /VCXI/VKSR_TT_GATE
    returning
      value(RR_PR_OUTPUT) type ref to ZCL_VCXI_PXSS_PR_OUTPUT
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_SOV
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_PR_SOV) type ref to ZCL_VCXI_PXSS_PR_SOV
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_SPEC
    exporting
      !ER_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_PR_SPEC) type ref to ZCL_VCXI_PXSS_PR_SPEC
    raising
      /VCXI/CX_CKX .
  methods GET_PSCALE
    importing
      !IR_GATE_PARENT type ref to /VCXI/CL_VKSR_GATE optional
    returning
      value(RT_PSCALE) type ZVCXI_XCSR_TT_PSCALE
    raising
      /VCXI/CX_CKX .
  methods GET_RHNDL_OUT
    returning
      value(RT_RHNDL) type ZVCXI_PXSR_TT_RHNDL
    raising
      /VCXI/CX_CKX .
  methods GET_WERKS
    returning
      value(RI_WERKS) type /VCXI/CL_VSMR_RTE_PSTEP=>YI_WERKS
    raising
      /VCXI/CX_CKX .
  methods GET_XCOMP_RTESEL
    returning
      value(RT_XCOMP_RTESEL) type ZVCXI_PXSR_TT_XCOMP_RTESEL
    raising
      /VCXI/CX_CKX .
  methods IS_DUMMY_ALLOWED
    returning
      value(RF_ALLOWED) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods REDETERMINE_DUMMY
    raising
      /VCXI/CX_CKX .
  methods SET_EVENT_HANDLER
    importing
      !IF_ACTIVATION type ABAP_BOOL
      !IR_PR_RTESPV type ref to ZCL_VCXI_XCSR_PR_RTESPV
    raising
      /VCXI/CX_CKX .
  methods SET_MFRAT
    importing
      !IF_MFRAT type ZVCXI_XCSP_MFRAT
    raising
      /VCXI/CX_CKX .
  methods TURN_PCDIR
    importing
      !IR_RTE_ARBPL type ref to /VCXI/CL_VSMR_RTE_ARBPL
      !IF_PCDIR_PREV type ZVCXI_P0SP_PCDIR
    returning
      value(RF_RECHECK) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods VALIDATE_PCDIR
    importing
      !IR_BL_PRTE type ref to ZCL_VCXI_XCSR_BL_PRTE
    returning
      value(RF_RECHECK) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods VALIDATE_RHNDL
    importing
      !IR_BL_PRTE type ref to ZCL_VCXI_XCSR_BL_PRTE
    returning
      value(RF_RECHECK) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .

  methods BUILD_RTE_COMBI_PSTEP
    redefinition .
  methods GET_BL_PSTEP
    redefinition .
  methods HANDLE_DESERIALIZE
    redefinition .
  methods HANDLE_INIT_EVQTY
    redefinition .
  methods HANDLE_PROD_FILLED
    redefinition .
  methods HANDLE_REBUILD_BL_PSTEP
    redefinition .
  methods UPDATE_BL_PRTE_BY_RTE_DEF
    redefinition .
  methods VALIDATE
    redefinition .
private section.

  class-data F_BUFFER_PROD_FILLED type ABAP_BOOL value ABAP_UNDEFINED ##NO_TEXT.
endclass. "ZCL_VCXI_PXSR_PR_RTESPV definition
class ZCL_VCXI_PXSR_PR_RTESPV implementation.
  method BUILD_RTE_COMBI_PSTEP.

    data: LR_RTE_PSTEP_CURR type ref to /VCXI/CL_VSMR_RTE_PSTEP,
          LR_BL_PSTEP_CURR  type ref to ZCL_VCXI_PXSR_BL_PSTEP.
    data: LR_RTE_PSTEP_PREV type ref to /VCXI/CL_VSMR_RTE_PSTEP,
          LR_BL_PSTEP_PREV  type ref to ZCL_VCXI_PXSR_BL_PSTEP.
    field-symbols:  <S_RTE_COMBI_PSTEP> type        /VCXI/VSMR_S_RTE_COMBI_PSTEP.

    loop at IT_RTE_PSTEP into LR_RTE_PSTEP_CURR.
      move LR_RTE_PSTEP_CURR->R_BLOBJ ?to LR_BL_PSTEP_CURR.

***   If we have two Prodcution Steps
      if LR_BL_PSTEP_PREV is bound.

***     Check if they should be combined
        if LR_BL_PSTEP_CURR->F_COMBW eq 'P' or  "Previous
           LR_BL_PSTEP_PREV->F_COMBW eq 'N'.    "Next

***       Create a new Combination Entry if non is active
          if <S_RTE_COMBI_PSTEP> is not assigned.
            append initial line to RT_RTE_COMBI_PSTEP assigning <S_RTE_COMBI_PSTEP>.
            append LR_RTE_PSTEP_PREV to <S_RTE_COMBI_PSTEP>-T_RTE_PSTEP.
          endif.

***       Add current PStep to Combination Entry
          append LR_RTE_PSTEP_CURR to <S_RTE_COMBI_PSTEP>-T_RTE_PSTEP.
        else.

***       End combination entry
          unassign <S_RTE_COMBI_PSTEP>.
        endif.
      endif.

***   Keep for next Round
      move LR_RTE_PSTEP_CURR to LR_RTE_PSTEP_PREV.
      move LR_BL_PSTEP_CURR  to LR_BL_PSTEP_PREV.
    endloop.

  endmethod.
  method CONSTRUCTOR.

    data:  LR_BL_RTESPV type ref to ZCL_VCXI_XCSR_BL_RTESPV.

*** Use or create the BL Routing Supervisor
    if IR_BL_RTESPV is bound.
      move IR_BL_RTESPV to LR_BL_RTESPV.
    else.
      create object LR_BL_RTESPV
        type ZCL_VCXI_PXSR_BL_RTESPV
        exporting
          IR_GATE = IR_GATE.
    endif.

*** Call Super
    call method SUPER->CONSTRUCTOR
      exporting
        IR_GATE      = IR_GATE
        IR_BL_RTESPV = LR_BL_RTESPV.

*** Request Auto Redetermination
    move ABAP_TRUE to ME->F_REDETERMINATION_REQ.

  endmethod.
  method CONVERT_EVQTY_FOR_XCONI.
  endmethod.
  method CREATE_BL_PRTE.

    data: LR_RTE_PRTE  type ref to /VCXI/CL_VSMR_RTE_PRTE.

    if IR_RTE_PRTE is bound.
      move IR_RTE_PRTE to LR_RTE_PRTE.
    else.
      create object LR_RTE_PRTE.
    endif.

    create object RR_BL_PRTE
      type ZCL_VCXI_PXSR_BL_PRTE
      exporting
        IR_RTE_PRTE  = LR_RTE_PRTE
        IR_MFMI      = ME->R_MFMI
        IR_MFSI      = ME->R_MFSI
        IT_CSPLIT    = ME->T_CSPLIT
        IF_DATE      = ME->F_DATE
        IF_LIFNR_REQ = ME->F_LIFNR_REQ.

*** Set Material Flow Ratio
    cast ZCL_VCXI_PXSR_BL_PRTE( RR_BL_PRTE )->SET_MFRAT( IF_MFRAT = ME->GET_MFRAT( ) ).

  endmethod.
  method CREATE_BL_PSTEP.

***------------------------------------------------------------------------------------------------
*** Create Instance based on ID
    case IF_IPSTP.
      when ZCL_VCXI_PXSR_BL_PSTEP_UNIT=>C_IPSTP_GRP or
           ZCL_VCXI_PXSR_BL_PSTEP_UNIT=>C_IPSTP_UNIT.
        create object RR_BL_PSTEP
          type ZCL_VCXI_PXSR_BL_PSTEP_UNIT
          exporting
            IF_IPSTP   = IF_IPSTP
            IF_DATE    = ME->F_DATE
            IR_APPDATA = ME->R_GATE->GET_APPDATA( ).
    endcase.

***------------------------------------------------------------------------------------------------
*** Initialize Production Step
    check RR_BL_PSTEP is bound.
    RR_BL_PSTEP->I_WERKS = ME->I_WERKS.
    RR_BL_PSTEP->SET_COMBW( IF_COMBW = IF_COMBW ).
    RR_BL_PSTEP->INIT_BY_SPEC( IR_GATE  = ME->R_GATE
                               IT_PRVDR = IT_PRVDR ).

  endmethod.
  method CREATE_BL_PSTEP_MANU.

    data: LF_PCDIR type ZVCXI_P0SP_PCDIR.
    data: LR_BL_PSTEP_MANU type ref to ZCL_VCXI_PXSR_BL_PSTEP_MANU.


*** Create BL PStep
    create object LR_BL_PSTEP_MANU
      exporting
        IF_DATE    = ME->F_DATE
        IR_APPDATA = ME->R_GATE->GET_APPDATA( ).

*** Mark as Manual
    move ABAP_TRUE to LR_BL_PSTEP_MANU->ZIF_VCXI_XCSR_BL_MANU~F_MANWC.

*** Default Machine Speed Rate
    move '60'      to LR_BL_PSTEP_MANU->ZIF_VCXI_XCSR_BL_MANU~S_MSRS-MSRST.

*** Get Direction and Handling Option
    ZCL_VCXI_P0SR_CUST_PSTEP=>GET_PSTEP_INFO( exporting IF_IPSTP = LR_BL_PSTEP_MANU->F_IPSTP
                                              importing EF_PCDIR = LF_PCDIR
                                                        EF_PCDOP = LR_BL_PSTEP_MANU->ZIF_VCXI_PXSR_PCDIR~F_PCDOP ).
    LR_BL_PSTEP_MANU->ZIF_VCXI_PXSR_PCDIR~SET_PCDIR( IF_PCDIR = LF_PCDIR ).

*** Return
    move LR_BL_PSTEP_MANU to RR_BL_PSTEP.

  endmethod.
  method CREATE_BL_PSTEP_OUTSO.

    data: LF_PCDIR type ZVCXI_P0SP_PCDIR.
    data: LR_BL_PSTEP_OUTSO type ref to ZCL_VCXI_PXSR_BL_PSTEP_OUTSO.


*** Create BL PStep
    create object LR_BL_PSTEP_OUTSO
      exporting
        IF_DATE    = ME->F_DATE
        IR_APPDATA = ME->R_GATE->GET_APPDATA( ).

*** Mark as Outsourcing
    move ABAP_TRUE to LR_BL_PSTEP_OUTSO->ZIF_VCXI_XCSR_BL_OUTSO~F_OUTSO.

*** Default Price Per
    move '1000'    to LR_BL_PSTEP_OUTSO->ZIF_VCXI_XCSR_BL_OUTSO~S_PRICP-PRICP.

*** Get Direction and Handling Option
    ZCL_VCXI_P0SR_CUST_PSTEP=>GET_PSTEP_INFO( exporting IF_IPSTP = LR_BL_PSTEP_OUTSO->F_IPSTP
                                              importing EF_PCDIR = LF_PCDIR
                                                        EF_PCDOP = LR_BL_PSTEP_OUTSO->ZIF_VCXI_PXSR_PCDIR~F_PCDOP ).
    LR_BL_PSTEP_OUTSO->ZIF_VCXI_PXSR_PCDIR~SET_PCDIR( IF_PCDIR = LF_PCDIR ).

*** Return
    move LR_BL_PSTEP_OUTSO to RR_BL_PSTEP.

  endmethod.
  method EVALUATE_BL_PRTE.

    data: LS_MQTYI type ZVCXI_XCSP_S_MQTYI.

    if ME->R_RTESEL is bound.
***   Buffer Machine Quantity In of Selected Route
      move ME->R_RTESEL->S_MQTYI to LS_MQTYI.
    endif.

    SUPER->EVALUATE_BL_PRTE( IT_BL_PRTE = IT_BL_PRTE ).

*** If Machine Quantity of Selected Routes has changed by the Evaluation, inform others via event
    if ME->R_RTESEL is bound and
       LS_MQTYI     is not initial and
       ME->R_RTESEL->S_MQTYI ne LS_MQTYI.
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_EVQTY_IN_CHANGED ).
    endif.

  endmethod.
  method FILL_PROD.

    data: LS_EXQTY        type        /VCXI/VKCR_S_EXQTY.
    data: LT_XCOMP_RTESEL type        ZVCXI_PXSR_TT_XCOMP_RTESEL,
          LT_GATE_RTESPV  type        /VCXI/VKSR_TT_GATE.
    data: LR_BL_RTESPV   type ref to ZCL_VCXI_PXSR_BL_RTESPV,
          LR_RTEFIL      type ref to ZCL_VCXI_XCSR_BL_PRTE,
          LR_GATE_RTESPV type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_RTESPV   type ref to ZCL_VCXI_PXSR_PR_RTESPV.

    check ME->R_BL_RTESPV is bound.

*** Get Explosion Quantity
    move ME->GET_EXQTY( ) to LS_EXQTY.

***--------------------------------------------------------------------------------------
*** Get Selected Route of Component
    LT_XCOMP_RTESEL = ME->GET_XCOMP_RTESEL( ).

*** Set Routes to Production
    move ME->R_BL_RTESPV ?to LR_BL_RTESPV.
    LR_BL_RTESPV->SET_PX_BL_PRTE( IT_XCOMP_RTESEL = LT_XCOMP_RTESEL
                                  IS_EXQTY        = LS_EXQTY ).

***--------------------------------------------------------------------------------------
*** Find Provider for Routing Supervisor of Components
    LT_GATE_RTESPV = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSR_PR_RTESPV=>C_IPRVT_PX_RTESPV
                                            IF_INUSE = ABAP_TRUE ).

*** Activate Event Handler
    loop at LT_GATE_RTESPV into LR_GATE_RTESPV.
      move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.
      LR_PR_RTESPV->SET_EVENT_HANDLER( IR_PR_RTESPV  = ME
                                       IF_ACTIVATION = ABAP_TRUE ).
    endloop.

*** Trigger Event without reference
    clear LR_RTEFIL.
    raise event PROD_FILLED exporting IR_BL_PRTE = LR_RTEFIL.

*** Deactivate Event Handler
    loop at LT_GATE_RTESPV into LR_GATE_RTESPV.
      move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.
      LR_PR_RTESPV->SET_EVENT_HANDLER( IR_PR_RTESPV  = ME
                                       IF_ACTIVATION = ABAP_FALSE ).
    endloop.

  endmethod.
  method GET_BL_PSTEP.

    data: LT_PRVDR_CSTEP type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_SPEC   type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_INPUT  type ref to /VCXI/CL_VKSR_GATE,
          LR_PRVDR_CSTEP type ref to /VCXI/CL_VKSR_GATE.


***--------------------------------------------------------------------------------------
*** Find Provider for Specification
    ME->GET_PRVDR_SPEC( importing ER_GATE = LR_GATE_SPEC ).
    check LR_GATE_SPEC is bound.



***--------------------------------------------------------------------------------------
*** Get Input Provider
    ME->GET_PRVDR_INPUT( importing ER_GATE = LR_GATE_INPUT ).
    if LR_GATE_INPUT is bound.
***   BL Production Steps - Input
      ME->GET_BL_PSTEP_INPUT( exporting IR_GATE_INPUT = LR_GATE_INPUT
                              changing  CT_BL_PSTEP   = RT_BL_PSTEP ).
    endif.

***--------------------------------------------------------------------------------------
*** Get Provider for Conversion (Sorted)
    LT_PRVDR_CSTEP = ME->GET_PRVDR_CSTEP( IR_GATE_SPEC = LR_GATE_SPEC ).
    loop at LT_PRVDR_CSTEP into LR_PRVDR_CSTEP.
      ME->GET_BL_PSTEP_CSTEP( exporting IR_GATE_CSTEP = LR_PRVDR_CSTEP
                              changing  CT_BL_PSTEP   = RT_BL_PSTEP ).
    endloop.

*** BL Production Steps - Output
    ME->GET_BL_PSTEP_OUTPUT( changing CT_BL_PSTEP = RT_BL_PSTEP ).

*** Get BL PStep - Shipping Manager
    ME->GET_BL_PSTEP_SHIPMGR( changing CT_BL_PSTEP = RT_BL_PSTEP ).

  endmethod.
  method GET_BL_PSTEP_CSTEP.
  endmethod.
  method GET_BL_PSTEP_INPUT.
  endmethod.
  method GET_BL_PSTEP_OUTPUT.

    data: LT_PRVDR_SSTEP type /VCXI/VKSR_TT_GATE,
          LT_PRVDR_OUT   type /VCXI/VKSR_TT_GATE.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.


***--------------------------------------------------------------------------------------
*** Get Separation Steps
    LT_PRVDR_SSTEP = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSS_PR_SSTEP=>C_IPRVT_PX_SSTEP
                                            IF_INUSE  = ABAP_TRUE ).
    check LT_PRVDR_SSTEP is not initial.

*** Get Outbound Elements
    append lines of ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSS_PR_XCONO=>C_IPRVT_XCONO
                                           IF_INUSE  = ABAP_TRUE ) to LT_PRVDR_OUT.
    append lines of ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSS_PR_XFG=>C_IPRVT_XFG
                                           IF_INUSE  = ABAP_TRUE ) to LT_PRVDR_OUT.
    ME->R_GATE->SORT_GATE( changing CT_GATE = LT_PRVDR_OUT ).

***--------------------------------------------------------------------------------------
*** Process Separation Steps
    loop at LT_PRVDR_SSTEP into LR_GATE.
      ME->GET_BL_PSTEP_SSTEP( exporting IR_GATE_SSTEP = LR_GATE
                                        IT_PRVDR_OUT  = LT_PRVDR_OUT
                              changing  CT_BL_PSTEP   = CT_BL_PSTEP ).
    endloop.

  endmethod.
  method GET_BL_PSTEP_SHIPMGR.

    data: LT_GATE_SHIPMGR  type /VCXI/VKSR_TT_GATE,
          LT_GATE_SHIPUNIT type /VCXI/VKSR_TT_GATE.
    data: LR_GATE_SHIPMGR  type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_SHIPMGR    type ref to ZCL_VCXI_XCSU_PR_SHIPMGR,
          LR_GATE_SHIPUNIT type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------------------------------------
*** Find Provider for Shipping Manager
    LT_GATE_SHIPMGR = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_IPRVT_XCS_SHIPMGR
                                             IF_INUSE = ABAP_TRUE ).
    check LT_GATE_SHIPMGR is not initial.
    LR_GATE_SHIPMGR = LT_GATE_SHIPMGR[ 1 ].


*** Find Provider for Shipping Units
    LT_GATE_SHIPUNIT = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_SHIPUNIT=>C_IPRVT_XCS_SHIPUNIT
                                              IF_INUSE = ABAP_TRUE ).

*** Filter by Shipping Manager
    loop at LT_GATE_SHIPUNIT into LR_GATE_SHIPUNIT.
      if LR_GATE_SHIPUNIT->IS_IN_LINE( IR_GATE = LR_GATE_SHIPMGR ) ne ABAP_TRUE.
        delete LT_GATE_SHIPUNIT.
      endif.
    endloop.
    check LT_GATE_SHIPUNIT is not initial.


***------------------------------------------------------------------------------------------------
*** Shipping Units Grouping
    ME->GET_BL_PSTEP_SHIPUNIT( exporting IR_GATE_SHIPMGR  = LR_GATE_SHIPMGR
                                         IT_GATE_SHIPUNIT = LT_GATE_SHIPUNIT
                                         IF_ATTID_SHUTY   = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_ATTID_SHUTY_GROUP
                                         IF_IPSTP         = ZCL_VCXI_PXSR_BL_PSTEP_UNIT=>C_IPSTP_GRP
                                         IF_COMBW         = ZCL_VCXI_PXSR_BL_PSTEP_UNIT=>C_COMBW_PREV
                               changing  CT_BL_PSTEP      = CT_BL_PSTEP ).

*** Shipping Units HU
    ME->GET_BL_PSTEP_SHIPUNIT( exporting IR_GATE_SHIPMGR  = LR_GATE_SHIPMGR
                                         IT_GATE_SHIPUNIT = LT_GATE_SHIPUNIT
                                         IF_ATTID_SHUTY   = ZCL_VCXI_XCSU_PR_SHIPMGR=>C_ATTID_SHUTY_UNIT
                                         IF_IPSTP         = ZCL_VCXI_PXSR_BL_PSTEP_UNIT=>C_IPSTP_UNIT
                               changing  CT_BL_PSTEP      = CT_BL_PSTEP ).

  endmethod.
  method GET_BL_PSTEP_SHIPUNIT.

    data: LT_GATE_SHIPUNIT type /VCXI/VKSR_TT_GATE,
          LT_GATE_PACKMAT  type /VCXI/VKSR_TT_GATE,
          LT_GATE_PSCALE   type /VCXI/VKSR_TT_GATE,
          LT_GATE_XCPMCNF  type /VCXI/VKSR_TT_GATE,
          LT_PRVDR         type /VCXI/VKSR_TT_GATE.
    data: LR_PR_SHIPMGR    type ref to ZCL_VCXI_XCSU_PR_SHIPMGR,
          LR_GATE_SHIPUNIT type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PACKMAT  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PSCALE   type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCPMCNF  type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------------------------------------
*** Get Shipping Manager
    LR_PR_SHIPMGR ?= IR_GATE_SHIPMGR->R_CLSPR.

*** Filter Shipping Units
    LT_GATE_SHIPUNIT = IT_GATE_SHIPUNIT.
    LR_PR_SHIPMGR->FILTER_BY_SHUTY( exporting IF_ATTID_SHUTY = IF_ATTID_SHUTY
                                    changing  CT_GATE        = LT_GATE_SHIPUNIT ).

*** Sort Shipping Units
    if LINES( LT_GATE_SHIPUNIT ) gt 1.
      ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE_SHIPUNIT ).
    endif.

*** Find all Provider for Price Scales
    LT_GATE_PSCALE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCS_PR_PSCALE=>C_IPRVT_XCS_PSCALE
                                            IF_INUSE = ABAP_TRUE ).

*** Find all Provider for Configured Packaging Material Configurations
    LT_GATE_XCPMCNF = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_XCPMCNF=>C_IPRVT_PX_XCPMCNF
                                             IF_INUSE = ABAP_TRUE ).

***------------------------------------------------------------------------------------------------
*** Find Provider for Packaging Materials and Configured Packaging Materials
    LT_GATE_PACKMAT = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_PACKMAT=>C_IPRVT_XCS_PACKMAT
                                             IF_INUSE = ABAP_TRUE ).
    append lines of ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSU_PR_CPM=>C_IPRVT_XCS_CPM
                                           IF_INUSE = ABAP_TRUE ) to LT_GATE_PACKMAT.

    loop at LT_GATE_PACKMAT into LR_GATE_PACKMAT.
      if LR_GATE_PACKMAT->IS_IN_LINE( IR_GATE = IR_GATE_SHIPMGR ) ne ABAP_TRUE.
        delete LT_GATE_PACKMAT.
        continue.
      endif.
    endloop.

*** Sort Packaging Materials
    if LINES( LT_GATE_PACKMAT ) gt 1.
      ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE_PACKMAT ).
    endif.

***------------------------------------------------------------------------------------------------
*** Create BL PStep for each Unit
    loop at LT_GATE_SHIPUNIT into LR_GATE_SHIPUNIT.
***   Get Shipping Manager and Shipping Unit as Provider.
      LT_PRVDR = value #( ( IR_GATE_SHIPMGR )
                          ( LR_GATE_SHIPUNIT ) ).

***   Get Packaging Materials which are in line with Shipping Unit
      loop at LT_GATE_PACKMAT into LR_GATE_PACKMAT.
        if LR_GATE_PACKMAT->IS_IN_LINE( IR_GATE = LR_GATE_SHIPUNIT ) eq ABAP_TRUE.
          append LR_GATE_PACKMAT to LT_PRVDR.
        else.
          continue.
        endif.

***     Get Price Scales which are in line with Packaging Material
        loop at LT_GATE_PSCALE into LR_GATE_PSCALE.
          if LR_GATE_PSCALE->IS_IN_LINE( IR_GATE = LR_GATE_PACKMAT ) eq ABAP_TRUE.
            append LR_GATE_PSCALE to LT_PRVDR.
          endif.
        endloop.

***     Get Configured Packaging Material Configuration which are in line with Packaging Material
        loop at LT_GATE_XCPMCNF into LR_GATE_XCPMCNF.
          if LR_GATE_XCPMCNF->IS_IN_LINE( IR_GATE = LR_GATE_PACKMAT ) eq ABAP_TRUE.
            append LR_GATE_XCPMCNF to LT_PRVDR.
          endif.
        endloop.
      endloop.

***   Create BL PStep
      append ME->CREATE_BL_PSTEP( IF_IPSTP = IF_IPSTP
                                  IT_PRVDR = LT_PRVDR
                                  IF_COMBW = IF_COMBW ) to CT_BL_PSTEP.

    endloop.

  endmethod.
  method GET_BL_PSTEP_SSTEP.
  endmethod.
  method GET_EVQTY_BY_FG.

    data: LF_UMREZ      type        UMREZ.
    data: LS_QCALC      type        ZVCXI_XCSS_S_QCALC.
    data: LT_GATE_OPQTY type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_OPQTY type ref to /VCXI/CL_VKSR_GATE,
          LR_OPQTY      type ref to ZIF_VCXI_XCSS_OPQTY,
          LR_APPDATA    type ref to /VCXI/CL_VKSR_APPDATA.


    check IR_GATE_FG is bound.

***--------------------------------------------------------------------------------------
*** Get Number of Outs
    if IR_GATE_FG->R_CLSPR is instance of ZCL_VCXI_PXSS_PR_XFG.
      EF_NOUTT = cast ZCL_VCXI_PXSS_PR_XFG( IR_GATE_FG->R_CLSPR )->GET_NOUTT( ).
    endif.

*** Fallback for calculating a "temporary" Evaluation Quantity
    if EF_NOUTT eq 0.
      move 1 to EF_NOUTT.
    endif.

*** Use 1 Ups as Default as XFG has no Ups
    EF_NOUPS = 1.

***--------------------------------------------------------------------------------------
*** Get Gates of Operation Quantity
    LT_GATE_OPQTY = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZIF_VCXI_XCSS_OPQTY=>C_IPRVT_XCS_OPQTY
                                           IF_INUSE  = ABAP_TRUE
                                           IF_SORTED = ABAP_TRUE ).
*** Find Multi Quantity
    loop at LT_GATE_OPQTY into LR_GATE_OPQTY.
      check LR_GATE_OPQTY->R_CLSPR is instance of ZCL_VCXI_XCSS_PR_MULTIQTY_MGR.
      LR_OPQTY ?= LR_GATE_OPQTY->R_CLSPR.
      exit.
    endloop.
    if LR_OPQTY is not bound.
***   Find Inline
      loop at LT_GATE_OPQTY into LR_GATE_OPQTY.
        check IR_GATE_FG->IS_IN_LINE( IR_GATE = LR_GATE_OPQTY ) eq ABAP_TRUE.
        try.
            move LR_GATE_OPQTY->R_CLSPR ?to LR_OPQTY.
          catch CX_SY_MOVE_CAST_ERROR.
            clear LR_OPQTY.
        endtry.
      endloop.
***   Take first
      if LR_OPQTY is not bound.
        read table LT_GATE_OPQTY into LR_GATE_OPQTY index 1.
        if SY-SUBRC eq 0.
          try.
              move LR_GATE_OPQTY->R_CLSPR ?to LR_OPQTY.
            catch CX_SY_MOVE_CAST_ERROR.
              clear LR_OPQTY.
          endtry.
        endif.
      endif.
    endif.

*** Get Operation Quantity of Provider or use Application Data
    if LR_OPQTY is bound.
      LR_OPQTY->GET_QCALC( importing ES_QCALC_SELF = LS_QCALC
                                     EF_UMREZ      = LF_UMREZ ).
***   Use Base and multiply by Numerator
      ES_EVQTY-EVQTY     = LS_QCALC-QCALC * LF_UMREZ.
      ES_EVQTY-EVQTY_UOM = LS_QCALC-QCALC_UOM.
    else.
      LR_APPDATA = ME->R_GATE->GET_APPDATA( ).
      ES_EVQTY-EVQTY     = LR_APPDATA->S_OPQTY-OPQTY.
      ES_EVQTY-EVQTY_UOM = LR_APPDATA->S_OPQTY-OPQTY_UOM.
    endif.

***--------------------------------------------------------------------------------------
    if cast ZIF_VCXI_PXSS_FG( IR_GATE_FG->R_CLSPR )->GET_MATNR( ) is initial.
***   Multiply by Quantity Factor
      ES_EVQTY-EVQTY *= cast ZIF_VCXI_PXSS_FG( IR_GATE_FG->R_CLSPR )->GET_QFACT( ).
    endif.

  endmethod.
  method GET_EVQTY_BY_GATE.

    data: LF_TABIX type I.
    data: LT_GATE_CHILD type /VCXI/VKSR_TT_GATE.
    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.


    check IR_GATE is bound.

***--------------------------------------------------------------------------------------
*** Get Provider for Output including children
    ME->GET_PRVDR_OUTPUT( importing ET_GATE_CHILD = LT_GATE_CHILD ).
    ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE_CHILD ).

*** Loop at all children
    loop at LT_GATE_CHILD into LR_GATE.
      case type of LR_GATE->R_CLSPR.
***     Gate is a Finished Good
        when type ZIF_VCXI_PXSS_FG.
***       Get Detials for Finished Good
          LF_TABIX += 1.
          if LR_GATE eq IR_GATE.
            ME->GET_EVQTY_BY_FG( exporting IR_GATE_FG = LR_GATE
                                 importing ES_EVQTY   = RS_EVQTY
                                           EF_NOUTT   = EF_NOUTT
                                           EF_NOUPS   = EF_NOUPS ).
          endif.

***     Check Gate is Connection Out
        when type ZCL_VCXI_PXSS_PR_XCONO.
***       Get Details for Connection Out
          LF_TABIX += 1.
          if LR_GATE eq IR_GATE.
            ME->GET_EVQTY_BY_XCONO( exporting IR_GATE_XCONO = LR_GATE
                                              IF_TABIX      = LF_TABIX
                                    importing ES_EVQTY      = RS_EVQTY
                                              EF_NOUTT      = EF_NOUTT
                                              EF_NOUPS      = EF_NOUPS ).
          endif.
      endcase.
***       Get Detials for Finished Good
***       Get Details for Connection Out
    endloop.

  endmethod.
  method GET_EVQTY_BY_IMFXC.

    data: LR_PR_XCONI type ref to ZCL_VCXI_PXSS_PR_XCONI.


*** Force Deserialize if currently requested
    if ME->F_DESERIALIZE_REQ eq ABAP_TRUE.
      ME->HANDLE_DESERIALIZE( ).
    endif.

*** Call Super
    RS_EVQTY = SUPER->GET_EVQTY_BY_IMFXC( IF_IMFXC = IF_IMFXC ).

***--------------------------------------------------------------------------------------
*** Find Connection In based on X-Connect ID
    loop at ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_XCONI=>C_IPRVT_XCONI
                                   IF_INUSE = ABAP_TRUE ) into data(LR_GATE).
      check cast ZCL_VCXI_PXSS_PR_XCONI( LR_GATE->R_CLSPR )->GET_GXCON( ) eq IF_IMFXC.

***   Convert Evaluation Quantity for Connection In
      ME->CONVERT_EVQTY_FOR_XCONI( exporting IR_GATE  = LR_GATE
                                   changing  CS_EVQTY = RS_EVQTY ).

***   Exit once the connection has been found
      exit.
    endloop.

  endmethod.
  method GET_EVQTY_BY_XCONO.

    data: LF_IMFXC     type ZVCXI_XCSP_IMFXC.
    data: LT_IMFXC_IN  type ZVCXI_XCSP_TT_IMFXC,
          LT_IMFXC_OUT type ZVCXI_XCSP_TT_IMFXC.
    data: LT_GATE_RTESPV type /VCXI/VKSR_TT_GATE.
    data: LR_PR_XCONO    type ref to ZCL_VCXI_PXSS_PR_XCONO,
          LR_GATE_RTESPV type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_RTESPV   type ref to ZCL_VCXI_PXSR_PR_RTESPV.


*** Process all Events before further determination of Evaluation Qty
    ME->R_GATE->RAISE_EVENTS( ).

***--------------------------------------------------------------------------------------
*** Get Number of Outs and Number of Ups
    move IR_GATE_XCONO->R_CLSPR ?to LR_PR_XCONO.
    EF_NOUTT = LR_PR_XCONO->GET_NOUTT( ).
    EF_NOUPS = LR_PR_XCONO->GET_NOUPS( ).

*** Fallback for calculating a "temporary" Evaluation Quantity
    EF_NOUTT = switch #( EF_NOUTT when 0 then 1 else EF_NOUTT ).
    EF_NOUPS = switch #( EF_NOUPS when 0 then 1 else EF_NOUPS ).

***--------------------------------------------------------------------------------------
*** Get x-Connect based on position of Gate in relation to Output
    ME->GET_IMFXC( importing ET_IMFXC_OUT = LT_IMFXC_OUT ).
    read table LT_IMFXC_OUT into LF_IMFXC index IF_TABIX.

*** Find Provider for Routing Supervisor of Components
    LT_GATE_RTESPV = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSR_PR_RTESPV=>C_IPRVT_PX_RTESPV
                                            IF_INUSE  = ABAP_TRUE ).
    loop at LT_GATE_RTESPV into LR_GATE_RTESPV.

***   Get Information by Routing Supervisor
      try.
          move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_RTESPV.
      endtry.

      check LR_PR_RTESPV is bound.

***   Get Inbound Connections
      refresh LT_IMFXC_IN.
      LR_PR_RTESPV->GET_IMFXC( importing ET_IMFXC_IN = LT_IMFXC_IN ).
      read table LT_IMFXC_IN with key TABLE_LINE = LF_IMFXC
                             transporting no fields.
      check SY-SUBRC is initial.

      try.
          ES_EVQTY = LR_PR_RTESPV->GET_EVQTY_BY_IMFXC( LF_IMFXC ).
        catch /VCXI/CX_CKX.
***       Clear all to reset parameter
          clear ES_EVQTY.
      endtry.
    endloop.

  endmethod.
  method GET_EXQTY.

    data: LF_UMREZ   type        UMREZ.
    data: LS_QCALC   type        ZVCXI_XCSS_S_QCALC.
    data: LT_GATE    type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE    type ref to /VCXI/CL_VKSR_GATE,
          LR_OPQTY   type ref to ZIF_VCXI_XCSS_OPQTY,
          LR_APPDATA type ref to /VCXI/CL_VKSR_APPDATA.

***--------------------------------------------------------------------------------------
*** Get Gates of Operation Quantity
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZIF_VCXI_XCSS_OPQTY=>C_IPRVT_XCS_OPQTY
                                     IF_INUSE  = ABAP_TRUE
                                     IF_SORTED = ABAP_TRUE ).
*** Find Inline
    loop at LT_GATE into LR_GATE.
      check ME->R_GATE->IS_IN_LINE( IR_GATE = LR_GATE ) eq ABAP_TRUE.
      try.
          move LR_GATE->R_CLSPR ?to LR_OPQTY.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_OPQTY.
      endtry.
    endloop.
*** Take first
    if LR_OPQTY is not bound.
      read table LT_GATE into LR_GATE index 1.
      if SY-SUBRC eq 0.
        try.
            move LR_GATE->R_CLSPR ?to LR_OPQTY.
          catch CX_SY_MOVE_CAST_ERROR.
            clear LR_OPQTY.
        endtry.
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Get Operation Quantity of Provider or use Application Data
    if LR_OPQTY is bound.
      LR_OPQTY->GET_QCALC( importing ES_QCALC_BASE = LS_QCALC
                                     EF_UMREZ      = LF_UMREZ ).
***   Use Base and multiply by Numerator
      RS_EXQTY-EXQTY     = LS_QCALC-QCALC * LF_UMREZ.
      RS_EXQTY-EXQTY_UOM = LS_QCALC-QCALC_UOM.
    else.
      LR_APPDATA  = ME->R_GATE->GET_APPDATA( ).
      move LR_APPDATA->S_OPQTY-OPQTY     to RS_EXQTY-EXQTY.
      move LR_APPDATA->S_OPQTY-OPQTY_UOM to RS_EXQTY-EXQTY_UOM.
    endif.

  endmethod.
  method GET_IMFXC.

    data: LF_EXCL  type ABAP_BOOL,
          LF_IMFXC type ZVCXI_XCSP_IMFXC.
    data: LS_XCONR type ZVCXI_PXSS_S_XCONR.
    data: LT_GATE  type /VCXI/VKSR_TT_GATE,
          LT_XCONR type ZVCXI_PXSS_TT_XCONR.
    data: LR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_EXCL type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE      type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_XCONI  type ref to ZCL_VCXI_PXSS_PR_XCONI.


*** Get Specification of current component
    ME->GET_PRVDR_SPEC( importing ER_GATE = LR_GATE_SPEC ).

***--------------------------------------------------------------------------------------
    if ET_IMFXC_IN is requested.
***   Get Connections Inbound
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_XCONI=>C_IPRVT_XCONI
                                       IF_INUSE = ABAP_TRUE ).

      loop at LT_GATE into LR_GATE.
        check LR_GATE->IS_IN_LINE( IR_GATE = LR_GATE_SPEC ) eq ABAP_TRUE.

***     Check if Connection In should be excluded
        LF_EXCL = ABAP_FALSE.
        loop at IT_GATE_EXCL into LR_GATE_EXCL.
          if LR_GATE->IS_IN_LINE( IR_GATE = LR_GATE_EXCL ) eq ABAP_TRUE.
            LF_EXCL = ABAP_TRUE.
            exit.
          endif.
        endloop.
        check LF_EXCL eq ABAP_FALSE.

***     Get its Connection GUID
        try.
            move LR_GATE->R_CLSPR ?to LR_PR_XCONI.
            check LR_PR_XCONI is bound.
            append LR_PR_XCONI->GET_GXCON( ) to ET_IMFXC_IN.

          catch CX_SY_MOVE_CAST_ERROR.
            continue.
        endtry.
      endloop.
    endif.


***--------------------------------------------------------------------------------------
    if ET_IMFXC_OUT is requested.
***   Get Connections Outbound
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_XCONO=>C_IPRVT_XCONO
                                       IF_INUSE = ABAP_TRUE ).
***   Get X-Connections (References)
      LT_XCONR = ME->GET_PRVDR_SOV( )->GET_XCONR( ).

      loop at LT_GATE into LR_GATE.
        try.
            read table LT_XCONR into LS_XCONR with key R_GATE_OUT = LR_GATE.
            if SY-SUBRC eq 0.
              check LS_XCONR-R_GATE_IN is bound.
              move LS_XCONR-R_GATE_IN->R_CLSPR ?to LR_PR_XCONI.
              check LR_PR_XCONI is bound.
              move LR_PR_XCONI->GET_GXCON( ) to LF_IMFXC.
            else.
              clear LF_IMFXC.
            endif.

            append LF_IMFXC to ET_IMFXC_OUT.

          catch CX_SY_MOVE_CAST_ERROR.
            continue.
        endtry.
      endloop.
    endif.

  endmethod.
  method GET_IMFXC_GATE_EXCL.

*** Exclude the Connections Ins of the Conversion Steps as well of Output,
*** as each conversion step needs to take care of that
    ME->GET_PRVDR_OUTPUT( importing ER_GATE = data(LR_GATE_OUTPUT) ).
    RT_GATE = value #( base ME->GET_PRVDR_CSTEP( )
                       ( LR_GATE_OUTPUT ) ).

  endmethod.
  method GET_MFRAT.

    RF_MFRAT = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_MFRAT )-ATFLV.

  endmethod.
  method GET_PRVDR_CSTEP.

    data: LT_PRVDR     type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE      type ref to /VCXI/CL_VKSR_GATE.


*** Determine Specification
    if IR_GATE_SPEC is supplied.
      LR_GATE_SPEC = IR_GATE_SPEC.
    else.
      ME->GET_PRVDR_SPEC( importing ER_GATE = LR_GATE_SPEC ).
    endif.

***--------------------------------------------------------------------------------------
*** Find Provider for Conversion Steps
    LT_PRVDR = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSS_PR_CSTEP=>C_IPRVT_PX_CSTEP
                                      IF_INUSE  = ABAP_TRUE ).

    loop at LT_PRVDR into LR_GATE.
***   Make sure it`s inline with current Specification
      check LR_GATE->IS_IN_LINE( LR_GATE_SPEC ) eq ABAP_TRUE.
      append LR_GATE to RT_PRVDR.
    endloop.

*** Sort Resulting Provider
    ME->R_GATE->SORT_GATE( changing CT_GATE = RT_PRVDR ).

  endmethod.
  method GET_PRVDR_INPUT.

    data:  LT_GATE  type /VCXI/VKSR_TT_GATE.

    clear: ER_GATE,
           RR_PR_INPUT.

***------------------------------------------------------------------------------------------------
*** Find Provider for Input
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_INPUT=>C_IPRVT_PX_INPUT
                                     IF_INUSE = ABAP_TRUE ).
    read table LT_GATE into ER_GATE index 1.
    check SY-SUBRC is initial.

    move ER_GATE->R_CLSPR ?to RR_PR_INPUT.
    check ER_GATE is bound.

***--------------------------------------------------------------------------------------
*** Find Child Provider for Input
    if ET_GATE_CHILD is requested.
      ET_GATE_CHILD = ER_GATE->GET_PRVDR( IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD
                                          IF_INUSE = ABAP_TRUE ).
    endif.

  endmethod.
  method GET_PRVDR_OUTPUT.

    data:  LT_GATE  type /VCXI/VKSR_TT_GATE.

    clear: ER_GATE,
           RR_PR_OUTPUT.

***------------------------------------------------------------------------------------------------
*** Find Provider for Output
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_OUTPUT=>C_IPRVT_PX_OUTPUT
                                     IF_INUSE = ABAP_TRUE ).
    read table LT_GATE into ER_GATE index 1.
    check SY-SUBRC is initial.

    move ER_GATE->R_CLSPR ?to RR_PR_OUTPUT.
    check ER_GATE is bound.

***--------------------------------------------------------------------------------------
*** Find Child Provider for Output
    if ET_GATE_CHILD is requested.
      ET_GATE_CHILD = ER_GATE->GET_PRVDR( IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD
                                          IF_INUSE = ABAP_TRUE ).
    endif.

  endmethod.
  method GET_PRVDR_RTESPV_BY_XCONO.

    data: LF_TABIX type I.
    data: LT_GATE_CHILD type /VCXI/VKSR_TT_GATE,
          LT_IMFXC_IN   type ZVCXI_XCSP_TT_IMFXC,
          LT_IMFXC_OUT  type ZVCXI_XCSP_TT_IMFXC.
    data: LT_GATE_RTESPV type /VCXI/VKSR_TT_GATE.
    data: LR_GATE_RTESPV type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_RTESPV   type ref to ZCL_VCXI_PXSR_PR_RTESPV.


***--------------------------------------------------------------------------------------
    if IF_TABIX is not supplied.
***   Get Provider for Output including children
      ME->GET_PRVDR_OUTPUT( importing ET_GATE_CHILD = LT_GATE_CHILD ).
      ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE_CHILD ).
      LF_TABIX = LINE_INDEX( LT_GATE_CHILD[ TABLE_LINE = IR_GATE_XCONO ] ).
    else.
      LF_TABIX = IF_TABIX.
    endif.

***--------------------------------------------------------------------------------------
*** Get x-Connect based on position of Gate in relation to Output
    ME->GET_IMFXC( importing ET_IMFXC_OUT = LT_IMFXC_OUT ).
    read table LT_IMFXC_OUT into EF_IMFXC index LF_TABIX.

*** Find Provider for Routing Supervisor of Components
    LT_GATE_RTESPV = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSR_PR_RTESPV=>C_IPRVT_PX_RTESPV
                                            IF_INUSE  = ABAP_TRUE ).
    loop at LT_GATE_RTESPV into LR_GATE_RTESPV.
***   Get Information by Routing Supervisor
      try.
          move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.
        catch CX_SY_MOVE_CAST_ERROR.
          clear LR_PR_RTESPV.
      endtry.

      check LR_PR_RTESPV is bound.

***   Get Inbound Connections
      refresh LT_IMFXC_IN.
      LR_PR_RTESPV->GET_IMFXC( importing ET_IMFXC_IN = LT_IMFXC_IN ).
      read table LT_IMFXC_IN with key TABLE_LINE = EF_IMFXC
                             transporting no fields.
      check SY-SUBRC is initial.

***   Return Routing Supervisor
      RR_PR_RTESPV = LR_PR_RTESPV.
      ER_GATE      = LR_GATE_RTESPV.
    endloop.

  endmethod.
  method GET_PRVDR_SOV.

    data:  LT_GATE  type /VCXI/VKSR_TT_GATE.

    clear: ER_GATE,
           RR_PR_SOV.

***------------------------------------------------------------------------------------------------
*** Find Provider for Specification Overview
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_SOV=>C_IPRVT_PX_SOV
                                     IF_INUSE = ABAP_TRUE ).
    if LT_GATE is not initial.
      ER_GATE = LT_GATE[ 1 ].
      RR_PR_SOV ?= ER_GATE->R_CLSPR.
    else.
      raise exception type /VCXI/CX_CKX.
    endif.

  endmethod.
  method GET_PRVDR_SPEC.

    data:  LT_GATE  type /VCXI/VKSR_TT_GATE.

    clear: ER_GATE,
           RR_PR_SPEC.

***------------------------------------------------------------------------------------------------
*** Find Provider for Specification
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_SPEC=>C_IPRVT_PX_SPEC
                                     IF_INUSE = ABAP_TRUE ).
    read table LT_GATE into ER_GATE index 1.
    check SY-SUBRC is initial.

    move ER_GATE->R_CLSPR ?to RR_PR_SPEC.

  endmethod.
  method GET_PSCALE.

    data: LT_GATE      type /VCXI/VKSR_TT_GATE.
    data: LR_GATE      type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_PSCALE type ref to ZCL_VCXI_XCS_PR_PSCALE.

***------------------------------------------------------------------------------------------------
*** Find Provider for Price Scale
    LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_XCS_PR_PSCALE=>C_IPRVT_XCS_PSCALE
                                     IF_INUSE  = ABAP_TRUE
                                     IF_SORTED = ABAP_TRUE ).

    loop at LT_GATE into LR_GATE
                   where TABLE_LINE->R_CLSPR is instance of ZCL_VCXI_XCS_PR_PSCALE.
***   Check Parent if supplied
      if IR_GATE_PARENT is supplied.
        check IR_GATE_PARENT->IS_PARENT( IR_GATE_CHILD = LR_GATE ).
      endif.

      LR_PR_PSCALE ?= LR_GATE->R_CLSPR.

***   Add Price Scale
      append value #( ISVCE   = LR_GATE->F_ID
                      S_PSQTY = LR_PR_PSCALE->GET_PSQTY( )
                      S_PRICE = LR_PR_PSCALE->GET_PRICE( )
                      S_PRICP = LR_PR_PSCALE->GET_PRICP( )
                    ) to RT_PSCALE.
    endloop.

  endmethod.
  method GET_RHNDL_IN.
  endmethod.
  method GET_RHNDL_OUT.

    data: LS_RHNDL_OUT type ZVCXI_PXSR_S_RHNDL.
    data: LR_PR_RHNDL   type ref to ZCL_VCXI_PXSS_PR_RHNDL,
          LR_PR_MS_CORE type ref to ZCL_VCXI_PXSS_PR_MS_CORE.


*** Process available Roll Handling
    loop at ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSS_PR_RHNDL=>C_IPRVT_PX_RHNDL
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = ABAP_TRUE ) into data(LR_GATE).
      LR_PR_RHNDL ?= LR_GATE->R_CLSPR.

***--------------------------------------------------------------------------------------
***   Add Roll Handling
      append value #( S_RHSRC = LR_PR_RHNDL->GET_RHSRC( )
                    ) to RT_RHNDL assigning field-symbol(<S_RHNDL>).

***--------------------------------------------------------------------------------------
***   Get Winding Information
      <S_RHNDL>-WISID = LR_PR_RHNDL->GET_WISID( ).
      <S_RHNDL>-WIDIR = LR_PR_RHNDL->GET_WIDIR( ).
      <S_RHNDL>-EYEMP = LR_PR_RHNDL->GET_EYEMP( ).

***   Get Dimension Information
      <S_RHNDL>-RDMTA = LR_PR_RHNDL->GET_RDIMTA( importing ES_RDITA  = <S_RHNDL>-S_RDITA
                                                           ES_RLETA  = <S_RHNDL>-S_RLETA
                                                           ES_RWGTA  = <S_RHNDL>-S_RWGTA ).

***   Get Core Information
      LR_PR_MS_CORE = LR_PR_RHNDL->GET_PRVDR_MS_CORE( ).
      if LR_PR_MS_CORE is bound.
        <S_RHNDL>-S_MS_CORE = value #( MATNR   = LR_PR_MS_CORE->GET_MATNR( )
                                       RLPCR   = LR_PR_MS_CORE->GET_RLPCR( )
                                       S_CRMAR = LR_PR_MS_CORE->GET_CRMAR( ) ).
      endif.
    endloop.

  endmethod.
  method GET_STATUS.

    data:  LF_RETURN  type        I.
    data:  LT_GATE    type        /VCXI/VKSR_TT_GATE.
    data:  LR_GATE    type ref to /VCXI/CL_VKSR_GATE.

    move /VCXI/CL_VKSR_SERVICE=>C_ELMST_G to RF_ELMST.

***--------------------------------------------------------------------------------------
    if ME->F_BUFFER_PROD_FILLED eq ABAP_UNDEFINED.

***   Fill Production is not required
      ME->CHECK_PROD_FILL( importing EF_RETURN = LF_RETURN ).
      if LF_RETURN eq 0.
        move ABAP_TRUE  to ME->F_BUFFER_PROD_FILLED.
      else.
        move ABAP_FALSE to ME->F_BUFFER_PROD_FILLED.
      endif.

***   Find Provider for Routing Supervisor
      LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSR_PR_RTESPV=>C_IPRVT_XCS_RTESPV
                                       IF_INUSE = ABAP_TRUE ).
***   Set Status of others
      loop at LT_GATE into LR_GATE
                     where TABLE_LINE ne ME->R_GATE.
        LR_GATE->GET_STATUS( ).
      endloop.

***   Set own Status
      if ME->F_BUFFER_PROD_FILLED eq ABAP_TRUE.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
      else.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
      endif.

***   Clear Buffer
      move ABAP_UNDEFINED to ME->F_BUFFER_PROD_FILLED.

    else.
      if ME->F_BUFFER_PROD_FILLED eq ABAP_TRUE.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
      else.
        RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                       IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Redetermination is not required
    if ME->F_REDETERMINATION_REQ ne ABAP_TRUE.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    else.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
    endif.

  endmethod.
  method GET_WERKS.

    data: LF_WERKS type WERKS_D.
    data: LR_PR_SPEC type ref to ZCL_VCXI_PXSS_PR_SPEC.
    field-symbols: <S_WERKS> type line of /VCXI/CL_VSMR_RTE_PSTEP=>YI_WERKS.

***--------------------------------------------------------------------------------------
    LR_PR_SPEC = ME->GET_PRVDR_SPEC( ).
    if LR_PR_SPEC is bound.
***   Use Plant of Specification
      LF_WERKS = LR_PR_SPEC->GET_WERKS( ).
    else.
***   Use Configuration Plant as provided by Application Data
      LF_WERKS = ME->R_GATE->GET_APPDATA( )->F_WERKS.
    endif.

***--------------------------------------------------------------------------------------
*** Filter to Plant
    append initial line to RI_WERKS assigning <S_WERKS>.
    move 'I'         to <S_WERKS>-SIGN.
    move 'EQ'        to <S_WERKS>-OPTION.
    move LF_WERKS    to <S_WERKS>-LOW.

  endmethod.
  method GET_XCOMP_RTESEL.

    data: LF_IMFXC       type ZVCXI_XCSP_IMFXC.
    data: LT_GATE_RTESPV type /VCXI/VKSR_TT_GATE,
          LT_IMFXC_IN    type ZVCXI_XCSP_TT_IMFXC,
          LT_BUFFER      type YT_BUFFER.
    data: LR_GATE_RTESPV   type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_RTESPV     type ref to ZCL_VCXI_PXSR_PR_RTESPV,
          LR_PR_RTESPV_OLD type ref to ZCL_VCXI_PXSR_PR_RTESPV,
          LR_BL_PSTEP      type ref to ZCL_VCXI_PXSR_BL_PSTEP.
    field-symbols: <S_XCOMP_RTESEL>     type          ZVCXI_PXSR_S_XCOMP_RTESEL,
                   <S_XCOMP_RTESEL_NEW> type          ZVCXI_PXSR_S_XCOMP_RTESEL,
                   <T_MFMI_OLD>         type standard table,
                   <T_MFMI_NEW>         type standard table,
                   <T_MFMI_TMP>         type standard table,
                   <S_MFMI>             type          ANY,
                   <T_MFSI>             type standard table,
                   <S_MFSI>             type          ANY,
                   <S_BUFFER>           type          YS_BUFFER.

***--------------------------------------------------------------------------------------
*** Find Provider for Routing Supervisor of Components
    LT_GATE_RTESPV = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_PXSR_PR_RTESPV=>C_IPRVT_PX_RTESPV
                                            IF_INUSE  = ABAP_TRUE
                                            IF_SORTED = ABAP_TRUE ).
    check LT_GATE_RTESPV is not initial.

***--------------------------------------------------------------------------------------
*** Process all Supervisor
    loop at LT_GATE_RTESPV into LR_GATE_RTESPV.
      move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.
      check LR_PR_RTESPV is bound.

***   Refresh Auto
      LR_PR_RTESPV->REFRESH_AUTO( ).
      ME->R_GATE->RAISE_EVENTS( ).

      if LR_PR_RTESPV->R_RTESEL is not bound.
***     No Selected Route defined.
        /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                              IF_MSGID = 'ZVCXI_XCSR'
                                              IF_MSGNO = '310' ).
      endif.

***   Add Selected Route to List
      append initial line to RT_XCOMP_RTESEL assigning <S_XCOMP_RTESEL>.
      move LR_PR_RTESPV->GET_ICELM( )      to <S_XCOMP_RTESEL>-ICELM.
      move LR_PR_RTESPV->R_RTESEL->COPY( ) to <S_XCOMP_RTESEL>-R_RTESEL.
      move LR_PR_RTESPV->R_BL_RTESPV      ?to <S_XCOMP_RTESEL>-R_BL_RTESPV.

      if <S_XCOMP_RTESEL>-R_RTESEL is not bound.
***     No Selected Route defined.
        /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                              IF_MSGID = 'ZVCXI_XCSR'
                                              IF_MSGNO = '310' ).
      endif.

***   Get x-Connects but exclude the Connections Ins of certain Gates as these take care themselfs
      LR_PR_RTESPV->GET_IMFXC( exporting IT_GATE_EXCL = LR_PR_RTESPV->GET_IMFXC_GATE_EXCL( )
                               importing ET_IMFXC_IN  = <S_XCOMP_RTESEL>-T_IMFXC_IN
                                         ET_IMFXC_OUT = <S_XCOMP_RTESEL>-T_IMFXC_OUT ).

      loop at <S_XCOMP_RTESEL>-T_IMFXC_IN into LF_IMFXC.
        append ABAP_TRUE to <S_XCOMP_RTESEL>-T_NEXTL.
      endloop.
    endloop.

***--------------------------------------------------------------------------------------
*** Reassign MFMIs of Dummy Routes
    loop at RT_XCOMP_RTESEL assigning <S_XCOMP_RTESEL>
                            where R_RTESEL->R_RTE_PRTE->T_RTE_ARBPL is initial.

***   Get Routing Supervisor (by Table Index)
      read table LT_GATE_RTESPV into LR_GATE_RTESPV index SY-TABIX.
      move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.

***   Assign Reference to MFMI
      check LR_PR_RTESPV->R_MFMI is bound.
      assign LR_PR_RTESPV->R_MFMI->* to <T_MFMI_OLD>.

***   Get X-Connect ID Outbound
      check LINES( <S_XCOMP_RTESEL>-T_IMFXC_OUT ) eq 1.
      read table <S_XCOMP_RTESEL>-T_IMFXC_OUT into LF_IMFXC
                                              index 1.
      clear <S_XCOMP_RTESEL>-R_RTESEL.

      move LR_PR_RTESPV to LR_PR_RTESPV_OLD.

***   Find matching Inbound
      clear: LR_PR_RTESPV.
      loop at RT_XCOMP_RTESEL assigning <S_XCOMP_RTESEL_NEW>.

***     Get Routing Supervisor (by Table Index)
        read table LT_GATE_RTESPV into LR_GATE_RTESPV index SY-TABIX.
        move LR_GATE_RTESPV->R_CLSPR ?to LR_PR_RTESPV.

***     Verify Match
        LR_PR_RTESPV->GET_IMFXC( importing ET_IMFXC_IN = LT_IMFXC_IN ).
        read table LT_IMFXC_IN with key TABLE_LINE = LF_IMFXC
                               transporting no fields.
        if SY-SUBRC eq 0.
          exit.
        else.
          clear: LR_PR_RTESPV.
        endif.
      endloop.

      if LR_PR_RTESPV is not bound.
        raise exception type /VCXI/CX_CKX.
      endif.

***   Assign Reference to MFMI
      read table LT_BUFFER with key R_PR_RTESPV = LR_PR_RTESPV
                           assigning <S_BUFFER>.
      if SY-SUBRC ne 0.
        append initial line to LT_BUFFER assigning <S_BUFFER>.
        move LR_PR_RTESPV to <S_BUFFER>-R_PR_RTESPV.

        if LR_PR_RTESPV->R_MFMI is bound.
***       Create copy of MFMI New
          assign LR_PR_RTESPV->R_MFMI->* to <T_MFMI_TMP>.
          create data <S_BUFFER>-R_MFMI like <T_MFMI_TMP>.
          assign <S_BUFFER>-R_MFMI->* to <T_MFMI_NEW>.
          move <T_MFMI_TMP> to <T_MFMI_NEW>.
        else.
***       Create copy of MFMI Old for New
          create data <S_BUFFER>-R_MFMI like <T_MFMI_OLD>.
        endif.
      endif.

***   Get old MFMI
      read table <T_MFMI_OLD> assigning <S_MFMI> index 1.
      if SY-SUBRC ne 0.
        raise exception type /VCXI/CX_CKX.
      endif.

***   Get Production Step which consumes X-Connection ID
      LR_BL_PSTEP ?= ME->GET_BL_PSTEP_BY_IMFXC( IF_IMFXC   = LF_IMFXC
                                                IR_BL_PRTE = <S_XCOMP_RTESEL_NEW>-R_RTESEL ).
      if LR_BL_PSTEP is bound.
        LR_BL_PSTEP->REPLACE_MFSI_BY_MFMI( IF_IMFXC = LF_IMFXC
                                           IR_MFMI  = LR_PR_RTESPV_OLD->R_MFMI ).
      else.

***     Add old MFMI to New and keep reference
        assign <S_BUFFER>-R_MFMI->* to <T_MFMI_NEW>.
        append <S_MFMI> to <T_MFMI_NEW> assigning <S_MFMI>.

***     Keep information of MFSI
        assign LR_PR_RTESPV_OLD->R_MFSI->* to <T_MFSI>.
        if <T_MFSI> is assigned.
          read table <T_MFSI> assigning <S_MFSI> with key ('IMFXC') = LF_IMFXC.
          if SY-SUBRC eq 0.
            move-corresponding <S_MFSI> to <S_MFMI>.
          endif.
        endif.

      endif.

***   Set new MFMI to Selected Route
      <S_XCOMP_RTESEL_NEW>-R_RTESEL->SET_MFMI( IR_MFMI = <S_BUFFER>-R_MFMI ).

***   X-Connect no longer needed
      delete <S_XCOMP_RTESEL_NEW>-T_IMFXC_IN where TABLE_LINE eq LF_IMFXC.

    endloop.

*** Remove empty Routes
    delete RT_XCOMP_RTESEL where R_RTESEL is initial.

  endmethod.
  method HANDLE_DESERIALIZE.

*** Deserialization requested
    move ABAP_TRUE to ME->F_DESERIALIZE_REQ.

*** Ensure all Events were processed before Deserialization
    ME->R_GATE->RAISE_EVENTS( ).

*** If Deserialization still required
    if ME->F_DESERIALIZE_REQ eq ABAP_TRUE.
      SUPER->HANDLE_DESERIALIZE( ).

***   Process Events that occure after Deserialization (e.g. Determination of Selected Route)
      ME->R_GATE->RAISE_EVENTS( ).

***   Deserialization completed
      clear ME->F_DESERIALIZE_REQ.
    else.
***   Already processed
      return.
    endif.

  endmethod.
  method HANDLE_EVENT.

    SUPER->HANDLE_EVENT( IF_IEVNT         = IF_IEVNT
                         IT_GATE_PROVIDER = IT_GATE_PROVIDER ).

    case IF_IEVNT.
      when C_IEVNT_I_RECALC_EVQTY_IN.
        ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_EVQTY_IN_CHANGED ).

    endcase.

  endmethod.
  method HANDLE_INIT_EVQTY.

    types: begin of YS_EVQTY_CHILD,
             S_EVQTY type ZVCXI_XCSR_S_EVQTY,
             NOUTT   type ZVCXI_PXS_NOUTT,
             NOUPS   type ZVCXI_PXS_NOUPS,
           end   of YS_EVQTY_CHILD,
           YT_EVQTY_CHILD type standard table of YS_EVQTY_CHILD.

    data: LF_TABIX type I,
          LF_NOUTT type ZVCXI_PXS_NOUTT,
          LF_MFRAT type ZVCXI_XCSP_MFRAT.
    data: LS_EVQTY       type        ZVCXI_XCSR_S_EVQTY,
          LS_EVQTY_CHILD type        ZVCXI_XCSR_S_EVQTY.
    data: LT_GATE_CHILD  type        /VCXI/VKSR_TT_GATE,
          LT_EVQTY_CHILD type        YT_EVQTY_CHILD.
    data: LR_GATE     type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_FG    type ref to ZIF_VCXI_PXSS_FG,
          LR_PR_XCONO type ref to ZCL_VCXI_PXSS_PR_XCONO.
    field-symbols: <S_EVQTY_CHILD> type YS_EVQTY_CHILD.


***--------------------------------------------------------------------------------------
*** Get Evaluation Quantity
    move ME->GET_EVQTY( ) to LS_EVQTY.
    clear: LS_EVQTY-EVQTY.

*** Get Provider for Output including children
    ME->GET_PRVDR_OUTPUT( importing ET_GATE_CHILD = LT_GATE_CHILD ).
    ME->R_GATE->SORT_GATE( changing CT_GATE = LT_GATE_CHILD ).

*** Loop at all children
    loop at LT_GATE_CHILD into LR_GATE.
***--------------------------------------------------------------------------------------
      case type of LR_GATE->R_CLSPR.
***     Gate is a Finished Good
        when type ZIF_VCXI_PXSS_FG into LR_PR_FG.
***       Get Detials for Finished Good
          append initial line to LT_EVQTY_CHILD assigning <S_EVQTY_CHILD>.
          LF_TABIX = SY-TABIX.
          ME->GET_EVQTY_BY_FG( exporting IR_GATE_FG = LR_GATE
                               importing ES_EVQTY   = <S_EVQTY_CHILD>-S_EVQTY
                                         EF_NOUTT   = <S_EVQTY_CHILD>-NOUTT
                                         EF_NOUPS   = <S_EVQTY_CHILD>-NOUPS ).

***       After MBQ, don't consider the co-products
          if LF_TABIX gt 1.
            if LR_PR_FG->GET_MATNR( ) is not initial.
              clear: <S_EVQTY_CHILD>-NOUTT,
                     <S_EVQTY_CHILD>-S_EVQTY-EVQTY.
            endif.
          endif.

***       Add Child #Outs to Total #Outs
          add <S_EVQTY_CHILD>-NOUTT to LF_NOUTT.


***--------------------------------------------------------------------------------------
***     Check Gate is Connection Out
        when type ZCL_VCXI_PXSS_PR_XCONO into LR_PR_XCONO.
***       Get Details for Connection Out
          append initial line to LT_EVQTY_CHILD assigning <S_EVQTY_CHILD>.
          LF_TABIX = SY-TABIX.
          ME->GET_EVQTY_BY_XCONO( exporting IR_GATE_XCONO = LR_GATE
                                            IF_TABIX      = LF_TABIX
                                  importing ES_EVQTY      = <S_EVQTY_CHILD>-S_EVQTY
                                            EF_NOUTT      = <S_EVQTY_CHILD>-NOUTT
                                            EF_NOUPS      = <S_EVQTY_CHILD>-NOUPS ).
***       Add Child #Outs to Total #Outs
          add <S_EVQTY_CHILD>-NOUTT to LF_NOUTT.
      endcase.

    endloop.


***--------------------------------------------------------------------------------------
*** Find maximum Evaluation Quantity
    loop at LT_EVQTY_CHILD assigning <S_EVQTY_CHILD>.
***   Ensure the determination was successful
      check <S_EVQTY_CHILD>-S_EVQTY-EVQTY_UOM is not initial and
            <S_EVQTY_CHILD>-NOUTT is not initial.

      clear LS_EVQTY_CHILD-EVQTY.
      LS_EVQTY_CHILD-EVQTY     = <S_EVQTY_CHILD>-S_EVQTY-EVQTY * ( LF_NOUTT / <S_EVQTY_CHILD>-NOUTT ).
      LS_EVQTY_CHILD-EVQTY_UOM = <S_EVQTY_CHILD>-S_EVQTY-EVQTY_UOM.

      if ZCL_VCXI_XCS_SERVICE_CALC=>COMPARE_WITH_ANY( IF_CALCV_1     = LS_EVQTY_CHILD-EVQTY
                                                      IF_CALCV_UOM_1 = LS_EVQTY_CHILD-EVQTY_UOM
                                                      IF_CALCV_2     = LS_EVQTY-EVQTY
                                                      IF_CALCV_UOM_2 = LS_EVQTY-EVQTY_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_GT ).
        move LS_EVQTY_CHILD to LS_EVQTY.
        LF_MFRAT = <S_EVQTY_CHILD>-NOUPS.
      endif.
    endloop.

*** Set Evaluation Quantity and Material Flow Ratio
    ME->SET_EVQTY( IS_EVQTY = LS_EVQTY ).
    ME->SET_MFRAT( IF_MFRAT = LF_MFRAT ).

  endmethod.
  method HANDLE_PROD_FILLED.

    data: LR_BL_PRTE type ref to ZCL_VCXI_XCSR_BL_PRTE,
          LR_CX_CKX  type ref to /VCXI/CX_CKX.

    try.
***     Copy own selected route and ignore provided one
        move ME->R_RTESEL->COPY( ) to LR_BL_PRTE.

***     Continue with Standard
        SUPER->HANDLE_PROD_FILLED( IR_BL_PRTE = LR_BL_PRTE ).

      catch /VCXI/CX_CKX into LR_CX_CKX.
        ME->R_GATE->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
    endtry.

  endmethod.
  method HANDLE_REBUILD_BL_PSTEP.

    data: LF_SIMILAR      type          ABAP_BOOL.
    data: LT_BL_PSTEP_NEW type          ZVCXI_XCSR_TT_BL_PSTEP,
          LT_PSTEP_OLD    type          /VCXI/CKX_TT_OBJECT,
          LT_PSTEP_NEW    type          /VCXI/CKX_TT_OBJECT,
          LT_IPSEQ_OLD    type table of ZVCXI_XCSR_TT_RANGE_IPSEQ,
          LT_IPSEQ_NEW    type table of ZVCXI_XCSR_TT_RANGE_IPSEQ,
          LT_COMBW_OLD    type table of ZVCXI_PXS_COMBW,
          LT_COMBW_NEW    type table of ZVCXI_PXS_COMBW,
          LT_RTE_LDIM_OLD type          /VCXI/VSMR_TT_RTE_LDIM,
          LT_RTE_LVAL_OLD type          /VCXI/VSMR_TT_RTE_LVAL,
          LT_RTE_LDIM_NEW type          /VCXI/VSMR_TT_RTE_LDIM,
          LT_RTE_LVAL_NEW type          /VCXI/VSMR_TT_RTE_LVAL,
          LT_CSPLIT_NEW   type          ZVCXI_XCSR_TT_CSPLIT.
    data: LI_WERKS_OLD    type          /VCXI/CL_VSMR_RTE_PSTEP=>YI_WERKS.
    data: LR_BL_PSTEP     type ref to   ZCL_VCXI_XCSR_BL_PSTEP,
          LR_PX_BL_PSTEP  type ref to   ZCL_VCXI_PXSR_BL_PSTEP,
          LR_BL_PSTEP_OLD type ref to   ZCL_VCXI_XCSR_BL_PSTEP,
          LR_BL_PSTEP_NEW type ref to   ZCL_VCXI_XCSR_BL_PSTEP,
          LR_MFMI_NEW     type ref to   DATA,
          LR_MFSI_NEW     type ref to   DATA.
    field-symbols: <T_MFMI_OLD> type standard table,
                   <T_MFMI_NEW> type standard table,
                   <T_MFSI_OLD> type standard table,
                   <T_MFSI_NEW> type standard table.

*** Be positiv
    move ABAP_TRUE to LF_SIMILAR.

***--------------------------------------------------------------------------------------
*** Compare Plant
    LI_WERKS_OLD = ME->I_WERKS.
    ME->I_WERKS  = ME->GET_WERKS( ).
    if LI_WERKS_OLD ne ME->I_WERKS.
      move ABAP_FALSE to LF_SIMILAR.
    endif.

***--------------------------------------------------------------------------------------
*** Get Production Steps of old BL PSteps
    loop at ME->T_BL_PSTEP into LR_BL_PSTEP.
      append LR_BL_PSTEP->R_PSTEP to LT_PSTEP_OLD.
      append LR_BL_PSTEP->I_IPSEQ to LT_IPSEQ_OLD.

      move LR_BL_PSTEP ?to LR_PX_BL_PSTEP.
      append LR_PX_BL_PSTEP->F_COMBW to LT_COMBW_OLD.
    endloop.
    ME->GET_STRICT_LIMITS( exporting IT_BL_PSTEP = ME->T_BL_PSTEP
                           importing ET_RTE_LDIM = LT_RTE_LDIM_OLD
                                     ET_RTE_LVAL = LT_RTE_LVAL_OLD ).

*** Get new BL PSteps
    LT_BL_PSTEP_NEW = ME->GET_BL_PSTEP( ).

*** Get Production Steps of new BL PSteps
    loop at LT_BL_PSTEP_NEW into LR_BL_PSTEP.
      append LR_BL_PSTEP->R_PSTEP to LT_PSTEP_NEW.
      append LR_BL_PSTEP->I_IPSEQ to LT_IPSEQ_NEW.

      move LR_BL_PSTEP ?to LR_PX_BL_PSTEP.
      append LR_PX_BL_PSTEP->F_COMBW to LT_COMBW_NEW.
    endloop.
    ME->GET_STRICT_LIMITS( exporting IT_BL_PSTEP = LT_BL_PSTEP_NEW
                           importing ET_RTE_LDIM = LT_RTE_LDIM_NEW
                                     ET_RTE_LVAL = LT_RTE_LVAL_NEW ).

***--------------------------------------------------------------------------------------
*** Compare Strict Limits
    if LT_RTE_LDIM_OLD ne LT_RTE_LDIM_NEW or
       LT_RTE_LVAL_OLD ne LT_RTE_LVAL_NEW.
      move ABAP_FALSE to LF_SIMILAR.
    endif.

***--------------------------------------------------------------------------------------
*** Get Material Flow Material In
    LR_MFMI_NEW = ME->GET_MFMI( ).

    if ( ME->R_MFMI is     bound and LR_MFMI_NEW is     bound ) or
       ( ME->R_MFMI is not bound and LR_MFMI_NEW is not bound ).
      if ME->R_MFMI is bound and LR_MFMI_NEW is bound.
        assign ME->R_MFMI->*  to <T_MFMI_OLD>.
        assign LR_MFMI_NEW->* to <T_MFMI_NEW>.
        if <T_MFMI_OLD> ne <T_MFMI_NEW>.
          move ABAP_FALSE to LF_SIMILAR.
        endif.
      endif.
    else.
      move ABAP_FALSE to LF_SIMILAR.
    endif.

***--------------------------------------------------------------------------------------
*** Get Material Flow SFG In
    LR_MFSI_NEW = ME->GET_MFSI( ).

    if ( ME->R_MFSI is     bound and LR_MFSI_NEW is     bound ) or
       ( ME->R_MFSI is not bound and LR_MFSI_NEW is not bound ).
      if ME->R_MFSI is bound and LR_MFSI_NEW is bound.
        assign ME->R_MFSI->*  to <T_MFSI_OLD>.
        assign LR_MFSI_NEW->* to <T_MFSI_NEW>.
        if <T_MFSI_OLD> ne <T_MFSI_NEW>.
          move ABAP_FALSE to LF_SIMILAR.
        endif.
      endif.
    else.
      move ABAP_FALSE to LF_SIMILAR.
    endif.

***--------------------------------------------------------------------------------------
*** Compare Cost Split if similar
    LT_CSPLIT_NEW = ME->GET_CSPLIT( ).
    if ME->T_CSPLIT ne LT_CSPLIT_NEW.
      move ABAP_FALSE to LF_SIMILAR.
    endif.

***--------------------------------------------------------------------------------------
*** Compare Production Steps if similar
    if LF_SIMILAR eq ABAP_TRUE.
      if LT_PSTEP_OLD eq LT_PSTEP_NEW and
         LT_IPSEQ_OLD eq LT_IPSEQ_NEW.
        loop at ME->T_BL_PSTEP into LR_BL_PSTEP_OLD.
          read table LT_BL_PSTEP_NEW into LR_BL_PSTEP_NEW index SY-TABIX.

          if LR_BL_PSTEP_OLD->COMPARE( IR_BL_PSTEP = LR_BL_PSTEP_NEW ) ne ABAP_TRUE.
            move ABAP_FALSE to LF_SIMILAR.
            exit.
          endif.
        endloop.
      else.
        move ABAP_FALSE to LF_SIMILAR.
      endif.
    endif.

    check LF_SIMILAR ne ABAP_TRUE.

***--------------------------------------------------------------------------------------
*** Use new BL PSteps
    move LR_MFMI_NEW     to ME->R_MFMI.
    move LR_MFSI_NEW     to ME->R_MFSI.
    move LT_CSPLIT_NEW   to ME->T_CSPLIT.
    move LT_BL_PSTEP_NEW to ME->T_BL_PSTEP.

    if LT_PSTEP_OLD    ne LT_PSTEP_NEW    or
       LT_IPSEQ_OLD    ne LT_IPSEQ_NEW    or
       LT_COMBW_OLD    ne LT_COMBW_NEW    or
       LT_RTE_LDIM_OLD ne LT_RTE_LDIM_NEW or
       LT_RTE_LVAL_OLD ne LT_RTE_LVAL_NEW.
***   Send Event
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_STRUC_CHANGED ).
    else.
***   Send Event
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_BL_PSTEP_CHANGED ).
    endif.

  endmethod.
  method IS_DUMMY_ALLOWED.

    data: LR_GATE     type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_XFG   type ref to ZCL_VCXI_PXSS_PR_XFG,
          LR_PR_XCONI type ref to ZCL_VCXI_PXSS_PR_XCONI,
          LR_PR_XCONO type ref to ZCL_VCXI_PXSS_PR_XCONO.
    data: LT_GATE_CHILD_INPUT  type /VCXI/VKSR_TT_GATE,
          LT_GATE_CHILD_OUTPUT type /VCXI/VKSR_TT_GATE.


***--------------------------------------------------------------------------------------
*** Allow Fake Route if no Production Steps are needed.
    if ME->T_BL_PSTEP is initial.
      move ABAP_TRUE to RF_ALLOWED.
    endif.

***--------------------------------------------------------------------------------------
*** Check: Output Finished Good and no Production Steps
    ME->GET_PRVDR_OUTPUT( importing ET_GATE_CHILD = LT_GATE_CHILD_OUTPUT ).
    loop at LT_GATE_CHILD_OUTPUT into LR_GATE.
      if LR_GATE->R_CLSPR is instance of ZCL_VCXI_PXSS_PR_XFG.
        LR_PR_XFG ?= LR_GATE->R_CLSPR.
        exit. " First FG is fine
      else.
        clear LR_PR_XFG.
      endif.
    endloop.

    if LR_PR_XFG      is bound and
       ME->T_BL_PSTEP is initial.
***   No Production Steps for Finished Good Component -> No Dummy
      move ABAP_FALSE to RF_ALLOWED.
      return.
    endif.

***--------------------------------------------------------------------------------------
*** Check complete empty component (XCONI->XCONO)
    ME->GET_PRVDR_INPUT( importing ET_GATE_CHILD = LT_GATE_CHILD_INPUT ).
    loop at LT_GATE_CHILD_INPUT into LR_GATE.
      if LR_GATE->R_CLSPR is instance of ZCL_VCXI_PXSS_PR_XCONI.
        LR_PR_XCONI ?= LR_GATE->R_CLSPR.
      else.
        clear LR_PR_XCONI.
        exit.
      endif.
    endloop.

    loop at LT_GATE_CHILD_OUTPUT into LR_GATE.
      if LR_GATE->R_CLSPR is instance of ZCL_VCXI_PXSS_PR_XCONO.
        LR_PR_XCONO ?= LR_GATE->R_CLSPR.
      else.
        clear LR_PR_XCONO.
        exit.
      endif.
    endloop.

    if LR_PR_XCONI is bound and
       LR_PR_XCONO is bound and
       ME->T_BL_PSTEP is initial.
***   Empty Component without Production Steps -> No Dummy
      move ABAP_FALSE to RF_ALLOWED.
      return.
    endif.

  endmethod.
  method IS_FILL_PROD_ALLOWED.

    data: LT_PRVDR_RTESPV type /VCXI/VKSR_TT_GATE,
          LT_PRVDR        type /VCXI/VKSR_TT_GATE.
    data: LR_PRVDR     type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_RTESPV type ref to ZCL_VCXI_XCSR_PR_RTESPV.

***--------------------------------------------------------------------------------------
*** Refresh Auto and get Selected Route
    ME->REFRESH_AUTO( ).
    ME->R_GATE->RAISE_EVENTS( ).

***--------------------------------------------------------------------------------------
    read table ME->T_RTEALT with key TABLE_LINE = ME->R_RTESEL
                            transporting no fields.
    check SY-SUBRC eq 0.

*** Be positive
    move ABAP_TRUE to EF_ALLOWED.

*** Ignore own Element for Routing Supervisor check
    append ME->R_GATE to CT_GATE_IGNORE.

***--------------------------------------------------------------------------------------
*** Find Provider for Routing Supervisor
    LT_PRVDR_RTESPV = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_XCSR_PR_RTESPV=>C_IPRVT_XCS_RTESPV
                                             IF_INUSE = ABAP_TRUE ).
    loop at LT_PRVDR_RTESPV into LR_PRVDR.

***   Check Routing Supervisor is not ignored
      read table CT_GATE_IGNORE with key TABLE_LINE = LR_PRVDR transporting no fields.
      check SY-SUBRC ne 0.

***   Get PR Reference
      try.
          move LR_PRVDR->R_CLSPR ?to LR_PR_RTESPV.
          check LR_PR_RTESPV is bound.
        catch CX_SY_MOVE_CAST_ERROR.
          continue.
      endtry.

***   Refresh Auto and get Selected Route
      LR_PR_RTESPV->REFRESH_AUTO( ).
      ME->R_GATE->RAISE_EVENTS( ).

***   Check if Fill is allowed
      LR_PR_RTESPV->IS_FILL_PROD_ALLOWED( importing EF_ALLOWED     = EF_ALLOWED
                                          changing  CT_GATE_IGNORE = CT_GATE_IGNORE ).
      if EF_ALLOWED ne ABAP_TRUE.
        exit.
      endif.
    endloop.

    check EF_ALLOWED eq ABAP_TRUE.

***--------------------------------------------------------------------------------------
*** Check Status of all Provider
    LT_PRVDR = ME->R_GATE->GET_PRVDR( IF_INUSE = ABAP_TRUE ).
    loop at LT_PRVDR into LR_PRVDR.

***   Don't check other Routing Supervisors
      read table LT_PRVDR_RTESPV with key TABLE_LINE = LR_PRVDR
                                 transporting no fields.
      check SY-SUBRC ne 0.

***   Only check PR Class Status if Provider is in line to me
      if LR_PRVDR->IS_IN_LINE( IR_GATE = ME->R_GATE ) eq ABAP_TRUE or
         ME->IS_IN_LINE_RTESPV( IR_PRVDR        = LR_PRVDR
                                IT_PRVDR_RTESPV = LT_PRVDR_RTESPV ) eq ABAP_TRUE.
        if LR_PRVDR->R_CLSPR is bound and
           LR_PRVDR->R_CLSPR->GET_STATUS( ) ne /VCXI/CL_VKSR_SERVICE=>C_ELMST_G.
          move ABAP_FALSE to EF_ALLOWED.
          exit.
        endif.

***     Check Status through Gate (includes child status)
      else.
        if LR_PRVDR->GET_STATUS( ) ne /VCXI/CL_VKSR_SERVICE=>C_ELMST_G.
          move ABAP_FALSE to EF_ALLOWED.
          exit.
        endif.
      endif.
    endloop.

  endmethod.
  method REDETERMINE_DUMMY.

    data:  LT_BL_PRTE   type        ZVCXI_XCSR_TT_BL_PRTE.
    data:  LR_BL_PRTE   type ref to ZCL_VCXI_XCSR_BL_PRTE.

***--------------------------------------------------------------------------------------
*** Remove all Machine Customizing Routes
    delete ME->T_RTEALT where TABLE_LINE->R_RTE_PRTE->F_RSRCE eq /VCXI/CL_VSMR_RTE_MGR=>C_RSRCE_MACHCUST.
    delete ME->T_RTEINV where TABLE_LINE->R_RTE_PRTE->F_RSRCE eq /VCXI/CL_VSMR_RTE_MGR=>C_RSRCE_MACHCUST.
    delete ME->T_RTEHID where TABLE_LINE->R_RTE_PRTE->F_RSRCE eq /VCXI/CL_VSMR_RTE_MGR=>C_RSRCE_MACHCUST.

***--------------------------------------------------------------------------------------
*** Create Dummy Route
    LR_BL_PRTE = ME->CREATE_BL_PRTE( ).

*** Copy to clear shared references
    LR_BL_PRTE = LR_BL_PRTE->COPY( ).
    move /VCXI/CL_VSMR_RTE_MGR=>C_RSRCE_MACHCUST to LR_BL_PRTE->R_RTE_PRTE->F_RSRCE.

*** Set Technical Checks to On
    LR_BL_PRTE->SET_TECHC( IF_TECHC = ABAP_TRUE ).

    append LR_BL_PRTE to LT_BL_PRTE.

***--------------------------------------------------------------------------------------
*** Validate Routes
    ME->VALIDATE( changing CT_BL_PRTE = LT_BL_PRTE ).

*** Run Evaluation if within Relevance Scope
    ME->EVALUATE_BL_PRTE( IT_BL_PRTE = LT_BL_PRTE ).

  endmethod.
  method REFRESH_AUTO.

*** Checks prior to Refresh
    if IF_FORCE ne ABAP_TRUE.
      check ME->F_REDETERMINATION_REQ eq ABAP_TRUE.
    endif.

*** Process Standard
    SUPER->REFRESH_AUTO( IF_FORCE = IF_FORCE ).

*** Add Fake Route if allowed
    if ME->IS_DUMMY_ALLOWED( ) eq ABAP_TRUE.
      ME->REDETERMINE_DUMMY( ).
    endif.

  endmethod.
  method SET_EVENT_HANDLER.

    set handler ME->HANDLE_PROD_FILLED for IR_PR_RTESPV activation IF_ACTIVATION.

  endmethod.
  method SET_MFRAT.

    data:  LF_CHANGED type ABAP_BOOL.
    data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

    LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_MFRAT ).

    LS_PARAM-ATFLV = IF_MFRAT.
    LS_PARAM-SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_CALC.

    LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

    if LF_CHANGED eq ABAP_TRUE.
***   Send Event
      ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_MFRAT_CHANGED ).
    endif.

  endmethod.
  method TURN_PCDIR.

    data: LF_PCDIR     type ZVCXI_P0SP_PCDIR,
          LF_PREVIOUS  type ABAP_BOOL,
          LF_MANDATORY type ABAP_BOOL,
          LF_IPSTP     type /VCXI/VSMC_IPSTP,
          LF_ILTYP     type /VCXI/VSMC_ILTYP.
    data: LT_ILTYP_PSTEP   type /VCXI/CKX_TT_ID,
          LT_ILTYP_ARBPL   type /VCXI/CKX_TT_ID,
          LT_MSG           type /VCXI/CKXM_TT_MSG,
          LT_RTE_PSTEP_ORG type /VCXI/VSMR_TT_RTE_PSTEP,
          LT_RTE_PSTEP_NEW type /VCXI/VSMR_TT_RTE_PSTEP,
          LT_MSG_ORG       type /VCXI/CKXM_TT_MSG.
    data: LR_RTE_PSTEP     type ref to /VCXI/CL_VSMR_RTE_PSTEP,
          LR_PCDIR         type ref to ZIF_VCXI_PXSR_PCDIR,
          LR_RTE_PSTEP_ORG type ref to /VCXI/CL_VSMR_RTE_PSTEP,
          LR_BL_PSTEP_ORG  type ref to ZCL_VCXI_XCSR_BL_PSTEP,
          LR_RTE_PSEQ_NEW  type ref to /VCXI/CL_VSMR_RTE_PSEQ,
          LR_RTE_PSTEP_NEW type ref to /VCXI/CL_VSMR_RTE_PSTEP,
          LR_BL_PSTEP_NEW  type ref to ZCL_VCXI_XCSR_BL_PSTEP.

    check IR_RTE_ARBPL->R_ARBPL is bound.

*** Get current Direction
    if IF_PCDIR_PREV is not initial.
      loop at IR_RTE_ARBPL->T_RTE_PSTEP into LR_RTE_PSTEP.
        try.
            move LR_RTE_PSTEP->R_BLOBJ ?to LR_PCDIR.
            check LR_PCDIR is bound.

            move LR_PCDIR->F_PCDIR to LF_PCDIR.

            if LR_PCDIR->F_PCDOP eq ZIF_VCXI_PXSR_PCDIR=>C_PCDOP_PREVIOUS.
              move ABAP_TRUE to LF_PREVIOUS.
            endif.
            exit.
          catch CX_SY_MOVE_CAST_ERROR.
            continue.
        endtry.
      endloop.
    endif.

    if not ( LF_PREVIOUS   eq ABAP_TRUE and
             IF_PCDIR_PREV is not initial and
             IF_PCDIR_PREV ne LF_PCDIR ).
***   Turn not because of prefere previous
      clear LF_PREVIOUS.

      check IR_RTE_ARBPL->T_MSG is not initial.
***   Get Error Messages
      move IR_RTE_ARBPL->T_MSG  to LT_MSG.
      delete LT_MSG where MSGTY eq 'S'
                     or   MSGTY eq 'I'
                     or   MSGTY eq 'W'.
      check LT_MSG is not initial.
    endif.

***----------------------------------------------------------------------------
*** Identify Limits that allow turning
    loop at IR_RTE_ARBPL->T_RTE_PSTEP into LR_RTE_PSTEP.
      try.
          move LR_RTE_PSTEP->R_BLOBJ ?to LR_PCDIR.
          check LR_PCDIR is bound.
        catch CX_SY_MOVE_CAST_ERROR.
          continue.
      endtry.

      if LR_PCDIR->F_PCDOP eq ZIF_VCXI_PXSR_PCDIR=>C_PCDOP_MANDATORY.
        move ABAP_TRUE to LF_MANDATORY.
        exit.
      endif.

      move LR_RTE_PSTEP->R_PSTEP->/VCXI/IF_CKX_OBJECT~GET_ID( ) to LF_IPSTP.
      ZCL_VCXI_P0SR_CUST_PSTEP=>GET_PSTEP_INFO( exporting IF_IPSTP = LF_IPSTP
                                                importing ET_ILTYP = LT_ILTYP_PSTEP ).
      append lines of LT_ILTYP_PSTEP to LT_ILTYP_ARBPL.
    endloop.

    check LF_MANDATORY ne ABAP_TRUE.

    sort LT_ILTYP_ARBPL.
    delete adjacent duplicates from LT_ILTYP_ARBPL.

***----------------------------------------------------------------------------
    if LF_PREVIOUS ne ABAP_TRUE.
***   Ignore Messages that can be resolved by Turn
      loop at LT_ILTYP_ARBPL into LF_ILTYP.
        delete LT_MSG where MSGV2 eq LF_ILTYP.
      endloop.

***   Check no other Error Message exists...
      check LT_MSG is initial.
    endif.

***----------------------------------------------------------------------------
*** Buffer to be able to turn it back
    move IR_RTE_ARBPL->T_RTE_PSTEP to LT_RTE_PSTEP_ORG.
    move IR_RTE_ARBPL->T_MSG       to LT_MSG_ORG.


    loop at IR_RTE_ARBPL->T_RTE_PSTEP into LR_RTE_PSTEP_ORG.
***   Create new Production Steps
      if LR_RTE_PSTEP_ORG->R_RTE_PSEQ is bound.
        create object LR_RTE_PSEQ_NEW
          exporting
            IR_PSEQ     = LR_RTE_PSTEP_ORG->R_RTE_PSEQ->R_PSEQ
            IR_RTE_PSEQ = LR_RTE_PSTEP_ORG->R_RTE_PSEQ->R_RTE_PSEQ.
        move LR_RTE_PSEQ_NEW->R_RTE_PSTEP to LR_RTE_PSTEP_NEW.
      else.
        create object LR_RTE_PSTEP_NEW
          exporting
            IR_PSTEP = LR_RTE_PSTEP_ORG->R_PSTEP.
      endif.
      append LR_RTE_PSTEP_NEW to LT_RTE_PSTEP_NEW.

***   Create Copy of BL Production Steps
      try.
          move LR_RTE_PSTEP_ORG->R_BLOBJ ?to LR_BL_PSTEP_ORG.
          if LR_BL_PSTEP_ORG is bound.
            LR_BL_PSTEP_NEW = LR_BL_PSTEP_ORG->COPY( ).
            move LR_BL_PSTEP_NEW to LR_RTE_PSTEP_NEW->R_BLOBJ.
          endif.
        catch CX_SY_MOVE_CAST_ERROR.                    "#EC NO_HANDLER
      endtry.

***   Turn
      try.
          move LR_RTE_PSTEP_NEW->R_BLOBJ ?to LR_PCDIR.
          if LR_PCDIR is bound.
            case LR_PCDIR->F_PCDIR.
              when 'A'.
                LR_PCDIR->SET_PCDIR( IF_PCDIR = 'B' ).
              when 'B'.
                LR_PCDIR->SET_PCDIR( IF_PCDIR = 'A' ).
            endcase.
          endif.
        catch CX_SY_MOVE_CAST_ERROR.
          continue.
      endtry.

***   Add new Limits
      LR_BL_PSTEP_NEW->ADD_LIMITS_TO_RTE_PSTEP( IR_RTE_PSTEP = LR_RTE_PSTEP_NEW ).
    endloop.

*** Set new Production Steps
    move LT_RTE_PSTEP_NEW to IR_RTE_ARBPL->T_RTE_PSTEP.

***----------------------------------------------------------------------------
*** Check Limits on Work Center Level
    IR_RTE_ARBPL->CHECK_LIMITS( ).

*** Get Error Messages
    move IR_RTE_ARBPL->T_MSG  to LT_MSG.
    delete LT_MSG where MSGTY eq 'S'
                   or   MSGTY eq 'I'
                   or   MSGTY eq 'W'.
    if LT_MSG is not initial.
***   Return to Original Direction
      move LT_RTE_PSTEP_ORG to IR_RTE_ARBPL->T_RTE_PSTEP.
      move LT_MSG_ORG       to IR_RTE_ARBPL->T_MSG.
    else.
***   Recheck complete Route
      move ABAP_TRUE to RF_RECHECK.
    endif.

  endmethod.
  method UPDATE_BL_PRTE_BY_RTE_DEF.

    data: LT_BL_PRTE     type        ZVCXI_XCSR_TT_BL_PRTE,
          LT_RTE_DEF_OLD type        ZVCXI_XCSR_TT_RTE_DEF.
    data: LR_BL_PRTE        type ref to ZCL_VCXI_XCSR_BL_PRTE.

***--------------------------------------------------------------------------------------
    if IT_RTE_DEF_OLD is supplied.
      move IT_RTE_DEF_OLD to LT_RTE_DEF_OLD.
    else.
      move ME->T_RTE_DEF  to LT_RTE_DEF_OLD.
    endif.

    if IT_BL_PRTE is supplied.
      move IT_BL_PRTE to LT_BL_PRTE.
    else.
      append lines of ME->T_RTEALT to LT_BL_PRTE.
      append lines of ME->T_RTEINV to LT_BL_PRTE.
      append lines of ME->T_RTEHID to LT_BL_PRTE.
    endif.


***--------------------------------------------------------------------------------------
    if ME->T_RTE_DEF is not initial.
***   Standard Processing
      SUPER->UPDATE_BL_PRTE_BY_RTE_DEF( IT_RTE_DEF_OLD = LT_RTE_DEF_OLD
                                        IT_BL_PRTE     = LT_BL_PRTE ).
    else.

***--------------------------------------------------------------------------------------
***   Special Processing for Dummy Routes
      loop at LT_BL_PRTE into LR_BL_PRTE.
***     Update Date
        LR_BL_PRTE->SET_DATE( IF_DATE = ME->F_DATE ).

***     Update Vendor required
        LR_BL_PRTE->SET_LIFNR_REQ( IF_LIFNR_REQ = ME->F_LIFNR_REQ ).

***     Update Material Flow Material In
        LR_BL_PRTE->SET_MFMI( IR_MFMI = ME->R_MFMI ).

***     Update Material Flow SFG In
        LR_BL_PRTE->SET_MFSI( IR_MFSI = ME->R_MFSI ).

***     Update Cost Split
        LR_BL_PRTE->SET_CSPLIT( IT_CSPLIT = ME->T_CSPLIT ).

      endloop.

***   Validate Routes
      ME->VALIDATE( changing CT_BL_PRTE = LT_BL_PRTE ).

***   Evaluate Routes
      ME->EVALUATE_BL_PRTE( IT_BL_PRTE = LT_BL_PRTE ).

    endif.

  endmethod.
  method VALIDATE.

    data: LF_RECHECK type        ABAP_BOOL.
    data: LR_BL_PRTE  type ref to ZCL_VCXI_XCSR_BL_PRTE.

    SUPER->VALIDATE( changing CT_BL_PRTE = CT_BL_PRTE ).

***------------------------------------------------------------------------------------------------
*** Process Routes
    loop at CT_BL_PRTE into LR_BL_PRTE.
      clear LF_RECHECK.

***   Update Material Flow Ratio
      cast ZCL_VCXI_PXSR_BL_PRTE( LR_BL_PRTE )->SET_MFRAT( IF_MFRAT = ME->GET_MFRAT( ) ).

***------------------------------------------------------------------------------------------------
***   Sheet Rotation
      if ME->VALIDATE_PCDIR( IR_BL_PRTE = LR_BL_PRTE ) eq ABAP_TRUE.
        move ABAP_TRUE to LF_RECHECK.
      endif.

***   Roll Handling
      if ME->VALIDATE_RHNDL( IR_BL_PRTE = LR_BL_PRTE ) eq ABAP_TRUE.
        move ABAP_TRUE to LF_RECHECK.
      endif.

***   Recheck
      if LF_RECHECK eq ABAP_TRUE.
        LR_BL_PRTE->CHECK( ).
        LR_BL_PRTE->INIT_RELPO( ).
      endif.
    endloop.

  endmethod.
method VALIDATE_PCDIR.

  data: LF_PCDIR      type        ZVCXI_P0SP_PCDIR.
  data: LR_BL_PRTE   type ref to ZCL_VCXI_PXSR_BL_PRTE,
        LR_RTE_ARBPL type ref to /VCXI/CL_VSMR_RTE_ARBPL,
        LR_RTE_PSTEP type ref to /VCXI/CL_VSMR_RTE_PSTEP,
        LR_PCDIR     type ref to ZIF_VCXI_PXSR_PCDIR.

  try.
      move IR_BL_PRTE ?to LR_BL_PRTE.
      check LR_BL_PRTE is bound.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

  loop at LR_BL_PRTE->R_RTE_PRTE->T_RTE_ARBPL into LR_RTE_ARBPL.

***--------------------------------------------------------------------------------------
*** Check Mandetory Directions missmatch will not be fixed automatically
    try.

***     Get PC Direction of Work Center
        LF_PCDIR = LR_BL_PRTE->GET_PCDIR_BY_RTE_ARBPL( IR_RTE_ARBPL = LR_RTE_ARBPL ).

      catch /VCXI/CX_CKX.
        exit.
    endtry.

***--------------------------------------------------------------------------------------
*** Update Direction
    loop at LR_RTE_ARBPL->T_RTE_PSTEP into LR_RTE_PSTEP.
      try.
          move LR_RTE_PSTEP->R_BLOBJ ?to LR_PCDIR.
          check LR_PCDIR is bound.
        catch CX_SY_MOVE_CAST_ERROR.
          continue.
      endtry.

      if LR_PCDIR->F_PCDIR ne LF_PCDIR.

***     Set Direction
        LR_PCDIR->SET_PCDIR( IF_PCDIR = LF_PCDIR ).
        move ABAP_TRUE to RF_RECHECK.

      endif.
    endloop.

  endloop.

*** Check
  if RF_RECHECK eq ABAP_TRUE.
    IR_BL_PRTE->CHECK( ).
  endif.

***--------------------------------------------------------------------------------------
*** Automatic Turn of Route
  clear LF_PCDIR.
  loop at LR_BL_PRTE->R_RTE_PRTE->T_RTE_ARBPL into LR_RTE_ARBPL.
    if ME->TURN_PCDIR( IR_RTE_ARBPL  = LR_RTE_ARBPL
                       IF_PCDIR_PREV = LF_PCDIR ) eq ABAP_TRUE.
      move ABAP_TRUE to RF_RECHECK.
    endif.

    if LR_BL_PRTE->R_RTE_PRTE->F_RSRCE ne ZCL_VCXI_PXSR_BL_PRTE=>C_RSRCE_USER.
      try.

***       Get PC Direction of Work Center
          LF_PCDIR = LR_BL_PRTE->GET_PCDIR_BY_RTE_ARBPL( IR_RTE_ARBPL = LR_RTE_ARBPL ).

        catch /VCXI/CX_CKX.
          clear LF_PCDIR.
      endtry.
    endif.
  endloop.

***--------------------------------------------------------------------------------------
*** Adjust PC Direction of Material Flow In
  clear LF_PCDIR.
  loop at LR_BL_PRTE->R_RTE_PRTE->T_RTE_ARBPL into LR_RTE_ARBPL.
    try.

***     Get PC Direction of Work Center
        LF_PCDIR = LR_BL_PRTE->GET_PCDIR_BY_RTE_ARBPL( IR_RTE_ARBPL = LR_RTE_ARBPL ).
        exit.

      catch /VCXI/CX_CKX.
        clear LF_PCDIR.
    endtry.
  endloop.

  LR_BL_PRTE->SET_PCDIR_OF_MFI( IF_PCDIR = LF_PCDIR ).

endmethod.
  method VALIDATE_RHNDL.

    "Validate only if Roll Handling is required by Sub-Class

  endmethod.
  method ZIF_VCXI_XCS_NGREP~FILL.

*** Get Selected Routes of Components
    data(LT_XCOMP_RTESEL) = ME->GET_XCOMP_RTESEL( ).

***--------------------------------------------------------------------------------------
*** Add Routes
    loop at LT_XCOMP_RTESEL into data(LS_XCOMP_RTESEL).
***   Add component as Group
      data(LF_GROUP_KEY) = CR_NETGRAPH_JSON->ADD_GROUP( IF_TITLE = 'Route' ).

***   Register Route to Node
      CR_NETGRAPH_JSON->REGISTER_TO_NODE( IR_OBJECT   = LS_XCOMP_RTESEL-R_RTESEL
                                          IF_NODE_KEY = LF_GROUP_KEY ).

***   Fill Group by Selected Route
      LS_XCOMP_RTESEL-R_RTESEL->ZIF_VCXI_XCS_NGREP~FILL( exporting IF_GROUP_KEY     = LF_GROUP_KEY
                                                         changing  CR_NETGRAPH_JSON = CR_NETGRAPH_JSON ).
    endloop.

****--------------------------------------------------------------------------------------
**** Add Connections between Routes
*    loop at LT_XCOMP_RTESEL into LS_XCOMP_RTESEL where T_IMFXC_OUT is not initial.
*
*    endloop.

  endmethod.
