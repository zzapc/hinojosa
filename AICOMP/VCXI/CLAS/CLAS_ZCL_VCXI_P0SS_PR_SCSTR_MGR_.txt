
class ZCL_VCXI_P0SS_PR_SCSTR_MGR definition
  public
  inheriting from /VCXI/CL_VKSR_CLSPR
  abstract
  create public .

public section.

  constants C_IEVNT_O_TRIM_ALLOC_CHANGED type /VCXI/VKSC_IEVNT value 'TRIM_ALLOC_CHANGED'. "#EC NOTEXT
  constants C_IPRVT_P0_SCSTR_MGR type /VCXI/VKSC_IPRVT value 'ZVCXI_P0SS_SCSTR_MGR'. "#EC NOTEXT
  constants C_PARID_DTLLT type /VCXI/VKS_PARID value 'ZVCXI_P0_DTLLT'. "#EC NOTEXT
  constants C_PARID_DTLRB type /VCXI/VKS_PARID value 'ZVCXI_P0_DTLRB'. "#EC NOTEXT
  constants C_PARID_DTWLT type /VCXI/VKS_PARID value 'ZVCXI_P0_DTWLT'. "#EC NOTEXT
  constants C_PARID_DTWRB type /VCXI/VKS_PARID value 'ZVCXI_P0_DTWRB'. "#EC NOTEXT
  constants C_PARID_OLLLT type /VCXI/VKS_PARID value 'ZVCXI_P0_OLLLT'. "#EC NOTEXT
  constants C_PARID_OLLRB type /VCXI/VKS_PARID value 'ZVCXI_P0_OLLRB'. "#EC NOTEXT
  constants C_PARID_OLWLT type /VCXI/VKS_PARID value 'ZVCXI_P0_OLWLT'. "#EC NOTEXT
  constants C_PARID_OLWRB type /VCXI/VKS_PARID value 'ZVCXI_P0_OLWRB'. "#EC NOTEXT
  constants C_PARID_SOPCR type /VCXI/VKS_PARID value 'ZVCXI_P0_SOPCR'. "#EC NOTEXT
  constants C_PARID_SOPLE type /VCXI/VKS_PARID value 'ZVCXI_P0_SOPLE'. "#EC NOTEXT
  constants C_PARID_TPLLT type /VCXI/VKS_PARID value 'ZVCXI_P0_TPLLT'. "#EC NOTEXT
  constants C_PARID_TPLRB type /VCXI/VKS_PARID value 'ZVCXI_P0_TPLRB'. "#EC NOTEXT
  constants C_PARID_TPSLT type /VCXI/VKS_PARID value 'ZVCXI_P0_TPSLT'. "#EC NOTEXT
  constants C_PARID_TPSRB type /VCXI/VKS_PARID value 'ZVCXI_P0_TPSRB'. "#EC NOTEXT
  constants C_SCSOP_ATTACHMENT type ZVCXI_P0S_SCSOP value 'ATTACHMENT'. "#EC NOTEXT
  constants C_SCSOP_CHOP type ZVCXI_P0S_SCSOP value 'CHOP'. "#EC NOTEXT
  constants C_SCSOP_CUTTING type ZVCXI_P0S_SCSOP value 'CUT'. "#EC NOTEXT
  constants C_SCSOP_SHTPR type ZVCXI_P0S_SCSOP value 'SHTPR'. "#EC NOTEXT
  constants C_SCSOP_SLIT_SCORE type ZVCXI_P0S_SCSOP value 'SLIT_SCORE'. "#EC NOTEXT
  constants C_TRIM_PARID_DTRIL type /VCXI/VKS_PARID value 'ZVCXI_P0_DTRIL'. "#EC NOTEXT
  constants C_TRIM_PARID_DTRIW type /VCXI/VKS_PARID value 'ZVCXI_P0_DTRIW'. "#EC NOTEXT
  constants C_TRIM_PARID_OLLEN type /VCXI/VKS_PARID value 'ZVCXI_P0_OLLEN'. "#EC NOTEXT
  constants C_TRIM_PARID_OLWID type /VCXI/VKS_PARID value 'ZVCXI_P0_OLWID'. "#EC NOTEXT
  constants C_TRIM_PARID_TRIPL type /VCXI/VKS_PARID value 'ZVCXI_P0_TRIPL'. "#EC NOTEXT
  constants C_TRIM_PARID_TRIPS type /VCXI/VKS_PARID value 'ZVCXI_P0_TRIPS'. "#EC NOTEXT
  data F_SSTRC type ZVCXI_P0SS_SSTRC read-only .
  data F_TSCOR_CUT type ZVCXI_P0SS_TSCOR read-only .

  type-pools ABAP .
  methods CHECK_NO_CALC
    importing
      !IF_CSCOR type ZVCXI_P0SS_CSCOR
      !IF_FNEST type ZVCXI_P0SS_FNEST
      !IF_ACTIV type FLAG
      !IF_SCSOP type ZVCXI_P0S_SCSOP
    returning
      value(RF_NO_CALC) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods NO_SCORES
    importing
      !IF_CSCOR type ZVCXI_P0SS_CSCOR
    returning
      value(RF_RETURN) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_TAPE_ACTIVE
    returning
      value(RF_ACTIVE) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_MS_SHTPR_ACTIVE
    importing
      !IF_INCL_CUT type ABAP_BOOL default ABAP_FALSE
    returning
      value(RF_ACTIVE) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_CHECK_INDIC_NEEDED
    returning
      value(RF_RETURN) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods GET_VALID_TRIM_DIFF
    importing
      !IF_AFTER_DIV type ABAP_BOOL default ABAP_FALSE
    exporting
      !ES_TRIML type ZVCXI_P0SS_S_TRIML
      !ES_TRIMS type ZVCXI_P0SS_S_TRIMS
    raising
      /VCXI/CX_CKX .
  methods GET_OLWID
    returning
      value(RS_OLWID) type ZVCXI_P0SS_S_OLWID
    raising
      /VCXI/CX_CKX .
  methods GET_TRIM
    importing
      !IF_PARID type /VCXI/VKS_PARID
    exporting
      !ES_TRITO type ZVCXI_P0SS_S_TRITO
      !ES_TRILT type ZVCXI_P0SS_S_TRILT
      !ES_TRIRB type ZVCXI_P0SS_S_TRIRB
      !ES_OVLTO type ZVCXI_P0SS_S_OVLTO
      !ES_OVLLT type ZVCXI_P0SS_S_OVLLT
      !ES_OVLRB type ZVCXI_P0SS_S_OVLRB
      !ES_TRILT_IO type ZVCXI_P0SS_S_TRILT
      !ES_TRIRB_IO type ZVCXI_P0SS_S_TRIRB
    raising
      /VCXI/CX_CKX .
  methods SET_TRIM
    importing
      !IF_PARID type /VCXI/VKS_PARID
      !IS_TRILT type ZVCXI_P0SS_S_TRILT optional
      !IS_TRIRB type ZVCXI_P0SS_S_TRIRB optional
      !IS_OVLLT type ZVCXI_P0SS_S_OVLLT optional
      !IS_OVLRB type ZVCXI_P0SS_S_OVLRB optional
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods GET_VALID_INDIC
    importing
      !IF_IGNORE_SCORE_C type ABAP_BOOL default ABAP_FALSE
      !IF_IGNORE_SCORE_L type ABAP_BOOL default ABAP_FALSE
      !IF_IGNORE_TAPE type ABAP_BOOL default ABAP_FALSE
      !IF_IGNORE_DIVISION type ABAP_BOOL default ABAP_FALSE
    returning
      value(RT_INDIC) type ZVCXI_P0SS_TT_INDIC
    raising
      /VCXI/CX_CKX .
  methods CONSTRUCTOR
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_ALL_VALID_SCSOP
    importing
      !IF_CSCOR type ZVCXI_P0SS_CSCOR optional
    returning
      value(RT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_BSTRL
    returning
      value(RF_BSTRL) type ZVCXI_P0SS_BSTRL
    raising
      /VCXI/CX_CKX .
  methods GET_BSTRW
    returning
      value(RF_BSTRW) type ZVCXI_P0SS_BSTRW
    raising
      /VCXI/CX_CKX .
  methods GET_DTRIL_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_DTRIW_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_FNEST
    returning
      value(RF_FNEST) type ZVCXI_P0SS_FNEST
    raising
      /VCXI/CX_CKX .
  methods GET_PTYPE
    returning
      value(RF_PTYPE) type ZVCXI_P0S_PTYPE
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP
    returning
      value(RT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_SOPCR
    returning
      value(RF_SOPCR) type ZVCXI_P0SS_SOPCR
    raising
      /VCXI/CX_CKX .
  methods GET_SOPCR_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_SOPLE
    returning
      value(RF_SOPLE) type ZVCXI_P0SS_SOPLE
    raising
      /VCXI/CX_CKX .
  methods GET_SOPLE_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_TRIPL_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_TRIPS_DESCR
    returning
      value(RF_DESCR) type /VCXI/CKX_DESCR
    raising
      /VCXI/CX_CKX .
  methods GET_WERKS
    returning
      value(RF_WERKS) type WERKS_D
    raising
      /VCXI/CX_CKX .
  methods SET_SOPCR
    importing
      !IF_SOPCR type ZVCXI_P0SS_SOPCR
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_SOPLE
    importing
      !IF_SOPLE type ZVCXI_P0SS_SOPLE
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods GET_ORIEN
  abstract
    exporting
      !EF_ORIEN type ZVCXI_P0S_ORIEN
    raising
      /VCXI/CX_CKX .

  methods GET_STATUS
    redefinition .
  methods GET_STATUS_MSG
    redefinition .
  methods HANDLE_EVENT
    redefinition .
protected section.

  constants C_ATTID_SCSTR_CALC type /VCXI/VKS_ATTID value 'SCSTR_CALC'. "#EC NOTEXT
  constants C_ATTID_TSCOR_CUT type /VCXI/VKS_ATTID value 'TSCOR_CUT'. "#EC NOTEXT
  constants C_IEVNT_I_INIT_REFERENCES type /VCXI/VKSC_IEVNT value 'INIT_REFERENCES'. "#EC NOTEXT
  constants C_IEVNT_I_INIT_TRIM_ALLOC type /VCXI/VKSC_IEVNT value 'INIT_TRIM_ALLOC'. "#EC NOTEXT
  constants C_IEVNT_I_RECALC_SCSTR type /VCXI/VKSC_IEVNT value 'RECALC_SCSTR'. "#EC NOTEXT
  constants C_IEVNT_I_SET_DEFAULT type /VCXI/VKSC_IEVNT value 'SET_DEFAULT'. "#EC NOTEXT
  constants C_IEVNT_O_SOPCR_CHANGED type /VCXI/VKSC_IEVNT value 'SOPCR_CHANGED'. "#EC NOTEXT
  constants C_IEVNT_O_SOPLE_CHANGED type /VCXI/VKSC_IEVNT value 'SOPLE_CHANGED'. "#EC NOTEXT
  type-pools ABAP .
  data F_INIT_SCSTR type ABAP_BOOL .
  data R_DCT type ref to ZIF_VCXI_P0SS_DCT .
  data R_GATE_DCT type ref to /VCXI/CL_VKSR_GATE .
  data R_GATE_PRODDIM type ref to /VCXI/CL_VKSR_GATE .
  data R_GATE_SHTDIM type ref to /VCXI/CL_VKSR_GATE .
  data R_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE .
  data R_SHTDIM type ref to ZIF_VCXI_P0SS_SHTDIM .

  methods GET_TPLLT
    returning
      value(RS_TRILT) type ZVCXI_P0SS_S_TRILT
    raising
      /VCXI/CX_CKX .
  methods GET_TPLRB
    returning
      value(RS_TRIRB) type ZVCXI_P0SS_S_TRIRB
    raising
      /VCXI/CX_CKX .
  methods GET_OLLRB
    returning
      value(RS_OVLRB) type ZVCXI_P0SS_S_OVLRB
    raising
      /VCXI/CX_CKX .
  methods GET_TPSLT
    returning
      value(RS_TRILT) type ZVCXI_P0SS_S_TRILT
    raising
      /VCXI/CX_CKX .
  methods GET_OLWLT
    returning
      value(RS_OVLLT) type ZVCXI_P0SS_S_OVLLT
    raising
      /VCXI/CX_CKX .
  methods GET_TPSRB
    returning
      value(RS_TRIRB) type ZVCXI_P0SS_S_TRIRB
    raising
      /VCXI/CX_CKX .
  methods GET_OLWRB
    returning
      value(RS_OVLRB) type ZVCXI_P0SS_S_OVLRB
    raising
      /VCXI/CX_CKX .
  methods GET_TRIPL
    returning
      value(RS_TRIPL) type ZVCXI_P0SS_S_TRIPL
    raising
      /VCXI/CX_CKX .
  methods GET_TRIPS
    returning
      value(RS_TRIPS) type ZVCXI_P0SS_S_TRIPS
    raising
      /VCXI/CX_CKX .
  methods SET_DTLLT
    importing
      !IS_TRILT type ZVCXI_P0SS_S_TRILT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_DTLRB
    importing
      !IS_TRIRB type ZVCXI_P0SS_S_TRIRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_DTWLT
    importing
      !IS_TRILT type ZVCXI_P0SS_S_TRILT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_DTWRB
    importing
      !IS_TRIRB type ZVCXI_P0SS_S_TRIRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_OLLLT
    importing
      !IS_OVLLT type ZVCXI_P0SS_S_OVLLT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_TPLLT
    importing
      !IS_TRILT type ZVCXI_P0SS_S_TRILT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_TPLRB
    importing
      !IS_TRIRB type ZVCXI_P0SS_S_TRIRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_OLLRB
    importing
      !IS_OVLRB type ZVCXI_P0SS_S_OVLRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_TPSLT
    importing
      !IS_TRILT type ZVCXI_P0SS_S_TRILT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_OLWLT
    importing
      !IS_OVLLT type ZVCXI_P0SS_S_OVLLT
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_TPSRB
    importing
      !IS_TRIRB type ZVCXI_P0SS_S_TRIRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods SET_OLWRB
    importing
      !IS_OVLRB type ZVCXI_P0SS_S_OVLRB
      !IF_SETBY type /VCXI/VKSR_SETBY default 'CALC'
    raising
      /VCXI/CX_CKX .
  methods IS_SHTPR_CUTTED
    returning
      value(RF_CUTTED) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods INIT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods CHECK_SCSTR
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_SCSTR_INDIC
    importing
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE optional
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_SOPCR
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_SOPLE
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods CHECK_SUM_TRIM
    importing
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE optional
    returning
      value(RF_RETURN) type I
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_SCSTR
    importing
      !IF_SORTED type ABAP_BOOL default ABAP_TRUE
    exporting
      !ET_GATE type /VCXI/VKSR_TT_GATE
      !ET_SCSTR type ZVCXI_P0SS_TT_SCSTR
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_MS_SHTPR
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_GATE_MS_SHTPR) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_OLLEN
    returning
      value(RS_OLLEN) type ZVCXI_P0SS_S_OLLEN
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_SCORE
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
      !IF_CSCOR type ZVCXI_P0SS_CSCOR
    returning
      value(RT_GATE_SCORE) type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods INIT_PRVDR_SHTDIM
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods INIT_PRVDR_PRODDIM
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods INIT_PRVDR_DCT
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods INIT_PRVDR_SPEC
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_TAPE
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RT_GATE_TAPE) type /VCXI/VKSR_TT_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_PRVDR_LAMI_RTS
    importing
      !IR_GATE_SPEC type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RR_GATE_LAMI) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_DTLLT
    returning
      value(RS_TRILT) type ZVCXI_P0SS_S_TRILT
    raising
      /VCXI/CX_CKX .
  methods GET_DTLRB
    returning
      value(RS_TRIRB) type ZVCXI_P0SS_S_TRIRB
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_ATTACH
    importing
      !IF_CSCOR type ZVCXI_P0SS_CSCOR
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_DTRIL
    returning
      value(RS_DTRIL) type ZVCXI_P0SS_S_DTRIL
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_CUTTING
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_NONE
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_DTRIW
    returning
      value(RS_DTRIW) type ZVCXI_P0SS_S_DTRIW
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_SHTPR
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_CHOP
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_DTWLT
    returning
      value(RS_TRILT) type ZVCXI_P0SS_S_TRILT
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_SLIT_SCORE
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods GET_DTWRB
    returning
      value(RS_TRIRB) type ZVCXI_P0SS_S_TRIRB
    raising
      /VCXI/CX_CKX .
  methods GET_SCSOP_SLIT_SCORE_MAN
    importing
      !IF_CSCOR type ZVCXI_P0SS_CSCOR
    changing
      value(CT_SCSOP) type ZVCXI_P0SS_TT_SCSOP
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_REFERENCES
    raising
      /VCXI/CX_CKX .
  methods HANDLE_INIT_TRIM_ALLOC
    raising
      /VCXI/CX_CKX .
  methods HANDLE_RECALC_SCSTR
    raising
      /VCXI/CX_CKX .
  methods HANDLE_SET_DEFAULT
    raising
      /VCXI/CX_CKX .
  methods INIT_SCSTR_CALC
    raising
      /VCXI/CX_CKX .
  methods INIT_TSCOR_CUT
    raising
      /VCXI/CX_CKX .
  methods UPDATE_SCSTR
    raising
      /VCXI/CX_CKX .
  methods GET_OLLLT
    returning
      value(RS_OVLLT) type ZVCXI_P0SS_S_OVLLT
    raising
      /VCXI/CX_CKX .
private section.
endclass. "ZCL_VCXI_P0SS_PR_SCSTR_MGR definition
class ZCL_VCXI_P0SS_PR_SCSTR_MGR implementation.
method CHECK_NO_CALC.

  case IF_CSCOR.
*** Cutting is not Selected and we have Nested and a Score Operation -> No Calculation Possible
    when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
      if IF_FNEST         eq ABAP_TRUE                                   and
         IF_ACTIV         eq ABAP_TRUE                                   and
         ME->GET_SOPLE( ) ne ZCL_VCXI_P0SS_BL_SCSOP_CUT=>C_SCSOP_CUTTING.
        move ABAP_TRUE to RF_NO_CALC.
      endif.

    when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
***   Cutting is not Selected and we have Nested and a Score Operation -> No Calculation Possible
      if IF_FNEST         eq ABAP_TRUE                                   and
         IF_ACTIV         eq ABAP_TRUE                                   and
         ME->GET_SOPCR( ) ne ZCL_VCXI_P0SS_BL_SCSOP_CUT=>C_SCSOP_CUTTING.
        move ABAP_TRUE to RF_NO_CALC.
      endif.
  endcase.

endmethod.
method CHECK_SCSTR.

***  0 Score Strings do have all needed Score Categories.
***  1 Score Strings do not have all needed Cross Scores as Score Category.
***  2 Score Strings do not have all needed Length Scores as Score Category.
***  3 Score Strings do not have all needed Score Categories.

  data: LF_SOPCR    type        ZVCXI_P0SS_SOPCR,
        LF_SOPLE    type        ZVCXI_P0SS_SOPLE,
        LF_CNTCR    type        I,
        LF_CNTLE    type        I.
  data: LT_SCSTR    type        ZVCXI_P0SS_TT_SCSTR.
  data: LR_PR_SCSTR type ref to ZCL_VCXI_P0SS_PR_SCSTR.

***------------------------------------------------------------------------------------------------
*** Start Doing
  LF_SOPCR = ME->GET_SOPCR( ).
  LF_SOPLE = ME->GET_SOPLE( ).

*** Get Score Strings
  ME->GET_PRVDR_SCSTR( importing ET_SCSTR = LT_SCSTR ).

  loop at LT_SCSTR into LR_PR_SCSTR.
    if LR_PR_SCSTR->GET_CSCOR( ) eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
      add 1 to LF_CNTCR.
    elseif LR_PR_SCSTR->GET_CSCOR( ) eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
      add 1 to LF_CNTLE.
    endif.
  endloop.


*** Check if Score String Cross is valid
  if LF_SOPCR eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT and
     LF_CNTCR lt 2.
    RF_RETURN = 1.
  endif.

*** Check if Score String Length is valid
  if LF_SOPLE eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT and
     LF_CNTLE lt 2.
    if RF_RETURN ne 0.
      RF_RETURN = 3.
    else.
      RF_RETURN = 2.
    endif.
  endif.

endmethod.
method CHECK_SCSTR_INDIC.

***  0 Score Strings do have all needed Seperators (Score Types or Tapes).
***  1 Check Score String(s). Invalid Separator(s) in use.
***  2 Following Separators are not considered on Score String Level: &1

  data: LF_SOPLE          type        ZVCXI_P0SS_SOPLE,
        LF_SOPCR          type        ZVCXI_P0SS_SOPCR,
        LF_SCSTR          type        ZVCXI_P0SS_SCSTR,
        LF_INDIC          type        CHAR30,
        LF_MSGV2          type        SYMSGV,
        LF_IGNORE_SCORE_L type        ABAP_BOOL,
        LF_IGNORE_SCORE_C type        ABAP_BOOL,
        LF_IGNORE_TAPE    type        ABAP_BOOL,
        LF_RETURN         type        I,
        LF_INV_ASSIGN     type        ABAP_BOOL.
  data: LT_SCSTR          type        ZVCXI_P0SS_TT_SCSTR,
        LT_INDIC_A        type        ZVCXI_P0SS_TT_INDIC,
        LT_INDIC_B        type        ZVCXI_P0SS_TT_INDIC.
  data: LR_PR_SCSTR       type ref to ZCL_VCXI_P0SS_PR_SCSTR.

  RF_RETURN = 1.

*** Get Score Strings
  ME->GET_PRVDR_SCSTR( importing ET_SCSTR = LT_SCSTR ).

***------------------------------------------------------------------------------------------------
*** Ignore Scores if they could be done on Cutting
  if ME->R_DCT               is bound and
     ME->R_DCT->GET_TDCUT( ) is not initial.

    move ME->GET_SOPLE( ) to LF_SOPLE.
    move ME->GET_SOPCR( ) to LF_SOPCR.

    if LF_SOPLE eq C_SCSOP_CUTTING.
      move ABAP_TRUE to LF_IGNORE_SCORE_L.
    endif.
    if LF_SOPCR eq C_SCSOP_CUTTING.
      move ABAP_TRUE to LF_IGNORE_SCORE_C.
    endif.

*** In case of Split we have to search for active cutting
    if LF_SOPLE eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT or
       LF_SOPCR eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
      loop at LT_SCSTR into LR_PR_SCSTR.
        if LR_PR_SCSTR->GET_SCSOP( ) eq C_SCSOP_CUTTING.
          case LR_PR_SCSTR->GET_CSCOR( ).
            when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
              move ABAP_TRUE to LF_IGNORE_SCORE_L.
            when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
              move ABAP_TRUE to LF_IGNORE_SCORE_C.
          endcase.
        endif.
      endloop.
    endif.
  endif.

*** Ignore Tapes in case of Sheet Procurement
  LF_IGNORE_TAPE = ME->IS_MS_SHTPR_ACTIVE( ).


***------------------------------------------------------------------------------------------------
*** Identify valid Indicators per Sheet Direction
  LT_INDIC_A = ME->GET_VALID_INDIC( IF_IGNORE_SCORE_L = LF_IGNORE_SCORE_L
                                    IF_IGNORE_SCORE_C = ABAP_TRUE
                                    IF_IGNORE_TAPE    = LF_IGNORE_TAPE ).

  LT_INDIC_B = ME->GET_VALID_INDIC( IF_IGNORE_SCORE_L = ABAP_TRUE
                                    IF_IGNORE_SCORE_C = LF_IGNORE_SCORE_C
                                    IF_IGNORE_TAPE    = ABAP_TRUE ).

***------------------------------------------------------------------------------------------------
*** Check Score Strings
  loop at LT_SCSTR into LR_PR_SCSTR.
    clear: LF_RETURN, LF_SCSTR.

*** Check each Score String for unused Indicator on different lists based on Score Category
    move LR_PR_SCSTR->GET_SCSTR( ) to LF_SCSTR.
    case LR_PR_SCSTR->GET_SHTDI( ).
      when 'A'.
        ZCL_VCXI_P0SS_CUST_SCSTR=>GET_UNASSIGNED_INDIC( exporting IF_SCSTR = LF_SCSTR
                                                        changing  CT_INDIC = LT_INDIC_A ).
      when 'B'.
        ZCL_VCXI_P0SS_CUST_SCSTR=>GET_UNASSIGNED_INDIC( exporting IF_SCSTR = LF_SCSTR
                                                        changing  CT_INDIC = LT_INDIC_B ).
    endcase.

*** Ignore Cutting Indicator if a cutting operation has been determined
    if LR_PR_SCSTR->GET_SCSOP( ) eq C_SCSOP_CUTTING.
      case LR_PR_SCSTR->GET_SHTDI( ).
        when 'A'.
          delete LT_INDIC_A where TABLE_LINE eq ME->F_TSCOR_CUT.
        when 'B'.
          delete LT_INDIC_B where TABLE_LINE eq ME->F_TSCOR_CUT.
      endcase.
    endif.

*** Check if there is a invalid separator used
    LR_PR_SCSTR->CHECK_SEP_SCSTR( importing EF_RETURN = LF_RETURN ).
    if LF_RETURN eq 1.
      move ABAP_TRUE to LF_INV_ASSIGN.
    endif.
  endloop.

***------------------------------------------------------------------------------------------------
*** Check if Score String is valid
  if LT_INDIC_A is initial and
     LT_INDIC_B is initial and
     LF_INV_ASSIGN eq ABAP_FALSE.
    RF_RETURN = 0.
    if IR_MSG is bound.
***   Score Strings do have all needed Seperators (Score Types or Tapes).
      IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                           IF_MSGTY = 'S'
                           IF_MSGNO = '170' ).
    endif.
  else.
    if LF_INV_ASSIGN eq ABAP_TRUE.
      RF_RETURN = 1.
      if IR_MSG is bound.
***     Check Score String(s). Invalid Separator(s) in use.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '172').
      endif.
    endif.

*** Scores on Direction A
    if LT_INDIC_A is not initial.
      RF_RETURN = 2.
      clear LF_MSGV2.
      loop at LT_INDIC_A into LF_INDIC.
        if LF_MSGV2 is not initial.
          concatenate LF_MSGV2 LF_INDIC into LF_MSGV2 separated by ', '.
        else.
          move LF_INDIC to LF_MSGV2.
        endif.
      endloop.

      if IR_MSG is bound.
***     Following Separators are not considered in &1 Score String(s): &2
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '171'
                             IF_MSGV1 = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH
                             IF_MSGV2 = LF_MSGV2 ).
      endif.
    endif.

*** Scores on Direction B
    if LT_INDIC_B is not initial.
      RF_RETURN = 2.
      clear LF_MSGV2.
      loop at LT_INDIC_B into LF_INDIC.
        if LF_MSGV2 is not initial.
          concatenate LF_MSGV2 LF_INDIC into LF_MSGV2 separated by ', '.
        else.
          move LF_INDIC to LF_MSGV2.
        endif.
      endloop.

      if IR_MSG is bound.
***     Following Separators are not considered in &1 Score String(s): &2
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '171'
                             IF_MSGV1 = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS
                             IF_MSGV2 = LF_MSGV2 ).
      endif.
    endif.
  endif.

endmethod.
method CHECK_SOPCR.

***  0 Score Operation Cross is maintained and valid.
***  1 Score Operation Cross is maintained but not valid.
***  2 Score Operation Cross is not maintained.

  data: LF_SOPCR type ZVCXI_P0SS_SOPCR.
  data: LT_SOPCR type ZVCXI_P0SS_TT_SCSOP.

***------------------------------------------------------------------------------------------------
*** Start Doing
  LF_SOPCR = ME->GET_SOPCR( ).
  if LF_SOPCR is initial.
    RF_RETURN = 2.
    exit.
  endif.

  LT_SOPCR = ME->GET_ALL_VALID_SCSOP( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).

*** Check if Score Operation Cross is Valid
  read table LT_SOPCR with key SCSOP = LF_SOPCR transporting no fields.
  if SY-SUBRC = 0.
    RF_RETURN = 0.
  else.
    RF_RETURN = 1.
  endif.

endmethod.
method CHECK_SOPLE.

***  0 Score Operation Length is maintained and valid.
***  1 Score Operation Length is maintained but not valid.
***  2 Score Operation Length is not maintained.

  data: LF_SOPLE type ZVCXI_P0SS_SOPLE.
  data: LT_SOPLE type ZVCXI_P0SS_TT_SCSOP.

***------------------------------------------------------------------------------------------------
*** Start Doing
  LF_SOPLE = ME->GET_SOPLE( ).
  if LF_SOPLE is initial.
    RF_RETURN = 2.
    exit.
  endif.

  LT_SOPLE = ME->GET_ALL_VALID_SCSOP( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).

*** Check if Score Operation Cross is Valid
  read table LT_SOPLE with key SCSOP = LF_SOPLE transporting no fields.
  if SY-SUBRC = 0.
    RF_RETURN = 0.
  else.
    RF_RETURN = 1.
  endif.

endmethod.
method CHECK_SUM_TRIM.

  data:  LS_TRITO          type ZVCXI_P0SS_S_TRITO,
         LS_TRITO_CALC     type ZVCXI_P0SS_S_TRITO,
         LS_TRILT          type ZVCXI_P0SS_S_TRILT,
         LS_TRIRB          type ZVCXI_P0SS_S_TRIRB,
         LS_OVLTO          type ZVCXI_P0SS_S_OVLTO,
         LS_OVLTO_CALC     type ZVCXI_P0SS_S_OVLTO,
         LS_OVLLT          type ZVCXI_P0SS_S_OVLLT,
         LS_OVLRB          type ZVCXI_P0SS_S_OVLRB.

  if ME->R_SHTDIM is not bound.
    ME->HANDLE_INIT_REFERENCES( ).
  endif.
  check ME->R_SHTDIM is bound.

*** --------------------------------------------------------------------------------------------
*** Get Division Trim Width
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_DTRIW
               importing  ES_TRITO    = LS_TRITO
                          ES_TRILT    = LS_TRILT
                          ES_TRIRB    = LS_TRIRB ).

*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIRB-TRIRB
                                                      IF_CALCV_UOM_1 = LS_TRIRB-TRIRB_UOM
                                                      IF_CALCV_2     = LS_TRILT-TRILT
                                                      IF_CALCV_UOM_2 = LS_TRILT-TRILT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_TRITO-TRITO_UOM
                                            importing EF_CALCV       = LS_TRITO_CALC-TRITO
                                                      EF_CALCV_UOM   = LS_TRITO_CALC-TRITO_UOM ).

  if LS_TRITO-TRITO is not initial.
*** Do check
    if LS_TRITO_CALC-TRITO     eq LS_TRITO-TRITO     and
       LS_TRITO_CALC-TRITO_UOM eq LS_TRITO-TRITO_UOM.

      if IR_MSG is supplied and
         IR_MSG is bound.
***     Divison Trim Width match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '156' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Divison Trim Width do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '157' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_TRITO, LS_TRITO_CALC, LS_TRIRB, LS_TRILT.

*** --------------------------------------------------------------------------------------------
*** Get Division Trim Length
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_DTRIL
               importing  ES_TRITO    = LS_TRITO
                          ES_TRILT    = LS_TRILT
                          ES_TRIRB    = LS_TRIRB ).

*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIRB-TRIRB
                                                      IF_CALCV_UOM_1 = LS_TRIRB-TRIRB_UOM
                                                      IF_CALCV_2     = LS_TRILT-TRILT
                                                      IF_CALCV_UOM_2 = LS_TRILT-TRILT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_TRITO-TRITO_UOM
                                            importing EF_CALCV       = LS_TRITO_CALC-TRITO
                                                      EF_CALCV_UOM   = LS_TRITO_CALC-TRITO_UOM ).

  if LS_TRITO-TRITO is not initial.
*** Do check
    if LS_TRITO_CALC-TRITO     eq LS_TRITO-TRITO     and
       LS_TRITO_CALC-TRITO_UOM eq LS_TRITO-TRITO_UOM.


      if IR_MSG is supplied and
         IR_MSG is bound.
***     Divison Trim Length match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '158' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Divison Trim Length do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '159' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_TRITO, LS_TRITO_CALC, LS_TRIRB, LS_TRILT.

*** --------------------------------------------------------------------------------------------
*** Get Side Trim
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_TRIPS
               importing  ES_TRITO    = LS_TRITO
                          ES_TRILT    = LS_TRILT
                          ES_TRIRB    = LS_TRIRB ).

*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIRB-TRIRB
                                                      IF_CALCV_UOM_1 = LS_TRIRB-TRIRB_UOM
                                                      IF_CALCV_2     = LS_TRILT-TRILT
                                                      IF_CALCV_UOM_2 = LS_TRILT-TRILT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_TRITO-TRITO_UOM
                                            importing EF_CALCV       = LS_TRITO_CALC-TRITO
                                                      EF_CALCV_UOM   = LS_TRITO_CALC-TRITO_UOM ).

  if LS_TRITO-TRITO is not initial.
*** Do check
    if LS_TRITO_CALC-TRITO     eq LS_TRITO-TRITO     and
       LS_TRITO_CALC-TRITO_UOM eq LS_TRITO-TRITO_UOM.

      if IR_MSG is supplied and
         IR_MSG is bound.
***     Side Trim match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '160' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Side Trim do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '161' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_TRITO, LS_TRITO_CALC, LS_TRIRB, LS_TRILT.

*** --------------------------------------------------------------------------------------------
*** Get Length Trim
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_TRIPL
               importing  ES_TRITO    = LS_TRITO
                          ES_TRILT    = LS_TRILT
                          ES_TRIRB    = LS_TRIRB ).

*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIRB-TRIRB
                                                      IF_CALCV_UOM_1 = LS_TRIRB-TRIRB_UOM
                                                      IF_CALCV_2     = LS_TRILT-TRILT
                                                      IF_CALCV_UOM_2 = LS_TRILT-TRILT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_TRITO-TRITO_UOM
                                            importing EF_CALCV       = LS_TRITO_CALC-TRITO
                                                      EF_CALCV_UOM   = LS_TRITO_CALC-TRITO_UOM ).

  if LS_TRITO-TRITO is not initial.
*** Do check
    if LS_TRITO_CALC-TRITO     eq LS_TRITO-TRITO     and
       LS_TRITO_CALC-TRITO_UOM eq LS_TRITO-TRITO_UOM.


      if IR_MSG is supplied and
         IR_MSG is bound.
***     Length Trim match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '162' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Length Trim do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '163' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_TRITO, LS_TRITO_CALC, LS_TRIRB, LS_TRILT.


*** --------------------------------------------------------------------------------------------
*** Get Overlap on Width
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_OLWID
               importing  ES_OVLTO    = LS_OVLTO
                          ES_OVLLT    = LS_OVLLT
                          ES_OVLRB    = LS_OVLRB ).

*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_OVLRB-OVLRB
                                                      IF_CALCV_UOM_1 = LS_OVLRB-OVLRB_UOM
                                                      IF_CALCV_2     = LS_OVLLT-OVLLT
                                                      IF_CALCV_UOM_2 = LS_OVLLT-OVLLT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_OVLTO-OVLTO_UOM
                                            importing EF_CALCV       = LS_OVLTO_CALC-OVLTO
                                                      EF_CALCV_UOM   = LS_OVLTO_CALC-OVLTO_UOM ).

  if LS_OVLTO-OVLTO is not initial.
*** Do check
    if LS_OVLTO_CALC-OVLTO     eq LS_OVLTO-OVLTO     and
       LS_OVLTO_CALC-OVLTO_UOM eq LS_OVLTO-OVLTO_UOM.

      if IR_MSG is supplied and
         IR_MSG is bound.
***     Overlap on Width match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '173' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Overlap on Width do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '174' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_OVLTO, LS_OVLTO_CALC, LS_OVLRB, LS_OVLLT.

*** --------------------------------------------------------------------------------------------
*** Get Overlap on Length
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_OLLEN
               importing  ES_OVLTO    = LS_OVLTO
                          ES_OVLLT    = LS_OVLLT
                          ES_OVLRB    = LS_OVLRB ).
*** Calc Total
  ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_OVLRB-OVLRB
                                                      IF_CALCV_UOM_1 = LS_OVLRB-OVLRB_UOM
                                                      IF_CALCV_2     = LS_OVLLT-OVLLT
                                                      IF_CALCV_UOM_2 = LS_OVLLT-OVLLT_UOM
                                                      IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                      IF_UOM         = LS_OVLTO-OVLTO_UOM
                                            importing EF_CALCV       = LS_OVLTO_CALC-OVLTO
                                                      EF_CALCV_UOM   = LS_OVLTO_CALC-OVLTO_UOM ).

  if LS_OVLTO-OVLTO is not initial.
*** Do check
    if LS_OVLTO_CALC-OVLTO     eq LS_OVLTO-OVLTO     and
       LS_OVLTO_CALC-OVLTO_UOM eq LS_OVLTO-OVLTO_UOM.

      if IR_MSG is supplied and
         IR_MSG is bound.
***     Overlap on Length match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'S'
                             IF_MSGNO = '175' ).
      endif.

    else.
      if IR_MSG is supplied and
         IR_MSG is bound.
***     Overlap on Length do not match Trim allocation.
        IR_MSG->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                             IF_MSGTY = 'E'
                             IF_MSGNO = '176' ).
      endif.
      RF_RETURN = 1.

    endif.
  endif.
  clear: LS_OVLTO, LS_OVLTO_CALC, LS_OVLRB, LS_OVLLT.

endmethod.
method CONSTRUCTOR.

*** Do super
  SUPER->CONSTRUCTOR( IR_GATE = IR_GATE ).

*** Get Score String Calcultion
  ME->INIT_SCSTR_CALC( ).

*** Get Score Type Cutting
  ME->INIT_TSCOR_CUT( ).

endmethod.
method GET_ALL_VALID_SCSOP.

  data:          LF_CUTTING type        ABAP_BOOL.
  data:          LS_SCSOP   type        ZVCXI_P0SS_S_SCSOP.
  data:          LT_SCSOP   type        ZVCXI_P0SS_TT_SCSOP.
  field-symbols: <S_SCSOP>  type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Get all Operations which are valid
  LT_SCSOP = ME->GET_SCSOP( ).

***------------------------------------------------------------------------------------------------
*** If there is already "NONE" -> exit
  read table LT_SCSOP with key SCSOP = ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE
                               CSCOR = IF_CSCOR
                      transporting no fields.
  if SY-SUBRC ne 0.

    if ME->IS_SHTPR_CUTTED( ) eq ABAP_FALSE.
***------------------------------------------------------------------------------------------------
***   Add the Slit/Score Operation if not already in there and no Chopping
      read table LT_SCSOP with key SCSOP = C_SCSOP_SLIT_SCORE
                                   CSCOR = IF_CSCOR
                          transporting no fields.
      if SY-SUBRC ne 0.
        read table LT_SCSOP with key SCSOP = ZCL_VCXI_P0SS_BL_SCSOP_CHOP=>C_SCSOP_CHOP
                            transporting no fields.
        if SY-SUBRC ne 0.
          append initial line to LT_SCSOP assigning <S_SCSOP>.
          <S_SCSOP>-SCSOP = C_SCSOP_SLIT_SCORE.
          <S_SCSOP>-CSCOR = IF_CSCOR.
        endif.
      endif.
    endif.

***------------------------------------------------------------------------------------------------
*** Add the Attachment Operation if not already there (both sides)
*** but we need the attachment text
    if ME->R_DCT is bound and
       ME->R_DCT->GET_ATTOT( ) is not initial.
      read table LT_SCSOP with key SCSOP = C_SCSOP_ATTACHMENT
                                   CSCOR = IF_CSCOR
                          transporting no fields.
      if SY-SUBRC ne 0.
        append initial line to LT_SCSOP assigning <S_SCSOP>.
        <S_SCSOP>-SCSOP = C_SCSOP_ATTACHMENT.
        <S_SCSOP>-CSCOR = IF_CSCOR.
      endif.
*** Remove Attachment from Validation list if we do not have a text (but maybe it is selected!)
    elseif ME->R_DCT is bound and
           ME->R_DCT->GET_ATTOT( ) is initial.
      delete RT_SCSOP where SCSOP = C_SCSOP_ATTACHMENT.
    endif.

    if ME->IS_SHTPR_CUTTED( ) eq ABAP_FALSE.
***------------------------------------------------------------------------------------------------
***   Add also SPLIT Operation if we have no Chopping
      read table LT_SCSOP with key SCSOP = ZCL_VCXI_P0SS_BL_SCSOP_CHOP=>C_SCSOP_CHOP
                          transporting no fields.
      if SY-SUBRC ne 0.
        append initial line to LT_SCSOP assigning <S_SCSOP>.
        <S_SCSOP>-SCSOP = ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
        <S_SCSOP>-CSCOR = IF_CSCOR.
      endif.
    endif.

  else.

    read table LT_SCSOP with key SCSOP = C_SCSOP_CUTTING
                                 CSCOR = IF_CSCOR
                        transporting no fields.

    if SY-SUBRC eq 0.
      LF_CUTTING = ABAP_TRUE.
    endif.


    if LF_CUTTING eq ABAP_TRUE.
***   Delete all which are not CUT!
      delete LT_SCSOP where SCSOP ne C_SCSOP_CUTTING
                        and CSCOR eq IF_CSCOR.
    else.
***   Delete all which are not NONE!
      delete LT_SCSOP where SCSOP ne ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE
                        and CSCOR eq IF_CSCOR.
    endif.
  endif.


*** Delete Chopping -> not Valid for Scores
  delete LT_SCSOP where SCSOP = C_SCSOP_CHOP.

***------------------------------------------------------------------------------------------------
*** Return only requested Operations
  if IF_CSCOR is supplied.
    loop at LT_SCSOP into LS_SCSOP
      where CSCOR = IF_CSCOR.
      append LS_SCSOP to RT_SCSOP.
    endloop.
  else.
    move LT_SCSOP to RT_SCSOP.
  endif.

endmethod.
method GET_BSTRL.

  data: LF_BSTRL type ZVCXI_P0SS_BSTRL,
        LF_TPLLT type CHAR10,
        LF_TPLRB type CHAR10,
        LF_DTLLT type CHAR10,
        LF_DTLRB type CHAR10,
        LF_DUPSL type ZVCXI_P0SS_DUPSL,
        LF_NOUPL type ZVCXI_P0SS_NOUPL.
  data: LS_TRILT type ZVCXI_P0SS_S_TRILT,
        LS_TRIRB type ZVCXI_P0SS_S_TRIRB.

*** Only if we do not have Nested Products!
  check ME->GET_FNEST( ) is initial.

*** -----------------------------------------------------------------------
*** Get all relevant trims
*** Get Length Trim
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_TRIPL
                importing ES_TRILT_IO = LS_TRILT
                          ES_TRIRB_IO = LS_TRIRB ).

  if LS_TRILT-TRILT is not initial.
    write LS_TRILT-TRILT to LF_TPLLT unit LS_TRILT-TRILT_UOM.
    condense LF_TPLLT no-gaps.
  endif.
  if LS_TRIRB-TRIRB is not initial.
    write LS_TRIRB-TRIRB to LF_TPLRB unit LS_TRIRB-TRIRB_UOM.
    condense LF_TPLRB no-gaps.
  endif.

*** Get Division Trim on Length
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_DTRIL
                importing ES_TRILT_IO = LS_TRILT
                          ES_TRIRB_IO = LS_TRIRB ).

  if LS_TRILT-TRILT is not initial.
    write LS_TRILT-TRILT to LF_DTLLT unit LS_TRILT-TRILT_UOM.
    condense LF_DTLLT no-gaps.
  endif.
  if LS_TRIRB-TRIRB is not initial.
    write LS_TRIRB-TRIRB to LF_DTLRB unit LS_TRIRB-TRIRB_UOM.
    condense LF_DTLRB no-gaps.
  endif.

*** -----------------------------------------------------------------------
*** Get Divison Ups
  LF_DUPSL = ME->R_SHTDIM->GET_DUPSL( ).

*** Get Ups
  LF_NOUPL = ME->R_SHTDIM->GET_NOUPL( ).

*** -----------------------------------------------------------------------
*** Start with Number of Ups
*** Multiply by Ups length
  LF_BSTRL = ZCL_VCXI_P0SS_CUST_SCSTR=>C_TSCOR_PRODUCT.

  do LF_NOUPL times.
    if RF_BSTRL is initial.
      move LF_BSTRL to RF_BSTRL.
    else.
      concatenate RF_BSTRL
                  LF_BSTRL
             into RF_BSTRL separated by SPACE.
    endif.
  enddo.


*** Go ahead with length (left/TOP - P - right/BOTTOM)
  if LF_TPLLT is not initial.
    concatenate LF_TPLLT
                RF_BSTRL
           into RF_BSTRL separated by SPACE.
  endif.

  if LF_TPLRB is not initial.
    concatenate RF_BSTRL
                LF_TPLRB
           into RF_BSTRL separated by SPACE.
  endif.

*** Save Product and Product Trim into local Variable
  move RF_BSTRL to LF_BSTRL.
  clear: RF_BSTRL.

*** Multiply by Divison Ups length
  do LF_DUPSL times.
    if RF_BSTRL is initial.
      move LF_BSTRL to RF_BSTRL.
    else.
      concatenate RF_BSTRL
                  LF_BSTRL
             into RF_BSTRL separated by SPACE.
    endif.
  enddo.

  if RF_BSTRL is initial.
    move LF_BSTRL to RF_BSTRL.
  endif.

*** Add the Division Trim (left/TOP - P - right/BOTTOM)
  if LF_DTLLT is not initial.
    concatenate LF_DTLLT
                RF_BSTRL
           into RF_BSTRL separated by SPACE.
  endif.

  if LF_DTLRB is not initial.
    concatenate RF_BSTRL
                LF_DTLRB
           into RF_BSTRL separated by SPACE.
  endif.

endmethod.
method GET_BSTRW.

  data: LF_BSTRW type ZVCXI_P0SS_BSTRW,
        LF_TPSLT type CHAR10,
        LF_TPSRB type CHAR10,
        LF_DTWLT type CHAR10,
        LF_DTWRB type CHAR10,
        LF_DUPSW type ZVCXI_P0SS_DUPSW,
        LF_NOUPW type ZVCXI_P0SS_NOUPW.
  data: LS_TRILT type ZVCXI_P0SS_S_TRILT,
        LS_TRIRB type ZVCXI_P0SS_S_TRIRB.

*** Only if we do not have Nested Products!
  check ME->GET_FNEST( ) is initial.

*** -----------------------------------------------------------------------
*** Get all relevant trims
*** Get Side Trim
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_TRIPS
                importing ES_TRILT_IO = LS_TRILT
                          ES_TRIRB_IO = LS_TRIRB ).

  if LS_TRILT-TRILT is not initial.
    write LS_TRILT-TRILT to LF_TPSLT unit LS_TRILT-TRILT_UOM.
    condense LF_TPSLT no-gaps.
  endif.
  if LS_TRIRB-TRIRB is not initial.
    write LS_TRIRB-TRIRB to LF_TPSRB unit LS_TRIRB-TRIRB_UOM.
    condense LF_TPSRB no-gaps.
  endif.

*** Get Division Trim on Width
  ME->GET_TRIM( exporting IF_PARID    = C_TRIM_PARID_DTRIW
                importing ES_TRILT_IO = LS_TRILT
                          ES_TRIRB_IO = LS_TRIRB ).

  if LS_TRILT-TRILT is not initial.
    write LS_TRILT-TRILT to LF_DTWLT unit LS_TRILT-TRILT_UOM.
    condense LF_DTWLT no-gaps.
  endif.
  if LS_TRIRB-TRIRB is not initial.
    write LS_TRIRB-TRIRB to LF_DTWRB unit LS_TRIRB-TRIRB_UOM.
    condense LF_DTWRB no-gaps.
  endif.

*** -----------------------------------------------------------------------
*** Get Divison Ups
  LF_DUPSW = ME->R_SHTDIM->GET_DUPSW( ).

*** Get Ups
  LF_NOUPW = ME->R_SHTDIM->GET_NOUPW( ).

*** -----------------------------------------------------------------------
*** Start with Number of Ups
*** Multiply by Ups Width
  LF_BSTRW = ZCL_VCXI_P0SS_CUST_SCSTR=>C_TSCOR_PRODUCT.

  do LF_NOUPW times.
    if RF_BSTRW is initial.
      move LF_BSTRW to RF_BSTRW.
    else.
      concatenate RF_BSTRW
                  LF_BSTRW
             into RF_BSTRW separated by SPACE.
    endif.
  enddo.


*** Go ahead with side trim (LEFT/top - P - RIGHT/bottom)
  if LF_TPSLT is not initial.
    concatenate LF_TPSLT
                RF_BSTRW
           into RF_BSTRW separated by SPACE.
  endif.

  if LF_TPSRB is not initial.
    concatenate RF_BSTRW
                LF_TPSRB
           into RF_BSTRW separated by SPACE.
  endif.

*** Save Product and Product Trim into local Variable
  move RF_BSTRW to LF_BSTRW.
  clear: RF_BSTRW.

*** Multiply by Divison Ups Width
  do LF_DUPSW times.
    if RF_BSTRW is initial.
      move LF_BSTRW to RF_BSTRW.
    else.
      concatenate RF_BSTRW
                  LF_BSTRW
             into RF_BSTRW separated by SPACE.
    endif.
  enddo.

  if RF_BSTRW is initial.
    move LF_BSTRW to RF_BSTRW.
  endif.

*** Add the Division Trim (LEFT/top - P - RIGHT/bottom)
  if LF_DTWLT is not initial.
    concatenate LF_DTWLT
                RF_BSTRW
           into RF_BSTRW separated by SPACE.
  endif.

  if LF_DTWRB is not initial.
    concatenate RF_BSTRW
                LF_DTWRB
           into RF_BSTRW separated by SPACE.
  endif.

endmethod.
method GET_DTLLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTLLT ).
  move LS_PARAM-ATFLV to RS_TRILT-TRILT.
  move LS_PARAM-UNIT  to RS_TRILT-TRILT_UOM.

endmethod.
method GET_DTLRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTLRB ).
  move LS_PARAM-ATFLV to RS_TRIRB-TRIRB.
  move LS_PARAM-UNIT  to RS_TRIRB-TRIRB_UOM.

endmethod.
method GET_DTRIL.

  check ME->R_SHTDIM is bound.
  move ME->R_SHTDIM->GET_DTRIL( ) to RS_DTRIL.

endmethod.
method GET_DTRIL_DESCR.

  data: LS_DFIES     type        DFIES.
  data: LR_TYPEDESCR type ref to CL_ABAP_TYPEDESCR,
        LR_ELEMDESCR type ref to CL_ABAP_ELEMDESCR.

  LR_TYPEDESCR = CL_ABAP_ELEMDESCR=>DESCRIBE_BY_NAME( P_NAME = 'ZVCXI_P0SS_DTRIL' ).

  check LR_TYPEDESCR is bound.
  try.
      move LR_TYPEDESCR ?to LR_ELEMDESCR.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_ELEMDESCR.
  endtry.

  check LR_ELEMDESCR is bound.
  LS_DFIES = LR_ELEMDESCR->GET_DDIC_FIELD( ).

  move LS_DFIES-SCRTEXT_L to RF_DESCR.

endmethod.
method GET_DTRIW.

  check ME->R_SHTDIM is bound.
  move ME->R_SHTDIM->GET_DTRIW( ) to RS_DTRIW.

endmethod.
method GET_DTRIW_DESCR.

  data: LS_DFIES     type        DFIES.
  data: LR_TYPEDESCR type ref to CL_ABAP_TYPEDESCR,
        LR_ELEMDESCR type ref to CL_ABAP_ELEMDESCR.

  LR_TYPEDESCR = CL_ABAP_ELEMDESCR=>DESCRIBE_BY_NAME( P_NAME = 'ZVCXI_P0SS_DTRIW' ).

  check LR_TYPEDESCR is bound.
  try.
      move LR_TYPEDESCR ?to LR_ELEMDESCR.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_ELEMDESCR.
  endtry.

  check LR_ELEMDESCR is bound.
  LS_DFIES = LR_ELEMDESCR->GET_DDIC_FIELD( ).

  move LS_DFIES-SCRTEXT_L to RF_DESCR.

endmethod.
method GET_DTWLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTWLT ).
  move LS_PARAM-ATFLV to RS_TRILT-TRILT.
  move LS_PARAM-UNIT  to RS_TRILT-TRILT_UOM.

endmethod.
method GET_DTWRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTWRB ).
  move LS_PARAM-ATFLV to RS_TRIRB-TRIRB.
  move LS_PARAM-UNIT  to RS_TRIRB-TRIRB_UOM.

endmethod.
method GET_FNEST.

*** Return nested Flag
  if ME->R_DCT is bound.
    RF_FNEST = ME->R_DCT->GET_FNEST( ).
  endif.

endmethod.
method GET_OLLEN.

  data:  LS_OLLEN           type        ZVCXI_P0SS_S_OLLEN.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_LAMI         type ref to ZCL_VCXI_P0SS_PR_LAMI.

***------------------------------------------------------------------------------------------------
*** Get all Lamination
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_P0SS_PR_LAMI=>C_IPRVT_P0_LAMI
                                   IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_LAMI.
        check LR_PR_LAMI is bound.
        LS_OLLEN = LR_PR_LAMI->GET_OLLEN( ).

        if LS_OLLEN-OLLEN gt RS_OLLEN-OLLEN.
          move LS_OLLEN to RS_OLLEN.
        endif.

      catch CX_SY_MOVE_CAST_ERROR.
        exit.
    endtry.
  endloop.

endmethod.
method GET_OLLLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLLLT ).
  move LS_PARAM-ATFLV to RS_OVLLT-OVLLT.
  move LS_PARAM-UNIT  to RS_OVLLT-OVLLT_UOM.

endmethod.
method GET_OLLRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLLRB ).
  move LS_PARAM-ATFLV to RS_OVLRB-OVLRB.
  move LS_PARAM-UNIT  to RS_OVLRB-OVLRB_UOM.

endmethod.
method GET_OLWID.

  data:  LS_OLWID           type        ZVCXI_P0SS_S_OLWID.
  data:  LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_LAMI         type ref to ZCL_VCXI_P0SS_PR_LAMI.

***------------------------------------------------------------------------------------------------
*** Get all Lamination
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_P0SS_PR_LAMI=>C_IPRVT_P0_LAMI
                                   IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_LAMI.
        check LR_PR_LAMI is bound.
        LS_OLWID = LR_PR_LAMI->GET_OLWID( ).

        if LS_OLWID-OLWID gt RS_OLWID-OLWID.
          move LS_OLWID to RS_OLWID.
        endif.

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

endmethod.
method GET_OLWLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLWLT ).
  move LS_PARAM-ATFLV to RS_OVLLT-OVLLT.
  move LS_PARAM-UNIT  to RS_OVLLT-OVLLT_UOM.

endmethod.
method GET_OLWRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLWRB ).
  move LS_PARAM-ATFLV to RS_OVLRB-OVLRB.
  move LS_PARAM-UNIT  to RS_OVLRB-OVLRB_UOM.

endmethod.
method GET_PRVDR_LAMI_RTS.

  data:  LT_GATE_LAMI   type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_LAMI   type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_LAMI     type ref to ZCL_VCXI_P0SS_PR_LAMI.

***------------------------------------------------------------------------------------------------
*** Find Provider for Lamination
  LT_GATE_LAMI = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_LAMI=>C_IPRVT_P0_LAMI
                                        IF_INUSE  = ABAP_TRUE
                                        IF_SORTED = ABAP_TRUE ).

  loop at LT_GATE_LAMI into LR_GATE_LAMI.
*** Check is child of Specification
    check LR_GATE_LAMI->IS_IN_LINE( IR_GATE = IR_GATE_SPEC ) eq ABAP_TRUE.

    try.
        move LR_GATE_LAMI->R_CLSPR ?to LR_PR_LAMI.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_LAMI.
    endtry.
    check LR_PR_LAMI is bound and
          LR_PR_LAMI->GET_TLAMI( ) eq ZCL_VCXI_P0SS_CUST_LAMI=>C_TLAMI_RTS.
    move LR_GATE_LAMI to RR_GATE_LAMI.
    exit.
  endloop.

endmethod.
method GET_PRVDR_MS_SHTPR.

  data:  LT_GATE_MS_SHTPR type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_MS_SHTPR type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------------------------------------
*** Get all Sheet Procurement Provider
  LT_GATE_MS_SHTPR = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_MS_SHTPR=>C_IPRVT_P0_MS_SHTPR
                                            IF_INUSE  = ABAP_TRUE
                                            IF_SORTED = ABAP_TRUE ).

  loop at LT_GATE_MS_SHTPR into LR_GATE_MS_SHTPR.
*** Check is child of Specification
    check LR_GATE_MS_SHTPR->GET_PARENT( ) eq IR_GATE_SPEC.
    move LR_GATE_MS_SHTPR to RR_GATE_MS_SHTPR.
    exit.
  endloop.

endmethod.
method GET_PRVDR_SCORE.

  data:  LF_CSCOR              type        ZVCXI_P0SS_CSCOR.
  data:  LT_GATE_SCORE         type        /VCXI/VKSR_TT_GATE,
         LT_GATE_SCORE_LAST    type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_SCORE         type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_SCORE           type ref to ZCL_VCXI_P0SS_PR_SCORE.

***------------------------------------------------------------------------------------------------
*** Find Provider for Score
  LT_GATE_SCORE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_P0SS_PR_SCORE=>C_IPRVT_P0_SCORE
                                         IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE_SCORE into LR_GATE_SCORE.
*** Check is child of Specification
    check LR_GATE_SCORE->IS_IN_LINE( IR_GATE = IR_GATE_SPEC ) eq ABAP_TRUE.
    try.
        move LR_GATE_SCORE->R_CLSPR ?to LR_PR_SCORE.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_SCORE.
    endtry.
    check LR_PR_SCORE is bound.

*** Return only Score Provider with right Score Category
    LR_PR_SCORE->GET_ISCOR( importing EF_CSCOR = LF_CSCOR ).
    check LF_CSCOR eq IF_CSCOR.
    append LR_GATE_SCORE to RT_GATE_SCORE.

  endloop.

*** Sort if more than 1
  if lines( RT_GATE_SCORE ) gt 1.
    ME->R_GATE->SORT_GATE( changing CT_GATE = RT_GATE_SCORE ).
  endif.

***------------------------------------------------------------------------------------------------
*** If we have only one Score which is only the last score -> clear and exit
  check lines( RT_GATE_SCORE ) eq 1.
  read table RT_GATE_SCORE into LR_GATE_SCORE index 1.

  LT_GATE_SCORE_LAST = ZCL_VCXI_P0SS_CUST_SCSTR=>GET_LAST_SCORE( IT_GATE_SCORE = RT_GATE_SCORE
                                                                 IF_CSCOR      = IF_CSCOR ).

  read table LT_GATE_SCORE_LAST with key TABLE_LINE = LR_GATE_SCORE
                                transporting no fields.
  check SY-SUBRC = 0.
  clear: RT_GATE_SCORE.

endmethod.
method GET_PRVDR_SCSTR.

  data:          LT_GATE            type        /VCXI/VKSR_TT_GATE.
  data:          LR_GATE            type ref to /VCXI/CL_VKSR_GATE,
                 LR_PR_SCSTR        type ref to ZCL_VCXI_P0SS_PR_SCSTR.

***------------------------------------------------------------------------------------------------
*** Get all Score Strings
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_SCSTR=>C_IPRVT_P0_SCSTR
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = IF_SORTED ).

  loop at LT_GATE into LR_GATE.
    try.
        move LR_GATE->R_CLSPR ?to LR_PR_SCSTR.
        check LR_PR_SCSTR is bound.
        append LR_GATE     to ET_GATE.
        append LR_PR_SCSTR to ET_SCSTR.

      catch CX_SY_MOVE_CAST_ERROR.
        continue.
    endtry.
  endloop.

endmethod.
method GET_PRVDR_TAPE.

  data:  LT_GATE_TAPE   type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_TAPE   type ref to /VCXI/CL_VKSR_GATE.

***------------------------------------------------------------------------------------------------
*** Find Provider for Tape
  LT_GATE_TAPE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_MS_TAPE=>C_IPRVT_P0_MS_TAPE
                                        IF_INUSE  = ABAP_TRUE
                                        IF_SORTED = ABAP_TRUE ).

  loop at LT_GATE_TAPE into LR_GATE_TAPE.
*** Check is child of Specification
    check LR_GATE_TAPE->IS_IN_LINE( IR_GATE = IR_GATE_SPEC ) eq ABAP_TRUE.
    append LR_GATE_TAPE to RT_GATE_TAPE.
  endloop.

endmethod.
method GET_PTYPE.

  data: LR_PR_SPEC type ref to ZCL_VCXI_P0SS_PR_SPEC.

  if ME->R_GATE_SPEC is not bound.
    ME->HANDLE_INIT_REFERENCES( ).
  endif.

  check ME->R_GATE_SPEC is bound.
  try.
      move ME->R_GATE_SPEC->R_CLSPR ?to LR_PR_SPEC.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_PR_SPEC.
  endtry.

  check LR_PR_SPEC is bound.
  RF_PTYPE = LR_PR_SPEC->GET_PTYPE( ).

endmethod.
method GET_SCSOP.
endmethod.
method GET_SCSOP_ATTACH.

  data:          LT_PRVDR_SLIT_W   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SLIT_L   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_C  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_L  type        /VCXI/VKSR_TT_GATE.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound.

*** Check Provider Die Cut
  check  ME->R_GATE_DCT is bound and
         ME->R_DCT      is bound.

*** Only if we have a Attachment defined!
*** and Die Cut Type is not defined
  check ME->R_DCT->GET_ATTOT( ) is not initial and
        ME->R_DCT->GET_TDCUT( ) is initial.

***------------------------------------------------------------------------------------------------
*** Start Doing
  if IF_CSCOR eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.

*** Only relevant if opeartion is choosen
    check ME->GET_SOPLE( ) eq C_SCSOP_ATTACHMENT.
***------------------------------------------------------------------------------------------------
*** Collect all Provider
    append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_L.
    append ME->R_GATE_DCT    to LT_PRVDR_SLIT_L.
    append ME->R_GATE        to LT_PRVDR_SLIT_L.

***------------------------------------------------------------------------------------------------
***   Add Operation for Length
    append initial line to CT_SCSOP assigning <S_SCSOP>.

    <S_SCSOP>-SCSOP = C_SCSOP_ATTACHMENT.
    <S_SCSOP>-SHTDI = 'A'.
    <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
    if ME->GET_SOPLE( ) eq C_SCSOP_ATTACHMENT.
      <S_SCSOP>-ACTIV = ABAP_TRUE.
***   If Score Operation is active add also right Score Provider
      LT_PRVDR_SCORE_L = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                              IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).

      if LT_PRVDR_SCORE_L is not initial.
        append lines of LT_PRVDR_SCORE_L to LT_PRVDR_SLIT_L.
      endif.
    endif.
    <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_L.


  elseif IF_CSCOR eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.

*** Only relevant if opeartion is choosen
    check ME->GET_SOPCR( ) eq C_SCSOP_ATTACHMENT.
***------------------------------------------------------------------------------------------------
*** Collect all Provider
    append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_W.
    append ME->R_GATE_DCT    to LT_PRVDR_SLIT_W.
    append ME->R_GATE        to LT_PRVDR_SLIT_W.

***------------------------------------------------------------------------------------------------
*** Add Operation for Width
    append initial line to CT_SCSOP assigning <S_SCSOP>.

    <S_SCSOP>-SCSOP = C_SCSOP_ATTACHMENT.
    <S_SCSOP>-SHTDI = 'B'.
    <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
    if ME->GET_SOPCR( ) eq C_SCSOP_ATTACHMENT.
      <S_SCSOP>-ACTIV = ABAP_TRUE.
***   If Score Operation is active add also right Score Provider
      LT_PRVDR_SCORE_C = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                              IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).

      if LT_PRVDR_SCORE_C is not initial.
        append lines of LT_PRVDR_SCORE_C to LT_PRVDR_SLIT_W.
      endif.
    endif.
    <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_W.
  endif.

endmethod.
method GET_SCSOP_CHOP.

  data:          LF_NO_OP          type        I value 2.
  data:          LT_PRVDR_CHOP_W   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_CHOP_L   type        /VCXI/VKSR_TT_GATE.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound and
        ME->R_SHTDIM      is bound.

*** Check if Division Type is as Sawing defined
  check ME->R_SHTDIM->GET_TDIVI( ) eq ZIF_VCXI_P0SS_SHTDIM=>C_TDIVI_CHOP.
***------------------------------------------------------------------------------------------------
*** Slit can be up to 2 times
  do LF_NO_OP times.

    if ( SY-INDEX eq 1                      and
         ME->R_SHTDIM->GET_SDIVI( ) eq 'L' ) or
       ( SY-INDEX eq 2                      and
         ME->R_SHTDIM->GET_SDIVI( ) ne 'L' ).

***   Only relevant if Ups > 1 or choosen as option or splitted
      check ME->R_SHTDIM->GET_DUPSL( ) gt 1.
***------------------------------------------------------------------------------------------------
***   Collect all Provider
      append ME->R_GATE_SHTDIM to LT_PRVDR_CHOP_L.
      append ME->R_GATE        to LT_PRVDR_CHOP_L.

***------------------------------------------------------------------------------------------------
***   Add Operation for Length
      append initial line to CT_SCSOP assigning <S_SCSOP>.

      <S_SCSOP>-SCSOP = C_SCSOP_CHOP.
      <S_SCSOP>-SHTDI = 'B'.
      <S_SCSOP>-T_PRVDR = LT_PRVDR_CHOP_L.


    elseif ( SY-INDEX eq 1                      and
             ME->R_SHTDIM->GET_SDIVI( ) eq 'W' ) or
           ( SY-INDEX eq 2                      and
             ME->R_SHTDIM->GET_SDIVI( ) ne 'W' ).

***   Only relevant if Ups > 1 or choosen as option or splitted
      check ME->R_SHTDIM->GET_DUPSW( ) gt 1.
***------------------------------------------------------------------------------------------------
***   Collect all Provider
      append ME->R_GATE_SHTDIM to LT_PRVDR_CHOP_W.
      append ME->R_GATE        to LT_PRVDR_CHOP_W.

***------------------------------------------------------------------------------------------------
***   Add Operation for Width
      append initial line to CT_SCSOP assigning <S_SCSOP>.

      <S_SCSOP>-SCSOP = C_SCSOP_CHOP.
      <S_SCSOP>-SHTDI = 'A'.
      <S_SCSOP>-T_PRVDR = LT_PRVDR_CHOP_W.
    endif.
  enddo.

endmethod.
method GET_SCSOP_CUTTING.

  data:          LT_PRVDR_CUT_W    type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_CUT_L    type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_C  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_L  type        /VCXI/VKSR_TT_GATE.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound.

*** Check Provider Die Cut
  check  ME->R_GATE_DCT is bound and
         ME->R_DCT      is bound.

*** Check if Die Cut Type is defined
  check ME->R_DCT->GET_TDCUT( ) is not initial.

*** Check Cutting on Sheet Procurement is not active
  check ME->IS_SHTPR_CUTTED( ) eq ABAP_FALSE.

***------------------------------------------------------------------------------------------------
*** Collect all Provider
  append ME->R_GATE_SHTDIM to LT_PRVDR_CUT_L.
  append ME->R_GATE_DCT    to LT_PRVDR_CUT_L.
  append ME->R_GATE        to LT_PRVDR_CUT_L.

***------------------------------------------------------------------------------------------------
*** Add Operation for Length
  append initial line to CT_SCSOP assigning <S_SCSOP>.

  <S_SCSOP>-SCSOP = C_SCSOP_CUTTING.
  <S_SCSOP>-SHTDI = 'A'.
  <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
  if ME->GET_SOPLE( ) eq C_SCSOP_CUTTING.
    <S_SCSOP>-ACTIV = ABAP_TRUE.
*** If Score Operation is active add also right Score Provider
    LT_PRVDR_SCORE_L = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                            IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).
    if LT_PRVDR_SCORE_L is not initial.
      append lines of LT_PRVDR_SCORE_L to LT_PRVDR_CUT_L.
    endif.
  endif.
  <S_SCSOP>-T_PRVDR = LT_PRVDR_CUT_L.

***------------------------------------------------------------------------------------------------
*** Collect all Provider
  append ME->R_GATE_SHTDIM to LT_PRVDR_CUT_W.
  append ME->R_GATE_DCT    to LT_PRVDR_CUT_W.
  append ME->R_GATE        to LT_PRVDR_CUT_W.

***------------------------------------------------------------------------------------------------
*** Add Operation for Width
  append initial line to CT_SCSOP assigning <S_SCSOP>.

  <S_SCSOP>-SCSOP = C_SCSOP_CUTTING.
  <S_SCSOP>-SHTDI = 'B'.
  <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
  if ME->GET_SOPCR( ) eq C_SCSOP_CUTTING.
    <S_SCSOP>-ACTIV = ABAP_TRUE.
*** If Score Operation is active add also right Score Provider
    LT_PRVDR_SCORE_C = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                            IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).
    if LT_PRVDR_SCORE_C is not initial.
      append lines of LT_PRVDR_SCORE_C to LT_PRVDR_CUT_W.
    endif.
  endif.
  <S_SCSOP>-T_PRVDR = LT_PRVDR_CUT_W.

endmethod.                    "GET_SCSOP_CUTTING
method GET_SCSOP_NONE.

  data:          LS_SCSOP          type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound.

***------------------------------------------------------------------------------------------------
*** Add Operation for Length
  LS_SCSOP-SCSOP = ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE.
  LS_SCSOP-SHTDI = 'A'.
  LS_SCSOP-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
*** Check no Scores are there for Length
  if ME->NO_SCORES( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ) eq ABAP_TRUE.
    append LS_SCSOP to CT_SCSOP.
  endif.

***------------------------------------------------------------------------------------------------
*** Collect all Provider
  clear: LS_SCSOP.

***------------------------------------------------------------------------------------------------
*** Add Operation for Width
  LS_SCSOP-SCSOP = ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE.
  LS_SCSOP-SHTDI = 'B'.
  LS_SCSOP-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
*** Check no Scores are there for Cross
  if ME->NO_SCORES( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ) eq ABAP_TRUE.
    append LS_SCSOP to CT_SCSOP.
  endif.

endmethod.                    "GET_SCSOP_CUTTING
method GET_SCSOP_SHTPR.

  data:          LF_ADD_CROSS      type        ABAP_BOOL.
  data:          LT_PRVDR_SHTPR    type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_L  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_C  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_TAPE     type        /VCXI/VKSR_TT_GATE.
  data:          LR_GATE_MS_SHTPR  type ref to /VCXI/CL_VKSR_GATE,
                 LR_PR_MS_SHTPR    type ref to ZCL_VCXI_P0SS_PR_MS_SHTPR.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound.

*** Find Provider for Sheet Procurement
  LR_GATE_MS_SHTPR = ME->GET_PRVDR_MS_SHTPR( IR_GATE_SPEC = ME->R_GATE_SPEC ).
  check LR_GATE_MS_SHTPR is bound.

*** Find Provider for Tape
  LT_PRVDR_TAPE = ME->GET_PRVDR_TAPE( IR_GATE_SPEC = ME->R_GATE_SPEC ).


*** Check Provider Die Cut and Die Cut Type -> Sheet needs to be Cutted!
  if ME->R_GATE_DCT          is bound and
     ME->R_DCT               is bound and
     ME->R_DCT->GET_TDCUT( ) is not initial.

***------------------------------------------------------------------------------------------------
*** Cutting is not relevant if we have it on the Sheet Procurement
    try.
        move LR_GATE_MS_SHTPR->R_CLSPR ?to LR_PR_MS_SHTPR.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_MS_SHTPR.
    endtry.

    if LR_PR_MS_SHTPR               is bound     and
       LR_PR_MS_SHTPR->GET_FLCUT( ) eq ABAP_TRUE.

      LF_ADD_CROSS = ABAP_TRUE.

    endif.
  endif.

***------------------------------------------------------------------------------------------------
*** Collect all Provider
*** Add Provider for Product Dimension if available
  append ME->R_GATE_SHTDIM      to LT_PRVDR_SHTPR.
  if ME->R_GATE_PRODDIM is bound.
    append ME->R_GATE_PRODDIM   to LT_PRVDR_SHTPR.
  endif.
  append LR_GATE_MS_SHTPR       to LT_PRVDR_SHTPR.
  append lines of LT_PRVDR_TAPE to LT_PRVDR_SHTPR.
  append ME->R_GATE             to LT_PRVDR_SHTPR.

***------------------------------------------------------------------------------------------------
*** Add Operation for Length
  append initial line to CT_SCSOP assigning <S_SCSOP>.

  <S_SCSOP>-SCSOP = C_SCSOP_SHTPR.
  <S_SCSOP>-SHTDI = 'A'.
  <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
  if ME->GET_SOPLE( ) eq C_SCSOP_SHTPR.
    <S_SCSOP>-ACTIV = ABAP_TRUE.
*** If Score Operation is active add also right Score Provider
    LT_PRVDR_SCORE_L = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                            IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).
    if LT_PRVDR_SCORE_L is not initial.
      append lines of LT_PRVDR_SCORE_L to LT_PRVDR_SHTPR.
    endif.
  endif.
  <S_SCSOP>-T_PRVDR = LT_PRVDR_SHTPR.

  check LF_ADD_CROSS eq ABAP_TRUE.

***------------------------------------------------------------------------------------------------
*** Collect all Provider
*** Add Provider for Product Dimension if available
  clear: LT_PRVDR_SHTPR.
  append ME->R_GATE_SHTDIM      to LT_PRVDR_SHTPR.
  if ME->R_GATE_PRODDIM is bound.
    append ME->R_GATE_PRODDIM   to LT_PRVDR_SHTPR.
  endif.
  append LR_GATE_MS_SHTPR       to LT_PRVDR_SHTPR.
  append lines of LT_PRVDR_TAPE to LT_PRVDR_SHTPR.
  append ME->R_GATE             to LT_PRVDR_SHTPR.

***------------------------------------------------------------------------------------------------
*** Add Operation ALSO for Cross!!! if we have scores!!!
*** If Score Operation is active add also right Score Provider
  LT_PRVDR_SCORE_C = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                          IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).
  check LT_PRVDR_SCORE_C is not initial.

  append initial line to CT_SCSOP assigning <S_SCSOP>.

  <S_SCSOP>-SCSOP = C_SCSOP_SHTPR.
  <S_SCSOP>-SHTDI = 'B'.
  <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
  if ME->GET_SOPCR( ) eq C_SCSOP_SHTPR.
    <S_SCSOP>-ACTIV = ABAP_TRUE.
    append lines of LT_PRVDR_SCORE_C to LT_PRVDR_SHTPR.
  endif.
  <S_SCSOP>-T_PRVDR = LT_PRVDR_SHTPR.


endmethod.                    "GET_SCSOP_CORR
method GET_SCSOP_SLIT_SCORE.

  data:          LF_NO_OP          type        I value 2.
  data:          LT_PRVDR_SLIT_W   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SLIT_L   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_C  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_L  type        /VCXI/VKSR_TT_GATE.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound and
        ME->R_SHTDIM      is bound.

*** Check if Division Type is as Sawing defined
  check ME->R_SHTDIM->GET_TDIVI( ) eq ZIF_VCXI_P0SS_SHTDIM=>C_TDIVI_SAW.
***------------------------------------------------------------------------------------------------
*** Slit can be up to 2 times
  do LF_NO_OP times.

    if ( SY-INDEX eq 1                      and
         ME->R_SHTDIM->GET_SDIVI( ) eq 'L' ) or
       ( SY-INDEX eq 2                      and
         ME->R_SHTDIM->GET_SDIVI( ) ne 'L' ).

***   Only relevant if Ups > 1 or choosen as option or splitted
      check ME->R_SHTDIM->GET_DUPSL( ) gt 1.
***------------------------------------------------------------------------------------------------
***   Collect all Provider
      append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_L.
      append ME->R_GATE        to LT_PRVDR_SLIT_L.

***------------------------------------------------------------------------------------------------
***   Add Operation for Length
      append initial line to CT_SCSOP assigning <S_SCSOP>.

      <S_SCSOP>-SCSOP = C_SCSOP_SLIT_SCORE.
      <S_SCSOP>-SHTDI = 'B'.
      <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
      if ME->GET_SOPCR( ) eq C_SCSOP_SLIT_SCORE.
        <S_SCSOP>-ACTIV = ABAP_TRUE.
***     If Score Operation is active add also right Score Provider
        LT_PRVDR_SCORE_C = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                                IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).
        if LT_PRVDR_SCORE_C is not initial.
          append lines of LT_PRVDR_SCORE_C to LT_PRVDR_SLIT_L.
          <S_SCSOP>-ACTIV = ABAP_TRUE.
        endif.
      endif.
      <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_L.


    elseif ( SY-INDEX eq 1                      and
             ME->R_SHTDIM->GET_SDIVI( ) eq 'W' ) or
           ( SY-INDEX eq 2                      and
             ME->R_SHTDIM->GET_SDIVI( ) ne 'W' ).

***   Only relevant if Ups > 1 or choosen as option or splitted
      check ME->R_SHTDIM->GET_DUPSW( ) gt 1.
***------------------------------------------------------------------------------------------------
***   Collect all Provider
      append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_W.
      append ME->R_GATE        to LT_PRVDR_SLIT_W.

***------------------------------------------------------------------------------------------------
***   Add Operation for Width
      append initial line to CT_SCSOP assigning <S_SCSOP>.

      <S_SCSOP>-SCSOP = C_SCSOP_SLIT_SCORE.
      <S_SCSOP>-SHTDI = 'A'.
      <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
      if ME->GET_SOPLE( ) eq C_SCSOP_SLIT_SCORE.
        <S_SCSOP>-ACTIV = ABAP_TRUE.
***     If Score Operation is active add also right Score Provider
        LT_PRVDR_SCORE_L = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                                IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).
        if LT_PRVDR_SCORE_L is not initial.
          append lines of LT_PRVDR_SCORE_L to LT_PRVDR_SLIT_W.
        endif.
      endif.
      <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_W.
    endif.
  enddo.

endmethod.
method GET_SCSOP_SLIT_SCORE_MAN.

  data:          LT_PRVDR_SLIT_W   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SLIT_L   type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_C  type        /VCXI/VKSR_TT_GATE,
                 LT_PRVDR_SCORE_L  type        /VCXI/VKSR_TT_GATE.
  field-symbols: <S_SCSOP>         type        ZVCXI_P0SS_S_SCSOP.

***------------------------------------------------------------------------------------------------
*** Check Provider for Specification
  check ME->R_GATE_SPEC is bound.

*** Check Provider for Sheet Dimension
  check ME->R_GATE_SHTDIM is bound and
        ME->R_SHTDIM      is bound.

*** Check there is no Chopping!!
  check ME->R_SHTDIM->GET_TDIVI( ) ne ZIF_VCXI_P0SS_SHTDIM=>C_TDIVI_CHOP.

***------------------------------------------------------------------------------------------------
*** Start Doing
  if IF_CSCOR eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.

*** Only relevant if Ups > 1 or choosen as option or splitted
    check ME->R_SHTDIM->GET_DUPSW( ) le 1 or
          ME->R_SHTDIM->GET_TDIVI( ) ne ZIF_VCXI_P0SS_SHTDIM=>C_TDIVI_SAW.
    check ME->GET_SOPLE( )          eq C_SCSOP_SLIT_SCORE or
          ME->GET_SOPLE( )          eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
***------------------------------------------------------------------------------------------------
***   Collect all Provider
    append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_L.
    append ME->R_GATE        to LT_PRVDR_SLIT_L.

***------------------------------------------------------------------------------------------------
***   Add Operation for Length
    append initial line to CT_SCSOP assigning <S_SCSOP>.

    <S_SCSOP>-SCSOP = C_SCSOP_SLIT_SCORE.
    <S_SCSOP>-SHTDI = 'A'.
    <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.
    if ME->GET_SOPLE( ) eq C_SCSOP_SLIT_SCORE or
       ME->GET_SOPLE( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
      <S_SCSOP>-ACTIV = ABAP_TRUE.
***   If Score Operation is active add also right Score Provider
      LT_PRVDR_SCORE_L = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                              IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).
      if LT_PRVDR_SCORE_L is not initial.
        append lines of LT_PRVDR_SCORE_L to LT_PRVDR_SLIT_L.
      endif.
    endif.
    <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_L.


  elseif IF_CSCOR eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.

*** Only relevant if Ups > 1 or choosen as option or splitted
    check ME->R_SHTDIM->GET_DUPSL( ) le 1 or
          ME->R_SHTDIM->GET_TDIVI( ) ne ZIF_VCXI_P0SS_SHTDIM=>C_TDIVI_SAW.
    check ME->GET_SOPCR( )          eq C_SCSOP_SLIT_SCORE or
          ME->GET_SOPCR( )          eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT .
***------------------------------------------------------------------------------------------------
*** Collect all Provider
    append ME->R_GATE_SHTDIM to LT_PRVDR_SLIT_W.
    append ME->R_GATE        to LT_PRVDR_SLIT_W.

***------------------------------------------------------------------------------------------------
*** Add Operation for Width
    append initial line to CT_SCSOP assigning <S_SCSOP>.

    <S_SCSOP>-SCSOP = C_SCSOP_SLIT_SCORE.
    <S_SCSOP>-SHTDI = 'B'.
    <S_SCSOP>-CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.
    if ME->GET_SOPCR( ) eq C_SCSOP_SLIT_SCORE or
       ME->GET_SOPCR( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
      <S_SCSOP>-ACTIV = ABAP_TRUE.
***   If Score Operation is active add also right Score Provider
      LT_PRVDR_SCORE_C = ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                                              IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).
      if LT_PRVDR_SCORE_C is not initial.
        append lines of LT_PRVDR_SCORE_C to LT_PRVDR_SLIT_W.
      endif.
    endif.
    <S_SCSOP>-T_PRVDR = LT_PRVDR_SLIT_W.
  endif.

endmethod.
method GET_SOPCR.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SOPCR ).
  move LS_PARAM-ATWRT to RF_SOPCR.

endmethod.
method GET_SOPCR_DESCR.

  data: LF_SOPCR      type ZVCXI_P0SS_SOPCR.

  LF_SOPCR = ME->GET_SOPCR( ).

*** Get Score Operation Cross Description
  RF_DESCR = ZCL_VCXI_P0SS_CUST_SCSTR=>GET_SCSOP_DESCR( IF_SCSOP = LF_SOPCR ).

endmethod.
method GET_SOPLE.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SOPLE ).
  move LS_PARAM-ATWRT to RF_SOPLE.

endmethod.
method GET_SOPLE_DESCR.

  data: LF_SOPLE      type ZVCXI_P0SS_SOPLE.

  LF_SOPLE = ME->GET_SOPLE( ).

*** Get Score Operation Length Description
  RF_DESCR = ZCL_VCXI_P0SS_CUST_SCSTR=>GET_SCSOP_DESCR( IF_SCSOP = LF_SOPLE ).

endmethod.
method GET_STATUS.

  RF_ELMST = SUPER->GET_STATUS( ).

***------------------------------------------------------------------------------------------------
*** Check Score Operation Length
  if ME->CHECK_SOPLE( ) eq 0.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------------------------------------
*** Check Score Operation Cross
  if ME->CHECK_SOPCR( ) eq 0.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------------------------------------
*** Check Sum of Trim
  if ME->CHECK_SUM_TRIM( ) eq 0.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
  else.
    RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                   IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endif.

***------------------------------------------------------------------------------------------------
*** Check Score Strings
  case ME->CHECK_SCSTR( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.


***------------------------------------------------------------------------------------------------
*** Check Score Strings Indicator
  case ME->CHECK_SCSTR_INDIC( ).
    when 0.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_G ).
    when others.
      RF_ELMST = /VCXI/CL_VKSR_SERVICE=>MERGE_ELMST( IF_ELMST1 = RF_ELMST
                                                     IF_ELMST2 = /VCXI/CL_VKSR_SERVICE=>C_ELMST_R ).
  endcase.

endmethod.
method GET_STATUS_MSG.

  SUPER->GET_STATUS_MSG( IR_MESSAGE = IR_MESSAGE ).

***------------------------------------------------------------------------------------------------
*** Check Score Operation Length
  case ME->CHECK_SOPLE( ).
    when 0.
***   Score Operation Length is maintained and valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '150' ).
    when 1.
***   Score Operation Length is maintained but not valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '151' ).
    when 2.
***   Score Operation Length is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '152' ).
  endcase.

***------------------------------------------------------------------------------------------------
*** Check Score Operation Cross
  case ME->CHECK_SOPCR( ).
    when 0.
***   Score Operation Cross is maintained and valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '153' ).
    when 1.
***   Score Operation Cross is maintained but not valid.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '154' ).
    when 2.
***   Score Operation Cross is not maintained.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '155' ).
  endcase.

***------------------------------------------------------------------------------------------------
*** Check Sum of Trim
  ME->CHECK_SUM_TRIM( IR_MSG = IR_MESSAGE ).

***------------------------------------------------------------------------------------------------
*** Check Score Strings
  case ME->CHECK_SCSTR( ).
    when 0.
***   Score Strings do have all needed Score Categories.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'S'
                               IF_MSGNO = '165' ).
    when 1.
***   Score Strings do not have all needed Cross Scores as Score Category.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '166' ).
    when 2.
***   Score Strings do not have all needed Length Scores as Score Category.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '167' ).
    when 3.
***   Score Strings do not have all needed Score Categories.
      IR_MESSAGE->ADD_MESSAGE( IF_MSGID = 'ZVCXI_P0SS'
                               IF_MSGTY = 'E'
                               IF_MSGNO = '168' ).
  endcase.

***------------------------------------------------------------------------------------------------
*** Check Score String Indicators
  ME->CHECK_SCSTR_INDIC( IR_MSG = IR_MESSAGE ).

endmethod.
method GET_TPLLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPLLT ).
  move LS_PARAM-ATFLV to RS_TRILT-TRILT.
  move LS_PARAM-UNIT  to RS_TRILT-TRILT_UOM.

endmethod.
method GET_TPLRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPLRB ).
  move LS_PARAM-ATFLV to RS_TRIRB-TRIRB.
  move LS_PARAM-UNIT  to RS_TRIRB-TRIRB_UOM.

endmethod.
method GET_TPSLT.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPSLT ).
  move LS_PARAM-ATFLV to RS_TRILT-TRILT.
  move LS_PARAM-UNIT  to RS_TRILT-TRILT_UOM.

endmethod.
method GET_TPSRB.

  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPSRB ).
  move LS_PARAM-ATFLV to RS_TRIRB-TRIRB.
  move LS_PARAM-UNIT  to RS_TRIRB-TRIRB_UOM.

endmethod.
method GET_TRIM.

  data: LF_OLLEN type ABAP_BOOL,
        LF_OLWID type ABAP_BOOL.
  data: LS_DTRIL type ZVCXI_P0SS_S_DTRIL,
        LS_DTRIW type ZVCXI_P0SS_S_DTRIW,
        LS_TRIPL type ZVCXI_P0SS_S_TRIPL,
        LS_TRIPS type ZVCXI_P0SS_S_TRIPS,
        LS_OLLEN type ZVCXI_P0SS_S_OLLEN,
        LS_OLWID type ZVCXI_P0SS_S_OLWID.

  if ME->R_SHTDIM is not bound.
    ME->HANDLE_INIT_REFERENCES( ).
  endif.
  check ME->R_SHTDIM is bound.

*** -------------------------------------------------------------------------------------------
*** Get Trim
  case IF_PARID.
    when C_TRIM_PARID_DTRIL.
***   Get Total Trim
      LS_DTRIL = ME->GET_DTRIL( ).
      move LS_DTRIL-DTRIL     to ES_TRITO-TRITO.
      move LS_DTRIL-DTRIL_UOM to ES_TRITO-TRITO_UOM.

***   Get Divison Tirm on Length - Left/Top and Right/Bottom
      ES_TRILT = ME->GET_DTLLT( ).
      ES_TRIRB = ME->GET_DTLRB( ).

      if ME->R_SHTDIM->GET_DUPSL( ) gt 1.
***     Overlap is needed
        LF_OLLEN = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_DTRIW.
***   Get Total Trim
      LS_DTRIW = ME->GET_DTRIW( ).
      move LS_DTRIW-DTRIW     to ES_TRITO-TRITO.
      move LS_DTRIW-DTRIW_UOM to ES_TRITO-TRITO_UOM.

***   Get Divison Trim on Width - Left/Top and Right/Bottom
      ES_TRILT = ME->GET_DTWLT( ).
      ES_TRIRB = ME->GET_DTWRB( ).

      if ME->R_SHTDIM->GET_DUPSW( ) gt 1.
***     Overlap is needed
        LF_OLWID = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_TRIPL.
***   Get Total Trim
      LS_TRIPL = ME->GET_TRIPL( ).
      move LS_TRIPL-TRIPL     to ES_TRITO-TRITO.
      move LS_TRIPL-TRIPL_UOM to ES_TRITO-TRITO_UOM.

***   Get Tirm on Length - Left/Top and Right/Bottom
      ES_TRILT = ME->GET_TPLLT( ).
      ES_TRIRB = ME->GET_TPLRB( ).

      if ME->R_SHTDIM->GET_DUPSL( ) le 1.
***     Overlap is needed
        LF_OLLEN = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_TRIPS.
***   Get Total Trim
      LS_TRIPS = ME->GET_TRIPS( ).
      move LS_TRIPS-TRIPS     to ES_TRITO-TRITO.
      move LS_TRIPS-TRIPS_UOM to ES_TRITO-TRITO_UOM.

***   Get Divison Trim on Width - Left/Top and Right/Bottom
      ES_TRILT = ME->GET_TPSLT( ).
      ES_TRIRB = ME->GET_TPSRB( ).

      if ME->R_SHTDIM->GET_DUPSW( ) le 1.
***     Overlap is needed
        LF_OLWID = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_OLLEN.
***   Return Overlap
      LF_OLLEN = ABAP_TRUE.

    when C_TRIM_PARID_OLWID.
***   Return Overlap
      LF_OLWID = ABAP_TRUE.

  endcase.

*** -------------------------------------------------------------------------------------------
*** Get Overlap
  case ABAP_TRUE.
    when LF_OLLEN.
***   Get Total Overlap
      LS_OLLEN = ME->GET_OLLEN( ).
      move LS_OLLEN-OLLEN     to ES_OVLTO-OVLTO.
      move LS_OLLEN-OLLEN_UOM to ES_OVLTO-OVLTO_UOM.

***   Get Overlap on Length Left/Top and Right/Bottom
      ES_OVLLT = ME->GET_OLLLT( ).
      ES_OVLRB = ME->GET_OLLRB( ).

    when LF_OLWID.
***   Get Total Overlap
      LS_OLWID = ME->GET_OLWID( ).
      move LS_OLWID-OLWID     to ES_OVLTO-OVLTO.
      move LS_OLWID-OLWID_UOM to ES_OVLTO-OVLTO_UOM.

***   Get Overlap on Width Left/Top and Right/Bottom
      ES_OVLLT = ME->GET_OLWLT( ).
      ES_OVLRB = ME->GET_OLWRB( ).

  endcase.

*** -------------------------------------------------------------------------------------------
*** Sum Up Trim Trim including Overlap
  if ES_TRILT_IO is requested.
    if ES_OVLLT-OVLLT is not initial.
      ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = ES_TRILT-TRILT
                                                          IF_CALCV_UOM_1 = ES_TRILT-TRILT_UOM
                                                          IF_CALCV_2     = ES_OVLLT-OVLLT
                                                          IF_CALCV_UOM_2 = ES_OVLLT-OVLLT_UOM
                                                          IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                          IF_UOM         = ES_TRILT-TRILT_UOM
                                                importing EF_CALCV       = ES_TRILT_IO-TRILT
                                                          EF_CALCV_UOM   = ES_TRILT_IO-TRILT_UOM ).
    else.
      move ES_TRILT to ES_TRILT_IO.
    endif.
  endif.

  if ES_TRIRB_IO is requested.
    if ES_OVLRB-OVLRB is not initial.
      ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = ES_TRIRB-TRIRB
                                                          IF_CALCV_UOM_1 = ES_TRIRB-TRIRB_UOM
                                                          IF_CALCV_2     = ES_OVLRB-OVLRB
                                                          IF_CALCV_UOM_2 = ES_OVLRB-OVLRB_UOM
                                                          IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_ADD
                                                          IF_UOM         = ES_TRIRB-TRIRB_UOM
                                                importing EF_CALCV       = ES_TRIRB_IO-TRIRB
                                                          EF_CALCV_UOM   = ES_TRIRB_IO-TRIRB_UOM ).
    else.
      move ES_TRIRB to ES_TRIRB_IO.
    endif.
  endif.

endmethod.
method GET_TRIPL.

  check ME->R_SHTDIM is bound.
  ME->R_SHTDIM->GET_TRIPL( importing ES_TRIPL = RS_TRIPL ).

endmethod.
method GET_TRIPL_DESCR.

  data: LS_DFIES     type        DFIES.
  data: LR_TYPEDESCR type ref to CL_ABAP_TYPEDESCR,
        LR_ELEMDESCR type ref to CL_ABAP_ELEMDESCR.

  LR_TYPEDESCR = CL_ABAP_ELEMDESCR=>DESCRIBE_BY_NAME( P_NAME = 'ZVCXI_P0SS_TRIPL' ).

  check LR_TYPEDESCR is bound.
  try.
      move LR_TYPEDESCR ?to LR_ELEMDESCR.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_ELEMDESCR.
  endtry.

  check LR_ELEMDESCR is bound.
  LS_DFIES = LR_ELEMDESCR->GET_DDIC_FIELD( ).

  move LS_DFIES-SCRTEXT_L to RF_DESCR.

endmethod.
method GET_TRIPS.

  check ME->R_SHTDIM is bound.
  ME->R_SHTDIM->GET_TRIPS( importing ES_TRIPS = RS_TRIPS ).

endmethod.
method GET_TRIPS_DESCR.

  data: LS_DFIES     type        DFIES.
  data: LR_TYPEDESCR type ref to CL_ABAP_TYPEDESCR,
        LR_ELEMDESCR type ref to CL_ABAP_ELEMDESCR.

  LR_TYPEDESCR = CL_ABAP_ELEMDESCR=>DESCRIBE_BY_NAME( P_NAME = 'ZVCXI_P0SS_TRIPS' ).

  check LR_TYPEDESCR is bound.
  try.
      move LR_TYPEDESCR ?to LR_ELEMDESCR.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_ELEMDESCR.
  endtry.

  check LR_ELEMDESCR is bound.
  LS_DFIES = LR_ELEMDESCR->GET_DDIC_FIELD( ).

  move LS_DFIES-SCRTEXT_L to RF_DESCR.

endmethod.
method GET_VALID_INDIC.

  data:          LF_INDIC      type        CHAR30,
                 LF_CSCOR      type        ZVCXI_P0SS_CSCOR.
  data:          LS_DTRIL      type        ZVCXI_P0SS_S_DTRIL,
                 LS_DTRIW      type        ZVCXI_P0SS_S_DTRIW,
                 LS_TRIPL      type        ZVCXI_P0SS_S_TRIPL,
                 LS_TRIPS      type        ZVCXI_P0SS_S_TRIPS,
                 LS_OLLEN      type        ZVCXI_P0SS_S_OLLEN,
                 LS_OLWID      type        ZVCXI_P0SS_S_OLWID.
  data:          LT_GATE_SCORE type        /VCXI/VKSR_TT_GATE,
                 LT_GATE_TAPE  type        /VCXI/VKSR_TT_GATE,
                 LT_INDIC      type        ZVCXI_P0SS_TT_INDIC.
  data:          LR_GATE       type ref to /VCXI/CL_VKSR_GATE,
                 LR_PR_SCORE   type ref to ZCL_VCXI_P0SS_PR_SCORE,
                 LR_PR_MS_TAPE type ref to ZCL_VCXI_P0SS_PR_MS_TAPE.

  check ME->R_GATE_SPEC is bound.

  if IF_IGNORE_SCORE_L eq ABAP_FALSE.
*** Collect all Score Types for length
    LT_GATE_SCORE = ME->GET_PRVDR_SCORE( IR_GATE_SPEC = ME->R_GATE_SPEC
                                         IF_CSCOR     = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).

    LT_INDIC = ZCL_VCXI_P0SS_CUST_SCSTR=>GET_TSCOR_INDIC( IT_GATE_SCORE = LT_GATE_SCORE
                                                          IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).

    append lines of LT_INDIC to RT_INDIC.
    delete adjacent duplicates from RT_INDIC.
  endif.

  if IF_IGNORE_SCORE_C eq ABAP_FALSE.
*** Collect all Score Types for Cross
    LT_GATE_SCORE = ME->GET_PRVDR_SCORE( IR_GATE_SPEC = ME->R_GATE_SPEC
                                         IF_CSCOR     = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).

    LT_INDIC = ZCL_VCXI_P0SS_CUST_SCSTR=>GET_TSCOR_INDIC( IT_GATE_SCORE = LT_GATE_SCORE
                                                          IF_CSCOR      = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).

    append lines of LT_INDIC to RT_INDIC.
    delete adjacent duplicates from RT_INDIC.
  endif.

*** Collect all Tape Types
  if IF_IGNORE_TAPE eq ABAP_FALSE.
    LT_GATE_TAPE = ME->GET_PRVDR_TAPE( IR_GATE_SPEC = ME->R_GATE_SPEC ).
    loop at LT_GATE_TAPE into LR_GATE.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_MS_TAPE.
          check LR_PR_MS_TAPE is bound.
          move LR_PR_MS_TAPE->GET_TTAPE( ) to LF_INDIC.
          collect LF_INDIC into RT_INDIC.

        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_SCORE.
      endtry.
    endloop.
  endif.

  if IF_IGNORE_DIVISION eq ABAP_FALSE.
*** Get Trim in case of no DieCut
    if ME->R_DCT                is not bound or
     ( ME->R_DCT                is bound     and
       ME->R_DCT->GET_TDCUT( )  is initial ).
      if ME->GET_SOPLE( ) ne C_SCSOP_SHTPR.
        LS_TRIPL = ME->GET_TRIPL( ).
        if ME->R_SHTDIM->GET_DUPSL( ) le 1.
          LS_OLLEN = ME->GET_OLLEN( ).
        endif.
      endif.
      if ME->GET_SOPCR( ) ne C_SCSOP_SHTPR.
        LS_TRIPS = ME->GET_TRIPS( ).
        if ME->R_SHTDIM->GET_DUPSW( ) le 1.
          LS_OLWID = ME->GET_OLWID( ).
        endif.
      endif.
    endif.

*** Get Division Trim
    LS_DTRIL = ME->GET_DTRIL( ).
    LS_DTRIW = ME->GET_DTRIW( ).

*** Get Overlaps
    if ME->R_SHTDIM->GET_DUPSL( ) gt 1.
      LS_OLLEN = ME->GET_OLLEN( ).
    endif.
    if ME->R_SHTDIM->GET_DUPSW( ) gt 1.
      LS_OLWID = ME->GET_OLWID( ).
    endif.

*** Add Cut Score Type if we have a Division/Ups
    check ME->R_SHTDIM is bound.
    if IF_IGNORE_SCORE_L eq ABAP_FALSE.
      if ME->R_SHTDIM->GET_DUPSW( ) gt 1 or
         LS_DTRIW-DTRIW             is not initial or
         LS_TRIPS-TRIPS             is not initial or
         LS_OLWID-OLWID             is not initial.

        move ME->F_TSCOR_CUT to LF_INDIC.
        collect LF_INDIC into RT_INDIC.
      endif.
    endif.
    if IF_IGNORE_SCORE_C eq ABAP_FALSE.
      if ME->R_SHTDIM->GET_DUPSL( ) gt 1 or
         LS_DTRIL-DTRIL             is not initial or
         LS_TRIPL-TRIPL             is not initial or
         LS_OLLEN-OLLEN             is not initial.

        move ME->F_TSCOR_CUT to LF_INDIC.
        collect LF_INDIC into RT_INDIC.
      endif.
    endif.
  endif.
endmethod.
method GET_VALID_TRIM_DIFF.

  data: LF_DUPSL type ZVCXI_P0SS_DUPSL,
        LF_DUPSW type ZVCXI_P0SS_DUPSW.
  data: LS_TRIMS type ZVCXI_P0SS_S_TRIMS,
        LS_TRIML type ZVCXI_P0SS_S_TRIML,
        LS_TRIPL type ZVCXI_P0SS_S_TRIPL,
        LS_TRIPS type ZVCXI_P0SS_S_TRIPS.

  check ME->R_SHTDIM is bound.

  if ES_TRIML is requested.
    LS_TRIML = ME->R_SHTDIM->GET_TRIML( ).
    LS_TRIPL = ME->GET_TRIPL( ).
    LF_DUPSL = ME->R_SHTDIM->GET_DUPSL( ).
*** Get Difference
    ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIML-TRIML
                                                        IF_CALCV_UOM_1 = LS_TRIML-TRIML_UOM
                                                        IF_CALCV_2     = LS_TRIPL-TRIPL
                                                        IF_CALCV_UOM_2 = LS_TRIPL-TRIPL_UOM
                                                        IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_SUBTRACT
                                                        IF_UOM         = LS_TRIPL-TRIPL_UOM
                                              importing EF_CALCV       = ES_TRIML-TRIML
                                                        EF_CALCV_UOM   = ES_TRIML-TRIML_UOM ).

    if IF_AFTER_DIV ne ABAP_TRUE.
      if LF_DUPSL is not initial.
        ES_TRIML-TRIML = ES_TRIML-TRIML * LF_DUPSL.
      endif.
    endif.

  endif.


  if ES_TRIMS is requested.
    LS_TRIMS = ME->R_SHTDIM->GET_TRIMS( ).
    LS_TRIPS = ME->GET_TRIPS( ).
    LF_DUPSW = ME->R_SHTDIM->GET_DUPSW( ).
*** Get Difference
    ZCL_VCXI_XCS_SERVICE_CALC=>CALC_WITH_ANY( exporting IF_CALCV_1     = LS_TRIMS-TRIMS
                                                        IF_CALCV_UOM_1 = LS_TRIMS-TRIMS_UOM
                                                        IF_CALCV_2     = LS_TRIPS-TRIPS
                                                        IF_CALCV_UOM_2 = LS_TRIPS-TRIPS_UOM
                                                        IF_OPERA       = ZCL_VCXI_XCS_SERVICE_CALC=>C_OPERA_SUBTRACT
                                                        IF_UOM         = LS_TRIPS-TRIPS_UOM
                                              importing EF_CALCV       = ES_TRIMS-TRIMS
                                                        EF_CALCV_UOM   = ES_TRIMS-TRIMS_UOM ).

    if IF_AFTER_DIV ne ABAP_TRUE.
      if LF_DUPSW is not initial.
        ES_TRIMS-TRIMS = ES_TRIMS-TRIMS * LF_DUPSW.
      endif.
    endif.

  endif.

endmethod.
method GET_WERKS.

  data: LR_APPDATA type ref to /VCXI/CL_VKSR_APPDATA.

  LR_APPDATA = ME->R_GATE->GET_APPDATA( ).

  RF_WERKS =  LR_APPDATA->F_WERKS.

endmethod.
method HANDLE_EVENT.

  SUPER->HANDLE_EVENT( IF_IEVNT         = IF_IEVNT
                       IT_GATE_PROVIDER = IT_GATE_PROVIDER ).

  case IF_IEVNT.
    when C_IEVNT_I_SET_DEFAULT.
      ME->HANDLE_SET_DEFAULT( ).

    when C_IEVNT_I_RECALC_SCSTR.
      ME->HANDLE_RECALC_SCSTR( ).

    when C_IEVNT_I_INIT_REFERENCES.
      ME->HANDLE_INIT_REFERENCES( ).

    when C_IEVNT_I_INIT_TRIM_ALLOC.
      ME->HANDLE_INIT_TRIM_ALLOC( ).
  endcase.

endmethod.
method HANDLE_INIT_REFERENCES.

***------------------------------------------------------------------------------------------------
*** Init Specification Reference
  ME->INIT_PRVDR_SPEC( ).

***------------------------------------------------------------------------------------------------
*** Init Sheet Dimension Reference
  ME->INIT_PRVDR_SHTDIM( IR_GATE_SPEC = ME->R_GATE_SPEC ).

***------------------------------------------------------------------------------------------------
*** Init Diecut Reference
  ME->INIT_PRVDR_DCT( IR_GATE_SPEC = ME->R_GATE_SPEC ).

endmethod.
method HANDLE_INIT_TRIM_ALLOC.

  data:  LS_DTRIW          type ZVCXI_P0SS_S_DTRIW,
         LS_DTRIL          type ZVCXI_P0SS_S_DTRIL,
         LS_TRIPS          type ZVCXI_P0SS_S_TRIPS,
         LS_TRIPL          type ZVCXI_P0SS_S_TRIPL,
         LS_TRILT          type ZVCXI_P0SS_S_TRILT,
         LS_TRIRB          type ZVCXI_P0SS_S_TRIRB,
         LS_OLWID          type ZVCXI_P0SS_S_OLWID,
         LS_OLLEN          type ZVCXI_P0SS_S_OLLEN,
         LS_OVLLT          type ZVCXI_P0SS_S_OVLLT,
         LS_OVLRB          type ZVCXI_P0SS_S_OVLRB.

*** Init Division Trim Width
  move ME->GET_DTRIW( )          to LS_DTRIW.
  if LS_DTRIW-DTRIW is initial.
    move ME->GET_DTWLT( )        to LS_TRILT.
    move ME->GET_DTWRB( )        to LS_TRIRB.
    clear: LS_TRILT-TRILT, LS_TRIRB-TRIRB.
    ME->SET_DTWLT( IS_TRILT = LS_TRILT
                   IF_SETBY = SPACE ).
    ME->SET_DTWRB( IS_TRIRB = LS_TRIRB
                   IF_SETBY = SPACE ).
  endif.

*** Init Division Trim Length
  move ME->GET_DTRIL( )          to LS_DTRIL.
  if LS_DTRIL-DTRIL is initial.
    move ME->GET_DTLLT( )        to LS_TRILT.
    move ME->GET_DTLRB( )        to LS_TRIRB.
    clear: LS_TRILT-TRILT, LS_TRIRB-TRIRB.
    ME->SET_DTLLT( IS_TRILT = LS_TRILT
                   IF_SETBY = SPACE ).
    ME->SET_DTLRB( IS_TRIRB = LS_TRIRB
                   IF_SETBY = SPACE ).
  endif.

*** Init Side Trim
  move ME->GET_TRIPS( )          to LS_TRIPS.
  if LS_TRIPS-TRIPS is initial.
    move ME->GET_TPSLT( )        to LS_TRILT.
    move ME->GET_TPSRB( )        to LS_TRIRB.
    clear: LS_TRILT-TRILT, LS_TRIRB-TRIRB.
    ME->SET_TPSLT( IS_TRILT = LS_TRILT
                   IF_SETBY = SPACE ).
    ME->SET_TPSRB( IS_TRIRB = LS_TRIRB
                   IF_SETBY = SPACE ).
  endif.

*** Init Length Trim
  move ME->GET_TRIPL( )          to LS_TRIPL.
  if LS_TRIPL-TRIPL is initial.
    move ME->GET_TPLLT( )        to LS_TRILT.
    move ME->GET_TPLRB( )        to LS_TRIRB.
    clear: LS_TRILT-TRILT, LS_TRIRB-TRIRB.
    ME->SET_TPLLT( IS_TRILT = LS_TRILT
                   IF_SETBY = SPACE ).
    ME->SET_TPLRB( IS_TRIRB = LS_TRIRB
                   IF_SETBY = SPACE ).
  endif.

*** Init Overlap on Width
  move ME->GET_OLWID( )          to LS_OLWID.
  if LS_OLWID-OLWID is initial.
    move ME->GET_OLWLT( )        to LS_OVLLT.
    move ME->GET_OLWRB( )        to LS_OVLRB.
    clear: LS_OVLLT-OVLLT, LS_OVLRB-OVLRB.
    ME->SET_OLWLT( IS_OVLLT = LS_OVLLT
                   IF_SETBY = SPACE ).
    ME->SET_OLWRB( IS_OVLRB = LS_OVLRB
                   IF_SETBY = SPACE ).
  endif.

*** Init Overlap on Length
  move ME->GET_OLLEN( )          to LS_OLLEN.
  if LS_OLLEN-OLLEN is initial.
    move ME->GET_OLLLT( )        to LS_OVLLT.
    move ME->GET_OLLRB( )        to LS_OVLRB.
    clear: LS_OVLLT-OVLLT, LS_OVLRB-OVLRB.
    ME->SET_OLLLT( IS_OVLLT = LS_OVLLT
                   IF_SETBY = SPACE ).
    ME->SET_OLLRB( IS_OVLRB = LS_OVLRB
                   IF_SETBY = SPACE ).
  endif.

endmethod.
method HANDLE_RECALC_SCSTR.

  data: LF_SPLIT        type        ABAP_BOOL,
        LF_NO_CALC      type        ABAP_BOOL,
        LF_FNEST        type        ZVCXI_P0SS_FNEST,
        LF_OP_NUMBER    type        I,
        LF_SOPLE        type        ABAP_BOOL,
        LF_SOPCR        type        ABAP_BOOL,
        LF_ACTIVE_SCSOP type        ABAP_BOOL.
  data: LS_SCSOP        type        ZVCXI_P0SS_S_SCSOP.
  data: LT_SCSOP        type        ZVCXI_P0SS_TT_SCSOP,
        LT_GATE         type        /VCXI/VKSR_TT_GATE.
  data: LR_GATE         type ref to /VCXI/CL_VKSR_GATE,
        LR_PR_SCSTR     type ref to ZCL_VCXI_P0SS_PR_SCSTR.

***------------------------------------------------------------------------------------------------
*** Raise first all events and then go ahead with update Score Strings
  ME->R_GATE->RAISE_EVENTS( IF_LEVNT = 9 ).

***------------------------------------------------------------------------------------------------
*** Init wrong score operations
  ME->INIT_SCSOP( ).

***------------------------------------------------------------------------------------------------
*** Get all Scores and Update the current Data
  ME->UPDATE_SCSTR( ).

***------------------------------------------------------------------------------------------------
*** Raise first all events and then go ahead with recalculations
  ME->R_GATE->RAISE_EVENTS( IF_LEVNT = 9 ).

***------------------------------------------------------------------------------------------------
*** Get all Scores Strings
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_SCSTR=>C_IPRVT_P0_SCSTR
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = ABAP_TRUE ).

***------------------------------------------------------------------------------------------------
*** Get all Valid/Needed Score String Operations and Start Recalc
  LT_SCSOP = ME->GET_SCSOP( ).

*** Get nested Flag
  LF_FNEST = ME->GET_FNEST( ).

  delete LT_SCSOP where SCSOP eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE.

  loop at LT_SCSOP into LS_SCSOP.
    move SY-TABIX to LF_OP_NUMBER.
*** Get Split active or not
*** and consider in case of Flag Nested, that we can not calculate the Tape Positions!
    clear: LF_SPLIT, LF_NO_CALC, LF_ACTIVE_SCSOP.
    case LS_SCSOP-CSCOR.
***   Length Scores
      when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH.

***     Active Operation -> Save it
        if LS_SCSOP-ACTIV eq ABAP_TRUE.
          move ABAP_TRUE to LF_SOPLE.
          move ABAP_TRUE to LF_ACTIVE_SCSOP.
        endif.

***     In Case of Split we have a Valid Score Operation for and Set Split indicator
        if ME->GET_SOPLE( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
          move ABAP_TRUE to LF_SPLIT.
          move ABAP_TRUE to LF_SOPLE.
          move ABAP_TRUE to LF_ACTIVE_SCSOP.
        endif.

***   Cross Scores
      when ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS.

***     Active Operation -> Save it
        if LS_SCSOP-ACTIV eq ABAP_TRUE.
          move ABAP_TRUE to LF_SOPCR.
          move ABAP_TRUE to LF_ACTIVE_SCSOP.
        endif.

***     In Case of Split we have a Valid Score Operation for and Set Split indicator
        if ME->GET_SOPCR( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT.
          move ABAP_TRUE to LF_SPLIT.
          move ABAP_TRUE to LF_SOPCR.
          move ABAP_TRUE to LF_ACTIVE_SCSOP.
        endif.

    endcase.

*** Check what can't be calculated
    LF_NO_CALC = ME->CHECK_NO_CALC( IF_CSCOR   = LS_SCSOP-CSCOR
                                    IF_FNEST   = LF_FNEST
                                    IF_ACTIV   = LF_ACTIVE_SCSOP
                                    IF_SCSOP   = LS_SCSOP-SCSOP ).

*** Cutting will be always "Calculated"
    if LS_SCSOP-SCSOP eq ZCL_VCXI_P0SS_BL_SCSOP_CUT=>C_SCSOP_CUTTING.
      clear: LF_NO_CALC.
    endif.

***------------------------------------------------------------------------------------------------
*** Get Right Score String and trigger Recalculation
    read table LT_GATE into LR_GATE index LF_OP_NUMBER.
    if SY-SUBRC eq 0.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_SCSTR.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_SCSTR.
      endtry.

      check LR_PR_SCSTR is bound.
      LR_PR_SCSTR->DO_RECALC( IT_PRVDR   = LS_SCSOP-T_PRVDR
                              IF_SPLIT   = LF_SPLIT
                              IF_FNEST   = LF_FNEST
                              IF_NO_CALC = LF_NO_CALC ).

    endif.
  endloop.

  if ME->GET_SOPLE( ) ne ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE  and
     LF_SOPLE         eq ABAP_FALSE.
    ME->SET_SOPLE( IF_SOPLE = SPACE ).
  endif.
  if ME->GET_SOPCR( ) ne ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE  and
     LF_SOPCR         eq ABAP_FALSE.
    ME->SET_SOPCR( IF_SOPCR = SPACE ).
  endif.

endmethod.
method HANDLE_SET_DEFAULT.

  ZCL_VCXI_XCDR_SERVICE=>SET_DEFAULT( IR_GATE = ME->R_GATE ).

endmethod.
method INIT_PRVDR_DCT.

  data:  LT_GATE_DCT  type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_DCT  type ref to /VCXI/CL_VKSR_GATE.

  check IR_GATE_SPEC is bound.

***------------------------------------------------------------------------------------------------
*** Find Provider for Die Cut
  LT_GATE_DCT = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_P0SS_DCT=>C_IPRVT_P0_DCT
                                       IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE_DCT into LR_GATE_DCT.
*** Check is child of Specification
    check LR_GATE_DCT->GET_PARENT( ) eq IR_GATE_SPEC.
    move LR_GATE_DCT to ME->R_GATE_DCT.
    exit.
  endloop.

  check ME->R_GATE_DCT is bound.
  try.
      move ME->R_GATE_DCT->R_CLSPR ?to ME->R_DCT.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

endmethod.
method INIT_PRVDR_PRODDIM.

  data:  LT_GATE_PRODDIM  type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_PRODDIM  type ref to /VCXI/CL_VKSR_GATE.

  check IR_GATE_SPEC is bound.

***------------------------------------------------------------------------------------------------
*** Find Provider for Product Dimension
  LT_GATE_PRODDIM = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_P0SS_PRODDIM=>C_IPRVT_P0_PRODDIM
                                           IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE_PRODDIM into LR_GATE_PRODDIM.
*** Check is child of Specification
    check LR_GATE_PRODDIM->GET_PARENT( ) eq IR_GATE_SPEC.
    move LR_GATE_PRODDIM to ME->R_GATE_PRODDIM.
    exit.
  endloop.

endmethod.
method INIT_PRVDR_SHTDIM.

  data:  LT_GATE_SHTDIM  type        /VCXI/VKSR_TT_GATE.
  data:  LR_GATE_SHTDIM  type ref to /VCXI/CL_VKSR_GATE.

  check IR_GATE_SPEC is bound.

***------------------------------------------------------------------------------------------------
*** Find Provider for Sheet Dimension
  LT_GATE_SHTDIM = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZIF_VCXI_P0SS_SHTDIM=>C_IPRVT_P0_SHTDIM
                                          IF_INUSE = ABAP_TRUE ).

  loop at LT_GATE_SHTDIM into LR_GATE_SHTDIM.
*** Check is child of Specification
    check LR_GATE_SHTDIM->GET_PARENT( ) eq IR_GATE_SPEC.
    move LR_GATE_SHTDIM to ME->R_GATE_SHTDIM.
    exit.
  endloop.

  check ME->R_GATE_SHTDIM is bound.
  try.
      move ME->R_GATE_SHTDIM->R_CLSPR ?to ME->R_SHTDIM.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: ME->R_SHTDIM.
  endtry.

  if ME->R_SHTDIM is not bound.
*** Provider &1 is not available for &2.
    /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE(
        IF_MSGTY = 'E'
        IF_MSGID = 'ZVCXI_XCS'
        IF_MSGNO = '010'
        IF_MSGV1 = ZIF_VCXI_P0SS_SHTDIM=>C_IPRVT_P0_SHTDIM
        IF_MSGV2 = ME->R_GATE->F_ID ).
  endif.

endmethod.
method INIT_PRVDR_SPEC.

  data:  LT_GATE  type /VCXI/VKSR_TT_GATE.

***------------------------------------------------------------------------------------------------
*** Find Provider for Specification (STD)
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_P0SS_PR_SPEC=>C_IPRVT_P0_SPEC
                                   IF_INUSE = ABAP_TRUE ).
  if LT_GATE is not initial.
    read table LT_GATE into ME->R_GATE_SPEC index 1.
  endif.

  if ME->R_GATE_SPEC is not bound.
*** Provider &1 is not available for &2.
    /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE(
        IF_MSGTY = 'E'
        IF_MSGID = 'ZVCXI_XCS'
        IF_MSGNO = '010'
        IF_MSGV1 = ZCL_VCXI_P0SS_PR_SPEC=>C_IPRVT_P0_SPEC
        IF_MSGV2 = ME->R_GATE->F_ID ).
  endif.

endmethod.
method INIT_SCSOP.

  data: LF_SOPCR type ZVCXI_P0SS_SOPCR,
        LF_SOPLE type ZVCXI_P0SS_SOPLE.
  data: LT_SCSOP type ZVCXI_P0SS_TT_SCSOP.

  LF_SOPLE = ME->GET_SOPLE( ).
  LF_SOPCR = ME->GET_SOPCR( ).

*** Refresh Score String Operations
  LT_SCSOP = ME->GET_ALL_VALID_SCSOP( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH ).
  read table LT_SCSOP with key SCSOP = LF_SOPLE
                      transporting no fields.

  if SY-SUBRC ne 0.
    ME->SET_SOPLE( IF_SOPLE = SPACE ).
  endif.

  LT_SCSOP = ME->GET_ALL_VALID_SCSOP( IF_CSCOR = ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS ).
  read table LT_SCSOP with key SCSOP = LF_SOPCR
                      transporting no fields.

  if SY-SUBRC ne 0.
    ME->SET_SOPCR( IF_SOPCR = SPACE ).
  endif.

endmethod.
method INIT_SCSTR_CALC.

  data:          LS_ATTRI         type        /VCXI/VKS_S_ATTRI.

***----------------------------------------------------------------------------
*** Get Score String Calculation (by Attribute)
  try.
      LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_SCSTR_CALC ).
    catch /VCXI/CX_CKX.
      clear LS_ATTRI.
  endtry.

  if LS_ATTRI is not initial.
    condense LS_ATTRI-ATTVA no-gaps.
    move LS_ATTRI-ATTVA to ME->F_SSTRC.
  endif.

endmethod.
method INIT_TSCOR_CUT.

  data:          LS_ATTRI         type        /VCXI/VKS_S_ATTRI.

***----------------------------------------------------------------------------
*** Get Score String Calculation (by Attribute)
  try.
      LS_ATTRI = ME->R_GATE->GET_ATTRI( IF_ATTID = C_ATTID_TSCOR_CUT ).
    catch /VCXI/CX_CKX.
      clear LS_ATTRI.
  endtry.

  if LS_ATTRI is not initial.
    condense LS_ATTRI-ATTVA no-gaps.
    move LS_ATTRI-ATTVA to ME->F_TSCOR_CUT.
  endif.

endmethod.
method IS_CHECK_INDIC_NEEDED.

  RF_RETURN = ABAP_TRUE.

endmethod.
method IS_MS_SHTPR_ACTIVE.

  data:  LR_GATE_MS_SHTPR type ref to /VCXI/CL_VKSR_GATE,
         LR_PR_MS_SHTPR   type ref to ZCL_VCXI_P0SS_PR_MS_SHTPR.

*** Check specification is bound
  check ME->R_GATE_SPEC is bound.

*** Find Provider for Sheet Procurement
  LR_GATE_MS_SHTPR = ME->GET_PRVDR_MS_SHTPR( IR_GATE_SPEC = ME->R_GATE_SPEC ).
  check LR_GATE_MS_SHTPR is bound.
  RF_ACTIVE = ABAP_TRUE.

  check IF_INCL_CUT is supplied.
  try.
      move LR_GATE_MS_SHTPR->R_CLSPR ?to LR_PR_MS_SHTPR.
    catch CX_SY_MOVE_CAST_ERROR.
      clear: LR_GATE_MS_SHTPR.
  endtry.

  if LR_PR_MS_SHTPR is bound and
     LR_PR_MS_SHTPR->GET_FLCUT( ) eq ABAP_TRUE.
    RF_ACTIVE = ABAP_TRUE.
  else.
    RF_ACTIVE = ABAP_FALSE.
  endif.

endmethod.
method IS_SHTPR_CUTTED.

  data:          LR_GATE_MS_SHTPR  type ref to /VCXI/CL_VKSR_GATE,
                 LR_PR_MS_SHTPR    type ref to ZCL_VCXI_P0SS_PR_MS_SHTPR.

*** Find Provider for Sheet Procurement
  LR_GATE_MS_SHTPR = ME->GET_PRVDR_MS_SHTPR( IR_GATE_SPEC = ME->R_GATE_SPEC ).
  if LR_GATE_MS_SHTPR is bound.

***------------------------------------------------------------------------------------------------
*** Cutting is not relevant if we have it on the Sheet Procurement
    try.
        move LR_GATE_MS_SHTPR->R_CLSPR ?to LR_PR_MS_SHTPR.
      catch CX_SY_MOVE_CAST_ERROR.
        clear: LR_PR_MS_SHTPR.
    endtry.

    check LR_PR_MS_SHTPR               is bound.
    move  LR_PR_MS_SHTPR->GET_FLCUT( ) to RF_CUTTED.
  endif.

endmethod.
method IS_TAPE_ACTIVE.

*** Check specification is bound
  check ME->R_GATE_SPEC is bound.

*** Find Provider for Tapes
  check ME->GET_PRVDR_TAPE( IR_GATE_SPEC = ME->R_GATE_SPEC ) is not initial.
  RF_ACTIVE = ABAP_TRUE.


endmethod.
method NO_SCORES.

*** Check Provider Scores
  if ME->GET_PRVDR_SCORE( IR_GATE_SPEC  = ME->R_GATE_SPEC
                          IF_CSCOR      = IF_CSCOR        ) is initial.
    move ABAP_TRUE to RF_RETURN.
  endif.

endmethod.
method SET_DTLLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTLLT ).

  move IS_TRILT-TRILT     to LS_PARAM-ATFLV.
  move IS_TRILT-TRILT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_DTLRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTLRB ).

  move IS_TRIRB-TRIRB     to LS_PARAM-ATFLV.
  move IS_TRIRB-TRIRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_DTWLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTWLT ).

  move IS_TRILT-TRILT     to LS_PARAM-ATFLV.
  move IS_TRILT-TRILT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_DTWRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_DTWRB ).

  move IS_TRIRB-TRIRB     to LS_PARAM-ATFLV.
  move IS_TRIRB-TRIRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_OLLLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLLLT ).

  move IS_OVLLT-OVLLT     to LS_PARAM-ATFLV.
  move IS_OVLLT-OVLLT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_OLLRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLLRB ).

  move IS_OVLRB-OVLRB     to LS_PARAM-ATFLV.
  move IS_OVLRB-OVLRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_OLWLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLWLT ).

  move IS_OVLLT-OVLLT     to LS_PARAM-ATFLV.
  move IS_OVLLT-OVLLT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_OLWRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_OLWRB ).

  move IS_OVLRB-OVLRB     to LS_PARAM-ATFLV.
  move IS_OVLRB-OVLRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_SOPCR.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SOPCR ).

  if IF_SOPCR is not initial.
    move IF_SOPCR to LS_PARAM-ATWRT.
    move IF_SETBY to LS_PARAM-SETBY.
  else.
    clear: LS_PARAM-ATWRT, LS_PARAM-SETBY.
  endif.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_SOPCR_CHANGED ).
  endif.

endmethod.
method SET_SOPLE.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_SOPLE ).

  if IF_SOPLE is not initial.
    move IF_SOPLE to LS_PARAM-ATWRT.
    move IF_SETBY to LS_PARAM-SETBY.
  else.
    clear: LS_PARAM-ATWRT, LS_PARAM-SETBY.
  endif.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_SOPLE_CHANGED ).
  endif.

endmethod.
method SET_TPLLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPLLT ).

  move IS_TRILT-TRILT     to LS_PARAM-ATFLV.
  move IS_TRILT-TRILT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_TPLRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPLRB ).

  move IS_TRIRB-TRIRB     to LS_PARAM-ATFLV.
  move IS_TRIRB-TRIRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_TPSLT.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPSLT ).

  move IS_TRILT-TRILT     to LS_PARAM-ATFLV.
  move IS_TRILT-TRILT_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_TPSRB.

  data:  LF_CHANGED type ABAP_BOOL.
  data:  LS_PARAM   type /VCXI/VKSR_S_PARAM.

  LS_PARAM = ME->R_GATE->GET_PARAM( IF_PARID = C_PARID_TPSRB ).

  move IS_TRIRB-TRIRB     to LS_PARAM-ATFLV.
  move IS_TRIRB-TRIRB_UOM to LS_PARAM-UNIT.
  move IF_SETBY           to LS_PARAM-SETBY.

  LF_CHANGED = ME->R_GATE->SET_PARAM( IS_PARAM = LS_PARAM ).

  if LF_CHANGED eq ABAP_TRUE.
*** Send Event
    ME->R_GATE->SET_EVENT( IF_IEVNT = C_IEVNT_O_TRIM_ALLOC_CHANGED ).
  endif.

endmethod.
method SET_TRIM.

  data: LF_OLLEN type ABAP_BOOL,
        LF_OLWID type ABAP_BOOL.

  check ME->R_SHTDIM is bound.

*** -------------------------------------------------------------------------------------------
*** Set Trim
  case IF_PARID.
    when C_TRIM_PARID_DTRIL.
***   Set Divison Tirm on Length - Left/Top and Right/Bottom
      if IS_TRILT ne ME->GET_DTLLT( ) and
         IS_TRILT is supplied.
        ME->SET_DTLLT( IS_TRILT = IS_TRILT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_TRIRB ne ME->GET_DTLRB( ) and
         IS_TRIRB is supplied.
        ME->SET_DTLRB( IS_TRIRB = IS_TRIRB
                       IF_SETBY = IF_SETBY ).
      endif.

      if ME->R_SHTDIM->GET_DUPSL( ) gt 1.
***     Overlap is needed
        LF_OLLEN = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_DTRIW.
***   Set Divison Trim on Width - Left/Top and Right/Bottom
      if IS_TRILT ne ME->GET_DTWLT( ) and
         IS_TRILT is supplied.
        ME->SET_DTWLT( IS_TRILT = IS_TRILT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_TRIRB ne ME->GET_DTWRB( ) and
         IS_TRIRB is supplied.
        ME->SET_DTWRB( IS_TRIRB = IS_TRIRB
                       IF_SETBY = IF_SETBY ).
      endif.

      if ME->R_SHTDIM->GET_DUPSW( ) gt 1.
***     Overlap is needed
        LF_OLWID = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_TRIPL.
***   Set Tirm on Length - Left/Top and Right/Bottom
      if IS_TRILT ne ME->GET_TPLLT( ) and
         IS_TRILT is supplied.
        ME->SET_TPLLT( IS_TRILT = IS_TRILT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_TRIRB ne ME->GET_TPLRB( ) and
         IS_TRIRB is supplied.
        ME->SET_TPLRB( IS_TRIRB = IS_TRIRB
                       IF_SETBY = IF_SETBY ).
      endif.

      if ME->R_SHTDIM->GET_DUPSL( ) le 1.
***     Overlap is needed
        LF_OLLEN = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_TRIPS.
***   Set Divison Trim on Width - Left/Top and Right/Bottom
      if IS_TRILT ne ME->GET_TPSLT( ) and
         IS_TRILT is supplied.
        ME->SET_TPSLT( IS_TRILT = IS_TRILT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_TRIRB ne ME->GET_TPSRB( ) and
         IS_TRIRB is supplied.
        ME->SET_TPSRB( IS_TRIRB = IS_TRIRB
                       IF_SETBY = IF_SETBY ).
      endif.

      if ME->R_SHTDIM->GET_DUPSW( ) le 1.
***     Overlap is needed
        LF_OLWID = ABAP_TRUE.
      endif.

    when C_TRIM_PARID_OLLEN.
***   Return Overlap
      LF_OLLEN = ABAP_TRUE.

    when C_TRIM_PARID_OLWID.
***   Return Overlap
      LF_OLWID = ABAP_TRUE.

  endcase.

*** -------------------------------------------------------------------------------------------
*** Set Overlap
  case ABAP_TRUE.
    when LF_OLLEN.
***   Set Overlap on Length Left/Top and Right/Bottom
      if IS_OVLLT ne ME->GET_OLLLT( ) and
         IS_OVLLT is supplied.
        ME->SET_OLLLT( IS_OVLLT = IS_OVLLT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_OVLRB ne ME->GET_OLLRB( ) and
         IS_OVLRB is supplied.
        ME->SET_OLLRB( IS_OVLRB = IS_OVLRB
                       IF_SETBY = IF_SETBY ).
      endif.

    when LF_OLWID.
***   Set Overlap on Width Left/Top and Right/Bottom
      if IS_OVLLT ne ME->GET_OLWLT( ) and
         IS_OVLLT is supplied.
        ME->SET_OLWLT( IS_OVLLT = IS_OVLLT
                       IF_SETBY = IF_SETBY ).
      endif.
      if IS_OVLRB ne ME->GET_OLWRB( ) and
         IS_OVLRB is supplied.
        ME->SET_OLWRB( IS_OVLRB = IS_OVLRB
                       IF_SETBY = IF_SETBY ).
      endif.

  endcase.

endmethod.
method UPDATE_SCSTR.

  data: LF_CSCOR        type        ZVCXI_P0SS_CSCOR,
        LF_CH_CSCOR     type        ABAP_BOOL,
        LF_CH_SHTDI     type        ABAP_BOOL.
  data: LS_SCSOP        type        ZVCXI_P0SS_S_SCSOP,
        LS_PRVDR_DEF    type        /VCXI/VKSR_S_PRVDR_DEF.
  data: LT_SCSOP        type        ZVCXI_P0SS_TT_SCSOP,
        LT_GATE         type        /VCXI/VKSR_TT_GATE,
        LT_PRVDR_DEF    type        /VCXI/VKSR_TT_PRVDR_DEF.
  data: LR_GATE         type ref to /VCXI/CL_VKSR_GATE,
        LR_PR_SCSTR     type ref to ZCL_VCXI_P0SS_PR_SCSTR.

***------------------------------------------------------------------------------------------------
*** Get all Scores Strings
  LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT  = ZCL_VCXI_P0SS_PR_SCSTR=>C_IPRVT_P0_SCSTR
                                   IF_INUSE  = ABAP_TRUE
                                   IF_SORTED = ABAP_TRUE ).

***------------------------------------------------------------------------------------------------
*** Get all Valid/Needed Score String Operations
  LT_SCSOP = ME->GET_SCSOP( ).


  delete LT_SCSOP where SCSOP eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_NONE.

  loop at LT_SCSOP into LS_SCSOP.
    clear: LF_CH_CSCOR, LF_CH_SHTDI.
    read table LT_GATE into LR_GATE index 1.
    if SY-SUBRC eq 0.
      try.
          move LR_GATE->R_CLSPR ?to LR_PR_SCSTR.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_SCSTR.
      endtry.

***   Remvoe from List of available Scores
      delete LT_GATE where TABLE_LINE eq LR_GATE.

    else.

***------------------------------------------------------------------------------------------------
***   Get Provider Definitions if not already done
      if LS_PRVDR_DEF is initial.
        LT_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( IF_IPRVT = ZCL_VCXI_P0SS_PR_SCSTR=>C_IPRVT_P0_SCSTR
                                                  IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD ).
        read table LT_PRVDR_DEF into LS_PRVDR_DEF index 1.
      endif.

***   Create Score String
      LR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = LS_PRVDR_DEF-ID ).

      if LR_GATE->IS_INUSE( )  ne ABAP_TRUE and
         LR_GATE->GET_USYNC( ) ne ABAP_TRUE.
        LR_GATE->SET_INUSE( IF_INUSE = ABAP_TRUE ).
      endif.

      try.
          move LR_GATE->R_CLSPR ?to LR_PR_SCSTR.
        catch CX_SY_MOVE_CAST_ERROR.
          clear: LR_PR_SCSTR.
      endtry.

    endif.

    check LR_PR_SCSTR is bound.
***------------------------------------------------------------------------------------------------
*** Set Values
*** Score Operation
    if LR_PR_SCSTR->GET_SCSOP( ) ne LS_SCSOP-SCSOP.
      LR_PR_SCSTR->SET_SCSOP( IF_SCSOP = LS_SCSOP-SCSOP ).

***   Set also Score String to Initial!
      LR_PR_SCSTR->SET_SCSTR( IF_SCSTR = SPACE ).

***   Update also Score Category
      LF_CH_CSCOR = ABAP_TRUE.

    endif.

*** Sheet Dimension
    if LR_PR_SCSTR->GET_SHTDI( ) ne LS_SCSOP-SHTDI.
      LR_PR_SCSTR->SET_SHTDI( IF_SHTDI = LS_SCSOP-SHTDI ).

***   Update also Score Category
      LF_CH_SHTDI = ABAP_TRUE.

***   TEST
***   Set also Score String to Initial!
      LR_PR_SCSTR->SET_SCSTR( IF_SCSTR = SPACE ).

    endif.

*** Score Category
    if ( LS_SCSOP-CSCOR   eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_LENGTH  and
         ME->GET_SOPLE( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT   and
         LF_CH_CSCOR      eq ABAP_FALSE                                and
         LF_CH_SHTDI      eq ABAP_FALSE                              ) or
       ( LS_SCSOP-CSCOR   eq ZCL_VCXI_P0SS_CUST_PRSTY=>C_CSCOR_CROSS   and
         ME->GET_SOPCR( ) eq ZCL_VCXI_P0SS_CUST_SCSTR=>C_SCSOP_SPLIT   and
         LF_CH_CSCOR      eq ABAP_FALSE                                and
         LF_CH_SHTDI      eq ABAP_FALSE                              ).
*** Do not change Score Category
    else.
      clear: LF_CSCOR.
      if LS_SCSOP-ACTIV eq ABAP_TRUE.
        move LS_SCSOP-CSCOR to LF_CSCOR.
      endif.

      if LR_PR_SCSTR->GET_CSCOR( ) ne LF_CSCOR.
        LR_PR_SCSTR->SET_CSCOR( IF_CSCOR = LF_CSCOR ).
      endif.
    endif.


  endloop.

***------------------------------------------------------------------------------------------------
*** Remove Scores Strings that are no longer needed
  loop at LT_GATE into LR_GATE.
    LR_GATE->DO_FREE( ).
  endloop.

endmethod.
