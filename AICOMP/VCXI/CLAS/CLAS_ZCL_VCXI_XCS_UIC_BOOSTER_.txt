
class ZCL_VCXI_XCS_UIC_BOOSTER definition
  public
  final
  create protected .

public section.

  interfaces /VCXI/IF_CKX_OBJECT_LOCKING .

  data S_BOOSTER_VIS type ZVCXI_XCS_S_BOOSTER_VIS read-only .

  methods DO_FREE
    raising
      /VCXI/CX_CKX .
  methods DO_MODIFY_SCREEN_BOOSTER
    importing
      !IF_REPID type SYREPID
      !IF_DYNNR type SYDYNNR
    raising
      /VCXI/CX_CKX .
  methods DO_PBO
    raising
      /VCXI/CX_CKX .
  methods DO_UPDATE_BOOSTER_VIS
    importing
      !IS_BOOSTER_VIS type ZVCXI_XCS_S_BOOSTER_VIS
    raising
      /VCXI/CX_CKX .
  methods DO_USER_COMMAND
    changing
      !CF_UCOMM type SYUCOMM
    raising
      /VCXI/CX_CKX .
  methods GET_DUI_INFO
    returning
      value(RS_DYNP) type /VCXI/CKX_S_DYNP_KEY
    raising
      /VCXI/CX_CKX .
  class-methods START_UI
    raising
      /VCXI/CX_CKX .
protected section.

  constants C_UC_ADD_BOOSTER type SYUCOMM value 'BOOSTER' ##NO_TEXT.
  constants C_UC_ADD_NODE type SYUCOMM value 'ADD_NODE' ##NO_TEXT.
  constants C_UC_BACK type SYUCOMM value 'BACK' ##NO_TEXT.
  constants C_UC_CANCEL type SYUCOMM value 'CANCEL' ##NO_TEXT.
  constants C_UC_DELETE type SYUCOMM value 'DELETE' ##NO_TEXT.
  constants C_UC_EXIT type SYUCOMM value 'EXIT' ##NO_TEXT.
  constants C_UC_OPEN type SYUCOMM value 'OPEN' ##NO_TEXT.
  constants C_UC_SAVE type SYUCOMM value 'SAVE' ##NO_TEXT.
  constants C_UC_TOGGLE type SYUCOMM value 'TOOGLE' ##NO_TEXT.
  data F_NODE_KEY_SEL type TM_NODEKEY .
  data R_CONTAINER type ref to CL_GUI_DOCKING_CONTAINER .
  data R_TREE type ref to CL_SIMPLE_TREE_MODEL .
  data S_DYNP type /VCXI/CKX_S_DYNP_KEY .

  methods ADD_NODES
    importing
      !IF_RELATKEY type TM_NODEKEY
      !IR_OBJECT type ref to /VCXI/IF_CKX_OBJECT
      !IT_NODEKEY_EXPANDED type TREEMNOTAB optional
    returning
      value(RF_NODEKEY) type TM_NODEKEY
    raising
      /VCXI/CX_CKX .
  methods CALL_SHLP_CUPRFL
    returning
      value(RR_CUPRFL) type ref to /VCXI/CL_VKSC_CUPRFL
    raising
      /VCXI/CX_CKX .
  methods CHECK_FOR_CHANGES
    returning
      value(RF_CANCELED) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CONSTRUCTOR
    raising
      /VCXI/CX_CKX .
  methods GET_OBJECT_OF_NODE
    importing
      !IF_NODE_KEY type TM_NODEKEY
    returning
      value(RR_OBJECT) type ref to /VCXI/IF_CKX_OBJECT
    raising
      /VCXI/CX_CKX .
  methods HANDLE_CREATE_BOOSTER
    returning
      value(RR_BOOSTER) type ref to ZCL_VCXI_XCS_BOOSTER
    raising
      /VCXI/CX_CKX .
  methods HANDLE_EXPAND_NO_CHILDREN
    for event EXPAND_NO_CHILDREN of CL_SIMPLE_TREE_MODEL
    importing
      !NODE_KEY .
  methods HANDLE_NODE_CONTEXT_REQ
    for event NODE_CONTEXT_MENU_REQUEST of CL_SIMPLE_TREE_MODEL
    importing
      !NODE_KEY
      !MENU .
  methods HANDLE_NODE_CONTEXT_SEL
    for event NODE_CONTEXT_MENU_SELECT of CL_SIMPLE_TREE_MODEL
    importing
      !NODE_KEY
      !FCODE .
  methods HANDLE_NODE_DOUBLE_CLICK
    for event NODE_DOUBLE_CLICK of CL_SIMPLE_TREE_MODEL
    importing
      !NODE_KEY .
  methods HANDLE_UC_BACK
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_CANCEL
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_DELETE
    importing
      !IF_NODE_KEY type TM_NODEKEY
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_EXIT
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_OPEN
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_SAVE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_TOGGLE
    raising
      /VCXI/CX_CKX .
  methods INIT_CONTAINER
    raising
      /VCXI/CX_CKX .
  methods INIT_DUI_VIS
    raising
      /VCXI/CX_CKX .
  methods INIT_TREE
    raising
      /VCXI/CX_CKX .
  methods LOAD_FROM_DB
    raising
      /VCXI/CX_CKX .
  methods REFRESH_TREE
    raising
      /VCXI/CX_CKX .
  methods REGISTER_TREE_EVENTS
    raising
      /VCXI/CX_CKX .
  methods SET_LOCK
    importing
      !IF_LOCKED type /VCXI/CKX_LOCKED
    raising
      /VCXI/CX_CKX .
  methods SET_PFSTATUS
    raising
      /VCXI/CX_CKX .
  methods SET_TITLE
    raising
      /VCXI/CX_CKX .
private section.

  data F_LOCKED type /VCXI/CKX_LOCKED .
endclass. "ZCL_VCXI_XCS_UIC_BOOSTER definition
class ZCL_VCXI_XCS_UIC_BOOSTER implementation.
  method /VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED.

***------------------------------------------------------------------------------------------------
*** Check of the Lock-Status of the Object
    if ME->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ) ne ABAP_TRUE.
***   Object is not locked - No changes possible!
      raise exception type /VCXI/CX_CKX
        exporting
          F_MSGTY = 'E'
          F_MSGID = '/VCXI/CKX'
          F_MSGNO = '201'.
    endif.

  endmethod.
  method /VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK.

***--------------------------------------------------------------------------------------
*** Set Lock Entry
    ME->SET_LOCK( IF_LOCKED = ABAP_TRUE ).

  endmethod.
  method /VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK.

***--------------------------------------------------------------------------------------
*** Remove Lock Entry
    ME->SET_LOCK( IF_LOCKED = ABAP_FALSE ).

  endmethod.
  method /VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED.

    move ME->F_LOCKED to RF_LOCKED.

  endmethod.
method ADD_NODES.

  data: LF_IMAGE    type        TV_IMAGE,
        LF_EXPANDER type        ABAP_BOOL.
  data: LT_CHILDREN type        /VCXI/CKX_TT_OBJECT.
  data: LR_OBJECT_H type ref to /VCXI/IF_CKX_OBJECT_H,
        LR_BOOSTER  type ref to ZCL_VCXI_XCS_BOOSTER.


***------------------------------------------------------------------------------------------------
*** Get Node Key
  move IR_OBJECT->GET_GUID( ) to RF_NODEKEY.

  try.
      move IR_OBJECT ?to LR_BOOSTER.
    catch CX_SY_MOVE_CAST_ERROR.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
  endtry.

*** Get Node Icon
  if LR_BOOSTER->F_NIDAT is initial.
    move ICON_FOLDER        to LF_IMAGE.
    move ABAP_TRUE          to LF_EXPANDER.
  else.
    move ICON_CONFIGURATION to LF_IMAGE.
    move ABAP_FALSE         to LF_EXPANDER.
  endif.

  if LR_BOOSTER->F_DELETED eq ABAP_TRUE.
    move ICON_DELETE to LF_IMAGE.
  endif.

*** If already expanded, don't use Expander
  read table IT_NODEKEY_EXPANDED with key TABLE_LINE = RF_NODEKEY
                                 transporting no fields.
  if SY-SUBRC eq 0.
    LF_EXPANDER = ABAP_FALSE.
  endif.

***------------------------------------------------------------------------------------------------
*** Only add Node if not already added
  if ME->R_TREE->NODE_KEY_IN_TREE( NODE_KEY = RF_NODEKEY ) ne ABAP_TRUE.

*** Add Node
    ME->R_TREE->ADD_NODE( exporting  NODE_KEY                = RF_NODEKEY
                                     RELATIVE_NODE_KEY       = IF_RELATKEY
                                     RELATIONSHIP            = CL_SIMPLE_TREE_MODEL=>RELAT_LAST_CHILD
                                     ISFOLDER                = ABAP_TRUE
                                     EXPANDER                = LF_EXPANDER
                                     IMAGE                   = LF_IMAGE
                                     EXPANDED_IMAGE          = LF_IMAGE
                                     TEXT                    = |{ IR_OBJECT->GET_ID( ) } - { IR_OBJECT->GET_DESCR( ) }|
                                     USER_OBJECT             = IR_OBJECT
                          exceptions NODE_KEY_EXISTS         = 1
                                     NODE_KEY_EMPTY          = 2
                                     ILLEGAL_RELATIONSHIP    = 3
                                     RELATIVE_NODE_NOT_FOUND = 4
                                     others                  = 6 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

**** Set Event Handler
*    set handler ME->HANDLE_OBJECT_CHANGED for LR_OBJECT.

  endif.

***------------------------------------------------------------------------------------------------
*** Add Sub Nodes not if expander is defined (Delayed Load)
  if LF_EXPANDER ne ABAP_TRUE.
    try.
        move IR_OBJECT ?to LR_OBJECT_H.
      catch CX_SY_MOVE_CAST_ERROR.
        clear LR_OBJECT_H.
    endtry.
    check LR_OBJECT_H is bound.

    LT_CHILDREN = LR_OBJECT_H->GET_CHILDREN( ).
    loop at LT_CHILDREN into data(LR_OBJECT).
      ME->ADD_NODES( IF_RELATKEY         = RF_NODEKEY
                     IR_OBJECT           = LR_OBJECT
                     IT_NODEKEY_EXPANDED = IT_NODEKEY_EXPANDED ).
    endloop.
  endif.

endmethod.
  method CALL_SHLP_CUPRFL.

    data: LS_SELFIELD type          SLIS_SELFIELD,
          LS_CMPRK    type          /VCXI/VKC_S_CMPRK.
    data: LT_CMPRK     type table of /VCXI/VKC_S_CMPRK,
          LT_EXCLUDING type          SLIS_T_EXTAB.

***----------------------------------------------------------------------------
*** Get all SmartVC Models
    select CMATN PRFID
           into table LT_CMPRK
           from /VCXI/VKS_TC200.

***----------------------------------------------------------------------------
*** Exclude Functions
*  append  '&NT1' to LT_EXCLUDING.   " Okay
    append  '&ETA' to LT_EXCLUDING.
    append  '&ALL' to LT_EXCLUDING.
    append  '&SAL' to LT_EXCLUDING.
*  append  '&OUP' to LT_EXCLUDING.   " Sort Up
*  append  '&ODN' to LT_EXCLUDING.   " Sort Down
*  append  '%SC'  to LT_EXCLUDING.   " Search
*  append  '%SC+' to LT_EXCLUDING.   " Search More
*  append  '&ILT' to LT_EXCLUDING.   " Filter
    append  '&OL0' to LT_EXCLUDING.
    append  '&CRB' to LT_EXCLUDING.
    append  '&CRL' to LT_EXCLUDING.
    append  '&CRR' to LT_EXCLUDING.
    append  '&CRE' to LT_EXCLUDING.
*  append  '&AC1' to LT_EXCLUDING.  " Cancel

***----------------------------------------------------------------------------
*** Display Popup
    call function 'REUSE_ALV_POPUP_TO_SELECT'
      exporting
        I_TITLE               = 'Select SmartVC Model'(T06)
        I_SELECTION           = ABAP_TRUE
        I_ALLOW_NO_SELECTION  = ABAP_TRUE
        I_SCREEN_START_COLUMN = 10
        I_SCREEN_START_LINE   = 10
        I_SCREEN_END_COLUMN   = 85
        I_SCREEN_END_LINE     = 25
        I_TABNAME             = 'LT_CMPRK'
        I_STRUCTURE_NAME      = '/VCXI/VKC_S_CMPRK'
        IT_EXCLUDING          = LT_EXCLUDING
      importing
        ES_SELFIELD           = LS_SELFIELD
      tables
        T_OUTTAB              = LT_CMPRK
      exceptions
        PROGRAM_ERROR         = 1.

    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

    check LS_SELFIELD-TABINDEX is not initial.

***----------------------------------------------------------------------------
*** Process Result
    read table LT_CMPRK into LS_CMPRK index LS_SELFIELD-TABINDEX.

*** Get Profile
    RR_CUPRFL = /VCXI/CL_VKSC_CUPRFL=>GET_INSTANCE_BY_CMPRK( IS_CMPRK = LS_CMPRK ).

  endmethod.
  method CHECK_FOR_CHANGES.

    data: LF_ANSWER type STRING,
          LF_CHANGED type ABAP_BOOL.
    data: LT_NODE_KEY type TREEMNOTAB.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

***--------------------------------------------------------------------------------------
*** Get All Nodes/Booster
    ME->R_TREE->GET_ALL_NODE_KEYS( importing NODE_KEY_TABLE = LT_NODE_KEY ).

    loop at LT_NODE_KEY assigning field-symbol(<F_NODE_KEY>).
      LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( <F_NODE_KEY> ) ).
      check LR_BOOSTER is bound.

***   Check if Object is changed
      if LR_BOOSTER->F_CHANGED eq ABAP_TRUE.
        move ABAP_TRUE to LF_CHANGED.
      endif.

    endloop.

    if LF_CHANGED eq ABAP_TRUE.
***   Unsaved Data
      call function 'POPUP_TO_CONFIRM'
        exporting
          TEXT_QUESTION  = 'Open changes exist. Do you want to save first?'(Q01)
        importing
          ANSWER         = LF_ANSWER
        exceptions
          TEXT_NOT_FOUND = 1
          others         = 2.
      if SY-SUBRC ne 0.
        /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
      endif.

      case LF_ANSWER.
        when '1'.
***       Save and than go on
          ME->HANDLE_UC_SAVE( ).
          move ABAP_FALSE to RF_CANCELED.
        when '2'.
***       Do nothing but go on
          move ABAP_FALSE to RF_CANCELED.
        when 'A'.
***       Cancel
          move ABAP_TRUE to RF_CANCELED.
      endcase.

    endif.

  endmethod.
  method CONSTRUCTOR.

*** Bind UI Framework
    call function 'ZVCXI_XCS_UIC_BOOSTER_BIND'
      exporting
        IR_UIC_BOOSTER = ME
      importing
        ES_DYNP        = ME->S_DYNP.

    ME->INIT_CONTAINER( ).
    ME->INIT_TREE( ).

*** Load Initial Data
    ME->LOAD_FROM_DB( ).

  endmethod.
  method DO_FREE.

***--------------------------------------------------------------------------------------
*** Deactivate Event Handler
    set handler ME->HANDLE_NODE_DOUBLE_CLICK      for ME->R_TREE activation ABAP_FALSE.
    set handler ME->HANDLE_NODE_CONTEXT_REQ       for ME->R_TREE activation ABAP_FALSE.
    set handler ME->HANDLE_NODE_CONTEXT_SEL       for ME->R_TREE activation ABAP_FALSE.

***--------------------------------------------------------------------------------------
*** Free Tree
    if ME->R_TREE is bound.
      ME->R_TREE->DELETE_ALL_NODES( ).
      free: ME->R_TREE.
    endif.

***--------------------------------------------------------------------------------------
*** Free Container
    if ME->R_CONTAINER is bound.
      ME->R_CONTAINER->FREE( ).
      clear ME->R_CONTAINER.
    endif.

  endmethod.
  method DO_MODIFY_SCREEN_BOOSTER.

    data: LF_LOCKED type        /VCXI/CKX_LOCKED.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

    try.

        if IF_REPID eq ME->GET_DUI_INFO( )-REPID and
           IF_DYNNR eq ME->GET_DUI_INFO( )-DYNNR.

          LF_LOCKED = ME->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ).

          if ME->F_NODE_KEY_SEL is not initial.
***         Get Booster
            LR_BOOSTER ?= ME->GET_OBJECT_OF_NODE( ME->F_NODE_KEY_SEL ).
            if LR_BOOSTER is bound.
              LF_LOCKED = LR_BOOSTER->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ).
            endif.
          endif.

          loop at screen.

            if LF_LOCKED ne ABAP_TRUE.
              move 0 to SCREEN-INPUT.
            endif.

***         Hide Elements which are only relevant for Booster
            if SCREEN-GROUP1 eq 'BST' and
               LR_BOOSTER             is bound and
               LR_BOOSTER->F_NIDAT    is initial.
              move 1 to SCREEN-INVISIBLE.
            endif.

***         Info Elements always Ready
            if SCREEN-GROUP2 eq 'INF'.
              move 1 to SCREEN-INPUT.
            endif.

            modify screen.
          endloop.
        endif.

      catch /VCXI/CX_CKX.          "#EC NO_HANDLER
    endtry.

  endmethod.
  method DO_PBO.

    try.
        ME->REFRESH_TREE( ).

        ME->SET_PFSTATUS( ).
        ME->SET_TITLE( ).

        ME->INIT_DUI_VIS( ).

      catch /VCXI/CX_CKX. "#EC NO_HANDLER
    endtry.

  endmethod.
  method DO_UPDATE_BOOSTER_VIS.

    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

    move IS_BOOSTER_VIS to ME->S_BOOSTER_VIS.

    try.
***     Get Booster
        LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( conv #( ME->S_BOOSTER_VIS-GBSTR ) ) ).
      catch /VCXI/CX_CKX.
        clear: LR_BOOSTER.
    endtry.
    check LR_BOOSTER is bound.

*** Update Booster
    if ME->S_BOOSTER_VIS-GPBST ne LR_BOOSTER->F_GPBST.
      LR_BOOSTER->SET_GPBST( ME->S_BOOSTER_VIS-GPBST ).
    endif.

    if ME->S_BOOSTER_VIS-IBSTR ne LR_BOOSTER->F_IBSTR.
      LR_BOOSTER->SET_IBSTR( ME->S_BOOSTER_VIS-IBSTR ).
    endif.

    if ME->S_BOOSTER_VIS-NIDAT ne LR_BOOSTER->F_NIDAT.
      LR_BOOSTER->SET_NIDAT( ME->S_BOOSTER_VIS-NIDAT ).
    endif.

    if ME->S_BOOSTER_VIS-DESCR ne LR_BOOSTER->/VCXI/IF_CKX_OBJECT~GET_DESCR( ).
      LR_BOOSTER->SET_DESCR( ME->S_BOOSTER_VIS-DESCR ).
    endif.

  endmethod.
  method DO_USER_COMMAND.

    case CF_UCOMM.

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_TOGGLE.
        ME->HANDLE_UC_TOGGLE( ).

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_OPEN.
        ME->HANDLE_UC_OPEN( ).

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_SAVE.
        ME->HANDLE_UC_SAVE( ).

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_BACK.
        ME->HANDLE_UC_BACK( ).

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_EXIT.
        ME->HANDLE_UC_EXIT( ).

      when ZCL_VCXI_XCS_UIC_BOOSTER=>C_UC_CANCEL.
        ME->HANDLE_UC_CANCEL( ).

      when others.

    endcase.

    clear: CF_UCOMM.

    CL_GUI_CFW=>FLUSH( ).  " flushing

  endmethod.
  method GET_DUI_INFO.

    if ME->F_NODE_KEY_SEL is not initial.
      move ME->S_DYNP-REPID             to RS_DYNP-REPID.
      move '0200'                       to RS_DYNP-DYNNR.
    else.
      move ME->S_DYNP-REPID             to RS_DYNP-REPID.
      move '9999'                       to RS_DYNP-DYNNR.
    endif.

  endmethod.
method GET_OBJECT_OF_NODE.

  data:      LR_USEROBJECT type ref to OBJECT.

  ME->R_TREE->NODE_GET_USER_OBJECT( exporting
                                      NODE_KEY       = IF_NODE_KEY
                                    importing
                                      USER_OBJECT    = LR_USEROBJECT
                                    exceptions
                                      NODE_NOT_FOUND = 1
                                      others         = 2 ).
  if SY-SUBRC      ne     0     or
     LR_USEROBJECT is not bound.
    exit.
  endif.

  try.
      move LR_USEROBJECT ?to RR_OBJECT.
    catch CX_SY_MOVE_CAST_ERROR.
      raise exception type /VCXI/CX_CKX.
  endtry.

endmethod.
  method HANDLE_CREATE_BOOSTER.

    types: begin of YS_WERKS_DESCR,
             WERKS type WERKS_D,
             DESCR type NAME1,
           end of YS_WERKS_DESCR.
    types: YT_WERKS_DESCR type standard table of YS_WERKS_DESCR.

    data: LF_CANCELED type        ABAP_BOOL,
          LF_IEALI    type        /VCXI/VKSC_IEALI,
          LF_CUOBJ    type        CUOBJ,
          LF_GVCIN    type        /VCXI/VKCR_GVCIN,
          LF_WERKS    type        WERKS_D.
    data: LS_INOB     type        INOB,
          LS_SELFIELD type SLIS_SELFIELD.
    data: LT_OBJECT_ALL  type        /VCXI/CKX_TT_OBJECT,
          LT_OBJECT_SEL  type        /VCXI/CKX_TT_OBJECT,
          LT_WERKS_DESCR type YT_WERKS_DESCR,
          LT_FCAT        type SLIS_T_FIELDCAT_ALV.
    data: LR_OBJECT   type ref to /VCXI/IF_CKX_OBJECT,
          LR_CUPRFL   type ref to /VCXI/CL_VKSC_CUPRFL,
          LR_SVC      type ref to /VCXI/CL_VKSRA_SVC,
          LR_IDAT_SVC type ref to ZCL_VCXI_XCI_IDAT_SVC.

***--------------------------------------------------------------------------------------
*** Pick Model
    LR_CUPRFL = ME->CALL_SHLP_CUPRFL( ).
    check LR_CUPRFL is bound.

***--------------------------------------------------------------------------------------
*** Pick Alias
    LT_OBJECT_ALL = LR_CUPRFL->GET_REGISTERED_CEALI( ).

*** Check for concrete default alias X_IDATSPV
    loop at LT_OBJECT_ALL into LR_OBJECT.
      if LR_OBJECT->GET_ID( ) eq 'X_IDATSPV'.
        move LR_OBJECT->GET_ID( ) to LF_IEALI.
        exit.
      endif.
    endloop.

    if LF_IEALI is initial.
      call function '/VCXI/CKX_OBJECT_POPUP_START'
        exporting
          IT_OBJECT_ALL = LT_OBJECT_ALL
        importing
          ET_OBJECT_SEL = LT_OBJECT_SEL
          EF_CANCELED   = LF_CANCELED.

      check LF_CANCELED ne ABAP_TRUE.
      read table LT_OBJECT_SEL into LR_OBJECT index 1.
      check SY-SUBRC eq 0.

      move LR_OBJECT->GET_ID( ) to LF_IEALI.

    endif.

*** Define Link between Internal Number and Object
    LS_INOB-CUOBJ  = LF_CUOBJ.
    LS_INOB-ROBTAB = 'MARA'.
    LS_INOB-ROBJEK = conv MATNR( LR_CUPRFL->R_CVC_CUPRFL->S_CMPRK-CMATN ).

*** Get Plant Value
    select MARC~WERKS, NAME1 into table @LT_WERKS_DESCR
      from MARC
      inner join T001W
        on T001W~WERKS eq MARC~WERKS
      where MATNR eq @LR_CUPRFL->R_CVC_CUPRFL->S_CMPRK-CMATN.

    append value #( FIELDNAME = 'WERKS' REF_FIELDNAME = 'WERKS' REF_TABNAME   = 'T001W' ) to LT_FCAT.
    append value #( FIELDNAME = 'DESCR' REF_FIELDNAME = 'NAME1' REF_TABNAME   = 'T001W' ) to LT_FCAT.

*** Display Popup
    call function 'REUSE_ALV_POPUP_TO_SELECT'
      exporting
        I_TITLE              = 'Select Plant'(T11)
        I_SELECTION          = ABAP_TRUE
        I_ALLOW_NO_SELECTION = ABAP_TRUE
        I_TABNAME            = 'LT_WERKS_DESCR'
        IT_FIELDCAT          = LT_FCAT
      importing
        ES_SELFIELD          = LS_SELFIELD
      tables
        T_OUTTAB             = LT_WERKS_DESCR
      exceptions
        PROGRAM_ERROR        = 1.

    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

    check LS_SELFIELD-TABINDEX is not initial.

*** Process Result
    read table LT_WERKS_DESCR into LF_WERKS index LS_SELFIELD-TABINDEX.

    try.
***--------------------------------------------------------------------------------------
***     Run Configuration
        call function 'CE_C_PROCESSING'
          exporting
            INSTANCE                       = LS_INOB-CUOBJ
            DATE                           = SY-DATUM
            DISPLAY                        = ' '
            OBJECT_ID                      = LS_INOB-ROBTAB
            OBJECT                         = LS_INOB-ROBJEK
            OWNER_ID                       = 'MARC'
            PLANT                          = LF_WERKS
            NO_DIALOG                      = ABAP_TRUE
            SUB_TYPE                       = '05'
            TYPE                           = 'E'
          importing
            NEW_INSTANCE                   = LF_CUOBJ
*    tables
*           APPLICATION_INPUT              = LT_OBJTABLE
          exceptions
            INTERNAL_ERROR                 = 1
            INSTANCE_NOT_FOUND             = 2
            REFERENCE_INSTANCE_NOT_FOUND   = 3
            INSTANCE_IS_A_CLASSIFICATION   = 4
            NO_PLANT                       = 5
            NO_QUANTITY                    = 6
            NO_CONNECTION_TO_CONFIGURATION = 7
            MATERIAL_VARIANT_NOT_ALLOWED   = 8
            INTERNAL_ERROR_ECM             = 9
            EOASL_NOT_ALLOWED              = 10
            MAXASL_NOT_ALLOWED             = 11
            XC_UNPROCESSED_DATA            = 12
            XC_FAILURE_PROCESSING_DATA     = 13
            NO_BOM                         = 14
            NO_KNOWLEDGE_BASE_FOUND        = 15
            ORDER_BOM_ERROR                = 16.

        if SY-SUBRC ne 0.
          /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
        endif.

***     Get Configuration
        LF_GVCIN = /VCXI/CL_VKCR_GATEWAY=>GET_GVCIN_BY_CUOBJ( IF_CUOBJ = LF_CUOBJ ).
        LR_SVC   = /VCXI/CL_VKSRA_SVC=>GET_INSTANCE( IF_GVCIN = LF_GVCIN ).
        check LR_SVC is bound.

***     Start SVC UI Configuration
        LR_SVC->START_UI( ).

***     Get Instance
        LR_IDAT_SVC = ZCL_VCXI_XCI_IDAT_SVC=>CREATE( IS_CMPRK = LR_CUPRFL->R_CVC_CUPRFL->S_CMPRK
                                                     IF_IEALI = LF_IEALI ).
        check LR_IDAT_SVC is bound.

***     Fill by SVC Data
        LR_IDAT_SVC->FILL_BY_SVC( LR_SVC ).

        LR_SVC->DO_FREE( ).
        clear: LR_SVC.

***     Start UI of Integration Data
        ZCL_VCXI_XCIU_UI_IDAT_SVC=>START( LR_IDAT_SVC ).

***--------------------------------------------------------------------------------------
***     Create new Booster
        try.
            RR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( SPACE ) ).
          catch CX_UUID_ERROR.                          "#EC NO_HANDLER
        endtry.
        check RR_BOOSTER is bound.

***     Set Integration Data ID
        RR_BOOSTER->SET_NIDAT( conv #( LR_IDAT_SVC->/VCXI/IF_CKX_OBJECT~GET_ID( ) ) ).
        move RR_BOOSTER->F_NIDAT to ME->S_BOOSTER_VIS-NIDAT.

      catch /VCXI/CX_CKX into data(LR_CX_CKX).
        LR_CX_CKX->SHOW_MESSAGE( ).
    endtry.


  endmethod.
  method HANDLE_EXPAND_NO_CHILDREN.

    data: LT_CHILDREN        type        /VCXI/CKX_TT_OBJECT,
          LT_TO_EXPAND_NODES type        TREEMNOTAB.
    data: LR_OBJECT   type ref to /VCXI/IF_CKX_OBJECT,
          LR_OBJECT_H type ref to /VCXI/IF_CKX_OBJECT_H,
          LR_CX_CKX   type ref to /VCXI/CX_CKX.

    try.
***--------------------------------------------------------------------------------------
***     Get Object of Node
        LR_OBJECT_H ?= ME->GET_OBJECT_OF_NODE( IF_NODE_KEY = NODE_KEY ).
        check LR_OBJECT_H is bound.

****--------------------------------------------------------------------------------------
***     Add Sub Nodes
        LT_CHILDREN = LR_OBJECT_H->GET_CHILDREN( ).
        loop at LT_CHILDREN into LR_OBJECT.
          ME->ADD_NODES( IF_RELATKEY = NODE_KEY
                         IR_OBJECT   = LR_OBJECT ).
        endloop.

***--------------------------------------------------------------------------------------
***     Get Nodes to Expand
        append NODE_KEY to LT_TO_EXPAND_NODES.

***     Expanded Nodes
        ME->R_TREE->EXPAND_NODES( exporting
                                    NODE_KEY_TABLE          = LT_TO_EXPAND_NODES
                                  exceptions
                                    ERROR_IN_NODE_KEY_TABLE = 1
                                    others                  = 2 ).
        if SY-SUBRC ne 0.
          /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
        endif.

      catch /VCXI/CX_CKX into LR_CX_CKX.
        LR_CX_CKX->SHOW_MESSAGE( ).
    endtry.

  endmethod.
  method HANDLE_NODE_CONTEXT_REQ.

    data: LF_DISABLED type ABAP_BOOL.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

***--------------------------------------------------------------------------------------
*** Get Node/Booster
    try.
        LR_BOOSTER ?= ME->GET_OBJECT_OF_NODE( IF_NODE_KEY = NODE_KEY ).
      catch /VCXI/CX_CKX.                               "#EC NO_HANDLER
    endtry.
    check LR_BOOSTER is bound.

    if ME->F_LOCKED eq ABAP_TRUE.
      move ABAP_FALSE to LF_DISABLED.
    else.
      move ABAP_TRUE  to LF_DISABLED.
    endif.

*** Set Selection
    move NODE_KEY to ME->F_NODE_KEY_SEL.

***--------------------------------------------------------------------------------------
*** Add Menu Items (Node/Booster)
    if LR_BOOSTER->F_NIDAT is initial.
      MENU->ADD_FUNCTION( TEXT     = 'Add Folder'(T01)
                          FCODE    = C_UC_ADD_NODE
                          DISABLED = LF_DISABLED ).

      MENU->ADD_FUNCTION( TEXT     = 'Add Booster'(T02)
                          FCODE    = C_UC_ADD_BOOSTER
                          DISABLED = LF_DISABLED ).

      MENU->ADD_SEPARATOR( ).
    endif.

*** Delete
    if LR_BOOSTER->F_GPBST is not initial.
      try.
***       Only for Node/Booster without children possible
          if LR_BOOSTER->/VCXI/IF_CKX_OBJECT_H~GET_CHILDREN( ) is initial.

            MENU->ADD_FUNCTION( TEXT     = 'Delete'(T03)
                                FCODE    = C_UC_DELETE
                                DISABLED = LF_DISABLED ).
          else.

            MENU->ADD_FUNCTION( TEXT     = 'Delete'(T03)
                                FCODE    = C_UC_DELETE
                                DISABLED = ABAP_TRUE ).
          endif.
        catch /VCXI/CX_CKX.                             "#EC NO_HANDLER
      endtry.

    endif.

  endmethod.
  method HANDLE_NODE_CONTEXT_SEL.

    data: LR_BOOSTER  type ref to ZCL_VCXI_XCS_BOOSTER,
          LR_CX_CKX   type ref to /VCXI/CX_CKX.

    case FCODE.

      when C_UC_ADD_NODE.
        try.
***         Create new Folder Node
            LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( SPACE ) ).
            LR_BOOSTER->SET_GPBST( conv #( NODE_KEY ) ).

***         Expand Header, so new Item can be marked as selected
            ME->HANDLE_EXPAND_NO_CHILDREN( NODE_KEY = NODE_KEY ).
            move LR_BOOSTER->F_GBSTR to ME->F_NODE_KEY_SEL.

          catch /VCXI/CX_CKX into LR_CX_CKX.
            LR_CX_CKX->SHOW_MESSAGE( ).
        endtry.

      when C_UC_ADD_BOOSTER.
        try.
***         Create new Booster
            LR_BOOSTER = ME->HANDLE_CREATE_BOOSTER( ).
            if LR_BOOSTER is bound.
              LR_BOOSTER->SET_GPBST( conv #( NODE_KEY ) ).

***           Expand Header, so new Item can be marked as selected
              ME->HANDLE_EXPAND_NO_CHILDREN( NODE_KEY = NODE_KEY ).
              move LR_BOOSTER->F_GBSTR to ME->F_NODE_KEY_SEL.

            endif.
          catch /VCXI/CX_CKX into LR_CX_CKX.
            LR_CX_CKX->SHOW_MESSAGE( ).
        endtry.

      when C_UC_DELETE.
        try.
***         Delete Booster
            ME->HANDLE_UC_DELETE( NODE_KEY ).

          catch /VCXI/CX_CKX into LR_CX_CKX.
            LR_CX_CKX->SHOW_MESSAGE( ).
        endtry.

      when others.

    endcase.

*** Trigger Tree Refresh
    CL_GUI_CFW=>SET_NEW_OK_CODE( NEW_CODE = 'UI_REFRESH' ).

  endmethod.
  method HANDLE_NODE_DOUBLE_CLICK.

    data: LR_OBJECT_LOCKING type ref to /VCXI/IF_CKX_OBJECT_LOCKING.

*** Set Selected Node Key
    move NODE_KEY to ME->F_NODE_KEY_SEL.

    try.
        if ME->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ).
***       Try To Lock Object
          LR_OBJECT_LOCKING ?= cast /VCXI/IF_CKX_OBJECT_LOCKING( ME->GET_OBJECT_OF_NODE( NODE_KEY ) ).
          if LR_OBJECT_LOCKING is bound.
            LR_OBJECT_LOCKING->DO_LOCK( ).
          endif.
        endif.
      catch /VCXI/CX_CKX. "#EC NO_HANDLER
    endtry.

*** Trigger Refresh UI
    CL_GUI_CFW=>SET_NEW_OK_CODE( NEW_CODE = 'UI_REFRESH' ).

  endmethod.
  method HANDLE_UC_BACK.

*** Check for changes and ask user to save them
    if ME->CHECK_FOR_CHANGES( ) ne ABAP_TRUE.
      ME->DO_FREE( ).
      leave to screen 0.
    endif.


  endmethod.
  method HANDLE_UC_CANCEL.

*** Check for changes and ask user to save them
    if ME->CHECK_FOR_CHANGES( ) ne ABAP_TRUE.
      ME->DO_FREE( ).
      leave to screen 0.
    endif.


  endmethod.
  method HANDLE_UC_DELETE.

    data: LF_ANSWER type STRING.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER,
          LR_OBJECT type ref to OBJECT..

***--------------------------------------------------------------------------------------
*** Get Booster
    LR_BOOSTER = cast ZCL_VCXI_XCS_BOOSTER( ME->GET_OBJECT_OF_NODE( IF_NODE_KEY ) ).

*** Only for Booster without children possible
    check LR_BOOSTER->/VCXI/IF_CKX_OBJECT_H~GET_CHILDREN( ) is initial.

*** Lock Booster
    LR_BOOSTER->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).

    try.
***     Handle missing lock
        LR_BOOSTER->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).
      catch /VCXI/CX_CKX into data(LR_CX_CKX).
        LR_CX_CKX->SHOW_MESSAGE( IF_TYPE = 'I' ).
        exit.
    endtry.

    call function 'POPUP_TO_CONFIRM'
      exporting
        TITLEBAR              = 'Confirm Deletion'(T04)
        TEXT_QUESTION         = 'Are you sure to delete Booster?'(T05)
        DISPLAY_CANCEL_BUTTON = ABAP_FALSE
      importing
        ANSWER                = LF_ANSWER.

    case LF_ANSWER.
      when '1'. " Yes
***     Delete Booster
        LR_BOOSTER->DELETE( ).
        LR_BOOSTER->SAVE( ).
        LR_BOOSTER->DO_FREE( ).
        free: LR_BOOSTER.

        clear: ME->F_NODE_KEY_SEL.

***     Delete Tree Item
        ME->R_TREE->DELETE_NODE( IF_NODE_KEY ).

      when '2'. " No
      when 'A'. " Cancel
    endcase.

  endmethod.
  method HANDLE_UC_EXIT.

*** Check for changes and ask user to save them
    if ME->CHECK_FOR_CHANGES( ) ne ABAP_TRUE.
      ME->DO_FREE( ).
      leave to screen 0.
    endif.


  endmethod.
  method HANDLE_UC_OPEN.

    data: LR_OBJECT   type ref to /VCXI/IF_CKX_OBJECT,
          LR_BOOSTER  type ref to ZCL_VCXI_XCS_BOOSTER,
          LR_IDAT_SVC type ref to ZCL_VCXI_XCI_IDAT_SVC.

    check ME->F_NODE_KEY_SEL is not initial.

*** Get Booster for selected Node
    LR_OBJECT = ME->GET_OBJECT_OF_NODE( ME->F_NODE_KEY_SEL ).

    check LR_OBJECT is instance of ZCL_VCXI_XCS_BOOSTER.
    LR_BOOSTER = cast ZCL_VCXI_XCS_BOOSTER( LR_OBJECT ).
    check LR_BOOSTER is bound.

*** Use existing Integration Data
    if LR_BOOSTER->F_NIDAT is not initial.

***   Get Instance
      LR_IDAT_SVC ?= ZCL_VCXI_XCI_IDAT_SVC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = conv #( LR_BOOSTER->F_NIDAT ) ).

***   Start UI of Integration Data
      ZCL_VCXI_XCIU_UI_IDAT_SVC=>START( LR_IDAT_SVC ).

    endif.

  endmethod.
  method HANDLE_UC_SAVE.

    data: LT_NODE_KEY type TREEMNOTAB.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.


***--------------------------------------------------------------------------------------
*** Get All Nodes/Booster
    ME->R_TREE->GET_ALL_NODE_KEYS( importing NODE_KEY_TABLE = LT_NODE_KEY ).

    loop at LT_NODE_KEY assigning field-symbol(<F_NODE_KEY>).
      LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( <F_NODE_KEY> ) ).
      check LR_BOOSTER is bound.
***   Save Booster
      LR_BOOSTER->SAVE( ).
    endloop.

  endmethod.
  method HANDLE_UC_TOGGLE.

    data: LT_NODE_KEY type TREEMNOTAB.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.


    if ME->F_LOCKED eq ABAP_TRUE.
***   Check for changes and ask user to save them
      check ME->CHECK_FOR_CHANGES( ) ne ABAP_TRUE.

***   Unlock UI Controller
      ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK( ).

***   Get All Nodes/Booster
      ME->R_TREE->GET_ALL_NODE_KEYS( importing NODE_KEY_TABLE = LT_NODE_KEY ).

      loop at LT_NODE_KEY assigning field-symbol(<F_NODE_KEY>).
        LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( <F_NODE_KEY> ) ).
        check LR_BOOSTER is bound.
***     Toogle Lock on Booster
        LR_BOOSTER->/VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK( ).
        LR_BOOSTER->DO_FREE( ).
        clear: LR_BOOSTER.
      endloop.

***   Refresh Tree and reload nodes from DB
      ME->R_TREE->DELETE_ALL_NODES( ).
      ME->LOAD_FROM_DB( ).
      clear: ME->F_NODE_KEY_SEL.

    else.

***   Lock UI Controller
      ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).

***   Try to lock selected Booster
      if ME->F_NODE_KEY_SEL is not initial.
***     Get Booster
        LR_BOOSTER ?= ME->GET_OBJECT_OF_NODE( ME->F_NODE_KEY_SEL ).
        if LR_BOOSTER is bound.
          LR_BOOSTER->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).
        endif.
      endif.

    endif.

  endmethod.
  method INIT_CONTAINER.

    if ME->R_CONTAINER is not bound.

***   Create the Docking Container Instance
      create object ME->R_CONTAINER
        exporting
          REPID                       = ME->S_DYNP-REPID
          DYNNR                       = ME->S_DYNP-DYNNR
          SIDE                        = CL_GUI_DOCKING_CONTAINER=>DOCK_AT_LEFT
*         EXTENSION                   = IF_EXTENSION
          RATIO                       = 30
        exceptions
          CNTL_ERROR                  = 1
          CNTL_SYSTEM_ERROR           = 2
          CREATE_ERROR                = 3
          LIFETIME_ERROR              = 4
          LIFETIME_DYNPRO_DYNPRO_LINK = 5
          others                      = 6.
      if SY-SUBRC ne 0.
        /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
      endif.

    endif.

  endmethod.
  method INIT_DUI_VIS.

    data: LS_LOG     type /VCXI/CKX_S_LOG,
          LS_LOG_EXT type /VCXI/CKX_S_LOG_EXT.
    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER,
          LR_OBJECT  type ref to /VCXI/IF_CKX_OBJECT.


    check ME->F_NODE_KEY_SEL is not initial.

*** Get Booster for selected Node
    LR_OBJECT ?= ME->GET_OBJECT_OF_NODE( IF_NODE_KEY = ME->F_NODE_KEY_SEL ).

    check LR_OBJECT is instance of ZCL_VCXI_XCS_BOOSTER.
    LR_BOOSTER = cast ZCL_VCXI_XCS_BOOSTER( LR_OBJECT ).
    check LR_BOOSTER is bound.

*** Fill Vis Structure
    move LR_BOOSTER->F_GBSTR to ME->S_BOOSTER_VIS-GBSTR.
    move LR_BOOSTER->F_GPBST to ME->S_BOOSTER_VIS-GPBST.
    move LR_BOOSTER->F_IBSTR to ME->S_BOOSTER_VIS-IBSTR.
    move LR_BOOSTER->/VCXI/IF_CKX_OBJECT~GET_DESCR( ) to ME->S_BOOSTER_VIS-DESCR.
    move LR_BOOSTER->F_NIDAT to ME->S_BOOSTER_VIS-NIDAT.

*** Configuration Material and Profile
    move LR_BOOSTER->GET_CMPRK( ) to ME->S_BOOSTER_VIS-S_CMPRK.

*** Get Log
    move LR_BOOSTER->/VCXI/IF_CKX_OBJECT~GET_LOG( )           to LS_LOG.
    move /VCXI/CL_CKX_SERVICE=>GET_LOG_EXT( IS_LOG = LS_LOG ) to LS_LOG_EXT.
    move LS_LOG_EXT                                           to ME->S_BOOSTER_VIS-S_LOG_EXT.

  endmethod.
method INIT_TREE.

  if ME->R_TREE is not bound.

*** Create the Tree Instance
    create object ME->R_TREE
      exporting
        NODE_SELECTION_MODE         = CL_GUI_COLUMN_TREE=>NODE_SEL_MODE_SINGLE
      exceptions
        ILLEGAL_NODE_SELECTION_MODE = 1
        others                      = 2.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Create the Tree Control
    ME->R_TREE->CREATE_TREE_CONTROL( exporting
                                       PARENT                       = ME->R_CONTAINER
                                     exceptions
                                       LIFETIME_ERROR               = 1
                                       CNTL_SYSTEM_ERROR            = 2
                                       CREATE_ERROR                 = 3
                                       FAILED                       = 4
                                       TREE_CONTROL_ALREADY_CREATED = 5
                                       others                       = 6 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Register the Tree Events
    ME->REGISTER_TREE_EVENTS( ).

  endif.

endmethod.
  method LOAD_FROM_DB.

    data: LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

***--------------------------------------------------------------------------------------
*** Load Data from DB for Root Element
    select GBSTR into table @data(LT_GBSTR)
      from ZVCXI_XCS_TD030
      where GPBST eq @SPACE.


    loop at LT_GBSTR assigning field-symbol(<F_GBSTR>).
***   Get Instance
      LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( conv #( <F_GBSTR> ) ) ).

      ME->ADD_NODES( IF_RELATKEY         = SPACE
                     IR_OBJECT           = LR_BOOSTER ).
    endloop.

  endmethod.
  method REFRESH_TREE.

    data: LF_NODEKEY  type TM_NODEKEY,
          LF_TOP_NODE type TM_NODEKEY.
    data: LT_NODEKEY_EXPANDED type TREEMNOTAB,
          LT_NODEKEY          type TREEMNOTAB.
    data: LR_OBJECT  type ref to /VCXI/IF_CKX_OBJECT,
          LR_BOOSTER type ref to ZCL_VCXI_XCS_BOOSTER.

***------------------------------------------------------------------------------------------------
*** Get Top Node
    ME->R_TREE->GET_TOP_NODE( importing  NODE_KEY = LF_TOP_NODE
                              exceptions others   = 9 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Get currently Expanded Nodes
    ME->R_TREE->GET_EXPANDED_NODES( importing  NODE_KEY_TABLE = LT_NODEKEY_EXPANDED
                                    exceptions others         = 9 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***------------------------------------------------------------------------------------------------
*** Delete all old Nodes
    ME->R_TREE->DELETE_ALL_NODES( ).

***------------------------------------------------------------------------------------------------
*** Add Node for Root Node
    if LF_TOP_NODE is initial.
      try.
          LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( SPACE ) ).
        catch CX_UUID_ERROR.                            "#EC NO_HANDLER
      endtry.

      break HARD_CODED.                                    "#EC NOBREAK
      LR_BOOSTER->SET_IBSTR( 'Root'(T09) ).
      LR_BOOSTER->SET_DESCR( 'Booster'(T10) ).
    else.
***   Get existing Instance
      LR_BOOSTER = cast #( ZCL_VCXI_XCS_BOOSTER=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( LF_TOP_NODE ) ).
    endif.

    check LR_BOOSTER is bound.
    LF_NODEKEY = ME->ADD_NODES( IF_RELATKEY         = SPACE
                                IR_OBJECT           = LR_BOOSTER
                                IT_NODEKEY_EXPANDED = LT_NODEKEY_EXPANDED ).

*** Add Children of Node
    if LT_NODEKEY_EXPANDED is initial.
      ME->HANDLE_EXPAND_NO_CHILDREN( NODE_KEY = LF_NODEKEY ).
    endif.

***------------------------------------------------------------------------------------------------
*** Filter Notes that are still there
    ME->R_TREE->NODE_KEYS_IN_TREE( exporting NODE_KEY_TABLE    = LT_NODEKEY_EXPANDED
                                   importing NODE_KEYS_IN_TREE = LT_NODEKEY ).

    if LT_NODEKEY is initial.
***   Expand all
      ME->R_TREE->EXPAND_ROOT_NODES( EXPAND_SUBTREE = ABAP_TRUE ).
    else.
***   Expand Nodes that were expanded
      ME->R_TREE->EXPAND_NODES( exporting  NODE_KEY_TABLE          = LT_NODEKEY
                                exceptions ERROR_IN_NODE_KEY_TABLE = 0 ).
    endif.

*** Set Top Node
    if ME->R_TREE->NODE_KEY_IN_TREE( NODE_KEY = LF_TOP_NODE ) eq ABAP_TRUE.
      ME->R_TREE->SET_TOP_NODE( exporting  NODE_KEY = LF_TOP_NODE
                                exceptions others   = 6 ). "#EC SUBRC_OK
    else.
      ME->R_TREE->SCROLL( SCROLL_COMMAND = CL_TREE_MODEL=>SCROLL_HOME ).
    endif.


*** Set Selected Node
    if ME->R_TREE->NODE_KEY_IN_TREE( NODE_KEY = ME->F_NODE_KEY_SEL ) eq ABAP_TRUE.
      ME->R_TREE->SET_SELECTED_NODE( NODE_KEY = ME->F_NODE_KEY_SEL ).
    endif.

  endmethod.
  method REGISTER_TREE_EVENTS.

    data:           LT_EVENT  type CNTL_SIMPLE_EVENTS.
    field-symbols:  <S_EVENT> type CNTL_SIMPLE_EVENT.


***------------------------------------------------------------------------------------------------
*** Set Registered Events
    append initial line to LT_EVENT assigning <S_EVENT>.
    move CL_SIMPLE_TREE_MODEL=>EVENTID_NODE_DOUBLE_CLICK     to <S_EVENT>-EVENTID.
    move ABAP_TRUE                                           to <S_EVENT>-APPL_EVENT.

    append initial line to LT_EVENT assigning <S_EVENT>.
    move CL_SIMPLE_TREE_MODEL=>EVENTID_NODE_CONTEXT_MENU_REQ to <S_EVENT>-EVENTID.
    move ABAP_TRUE                                           to <S_EVENT>-APPL_EVENT.

    ME->R_TREE->SET_REGISTERED_EVENTS( exporting
                                         EVENTS                    = LT_EVENT
                                       exceptions
                                         ILLEGAL_EVENT_COMBINATION = 1
                                         UNKNOWN_EVENT             = 2
                                         others                    = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***------------------------------------------------------------------------------------------------
*** Set Event Handler
    set handler ME->HANDLE_NODE_DOUBLE_CLICK      for ME->R_TREE.
    set handler ME->HANDLE_NODE_CONTEXT_REQ       for ME->R_TREE.
    set handler ME->HANDLE_NODE_CONTEXT_SEL       for ME->R_TREE.

    set handler ME->HANDLE_EXPAND_NO_CHILDREN     for ME->R_TREE.

  endmethod.
  method SET_LOCK.

    data:  LR_CX_CKX type ref to /VCXI/CX_CKX.

    try.

        if IF_LOCKED eq ABAP_TRUE.
***       Try to Set Write Lock
          call function 'ENQUEUE_E_TABLE'
            exporting
*             MODE_RSTABLE   = 'E'
              TABNAME        = 'ZVCXI_XCS_TD030'
*             VARKEY         = VARKEY
*             X_TABNAME      = ' '
*             X_VARKEY       = ' '
*             _SCOPE         = '2'
*             _WAIT          = ' '
*             _COLLECT       = ' '
            exceptions
              FOREIGN_LOCK   = 1
              SYSTEM_FAILURE = 2
              others         = 3.
          if SY-SUBRC ne 0.
            /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
          endif.

        else.
***       Remove Write Lock
          call function 'DEQUEUE_E_TABLE'
            exporting
*             MODE_RSTABLE       = 'E'
              TABNAME = 'ZVCXI_XCS_TD030'
*             VARKEY  = VARKEY
*             X_TABNAME          = ' '
*             X_VARKEY           = ' '
*             _SCOPE  = '3'
*             _SYNCHRON          = ' '
*             _COLLECT           = ' '
            .

        endif.


***------------------------------------------------------------------
        move IF_LOCKED to ME->F_LOCKED.

      catch /VCXI/CX_CKX into LR_CX_CKX.
        ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK( ).
        raise exception LR_CX_CKX.
    endtry.

  endmethod.
  method SET_PFSTATUS.

    data:  LT_EXCLUDE type standard table of SYUCOMM.

***----------------------------------------------------------------------------
*** Set PF-Status
    set pf-status '0100' of program ME->S_DYNP-REPID excluding LT_EXCLUDE.

  endmethod.
  method SET_TITLE.

    if ME->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ) eq ABAP_TRUE.
      set titlebar '0100_EDIT' of program ME->S_DYNP-REPID.
    else.
      set titlebar '0100_DISP' of program ME->S_DYNP-REPID.
    endif.

  endmethod.
  method START_UI.

    data:  LR_UIC_BOOSTER type ref to ZCL_VCXI_XCS_UIC_BOOSTER.

*** Create Instance of Framework
    create object LR_UIC_BOOSTER.

*** Call Screen
    call function 'ZVCXI_XCS_UIC_BOOSTER_START'.

  endmethod.
