
class ZCL_VCXI_XCDC_CONDDEF definition
  public
  create public .

public section.

  interfaces /VCXI/IF_CKX_OBJECT .
  interfaces /VCXI/IF_CKX_OBJECT_ACTION .
  interfaces /VCXI/IF_CKX_OBJECT_CD .
  interfaces /VCXI/IF_CKX_OBJECT_LOCKING .
  interfaces /VCXI/IF_CKX_OBJECT_WHEREUSED .

  constants C_ACTVT_CREATE type ACTIV_AUTH value '01'. "#EC NOTEXT
  constants C_ACTVT_DELETE type ACTIV_AUTH value '06'. "#EC NOTEXT
  constants C_ACTVT_DISPLAY type ACTIV_AUTH value '03'. "#EC NOTEXT
  constants C_ACTVT_EDIT type ACTIV_AUTH value '02'. "#EC NOTEXT
  constants C_CDOCL_CONDDEF type CDOBJECTCL value 'ZVCXI_XCD_CONDD'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_ADD type UI_FUNC value 'CONDDEF_ADD'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_ADD_CONDREC type UI_FUNC value 'CONDDEF_ADD_CONDREC'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_COPY type UI_FUNC value 'CONDDEF_COPY'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_DELETE type UI_FUNC value 'CONDDEF_DELETE'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_FREE type UI_FUNC value 'FREE'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_REQ_TR type UI_FUNC value 'CONDDEF_REQ_TR'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_SAVE type UI_FUNC value 'SAVE'. "#EC NOTEXT
  constants C_FCODE_CONDDEF_WHEREUSED type UI_FUNC value 'CONDDEF_WHEREUSED'. "#EC NOTEXT
  constants C_TOOBJ_CONDDEF type /VCXI/CKX_TOOBJ value 'CONDDEF'. "#EC NOTEXT
  type-pools ABAP .
  data F_DELETED type ABAP_BOOL read-only value ABAP_FALSE. "#EC NOTEXT .
  data R_REGDVC type ref to ZCL_VCXI_XCDC_REGDVC read-only .
  data T_CD_EXIT type ZVCXI_XCDC_TT_CD_EXIT read-only .
  data T_CD_VALID type ZVCXI_XCDC_TT_CD_VALID read-only .
  data T_CD_VALUE type ZVCXI_XCDC_TT_CD_VALUE read-only .
  data S_SRC type /VCXI/CKX_S_SRC read-only .
  data T_GCORE type ZVCXI_XCD_TT_GCORE .
  constants C_FCODE_CONDDEF_CHECK type UI_FUNC value 'CONDDEF_CHECK'. "#EC NOTEXT

  methods DO_CHECK
    importing
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE
    raising
      /VCXI/CX_CKX .
  methods CHECK_DEFAUEL
    importing
      !IF_PARID type /VCXI/VKS_PARID
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  class-methods CHECK_AUTH
    importing
      !IF_ACTVT type ACTIV_AUTH
      !IR_CONDDEF type ref to ZCL_VCXI_XCDC_CONDDEF optional
      !IF_ID type /VCXI/CKX_ID optional
    raising
      /VCXI/CX_CKX .
  methods CHECK_DEFAUEX
    importing
      !IF_IEXIT type ZVCXI_XCD_IEXIT
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_DEFAUELEX
    importing
      !IF_PARID type /VCXI/VKS_PARID
      !IF_IEXIT type ZVCXI_XCD_IEXIT
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_EXIT
    importing
      !IF_IEXIT type ZVCXI_XCD_IEXIT
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_FILTER
    importing
      !IS_CR_FILTER type ZVCXI_XCDC_S_CR_FILTER
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_FUNCT
    importing
      !IF_IFUNC type ZVCXI_XCD_IFUNC
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_SCRGR
    importing
      !IF_ISCGR type ZVCXI_XCD_ISCGR
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods CHECK_VALUE
    importing
      !IF_ICOVA type ZVCXI_XCD_ICOVA
    returning
      value(RF_OKAY) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods DELETE_CD_EXIT
    importing
      !IS_CD_EXIT type ZVCXI_XCDC_S_CD_EXIT
    raising
      /VCXI/CX_CKX .
  methods DELETE_CD_VALID
    importing
      !IS_CD_VALID type ZVCXI_XCDC_S_CD_VALID
    raising
      /VCXI/CX_CKX .
  methods DELETE_CD_VALUE
    importing
      !IS_CD_VALUE type ZVCXI_XCDC_S_CD_VALUE
    raising
      /VCXI/CX_CKX .
  methods SET_REGDVC
    importing
      !IF_GREGE type /VCXI/CKR_GREGE
    raising
      /VCXI/CX_CKX .
  methods UPDATE_CD_EXIT
    importing
      !IS_CD_EXIT type ZVCXI_XCDC_S_CD_EXIT
    raising
      /VCXI/CX_CKX .
  methods UPDATE_CD_VALID
    importing
      !IS_CD_VALID type ZVCXI_XCDC_S_CD_VALID
    raising
      /VCXI/CX_CKX .
  methods UPDATE_CD_VALUE
    importing
      !IS_CD_VALUE type ZVCXI_XCDC_S_CD_VALUE
    raising
      /VCXI/CX_CKX .
  methods ADD_CD_VALUE
    importing
      !IS_CD_VALUE type ZVCXI_XCDC_S_CD_VALUE
    raising
      /VCXI/CX_CKX .
  methods ADD_CD_VALID
    importing
      !IS_CD_VALID type ZVCXI_XCDC_S_CD_VALID
    raising
      /VCXI/CX_CKX .
  methods ADD_CD_EXIT
    importing
      !IS_CD_EXIT type ZVCXI_XCDC_S_CD_EXIT
    raising
      /VCXI/CX_CKX .
  methods CONSTRUCTOR
    importing
      !IF_GCODE type ZVCXI_XCD_GCODE
    raising
      /VCXI/CX_CKX .
  class-methods CREATE
    returning
      value(RR_CONDDEF) type ref to ZCL_VCXI_XCDC_CONDDEF
    raising
      /VCXI/CX_CKX .
  methods SET_DESCR
    importing
      !IF_DESCR type /VCXI/CKX_DESCR
      !IF_LANGU type LANGU default SY-LANGU
    raising
      /VCXI/CX_CKX .
  methods SET_ID
    importing
      !IF_ID type /VCXI/CKX_ID
    raising
      /VCXI/CX_CKX .
protected section.

  data F_CHANGED type ABAP_BOOL .
  data F_GCODE type ZVCXI_XCD_GCODE .
  data F_WRITE_TR type ABAP_BOOL .
  data R_DVCCOND type ref to ZCL_VCXI_XCDC_DVCCOND .

  methods CHECK_EXIT_FNAME
    importing
      !IF_FNAME type FUNCNAME
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE
    raising
      /VCXI/CX_CKX .
  methods CHECK_VALUE_FEXCO
    importing
      !IF_FEXCO type ZVCXI_XCD_FEXCO
      !IR_MSG type ref to /VCXI/CL_CKXM_MESSAGE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_COPY
    returning
      value(RR_CONDDEF) type ref to ZCL_VCXI_XCDC_CONDDEF
    raising
      /VCXI/CX_CKX .
  methods HANDLE_DELETE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_FREE
    raising
      /VCXI/CX_CKX .
  methods HANDLE_SAVE
    raising
      /VCXI/CX_CKX .
  methods SET_LOCK
    importing
      !IF_LOCKED type /VCXI/CKX_LOCKED
    raising
      /VCXI/CX_CKX .
private section.

  data F_ICODE type ZVCXI_XCD_ICODE .
  data F_LOCKED type /VCXI/CKX_LOCKED .
  data S_LOG type /VCXI/CKX_S_LOG .
  data T_DESCR type /VCXI/CKX_TT_DESCR .
  class-data T_INSTANCE type /VCXI/CKX_TT_OBJECT_INSTANCE .
  type-pools ABAP .
  data F_DELAYED_LOAD_DESCR type ABAP_BOOL .

  methods BUILD_TC260
    returning
      value(RT_TC260) type ZVCXI_XCD_TT_TC260
    raising
      /VCXI/CX_CKX .
  methods BUILD_TC250
    returning
      value(RT_TC250) type ZVCXI_XCD_TT_TC250
    raising
      /VCXI/CX_CKX .
  methods BUILD_TC201
    returning
      value(RT_TC201) type ZVCXI_XCD_TT_TC201
    raising
      /VCXI/CX_CKX .
  methods INIT_SRC
    raising
      /VCXI/CX_CKX .
  methods HANDLE_CHANGED
    for event /VCXI/IF_CKX_OBJECT~CHANGED of ZCL_VCXI_XCDC_CONDDEF .
  methods INIT_LOG
    raising
      /VCXI/CX_CKX .
  methods LOAD_FROM_DB
    raising
      /VCXI/CX_CKX .
endclass. "ZCL_VCXI_XCDC_CONDDEF definition
class ZCL_VCXI_XCDC_CONDDEF implementation.
method /VCXI/IF_CKX_OBJECT_ACTION~GET_ACTIONS.

  data:  LF_DISABLED type CUA_ACTIVE.

*** Create Menu Reference
  create object RR_MENU.

  if ME->R_DVCCOND->F_CCCORACTIV ne 2.  "Customizing in this client cannot be changed
    move ABAP_FALSE to LF_DISABLED.
  else.
    move ABAP_TRUE  to LF_DISABLED.
  endif.

*** Create Condition Definiton
  RR_MENU->ADD_FUNCTION( FCODE    = ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_ADD
                         TEXT     = 'Create Conditon Definition'(001)
                         DISABLED = LF_DISABLED ).

*** Create Condition Record
  RR_MENU->ADD_FUNCTION( FCODE    = ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_ADD_CONDREC
                         TEXT     = 'Create Conditon Record'(002)
                         DISABLED = ABAP_FALSE ).

*** Where-Used List
  RR_MENU->ADD_FUNCTION( FCODE    = ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_WHEREUSED
                         ICON     = ICON_REFERENCE_LIST
                         TEXT     = 'Where-Used List'(003)
                         DISABLED = ABAP_FALSE ).

*** Delete Condition Definition
  if ME->R_DVCCOND->F_CCCORACTIV                  ne 2 and
     ME->/VCXI/IF_CKX_OBJECT_WHEREUSED~IS_USED( ) ne ABAP_TRUE.
    LF_DISABLED = ABAP_FALSE.
  else.
    LF_DISABLED = ABAP_TRUE.
  endif.
  RR_MENU->ADD_FUNCTION( FCODE    = ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_DELETE
                         TEXT     = 'Delete Condition Definition'(004)
                         DISABLED = LF_DISABLED ).

*** Copy Condition Definition
  if ME->R_DVCCOND->F_CCCORACTIV                  ne 2.
    LF_DISABLED = ABAP_FALSE.
  else.
    LF_DISABLED = ABAP_TRUE.
  endif.
  RR_MENU->ADD_FUNCTION( FCODE    = ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_COPY
                         TEXT     = 'Copy Conditon Definition'(005)
                         DISABLED = LF_DISABLED ).

endmethod.
method /VCXI/IF_CKX_OBJECT_ACTION~HANDLE_ACTION.


  case IF_FCODE.
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_ADD.
      ZCL_VCXI_XCDC_CONDDEF=>CREATE( ).
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_ADD_CONDREC.
      ZCL_VCXI_XCDC_CONDREC=>CREATE_BY_CONDDEF( IR_CONDDEF = ME ).
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_COPY.
      ME->HANDLE_COPY( ).
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_SAVE.
      ME->HANDLE_SAVE( ).
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_DELETE.
      ME->HANDLE_DELETE( ).
    when ZCL_VCXI_XCDC_CONDDEF=>C_FCODE_CONDDEF_FREE.
      ME->HANDLE_FREE( ).
  endcase.

endmethod.
method /VCXI/IF_CKX_OBJECT_CD~GET_INFO.

  move ZCL_VCXI_XCDC_CONDDEF=>C_CDOCL_CONDDEF to EF_CDOCL.
  move ME->/VCXI/IF_CKX_OBJECT~GET_GUID( )    to EF_CDOID.

endmethod.
method /VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED.

***------------------------------------------------------------------------------------------------
*** Check of the Lock-Status of the Object
  if ME->/VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED( ) ne ABAP_TRUE.
*** Condition Definition is not locked. No changes possible.
    raise exception type /VCXI/CX_CKX
          exporting
            F_MSGTY = 'E'
            F_MSGID = 'ZVCXI_XCDC'
            F_MSGNO = '101'.
  endif.

endmethod.
method /VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK .

***--------------------------------------------------------------------------------------
*** Check Authorization
  ZCL_VCXI_XCDC_CONDDEF=>CHECK_AUTH( IF_ACTVT   = ZCL_VCXI_XCDC_CONDDEF=>C_ACTVT_EDIT
                                     IR_CONDDEF = ME ).

***--------------------------------------------------------------------------------------
*** Customizing Changes allowed in Client
  check ME->R_DVCCOND->F_CCCORACTIV ne '2'.

*** Check Source of Element Type
  /VCXI/CL_CKX_SERVICE=>CHECK_SRC( IS_SRC = ME->S_SRC ).

*** Set DB Lock Entrie
  ME->SET_LOCK( IF_LOCKED = ABAP_TRUE ).

  move ABAP_TRUE to ME->F_LOCKED.


***--------------------------------------------------------------------------------------
  try.
***   Load from DB
      ME->LOAD_FROM_DB( ).

    catch /VCXI/CX_CKX.
      ME->HANDLE_FREE( ).
  endtry.

endmethod.
method /VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK .

*** Delete DB Lock Entrie
  ME->SET_LOCK( IF_LOCKED = ABAP_FALSE ).

  move ABAP_FALSE to ME->F_LOCKED.

***--------------------------------------------------------------------------------------
  try.
***   Load from DB
      ME->LOAD_FROM_DB( ).

    catch /VCXI/CX_CKX.
      ME->HANDLE_FREE( ).
  endtry.

endmethod.
method /VCXI/IF_CKX_OBJECT_LOCKING~IS_LOCKED .

  move ME->F_LOCKED to RF_LOCKED.

endmethod.
method /VCXI/IF_CKX_OBJECT_WHEREUSED~GET_WHEREUSED.

  data:  LF_GCODE    type                   /VCXI/CKX_GUID,
         LF_GUID     type                   /VCXI/CKX_GUID,
         LF_GCORE    type                   ZVCXI_XCD_GCORE.
  data:  LS_TD300    type                   ZVCXI_XCD_TD300.
  data:  LT_GCORE    type standard table of ZVCXI_XCD_GCORE.
  data:  LR_CONDREC  type ref to            ZCL_VCXI_XCDC_CONDREC.

*** Get GUID of Condition Definition
  LF_GCODE = ME->/VCXI/IF_CKX_OBJECT~GET_GUID( ).

*** Select all current SmartVC Customizing Elements that ues this Registry Element
  select GCORE
         into table LT_GCORE
         from ZVCXI_XCD_TD300
        where GCODE eq LF_GCODE.

  loop at LT_GCORE into LF_GCORE.
*** Get GUID
    move LF_GCORE to LF_GUID.

*** Get Condition Record to return
    LR_CONDREC ?= ZCL_VCXI_XCDC_CONDREC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
    append LR_CONDREC to RT_OBJECT.
  endloop.

  loop at ME->T_GCORE into LF_GCORE.
    read table LT_GCORE with key TABLE_LINE = LF_GCORE transporting no fields.
    check SY-SUBRC ne 0.
*** Get GUID
    move LF_GCORE to LF_GUID.

*** Get Condition Record to return
    LR_CONDREC ?= ZCL_VCXI_XCDC_CONDREC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
    append LR_CONDREC to RT_OBJECT.

  endloop.

endmethod.
method /VCXI/IF_CKX_OBJECT_WHEREUSED~IS_USED.

  if ME->/VCXI/IF_CKX_OBJECT_WHEREUSED~GET_WHEREUSED( ) is not initial.
    move ABAP_TRUE  to RF_USED.
  else.
    move ABAP_FALSE to RF_USED.
  endif.

endmethod.
method /VCXI/IF_CKX_OBJECT~GET_DESCR.

  data:  LT_DESCR type /VCXI/CKX_TT_DESCR.

  try.
      LT_DESCR = ME->/VCXI/IF_CKX_OBJECT~GET_DESCR_ALL( ).
      RF_DESCR = /VCXI/CL_CKX_SERVICE=>GET_DESCR_TRANSLATION( IT_DESCR = LT_DESCR ).
    catch /VCXI/CX_CKX.
      clear RF_DESCR.
  endtry.


endmethod.
method /VCXI/IF_CKX_OBJECT~GET_DESCR_ALL.

***----------------------------------------------------------------------------
*** Load Description if load was delayed
  if ME->F_DELAYED_LOAD_DESCR eq ABAP_TRUE.
    move ABAP_FALSE to ME->F_DELAYED_LOAD_DESCR.

*** Load Description
    select LANGU DESCR
           into table ME->T_DESCR
           from ZVCXI_XCD_TC200T
          where GCODE eq ME->F_GCODE.                                  "#EC CI_SUBRC
  endif.

***----------------------------------------------------------------------------
*** Return Descriptions
  move ME->T_DESCR to RT_DESCR.

endmethod.
method /VCXI/IF_CKX_OBJECT~GET_GUID.

  move ME->F_GCODE to RF_GUID.

endmethod.
method /VCXI/IF_CKX_OBJECT~GET_ID.

  move ME->F_ICODE to RF_ID.

endmethod.
method /VCXI/IF_CKX_OBJECT~GET_INSTANCE.

  data:  LF_GCODE    type        ZVCXI_XCD_GCODE.
  data:  LS_INSTANCE type        /VCXI/CKX_S_OBJECT_INSTANCE.
  data:  LR_CONDDEF  type ref to ZCL_VCXI_XCDC_CONDDEF.

*** Make sure DVC Condition Customizing Instance is there
  ZCL_VCXI_XCDC_DVCCOND=>GET_INSTANCE( ).

*** Check Instances
  read table ZCL_VCXI_XCDC_CONDDEF=>T_INSTANCE into LS_INSTANCE with key GUID = IF_GUID.
  if SY-SUBRC eq 0.
    move LS_INSTANCE-R_OBJECT to RR_OBJECT.
  else.
    move IF_GUID to LF_GCODE.

*** Get new Instance
    try.
        create object LR_CONDDEF
          exporting
            IF_GCODE = LF_GCODE.
      catch CX_SY_CREATE_OBJECT_ERROR.
        raise exception type /VCXI/CX_CKX.
    endtry.
    move LR_CONDDEF ?to RR_OBJECT.
  endif.

endmethod.
method /VCXI/IF_CKX_OBJECT~GET_LOG.

  move ME->S_LOG to RS_LOG.

endmethod.
method ADD_CD_EXIT.

  field-symbols: <S_CD_EXIT> type ZVCXI_XCDC_S_CD_EXIT.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_EXIT assigning <S_CD_EXIT> with key IEXIT = IS_CD_EXIT-IEXIT.

  if SY-SUBRC ne 0.
    append initial line to ME->T_CD_EXIT assigning <S_CD_EXIT>.
    move-corresponding IS_CD_EXIT to <S_CD_EXIT>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method ADD_CD_VALID.

  field-symbols: <S_CD_VALID> type ZVCXI_XCDC_S_CD_VALID.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALID assigning <S_CD_VALID> with key CMATN = IS_CD_VALID-CMATN
                                                            PRFID = IS_CD_VALID-PRFID
                                                            ICELM = IS_CD_VALID-ICELM.

  if SY-SUBRC ne 0.
    append initial line to ME->T_CD_VALID assigning <S_CD_VALID>.
    move-corresponding IS_CD_VALID to <S_CD_VALID>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method ADD_CD_VALUE.

  field-symbols: <S_CD_VALUE> type ZVCXI_XCDC_S_CD_VALUE.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALUE assigning <S_CD_VALUE> with key ICOVA = IS_CD_VALUE-ICOVA.

  if SY-SUBRC ne 0.
    append initial line to ME->T_CD_VALUE assigning <S_CD_VALUE>.
    move-corresponding IS_CD_VALUE to <S_CD_VALUE>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method BUILD_TC201.

  data:          LS_CD_VALID type ZVCXI_XCDC_S_CD_VALID.
  field-symbols: <S_TC201>   type ZVCXI_XCD_TC201.

  loop at ME->T_CD_VALID into LS_CD_VALID.
    append initial line to RT_TC201 assigning <S_TC201>.
    move SY-MANDT                  to <S_TC201>-MANDT.
    move ME->F_GCODE               to <S_TC201>-GCODE.
    move-corresponding LS_CD_VALID to <S_TC201>.
  endloop.

endmethod.
method BUILD_TC250.

  data:          LS_CD_VALUE type ZVCXI_XCDC_S_CD_VALUE.
  field-symbols: <S_TC250>   type ZVCXI_XCD_TC250.

  loop at ME->T_CD_VALUE into LS_CD_VALUE.
    append initial line to RT_TC250 assigning <S_TC250>.
    move SY-MANDT                  to <S_TC250>-MANDT.
    move ME->F_GCODE               to <S_TC250>-GCODE.
    move-corresponding LS_CD_VALUE to <S_TC250>.
  endloop.

endmethod.
method BUILD_TC260.

  data:          LS_CD_EXIT  type ZVCXI_XCDC_S_CD_EXIT.
  field-symbols: <S_TC260>   type ZVCXI_XCD_TC260.

  loop at ME->T_CD_EXIT into LS_CD_EXIT.
    append initial line to RT_TC260 assigning <S_TC260>.
    move SY-MANDT                  to <S_TC260>-MANDT.
    move ME->F_GCODE               to <S_TC260>-GCODE.
    move-corresponding LS_CD_EXIT to <S_TC260>.
  endloop.

endmethod.
method CHECK_AUTH.

  data:  LF_ID     type /VCXI/CKX_ID,
         LF_MSGV1  type SYMSGV,
         LF_MSGV2  type SYMSGV.

***--------------------------------------------------------------------------------------
*** Get Condition Definition ID
  if IR_CONDDEF is bound.
    move IR_CONDDEF->/VCXI/IF_CKX_OBJECT~GET_ID( ) to LF_ID.
  elseif IF_ID is not initial.
    move IF_ID to LF_ID.
  endif.

****--------------------------------------------------------------------------------------
**** Check Authority for Condition Definition
  if LF_ID is not initial.
    authority-check object 'Z_XC_DVC_D'
             id 'ACTVT'       field IF_ACTVT
             id 'Z_XC_DVC_D'  field LF_ID.
  else.
    authority-check object 'Z_XC_DVC_D'
             id 'ACTVT'       field IF_ACTVT
             id 'Z_XC_DVC_D'  dummy.
  endif.

***--------------------------------------------------------------------------------------
  if SY-SUBRC ne 0.
*** Get Activity Description
    select single LTEXT
           into LF_MSGV1
           from TACTT
          where SPRAS eq SY-LANGU
           and  ACTVT eq IF_ACTVT.

***   No authorization to & Condition Definition &.
    move LF_ID to LF_MSGV2.
    raise exception type /VCXI/CX_CKX
       exporting
         F_MSGTY = 'E'
         F_MSGID = 'ZVCXI_XCDC'
         F_MSGNO = '150'
         F_MSGV1 = LF_MSGV1
         F_MSGV2 = LF_MSGV2.
  endif.

endmethod.
method CHECK_DEFAUEL.

  data: LR_DEFAU type ref to ZIF_VCXI_XCDC_REGDVC_DEFAU.

  try.
      move ME->R_REGDVC ?to LR_DEFAU.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

*** Check if Value Parameter is Valid
  read table LR_DEFAU->T_REGDVC_DEFAUEL with key PARID = IF_PARID
                                        transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_DEFAUELEX.

  data: LR_DEFAU type ref to ZIF_VCXI_XCDC_REGDVC_DEFAU.

  try.
      move ME->R_REGDVC ?to LR_DEFAU.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

*** Check if Exit for Parameter is Valid
  read table LR_DEFAU->T_REGDVC_DEFAUELEX with key PARID = IF_PARID
                                                   IEXIT = IF_IEXIT
                                          transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_DEFAUEX.

  data: LR_DEFAU type ref to ZIF_VCXI_XCDC_REGDVC_DEFAU.

  try.
      move ME->R_REGDVC ?to LR_DEFAU.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

*** Check if Exit for Parameter is Valid
  read table LR_DEFAU->T_REGDVC_DEFAUEX with key IEXIT = IF_IEXIT
                                        transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_EXIT.

*** Check if Value ID is Valid
  read table ME->T_CD_EXIT with key IEXIT = IF_IEXIT
                           transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_EXIT_FNAME.

  data:  LF_FUNCNAME          type                   RS38L-NAME,
         LF_EXCEPTION_CLASSES type                   ENLFDIR-EXTEN3.
  data:  LS_RSEXC             type                   RSEXC,
         LS_RSIMP             type                   RSIMP,
         LS_RSEXP             type                   RSEXP.
  data:  LT_RSEXC             type standard table of RSEXC,
         LT_RSIMP             type standard table of RSIMP,
         LT_RSEXP             type standard table of RSEXP,
         LT_RSCHA             type standard table of RSCHA,
         LT_RSTBL             type standard table of RSTBL.
  data:  LR_CX_CKX            type ref to            /VCXI/CX_CKX.

  check IF_FNAME is not initial.

***----------------------------------------------------------------------------
*** Get Function Module Interface Definition
  try.
      move IF_FNAME to LF_FUNCNAME.
      call function 'FUNCTION_IMPORT_INTERFACE'
        exporting
          FUNCNAME           = LF_FUNCNAME
        importing
          EXCEPTION_CLASSES  = LF_EXCEPTION_CLASSES
        tables
          EXCEPTION_LIST     = LT_RSEXC
          IMPORT_PARAMETER   = LT_RSIMP
          EXPORT_PARAMETER   = LT_RSEXP
          CHANGING_PARAMETER = LT_RSCHA
          TABLES_PARAMETER   = LT_RSTBL
        exceptions
          ERROR_MESSAGE      = 1
          FUNCTION_NOT_FOUND = 2
          INVALID_NAME       = 3
          others             = 4.
      if SY-SUBRC <> 0.
        /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
      endif.
    catch /VCXI/CX_CKX into LR_CX_CKX.
      IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      exit.
  endtry.

***----------------------------------------------------------------------------
*** Check Exception
  if LT_RSEXC is not initial.
*** Only Class-based Exceptions
    if LF_EXCEPTION_CLASSES ne ABAP_TRUE.
***   Function Module &1: Only class-based Exceptions are supported.
      try.
          /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                IF_MSGID = 'ZVCXI_XCDC'
                                                IF_MSGNO = '107'
                                                IF_MSGV1 = LF_FUNCNAME ).
        catch /VCXI/CX_CKX into LR_CX_CKX.
          IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endtry.
    endif.
*** Only supported Exceptions
    loop at LT_RSEXC into LS_RSEXC where EXCEPTION ne '/VCXI/CX_CKX'.
***   Function Module &1: Class-based Exception &2 is not supported.
      try.
          /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                IF_MSGID = 'ZVCXI_XCDC'
                                                IF_MSGNO = '108'
                                                IF_MSGV1 = LF_FUNCNAME
                                                IF_MSGV2 = LS_RSEXC-EXCEPTION ).
        catch /VCXI/CX_CKX into LR_CX_CKX.
          IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endtry.
    endloop.
  endif.

***----------------------------------------------------------------------------
*** Check Importing Parameter
  loop at LT_RSIMP into LS_RSIMP.
    case LS_RSIMP-PARAMETER.
      when 'IR_GATE'.
        if LS_RSIMP-TYP ne 'REF TO /VCXI/CL_VKSR_GATE'.
***       Function Module &1: Parameter &2 requires 'TYPE &3'.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '105'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSIMP-PARAMETER
                                                    IF_MSGV3 = 'ABAP_BOOL' ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
      when others.
***     Other Parameters have to be optional
        if LS_RSIMP-OPTIONAL ne ABAP_TRUE.
***       Function Module &1: Parameter &2 is only supported if optional.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '106'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSIMP-PARAMETER ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
    endcase.
  endloop.

***----------------------------------------------------------------------------
*** Check Exporting Parameter
  loop at LT_RSEXP into LS_RSEXP.
    case LS_RSEXP-PARAMETER.
      when 'EF_VALID'.
        if LS_RSEXP-TYP ne 'ABAP_BOOL'.
***       Function Module &1: Parameter &2 requires 'TYPE &3'.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '105'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSEXP-PARAMETER
                                                    IF_MSGV3 = 'ABAP_BOOL' ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
      when others.
***     Function Module &1: Parameter &1 is not supported.
        try.
            /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                  IF_MSGID = 'ZVCXI_XCDC'
                                                  IF_MSGNO = '104'
                                                  IF_MSGV1 = LF_FUNCNAME
                                                  IF_MSGV2 = LS_RSEXP-PARAMETER ).
          catch /VCXI/CX_CKX into LR_CX_CKX.
            IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
        endtry.
    endcase.
  endloop.

endmethod.
method CHECK_FILTER.

*** Check Full Combination
  if     IS_CR_FILTER-CMATN is not initial and
         IS_CR_FILTER-PRFID is not initial and
         IS_CR_FILTER-ICELM is not initial.

    read table ME->T_CD_VALID with key CMATN = IS_CR_FILTER-CMATN
                                       PRFID = IS_CR_FILTER-PRFID
                                       ICELM = IS_CR_FILTER-ICELM
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check only Config Material
  elseif IS_CR_FILTER-CMATN is not initial and
         IS_CR_FILTER-PRFID is     initial and
         IS_CR_FILTER-ICELM is     initial.

    read table ME->T_CD_VALID with key CMATN = IS_CR_FILTER-CMATN
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check only Profil
  elseif IS_CR_FILTER-CMATN is     initial and
         IS_CR_FILTER-PRFID is not initial and
         IS_CR_FILTER-ICELM is     initial.

    read table ME->T_CD_VALID with key PRFID = IS_CR_FILTER-PRFID
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check only Customizing Element
  elseif IS_CR_FILTER-CMATN is     initial and
         IS_CR_FILTER-PRFID is     initial and
         IS_CR_FILTER-ICELM is not initial.

    read table ME->T_CD_VALID with key ICELM = IS_CR_FILTER-ICELM
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check Config Material and Profil
  elseif IS_CR_FILTER-CMATN is not initial and
         IS_CR_FILTER-PRFID is not initial and
         IS_CR_FILTER-ICELM is     initial.

    read table ME->T_CD_VALID with key CMATN = IS_CR_FILTER-CMATN
                                       PRFID = IS_CR_FILTER-PRFID
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check Config Material and Customizing Element
  elseif IS_CR_FILTER-CMATN is not initial and
         IS_CR_FILTER-PRFID is     initial and
         IS_CR_FILTER-ICELM is not initial.

    read table ME->T_CD_VALID with key CMATN = IS_CR_FILTER-CMATN
                                       ICELM = IS_CR_FILTER-ICELM
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Check Profil and Customizing Element.
  elseif IS_CR_FILTER-CMATN is     initial and
         IS_CR_FILTER-PRFID is not initial and
         IS_CR_FILTER-ICELM is not initial.

    read table ME->T_CD_VALID with key PRFID = IS_CR_FILTER-PRFID
                                       ICELM = IS_CR_FILTER-ICELM
                              transporting no fields.
    if SY-SUBRC = 0.
      move ABAP_TRUE to RF_OKAY.
    else.
      move ABAP_FALSE to RF_OKAY.
    endif.

*** Nothing Maintained is always Valid
  else.
    move ABAP_TRUE to RF_OKAY.
  endif.

endmethod.
method CHECK_FUNCT.

  data: LR_FUNCT type ref to ZIF_VCXI_XCDC_REGDVC_FUNCT.

  try.
      move ME->R_REGDVC ?to LR_FUNCT.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

*** Check if Function ID is Valid
  read table LR_FUNCT->T_REGDVC_FUNCT with key IFUNC = IF_IFUNC
                                      transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_SCRGR.

  data: LR_SCRGR type ref to ZIF_VCXI_XCDC_REGDVC_SCRGR.

  try.
      move ME->R_REGDVC ?to LR_SCRGR.
    catch CX_SY_MOVE_CAST_ERROR.
      exit.
  endtry.

*** Check if Screen Group ID is Valid
  read table LR_SCRGR->T_REGDVC_SCRGR with key ISCGR = IF_ISCGR
                                      transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_VALUE.

*** Check if Value ID is Valid
  read table ME->T_CD_VALUE with key ICOVA = IF_ICOVA
                            transporting no fields.
  if SY-SUBRC = 0.
    move ABAP_TRUE to RF_OKAY.
  else.
    move ABAP_FALSE to RF_OKAY.
  endif.

endmethod.
method CHECK_VALUE_FEXCO.

  data:  LF_FUNCNAME          type                   RS38L-NAME,
         LF_EXCEPTION_CLASSES type                   ENLFDIR-EXTEN3.
  data:  LS_RSEXC             type                   RSEXC,
         LS_RSIMP             type                   RSIMP,
         LS_RSEXP             type                   RSEXP.
  data:  LT_RSEXC             type standard table of RSEXC,
         LT_RSIMP             type standard table of RSIMP,
         LT_RSEXP             type standard table of RSEXP,
         LT_RSCHA             type standard table of RSCHA,
         LT_RSTBL             type standard table of RSTBL.
  data:  LR_CX_CKX            type ref to            /VCXI/CX_CKX.

  check IF_FEXCO is not initial.

***----------------------------------------------------------------------------
*** Get Function Module Interface Definition
  try.
      move IF_FEXCO to LF_FUNCNAME.
      call function 'FUNCTION_IMPORT_INTERFACE'
        exporting
          FUNCNAME           = LF_FUNCNAME
        importing
          EXCEPTION_CLASSES  = LF_EXCEPTION_CLASSES
        tables
          EXCEPTION_LIST     = LT_RSEXC
          IMPORT_PARAMETER   = LT_RSIMP
          EXPORT_PARAMETER   = LT_RSEXP
          CHANGING_PARAMETER = LT_RSCHA
          TABLES_PARAMETER   = LT_RSTBL
        exceptions
          ERROR_MESSAGE      = 1
          FUNCTION_NOT_FOUND = 2
          INVALID_NAME       = 3
          others             = 4.
      if SY-SUBRC <> 0.
        /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
      endif.
    catch /VCXI/CX_CKX into LR_CX_CKX.
      IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      exit.
  endtry.

***----------------------------------------------------------------------------
*** Check Exception
  if LT_RSEXC is not initial.
*** Only Class-based Exceptions
    if LF_EXCEPTION_CLASSES ne ABAP_TRUE.
***   Function Module &1: Only class-based Exceptions are supported.
      try.
          /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                IF_MSGID = 'ZVCXI_XCDC'
                                                IF_MSGNO = '107'
                                                IF_MSGV1 = LF_FUNCNAME ).
        catch /VCXI/CX_CKX into LR_CX_CKX.
          IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endtry.
    endif.
*** Only supported Exceptions
    loop at LT_RSEXC into LS_RSEXC where EXCEPTION ne '/VCXI/CX_CKX'.
***   Function Module &1: Class-based Exception &2 is not supported.
      try.
          /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                IF_MSGID = 'ZVCXI_XCDC'
                                                IF_MSGNO = '108'
                                                IF_MSGV1 = LF_FUNCNAME
                                                IF_MSGV2 = LS_RSEXC-EXCEPTION ).
        catch /VCXI/CX_CKX into LR_CX_CKX.
          IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endtry.
    endloop.
  endif.

***----------------------------------------------------------------------------
*** Check Importing Parameter
  loop at LT_RSIMP into LS_RSIMP.
    case LS_RSIMP-PARAMETER.
      when 'IR_GATE'.
        if LS_RSIMP-TYP ne 'REF TO /VCXI/CL_VKSR_GATE'.
***       Function Module &1: Parameter &2 requires 'TYPE &3'.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '105'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSIMP-PARAMETER
                                                    IF_MSGV3 = 'REF TO /VCXI/CL_VKSR_GATE' ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
      when others.
***     Other Parameters have to be optional
        if LS_RSIMP-OPTIONAL ne ABAP_TRUE.
***       Function Module &1: Parameter &2 is only supported if optional.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '106'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSIMP-PARAMETER ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
    endcase.
  endloop.

***----------------------------------------------------------------------------
*** Check Exporting Parameter
  loop at LT_RSEXP into LS_RSEXP.
    case LS_RSEXP-PARAMETER.
      when 'ER_GATE'.
        if LS_RSEXP-TYP ne 'REF TO /VCXI/CL_VKSR_GATE'.
***       Function Module &1: Parameter &2 requires 'TYPE &3'.
          try.
              /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                    IF_MSGID = 'ZVCXI_XCDC'
                                                    IF_MSGNO = '105'
                                                    IF_MSGV1 = LF_FUNCNAME
                                                    IF_MSGV2 = LS_RSEXP-PARAMETER
                                                    IF_MSGV3 = 'REF TO /VCXI/CL_VKSR_GATE' ).
            catch /VCXI/CX_CKX into LR_CX_CKX.
              IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
          endtry.
        endif.
      when others.
***     Function Module &1: Parameter &1 is not supported.
        try.
            /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                                  IF_MSGID = 'ZVCXI_XCDC'
                                                  IF_MSGNO = '104'
                                                  IF_MSGV1 = LF_FUNCNAME
                                                  IF_MSGV2 = LS_RSEXP-PARAMETER ).
          catch /VCXI/CX_CKX into LR_CX_CKX.
            IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
        endtry.
    endcase.
  endloop.

endmethod.
method CONSTRUCTOR.

  field-symbols:  <S_INSTANCE>       type         /VCXI/CKX_S_OBJECT_INSTANCE.

***------------------------------------------------------------------------------------------------
*** Set Import Parameter to Attributes
  move IF_GCODE to ME->F_GCODE.

*** Get DynamicVC Condition Instance
  ME->R_DVCCOND = ZCL_VCXI_XCDC_DVCCOND=>GET_INSTANCE( ).

***------------------------------------------------------------------------------------------------
*** Define Type of Object
  move C_TOOBJ_CONDDEF to ME->/VCXI/IF_CKX_OBJECT~F_TOOBJ.

***------------------------------------------------------------------------------------------------
*** Add instance to instance buffer
  append initial line to ZCL_VCXI_XCDC_CONDDEF=>T_INSTANCE assigning <S_INSTANCE>.
  move ME->/VCXI/IF_CKX_OBJECT~GET_GUID( )  to <S_INSTANCE>-GUID.
  move ME                                  ?to <S_INSTANCE>-R_OBJECT.

*** Register to DynamicVC Condition Instance
  ME->R_DVCCOND->REGISTER_OBJECT( IR_OBJECT = ME ).

***------------------------------------------------------------------------------------------------
*** Load DB
  ME->LOAD_FROM_DB( ).

***------------------------------------------------------------------------------------------------
  set handler ME->HANDLE_CHANGED for ME.

endmethod.
  method CREATE.

    data:  LF_GCODE                     type        ZVCXI_XCD_GCODE.
    data:  LR_CX_SY_CREATE_OBJECT_ERROR type ref to CX_SY_CREATE_OBJECT_ERROR.

***--------------------------------------------------------------------------------------
*** Check Authorization
    ZCL_VCXI_XCDC_CONDDEF=>CHECK_AUTH( IF_ACTVT = ZCL_VCXI_XCDC_CONDDEF=>C_ACTVT_CREATE ).

*** Check Client Status
    if ZCL_VCXI_XCDC_DVCCOND=>GET_INSTANCE( )->F_CCCORACTIV eq 2.  "Customizing in this client cannot be changed
***   Client &1 has status 'not modifiable'
      /VCXI/CX_CKX=>RAISE_CKX_WITH_MESSAGE( IF_MSGTY = 'E'
                                            IF_MSGID = 'TK'
                                            IF_MSGNO = '430'
                                            IF_MSGV1 = SY-MANDT ).
    endif.

***--------------------------------------------------------------------------------------
*** Get GUID
    call function 'GUID_CREATE'
      importing
        EV_GUID_22 = LF_GCODE.

*** Create Condition Definition
    try.
        create object RR_CONDDEF
          exporting
            IF_GCODE = LF_GCODE.
      catch CX_SY_CREATE_OBJECT_ERROR into LR_CX_SY_CREATE_OBJECT_ERROR.
        /VCXI/CX_CKX=>RAISE_CKX_BY_PREVIOUS( IR_PREVIOUS = LR_CX_SY_CREATE_OBJECT_ERROR ).
    endtry.

    RR_CONDDEF->INIT_SRC( ).
    RR_CONDDEF->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).
    RR_CONDDEF->INIT_LOG( ).
    RR_CONDDEF->SET_LOCK( IF_LOCKED = ABAP_TRUE ).

  endmethod.
method DELETE_CD_EXIT.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_EXIT with key IEXIT = IS_CD_EXIT-IEXIT
                           transporting no fields.

  if SY-SUBRC eq 0.
    delete ME->T_CD_EXIT where IEXIT = IS_CD_EXIT-IEXIT.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method DELETE_CD_VALID.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALID with key CMATN = IS_CD_VALID-CMATN
                                     PRFID = IS_CD_VALID-PRFID
                                     ICELM = IS_CD_VALID-ICELM
                               transporting no fields.

  if SY-SUBRC eq 0.
    delete ME->T_CD_VALID where CMATN = IS_CD_VALID-CMATN
                            and PRFID = IS_CD_VALID-PRFID
                            and ICELM = IS_CD_VALID-ICELM.

  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method DELETE_CD_VALUE.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALUE with key ICOVA = IS_CD_VALUE-ICOVA
                               transporting no fields.

  if SY-SUBRC eq 0.
    delete ME->T_CD_VALUE where ICOVA = IS_CD_VALUE-ICOVA.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method DO_CHECK.

  data: LF_GUID     type         /VCXI/CKX_GUID.
  data: LS_CD_VALUE type         ZVCXI_XCDC_S_CD_VALUE,
        LS_CD_EXIT  type         ZVCXI_XCDC_S_CD_EXIT.
  data: LR_CX_CKX   type ref to  /VCXI/CX_CKX.

  check ME->F_DELETED ne ABAP_TRUE.

*** Do Check if Registry element is filled and valid
  if ME->R_REGDVC is not bound.
*** No valid Registry Element is maintained. Please check!
    IR_MSG->ADD_MESSAGE( IF_MSGTY = 'E'
                         IF_MSGID = 'ZVCXI_XCDC'
                         IF_MSGNO = '109' ).
  endif.

*** Do Check of Value Entries
  loop at ME->T_CD_VALUE into LS_CD_VALUE.

*** Check DataElement
    call function 'DDIF_FIELDLABEL_GET'
      exporting
        TABNAME        = LS_CD_VALUE-DATEL
        LANGU          = SY-LANGU
        LFIELDNAME     = ' '
      exceptions
        NOT_FOUND      = 1
        INTERNAL_ERROR = 2
        others         = 3.
    if SY-SUBRC <> 0.
      IR_MSG->ADD_MESSAGE( IF_MSGTY = 'E'
                           IF_MSGID = 'ZVCXI_XCDC'
                           IF_MSGNO = '103'
                           IF_MSGV1 = LS_CD_VALUE-DATEL ).
    endif.

*** Check Condition relativ Alias - Exit
    ME->CHECK_VALUE_FEXCO( IF_FEXCO = LS_CD_VALUE-FEXCO
                           IR_MSG   = IR_MSG ).

*** Check Parameter ID
    if LS_CD_VALUE-PARID ne 'LEOKY'.
      move LS_CD_VALUE-PARID to LF_GUID.
      try.
          /VCXI/CL_VKSC_PARAM=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
        catch /VCXI/CX_CKX into LR_CX_CKX.
          IR_MSG->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
      endtry.
    endif.
  endloop.

*** Do Check of Exit Entries
  loop at ME->T_CD_EXIT into LS_CD_EXIT.

*** Check Function Name
    ME->CHECK_EXIT_FNAME( IF_FNAME = LS_CD_EXIT-FNAME
                          IR_MSG   = IR_MSG ).

  endloop.

endmethod.
method HANDLE_CHANGED.

  data:  LR_CX_CKX type ref to /VCXI/CX_CKX.

  try.
      move SY-UNAME     to ME->S_LOG-CHABY.
      get time stamp field ME->S_LOG-CHAAT.

***   Set the Change Indicator
      move ABAP_TRUE to ME->F_CHANGED.

***   Transport
      if ME->R_DVCCOND->F_CCCORACTIV eq '1'.
        move ABAP_TRUE to ME->F_WRITE_TR.
        ME->R_DVCCOND->REQUEST_TRANSPORT( ).
      endif.

    catch /VCXI/CX_CKX into LR_CX_CKX.
      LR_CX_CKX->SHOW_MESSAGE( ).
  endtry.

endmethod.
method HANDLE_COPY.

  data:  LF_GREGE    type     /VCXI/CKR_GREGE.
  data:  LS_DESCR    type     /VCXI/CKX_S_DESCR,
         LS_CD_VALID type     ZVCXI_XCDC_S_CD_VALID,
         LS_CD_VALUE type     ZVCXI_XCDC_S_CD_VALUE,
         LS_CD_EXIT  type     ZVCXI_XCDC_S_CD_EXIT.
  data:  LT_DESCR    type     /VCXI/CKX_TT_DESCR.

***------------------------------------------------------------------------------------------------
*** Check of the Lock-Status of the Object
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

*** Create new Condition Definition
  RR_CONDDEF = ZCL_VCXI_XCDC_CONDDEF=>CREATE( ).

*** Copy Header
  RR_CONDDEF->SET_ID( IF_ID = ME->F_ICODE ).
  if ME->R_REGDVC is bound.
    LF_GREGE = ME->R_REGDVC->/VCXI/IF_CKX_OBJECT~GET_GUID( ).
    RR_CONDDEF->SET_REGDVC( IF_GREGE = LF_GREGE ).
  endif.

*** Copy Description
  LT_DESCR = ME->/VCXI/IF_CKX_OBJECT~GET_DESCR_ALL( ).
  loop at LT_DESCR into LS_DESCR.
    RR_CONDDEF->SET_DESCR( IF_DESCR = LS_DESCR-DESCR
                           IF_LANGU = LS_DESCR-LANGU ).
  endloop.

*** Set Valid
  loop at ME->T_CD_VALID into LS_CD_VALID.
    RR_CONDDEF->ADD_CD_VALID( IS_CD_VALID = LS_CD_VALID ).
  endloop.

*** Set Value
  loop at ME->T_CD_VALUE into LS_CD_VALUE.
    RR_CONDDEF->ADD_CD_VALUE( IS_CD_VALUE = LS_CD_VALUE ).
  endloop.

*** Set Exit
  loop at ME->T_CD_EXIT into LS_CD_EXIT.
    RR_CONDDEF->ADD_CD_EXIT( IS_CD_EXIT = LS_CD_EXIT ).
  endloop.

endmethod.
method HANDLE_DELETE.

  data: LT_OBJECT type /VCXI/CKX_TT_OBJECT.
  data: LF_MSGV1  type SYMSGV.

***------------------------------------------------------------------------------------------------
*** Check of the Lock-Status of the Object
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_LOCK( ).
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

***------------------------------------------------------------------------------------------------
*** Check Authorization
  ZCL_VCXI_XCDC_CONDDEF=>CHECK_AUTH( IF_ACTVT   = ZCL_VCXI_XCDC_CONDDEF=>C_ACTVT_DELETE
                                     IR_CONDDEF = ME ).

***------------------------------------------------------------------------------------------------
*** Check if it used or not -> Only delete Objects which are not in Use!!
  if ME->/VCXI/IF_CKX_OBJECT_WHEREUSED~IS_USED( ) eq ABAP_TRUE.
    LT_OBJECT = ME->/VCXI/IF_CKX_OBJECT_WHEREUSED~GET_WHEREUSED( ).
    LF_MSGV1 = lines( LT_OBJECT ).
*** Condition Definition is still in Use of &1 Objects and can't be deleted.
    raise exception type /VCXI/CX_CKX
          exporting
            F_MSGTY = 'E'
            F_MSGID = 'ZVCXI_XCDC'
            F_MSGNO = '102'
            F_MSGV1 = LF_MSGV1.
  endif.

***------------------------------------------------------------------------------------------------
*** Mark as deleted
  move ABAP_TRUE to ME->F_DELETED.
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method HANDLE_FREE .

  data:  LF_GUID type /VCXI/CKX_GUID.

  ME->R_DVCCOND->UNREGISTER_OBJECT( IR_OBJECT = ME ).

  LF_GUID = ME->/VCXI/IF_CKX_OBJECT~GET_GUID( ).
  delete ZCL_VCXI_XCDC_CONDDEF=>T_INSTANCE where GUID = LF_GUID.

endmethod.
method HANDLE_SAVE .

  data:  LF_GREGE     type        /VCXI/CKR_GREGE.
  data:  LT_TC201     type        ZVCXI_XCD_TT_TC201,
         LT_TC250     type        ZVCXI_XCD_TT_TC250,
         LT_TC260     type        ZVCXI_XCD_TT_TC260.

*** Save only if changed
  check ME->F_CHANGED eq ABAP_TRUE.
  move ABAP_FALSE to ME->F_CHANGED.

***----------------------------------------------------------------------------
*** Set Changed Info to Log
  move SY-UNAME     to ME->S_LOG-CHABY.
  get time stamp field ME->S_LOG-CHAAT.

*** Get Registry Element DynamicVC GUID
  if ME->R_REGDVC is bound.
    move ME->R_REGDVC->/VCXI/IF_CKX_OBJECT~GET_GUID( ) to LF_GREGE.
  endif.

*** Get Depending Tables
  LT_TC201 = ME->BUILD_TC201( ).
  LT_TC250 = ME->BUILD_TC250( ).
  LT_TC260 = ME->BUILD_TC260( ).

***----------------------------------------------------------------------------
  if ME->F_DELETED eq ABAP_FALSE.
*** Save Condition Definition
    call function 'ZVCXI_XCDC_DB_SAVE_CONDDEF'
      in update task
      exporting
        IF_GCODE    = ME->F_GCODE
        IF_ICODE    = ME->F_ICODE
        IF_GREGE    = LF_GREGE
        IS_LOG      = ME->S_LOG
        IS_SRC      = ME->S_SRC
        IT_DESCR    = ME->T_DESCR
        IT_TC201    = LT_TC201
        IT_TC250    = LT_TC250
        IT_TC260    = LT_TC260
        IF_WRITE_TR = ME->F_WRITE_TR.
  else.
*** Delete Condition Definition
    call function 'ZVCXI_XCDC_DB_DEL_CONDDEF'
      in update task
      exporting
        IF_GCODE    = ME->F_GCODE
        IF_WRITE_TR = ME->F_WRITE_TR.
  endif.

endmethod.
method INIT_LOG.

***----------------------------------------------------------------------------
*** Set Created Info to Log
  move SY-UNAME     to ME->S_LOG-CREBY.
  get time stamp field ME->S_LOG-CREAT.

  raise event /VCXI/IF_CKX_OBJECT~CREATED.
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method INIT_SRC.

*** Set Source
  move SY-SYSID to ME->S_SRC-SRCSY.
  move SY-MANDT to ME->S_SRC-SRCMA.

endmethod.
method LOAD_FROM_DB .

  data:  LF_GUID    type                   /VCXI/CKX_GUID,
         LF_GCORE   type                   ZVCXI_XCD_GCORE.
  data:  LS_TC200   type                   ZVCXI_XCD_TC200.
  data:  LT_GCORE   type standard table of ZVCXI_XCD_GCORE.


  free: ME->F_ICODE,
        ME->T_CD_EXIT,
        ME->T_CD_VALID,
        ME->T_CD_VALUE,
        ME->T_DESCR,
        ME->R_REGDVC.


***------------------------------------------------------------------------------------------------
*** Load Header
  select single *
         into LS_TC200
         from ZVCXI_XCD_TC200
        where GCODE eq ME->F_GCODE.
  check SY-SUBRC eq 0.
  free:   ME->S_LOG,
          ME->S_SRC.
  move               LS_TC200-ICODE to ME->F_ICODE.
  move-corresponding LS_TC200       to ME->S_LOG.
  move-corresponding LS_TC200       to ME->S_SRC.

  if LS_TC200-GREGE is not initial.
    move LS_TC200-GREGE to LF_GUID.
    ME->R_REGDVC ?= ZCL_VCXI_XCDC_REGDVC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
  endif.

*** Delay Load of Descriptions
  move ABAP_TRUE to ME->F_DELAYED_LOAD_DESCR.


***------------------------------------------------------------------------------------------------
*** Load CD - Validation
  select *
         into corresponding fields of table ME->T_CD_VALID
         from ZVCXI_XCD_TC201
        where GCODE eq ME->F_GCODE.

*** Load CD - Value
  select *
         into corresponding fields of table ME->T_CD_VALUE
         from ZVCXI_XCD_TC250
        where GCODE eq ME->F_GCODE.

*** Load CD - Exit
  select *
         into corresponding fields of table ME->T_CD_EXIT
         from ZVCXI_XCD_TC260
        where GCODE eq ME->F_GCODE.


***------------------------------------------------------------------------------------------------
*** Load all Condition Records of Condition Definition
  select GCORE into table LT_GCORE
               from ZVCXI_XCD_TD300
        where GCODE eq ME->F_GCODE.

*** Get Instance for Condition Record
  loop at LT_GCORE into LF_GCORE.
    move LF_GCORE to LF_GUID.
    ZCL_VCXI_XCDC_CONDREC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).
  endloop.

endmethod.
method SET_DESCR .

  field-symbols:  <S_DESCR> type /VCXI/CKX_S_DESCR.

*** Check of the Lock-Status of the Object
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

*** Set Description
  read table ME->T_DESCR assigning <S_DESCR> with key LANGU = IF_LANGU.
  if SY-SUBRC ne 0.
    append initial line to ME->T_DESCR assigning <S_DESCR>.
    move IF_LANGU to <S_DESCR>-LANGU.
  endif.
  move IF_DESCR   to <S_DESCR>-DESCR.

*** Raise Changed Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method SET_ID.

*** Check of the Lock-Status of the Object
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

***--------------------------------------------------------------------------------------
*** Check Authorization
  ZCL_VCXI_XCDC_CONDDEF=>CHECK_AUTH( IF_ACTVT = ZCL_VCXI_XCDC_CONDDEF=>C_ACTVT_EDIT
                                     IF_ID    = IF_ID ).


*** Continue only if changed
  check IF_ID ne ME->F_ICODE.

  move IF_ID to ME->F_ICODE.
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method SET_LOCK.

  data:  LR_CX_CKX type ref to /VCXI/CX_CKX.

  try.
***------------------------------------------------------------------
      if IF_LOCKED eq ABAP_TRUE.
***     Try to Set Write Lock
        call function 'ENQUEUE_EZVCXI_XCD_C200E'
          exporting
            GCODE          = ME->F_GCODE
          exceptions
            FOREIGN_LOCK   = 1
            SYSTEM_FAILURE = 2
            others         = 3.
        if SY-SUBRC ne 0.
          /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
        endif.

***------------------------------------------------------------------
      else.
***     Remove Write Lock
        call function 'DEQUEUE_EZVCXI_XCD_C200E'
          exporting
            GCODE = ME->F_GCODE.
      endif.

      move IF_LOCKED to ME->F_LOCKED.

    catch /VCXI/CX_CKX into LR_CX_CKX.
      ME->/VCXI/IF_CKX_OBJECT_LOCKING~DO_UNLOCK( ).
      raise exception LR_CX_CKX.
  endtry.

endmethod.
method SET_REGDVC.

  data:  LF_GUID type /VCXI/CKX_GUID.

***----------------------------------------------------------------------------
*** Check of the Lock-Status of the Object
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

***----------------------------------------------------------------------------
  if ME->R_REGDVC is not bound or
     IF_GREGE     ne ME->R_REGDVC->/VCXI/IF_CKX_OBJECT~GET_GUID( ).
*** Set new Registry Element DynamicVC
    move IF_GREGE to LF_GUID.
    ME->R_REGDVC ?= ZCL_VCXI_XCDC_REGDVC=>/VCXI/IF_CKX_OBJECT~GET_INSTANCE( IF_GUID = LF_GUID ).

*** Raise Changed Event
    raise event /VCXI/IF_CKX_OBJECT~CHANGED.
  endif.


endmethod.
method UPDATE_CD_EXIT.

  field-symbols: <S_CD_EXIT> type ZVCXI_XCDC_S_CD_EXIT.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_EXIT assigning <S_CD_EXIT> with key IEXIT = IS_CD_EXIT-IEXIT.

  if SY-SUBRC eq 0.
    move-corresponding IS_CD_EXIT to <S_CD_EXIT>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method UPDATE_CD_VALID.

  field-symbols: <S_CD_VALID> type ZVCXI_XCDC_S_CD_VALID.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALID assigning <S_CD_VALID> with key CMATN = IS_CD_VALID-CMATN
                                                            PRFID = IS_CD_VALID-PRFID
                                                            ICELM = IS_CD_VALID-ICELM.

  if SY-SUBRC eq 0.
    move-corresponding IS_CD_VALID to <S_CD_VALID>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
method UPDATE_CD_VALUE.

  field-symbols: <S_CD_VALUE> type ZVCXI_XCDC_S_CD_VALUE.

*** Make sure that obejct is locked
  ME->/VCXI/IF_CKX_OBJECT_LOCKING~CHECK_IS_LOCKED( ).

  read table ME->T_CD_VALUE assigning <S_CD_VALUE> with key ICOVA = IS_CD_VALUE-ICOVA.

  if SY-SUBRC eq 0.
    move-corresponding IS_CD_VALUE to <S_CD_VALUE>.
  endif.

***----------------------------------------------------------------------------
*** Raise Change Event
  raise event /VCXI/IF_CKX_OBJECT~CHANGED.

endmethod.
