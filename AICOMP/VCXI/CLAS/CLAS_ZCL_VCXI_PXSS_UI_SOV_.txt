
class ZCL_VCXI_PXSS_UI_SOV definition
  public
  inheriting from /VCXI/CL_VKSRU_CLSUI
  create public .

public section.

  data S_SOV_VIS type ZVCXI_PXSS_S_SOV_VIS .

  methods CONSTRUCTOR
    importing
      !IR_UIFW type ref to /VCXI/IF_VKSU_UIFW
      !IR_UIGATE type ref to /VCXI/CL_VKSRU_UIGATE
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods DO_PBO
    raising
      /VCXI/CX_CKX .
  methods DO_UPDATE_SOV_VIS
    importing
      !IS_SOV_VIS type ZVCXI_PXSS_S_SOV_VIS
    raising
      /VCXI/CX_CKX .
  methods SET_CURSOR
    raising
      /VCXI/CX_CKX .

  methods ACTIVATE
    redefinition .
  methods DEACTIVATE
    redefinition .
  methods DO_MODIFY_SCREEN
    redefinition .
  methods DO_USER_COMMAND
    redefinition .
protected section.

  types:
    begin of YS_CLSTR_BUFFER,
      R_GATE   type ref to /VCXI/CL_VKSR_GATE,
      NETOBJID type        NETOBJID,
    end   of YS_CLSTR_BUFFER .
  types:
    YT_CLSTR_BUFFER type standard table of YS_CLSTR_BUFFER .
  types:
    begin of YS_NODE_BUFFER,
      R_GATE   type ref to /VCXI/CL_VKSR_GATE,
      NETOBJID type        NETOBJID,
      CLSTR_ID type        NETOBJID,
    end   of YS_NODE_BUFFER .
  types:
    YT_NODE_BUFFER type standard table of YS_NODE_BUFFER .
  types:
    begin of YS_LINE_BUFFER,
      R_GATE_OUT type ref to  /VCXI/CL_VKSR_GATE,
      R_GATE_IN  type ref to  /VCXI/CL_VKSR_GATE,
      NETOBJID   type NETOBJID,
      FIX        type ABAP_BOOL,
    end   of YS_LINE_BUFFER .
  types:
    YT_LINE_BUFFER type standard table of YS_LINE_BUFFER .
  types:
    begin of YS_POPUP_MENU,
      ID    type          GRMODE,
      FCODE type          SYUCOMM,
      TEXT  type          NETVALSVAL,
*      R_ND  type ref to   ZCL_VCXI_F0SS_ND,
    end of YS_POPUP_MENU .
  types:
    YT_POPUP_MENU type standard table of YS_POPUP_MENU .

  constants C_BTYPE_BUTTON type TB_BTYPE value 0 ##NO_TEXT.
  constants C_BTYPE_MENU type TB_BTYPE value 2 ##NO_TEXT.
  constants C_BTYPE_SEPARATOR type TB_BTYPE value 3 ##NO_TEXT.
  constants C_FCODE_COLLAPSE type UI_FUNC value 'CCTO' ##NO_TEXT.
  constants C_FCODE_CONNECT type UI_FUNC value 'CCON' ##NO_TEXT.
  constants C_FCODE_DELETE type UI_FUNC value 'CDEL' ##NO_TEXT.
  constants C_FCODE_EXPAND type UI_FUNC value 'CECM' ##NO_TEXT.
  constants C_FCODE_MERGE type UI_FUNC value 'MERGE' ##NO_TEXT.
  constants C_FCODE_OVERVIEW type UI_FUNC value 'VCMP' ##NO_TEXT.
  constants C_FCODE_ZOOM_IN type UI_FUNC value 'OZIN' ##NO_TEXT.
  constants C_FCODE_ZOOM_OUT type UI_FUNC value 'OZOU' ##NO_TEXT.
  constants C_FL_CLSTR type NETVALSFL value 'C' ##NO_TEXT.
  constants C_OBJTY_CLSTR type NETOBJTYPE value 'c' ##NO_TEXT.
  constants C_OBJTY_LINE type NETOBJTYPE value 'l' ##NO_TEXT.
  constants C_OBJTY_NODE type NETOBJTYPE value 'n' ##NO_TEXT.
  constants C_STAT_WAIT type GRSTAT value '4' ##NO_TEXT.
  constants C_UC_ADD_XCOMP type UI_FUNC value 'ADD_XCOMP' ##NO_TEXT.
  constants C_UC_COLLAPSE type SYUCOMM value 'ACLUS5' ##NO_TEXT.
  constants C_UC_CONNECT type UI_FUNC value 'ACON' ##NO_TEXT.
  constants C_UC_DELETE type UI_FUNC value 'ADEL' ##NO_TEXT.
  constants C_UC_DOUBLE_CLICK type SYUCOMM value 'ADBCL' ##NO_TEXT.
  constants C_UC_DPOPUP type UI_FUNC value 'DPOPUP' ##NO_TEXT.
  constants C_UC_EXPAND type SYUCOMM value 'ACLUS0' ##NO_TEXT.
  constants C_UC_ICONT type UI_FUNC value 'ICONT' ##NO_TEXT.
  constants C_UC_INSERT type UI_FUNC value 'AINS' ##NO_TEXT.
  constants C_UC_MODIFY type UI_FUNC value 'AMOD' ##NO_TEXT.
  constants C_UC_POPUP type UI_FUNC value 'POPUP' ##NO_TEXT.
  constants C_UC_SELECT type UI_FUNC value 'SELECT' ##NO_TEXT.
  data F_ABAP_CMD type GRABAPCMD .
  data F_CURSOR type SCRFNAME .
  data F_LAST_UCOMM type SYUCOMM .
  data F_STAT type GRSTAT .
  data R_CONTAINER_GRAPHIC type ref to CL_GUI_CONTAINER .
  data R_CONTAINER_SPLITTER type ref to CL_GUI_SPLITTER_CONTAINER .
  data R_CONTAINER_TOOLBAR type ref to CL_GUI_CONTAINER .
  data R_NETCHART type ref to CL_GUI_NETCHART .
  data R_PR_SOV type ref to ZCL_VCXI_PXSS_PR_SOV .
  data R_TOOLBAR type ref to CL_GUI_TOOLBAR .
  data S_PROFILE type NET_PROFIL .
  data T_CLSTR_BUFFER type YT_CLSTR_BUFFER .
  data T_INODE type CNG_INODES_TAB .
  data T_INVAL type NET_NVALS_TAB .
  data T_LINE_BUFFER type YT_LINE_BUFFER .
  data T_NODE_BUFFER type YT_NODE_BUFFER .
  data T_POPUP_MENU type YT_POPUP_MENU .
  data T_PRVDR_DEF type /VCXI/VKSR_TT_PRVDR_DEF .
  data R_NETGRAPH type ref to ZCL_VCXI_XCS_NETGRAPH .

  methods ADD_AS_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_CLSTR type CNG_CLUSTR_TAB
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_AS_LINE
    importing
      !IR_GATE_OUT type ref to /VCXI/CL_VKSR_GATE
      !IR_GATE_IN type ref to /VCXI/CL_VKSR_GATE
      !IF_FIX type ABAP_BOOL
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_LINE type CNG_LINES_TAB
      !CT_LVAL type LVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_AS_NODE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    exporting
      !EF_NETOBJID type NETOBJID
    changing
      !CT_NODE type CNG_NODES_TAB
      !CT_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods ADD_NODE_TO_CLUSTER
    importing
      !IF_NETOBJID_CLSTR type NETOBJID
      !IF_NETOBJID_NODE type NETOBJID
    changing
      !CT_CVAL type CVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods CHECK_DELETION
    changing
      !CT_DELETION type NET_DELETE_TAB
      !CF_GR_MES type GRMES
    raising
      /VCXI/CX_CKX .
  methods DELETE_CLUSTER
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    changing
      !CT_DELETION type NET_DELETE_TAB
      !CT_CVAL type CVALS_TAB optional
    raising
      /VCXI/CX_CKX .
  methods GET_BUTTON
    exporting
      !ET_CTXMENU type TTB_BTNMNU
    returning
      value(RT_BUTTON) type TTB_BUTTON
    raising
      /VCXI/CX_CKX .
  methods GET_GATE_BY_NODEID
    importing
      !IF_NETOBJID type NETOBJID
    returning
      value(RR_GATE) type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods GET_GRAPHIC_CHANGES
    exporting
      !ET_CLSTR type CNG_CLUSTR_TAB
      !ET_CVAL type CVALS_TAB
      !ET_DELETION type NET_DELETE_TAB
      !ET_LINE type CNG_LINES_TAB
      !ET_LVAL type LVALS_TAB
      !ET_NODE type CNG_NODES_TAB
      !ET_NVAL type NVALS_TAB
    raising
      /VCXI/CX_CKX .
  methods GET_MENU_ADD_XCOMP
    returning
      value(RR_CTMENU) type ref to CL_CTMENU
    raising
      /VCXI/CX_CKX .
  methods GET_MENU_ICONT
    returning
      value(RR_CTMENU) type ref to CL_CTMENU
    raising
      /VCXI/CX_CKX .
  methods GET_NEXT_NETOBJID
    returning
      value(RF_NETOBJID) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods GET_NODEID_BY_GATE
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_NETOBJID) type NETOBJID
    raising
      /VCXI/CX_CKX .
  methods HANDLE_TOOLBAR_FCODE
    for event FUNCTION_SELECTED of CL_GUI_TOOLBAR
    importing
      !FCODE .
  methods HANDLE_UC_COLLAPSE
    importing
      !IT_NODE type CNG_NODES_TAB
      !IT_CLSTR type CNG_CLUSTR_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_DELETE
    importing
      !IT_DELETION type NET_DELETE_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_DOUBLE_CLICK
    importing
      !IT_CLSTR type CNG_CLUSTR_TAB
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_EXPAND
    importing
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_ICONT
    importing
      !IF_FCODE type UI_FUNC
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_ADD_XCOMP
    importing
      !IF_FCODE type UI_FUNC
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_POPUP_MENU
    importing
      !IT_NODE type CNG_NODES_TAB
    raising
      /VCXI/CX_CKX .
  methods HANDLE_UC_POPUP_SEL
    importing
      !IF_GR_MODE type GRMODE
    raising
      /VCXI/CX_CKX .
  methods INIT_CONTAINERS
    raising
      /VCXI/CX_CKX .
  methods INIT_NETCHART
    raising
      /VCXI/CX_CKX .
  methods INIT_PROFILE
    raising
      /VCXI/CX_CKX .
  methods INIT_TOOLBAR
    raising
      /VCXI/CX_CKX .
  methods INIT_VIS
    raising
      /VCXI/CX_CKX .
  methods IS_EXPANDED
    importing
      !IR_GATE type ref to /VCXI/CL_VKSR_GATE
    returning
      value(RF_RESULT) type ABAP_BOOL
    raising
      /VCXI/CX_CKX .
  methods IS_INLINE
    changing
      !CR_GATE type ref to /VCXI/CL_VKSR_GATE
    raising
      /VCXI/CX_CKX .
  methods REFRESH_GRAPHIC
    raising
      /VCXI/CX_CKX .
private section.

  data F_NETOBJID_LAST type NETOBJID .
endclass. "ZCL_VCXI_PXSS_UI_SOV definition
class ZCL_VCXI_PXSS_UI_SOV implementation.
  method ACTIVATE.

    SUPER->ACTIVATE( ).

****--------------------------------------------------------------------------------------
**** Initialize Profile for Net Graphic
*    ME->INIT_PROFILE( ).

***--------------------------------------------------------------------------------------
*** Bind UI to Dynpro
    call function 'ZVCXI_PXSS_UI_SOV_BIND'
      exporting
        IR_UI_SOV = ME
      importing
        ES_DYNP   = ME->S_DYNP.


*** Create Network Graphic
    create object ME->R_NETGRAPH
      exporting
        IR_GATE   = ME->R_GATE
        IR_UIGATE = ME->R_UIGATE.
*        IF_CONTAINER_NAME = '0100CC_NETGRAPH'.

  endmethod.
  method ADD_AS_CLUSTER.

    data: LF_NETTYPE type NETTYPE.
    data: LS_CVAL type ZVCXI_PXSS_S_ND_CVAL.
    data: LT_CVAL type ZVCXI_PXSS_TT_ND_CVAL.


*** Get Cluster Information if supported by Gate
    check IR_GATE->R_CLSPR is instance of ZIF_VCXI_PXSS_ND_CLUSTER.
    cast ZIF_VCXI_PXSS_ND_CLUSTER( IR_GATE->R_CLSPR )->GET_INFO( importing EF_NETTYPE = LF_NETTYPE
                                                                           ET_CVAL    = LT_CVAL ).

***------------------------------------------------------------------------------------------------
    if LINE_EXISTS( ME->T_CLSTR_BUFFER[ R_GATE = IR_GATE ] ).
      EF_NETOBJID = ME->T_CLSTR_BUFFER[ R_GATE = IR_GATE ]-NETOBJID.
***   Remove current Node values
      delete CT_CLSTR where ID eq EF_NETOBJID.
      delete CT_CVAL  where ID eq EF_NETOBJID.
    else.
***   Get next free Object ID and add to Buffer
      EF_NETOBJID = ME->GET_NEXT_NETOBJID( ).
      append value #( R_GATE   = IR_GATE
                      NETOBJID = EF_NETOBJID ) to ME->T_CLSTR_BUFFER.
***   Add to Graphic
      append value #( ID   = EF_NETOBJID
                      TYPE = LF_NETTYPE ) to CT_CLSTR.
    endif.

***------------------------------------------------------------------------------------------------
*** Set Cluster Attributes
    loop at LT_CVAL into LS_CVAL.
      append value #( ID  = EF_NETOBJID
                      FL  = LS_CVAL-FL
                      VAL = LS_CVAL-VAL ) to CT_CVAL.
    endloop.

  endmethod.
  method ADD_AS_LINE.

    field-symbols: <S_LINE_BUFFER> type        YS_LINE_BUFFER,
                   <S_LINE>        type        CNG_LINES,
                   <S_LVAL>        type        NET_LVALS.

    check IR_GATE_IN is bound and
          IR_GATE_OUT is bound.

*** Get next free Object ID
    move ME->GET_NEXT_NETOBJID( ) to EF_NETOBJID.

*** Add to Buffer
    append initial line to ME->T_LINE_BUFFER assigning <S_LINE_BUFFER>.
    move IR_GATE_OUT to <S_LINE_BUFFER>-R_GATE_OUT.
    move IR_GATE_IN  to <S_LINE_BUFFER>-R_GATE_IN.
    move EF_NETOBJID to <S_LINE_BUFFER>-NETOBJID.
    move IF_FIX      to <S_LINE_BUFFER>-FIX.

*** Add to Graphic
    append initial line to CT_LINE assigning <S_LINE>.
    move EF_NETOBJID                                     to <S_LINE>-ID.
    move ME->GET_NODEID_BY_GATE( IR_GATE = IR_GATE_OUT ) to <S_LINE>-PRE.
    move ME->GET_NODEID_BY_GATE( IR_GATE = IR_GATE_IN )  to <S_LINE>-SUC.
    move '0'                                             to <S_LINE>-TYPE.
    move 'AA'                                            to <S_LINE>-AB.

*** Description
    append initial line to CT_LVAL assigning <S_LVAL>.
    <S_LVAL>-ID    = EF_NETOBJID.
    <S_LVAL>-FL    = '0'.
    <S_LVAL>-VAL   = IR_GATE_OUT->R_CLSPR->GET_DESCR( ).

  endmethod.
  method ADD_AS_NODE.

    data: LF_NETTYPE type NETTYPE.
    data: LS_NVAL type ZVCXI_PXSS_S_ND_NVAL.
    data: LT_NVAL type ZVCXI_PXSS_TT_ND_NVAL.


*** Get Node Information if supported by Gate
    check IR_GATE->R_CLSPR is instance of ZIF_VCXI_PXSS_ND_NODE.
    cast ZIF_VCXI_PXSS_ND_NODE( IR_GATE->R_CLSPR )->GET_INFO( importing EF_NETTYPE = LF_NETTYPE
                                                                        ET_NVAL    = LT_NVAL ).

***------------------------------------------------------------------------------------------------
    if LINE_EXISTS( ME->T_NODE_BUFFER[ R_GATE = IR_GATE ] ).
      EF_NETOBJID = ME->T_NODE_BUFFER[ R_GATE = IR_GATE ]-NETOBJID.
***   Remove current Node values
      delete CT_NODE where ID eq EF_NETOBJID.
      delete CT_NVAL where ID eq EF_NETOBJID.
    else.
***   Get next free Object ID and add to Buffer
      EF_NETOBJID = ME->GET_NEXT_NETOBJID( ).
      append value #( R_GATE   = IR_GATE
                      NETOBJID = EF_NETOBJID ) to ME->T_NODE_BUFFER.
***   Add to Graphic
      append value #( ID   = EF_NETOBJID
                      TYPE = LF_NETTYPE ) to CT_NODE.
    endif.

***------------------------------------------------------------------------------------------------
*** Set Cluster Attributes
    loop at LT_NVAL into LS_NVAL.
      append value #( ID  = EF_NETOBJID
                      FL  = LS_NVAL-FL
                      VAL = LS_NVAL-VAL ) to CT_NVAL.
    endloop.

  endmethod.
  method ADD_NODE_TO_CLUSTER.

    break TBD.

*    data:           LR_ND           type ref to ZCL_VCXI_F0SS_ND,
*                    LR_GATE         type ref to /VCXI/CL_VKSR_GATE.
*    data:           LT_NVALS        type        NVALS_TAB.
*    field-symbols:  <S_CVAL>        type        NET_CVALS,
*                    <S_NVAL>        type        NET_NVALS,
*                    <S_NODE_BUFFER> type        YS_NODE_BUFFER.
*
**** Get Cluster Gate
*    LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = IF_NETOBJID_CLSTR ).
*
**** Get Cluster Information if supported by Gate
*    check IR_GATE->R_CLSPR is instance of ZIF_VCXI_PXSS_ND_CLUSTER.
*    cast ZIF_VCXI_PXSS_ND_CLUSTER( LR_GATE->R_CLSPR )->GET_INFO( importing EF_NETTYPE = LF_NETTYPE
*                                                                           ET_NVAL    = LT_NVAL ).
*
**** Add Cluster Attribute
*    append initial line to LT_NVALS assigning <S_NVAL>.
*    <S_NVAL>-ID    = IF_NETOBJID_CLSTR.
*    <S_NVAL>-FL    = 'A'.
*    <S_NVAL>-VAL   = IF_NETOBJID_NODE.
*
*    LR_ND->ADD_NVALS( IT_NVALS = LT_NVALS ).
*
**** Update Node Buffer table wth cluster
*    read table ME->T_NODE_BUFFER assigning <S_NODE_BUFFER> with key NETOBJID = IF_NETOBJID_NODE.
*    if SY-SUBRC eq 0.
*      move IF_NETOBJID_CLSTR to <S_NODE_BUFFER>-CLSTR_ID.
*    endif.
*
**** Add Node to Return Table
*    append initial line to CT_CVAL assigning <S_CVAL>.
*    move-corresponding <S_NVAL> to <S_CVAL>.

  endmethod.
  method CHECK_DELETION.

    data: LF_RETURN type I.
    data: LS_CVALS type NET_CVALS,
          LT_CVALS type CVALS_TAB.


***--------------------------------------------------------------------------------------
*** If Deletion table is empty check if a cluster is involved
    check LINES( CT_DELETION ) is initial.

*** Send Function Code Expand to NetGraphic
    ME->R_NETCHART->SET_FUNCTION_CODE( exporting FUNCTION_CODE = C_FCODE_EXPAND
                                       importing RETURN        = LF_RETURN ).
    if LF_RETURN ne 0.
      CL_GUI_CFW=>FLUSH( ).
      return.
    endif.

*** Process after Input for Graphic
    ME->R_NETCHART->GRAPHIC_PAI( importing GR_MES = CF_GR_MES
                                 changing  CVALS  = LT_CVALS ).

*** Check for Cluster values involved
    loop at LT_CVALS into LS_CVALS.
      insert value #( OBJ_TYPE = C_OBJTY_CLSTR
                      ID       = LS_CVALS-ID ) into table CT_DELETION.
    endloop.

    CF_GR_MES = C_UC_DELETE.

  endmethod.
  method CONSTRUCTOR.

    SUPER->CONSTRUCTOR( IR_UIFW   = IR_UIFW
                        IR_UIGATE = IR_UIGATE
                        IR_GATE   = IR_GATE ).

*** Assign th RP Class to the UI Class
    try.
        move IR_GATE->R_CLSPR ?to ME->R_PR_SOV.
      catch CX_SY_MOVE_CAST_ERROR.

***     UI ABAP Class is not compatible with PR ABAP Class.
        raise exception type /VCXI/CX_CKX
          exporting
            F_MSGTY = 'E'
            F_MSGID = '/VCXI/VKSR'
            F_MSGNO = '801'.
    endtry.

  endmethod.
  method DEACTIVATE.

    SUPER->DEACTIVATE( ).

***--------------------------------------------------------------------------------------
*** Free Network Graphic
    if ME->R_NETGRAPH is bound.
      ME->R_NETGRAPH->DO_FREE( ).
      clear ME->R_NETGRAPH.
    endif.

*    if ME->R_NETCHART is bound.
****   Clean up
*      ME->R_NETCHART->GRAPHIC_PAI( exporting AT_CONTROL_DESTROY = 'X' ).
*
****   Free Control
*      ME->R_NETCHART->FREE( ).
*      free: ME->R_NETCHART.
*      free: ME->F_STAT,
*            ME->T_CLSTR_BUFFER,
*            ME->T_NODE_BUFFER,
*            ME->T_LINE_BUFFER.
*    endif.
*
*    if ME->R_CONTAINER_GRAPHIC is bound.
****   Free Container for Graphic
*      ME->R_CONTAINER_GRAPHIC->FREE( ).
*      free: ME->R_CONTAINER_GRAPHIC.
*    endif.
*
*    if ME->R_CONTAINER_TOOLBAR is bound.
****   Free Container for Toolbar
*      ME->R_CONTAINER_TOOLBAR->FREE( ).
*      free: ME->R_CONTAINER_TOOLBAR.
*    endif.
*
*    if ME->R_CONTAINER_SPLITTER is bound.
****   Free Container for Splitter
*      ME->R_CONTAINER_SPLITTER->FREE( ).
*      free: ME->R_CONTAINER_SPLITTER.
*    endif.

  endmethod.
  method DELETE_CLUSTER.

    data: LF_NETOBJID type NETOBJID.
    data: LS_NODE_BUFFER type YS_NODE_BUFFER.


    check LINE_EXISTS( ME->T_CLSTR_BUFFER[ R_GATE = IR_GATE ] ).
    LF_NETOBJID = ME->T_CLSTR_BUFFER[ R_GATE = IR_GATE ]-NETOBJID.

***--------------------------------------------------------------------------------------
*** Add as Graphical Objects for Deletion
    append value #( OBJ_TYPE = C_OBJTY_CLSTR
                    ID       = LF_NETOBJID ) to CT_DELETION.

*** Remove Cluster from Buffer and its values
    delete ME->T_CLSTR_BUFFER where NETOBJID eq LF_NETOBJID.
    delete CT_CVAL            where ID       eq LF_NETOBJID.

***--------------------------------------------------------------------------------------
*** Delete all contained Nodes based on link to Cluster
    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER where CLSTR_ID eq LF_NETOBJID.

***   Mark for Deletion
      append value #( OBJ_TYPE = C_OBJTY_NODE
                      ID       = LS_NODE_BUFFER-NETOBJID ) to CT_DELETION.

***   Remove Node from Buffer
      delete ME->T_NODE_BUFFER.
    endloop.

  endmethod.
  method DO_MODIFY_SCREEN.

    data: LF_LOCKED type        /VCXI/CKX_LOCKED,
          LF_INUSE  type        /VCXI/VKSR_INUSE.


    try.
        SUPER->DO_MODIFY_SCREEN( IF_REPID = IF_REPID
                                 IF_DYNNR = IF_DYNNR ).

        LF_LOCKED = ME->R_GATE->IS_LOCKED( ).
        LF_INUSE  = ME->R_GATE->IS_INUSE( ).

***     Modify Scree using DynamicVC
        ZCL_VCXI_XCDR_SERVICE=>MODIFY_SCREEN( IR_GATE = ME->R_GATE ).

        loop at screen.
***       Lock everything if not in change mode
          if LF_LOCKED ne ABAP_TRUE or
             LF_INUSE  ne ABAP_TRUE.
            move 0 to SCREEN-INPUT.
          endif.
          modify screen.

***       Set Cursor
          if SCREEN-NAME eq ME->F_CURSOR.
            set cursor field ME->F_CURSOR.
          endif.
        endloop.

      catch /VCXI/CX_CKX into data(LR_CX_CKX).
        ME->R_GATE->ADD_MESSAGE_BY_CX_CKX( IR_CX_CKX = LR_CX_CKX ).
    endtry.

  endmethod.
  method DO_PBO.

***--------------------------------------------------------------------------------------
*** Initialize VIS
    ME->INIT_VIS( ).

***--------------------------------------------------------------------------------------
*** Initialize Containers: Splitter, Toolbar, Graphic
*    ME->INIT_CONTAINERS( ).

**** Initialize Toolbar
*    ME->INIT_TOOLBAR( ).
*
**** Initialize Netchart Object
*    ME->INIT_NETCHART( ).
*
****--------------------------------------------------------------------------------------
**** Refresh Graphic
*    ME->REFRESH_GRAPHIC( ).

***--------------------------------------------------------------------------------------
*** Refresh Network Graphic
    if ME->R_NETGRAPH is bound.
      move ABAP_TRUE to ME->R_NETGRAPH->F_REFRESH_REQ.
***   Refresh Network Graphic Component
      ME->R_NETGRAPH->REFRESH_NETGRAPH( ).
    endif.

  endmethod.
  method DO_UPDATE_SOV_VIS.

    check ME->R_PR_SOV is bound.

***--------------------------------------------------------------------------------------
*** Set Context ID
    if ME->S_SOV_VIS-ICONT ne IS_SOV_VIS-ICONT .
      ME->R_PR_SOV->SET_ICONT( IF_ICONT = IS_SOV_VIS-ICONT
                               IF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_USER ).
    endif.

  endmethod.
  method DO_USER_COMMAND.

    data: LF_RETURN  type I,
          LF_GR_MES  type GRMES,
          LF_GR_MODE type GRMODE,
          LF_UCOMM   type SYUCOMM.
    data: LT_CLSTR    type CNG_CLUSTR_TAB,
          LT_NODE     type CNG_NODES_TAB,
          LT_LINE     type CNG_LINES_TAB,
          LT_DELETION type NET_DELETE_TAB,
          LT_CVALS    type CVALS_TAB,
          LT_NVALS    type NVALS_TAB,
          LT_FVALS    type NVALS_TAB.

    SUPER->DO_USER_COMMAND( IF_UCOMM = IF_UCOMM ).

*    check ME->R_NETCHART is bound.
*
****--------------------------------------------------------------------------------------
**** Save incoming funtion code
*    move IF_UCOMM to LF_UCOMM.
*
**** Expand node => simulate doubleclick to get feedback from graphic
*    if LF_UCOMM eq C_FCODE_EXPAND or
*       LF_UCOMM eq C_FCODE_COLLAPSE or
*       LF_UCOMM eq C_FCODE_MERGE.
*
*      move: LF_UCOMM    to ME->F_LAST_UCOMM,
*            C_UC_MODIFY to LF_UCOMM.
*
****   Refresh Line Buffer to ensure a complete re-build
*      refresh ME->T_LINE_BUFFER.
*    endif.
*
****--------------------------------------------------------------------------------------
**** Send Function Code to Control if not Control- or Shell-Event
*    if IF_UCOMM(4) ne '%_GC' and
*       IF_UCOMM(4) ne '%_GS'.
*      ME->R_NETCHART->SET_FUNCTION_CODE( exporting FUNCTION_CODE = LF_UCOMM
*                                         importing RETURN        = LF_RETURN ).
*      if LF_RETURN ne 0.
*        CL_GUI_CFW=>FLUSH( ).
*        return.
*      endif.
*    endif.
*
****--------------------------------------------------------------------------------------
**** Process after Input for Graphic
*    ME->R_NETCHART->GRAPHIC_PAI( importing GR_MES       = LF_GR_MES
*                                           GR_MODE      = LF_GR_MODE
*                                 changing  DELETIONS    = LT_DELETION
*                                           FVALS        = LT_FVALS
*                                           LINES        = LT_LINE
*                                           NODES        = LT_NODE
*                                           NVALS        = LT_NVALS
*                                           CLUSTERS     = LT_CLSTR
*                                           CVALS        = LT_CVALS ).
*
**** Set Back to expand to handle it correctly
*    if ME->F_ABAP_CMD eq C_UC_SELECT.
*      move ME->F_LAST_UCOMM to LF_GR_MES.
*    endif.
*
*    clear: ME->F_ABAP_CMD.
*    move C_STAT_WAIT to ME->F_STAT.
*
****--------------------------------------------------------------------------------------
**** Process Action
*    case LF_GR_MES.
*
*****   Insert
**      when C_UC_INSERT.
**        ME->F_ABAP_CMD = LF_GR_MES.
**        ME->HANDLE_UC_INSERT( exporting IT_NODE = LT_NODE ).
**
*****   Connect
**      when C_UC_CONNECT.
**        ME->F_ABAP_CMD = LF_GR_MES.
**        ME->HANDLE_UC_CONNECT( exporting IT_LINE = LT_LINE ).
*
****   Delete
*      when C_UC_DELETE.
*        ME->CHECK_DELETION( changing CT_DELETION = LT_DELETION
*                                     CF_GR_MES   = LF_GR_MES ).
*
*        ME->F_ABAP_CMD = LF_GR_MES.
*        ME->HANDLE_UC_DELETE( exporting IT_DELETION = LT_DELETION ).
*
****   Double Click
*      when C_UC_DOUBLE_CLICK.
*        ME->F_ABAP_CMD = LF_GR_MES.
*        ME->HANDLE_UC_DOUBLE_CLICK( exporting IT_CLSTR = LT_CLSTR
*                                              IT_NODE  = LT_NODE ).
****   Expand Node/Cluster
*      when C_FCODE_EXPAND.
*        ME->F_ABAP_CMD = C_UC_MODIFY.
*        ME->HANDLE_UC_EXPAND( exporting IT_NODE  = LT_NODE ).
*
****   Collapse Cluster
*      when C_FCODE_COLLAPSE.
*        ME->F_ABAP_CMD = C_UC_MODIFY.
*        ME->HANDLE_UC_COLLAPSE( exporting IT_NODE  = LT_NODE
*                                          IT_CLSTR = LT_CLSTR ).
*
****   Simulate Modify
*      when C_UC_MODIFY.
*        ME->F_ABAP_CMD = C_UC_SELECT.
*
****     Refresh UI here to get in next run the "selected" node
*        ME->REFRESH_GRAPHIC( ).
*        ME->R_UIGATE->REFRESH_SCREEN( ).
*
****   Dynamic Popup
*      when C_UC_DPOPUP.
*        ME->F_ABAP_CMD = LF_GR_MES.
*        ME->HANDLE_UC_POPUP_MENU( exporting IT_NODE = LT_NODE ).
*
****   Popup Message
*      when C_UC_POPUP.
*        ME->F_ABAP_CMD = C_UC_MODIFY.
*        ME->HANDLE_UC_POPUP_SEL( exporting IF_GR_MODE = LF_GR_MODE ).
*
*****   Merge
**      when C_FCODE_MERGE.
**        ME->F_ABAP_CMD = C_UC_MODIFY.
**        ME->HANDLE_UC_MERGE_COMP( exporting IT_NODE  = LT_NODE
**                                            IT_CLSTR = LT_CLSTR ).
*
*    endcase.

  endmethod.
  method GET_BUTTON.

    data: LF_DISABLED type ABAP_BOOL.


***--------------------------------------------------------------------------------------
*** Get Disable-Status
    if ME->R_GATE->IS_LOCKED( ) ne ABAP_TRUE or
       ME->R_GATE->IS_INUSE( )  ne ABAP_TRUE.
      move ABAP_TRUE to LF_DISABLED.
    endif.

***--------------------------------------------------------------------------------------
*** Add Menu - Add Component
    append value #( FUNCTION  = C_UC_ADD_XCOMP
                    ICON      = ICON_CREATE
                    BUTN_TYPE = CNTB_BTYPE_MENU
                  ) to RT_BUTTON.
    append value #( FUNCTION = C_UC_ADD_XCOMP
                    CTMENU   = ME->GET_MENU_ADD_XCOMP( ) ) to ET_CTXMENU.

*** Add Button - Delete
    append value #( FUNCTION  = C_FCODE_DELETE
                    ICON      = ICON_DELETE
                    QUICKINFO = text-B03
                    BUTN_TYPE = C_BTYPE_BUTTON
                    DISABLED  = LF_DISABLED
                  ) to RT_BUTTON.

**** Add Button - Connect
*    append value #( FUNCTION  = C_FCODE_CONNECT
*                    ICON      = ICON_CONNECT
*                    BUTN_TYPE = C_BTYPE_BUTTON
*                    DISABLED  = LF_DISABLED
*                    TEXT      = text-B01
*                  ) to RT_BUTTON.
*
**** Add Button - Merge
*    append value #( FUNCTION  = C_FCODE_MERGE
*                    ICON      = ICON_PREVIOUS_HIERARCHY_LEVEL
*                    BUTN_TYPE = C_BTYPE_BUTTON
*                    DISABLED  = LF_DISABLED
*                    TEXT      = text-B02
*                  ) to RT_BUTTON.

***--------------------------------------------------------------------------------------
*** Add Separator
    append value #( BUTN_TYPE = C_BTYPE_SEPARATOR ) to RT_BUTTON.

***--------------------------------------------------------------------------------------
*** Add Button - Overview
    append value #( FUNCTION  = C_FCODE_OVERVIEW
                    ICON      = ICON_OVERVIEW
                    QUICKINFO = text-B11
                    BUTN_TYPE = C_BTYPE_BUTTON
                  ) to RT_BUTTON.

*** Add Button - Zoom In
    append value #( FUNCTION  = C_FCODE_ZOOM_IN
                    ICON      = ICON_ZOOM_IN
                    QUICKINFO = text-B12
                    BUTN_TYPE = C_BTYPE_BUTTON
                  ) to RT_BUTTON.

*** Add Button - Zoom Out
    append value #( FUNCTION  = C_FCODE_ZOOM_OUT
                    ICON      = ICON_ZOOM_OUT
                    QUICKINFO = text-B13
                    BUTN_TYPE = C_BTYPE_BUTTON
                  ) to RT_BUTTON.

**** Add Button - Collapse
*    append value #( FUNCTION  = C_FCODE_COLLAPSE
*                    ICON      = ICON_COLLAPSE_ALL
*                    QUICKINFO = text-B14
*                    BUTN_TYPE = C_BTYPE_BUTTON
*                  ) to RT_BUTTON.
*
**** Add Button - Expand
*    append value #( FUNCTION  = C_FCODE_EXPAND
*                    ICON      = ICON_EXPAND_ALL
*                    QUICKINFO = text-B15
*                    BUTN_TYPE = C_BTYPE_BUTTON
*                  ) to RT_BUTTON.

***--------------------------------------------------------------------------------------
*** Add Separator
    append value #( BUTN_TYPE = C_BTYPE_SEPARATOR ) to RT_BUTTON.

***--------------------------------------------------------------------------------------
*** Add Menu - Context
    append value #( FUNCTION  = C_UC_ICONT
                    BUTN_TYPE = CNTB_BTYPE_MENU
                    TEXT      = text-B21
                  ) to RT_BUTTON.
    append value #( FUNCTION = C_UC_ICONT
                    CTMENU   = ME->GET_MENU_ICONT( ) ) to ET_CTXMENU.

  endmethod.
  method GET_GATE_BY_NODEID.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER.

*** Search for Match as Cluster
    read table ME->T_CLSTR_BUFFER with key NETOBJID = IF_NETOBJID
                                  into LS_CLSTR_BUFFER.
    if SY-SUBRC eq 0.
      move LS_CLSTR_BUFFER-R_GATE to RR_GATE.
      return.
    endif.

*** Search for Match as Node
    read table ME->T_NODE_BUFFER with key NETOBJID = IF_NETOBJID
                                 into LS_NODE_BUFFER.
    if SY-SUBRC eq 0.
      move LS_NODE_BUFFER-R_GATE to RR_GATE.
      return.
    endif.

  endmethod.
  method GET_GRAPHIC_CHANGES.

    data: LF_OBJID_XCLST type NETOBJID,
          LF_OBJID_XNODE type NETOBJID.
    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER,
          LS_LINE_BUFFER  type YS_LINE_BUFFER,
          LS_SEQUENCE     type ZCL_VCXI_PXSS_PR_SPEC=>YS_SEQUENCE,
          LS_XCONR        type ZVCXI_PXSS_S_XCONR.
    data: LT_GATE_SPEC   type /VCXI/VKSR_TT_GATE,
          LT_GATE_XCOMP  type /VCXI/VKSR_TT_GATE,
          LT_SEQUENCE    type ZCL_VCXI_PXSS_PR_SPEC=>YT_SEQUENCE,
          LT_XCONR       type ZVCXI_PXSS_TT_XCONR,
          LT_LINE_BUFFER type YT_LINE_BUFFER.
    data: LR_GATE_SPEC  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_XCOMP type ref to /VCXI/CL_VKSR_GATE,
          LR_PR_SPEC    type ref to ZCL_VCXI_PXSS_PR_SPEC,
          LR_GATE_NEXT  type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_PREV  type ref to /VCXI/CL_VKSR_GATE.
    field-symbols: <S_DELETION>    type NET_DELETE,
                   <S_NODE_BUFFER> type YS_NODE_BUFFER.


***--------------------------------------------------------------------------------------
*** Get all Components
    LT_GATE_XCOMP = ME->R_GATE->GET_PRVDR( IF_IPRVT = ZCL_VCXI_PXSS_PR_XCOMP=>C_IPRVT_PX_XCOMP
                                           IF_INUSE = ABAP_TRUE ).

    loop at LT_GATE_XCOMP into LR_GATE_XCOMP.

***   If Component Node is expanded add it to Cluster Table
      if ME->IS_EXPANDED( exporting IR_GATE = LR_GATE_XCOMP ) eq ABAP_TRUE.


****   Get Specification Gate
*      LT_GATE_SPEC = LR_GATE_XCOMP->GET_PRVDR( IF_IPRVT = ZCL_VCXI_F0SS_PR_SPEC=>C_IPRVT_F0_SPEC
*                                               IF_INUSE = ABAP_TRUE ).
*
*      read table LT_GATE_SPEC into LR_GATE_SPEC index 1.
*      check LR_GATE_SPEC is bound.
*
*      move LR_GATE_SPEC->R_CLSPR ?to LR_PR_SPEC.
*      check LR_PR_SPEC is bound.
*
****   Get sequence of Gates inside the Specification
*      LT_SEQUENCE = LR_PR_SPEC->GET_SEQUENCE( ).
*
****   If Component Node is expanded add it to Cluster Table
*      if ME->IS_EXPANDED( exporting IR_GATE = LR_GATE_XCOMP ) eq ABAP_TRUE.
*
****     Identify new or changed Cluster
*        read table ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER
*                                      with key R_GATE = LR_GATE_XCOMP.
*
*        if SY-SUBRC is initial.
*          move LS_CLSTR_BUFFER-NETOBJID to LF_OBJID_XCLST.
*          ME->UPDATE_CLUSTER( exporting IF_NETOBJID = LS_CLSTR_BUFFER-NETOBJID
*                              changing  CT_CVAL     = ET_CVAL ).
*        else.
****       Add Gate as Cluster
*          ME->ADD_AS_CLUSTER( exporting IR_GATE     = LR_GATE_XCOMP
*                              importing EF_NETOBJID = LF_OBJID_XCLST
*                              changing  CT_CLSTR    = ET_CLSTR
*                                        CT_CVAL     = ET_CVAL ).
*        endif.
*
****     Remove old Node of Component
*        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
*                                      with key R_GATE = LR_GATE_XCOMP.
*        if SY-SUBRC eq 0.
*          append initial line to ET_DELETION assigning <S_DELETION>.
*          move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
*          move LS_NODE_BUFFER-NETOBJID  to <S_DELETION>-ID.
*
*          delete ME->T_NODE_BUFFER where R_GATE = LR_GATE_XCOMP.
*          delete ET_NVAL where ID eq LS_NODE_BUFFER-NETOBJID.
*        endif.
*
****     Handle all inner components
*        loop at LT_SEQUENCE into LS_SEQUENCE.
****       Add the Next Nodes
*          loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
*            clear LF_OBJID_XNODE.
*
****         Identify new or changed Node
*            read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
*                                          with key R_GATE = LR_GATE_NEXT.
*            if SY-SUBRC eq 0.
*              move LS_NODE_BUFFER-NETOBJID to LF_OBJID_XNODE.
*              ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
*                               changing  CT_NVAL     = ET_NVAL ).
*            else.
****           Add Gate as Node
*              ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_NEXT
*                               importing EF_NETOBJID = LF_OBJID_XNODE
*                               changing  CT_NODE     = ET_NODE
*                                         CT_NVAL     = ET_NVAL ).
*
****           Add Node to Cluster
*              ME->ADD_NODE_TO_CLUSTER( exporting IF_NETOBJID_CLSTR = LF_OBJID_XCLST
*                                                 IF_NETOBJID_NODE  = LF_OBJID_XNODE
*                                       changing  CT_CVAL           = ET_CVAL ).
*
*            endif.
*          endloop.
*
****       Add the Previous Nodes
*          loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.
*            clear LF_OBJID_XNODE.
*
****         Identify new or changed Node
*            read table ME->T_NODE_BUFFER into LS_NODE_BUFFER
*                                          with key R_GATE = LR_GATE_PREV.
*            if SY-SUBRC eq 0.
*              move LS_NODE_BUFFER-NETOBJID to LF_OBJID_XNODE.
*              ME->UPDATE_NODE( exporting IF_NETOBJID = LS_NODE_BUFFER-NETOBJID
*                               changing  CT_NVAL     = ET_NVAL ).
*            else.
****           Add Gate as Node
*              ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_PREV
*                               importing EF_NETOBJID = LF_OBJID_XNODE
*                               changing  CT_NODE     = ET_NODE
*                                         CT_NVAL     = ET_NVAL ).
*
****           Add Node to Cluster
*              ME->ADD_NODE_TO_CLUSTER( exporting IF_NETOBJID_CLSTR = LF_OBJID_XCLST
*                                                 IF_NETOBJID_NODE  = LF_OBJID_XNODE
*                                       changing  CT_CVAL           = ET_CVAL ).
*
*            endif.
*          endloop.
*        endloop.
*
****     Add Lines inside Component
*        loop at LT_SEQUENCE into LS_SEQUENCE.
*          loop at LS_SEQUENCE-T_GATE_NEXT into LR_GATE_NEXT.
*            loop at LS_SEQUENCE-T_GATE_PREV into LR_GATE_PREV.
*
****           Check Line isn't alread there
*              read table ME->T_LINE_BUFFER with key R_GATE_OUT = LR_GATE_NEXT
*                                                    R_GATE_IN  = LR_GATE_PREV
*                                           transporting no fields.
*              check SY-SUBRC is not initial.
*
****           Add Line
*              ME->ADD_AS_LINE( exporting IR_GATE_OUT = LR_GATE_NEXT
*                                         IR_GATE_IN  = LR_GATE_PREV
*                                         IF_FIX      = ABAP_TRUE
*                               changing  CT_LINE     = ET_LINE
*                                         CT_LVAL     = ET_LVAL ).
*            endloop.
*          endloop.
*        endloop.
*
      else.
***     Add/Update Component as Node
        ME->ADD_AS_NODE( exporting IR_GATE     = LR_GATE_XCOMP
                         importing EF_NETOBJID = LF_OBJID_XNODE
                         changing  CT_NODE     = ET_NODE
                                   CT_NVAL     = ET_NVAL ).

***     Remove old Cluster of Component
        ME->DELETE_CLUSTER( exporting IR_GATE     = LR_GATE_XCOMP
                            changing  CT_DELETION = ET_DELETION
                                      CT_CVAL     = ET_CVAL ).

      endif.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify deleted Nodes
    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
      check LS_NODE_BUFFER-R_GATE is not bound or
            LS_NODE_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_NODE             to <S_DELETION>-OBJ_TYPE.
      move LS_NODE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_NODE_BUFFER.
    endloop.

***--------------------------------------------------------------------------------------
*** Get Connections between Film Components
    LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

    move ME->T_LINE_BUFFER to LT_LINE_BUFFER.
    delete LT_LINE_BUFFER where FIX eq ABAP_TRUE.

*** Delete Connections with missing Gate
    delete LT_XCONR where R_GATE_OUT is not bound.
    delete LT_XCONR where R_GATE_IN  is not bound.

***--------------------------------------------------------------------------------------
*** Complete Re-Build of the lines
    loop at LT_XCONR into LS_XCONR.

***--------------------------------------------------------------------------------------
***   If the Gate is not found in any Buffer check if belongs to a Film Component
      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_OUT ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_OUT ).
      endif.

      if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR-R_GATE_IN ) is initial.
        ME->IS_INLINE( changing CR_GATE = LS_XCONR-R_GATE_IN ).
      endif.

***   Read info from Line Buffer table with the new gates (possible Film component)
      read table LT_LINE_BUFFER  with key R_GATE_OUT = LS_XCONR-R_GATE_OUT
                                          R_GATE_IN  = LS_XCONR-R_GATE_IN transporting no fields.
      if SY-SUBRC is initial.
        delete LT_LINE_BUFFER index SY-TABIX.
      else.
***     Add Line
        ME->ADD_AS_LINE( exporting IR_GATE_OUT = LS_XCONR-R_GATE_OUT
                                   IR_GATE_IN  = LS_XCONR-R_GATE_IN
                                   IF_FIX      = ABAP_FALSE
                         changing  CT_LINE     = ET_LINE
                                   CT_LVAL     = ET_LVAL ).
      endif.
    endloop.

*** Special case for deleting the lines when Cluster is seen as Node
    if ME->F_ABAP_CMD eq C_UC_DELETE.
***   Identify deleted Lines
      loop at LT_LINE_BUFFER into LS_LINE_BUFFER.

**      If node is not set to be freed
        check LS_LINE_BUFFER-R_GATE_IN->F_FREED is initial and
              LS_LINE_BUFFER-R_GATE_OUT->F_FREED is initial.

***     Only in the case when clusters are nodes
        check ME->IS_EXPANDED( exporting IR_GATE = LS_LINE_BUFFER-R_GATE_IN ) ne ABAP_TRUE.
        check ME->IS_EXPANDED( exporting IR_GATE = LS_LINE_BUFFER-R_GATE_OUT ) ne ABAP_TRUE.

***     Mark for Deletion
        append initial line to ET_DELETION assigning <S_DELETION>.
        move C_OBJTY_LINE            to <S_DELETION>-OBJ_TYPE.
        move LS_LINE_BUFFER-NETOBJID to <S_DELETION>-ID.

***     Remove from Buffer
        delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
      endloop.
    endif.

***--------------------------------------------------------------------------------------
*** Identify Deleted Clusters
    loop at ME->T_CLSTR_BUFFER into LS_CLSTR_BUFFER.
      check LS_CLSTR_BUFFER-R_GATE is not bound or
            LS_CLSTR_BUFFER-R_GATE->F_FREED eq ABAP_TRUE.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_CLSTR             to <S_DELETION>-OBJ_TYPE.
      move LS_CLSTR_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove it from Buffer
      delete ME->T_CLSTR_BUFFER.
    endloop.

***--------------------------------------------------------------------------------------
*** Identify Deleted Lines
    loop at ME->T_LINE_BUFFER into LS_LINE_BUFFER where FIX eq ABAP_UNDEFINED.

***   Mark for Deletion
      append initial line to ET_DELETION assigning <S_DELETION>.
      move C_OBJTY_LINE             to <S_DELETION>-OBJ_TYPE.
      move LS_LINE_BUFFER-NETOBJID  to <S_DELETION>-ID.

***   Remove from Buffer
      delete ME->T_LINE_BUFFER where NETOBJID eq LS_LINE_BUFFER-NETOBJID.
    endloop.

  endmethod.
  method GET_MENU_ADD_XCOMP .

    data: LF_DISABLED type ABAP_BOOL.
    data: LT_PRVDR_DEF type /VCXI/VKSR_TT_PRVDR_DEF,
          LT_GATE      type        /VCXI/VKSR_TT_GATE.
    field-symbols: <S_PRVDR_DEF> type /VCXI/VKSR_S_PRVDR_DEF.


    RR_CTMENU = new #( ).

*** Get Disable-Status
    if ME->R_GATE->IS_LOCKED( ) ne ABAP_TRUE or
       ME->R_GATE->IS_INUSE( )  ne ABAP_TRUE.
      move ABAP_TRUE to LF_DISABLED.
    endif.

*** Get possible Provider based on thier ID
    LT_PRVDR_DEF = ME->R_GATE->GET_PRVDR_DEF( IF_TPRVR = /VCXI/IF_VKSC_REGELMNT_PRVTY=>C_TPRVR_CHILD ).
    sort LT_PRVDR_DEF.
    delete adjacent duplicates from LT_PRVDR_DEF comparing ID.
    sort LT_PRVDR_DEF by DESCR.

    loop at LT_PRVDR_DEF assigning <S_PRVDR_DEF>.
      if LF_DISABLED ne ABAP_TRUE.
***     Get Gates of Provider
        LT_GATE = ME->R_GATE->GET_PRVDR( IF_IPRVT = <S_PRVDR_DEF>-IPRVT
                                         IF_INUSE = ABAP_TRUE ).

***     Reduece possible Provider based on aready active Provider with searched ID
        loop at LT_GATE transporting no fields
                        where TABLE_LINE->F_ID eq <S_PRVDR_DEF>-ID.
          <S_PRVDR_DEF>-QTYMA = <S_PRVDR_DEF>-QTYMA - 1.
          if <S_PRVDR_DEF>-QTYMA lt 1.
            exit.
          endif.
        endloop.
      else.
        <S_PRVDR_DEF>-QTYMA = 0. " Dont allow adding in Display Mode
      endif.

***   Add Function
      RR_CTMENU->ADD_FUNCTION( FCODE    = C_UC_ADD_XCOMP && '@' && <S_PRVDR_DEF>-ID
                               TEXT     = conv GUI_TEXT( <S_PRVDR_DEF>-DESCR )
                               DISABLED = switch #( <S_PRVDR_DEF>-QTYMA when 0 then ABAP_TRUE ) ).

    endloop.

  endmethod.
  method GET_MENU_ICONT.

    data: LF_DISABLED type ABAP_BOOL,
          LF_ICONT    type ZVCXI_P0S_ICONT.
    data: LS_DD07V type DD07V.
    data: LT_DD07V type table of DD07V.
    data: LR_CTMENU type ref to CL_CTMENU.


*** Get Disable-Status
    if ME->R_GATE->IS_LOCKED( ) ne ABAP_TRUE or
       ME->R_GATE->IS_INUSE( )  ne ABAP_TRUE.
      move ABAP_TRUE to LF_DISABLED.
    endif.

    RR_CTMENU = new #( ).

    call function 'DD_DOMVALUES_GET'
      exporting
        DOMNAME   = 'ZVCXI_P0S_ICONT'
        TEXT      = 'X'
      tables
        DD07V_TAB = LT_DD07V.
    LF_ICONT = ME->R_PR_SOV->ZIF_VCXI_PXSS_ICONT~GET_ICONT( ).
    loop at LT_DD07V into LS_DD07V.
      RR_CTMENU->ADD_FUNCTION( FCODE    = C_UC_ICONT && '@' && LS_DD07V-DOMVALUE_L
                               TEXT     = conv #( LS_DD07V-DDTEXT )
                               DISABLED = LF_DISABLED
                               CHECKED  = cond #( when LS_DD07V-DOMVALUE_L eq LF_ICONT then ABAP_TRUE else ABAP_FALSE ) ).
    endloop.

  endmethod.
  method GET_NEXT_NETOBJID.

    add 1 to ME->F_NETOBJID_LAST.
    condense ME->F_NETOBJID_LAST.

    move ME->F_NETOBJID_LAST to RF_NETOBJID.

  endmethod.
  method GET_NODEID_BY_GATE.

    data: LS_CLSTR_BUFFER type YS_CLSTR_BUFFER,
          LS_NODE_BUFFER  type YS_NODE_BUFFER.

*** Search for direct Match as Cluster
    read table ME->T_CLSTR_BUFFER with key R_GATE = IR_GATE
                                  into LS_CLSTR_BUFFER.
    if SY-SUBRC eq 0.
      move LS_CLSTR_BUFFER-NETOBJID to RF_NETOBJID.
      return.
    endif.

*** Search for direct Match as Node
    read table ME->T_NODE_BUFFER with key R_GATE = IR_GATE
                                 into LS_NODE_BUFFER.
    if SY-SUBRC eq 0.
      move LS_NODE_BUFFER-NETOBJID to RF_NETOBJID.
      return.
    endif.

  endmethod.
  method HANDLE_TOOLBAR_FCODE.

    data:  LR_CX_CKX type ref to /VCXI/CX_CKX.

    try.
        if FCODE cs C_UC_ICONT.
          ME->HANDLE_UC_ICONT( IF_FCODE = FCODE ).
        elseif FCODE cs C_UC_ADD_XCOMP.
          ME->HANDLE_UC_ADD_XCOMP( IF_FCODE = FCODE ).
        else.
***       Handle Function Code like normal User-Command
          ME->DO_USER_COMMAND( IF_UCOMM = FCODE ).
        endif.

      catch /VCXI/CX_CKX into LR_CX_CKX.
        LR_CX_CKX->SHOW_MESSAGE( ).
    endtry.

  endmethod.
  method HANDLE_UC_ADD_XCOMP.

    data: LR_GATE type ref to /VCXI/CL_VKSR_GATE.


    check SUBSTRING_BEFORE( VAL = IF_FCODE SUB = '@' ) eq C_UC_ADD_XCOMP.

***--------------------------------------------------------------------------------------
*** Create Child based on ID provided after generic User Command
    LR_GATE = ME->R_GATE->CREATE_ELEMENT( IF_ID = SUBSTRING_AFTER( VAL = IF_FCODE SUB = '@' ) ).
    if LR_GATE is bound.
***   Set In Use
      if LR_GATE->IS_INUSE( ) eq ABAP_FALSE.
        LR_GATE->SET_INUSE( IF_INUSE = ABAP_TRUE ).
      endif.
    endif.

***--------------------------------------------------------------------------------------
*** Update Toolbar
    ME->R_TOOLBAR->SET_STATIC_CTXMENU( exporting  FCODE                = C_UC_ADD_XCOMP
                                                  CTXMENU              = ME->GET_MENU_ADD_XCOMP( )
                                       exceptions CTMENU_ERROR         = 1
                                                  CNTL_ERROR           = 2
                                                  CNTB_ERROR_PARAMETER = 3 ).
*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_COLLAPSE.

*    data:         LS_CLSTR          type CNG_CLUSTR,
*                  LS_NODES          type CNG_NODES,
*                  LS_NODE_BUFFER    type YS_NODE_BUFFER.
*    data:         LR_GATE           type ref to /VCXI/CL_VKSR_GATE,
*                  LR_ND             type ref to ZCL_VCXI_F0SS_ND.
*    field-symbols: <S_CLSTR_BUFFER> type YS_CLSTR_BUFFER.
*
****--------------------------------------------------------------------------------------
**** Check whether all or only one selected Cluster should be collapsed
*    if LINES( IT_NODE ) is not initial.
****   Get Gate for Cluster
*      loop at IT_NODE into LS_NODES.
*
*        read table ME->T_NODE_BUFFER into LS_NODE_BUFFER with key NETOBJID = LS_NODES-ID.
*        check LS_NODE_BUFFER-CLSTR_ID is not initial.
*
*        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE_BUFFER-CLSTR_ID ) to LR_GATE.
*
*        check LR_GATE is bound.
****--------------------------------------------------------------------------------------
****     Set Collapse Cluster Attribute
*        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                IR_GATE   = LR_GATE ).
*        check LR_ND is bound.
*
****     Set Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).
*
*      endloop.
*
*    elseif LINES( IT_CLSTR ) is not initial.
*
*      loop at IT_CLSTR into LS_CLSTR.
*        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_CLSTR-ID ) to LR_GATE.
*
*        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                IR_GATE   = LR_GATE ).
*        check LR_ND is bound.
*
****     Set Expand Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).
*
*      endloop.
*
*    else.
****   Collapse all Clusters
*      loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
*        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                IR_GATE   = <S_CLSTR_BUFFER>-R_GATE ).
*        check LR_ND is bound.
*
****     Set Expand Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_FALSE ).
*      endloop.
*
*    endif.
*
****--------------------------------------------------------------------------------------
**** Refresh UI
*    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_DELETE.

    data: LF_NETOBJID    type        NETOBJID.
    data: LS_DELETION    type        NET_DELETE,
          LS_LINE_BUFFER type        YS_LINE_BUFFER,
          LS_XCONR       type        ZVCXI_PXSS_S_XCONR,
          LS_XCONR_READ  type        ZVCXI_PXSS_S_XCONR.
*          LS_NVALS       type        ZCL_VCXI_F0SS_ND=>YS_NVALS.
    data: LT_XCONR_DEL type        ZVCXI_PXSS_TT_XCONR,
          LT_XCONR     type        ZVCXI_PXSS_TT_XCONR,
          LT_GATE_FREE type        /VCXI/VKSR_TT_GATE.
    data: LR_GATE      type ref to /VCXI/CL_VKSR_GATE,
          LR_GATE_NODE type ref to /VCXI/CL_VKSR_GATE.

***--------------------------------------------------------------------------------------
*** Process Deletion Requests
    loop at IT_DELETION into LS_DELETION.

      case LS_DELETION-OBJ_TYPE.
***     Nodes
        when C_OBJTY_NODE.
          LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_DELETION-ID ).
          check LR_GATE is bound.

****       Delete only if it`s not Input/Output
*          check ME->IS_INOUT( IR_GATE = LR_GATE ) ne ABAP_TRUE.
          append LR_GATE to LT_GATE_FREE.

***     Lines
        when C_OBJTY_LINE.
          read table ME->T_LINE_BUFFER into LS_LINE_BUFFER
                                       with key NETOBJID = LS_DELETION-ID.
          check SY-SUBRC is initial.

          clear: LS_XCONR.
          move LS_LINE_BUFFER-R_GATE_IN   to LS_XCONR-R_GATE_IN.
          move LS_LINE_BUFFER-R_GATE_OUT  to LS_XCONR-R_GATE_OUT.
          append LS_XCONR to LT_XCONR_DEL.

***     Cluster
        when C_OBJTY_CLSTR.
          LR_GATE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_DELETION-ID ).
          if LR_GATE is bound.
            append LR_GATE to LT_GATE_FREE.
          endif.

****       Get Node instance for Gate
*          LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                  IR_GATE   = LR_GATE ).
*
****       Delete contained Nodes
*          loop at LR_ND->T_NVALS into LS_NVALS where FL eq 'A'.
*
*            move LS_NVALS-VAL to LF_NETOBJID.
*            LR_GATE_NODE = ME->GET_GATE_BY_NODEID( IF_NETOBJID = LF_NETOBJID ).
*            if LR_GATE_NODE is bound.
*              append LR_GATE_NODE to LT_GATE_FREE.
*            endif.
*
*          endloop.
      endcase.
    endloop.

***--------------------------------------------------------------------------------------
*** Delete Connections collectively
    if LT_XCONR_DEL is not initial.
      LT_XCONR = ME->R_PR_SOV->GET_XCONR( ).

      loop at LT_XCONR into LS_XCONR.
        move LS_XCONR to LS_XCONR_READ.

***     If the Gate is not found in any Buffer check if belongs to a Component
        if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR_READ-R_GATE_OUT ) is initial.
          ME->IS_INLINE( changing CR_GATE = LS_XCONR_READ-R_GATE_OUT ).
        endif.

        if ME->GET_NODEID_BY_GATE( IR_GATE = LS_XCONR_READ-R_GATE_IN ) is initial.
          ME->IS_INLINE( changing CR_GATE = LS_XCONR_READ-R_GATE_IN ).
        endif.

        read table LT_XCONR_DEL with key TABLE_LINE = LS_XCONR_READ
                                transporting no fields.
        if SY-SUBRC eq 0.
          delete LT_XCONR_DEL index SY-TABIX.
          delete LT_XCONR.
          append LS_XCONR-R_GATE_OUT to LT_GATE_FREE.
          append LS_XCONR-R_GATE_IN  to LT_GATE_FREE.
        endif.
      endloop.

      ME->R_PR_SOV->SET_XCONR( IT_XCONR = LT_XCONR ).
    endif.

***--------------------------------------------------------------------------------------
*** Free all collected Gates
    loop at LT_GATE_FREE into LR_GATE.
      LR_GATE->DO_FREE( ).
    endloop.

***--------------------------------------------------------------------------------------
*** Refresh UI
    ME->REFRESH_GRAPHIC( ).
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_DOUBLE_CLICK.

    data: LS_CLSTR type        CNG_CLUSTR,
          LS_NODE  type        CNG_NODES.
    data: LR_GATE  type ref to /VCXI/CL_VKSR_GATE,
          LR_CLSTI type ref to /VCXI/CL_VKSRU_CLSTI.

***--------------------------------------------------------------------------------------
*** Double Click on Cluster
    loop at IT_CLSTR into LS_CLSTR.
      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_CLSTR-ID ) to LR_GATE.
***   Stop at first
      if LR_GATE is bound.
        exit.
      endif.
    endloop.

*** Double Click on Node
    loop at IT_NODE into LS_NODE.
      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.
***   Stop at first
      if LR_GATE is bound.
        exit.
      endif.
    endloop.

***--------------------------------------------------------------------------------------
    check LR_GATE is bound.

*** Open Tree Node
    ME->R_UIGATE->EXPAND_TREE_NODE( IF_GATKY = LR_GATE->F_GATKY ).

*** Highlight Node
    ME->R_UIGATE->SELECT_TREE_NODE( IF_GATKY = LR_GATE->F_GATKY ).

*** Delegate Double Click to Tree Item Class
    LR_CLSTI = ME->R_UIGATE->GET_CLSTI( IR_GATE = LR_GATE ).
    check LR_CLSTI is bound.
    LR_CLSTI->/VCXI/IF_VKSU_TI_EVENT~HANDLE_DOUBLE_CLICK( ).

  endmethod.
  method HANDLE_UC_EXPAND.

*    data:          LS_NODE          type        CNG_NODES.
*    data:          LR_GATE          type ref to /VCXI/CL_VKSR_GATE,
*                   LR_ND            type ref to ZCL_VCXI_F0SS_ND.
*    field-symbols: <S_CLSTR_BUFFER> type        YS_CLSTR_BUFFER,
*                   <S_NODE_BUFFER>  type        YS_NODE_BUFFER.
*
****--------------------------------------------------------------------------------------
**** Check whether all or only one selected Cluster should be collapsed
*    if LINES( IT_NODE ) is not initial.
*
****   Get Gate for Node
*      loop at IT_NODE into LS_NODE.
*        move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.
*
*        check LR_GATE is bound.
*
****--------------------------------------------------------------------------------------
****     Set Collapse Cluster Attribute
*        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                IR_GATE   = LR_GATE ).
*        check LR_ND is bound.
*
****     Set Expand Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
*      endloop.
*
*    else.
****   Expand all clusters
*      loop at ME->T_CLSTR_BUFFER assigning <S_CLSTR_BUFFER>.
*        LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                IR_GATE   = <S_CLSTR_BUFFER>-R_GATE ).
*        check LR_ND is bound.
*
****     Set Expand Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
*      endloop.
*
****   Expand all current nodes
*      loop at ME->T_NODE_BUFFER assigning <S_NODE_BUFFER>.
*        try.
*            LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                                    IR_GATE   = <S_NODE_BUFFER>-R_GATE ).
*          catch CX_SY_MOVE_CAST_ERROR.
*            clear: LR_ND.
*        endtry.
*
*        check LR_ND is bound.
*
****     Set Expand Value
*        LR_ND->SET_EXPAND( IF_EXPAND = ABAP_TRUE ).
*      endloop.
*
*    endif.
*
****--------------------------------------------------------------------------------------
**** Refresh UI
*    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_ICONT.

    check SUBSTRING_BEFORE( VAL = IF_FCODE SUB = '@' ) eq C_UC_ICONT.

*** Set Context
    ME->R_PR_SOV->ZIF_VCXI_PXSS_ICONT~SET_ICONT( IF_ICONT = SUBSTRING_AFTER( VAL = IF_FCODE SUB = '@' )
                                                 IF_SETBY = /VCXI/CL_VKSR_GATE=>C_SETBY_USER ).

*** Update Toolbar
    ME->R_TOOLBAR->SET_STATIC_CTXMENU( exporting  FCODE                = C_UC_ICONT
                                                  CTXMENU              = ME->GET_MENU_ICONT( )
                                       exceptions CTMENU_ERROR         = 1
                                                  CNTL_ERROR           = 2
                                                  CNTB_ERROR_PARAMETER = 3 ).
*** Refresh UI
    ME->R_UIGATE->REFRESH_SCREEN( ).

  endmethod.
  method HANDLE_UC_POPUP_MENU.

*    data: LF_ID           type          GRMODE,
*          LF_ABCDE        type          SYABCDE,
*          LF_POS          type          I.
*    data: LS_NODE         type          CNG_NODES,
*          LS_FCODE        type          ZCL_VCXI_F0SS_ND=>YS_FCODE,
*          LS_POPUP_MENU   type          YS_POPUP_MENU.
*    data: LT_FCODE        type          ZCL_VCXI_F0SS_ND=>YT_FCODE.
*    data: LR_GATE         type ref to   /VCXI/CL_VKSR_GATE,
*          LR_ND           type ref to   ZCL_VCXI_F0SS_ND.
*    field-symbols:  <S_POPUP_MENU>  type          YS_POPUP_MENU.
*
*    refresh: ME->T_POPUP_MENU.
*
****--------------------------------------------------------------------------------------
**** Right Click on Node
*    loop at IT_NODE into LS_NODE.
*      move ME->GET_GATE_BY_NODEID( IF_NETOBJID = LS_NODE-ID ) to LR_GATE.
*
****   Stop at first
*      if LR_GATE is bound.
*        exit.
*      endif.
*    endloop.
*
*    check LR_GATE is bound.
*
****--------------------------------------------------------------------------------------
**** Get Node Instance
*    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                            IR_GATE   = LR_GATE ).
*    check LR_ND is bound.
*    refresh: LT_FCODE.
*
**** Get Node Popup Menu Entries
*    LR_ND->GET_FCODE( importing ET_FCODE = LT_FCODE ).
*
*    move SY-ABCDE to LF_ABCDE.
*
**** Add Cluster Popup Menu Entries
*    loop at LT_FCODE into LS_FCODE.
*      add 1 to LF_POS.
*      move LF_ABCDE+LF_POS(1) to LF_ID.
*
*      append initial line to ME->T_POPUP_MENU assigning <S_POPUP_MENU>.
*      move LF_ID          to <S_POPUP_MENU>-ID.
*      move LS_FCODE-FCODE to <S_POPUP_MENU>-FCODE.
*      move LS_FCODE-TEXT  to <S_POPUP_MENU>-TEXT.
*      move LR_ND          to <S_POPUP_MENU>-R_ND.
*    endloop.
*
****--------------------------------------------------------------------------------------
**** Create Popup Menu Entries based on generated entries
*    loop at ME->T_POPUP_MENU into LS_POPUP_MENU.
****   Set Popup Menu Entry
*      call function 'CNET_SET_POPUP_DATA'
*        exporting
*          OBJECT = 'U3'
*          ID     = LS_POPUP_MENU-ID
*          TEXT   = LS_POPUP_MENU-TEXT
*        exceptions
*          others = 0.
*    endloop.
*
  endmethod.
  method HANDLE_UC_POPUP_SEL.

    break TBD.

*    data: LS_POPUP_MENU  type        YS_POPUP_MENU.
*    data: LR_PARENT_GATE type ref to /VCXI/CL_VKSR_GATE.
*    field-symbols: <S_LINE_BUFFER> type YS_LINE_BUFFER.
*
****--------------------------------------------------------------------------------------
**** Read Popup Menu Table with selected item id
*    read table ME->T_POPUP_MENU into LS_POPUP_MENU with key ID = IF_GR_MODE.
*
*    check SY-SUBRC            is initial and
*          LS_POPUP_MENU-R_ND  is bound.

*    case LS_POPUP_MENU-FCODE.
*      when ZCL_VCXI_F0SS_ND_CSTEP=>C_UC_SPLIT.
*****     Special handling for Split option
**        ME->HANDLE_UC_SPLIT_COMP( exporting IS_POPUP_MENU = LS_POPUP_MENU ).
**
**      when ZCL_VCXI_F0SS_ND_CSTEP=>C_UC_MERGE.
*****     Special handling for Merge option
**        ME->HANDLE_UC_MERGE_COMP( exporting IS_POPUP_MENU = LS_POPUP_MENU ).
**
*      when others.
****     Handle Popup Menu Selection
*        LS_POPUP_MENU-R_ND->HANDLE_UC_POPUP_SEL( IF_FCODE = LS_POPUP_MENU-FCODE ).
*        ME->R_UIGATE->REFRESH_SCREEN( ).
*
****     Only if it`s a conversion in place
*        check LS_POPUP_MENU-FCODE cp '*CSTEP*'.
*
*        move LS_POPUP_MENU-R_ND->GET_GATE( ) to LR_PARENT_GATE.
*        loop at ME->T_LINE_BUFFER assigning <S_LINE_BUFFER> where R_GATE_OUT eq LR_PARENT_GATE.
*          check <S_LINE_BUFFER>-R_GATE_IN is bound.
*          move ABAP_UNDEFINED to <S_LINE_BUFFER>-FIX.
*        endloop.
*
*    endcase.

  endmethod.
  method INIT_CONTAINERS.

    check ME->R_CONTAINER_SPLITTER is not bound.


*** Graphic component is not supported by SAP for Mac OSX and WebGUI
    check CL_GUI_FRONTEND_SERVICES=>GET_PLATFORM( ) ne CL_GUI_FRONTEND_SERVICES=>PLATFORM_MACOSX and
          CL_GUI_CONTROL=>WWW_ACTIVE                ne ABAP_TRUE.


***--------------------------------------------------------------------------------------
*** Create Splitter
    create object ME->R_CONTAINER_SPLITTER
      exporting
        PARENT            = CL_GUI_CONTAINER=>DEFAULT_SCREEN
        ROWS              = 2
        COLUMNS           = 1
      exceptions
        CNTL_ERROR        = 1
        CNTL_SYSTEM_ERROR = 2
        others            = 3.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Get Toolbar Container
    ME->R_CONTAINER_TOOLBAR = ME->R_CONTAINER_SPLITTER->GET_CONTAINER( ROW       = 1
                                                                       COLUMN    = 1 ).

*** Get Graphic Container
    ME->R_CONTAINER_GRAPHIC = ME->R_CONTAINER_SPLITTER->GET_CONTAINER( ROW       = 2
                                                                       COLUMN    = 1 ).

***--------------------------------------------------------------------------------------
*** Make Row Absolute
    ME->R_CONTAINER_SPLITTER->SET_ROW_MODE( MODE = CL_GUI_SPLITTER_CONTAINER=>MODE_ABSOLUTE ).

*** Set Row Height
    ME->R_CONTAINER_SPLITTER->SET_ROW_HEIGHT( exporting  ID                = 1
                                                         HEIGHT            = CL_GUI_CFW=>COMPUTE_METRIC_FROM_DYNP( METRIC = CL_GUI_CONTROL=>METRIC_PIXEL
                                                                                                                   X_OR_Y = 'Y'
                                                                                                                   IN     = 1 ) " reserve space for supplied number of rows
                                              exceptions CNTL_ERROR        = 1
                                                         CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Make it not movable
    ME->R_CONTAINER_SPLITTER->SET_ROW_SASH( exporting  ID                = 1
                                                       TYPE              = CL_GUI_SPLITTER_CONTAINER=>TYPE_MOVABLE
                                                       VALUE             = CL_GUI_SPLITTER_CONTAINER=>FALSE
                                            exceptions CNTL_ERROR        = 1
                                                       CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Make Separator not visible
    ME->R_CONTAINER_SPLITTER->SET_ROW_SASH( exporting  ID                = 1
                                                       TYPE              = CL_GUI_SPLITTER_CONTAINER=>TYPE_SASHVISIBLE
                                                       VALUE             = CL_GUI_SPLITTER_CONTAINER=>FALSE
                                            exceptions CNTL_ERROR        = 1
                                                       CNTL_SYSTEM_ERROR = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method INIT_NETCHART.

    check ME->R_NETCHART is not bound and
          ME->R_CONTAINER_GRAPHIC is bound.

*** Graphic component is not supported by SAP for Mac OSX
    check CL_GUI_FRONTEND_SERVICES=>GET_PLATFORM( ) ne CL_GUI_FRONTEND_SERVICES=>PLATFORM_MACOSX.

*** Create Netchart Object
    create object ME->R_NETCHART
      exporting
        PARENT                    = ME->R_CONTAINER_GRAPHIC
      exceptions
        CNTL_ERROR                = 1
        CNTL_SYSTEM_ERROR         = 2
        ILLEGAL_EVENT_COMBINATION = 3
        CREATE_ERROR              = 4
        others                    = 5.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method INIT_PROFILE.

    break HARDCODED_VALUES.
    move: 'ZF0'                to ME->S_PROFILE-GRUPPE,
          '000000000001'       to ME->S_PROFILE-NAME,
          '1'                  to ME->S_PROFILE-INDEX.

  endmethod.
  method INIT_TOOLBAR.

    data: LF_LOCKED   type /VCXI/CKX_LOCKED,
          LF_INUSE    type /VCXI/VKSR_INUSE,
          LF_DISABLED type ABAP_BOOL.
    data: LT_CTXMENU  type TTB_BTNMNU.

    check ME->R_TOOLBAR is not bound and
          ME->R_CONTAINER_TOOLBAR is bound.

***--------------------------------------------------------------------------------------
*** Create Toolbar
    create object ME->R_TOOLBAR
      exporting
        PARENT             = ME->R_CONTAINER_TOOLBAR
      exceptions
        CNTL_INSTALL_ERROR = 1
        CNTL_ERROR         = 2
        CNTB_WRONG_VERSION = 3
        others             = 4.
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

***--------------------------------------------------------------------------------------
*** Set Registered Events
    ME->R_TOOLBAR->SET_REGISTERED_EVENTS( exporting
                                            EVENTS                    = value #( ( EVENTID = CL_GUI_TOOLBAR=>M_ID_FUNCTION_SELECTED ) )
                                          exceptions
                                            CNTL_ERROR                = 1
                                            CNTL_SYSTEM_ERROR         = 2
                                            ILLEGAL_EVENT_COMBINATION = 3
                                            others                    = 4 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

*** Set Event Handler
    set handler ME->HANDLE_TOOLBAR_FCODE    for ME->R_TOOLBAR.

***--------------------------------------------------------------------------------------
*** Adds a List of Pushbuttons
    ME->R_TOOLBAR->ADD_BUTTON_GROUP( exporting  DATA_TABLE       = ME->GET_BUTTON( importing ET_CTXMENU = LT_CTXMENU )
                                     exceptions DP_ERROR         = 1
                                                CNTB_ERROR_FCODE = 2 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

    ME->R_TOOLBAR->ASSIGN_STATIC_CTXMENU_TABLE( exporting  TABLE_CTXMENU        = LT_CTXMENU
                                                exceptions CNTL_ERROR           = 1
                                                           CNTB_ERROR_PARAMETER = 2
                                                           DP_ERROR             = 3 ).
    if SY-SUBRC ne 0.
      /VCXI/CX_CKX=>RAISE_CKX_BY_SY( ).
    endif.

  endmethod.
  method INIT_VIS.

    free: ME->S_SOV_VIS.
    check ME->R_PR_SOV is bound.

*** Get Context ID
    ME->S_SOV_VIS-ICONT = ME->R_PR_SOV->GET_ICONT( importing EF_DESCR = ME->S_SOV_VIS-ICONT_DESCR ).

  endmethod.
  method IS_EXPANDED.

    break TBD.
*    data LR_ND type ref to ZCL_VCXI_F0SS_ND.
*
*    check IR_GATE is bound.
*
**** Get Node Instance
*    LR_ND = ZCL_VCXI_F0SS_ND=>GET_INSTANCE( IR_UIGATE = ME->R_UIGATE
*                                            IR_GATE   = IR_GATE ).
*    check LR_ND is bound.
*    move LR_ND->F_EXPANDED to RF_RESULT.

  endmethod.
  method IS_INLINE.

    data: LS_NODE_BUFFER  type YS_NODE_BUFFER.

    loop at ME->T_NODE_BUFFER into LS_NODE_BUFFER.
***   Check if the Gate is inline with a Film Component
      check LS_NODE_BUFFER-R_GATE->IS_IN_LINE( IR_GATE = CR_GATE ) eq ABAP_TRUE.
      move LS_NODE_BUFFER-R_GATE to CR_GATE.
      exit.
    endloop.

  endmethod.
  method REFRESH_GRAPHIC.

    data: LT_CLSTR    type CNG_CLUSTR_TAB,
          LT_CVAL     type CVALS_TAB,
          LT_NODE     type CNG_NODES_TAB,
          LT_NVAL     type NVALS_TAB,
          LT_LINE     type CNG_LINES_TAB,
          LT_LVAL     type LVALS_TAB,
          LT_DELETION type NET_DELETE_TAB.

    check ME->R_NETCHART is bound.

*** Get Changes to the Graphic
    ME->GET_GRAPHIC_CHANGES( importing ET_CLSTR    = LT_CLSTR
                                       ET_CVAL     = LT_CVAL
                                       ET_NODE     = LT_NODE
                                       ET_NVAL     = LT_NVAL
                                       ET_LINE     = LT_LINE
                                       ET_LVAL     = LT_LVAL
                                       ET_DELETION = LT_DELETION ).

*** Add Initial Values to Node Values
    append lines of ME->T_INVAL to LT_NVAL.

*** Set user-defined values for nodes to display icons
    perform SET_USER_FVALS in program SAPLCNET using '0' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '1' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '2' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '3' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '4' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '5' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '6' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '7' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '8' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using '9' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'A' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'B' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'C' 'b' 't' '9'.
    perform SET_USER_FVALS in program SAPLCNET using 'D' 'b' 't' '9'.

    if LT_DELETION    is not initial and
       ME->F_ABAP_CMD is initial.
      move C_UC_DELETE to ME->F_ABAP_CMD.
    endif.
    if ( LT_NODE      is not initial or
         LT_CLSTR     is not initial ) and
       ME->F_ABAP_CMD is initial.
      move C_UC_INSERT to ME->F_ABAP_CMD.
    endif.

*** Process Graphic (clears tables, once processed)
    ME->R_NETCHART->GRAPHIC_NETWORK_PBO( exporting ABAP_CMD       = ME->F_ABAP_CMD
                                                   CONFIRM        = 'X'
                                                   PROFILE        = ME->S_PROFILE
                                                   STAT           = ME->F_STAT
                                                   STATUS_TEXT    = SPACE
                                         changing  INODES         = ME->T_INODE
                                                   DELETIONS      = LT_DELETION
                                                   LINES          = LT_LINE
                                                   LVALS          = LT_LVAL
                                                   NODES          = LT_NODE
                                                   NVALS          = LT_NVAL
                                                   CLUSTERS       = LT_CLSTR
                                                   CVALS          = LT_CVAL ).
*** Initial Display Overview
    ME->DO_USER_COMMAND( IF_UCOMM = C_FCODE_OVERVIEW ).

    if ME->F_ABAP_CMD is not initial.
      ME->REFRESH_GRAPHIC( ).
    endif.

  endmethod.
  method SET_CURSOR.

    data:  LF_CURSOR type SCRFNAME.

    get cursor field LF_CURSOR.
    if LF_CURSOR is not initial.
      move LF_CURSOR to ME->F_CURSOR.
    endif.

  endmethod.
